(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["vendor"],{

/***/ "./node_modules/asciichart/asciichart.js":
/*!***********************************************!*\
  !*** ./node_modules/asciichart/asciichart.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n(function (exports) {\n  // control sequences for coloring\n  exports.black = \"\\x1b[30m\";\n  exports.red = \"\\x1b[31m\";\n  exports.green = \"\\x1b[32m\";\n  exports.yellow = \"\\x1b[33m\";\n  exports.blue = \"\\x1b[34m\";\n  exports.magenta = \"\\x1b[35m\";\n  exports.cyan = \"\\x1b[36m\";\n  exports.lightgray = \"\\x1b[37m\";\n  exports.default = \"\\x1b[39m\";\n  exports.darkgray = \"\\x1b[90m\";\n  exports.lightred = \"\\x1b[91m\";\n  exports.lightgreen = \"\\x1b[92m\";\n  exports.lightyellow = \"\\x1b[93m\";\n  exports.lightblue = \"\\x1b[94m\";\n  exports.lightmagenta = \"\\x1b[95m\";\n  exports.lightcyan = \"\\x1b[96m\";\n  exports.white = \"\\x1b[97m\";\n  exports.reset = \"\\x1b[0m\";\n\n  function colored(char, color) {\n    // do not color it if color is not specified\n    return color === undefined ? char : color + char + exports.reset;\n  }\n\n  exports.colored = colored;\n\n  exports.plot = function (series) {\n    var cfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\n    // this function takes oth one array and array of arrays\n    // if an array of numbers is passed it is transfored to\n    // an array of exactly one array with numbers\n    if (typeof series[0] == \"number\") {\n      series = [series];\n    }\n\n    cfg = typeof cfg !== 'undefined' ? cfg : {};\n    var min = typeof cfg.min !== 'undefined' ? cfg.min : series[0][0];\n    var max = typeof cfg.max !== 'undefined' ? cfg.max : series[0][0];\n\n    for (var j = 0; j < series.length; j++) {\n      for (var i = 0; i < series[j].length; i++) {\n        min = Math.min(min, series[j][i]);\n        max = Math.max(max, series[j][i]);\n      }\n    }\n\n    var defaultSymbols = ['┼', '┤', '╶', '╴', '─', '╰', '╭', '╮', '╯', '│'];\n    var range = Math.abs(max - min);\n    var offset = typeof cfg.offset !== 'undefined' ? cfg.offset : 3;\n    var padding = typeof cfg.padding !== 'undefined' ? cfg.padding : '           ';\n    var height = typeof cfg.height !== 'undefined' ? cfg.height : range;\n    var colors = typeof cfg.colors !== 'undefined' ? cfg.colors : [];\n    var ratio = range !== 0 ? height / range : 1;\n    var min2 = Math.round(min * ratio);\n    var max2 = Math.round(max * ratio);\n    var rows = Math.abs(max2 - min2);\n    var width = 0;\n\n    for (var _i = 0; _i < series.length; _i++) {\n      width = Math.max(width, series[_i].length);\n    }\n\n    width = width + offset;\n    var symbols = typeof cfg.symbols !== 'undefined' ? cfg.symbols : defaultSymbols;\n    var format = typeof cfg.format !== 'undefined' ? cfg.format : function (x) {\n      return (padding + x.toFixed(2)).slice(-padding.length);\n    };\n    var result = new Array(rows + 1); // empty space\n\n    for (var _i2 = 0; _i2 <= rows; _i2++) {\n      result[_i2] = new Array(width);\n\n      for (var _j = 0; _j < width; _j++) {\n        result[_i2][_j] = ' ';\n      }\n    }\n\n    for (var y = min2; y <= max2; ++y) {\n      // axis + labels\n      var label = format(rows > 0 ? max - (y - min2) * range / rows : y, y - min2);\n      result[y - min2][Math.max(offset - label.length, 0)] = label;\n      result[y - min2][offset - 1] = y == 0 ? symbols[0] : symbols[1];\n    }\n\n    for (var _j2 = 0; _j2 < series.length; _j2++) {\n      var currentColor = colors[_j2 % colors.length];\n      var y0 = Math.round(series[_j2][0] * ratio) - min2;\n      result[rows - y0][offset - 1] = colored(symbols[0], currentColor); // first value\n\n      for (var x = 0; x < series[_j2].length - 1; x++) {\n        // plot the line\n        var _y = Math.round(series[_j2][x + 0] * ratio) - min2;\n\n        var y1 = Math.round(series[_j2][x + 1] * ratio) - min2;\n\n        if (_y == y1) {\n          result[rows - _y][x + offset] = colored(symbols[4], currentColor);\n        } else {\n          result[rows - y1][x + offset] = colored(_y > y1 ? symbols[5] : symbols[6], currentColor);\n          result[rows - _y][x + offset] = colored(_y > y1 ? symbols[7] : symbols[8], currentColor);\n          var from = Math.min(_y, y1);\n          var to = Math.max(_y, y1);\n\n          for (var _y2 = from + 1; _y2 < to; _y2++) {\n            result[rows - _y2][x + offset] = colored(symbols[9], currentColor);\n          }\n        }\n      }\n    }\n\n    return result.map(function (x) {\n      return x.join('');\n    }).join('\\n');\n  };\n})( false ?\n/* istanbul ignore next */\nundefined : exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXNjaWljaGFydC9hc2NpaWNoYXJ0LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FzY2lpY2hhcnQvYXNjaWljaGFydC5qcz8xYjIyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4oZnVuY3Rpb24gKGV4cG9ydHMpIHtcblxuICAgIC8vIGNvbnRyb2wgc2VxdWVuY2VzIGZvciBjb2xvcmluZ1xuXG4gICAgZXhwb3J0cy5ibGFjayA9IFwiXFx4MWJbMzBtXCJcbiAgICBleHBvcnRzLnJlZCA9IFwiXFx4MWJbMzFtXCJcbiAgICBleHBvcnRzLmdyZWVuID0gXCJcXHgxYlszMm1cIlxuICAgIGV4cG9ydHMueWVsbG93ID0gXCJcXHgxYlszM21cIlxuICAgIGV4cG9ydHMuYmx1ZSA9IFwiXFx4MWJbMzRtXCJcbiAgICBleHBvcnRzLm1hZ2VudGEgPSBcIlxceDFiWzM1bVwiXG4gICAgZXhwb3J0cy5jeWFuID0gXCJcXHgxYlszNm1cIlxuICAgIGV4cG9ydHMubGlnaHRncmF5ID0gXCJcXHgxYlszN21cIlxuICAgIGV4cG9ydHMuZGVmYXVsdCA9IFwiXFx4MWJbMzltXCJcbiAgICBleHBvcnRzLmRhcmtncmF5ID0gXCJcXHgxYls5MG1cIlxuICAgIGV4cG9ydHMubGlnaHRyZWQgPSBcIlxceDFiWzkxbVwiXG4gICAgZXhwb3J0cy5saWdodGdyZWVuID0gXCJcXHgxYls5Mm1cIlxuICAgIGV4cG9ydHMubGlnaHR5ZWxsb3cgPSBcIlxceDFiWzkzbVwiXG4gICAgZXhwb3J0cy5saWdodGJsdWUgPSBcIlxceDFiWzk0bVwiXG4gICAgZXhwb3J0cy5saWdodG1hZ2VudGEgPSBcIlxceDFiWzk1bVwiXG4gICAgZXhwb3J0cy5saWdodGN5YW4gPSBcIlxceDFiWzk2bVwiXG4gICAgZXhwb3J0cy53aGl0ZSA9IFwiXFx4MWJbOTdtXCJcbiAgICBleHBvcnRzLnJlc2V0ID0gXCJcXHgxYlswbVwiXG5cbiAgICBmdW5jdGlvbiBjb2xvcmVkIChjaGFyLCBjb2xvcikge1xuICAgICAgICAvLyBkbyBub3QgY29sb3IgaXQgaWYgY29sb3IgaXMgbm90IHNwZWNpZmllZFxuICAgICAgICByZXR1cm4gKGNvbG9yID09PSB1bmRlZmluZWQpID8gY2hhciA6IChjb2xvciArIGNoYXIgKyBleHBvcnRzLnJlc2V0KVxuICAgIH1cblxuICAgIGV4cG9ydHMuY29sb3JlZCA9IGNvbG9yZWRcblxuICAgIGV4cG9ydHMucGxvdCA9IGZ1bmN0aW9uIChzZXJpZXMsIGNmZyA9IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyB0aGlzIGZ1bmN0aW9uIHRha2VzIG90aCBvbmUgYXJyYXkgYW5kIGFycmF5IG9mIGFycmF5c1xuICAgICAgICAvLyBpZiBhbiBhcnJheSBvZiBudW1iZXJzIGlzIHBhc3NlZCBpdCBpcyB0cmFuc2ZvcmVkIHRvXG4gICAgICAgIC8vIGFuIGFycmF5IG9mIGV4YWN0bHkgb25lIGFycmF5IHdpdGggbnVtYmVyc1xuICAgICAgICBpZiAodHlwZW9mKHNlcmllc1swXSkgPT0gXCJudW1iZXJcIil7XG4gICAgICAgICAgICBzZXJpZXMgPSBbc2VyaWVzXVxuICAgICAgICB9XG5cbiAgICAgICAgY2ZnID0gKHR5cGVvZiBjZmcgIT09ICd1bmRlZmluZWQnKSA/IGNmZyA6IHt9XG5cbiAgICAgICAgbGV0IG1pbiA9ICh0eXBlb2YgY2ZnLm1pbiAhPT0gJ3VuZGVmaW5lZCcpID8gY2ZnLm1pbiA6IHNlcmllc1swXVswXVxuICAgICAgICBsZXQgbWF4ID0gKHR5cGVvZiBjZmcubWF4ICE9PSAndW5kZWZpbmVkJykgPyBjZmcubWF4IDogc2VyaWVzWzBdWzBdXG5cbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzZXJpZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VyaWVzW2pdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbWluID0gTWF0aC5taW4obWluLCBzZXJpZXNbal1baV0pXG4gICAgICAgICAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBzZXJpZXNbal1baV0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZGVmYXVsdFN5bWJvbHMgPSBbICfilLwnLCAn4pSkJywgJ+KVticsICfilbQnLCAn4pSAJywgJ+KVsCcsICfila0nLCAn4pWuJywgJ+KVrycsICfilIInIF1cbiAgICAgICAgbGV0IHJhbmdlICAgPSBNYXRoLmFicyAobWF4IC0gbWluKVxuICAgICAgICBsZXQgb2Zmc2V0ICA9ICh0eXBlb2YgY2ZnLm9mZnNldCAgIT09ICd1bmRlZmluZWQnKSA/IGNmZy5vZmZzZXQgIDogM1xuICAgICAgICBsZXQgcGFkZGluZyA9ICh0eXBlb2YgY2ZnLnBhZGRpbmcgIT09ICd1bmRlZmluZWQnKSA/IGNmZy5wYWRkaW5nIDogJyAgICAgICAgICAgJ1xuICAgICAgICBsZXQgaGVpZ2h0ICA9ICh0eXBlb2YgY2ZnLmhlaWdodCAgIT09ICd1bmRlZmluZWQnKSA/IGNmZy5oZWlnaHQgIDogcmFuZ2VcbiAgICAgICAgbGV0IGNvbG9ycyAgPSAodHlwZW9mIGNmZy5jb2xvcnMgIT09ICd1bmRlZmluZWQnKSA/IGNmZy5jb2xvcnMgOiBbXVxuICAgICAgICBsZXQgcmF0aW8gICA9IHJhbmdlICE9PSAwID8gaGVpZ2h0IC8gcmFuZ2UgOiAxO1xuICAgICAgICBsZXQgbWluMiAgICA9IE1hdGgucm91bmQgKG1pbiAqIHJhdGlvKVxuICAgICAgICBsZXQgbWF4MiAgICA9IE1hdGgucm91bmQgKG1heCAqIHJhdGlvKVxuICAgICAgICBsZXQgcm93cyAgICA9IE1hdGguYWJzIChtYXgyIC0gbWluMilcbiAgICAgICAgbGV0IHdpZHRoID0gMFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgd2lkdGggPSBNYXRoLm1heCh3aWR0aCwgc2VyaWVzW2ldLmxlbmd0aClcbiAgICAgICAgfVxuICAgICAgICB3aWR0aCA9IHdpZHRoICsgb2Zmc2V0XG4gICAgICAgIGxldCBzeW1ib2xzID0gKHR5cGVvZiBjZmcuc3ltYm9scyAhPT0gJ3VuZGVmaW5lZCcpID8gY2ZnLnN5bWJvbHMgOiBkZWZhdWx0U3ltYm9sc1xuICAgICAgICBsZXQgZm9ybWF0ICA9ICh0eXBlb2YgY2ZnLmZvcm1hdCAhPT0gJ3VuZGVmaW5lZCcpID8gY2ZnLmZvcm1hdCA6IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gKHBhZGRpbmcgKyB4LnRvRml4ZWQgKDIpKS5zbGljZSAoLXBhZGRpbmcubGVuZ3RoKVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHJlc3VsdCA9IG5ldyBBcnJheSAocm93cyArIDEpIC8vIGVtcHR5IHNwYWNlXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IHJvd3M7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0W2ldID0gbmV3IEFycmF5ICh3aWR0aClcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgd2lkdGg7IGorKykge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtpXVtqXSA9ICcgJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHkgPSBtaW4yOyB5IDw9IG1heDI7ICsreSkgeyAvLyBheGlzICsgbGFiZWxzXG4gICAgICAgICAgICBsZXQgbGFiZWwgPSBmb3JtYXQgKHJvd3MgPiAwID8gbWF4IC0gKHkgLSBtaW4yKSAqIHJhbmdlIC8gcm93cyA6IHksIHkgLSBtaW4yKVxuICAgICAgICAgICAgcmVzdWx0W3kgLSBtaW4yXVtNYXRoLm1heCAob2Zmc2V0IC0gbGFiZWwubGVuZ3RoLCAwKV0gPSBsYWJlbFxuICAgICAgICAgICAgcmVzdWx0W3kgLSBtaW4yXVtvZmZzZXQgLSAxXSA9ICh5ID09IDApID8gc3ltYm9sc1swXSA6IHN5bWJvbHNbMV1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2VyaWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudENvbG9yID0gY29sb3JzW2ogJSBjb2xvcnMubGVuZ3RoXVxuICAgICAgICAgICAgbGV0IHkwID0gTWF0aC5yb3VuZCAoc2VyaWVzW2pdWzBdICogcmF0aW8pIC0gbWluMlxuICAgICAgICAgICAgcmVzdWx0W3Jvd3MgLSB5MF1bb2Zmc2V0IC0gMV0gPSBjb2xvcmVkKHN5bWJvbHNbMF0sIGN1cnJlbnRDb2xvcikgLy8gZmlyc3QgdmFsdWVcblxuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBzZXJpZXNbal0ubGVuZ3RoIC0gMTsgeCsrKSB7IC8vIHBsb3QgdGhlIGxpbmVcbiAgICAgICAgICAgICAgICBsZXQgeTAgPSBNYXRoLnJvdW5kIChzZXJpZXNbal1beCArIDBdICogcmF0aW8pIC0gbWluMlxuICAgICAgICAgICAgICAgIGxldCB5MSA9IE1hdGgucm91bmQgKHNlcmllc1tqXVt4ICsgMV0gKiByYXRpbykgLSBtaW4yXG4gICAgICAgICAgICAgICAgaWYgKHkwID09IHkxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtyb3dzIC0geTBdW3ggKyBvZmZzZXRdID0gY29sb3JlZChzeW1ib2xzWzRdLCBjdXJyZW50Q29sb3IpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3Jvd3MgLSB5MV1beCArIG9mZnNldF0gPSBjb2xvcmVkKCh5MCA+IHkxKSA/IHN5bWJvbHNbNV0gOiBzeW1ib2xzWzZdLCBjdXJyZW50Q29sb3IpXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtyb3dzIC0geTBdW3ggKyBvZmZzZXRdID0gY29sb3JlZCgoeTAgPiB5MSkgPyBzeW1ib2xzWzddIDogc3ltYm9sc1s4XSwgY3VycmVudENvbG9yKVxuICAgICAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IE1hdGgubWluICh5MCwgeTEpXG4gICAgICAgICAgICAgICAgICAgIGxldCB0byA9IE1hdGgubWF4ICh5MCwgeTEpXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHkgPSBmcm9tICsgMTsgeSA8IHRvOyB5KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtyb3dzIC0geV1beCArIG9mZnNldF0gPSBjb2xvcmVkKHN5bWJvbHNbOV0sIGN1cnJlbnRDb2xvcilcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0Lm1hcCAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguam9pbiAoJycpIH0pLmpvaW4gKCdcXG4nKVxuICAgIH1cblxufSkgKHR5cGVvZiBleHBvcnRzID09PSAndW5kZWZpbmVkJyA/IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHRoaXNbJ2FzY2lpY2hhcnQnXSA9IHt9IDogZXhwb3J0cyk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUFBO0FBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/asciichart/asciichart.js\n");

/***/ }),

/***/ "./node_modules/dompurify/dist/purify.js":
/*!***********************************************!*\
  !*** ./node_modules/dompurify/dist/purify.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof2(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof2(obj); }\n\n/*! @license DOMPurify | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.0.8/LICENSE */\n(function (global, factory) {\n  ( false ? undefined : _typeof2(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (undefined);\n})(this, function () {\n  'use strict';\n\n  function _toConsumableArray(arr) {\n    if (Array.isArray(arr)) {\n      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n        arr2[i] = arr[i];\n      }\n\n      return arr2;\n    } else {\n      return Array.from(arr);\n    }\n  }\n\n  var hasOwnProperty = Object.hasOwnProperty,\n      setPrototypeOf = Object.setPrototypeOf,\n      isFrozen = Object.isFrozen,\n      objectKeys = Object.keys;\n  var freeze = Object.freeze,\n      seal = Object.seal; // eslint-disable-line import/no-mutable-exports\n\n  var _ref = typeof Reflect !== 'undefined' && Reflect,\n      apply = _ref.apply,\n      construct = _ref.construct;\n\n  if (!apply) {\n    apply = function apply(fun, thisValue, args) {\n      return fun.apply(thisValue, args);\n    };\n  }\n\n  if (!freeze) {\n    freeze = function freeze(x) {\n      return x;\n    };\n  }\n\n  if (!seal) {\n    seal = function seal(x) {\n      return x;\n    };\n  }\n\n  if (!construct) {\n    construct = function construct(Func, args) {\n      return new (Function.prototype.bind.apply(Func, [null].concat(_toConsumableArray(args))))();\n    };\n  }\n\n  var arrayForEach = unapply(Array.prototype.forEach);\n  var arrayIndexOf = unapply(Array.prototype.indexOf);\n  var arrayJoin = unapply(Array.prototype.join);\n  var arrayPop = unapply(Array.prototype.pop);\n  var arrayPush = unapply(Array.prototype.push);\n  var arraySlice = unapply(Array.prototype.slice);\n  var stringToLowerCase = unapply(String.prototype.toLowerCase);\n  var stringMatch = unapply(String.prototype.match);\n  var stringReplace = unapply(String.prototype.replace);\n  var stringIndexOf = unapply(String.prototype.indexOf);\n  var stringTrim = unapply(String.prototype.trim);\n  var regExpTest = unapply(RegExp.prototype.test);\n  var regExpCreate = unconstruct(RegExp);\n  var typeErrorCreate = unconstruct(TypeError);\n\n  function unapply(func) {\n    return function (thisArg) {\n      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      return apply(func, thisArg, args);\n    };\n  }\n\n  function unconstruct(func) {\n    return function () {\n      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return construct(func, args);\n    };\n  }\n  /* Add properties to a lookup table */\n\n\n  function addToSet(set, array) {\n    if (setPrototypeOf) {\n      // Make 'in' and truthy checks like Boolean(set.constructor)\n      // independent of any properties defined on Object.prototype.\n      // Prevent prototype setters from intercepting set as a this value.\n      setPrototypeOf(set, null);\n    }\n\n    var l = array.length;\n\n    while (l--) {\n      var element = array[l];\n\n      if (typeof element === 'string') {\n        var lcElement = stringToLowerCase(element);\n\n        if (lcElement !== element) {\n          // Config presets (e.g. tags.js, attrs.js) are immutable.\n          if (!isFrozen(array)) {\n            array[l] = lcElement;\n          }\n\n          element = lcElement;\n        }\n      }\n\n      set[element] = true;\n    }\n\n    return set;\n  }\n  /* Shallow clone an object */\n\n\n  function clone(object) {\n    var newObject = {};\n    var property = void 0;\n\n    for (property in object) {\n      if (apply(hasOwnProperty, object, [property])) {\n        newObject[property] = object[property];\n      }\n    }\n\n    return newObject;\n  }\n\n  var html = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']); // SVG\n\n  var svg = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'audio', 'canvas', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'video', 'view', 'vkern']);\n  var svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']);\n  var mathMl = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover']);\n  var text = freeze(['#text']);\n  var html$1 = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns']);\n  var svg$1 = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'tabindex', 'targetx', 'targety', 'transform', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);\n  var mathMl$1 = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);\n  var xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']); // eslint-disable-next-line unicorn/better-regex\n\n  var MUSTACHE_EXPR = seal(/\\{\\{[\\s\\S]*|[\\s\\S]*\\}\\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode\n\n  var ERB_EXPR = seal(/<%[\\s\\S]*|[\\s\\S]*%>/gm);\n  var DATA_ATTR = seal(/^data-[\\-\\w.\\u00B7-\\uFFFF]/); // eslint-disable-line no-useless-escape\n\n  var ARIA_ATTR = seal(/^aria-[\\-\\w]+$/); // eslint-disable-line no-useless-escape\n\n  var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i // eslint-disable-line no-useless-escape\n  );\n  var IS_SCRIPT_OR_DATA = seal(/^(?:\\w+script|data):/i);\n  var ATTR_WHITESPACE = seal(/[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205f\\u3000]/g // eslint-disable-line no-control-regex\n  );\n\n  var _typeof = typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\" ? function (obj) {\n    return _typeof2(obj);\n  } : function (obj) {\n    return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n  };\n\n  function _toConsumableArray$1(arr) {\n    if (Array.isArray(arr)) {\n      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n        arr2[i] = arr[i];\n      }\n\n      return arr2;\n    } else {\n      return Array.from(arr);\n    }\n  }\n\n  var getGlobal = function getGlobal() {\n    return typeof window === 'undefined' ? null : window;\n  };\n  /**\n   * Creates a no-op policy for internal use only.\n   * Don't export this function outside this module!\n   * @param {?TrustedTypePolicyFactory} trustedTypes The policy factory.\n   * @param {Document} document The document object (to determine policy name suffix)\n   * @return {?TrustedTypePolicy} The policy created (or null, if Trusted Types\n   * are not supported).\n   */\n\n\n  var _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, document) {\n    if ((typeof trustedTypes === 'undefined' ? 'undefined' : _typeof(trustedTypes)) !== 'object' || typeof trustedTypes.createPolicy !== 'function') {\n      return null;\n    } // Allow the callers to control the unique policy name\n    // by adding a data-tt-policy-suffix to the script element with the DOMPurify.\n    // Policy creation with duplicate names throws in Trusted Types.\n\n\n    var suffix = null;\n    var ATTR_NAME = 'data-tt-policy-suffix';\n\n    if (document.currentScript && document.currentScript.hasAttribute(ATTR_NAME)) {\n      suffix = document.currentScript.getAttribute(ATTR_NAME);\n    }\n\n    var policyName = 'dompurify' + (suffix ? '#' + suffix : '');\n\n    try {\n      return trustedTypes.createPolicy(policyName, {\n        createHTML: function createHTML(html$$1) {\n          return html$$1;\n        }\n      });\n    } catch (_) {\n      // Policy creation failed (most likely another DOMPurify script has\n      // already run). Skip creating the policy, as this will only cause errors\n      // if TT are enforced.\n      console.warn('TrustedTypes policy ' + policyName + ' could not be created.');\n      return null;\n    }\n  };\n\n  function createDOMPurify() {\n    var window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();\n\n    var DOMPurify = function DOMPurify(root) {\n      return createDOMPurify(root);\n    };\n    /**\n     * Version label, exposed for easier checks\n     * if DOMPurify is up to date or not\n     */\n\n\n    DOMPurify.version = '2.0.12';\n    /**\n     * Array of elements that DOMPurify removed during sanitation.\n     * Empty if nothing was removed.\n     */\n\n    DOMPurify.removed = [];\n\n    if (!window || !window.document || window.document.nodeType !== 9) {\n      // Not running in a browser, provide a factory function\n      // so that you can pass your own Window\n      DOMPurify.isSupported = false;\n      return DOMPurify;\n    }\n\n    var originalDocument = window.document;\n    var removeTitle = false;\n    var document = window.document;\n    var DocumentFragment = window.DocumentFragment,\n        HTMLTemplateElement = window.HTMLTemplateElement,\n        Node = window.Node,\n        NodeFilter = window.NodeFilter,\n        _window$NamedNodeMap = window.NamedNodeMap,\n        NamedNodeMap = _window$NamedNodeMap === undefined ? window.NamedNodeMap || window.MozNamedAttrMap : _window$NamedNodeMap,\n        Text = window.Text,\n        Comment = window.Comment,\n        DOMParser = window.DOMParser,\n        trustedTypes = window.trustedTypes; // As per issue #47, the web-components registry is inherited by a\n    // new document created via createHTMLDocument. As per the spec\n    // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)\n    // a new empty registry is used when creating a template contents owner\n    // document, so we use that as our parent document to ensure nothing\n    // is inherited.\n\n    if (typeof HTMLTemplateElement === 'function') {\n      var template = document.createElement('template');\n\n      if (template.content && template.content.ownerDocument) {\n        document = template.content.ownerDocument;\n      }\n    }\n\n    var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);\n\n    var emptyHTML = trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML('') : '';\n    var _document = document,\n        implementation = _document.implementation,\n        createNodeIterator = _document.createNodeIterator,\n        getElementsByTagName = _document.getElementsByTagName,\n        createDocumentFragment = _document.createDocumentFragment;\n    var importNode = originalDocument.importNode;\n    var hooks = {};\n    /**\n     * Expose whether this browser supports running the full DOMPurify.\n     */\n\n    DOMPurify.isSupported = implementation && typeof implementation.createHTMLDocument !== 'undefined' && document.documentMode !== 9;\n    var MUSTACHE_EXPR$$1 = MUSTACHE_EXPR,\n        ERB_EXPR$$1 = ERB_EXPR,\n        DATA_ATTR$$1 = DATA_ATTR,\n        ARIA_ATTR$$1 = ARIA_ATTR,\n        IS_SCRIPT_OR_DATA$$1 = IS_SCRIPT_OR_DATA,\n        ATTR_WHITESPACE$$1 = ATTR_WHITESPACE;\n    var IS_ALLOWED_URI$$1 = IS_ALLOWED_URI;\n    /**\n     * We consider the elements and attributes below to be safe. Ideally\n     * don't add any new ones but feel free to remove unwanted ones.\n     */\n\n    /* allowed element names */\n\n    var ALLOWED_TAGS = null;\n    var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(html), _toConsumableArray$1(svg), _toConsumableArray$1(svgFilters), _toConsumableArray$1(mathMl), _toConsumableArray$1(text)));\n    /* Allowed attribute names */\n\n    var ALLOWED_ATTR = null;\n    var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray$1(html$1), _toConsumableArray$1(svg$1), _toConsumableArray$1(mathMl$1), _toConsumableArray$1(xml)));\n    /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */\n\n    var FORBID_TAGS = null;\n    /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */\n\n    var FORBID_ATTR = null;\n    /* Decide if ARIA attributes are okay */\n\n    var ALLOW_ARIA_ATTR = true;\n    /* Decide if custom data attributes are okay */\n\n    var ALLOW_DATA_ATTR = true;\n    /* Decide if unknown protocols are okay */\n\n    var ALLOW_UNKNOWN_PROTOCOLS = false;\n    /* Output should be safe for jQuery's $() factory? */\n\n    var SAFE_FOR_JQUERY = false;\n    /* Output should be safe for common template engines.\n     * This means, DOMPurify removes data attributes, mustaches and ERB\n     */\n\n    var SAFE_FOR_TEMPLATES = false;\n    /* Decide if document with <html>... should be returned */\n\n    var WHOLE_DOCUMENT = false;\n    /* Track whether config is already set on this instance of DOMPurify. */\n\n    var SET_CONFIG = false;\n    /* Decide if all elements (e.g. style, script) must be children of\n     * document.body. By default, browsers might move them to document.head */\n\n    var FORCE_BODY = false;\n    /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html\n     * string (or a TrustedHTML object if Trusted Types are supported).\n     * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead\n     */\n\n    var RETURN_DOM = false;\n    /* Decide if a DOM `DocumentFragment` should be returned, instead of a html\n     * string  (or a TrustedHTML object if Trusted Types are supported) */\n\n    var RETURN_DOM_FRAGMENT = false;\n    /* If `RETURN_DOM` or `RETURN_DOM_FRAGMENT` is enabled, decide if the returned DOM\n     * `Node` is imported into the current `Document`. If this flag is not enabled the\n     * `Node` will belong (its ownerDocument) to a fresh `HTMLDocument`, created by\n     * DOMPurify. */\n\n    var RETURN_DOM_IMPORT = false;\n    /* Try to return a Trusted Type object instead of a string, retrun a string in\n     * case Trusted Types are not supported  */\n\n    var RETURN_TRUSTED_TYPE = false;\n    /* Output should be free from DOM clobbering attacks? */\n\n    var SANITIZE_DOM = true;\n    /* Keep element content when removing element? */\n\n    var KEEP_CONTENT = true;\n    /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead\n     * of importing it into a new Document and returning a sanitized copy */\n\n    var IN_PLACE = false;\n    /* Allow usage of profiles like html, svg and mathMl */\n\n    var USE_PROFILES = {};\n    /* Tags to ignore content of when KEEP_CONTENT is true */\n\n    var FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);\n    /* Tags that are safe for data: URIs */\n\n    var DATA_URI_TAGS = null;\n    var DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);\n    /* Attributes safe for values like \"javascript:\" */\n\n    var URI_SAFE_ATTRIBUTES = null;\n    var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'summary', 'title', 'value', 'style', 'xmlns']);\n    /* Keep a reference to config to pass to hooks */\n\n    var CONFIG = null;\n    /* Ideally, do not touch anything below this line */\n\n    /* ______________________________________________ */\n\n    var formElement = document.createElement('form');\n    /**\n     * _parseConfig\n     *\n     * @param  {Object} cfg optional config literal\n     */\n    // eslint-disable-next-line complexity\n\n    var _parseConfig = function _parseConfig(cfg) {\n      if (CONFIG && CONFIG === cfg) {\n        return;\n      }\n      /* Shield configuration object from tampering */\n\n\n      if (!cfg || (typeof cfg === 'undefined' ? 'undefined' : _typeof(cfg)) !== 'object') {\n        cfg = {};\n      }\n      /* Set configuration parameters */\n\n\n      ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;\n      ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;\n      URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR) : DEFAULT_URI_SAFE_ATTRIBUTES;\n      DATA_URI_TAGS = 'ADD_DATA_URI_TAGS' in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS) : DEFAULT_DATA_URI_TAGS;\n      FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS) : {};\n      FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR) : {};\n      USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;\n      ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true\n\n      ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true\n\n      ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false\n\n      SAFE_FOR_JQUERY = cfg.SAFE_FOR_JQUERY || false; // Default false\n\n      SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false\n\n      WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false\n\n      RETURN_DOM = cfg.RETURN_DOM || false; // Default false\n\n      RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false\n\n      RETURN_DOM_IMPORT = cfg.RETURN_DOM_IMPORT || false; // Default false\n\n      RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false\n\n      FORCE_BODY = cfg.FORCE_BODY || false; // Default false\n\n      SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true\n\n      KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true\n\n      IN_PLACE = cfg.IN_PLACE || false; // Default false\n\n      IS_ALLOWED_URI$$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$$1;\n\n      if (SAFE_FOR_TEMPLATES) {\n        ALLOW_DATA_ATTR = false;\n      }\n\n      if (RETURN_DOM_FRAGMENT) {\n        RETURN_DOM = true;\n      }\n      /* Parse profile info */\n\n\n      if (USE_PROFILES) {\n        ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(text)));\n        ALLOWED_ATTR = [];\n\n        if (USE_PROFILES.html === true) {\n          addToSet(ALLOWED_TAGS, html);\n          addToSet(ALLOWED_ATTR, html$1);\n        }\n\n        if (USE_PROFILES.svg === true) {\n          addToSet(ALLOWED_TAGS, svg);\n          addToSet(ALLOWED_ATTR, svg$1);\n          addToSet(ALLOWED_ATTR, xml);\n        }\n\n        if (USE_PROFILES.svgFilters === true) {\n          addToSet(ALLOWED_TAGS, svgFilters);\n          addToSet(ALLOWED_ATTR, svg$1);\n          addToSet(ALLOWED_ATTR, xml);\n        }\n\n        if (USE_PROFILES.mathMl === true) {\n          addToSet(ALLOWED_TAGS, mathMl);\n          addToSet(ALLOWED_ATTR, mathMl$1);\n          addToSet(ALLOWED_ATTR, xml);\n        }\n      }\n      /* Merge configuration parameters */\n\n\n      if (cfg.ADD_TAGS) {\n        if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {\n          ALLOWED_TAGS = clone(ALLOWED_TAGS);\n        }\n\n        addToSet(ALLOWED_TAGS, cfg.ADD_TAGS);\n      }\n\n      if (cfg.ADD_ATTR) {\n        if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {\n          ALLOWED_ATTR = clone(ALLOWED_ATTR);\n        }\n\n        addToSet(ALLOWED_ATTR, cfg.ADD_ATTR);\n      }\n\n      if (cfg.ADD_URI_SAFE_ATTR) {\n        addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);\n      }\n      /* Add #text in case KEEP_CONTENT is set to true */\n\n\n      if (KEEP_CONTENT) {\n        ALLOWED_TAGS['#text'] = true;\n      }\n      /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */\n\n\n      if (WHOLE_DOCUMENT) {\n        addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);\n      }\n      /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */\n\n\n      if (ALLOWED_TAGS.table) {\n        addToSet(ALLOWED_TAGS, ['tbody']);\n        delete FORBID_TAGS.tbody;\n      } // Prevent further manipulation of configuration.\n      // Not available in IE8, Safari 5, etc.\n\n\n      if (freeze) {\n        freeze(cfg);\n      }\n\n      CONFIG = cfg;\n    };\n    /**\n     * _forceRemove\n     *\n     * @param  {Node} node a DOM node\n     */\n\n\n    var _forceRemove = function _forceRemove(node) {\n      arrayPush(DOMPurify.removed, {\n        element: node\n      });\n\n      try {\n        // eslint-disable-next-line unicorn/prefer-node-remove\n        node.parentNode.removeChild(node);\n      } catch (_) {\n        node.outerHTML = emptyHTML;\n      }\n    };\n    /**\n     * _removeAttribute\n     *\n     * @param  {String} name an Attribute name\n     * @param  {Node} node a DOM node\n     */\n\n\n    var _removeAttribute = function _removeAttribute(name, node) {\n      try {\n        arrayPush(DOMPurify.removed, {\n          attribute: node.getAttributeNode(name),\n          from: node\n        });\n      } catch (_) {\n        arrayPush(DOMPurify.removed, {\n          attribute: null,\n          from: node\n        });\n      }\n\n      node.removeAttribute(name);\n    };\n    /**\n     * _initDocument\n     *\n     * @param  {String} dirty a string of dirty markup\n     * @return {Document} a DOM, filled with the dirty markup\n     */\n\n\n    var _initDocument = function _initDocument(dirty) {\n      /* Create a HTML document */\n      var doc = void 0;\n      var leadingWhitespace = void 0;\n\n      if (FORCE_BODY) {\n        dirty = '<remove></remove>' + dirty;\n      } else {\n        /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */\n        var matches = stringMatch(dirty, /^[\\r\\n\\t ]+/);\n        leadingWhitespace = matches && matches[0];\n      }\n\n      var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;\n      /* Use the DOMParser API by default, fallback later if needs be */\n\n      try {\n        doc = new DOMParser().parseFromString(dirtyPayload, 'text/html');\n      } catch (_) {}\n      /* Remove title to fix a mXSS bug in older MS Edge */\n\n\n      if (removeTitle) {\n        addToSet(FORBID_TAGS, ['title']);\n      }\n      /* Use createHTMLDocument in case DOMParser is not available */\n\n\n      if (!doc || !doc.documentElement) {\n        doc = implementation.createHTMLDocument('');\n        var _doc = doc,\n            body = _doc.body;\n        body.parentNode.removeChild(body.parentNode.firstElementChild);\n        body.outerHTML = dirtyPayload;\n      }\n\n      if (dirty && leadingWhitespace) {\n        doc.body.insertBefore(document.createTextNode(leadingWhitespace), doc.body.childNodes[0] || null);\n      }\n      /* Work on whole document or just its body */\n\n\n      return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];\n    };\n    /* Here we test for a broken feature in Edge that might cause mXSS */\n\n\n    if (DOMPurify.isSupported) {\n      (function () {\n        try {\n          var doc = _initDocument('<x/><title>&lt;/title&gt;&lt;img&gt;');\n\n          if (regExpTest(/<\\/title/, doc.querySelector('title').innerHTML)) {\n            removeTitle = true;\n          }\n        } catch (_) {}\n      })();\n    }\n    /**\n     * _createIterator\n     *\n     * @param  {Document} root document/fragment to create iterator for\n     * @return {Iterator} iterator instance\n     */\n\n\n    var _createIterator = function _createIterator(root) {\n      return createNodeIterator.call(root.ownerDocument || root, root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, function () {\n        return NodeFilter.FILTER_ACCEPT;\n      }, false);\n    };\n    /**\n     * _isClobbered\n     *\n     * @param  {Node} elm element to check for clobbering attacks\n     * @return {Boolean} true if clobbered, false if safe\n     */\n\n\n    var _isClobbered = function _isClobbered(elm) {\n      if (elm instanceof Text || elm instanceof Comment) {\n        return false;\n      }\n\n      if (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string') {\n        return true;\n      }\n\n      return false;\n    };\n    /**\n     * _isNode\n     *\n     * @param  {Node} obj object to check whether it's a DOM node\n     * @return {Boolean} true is object is a DOM node\n     */\n\n\n    var _isNode = function _isNode(object) {\n      return (typeof Node === 'undefined' ? 'undefined' : _typeof(Node)) === 'object' ? object instanceof Node : object && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string';\n    };\n    /**\n     * _executeHook\n     * Execute user configurable hooks\n     *\n     * @param  {String} entryPoint  Name of the hook's entry point\n     * @param  {Node} currentNode node to work on with the hook\n     * @param  {Object} data additional hook parameters\n     */\n\n\n    var _executeHook = function _executeHook(entryPoint, currentNode, data) {\n      if (!hooks[entryPoint]) {\n        return;\n      }\n\n      arrayForEach(hooks[entryPoint], function (hook) {\n        hook.call(DOMPurify, currentNode, data, CONFIG);\n      });\n    };\n    /**\n     * _sanitizeElements\n     *\n     * @protect nodeName\n     * @protect textContent\n     * @protect removeChild\n     *\n     * @param   {Node} currentNode to check for permission to exist\n     * @return  {Boolean} true if node was killed, false if left alive\n     */\n    // eslint-disable-next-line complexity\n\n\n    var _sanitizeElements = function _sanitizeElements(currentNode) {\n      var content = void 0;\n      /* Execute a hook if present */\n\n      _executeHook('beforeSanitizeElements', currentNode, null);\n      /* Check if element is clobbered or can clobber */\n\n\n      if (_isClobbered(currentNode)) {\n        _forceRemove(currentNode);\n\n        return true;\n      }\n      /* Now let's check the element's type and name */\n\n\n      var tagName = stringToLowerCase(currentNode.nodeName);\n      /* Execute a hook if present */\n\n      _executeHook('uponSanitizeElement', currentNode, {\n        tagName: tagName,\n        allowedTags: ALLOWED_TAGS\n      });\n      /* Take care of an mXSS pattern using p, br inside svg, math */\n\n\n      if ((tagName === 'svg' || tagName === 'math') && currentNode.querySelectorAll('p, br').length !== 0) {\n        _forceRemove(currentNode);\n\n        return true;\n      }\n      /* Remove element if anything forbids its presence */\n\n\n      if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n        /* Keep content except for bad-listed elements */\n        if (KEEP_CONTENT && !FORBID_CONTENTS[tagName] && typeof currentNode.insertAdjacentHTML === 'function') {\n          try {\n            var htmlToInsert = currentNode.innerHTML;\n            currentNode.insertAdjacentHTML('AfterEnd', trustedTypesPolicy ? trustedTypesPolicy.createHTML(htmlToInsert) : htmlToInsert);\n          } catch (_) {}\n        }\n\n        _forceRemove(currentNode);\n\n        return true;\n      }\n      /* Remove in case a noscript/noembed XSS is suspected */\n\n\n      if (tagName === 'noscript' && regExpTest(/<\\/noscript/i, currentNode.innerHTML)) {\n        _forceRemove(currentNode);\n\n        return true;\n      }\n\n      if (tagName === 'noembed' && regExpTest(/<\\/noembed/i, currentNode.innerHTML)) {\n        _forceRemove(currentNode);\n\n        return true;\n      }\n      /* Convert markup to cover jQuery behavior */\n\n\n      if (SAFE_FOR_JQUERY && !currentNode.firstElementChild && (!currentNode.content || !currentNode.content.firstElementChild) && regExpTest(/</g, currentNode.textContent)) {\n        arrayPush(DOMPurify.removed, {\n          element: currentNode.cloneNode()\n        });\n\n        if (currentNode.innerHTML) {\n          currentNode.innerHTML = stringReplace(currentNode.innerHTML, /</g, '&lt;');\n        } else {\n          currentNode.innerHTML = stringReplace(currentNode.textContent, /</g, '&lt;');\n        }\n      }\n      /* Sanitize element content to be template-safe */\n\n\n      if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {\n        /* Get the element's text content */\n        content = currentNode.textContent;\n        content = stringReplace(content, MUSTACHE_EXPR$$1, ' ');\n        content = stringReplace(content, ERB_EXPR$$1, ' ');\n\n        if (currentNode.textContent !== content) {\n          arrayPush(DOMPurify.removed, {\n            element: currentNode.cloneNode()\n          });\n          currentNode.textContent = content;\n        }\n      }\n      /* Execute a hook if present */\n\n\n      _executeHook('afterSanitizeElements', currentNode, null);\n\n      return false;\n    };\n    /**\n     * _isValidAttribute\n     *\n     * @param  {string} lcTag Lowercase tag name of containing element.\n     * @param  {string} lcName Lowercase attribute name.\n     * @param  {string} value Attribute value.\n     * @return {Boolean} Returns true if `value` is valid, otherwise false.\n     */\n    // eslint-disable-next-line complexity\n\n\n    var _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {\n      /* Make sure attribute cannot clobber */\n      if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {\n        return false;\n      }\n      /* Allow valid data-* attributes: At least one character after \"-\"\n          (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)\n          XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)\n          We don't need to check the value; it's always URI safe. */\n\n\n      if (ALLOW_DATA_ATTR && regExpTest(DATA_ATTR$$1, lcName)) ;else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$$1, lcName)) ;else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {\n        return false;\n        /* Check value is safe. First, is attr inert? If so, is safe */\n      } else if (URI_SAFE_ATTRIBUTES[lcName]) ;else if (regExpTest(IS_ALLOWED_URI$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) ;else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ;else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) ;else if (!value) ;else {\n        return false;\n      }\n      return true;\n    };\n    /**\n     * _sanitizeAttributes\n     *\n     * @protect attributes\n     * @protect nodeName\n     * @protect removeAttribute\n     * @protect setAttribute\n     *\n     * @param  {Node} currentNode to sanitize\n     */\n    // eslint-disable-next-line complexity\n\n\n    var _sanitizeAttributes = function _sanitizeAttributes(currentNode) {\n      var attr = void 0;\n      var value = void 0;\n      var lcName = void 0;\n      var idAttr = void 0;\n      var l = void 0;\n      /* Execute a hook if present */\n\n      _executeHook('beforeSanitizeAttributes', currentNode, null);\n\n      var attributes = currentNode.attributes;\n      /* Check if we have attributes; if not we might have a text node */\n\n      if (!attributes) {\n        return;\n      }\n\n      var hookEvent = {\n        attrName: '',\n        attrValue: '',\n        keepAttr: true,\n        allowedAttributes: ALLOWED_ATTR\n      };\n      l = attributes.length;\n      /* Go backwards over all attributes; safely remove bad ones */\n\n      while (l--) {\n        attr = attributes[l];\n        var _attr = attr,\n            name = _attr.name,\n            namespaceURI = _attr.namespaceURI;\n        value = stringTrim(attr.value);\n        lcName = stringToLowerCase(name);\n        /* Execute a hook if present */\n\n        hookEvent.attrName = lcName;\n        hookEvent.attrValue = value;\n        hookEvent.keepAttr = true;\n        hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set\n\n        _executeHook('uponSanitizeAttribute', currentNode, hookEvent);\n\n        value = hookEvent.attrValue;\n        /* Did the hooks approve of the attribute? */\n\n        if (hookEvent.forceKeepAttr) {\n          continue;\n        }\n        /* Remove attribute */\n        // Safari (iOS + Mac), last tested v8.0.5, crashes if you try to\n        // remove a \"name\" attribute from an <img> tag that has an \"id\"\n        // attribute at the time.\n\n\n        if (lcName === 'name' && currentNode.nodeName === 'IMG' && attributes.id) {\n          idAttr = attributes.id;\n          attributes = arraySlice(attributes, []);\n\n          _removeAttribute('id', currentNode);\n\n          _removeAttribute(name, currentNode);\n\n          if (arrayIndexOf(attributes, idAttr) > l) {\n            currentNode.setAttribute('id', idAttr.value);\n          }\n        } else if ( // This works around a bug in Safari, where input[type=file]\n        // cannot be dynamically set after type has been removed\n        currentNode.nodeName === 'INPUT' && lcName === 'type' && value === 'file' && hookEvent.keepAttr && (ALLOWED_ATTR[lcName] || !FORBID_ATTR[lcName])) {\n          continue;\n        } else {\n          // This avoids a crash in Safari v9.0 with double-ids.\n          // The trick is to first set the id to be empty and then to\n          // remove the attribute\n          if (name === 'id') {\n            currentNode.setAttribute(name, '');\n          }\n\n          _removeAttribute(name, currentNode);\n        }\n        /* Did the hooks approve of the attribute? */\n\n\n        if (!hookEvent.keepAttr) {\n          continue;\n        }\n        /* Work around a security issue in jQuery 3.0 */\n\n\n        if (SAFE_FOR_JQUERY && regExpTest(/\\/>/i, value)) {\n          _removeAttribute(name, currentNode);\n\n          continue;\n        }\n        /* Take care of an mXSS pattern using namespace switches */\n\n\n        if (regExpTest(/svg|math/i, currentNode.namespaceURI) && regExpTest(regExpCreate('</(' + arrayJoin(objectKeys(FORBID_CONTENTS), '|') + ')', 'i'), value)) {\n          _removeAttribute(name, currentNode);\n\n          continue;\n        }\n        /* Sanitize attribute content to be template-safe */\n\n\n        if (SAFE_FOR_TEMPLATES) {\n          value = stringReplace(value, MUSTACHE_EXPR$$1, ' ');\n          value = stringReplace(value, ERB_EXPR$$1, ' ');\n        }\n        /* Is `value` valid for this attribute? */\n\n\n        var lcTag = currentNode.nodeName.toLowerCase();\n\n        if (!_isValidAttribute(lcTag, lcName, value)) {\n          continue;\n        }\n        /* Handle invalid data-* attribute set by try-catching it */\n\n\n        try {\n          if (namespaceURI) {\n            currentNode.setAttributeNS(namespaceURI, name, value);\n          } else {\n            /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. \"x-schema\". */\n            currentNode.setAttribute(name, value);\n          }\n\n          arrayPop(DOMPurify.removed);\n        } catch (_) {}\n      }\n      /* Execute a hook if present */\n\n\n      _executeHook('afterSanitizeAttributes', currentNode, null);\n    };\n    /**\n     * _sanitizeShadowDOM\n     *\n     * @param  {DocumentFragment} fragment to iterate over recursively\n     */\n\n\n    var _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {\n      var shadowNode = void 0;\n\n      var shadowIterator = _createIterator(fragment);\n      /* Execute a hook if present */\n\n\n      _executeHook('beforeSanitizeShadowDOM', fragment, null);\n\n      while (shadowNode = shadowIterator.nextNode()) {\n        /* Execute a hook if present */\n        _executeHook('uponSanitizeShadowNode', shadowNode, null);\n        /* Sanitize tags and elements */\n\n\n        if (_sanitizeElements(shadowNode)) {\n          continue;\n        }\n        /* Deep shadow DOM detected */\n\n\n        if (shadowNode.content instanceof DocumentFragment) {\n          _sanitizeShadowDOM(shadowNode.content);\n        }\n        /* Check attributes, sanitize if necessary */\n\n\n        _sanitizeAttributes(shadowNode);\n      }\n      /* Execute a hook if present */\n\n\n      _executeHook('afterSanitizeShadowDOM', fragment, null);\n    };\n    /**\n     * Sanitize\n     * Public method providing core sanitation functionality\n     *\n     * @param {String|Node} dirty string or DOM node\n     * @param {Object} configuration object\n     */\n    // eslint-disable-next-line complexity\n\n\n    DOMPurify.sanitize = function (dirty, cfg) {\n      var body = void 0;\n      var importedNode = void 0;\n      var currentNode = void 0;\n      var oldNode = void 0;\n      var returnNode = void 0;\n      /* Make sure we have a string to sanitize.\n        DO NOT return early, as this will return the wrong type if\n        the user has requested a DOM object rather than a string */\n\n      if (!dirty) {\n        dirty = '<!-->';\n      }\n      /* Stringify, in case dirty is an object */\n\n\n      if (typeof dirty !== 'string' && !_isNode(dirty)) {\n        // eslint-disable-next-line no-negated-condition\n        if (typeof dirty.toString !== 'function') {\n          throw typeErrorCreate('toString is not a function');\n        } else {\n          dirty = dirty.toString();\n\n          if (typeof dirty !== 'string') {\n            throw typeErrorCreate('dirty is not a string, aborting');\n          }\n        }\n      }\n      /* Check we can run. Otherwise fall back or ignore */\n\n\n      if (!DOMPurify.isSupported) {\n        if (_typeof(window.toStaticHTML) === 'object' || typeof window.toStaticHTML === 'function') {\n          if (typeof dirty === 'string') {\n            return window.toStaticHTML(dirty);\n          }\n\n          if (_isNode(dirty)) {\n            return window.toStaticHTML(dirty.outerHTML);\n          }\n        }\n\n        return dirty;\n      }\n      /* Assign config vars */\n\n\n      if (!SET_CONFIG) {\n        _parseConfig(cfg);\n      }\n      /* Clean up removed elements */\n\n\n      DOMPurify.removed = [];\n      /* Check if dirty is correctly typed for IN_PLACE */\n\n      if (typeof dirty === 'string') {\n        IN_PLACE = false;\n      }\n\n      if (IN_PLACE) ;else if (dirty instanceof Node) {\n        /* If dirty is a DOM element, append to an empty document to avoid\n           elements being stripped by the parser */\n        body = _initDocument('<!-->');\n        importedNode = body.ownerDocument.importNode(dirty, true);\n\n        if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {\n          /* Node is already a body, use as is */\n          body = importedNode;\n        } else if (importedNode.nodeName === 'HTML') {\n          body = importedNode;\n        } else {\n          // eslint-disable-next-line unicorn/prefer-node-append\n          body.appendChild(importedNode);\n        }\n      } else {\n        /* Exit directly if we have nothing to do */\n        if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // eslint-disable-next-line unicorn/prefer-includes\n        dirty.indexOf('<') === -1) {\n          return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;\n        }\n        /* Initialize the document to work on */\n\n\n        body = _initDocument(dirty);\n        /* Check we have a DOM node from the data */\n\n        if (!body) {\n          return RETURN_DOM ? null : emptyHTML;\n        }\n      }\n      /* Remove first element node (ours) if FORCE_BODY is set */\n\n      if (body && FORCE_BODY) {\n        _forceRemove(body.firstChild);\n      }\n      /* Get node iterator */\n\n\n      var nodeIterator = _createIterator(IN_PLACE ? dirty : body);\n      /* Now start iterating over the created document */\n\n\n      while (currentNode = nodeIterator.nextNode()) {\n        /* Fix IE's strange behavior with manipulated textNodes #89 */\n        if (currentNode.nodeType === 3 && currentNode === oldNode) {\n          continue;\n        }\n        /* Sanitize tags and elements */\n\n\n        if (_sanitizeElements(currentNode)) {\n          continue;\n        }\n        /* Shadow DOM detected, sanitize it */\n\n\n        if (currentNode.content instanceof DocumentFragment) {\n          _sanitizeShadowDOM(currentNode.content);\n        }\n        /* Check attributes, sanitize if necessary */\n\n\n        _sanitizeAttributes(currentNode);\n\n        oldNode = currentNode;\n      }\n\n      oldNode = null;\n      /* If we sanitized `dirty` in-place, return it. */\n\n      if (IN_PLACE) {\n        return dirty;\n      }\n      /* Return sanitized string or DOM */\n\n\n      if (RETURN_DOM) {\n        if (RETURN_DOM_FRAGMENT) {\n          returnNode = createDocumentFragment.call(body.ownerDocument);\n\n          while (body.firstChild) {\n            // eslint-disable-next-line unicorn/prefer-node-append\n            returnNode.appendChild(body.firstChild);\n          }\n        } else {\n          returnNode = body;\n        }\n\n        if (RETURN_DOM_IMPORT) {\n          /*\n            AdoptNode() is not used because internal state is not reset\n            (e.g. the past names map of a HTMLFormElement), this is safe\n            in theory but we would rather not risk another attack vector.\n            The state that is cloned by importNode() is explicitly defined\n            by the specs.\n          */\n          returnNode = importNode.call(originalDocument, returnNode, true);\n        }\n\n        return returnNode;\n      }\n\n      var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;\n      /* Sanitize final string template-safe */\n\n      if (SAFE_FOR_TEMPLATES) {\n        serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$$1, ' ');\n        serializedHTML = stringReplace(serializedHTML, ERB_EXPR$$1, ' ');\n      }\n\n      return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;\n    };\n    /**\n     * Public method to set the configuration once\n     * setConfig\n     *\n     * @param {Object} cfg configuration object\n     */\n\n\n    DOMPurify.setConfig = function (cfg) {\n      _parseConfig(cfg);\n\n      SET_CONFIG = true;\n    };\n    /**\n     * Public method to remove the configuration\n     * clearConfig\n     *\n     */\n\n\n    DOMPurify.clearConfig = function () {\n      CONFIG = null;\n      SET_CONFIG = false;\n    };\n    /**\n     * Public method to check if an attribute value is valid.\n     * Uses last set config, if any. Otherwise, uses config defaults.\n     * isValidAttribute\n     *\n     * @param  {string} tag Tag name of containing element.\n     * @param  {string} attr Attribute name.\n     * @param  {string} value Attribute value.\n     * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.\n     */\n\n\n    DOMPurify.isValidAttribute = function (tag, attr, value) {\n      /* Initialize shared config vars if necessary. */\n      if (!CONFIG) {\n        _parseConfig({});\n      }\n\n      var lcTag = stringToLowerCase(tag);\n      var lcName = stringToLowerCase(attr);\n      return _isValidAttribute(lcTag, lcName, value);\n    };\n    /**\n     * AddHook\n     * Public method to add DOMPurify hooks\n     *\n     * @param {String} entryPoint entry point for the hook to add\n     * @param {Function} hookFunction function to execute\n     */\n\n\n    DOMPurify.addHook = function (entryPoint, hookFunction) {\n      if (typeof hookFunction !== 'function') {\n        return;\n      }\n\n      hooks[entryPoint] = hooks[entryPoint] || [];\n      arrayPush(hooks[entryPoint], hookFunction);\n    };\n    /**\n     * RemoveHook\n     * Public method to remove a DOMPurify hook at a given entryPoint\n     * (pops it from the stack of hooks if more are present)\n     *\n     * @param {String} entryPoint entry point for the hook to remove\n     */\n\n\n    DOMPurify.removeHook = function (entryPoint) {\n      if (hooks[entryPoint]) {\n        arrayPop(hooks[entryPoint]);\n      }\n    };\n    /**\n     * RemoveHooks\n     * Public method to remove all DOMPurify hooks at a given entryPoint\n     *\n     * @param  {String} entryPoint entry point for the hooks to remove\n     */\n\n\n    DOMPurify.removeHooks = function (entryPoint) {\n      if (hooks[entryPoint]) {\n        hooks[entryPoint] = [];\n      }\n    };\n    /**\n     * RemoveAllHooks\n     * Public method to remove all DOMPurify hooks\n     *\n     */\n\n\n    DOMPurify.removeAllHooks = function () {\n      hooks = {};\n    };\n\n    return DOMPurify;\n  }\n\n  var purify = createDOMPurify();\n  return purify;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZG9tcHVyaWZ5L2Rpc3QvcHVyaWZ5LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL3NyYy91dGlscy5qcz81MGYzIiwid2VicGFjazovLy8uLi9zcmMvdGFncy5qcz8yNWYxIiwid2VicGFjazovLy8uLi9zcmMvYXR0cnMuanM/MWM1MCIsIndlYnBhY2s6Ly8vLi4vc3JjL3JlZ2V4cC5qcz9kOWZkIiwid2VicGFjazovLy8uLi9zcmMvcHVyaWZ5LmpzP2M1NjciXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgeyBoYXNPd25Qcm9wZXJ0eSwgc2V0UHJvdG90eXBlT2YsIGlzRnJvemVuLCBrZXlzOiBvYmplY3RLZXlzIH0gPSBPYmplY3Q7XG5cbmxldCB7IGZyZWV6ZSwgc2VhbCB9ID0gT2JqZWN0OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGltcG9ydC9uby1tdXRhYmxlLWV4cG9ydHNcbmxldCB7IGFwcGx5LCBjb25zdHJ1Y3QgfSA9IHR5cGVvZiBSZWZsZWN0ICE9PSAndW5kZWZpbmVkJyAmJiBSZWZsZWN0O1xuXG5pZiAoIWFwcGx5KSB7XG4gIGFwcGx5ID0gZnVuY3Rpb24gKGZ1biwgdGhpc1ZhbHVlLCBhcmdzKSB7XG4gICAgcmV0dXJuIGZ1bi5hcHBseSh0aGlzVmFsdWUsIGFyZ3MpO1xuICB9O1xufVxuXG5pZiAoIWZyZWV6ZSkge1xuICBmcmVlemUgPSBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufVxuXG5pZiAoIXNlYWwpIHtcbiAgc2VhbCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIHg7XG4gIH07XG59XG5cbmlmICghY29uc3RydWN0KSB7XG4gIGNvbnN0cnVjdCA9IGZ1bmN0aW9uIChGdW5jLCBhcmdzKSB7XG4gICAgcmV0dXJuIG5ldyBGdW5jKC4uLmFyZ3MpO1xuICB9O1xufVxuXG5jb25zdCBhcnJheUZvckVhY2ggPSB1bmFwcGx5KEFycmF5LnByb3RvdHlwZS5mb3JFYWNoKTtcbmNvbnN0IGFycmF5SW5kZXhPZiA9IHVuYXBwbHkoQXJyYXkucHJvdG90eXBlLmluZGV4T2YpO1xuY29uc3QgYXJyYXlKb2luID0gdW5hcHBseShBcnJheS5wcm90b3R5cGUuam9pbik7XG5jb25zdCBhcnJheVBvcCA9IHVuYXBwbHkoQXJyYXkucHJvdG90eXBlLnBvcCk7XG5jb25zdCBhcnJheVB1c2ggPSB1bmFwcGx5KEFycmF5LnByb3RvdHlwZS5wdXNoKTtcbmNvbnN0IGFycmF5U2xpY2UgPSB1bmFwcGx5KEFycmF5LnByb3RvdHlwZS5zbGljZSk7XG5cbmNvbnN0IHN0cmluZ1RvTG93ZXJDYXNlID0gdW5hcHBseShTdHJpbmcucHJvdG90eXBlLnRvTG93ZXJDYXNlKTtcbmNvbnN0IHN0cmluZ01hdGNoID0gdW5hcHBseShTdHJpbmcucHJvdG90eXBlLm1hdGNoKTtcbmNvbnN0IHN0cmluZ1JlcGxhY2UgPSB1bmFwcGx5KFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSk7XG5jb25zdCBzdHJpbmdJbmRleE9mID0gdW5hcHBseShTdHJpbmcucHJvdG90eXBlLmluZGV4T2YpO1xuY29uc3Qgc3RyaW5nVHJpbSA9IHVuYXBwbHkoU3RyaW5nLnByb3RvdHlwZS50cmltKTtcblxuY29uc3QgcmVnRXhwVGVzdCA9IHVuYXBwbHkoUmVnRXhwLnByb3RvdHlwZS50ZXN0KTtcbmNvbnN0IHJlZ0V4cENyZWF0ZSA9IHVuY29uc3RydWN0KFJlZ0V4cCk7XG5cbmNvbnN0IHR5cGVFcnJvckNyZWF0ZSA9IHVuY29uc3RydWN0KFR5cGVFcnJvcik7XG5cbmV4cG9ydCBmdW5jdGlvbiB1bmFwcGx5KGZ1bmMpIHtcbiAgcmV0dXJuICh0aGlzQXJnLCAuLi5hcmdzKSA9PiBhcHBseShmdW5jLCB0aGlzQXJnLCBhcmdzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVuY29uc3RydWN0KGZ1bmMpIHtcbiAgcmV0dXJuICguLi5hcmdzKSA9PiBjb25zdHJ1Y3QoZnVuYywgYXJncyk7XG59XG5cbi8qIEFkZCBwcm9wZXJ0aWVzIHRvIGEgbG9va3VwIHRhYmxlICovXG5leHBvcnQgZnVuY3Rpb24gYWRkVG9TZXQoc2V0LCBhcnJheSkge1xuICBpZiAoc2V0UHJvdG90eXBlT2YpIHtcbiAgICAvLyBNYWtlICdpbicgYW5kIHRydXRoeSBjaGVja3MgbGlrZSBCb29sZWFuKHNldC5jb25zdHJ1Y3RvcilcbiAgICAvLyBpbmRlcGVuZGVudCBvZiBhbnkgcHJvcGVydGllcyBkZWZpbmVkIG9uIE9iamVjdC5wcm90b3R5cGUuXG4gICAgLy8gUHJldmVudCBwcm90b3R5cGUgc2V0dGVycyBmcm9tIGludGVyY2VwdGluZyBzZXQgYXMgYSB0aGlzIHZhbHVlLlxuICAgIHNldFByb3RvdHlwZU9mKHNldCwgbnVsbCk7XG4gIH1cblxuICBsZXQgbCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGwtLSkge1xuICAgIGxldCBlbGVtZW50ID0gYXJyYXlbbF07XG4gICAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgbGNFbGVtZW50ID0gc3RyaW5nVG9Mb3dlckNhc2UoZWxlbWVudCk7XG4gICAgICBpZiAobGNFbGVtZW50ICE9PSBlbGVtZW50KSB7XG4gICAgICAgIC8vIENvbmZpZyBwcmVzZXRzIChlLmcuIHRhZ3MuanMsIGF0dHJzLmpzKSBhcmUgaW1tdXRhYmxlLlxuICAgICAgICBpZiAoIWlzRnJvemVuKGFycmF5KSkge1xuICAgICAgICAgIGFycmF5W2xdID0gbGNFbGVtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlbWVudCA9IGxjRWxlbWVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRbZWxlbWVudF0gPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHNldDtcbn1cblxuLyogU2hhbGxvdyBjbG9uZSBhbiBvYmplY3QgKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZShvYmplY3QpIHtcbiAgY29uc3QgbmV3T2JqZWN0ID0ge307XG5cbiAgbGV0IHByb3BlcnR5O1xuICBmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xuICAgIGlmIChhcHBseShoYXNPd25Qcm9wZXJ0eSwgb2JqZWN0LCBbcHJvcGVydHldKSkge1xuICAgICAgbmV3T2JqZWN0W3Byb3BlcnR5XSA9IG9iamVjdFtwcm9wZXJ0eV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld09iamVjdDtcbn1cblxuZXhwb3J0IHtcbiAgLy8gQXJyYXlcbiAgYXJyYXlGb3JFYWNoLFxuICBhcnJheUluZGV4T2YsXG4gIGFycmF5Sm9pbixcbiAgYXJyYXlQb3AsXG4gIGFycmF5UHVzaCxcbiAgYXJyYXlTbGljZSxcbiAgLy8gT2JqZWN0XG4gIGZyZWV6ZSxcbiAgaGFzT3duUHJvcGVydHksXG4gIGlzRnJvemVuLFxuICBvYmplY3RLZXlzLFxuICBzZXRQcm90b3R5cGVPZixcbiAgc2VhbCxcbiAgLy8gUmVnRXhwXG4gIHJlZ0V4cENyZWF0ZSxcbiAgcmVnRXhwVGVzdCxcbiAgLy8gU3RyaW5nXG4gIHN0cmluZ0luZGV4T2YsXG4gIHN0cmluZ01hdGNoLFxuICBzdHJpbmdSZXBsYWNlLFxuICBzdHJpbmdUb0xvd2VyQ2FzZSxcbiAgc3RyaW5nVHJpbSxcbiAgLy8gRXJyb3JzXG4gIHR5cGVFcnJvckNyZWF0ZSxcbn07XG4iLCJpbXBvcnQgeyBmcmVlemUgfSBmcm9tICcuL3V0aWxzJztcblxuZXhwb3J0IGNvbnN0IGh0bWwgPSBmcmVlemUoW1xuICAnYScsXG4gICdhYmJyJyxcbiAgJ2Fjcm9ueW0nLFxuICAnYWRkcmVzcycsXG4gICdhcmVhJyxcbiAgJ2FydGljbGUnLFxuICAnYXNpZGUnLFxuICAnYXVkaW8nLFxuICAnYicsXG4gICdiZGknLFxuICAnYmRvJyxcbiAgJ2JpZycsXG4gICdibGluaycsXG4gICdibG9ja3F1b3RlJyxcbiAgJ2JvZHknLFxuICAnYnInLFxuICAnYnV0dG9uJyxcbiAgJ2NhbnZhcycsXG4gICdjYXB0aW9uJyxcbiAgJ2NlbnRlcicsXG4gICdjaXRlJyxcbiAgJ2NvZGUnLFxuICAnY29sJyxcbiAgJ2NvbGdyb3VwJyxcbiAgJ2NvbnRlbnQnLFxuICAnZGF0YScsXG4gICdkYXRhbGlzdCcsXG4gICdkZCcsXG4gICdkZWNvcmF0b3InLFxuICAnZGVsJyxcbiAgJ2RldGFpbHMnLFxuICAnZGZuJyxcbiAgJ2RpcicsXG4gICdkaXYnLFxuICAnZGwnLFxuICAnZHQnLFxuICAnZWxlbWVudCcsXG4gICdlbScsXG4gICdmaWVsZHNldCcsXG4gICdmaWdjYXB0aW9uJyxcbiAgJ2ZpZ3VyZScsXG4gICdmb250JyxcbiAgJ2Zvb3RlcicsXG4gICdmb3JtJyxcbiAgJ2gxJyxcbiAgJ2gyJyxcbiAgJ2gzJyxcbiAgJ2g0JyxcbiAgJ2g1JyxcbiAgJ2g2JyxcbiAgJ2hlYWQnLFxuICAnaGVhZGVyJyxcbiAgJ2hncm91cCcsXG4gICdocicsXG4gICdodG1sJyxcbiAgJ2knLFxuICAnaW1nJyxcbiAgJ2lucHV0JyxcbiAgJ2lucycsXG4gICdrYmQnLFxuICAnbGFiZWwnLFxuICAnbGVnZW5kJyxcbiAgJ2xpJyxcbiAgJ21haW4nLFxuICAnbWFwJyxcbiAgJ21hcmsnLFxuICAnbWFycXVlZScsXG4gICdtZW51JyxcbiAgJ21lbnVpdGVtJyxcbiAgJ21ldGVyJyxcbiAgJ25hdicsXG4gICdub2JyJyxcbiAgJ29sJyxcbiAgJ29wdGdyb3VwJyxcbiAgJ29wdGlvbicsXG4gICdvdXRwdXQnLFxuICAncCcsXG4gICdwaWN0dXJlJyxcbiAgJ3ByZScsXG4gICdwcm9ncmVzcycsXG4gICdxJyxcbiAgJ3JwJyxcbiAgJ3J0JyxcbiAgJ3J1YnknLFxuICAncycsXG4gICdzYW1wJyxcbiAgJ3NlY3Rpb24nLFxuICAnc2VsZWN0JyxcbiAgJ3NoYWRvdycsXG4gICdzbWFsbCcsXG4gICdzb3VyY2UnLFxuICAnc3BhY2VyJyxcbiAgJ3NwYW4nLFxuICAnc3RyaWtlJyxcbiAgJ3N0cm9uZycsXG4gICdzdHlsZScsXG4gICdzdWInLFxuICAnc3VtbWFyeScsXG4gICdzdXAnLFxuICAndGFibGUnLFxuICAndGJvZHknLFxuICAndGQnLFxuICAndGVtcGxhdGUnLFxuICAndGV4dGFyZWEnLFxuICAndGZvb3QnLFxuICAndGgnLFxuICAndGhlYWQnLFxuICAndGltZScsXG4gICd0cicsXG4gICd0cmFjaycsXG4gICd0dCcsXG4gICd1JyxcbiAgJ3VsJyxcbiAgJ3ZhcicsXG4gICd2aWRlbycsXG4gICd3YnInLFxuXSk7XG5cbi8vIFNWR1xuZXhwb3J0IGNvbnN0IHN2ZyA9IGZyZWV6ZShbXG4gICdzdmcnLFxuICAnYScsXG4gICdhbHRnbHlwaCcsXG4gICdhbHRnbHlwaGRlZicsXG4gICdhbHRnbHlwaGl0ZW0nLFxuICAnYW5pbWF0ZWNvbG9yJyxcbiAgJ2FuaW1hdGVtb3Rpb24nLFxuICAnYW5pbWF0ZXRyYW5zZm9ybScsXG4gICdhdWRpbycsXG4gICdjYW52YXMnLFxuICAnY2lyY2xlJyxcbiAgJ2NsaXBwYXRoJyxcbiAgJ2RlZnMnLFxuICAnZGVzYycsXG4gICdlbGxpcHNlJyxcbiAgJ2ZpbHRlcicsXG4gICdmb250JyxcbiAgJ2cnLFxuICAnZ2x5cGgnLFxuICAnZ2x5cGhyZWYnLFxuICAnaGtlcm4nLFxuICAnaW1hZ2UnLFxuICAnbGluZScsXG4gICdsaW5lYXJncmFkaWVudCcsXG4gICdtYXJrZXInLFxuICAnbWFzaycsXG4gICdtZXRhZGF0YScsXG4gICdtcGF0aCcsXG4gICdwYXRoJyxcbiAgJ3BhdHRlcm4nLFxuICAncG9seWdvbicsXG4gICdwb2x5bGluZScsXG4gICdyYWRpYWxncmFkaWVudCcsXG4gICdyZWN0JyxcbiAgJ3N0b3AnLFxuICAnc3R5bGUnLFxuICAnc3dpdGNoJyxcbiAgJ3N5bWJvbCcsXG4gICd0ZXh0JyxcbiAgJ3RleHRwYXRoJyxcbiAgJ3RpdGxlJyxcbiAgJ3RyZWYnLFxuICAndHNwYW4nLFxuICAndmlkZW8nLFxuICAndmlldycsXG4gICd2a2VybicsXG5dKTtcblxuZXhwb3J0IGNvbnN0IHN2Z0ZpbHRlcnMgPSBmcmVlemUoW1xuICAnZmVCbGVuZCcsXG4gICdmZUNvbG9yTWF0cml4JyxcbiAgJ2ZlQ29tcG9uZW50VHJhbnNmZXInLFxuICAnZmVDb21wb3NpdGUnLFxuICAnZmVDb252b2x2ZU1hdHJpeCcsXG4gICdmZURpZmZ1c2VMaWdodGluZycsXG4gICdmZURpc3BsYWNlbWVudE1hcCcsXG4gICdmZURpc3RhbnRMaWdodCcsXG4gICdmZUZsb29kJyxcbiAgJ2ZlRnVuY0EnLFxuICAnZmVGdW5jQicsXG4gICdmZUZ1bmNHJyxcbiAgJ2ZlRnVuY1InLFxuICAnZmVHYXVzc2lhbkJsdXInLFxuICAnZmVNZXJnZScsXG4gICdmZU1lcmdlTm9kZScsXG4gICdmZU1vcnBob2xvZ3knLFxuICAnZmVPZmZzZXQnLFxuICAnZmVQb2ludExpZ2h0JyxcbiAgJ2ZlU3BlY3VsYXJMaWdodGluZycsXG4gICdmZVNwb3RMaWdodCcsXG4gICdmZVRpbGUnLFxuICAnZmVUdXJidWxlbmNlJyxcbl0pO1xuXG5leHBvcnQgY29uc3QgbWF0aE1sID0gZnJlZXplKFtcbiAgJ21hdGgnLFxuICAnbWVuY2xvc2UnLFxuICAnbWVycm9yJyxcbiAgJ21mZW5jZWQnLFxuICAnbWZyYWMnLFxuICAnbWdseXBoJyxcbiAgJ21pJyxcbiAgJ21sYWJlbGVkdHInLFxuICAnbW11bHRpc2NyaXB0cycsXG4gICdtbicsXG4gICdtbycsXG4gICdtb3ZlcicsXG4gICdtcGFkZGVkJyxcbiAgJ21waGFudG9tJyxcbiAgJ21yb290JyxcbiAgJ21yb3cnLFxuICAnbXMnLFxuICAnbXNwYWNlJyxcbiAgJ21zcXJ0JyxcbiAgJ21zdHlsZScsXG4gICdtc3ViJyxcbiAgJ21zdXAnLFxuICAnbXN1YnN1cCcsXG4gICdtdGFibGUnLFxuICAnbXRkJyxcbiAgJ210ZXh0JyxcbiAgJ210cicsXG4gICdtdW5kZXInLFxuICAnbXVuZGVyb3ZlcicsXG5dKTtcblxuZXhwb3J0IGNvbnN0IHRleHQgPSBmcmVlemUoWycjdGV4dCddKTtcbiIsImltcG9ydCB7IGZyZWV6ZSB9IGZyb20gJy4vdXRpbHMnO1xuXG5leHBvcnQgY29uc3QgaHRtbCA9IGZyZWV6ZShbXG4gICdhY2NlcHQnLFxuICAnYWN0aW9uJyxcbiAgJ2FsaWduJyxcbiAgJ2FsdCcsXG4gICdhdXRvY2FwaXRhbGl6ZScsXG4gICdhdXRvY29tcGxldGUnLFxuICAnYXV0b3BpY3R1cmVpbnBpY3R1cmUnLFxuICAnYXV0b3BsYXknLFxuICAnYmFja2dyb3VuZCcsXG4gICdiZ2NvbG9yJyxcbiAgJ2JvcmRlcicsXG4gICdjYXB0dXJlJyxcbiAgJ2NlbGxwYWRkaW5nJyxcbiAgJ2NlbGxzcGFjaW5nJyxcbiAgJ2NoZWNrZWQnLFxuICAnY2l0ZScsXG4gICdjbGFzcycsXG4gICdjbGVhcicsXG4gICdjb2xvcicsXG4gICdjb2xzJyxcbiAgJ2NvbHNwYW4nLFxuICAnY29udHJvbHMnLFxuICAnY29udHJvbHNsaXN0JyxcbiAgJ2Nvb3JkcycsXG4gICdjcm9zc29yaWdpbicsXG4gICdkYXRldGltZScsXG4gICdkZWNvZGluZycsXG4gICdkZWZhdWx0JyxcbiAgJ2RpcicsXG4gICdkaXNhYmxlZCcsXG4gICdkaXNhYmxlcGljdHVyZWlucGljdHVyZScsXG4gICdkaXNhYmxlcmVtb3RlcGxheWJhY2snLFxuICAnZG93bmxvYWQnLFxuICAnZHJhZ2dhYmxlJyxcbiAgJ2VuY3R5cGUnLFxuICAnZW50ZXJrZXloaW50JyxcbiAgJ2ZhY2UnLFxuICAnZm9yJyxcbiAgJ2hlYWRlcnMnLFxuICAnaGVpZ2h0JyxcbiAgJ2hpZGRlbicsXG4gICdoaWdoJyxcbiAgJ2hyZWYnLFxuICAnaHJlZmxhbmcnLFxuICAnaWQnLFxuICAnaW5wdXRtb2RlJyxcbiAgJ2ludGVncml0eScsXG4gICdpc21hcCcsXG4gICdraW5kJyxcbiAgJ2xhYmVsJyxcbiAgJ2xhbmcnLFxuICAnbGlzdCcsXG4gICdsb2FkaW5nJyxcbiAgJ2xvb3AnLFxuICAnbG93JyxcbiAgJ21heCcsXG4gICdtYXhsZW5ndGgnLFxuICAnbWVkaWEnLFxuICAnbWV0aG9kJyxcbiAgJ21pbicsXG4gICdtaW5sZW5ndGgnLFxuICAnbXVsdGlwbGUnLFxuICAnbXV0ZWQnLFxuICAnbmFtZScsXG4gICdub3NoYWRlJyxcbiAgJ25vdmFsaWRhdGUnLFxuICAnbm93cmFwJyxcbiAgJ29wZW4nLFxuICAnb3B0aW11bScsXG4gICdwYXR0ZXJuJyxcbiAgJ3BsYWNlaG9sZGVyJyxcbiAgJ3BsYXlzaW5saW5lJyxcbiAgJ3Bvc3RlcicsXG4gICdwcmVsb2FkJyxcbiAgJ3B1YmRhdGUnLFxuICAncmFkaW9ncm91cCcsXG4gICdyZWFkb25seScsXG4gICdyZWwnLFxuICAncmVxdWlyZWQnLFxuICAncmV2JyxcbiAgJ3JldmVyc2VkJyxcbiAgJ3JvbGUnLFxuICAncm93cycsXG4gICdyb3dzcGFuJyxcbiAgJ3NwZWxsY2hlY2snLFxuICAnc2NvcGUnLFxuICAnc2VsZWN0ZWQnLFxuICAnc2hhcGUnLFxuICAnc2l6ZScsXG4gICdzaXplcycsXG4gICdzcGFuJyxcbiAgJ3NyY2xhbmcnLFxuICAnc3RhcnQnLFxuICAnc3JjJyxcbiAgJ3NyY3NldCcsXG4gICdzdGVwJyxcbiAgJ3N0eWxlJyxcbiAgJ3N1bW1hcnknLFxuICAndGFiaW5kZXgnLFxuICAndGl0bGUnLFxuICAndHJhbnNsYXRlJyxcbiAgJ3R5cGUnLFxuICAndXNlbWFwJyxcbiAgJ3ZhbGlnbicsXG4gICd2YWx1ZScsXG4gICd3aWR0aCcsXG4gICd4bWxucycsXG5dKTtcblxuZXhwb3J0IGNvbnN0IHN2ZyA9IGZyZWV6ZShbXG4gICdhY2NlbnQtaGVpZ2h0JyxcbiAgJ2FjY3VtdWxhdGUnLFxuICAnYWRkaXRpdmUnLFxuICAnYWxpZ25tZW50LWJhc2VsaW5lJyxcbiAgJ2FzY2VudCcsXG4gICdhdHRyaWJ1dGVuYW1lJyxcbiAgJ2F0dHJpYnV0ZXR5cGUnLFxuICAnYXppbXV0aCcsXG4gICdiYXNlZnJlcXVlbmN5JyxcbiAgJ2Jhc2VsaW5lLXNoaWZ0JyxcbiAgJ2JlZ2luJyxcbiAgJ2JpYXMnLFxuICAnYnknLFxuICAnY2xhc3MnLFxuICAnY2xpcCcsXG4gICdjbGlwLXBhdGgnLFxuICAnY2xpcC1ydWxlJyxcbiAgJ2NvbG9yJyxcbiAgJ2NvbG9yLWludGVycG9sYXRpb24nLFxuICAnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJyxcbiAgJ2NvbG9yLXByb2ZpbGUnLFxuICAnY29sb3ItcmVuZGVyaW5nJyxcbiAgJ2N4JyxcbiAgJ2N5JyxcbiAgJ2QnLFxuICAnZHgnLFxuICAnZHknLFxuICAnZGlmZnVzZWNvbnN0YW50JyxcbiAgJ2RpcmVjdGlvbicsXG4gICdkaXNwbGF5JyxcbiAgJ2Rpdmlzb3InLFxuICAnZHVyJyxcbiAgJ2VkZ2Vtb2RlJyxcbiAgJ2VsZXZhdGlvbicsXG4gICdlbmQnLFxuICAnZmlsbCcsXG4gICdmaWxsLW9wYWNpdHknLFxuICAnZmlsbC1ydWxlJyxcbiAgJ2ZpbHRlcicsXG4gICdmaWx0ZXJ1bml0cycsXG4gICdmbG9vZC1jb2xvcicsXG4gICdmbG9vZC1vcGFjaXR5JyxcbiAgJ2ZvbnQtZmFtaWx5JyxcbiAgJ2ZvbnQtc2l6ZScsXG4gICdmb250LXNpemUtYWRqdXN0JyxcbiAgJ2ZvbnQtc3RyZXRjaCcsXG4gICdmb250LXN0eWxlJyxcbiAgJ2ZvbnQtdmFyaWFudCcsXG4gICdmb250LXdlaWdodCcsXG4gICdmeCcsXG4gICdmeScsXG4gICdnMScsXG4gICdnMicsXG4gICdnbHlwaC1uYW1lJyxcbiAgJ2dseXBocmVmJyxcbiAgJ2dyYWRpZW50dW5pdHMnLFxuICAnZ3JhZGllbnR0cmFuc2Zvcm0nLFxuICAnaGVpZ2h0JyxcbiAgJ2hyZWYnLFxuICAnaWQnLFxuICAnaW1hZ2UtcmVuZGVyaW5nJyxcbiAgJ2luJyxcbiAgJ2luMicsXG4gICdrJyxcbiAgJ2sxJyxcbiAgJ2syJyxcbiAgJ2szJyxcbiAgJ2s0JyxcbiAgJ2tlcm5pbmcnLFxuICAna2V5cG9pbnRzJyxcbiAgJ2tleXNwbGluZXMnLFxuICAna2V5dGltZXMnLFxuICAnbGFuZycsXG4gICdsZW5ndGhhZGp1c3QnLFxuICAnbGV0dGVyLXNwYWNpbmcnLFxuICAna2VybmVsbWF0cml4JyxcbiAgJ2tlcm5lbHVuaXRsZW5ndGgnLFxuICAnbGlnaHRpbmctY29sb3InLFxuICAnbG9jYWwnLFxuICAnbWFya2VyLWVuZCcsXG4gICdtYXJrZXItbWlkJyxcbiAgJ21hcmtlci1zdGFydCcsXG4gICdtYXJrZXJoZWlnaHQnLFxuICAnbWFya2VydW5pdHMnLFxuICAnbWFya2Vyd2lkdGgnLFxuICAnbWFza2NvbnRlbnR1bml0cycsXG4gICdtYXNrdW5pdHMnLFxuICAnbWF4JyxcbiAgJ21hc2snLFxuICAnbWVkaWEnLFxuICAnbWV0aG9kJyxcbiAgJ21vZGUnLFxuICAnbWluJyxcbiAgJ25hbWUnLFxuICAnbnVtb2N0YXZlcycsXG4gICdvZmZzZXQnLFxuICAnb3BlcmF0b3InLFxuICAnb3BhY2l0eScsXG4gICdvcmRlcicsXG4gICdvcmllbnQnLFxuICAnb3JpZW50YXRpb24nLFxuICAnb3JpZ2luJyxcbiAgJ292ZXJmbG93JyxcbiAgJ3BhaW50LW9yZGVyJyxcbiAgJ3BhdGgnLFxuICAncGF0aGxlbmd0aCcsXG4gICdwYXR0ZXJuY29udGVudHVuaXRzJyxcbiAgJ3BhdHRlcm50cmFuc2Zvcm0nLFxuICAncGF0dGVybnVuaXRzJyxcbiAgJ3BvaW50cycsXG4gICdwcmVzZXJ2ZWFscGhhJyxcbiAgJ3ByZXNlcnZlYXNwZWN0cmF0aW8nLFxuICAncHJpbWl0aXZldW5pdHMnLFxuICAncicsXG4gICdyeCcsXG4gICdyeScsXG4gICdyYWRpdXMnLFxuICAncmVmeCcsXG4gICdyZWZ5JyxcbiAgJ3JlcGVhdGNvdW50JyxcbiAgJ3JlcGVhdGR1cicsXG4gICdyZXN0YXJ0JyxcbiAgJ3Jlc3VsdCcsXG4gICdyb3RhdGUnLFxuICAnc2NhbGUnLFxuICAnc2VlZCcsXG4gICdzaGFwZS1yZW5kZXJpbmcnLFxuICAnc3BlY3VsYXJjb25zdGFudCcsXG4gICdzcGVjdWxhcmV4cG9uZW50JyxcbiAgJ3NwcmVhZG1ldGhvZCcsXG4gICdzdGFydG9mZnNldCcsXG4gICdzdGRkZXZpYXRpb24nLFxuICAnc3RpdGNodGlsZXMnLFxuICAnc3RvcC1jb2xvcicsXG4gICdzdG9wLW9wYWNpdHknLFxuICAnc3Ryb2tlLWRhc2hhcnJheScsXG4gICdzdHJva2UtZGFzaG9mZnNldCcsXG4gICdzdHJva2UtbGluZWNhcCcsXG4gICdzdHJva2UtbGluZWpvaW4nLFxuICAnc3Ryb2tlLW1pdGVybGltaXQnLFxuICAnc3Ryb2tlLW9wYWNpdHknLFxuICAnc3Ryb2tlJyxcbiAgJ3N0cm9rZS13aWR0aCcsXG4gICdzdHlsZScsXG4gICdzdXJmYWNlc2NhbGUnLFxuICAndGFiaW5kZXgnLFxuICAndGFyZ2V0eCcsXG4gICd0YXJnZXR5JyxcbiAgJ3RyYW5zZm9ybScsXG4gICd0ZXh0LWFuY2hvcicsXG4gICd0ZXh0LWRlY29yYXRpb24nLFxuICAndGV4dC1yZW5kZXJpbmcnLFxuICAndGV4dGxlbmd0aCcsXG4gICd0eXBlJyxcbiAgJ3UxJyxcbiAgJ3UyJyxcbiAgJ3VuaWNvZGUnLFxuICAndmFsdWVzJyxcbiAgJ3ZpZXdib3gnLFxuICAndmlzaWJpbGl0eScsXG4gICd2ZXJzaW9uJyxcbiAgJ3ZlcnQtYWR2LXknLFxuICAndmVydC1vcmlnaW4teCcsXG4gICd2ZXJ0LW9yaWdpbi15JyxcbiAgJ3dpZHRoJyxcbiAgJ3dvcmQtc3BhY2luZycsXG4gICd3cmFwJyxcbiAgJ3dyaXRpbmctbW9kZScsXG4gICd4Y2hhbm5lbHNlbGVjdG9yJyxcbiAgJ3ljaGFubmVsc2VsZWN0b3InLFxuICAneCcsXG4gICd4MScsXG4gICd4MicsXG4gICd4bWxucycsXG4gICd5JyxcbiAgJ3kxJyxcbiAgJ3kyJyxcbiAgJ3onLFxuICAnem9vbWFuZHBhbicsXG5dKTtcblxuZXhwb3J0IGNvbnN0IG1hdGhNbCA9IGZyZWV6ZShbXG4gICdhY2NlbnQnLFxuICAnYWNjZW50dW5kZXInLFxuICAnYWxpZ24nLFxuICAnYmV2ZWxsZWQnLFxuICAnY2xvc2UnLFxuICAnY29sdW1uc2FsaWduJyxcbiAgJ2NvbHVtbmxpbmVzJyxcbiAgJ2NvbHVtbnNwYW4nLFxuICAnZGVub21hbGlnbicsXG4gICdkZXB0aCcsXG4gICdkaXInLFxuICAnZGlzcGxheScsXG4gICdkaXNwbGF5c3R5bGUnLFxuICAnZW5jb2RpbmcnLFxuICAnZmVuY2UnLFxuICAnZnJhbWUnLFxuICAnaGVpZ2h0JyxcbiAgJ2hyZWYnLFxuICAnaWQnLFxuICAnbGFyZ2VvcCcsXG4gICdsZW5ndGgnLFxuICAnbGluZXRoaWNrbmVzcycsXG4gICdsc3BhY2UnLFxuICAnbHF1b3RlJyxcbiAgJ21hdGhiYWNrZ3JvdW5kJyxcbiAgJ21hdGhjb2xvcicsXG4gICdtYXRoc2l6ZScsXG4gICdtYXRodmFyaWFudCcsXG4gICdtYXhzaXplJyxcbiAgJ21pbnNpemUnLFxuICAnbW92YWJsZWxpbWl0cycsXG4gICdub3RhdGlvbicsXG4gICdudW1hbGlnbicsXG4gICdvcGVuJyxcbiAgJ3Jvd2FsaWduJyxcbiAgJ3Jvd2xpbmVzJyxcbiAgJ3Jvd3NwYWNpbmcnLFxuICAncm93c3BhbicsXG4gICdyc3BhY2UnLFxuICAncnF1b3RlJyxcbiAgJ3NjcmlwdGxldmVsJyxcbiAgJ3NjcmlwdG1pbnNpemUnLFxuICAnc2NyaXB0c2l6ZW11bHRpcGxpZXInLFxuICAnc2VsZWN0aW9uJyxcbiAgJ3NlcGFyYXRvcicsXG4gICdzZXBhcmF0b3JzJyxcbiAgJ3N0cmV0Y2h5JyxcbiAgJ3N1YnNjcmlwdHNoaWZ0JyxcbiAgJ3N1cHNjcmlwdHNoaWZ0JyxcbiAgJ3N5bW1ldHJpYycsXG4gICd2b2Zmc2V0JyxcbiAgJ3dpZHRoJyxcbiAgJ3htbG5zJyxcbl0pO1xuXG5leHBvcnQgY29uc3QgeG1sID0gZnJlZXplKFtcbiAgJ3hsaW5rOmhyZWYnLFxuICAneG1sOmlkJyxcbiAgJ3hsaW5rOnRpdGxlJyxcbiAgJ3htbDpzcGFjZScsXG4gICd4bWxuczp4bGluaycsXG5dKTtcbiIsImltcG9ydCB7IHNlYWwgfSBmcm9tICcuL3V0aWxzJztcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHVuaWNvcm4vYmV0dGVyLXJlZ2V4XG5leHBvcnQgY29uc3QgTVVTVEFDSEVfRVhQUiA9IHNlYWwoL1xce1xce1tcXHNcXFNdKnxbXFxzXFxTXSpcXH1cXH0vZ20pOyAvLyBTcGVjaWZ5IHRlbXBsYXRlIGRldGVjdGlvbiByZWdleCBmb3IgU0FGRV9GT1JfVEVNUExBVEVTIG1vZGVcbmV4cG9ydCBjb25zdCBFUkJfRVhQUiA9IHNlYWwoLzwlW1xcc1xcU10qfFtcXHNcXFNdKiU+L2dtKTtcbmV4cG9ydCBjb25zdCBEQVRBX0FUVFIgPSBzZWFsKC9eZGF0YS1bXFwtXFx3LlxcdTAwQjctXFx1RkZGRl0vKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11c2VsZXNzLWVzY2FwZVxuZXhwb3J0IGNvbnN0IEFSSUFfQVRUUiA9IHNlYWwoL15hcmlhLVtcXC1cXHddKyQvKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11c2VsZXNzLWVzY2FwZVxuZXhwb3J0IGNvbnN0IElTX0FMTE9XRURfVVJJID0gc2VhbChcbiAgL14oPzooPzooPzpmfGh0KXRwcz98bWFpbHRvfHRlbHxjYWxsdG98Y2lkfHhtcHApOnxbXmEtel18W2EteisuXFwtXSsoPzpbXmEteisuXFwtOl18JCkpL2kgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11c2VsZXNzLWVzY2FwZVxuKTtcbmV4cG9ydCBjb25zdCBJU19TQ1JJUFRfT1JfREFUQSA9IHNlYWwoL14oPzpcXHcrc2NyaXB0fGRhdGEpOi9pKTtcbmV4cG9ydCBjb25zdCBBVFRSX1dISVRFU1BBQ0UgPSBzZWFsKFxuICAvW1xcdTAwMDAtXFx1MDAyMFxcdTAwQTBcXHUxNjgwXFx1MTgwRVxcdTIwMDAtXFx1MjAyOVxcdTIwNWZcXHUzMDAwXS9nIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29udHJvbC1yZWdleFxuKTtcbiIsImltcG9ydCAqIGFzIFRBR1MgZnJvbSAnLi90YWdzJztcbmltcG9ydCAqIGFzIEFUVFJTIGZyb20gJy4vYXR0cnMnO1xuaW1wb3J0ICogYXMgRVhQUkVTU0lPTlMgZnJvbSAnLi9yZWdleHAnO1xuaW1wb3J0IHtcbiAgYWRkVG9TZXQsXG4gIGNsb25lLFxuICBmcmVlemUsXG4gIG9iamVjdEtleXMsXG4gIGFycmF5Rm9yRWFjaCxcbiAgYXJyYXlJbmRleE9mLFxuICBhcnJheUpvaW4sXG4gIGFycmF5UG9wLFxuICBhcnJheVB1c2gsXG4gIGFycmF5U2xpY2UsXG4gIHN0cmluZ01hdGNoLFxuICBzdHJpbmdSZXBsYWNlLFxuICBzdHJpbmdUb0xvd2VyQ2FzZSxcbiAgc3RyaW5nSW5kZXhPZixcbiAgc3RyaW5nVHJpbSxcbiAgcmVnRXhwVGVzdCxcbiAgcmVnRXhwQ3JlYXRlLFxuICB0eXBlRXJyb3JDcmVhdGUsXG59IGZyb20gJy4vdXRpbHMnO1xuXG5jb25zdCBnZXRHbG9iYWwgPSAoKSA9PiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogd2luZG93KTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbm8tb3AgcG9saWN5IGZvciBpbnRlcm5hbCB1c2Ugb25seS5cbiAqIERvbid0IGV4cG9ydCB0aGlzIGZ1bmN0aW9uIG91dHNpZGUgdGhpcyBtb2R1bGUhXG4gKiBAcGFyYW0gez9UcnVzdGVkVHlwZVBvbGljeUZhY3Rvcnl9IHRydXN0ZWRUeXBlcyBUaGUgcG9saWN5IGZhY3RvcnkuXG4gKiBAcGFyYW0ge0RvY3VtZW50fSBkb2N1bWVudCBUaGUgZG9jdW1lbnQgb2JqZWN0ICh0byBkZXRlcm1pbmUgcG9saWN5IG5hbWUgc3VmZml4KVxuICogQHJldHVybiB7P1RydXN0ZWRUeXBlUG9saWN5fSBUaGUgcG9saWN5IGNyZWF0ZWQgKG9yIG51bGwsIGlmIFRydXN0ZWQgVHlwZXNcbiAqIGFyZSBub3Qgc3VwcG9ydGVkKS5cbiAqL1xuY29uc3QgX2NyZWF0ZVRydXN0ZWRUeXBlc1BvbGljeSA9IGZ1bmN0aW9uICh0cnVzdGVkVHlwZXMsIGRvY3VtZW50KSB7XG4gIGlmIChcbiAgICB0eXBlb2YgdHJ1c3RlZFR5cGVzICE9PSAnb2JqZWN0JyB8fFxuICAgIHR5cGVvZiB0cnVzdGVkVHlwZXMuY3JlYXRlUG9saWN5ICE9PSAnZnVuY3Rpb24nXG4gICkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gQWxsb3cgdGhlIGNhbGxlcnMgdG8gY29udHJvbCB0aGUgdW5pcXVlIHBvbGljeSBuYW1lXG4gIC8vIGJ5IGFkZGluZyBhIGRhdGEtdHQtcG9saWN5LXN1ZmZpeCB0byB0aGUgc2NyaXB0IGVsZW1lbnQgd2l0aCB0aGUgRE9NUHVyaWZ5LlxuICAvLyBQb2xpY3kgY3JlYXRpb24gd2l0aCBkdXBsaWNhdGUgbmFtZXMgdGhyb3dzIGluIFRydXN0ZWQgVHlwZXMuXG4gIGxldCBzdWZmaXggPSBudWxsO1xuICBjb25zdCBBVFRSX05BTUUgPSAnZGF0YS10dC1wb2xpY3ktc3VmZml4JztcbiAgaWYgKFxuICAgIGRvY3VtZW50LmN1cnJlbnRTY3JpcHQgJiZcbiAgICBkb2N1bWVudC5jdXJyZW50U2NyaXB0Lmhhc0F0dHJpYnV0ZShBVFRSX05BTUUpXG4gICkge1xuICAgIHN1ZmZpeCA9IGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuZ2V0QXR0cmlidXRlKEFUVFJfTkFNRSk7XG4gIH1cblxuICBjb25zdCBwb2xpY3lOYW1lID0gJ2RvbXB1cmlmeScgKyAoc3VmZml4ID8gJyMnICsgc3VmZml4IDogJycpO1xuXG4gIHRyeSB7XG4gICAgcmV0dXJuIHRydXN0ZWRUeXBlcy5jcmVhdGVQb2xpY3kocG9saWN5TmFtZSwge1xuICAgICAgY3JlYXRlSFRNTChodG1sKSB7XG4gICAgICAgIHJldHVybiBodG1sO1xuICAgICAgfSxcbiAgICB9KTtcbiAgfSBjYXRjaCAoXykge1xuICAgIC8vIFBvbGljeSBjcmVhdGlvbiBmYWlsZWQgKG1vc3QgbGlrZWx5IGFub3RoZXIgRE9NUHVyaWZ5IHNjcmlwdCBoYXNcbiAgICAvLyBhbHJlYWR5IHJ1bikuIFNraXAgY3JlYXRpbmcgdGhlIHBvbGljeSwgYXMgdGhpcyB3aWxsIG9ubHkgY2F1c2UgZXJyb3JzXG4gICAgLy8gaWYgVFQgYXJlIGVuZm9yY2VkLlxuICAgIGNvbnNvbGUud2FybihcbiAgICAgICdUcnVzdGVkVHlwZXMgcG9saWN5ICcgKyBwb2xpY3lOYW1lICsgJyBjb3VsZCBub3QgYmUgY3JlYXRlZC4nXG4gICAgKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuZnVuY3Rpb24gY3JlYXRlRE9NUHVyaWZ5KHdpbmRvdyA9IGdldEdsb2JhbCgpKSB7XG4gIGNvbnN0IERPTVB1cmlmeSA9IChyb290KSA9PiBjcmVhdGVET01QdXJpZnkocm9vdCk7XG5cbiAgLyoqXG4gICAqIFZlcnNpb24gbGFiZWwsIGV4cG9zZWQgZm9yIGVhc2llciBjaGVja3NcbiAgICogaWYgRE9NUHVyaWZ5IGlzIHVwIHRvIGRhdGUgb3Igbm90XG4gICAqL1xuICBET01QdXJpZnkudmVyc2lvbiA9IFZFUlNJT047XG5cbiAgLyoqXG4gICAqIEFycmF5IG9mIGVsZW1lbnRzIHRoYXQgRE9NUHVyaWZ5IHJlbW92ZWQgZHVyaW5nIHNhbml0YXRpb24uXG4gICAqIEVtcHR5IGlmIG5vdGhpbmcgd2FzIHJlbW92ZWQuXG4gICAqL1xuICBET01QdXJpZnkucmVtb3ZlZCA9IFtdO1xuXG4gIGlmICghd2luZG93IHx8ICF3aW5kb3cuZG9jdW1lbnQgfHwgd2luZG93LmRvY3VtZW50Lm5vZGVUeXBlICE9PSA5KSB7XG4gICAgLy8gTm90IHJ1bm5pbmcgaW4gYSBicm93c2VyLCBwcm92aWRlIGEgZmFjdG9yeSBmdW5jdGlvblxuICAgIC8vIHNvIHRoYXQgeW91IGNhbiBwYXNzIHlvdXIgb3duIFdpbmRvd1xuICAgIERPTVB1cmlmeS5pc1N1cHBvcnRlZCA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIERPTVB1cmlmeTtcbiAgfVxuXG4gIGNvbnN0IG9yaWdpbmFsRG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQ7XG4gIGxldCByZW1vdmVUaXRsZSA9IGZhbHNlO1xuXG4gIGxldCB7IGRvY3VtZW50IH0gPSB3aW5kb3c7XG4gIGNvbnN0IHtcbiAgICBEb2N1bWVudEZyYWdtZW50LFxuICAgIEhUTUxUZW1wbGF0ZUVsZW1lbnQsXG4gICAgTm9kZSxcbiAgICBOb2RlRmlsdGVyLFxuICAgIE5hbWVkTm9kZU1hcCA9IHdpbmRvdy5OYW1lZE5vZGVNYXAgfHwgd2luZG93Lk1vek5hbWVkQXR0ck1hcCxcbiAgICBUZXh0LFxuICAgIENvbW1lbnQsXG4gICAgRE9NUGFyc2VyLFxuICAgIHRydXN0ZWRUeXBlcyxcbiAgfSA9IHdpbmRvdztcblxuICAvLyBBcyBwZXIgaXNzdWUgIzQ3LCB0aGUgd2ViLWNvbXBvbmVudHMgcmVnaXN0cnkgaXMgaW5oZXJpdGVkIGJ5IGFcbiAgLy8gbmV3IGRvY3VtZW50IGNyZWF0ZWQgdmlhIGNyZWF0ZUhUTUxEb2N1bWVudC4gQXMgcGVyIHRoZSBzcGVjXG4gIC8vIChodHRwOi8vdzNjLmdpdGh1Yi5pby93ZWJjb21wb25lbnRzL3NwZWMvY3VzdG9tLyNjcmVhdGluZy1hbmQtcGFzc2luZy1yZWdpc3RyaWVzKVxuICAvLyBhIG5ldyBlbXB0eSByZWdpc3RyeSBpcyB1c2VkIHdoZW4gY3JlYXRpbmcgYSB0ZW1wbGF0ZSBjb250ZW50cyBvd25lclxuICAvLyBkb2N1bWVudCwgc28gd2UgdXNlIHRoYXQgYXMgb3VyIHBhcmVudCBkb2N1bWVudCB0byBlbnN1cmUgbm90aGluZ1xuICAvLyBpcyBpbmhlcml0ZWQuXG4gIGlmICh0eXBlb2YgSFRNTFRlbXBsYXRlRWxlbWVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnN0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICBpZiAodGVtcGxhdGUuY29udGVudCAmJiB0ZW1wbGF0ZS5jb250ZW50Lm93bmVyRG9jdW1lbnQpIHtcbiAgICAgIGRvY3VtZW50ID0gdGVtcGxhdGUuY29udGVudC5vd25lckRvY3VtZW50O1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHRydXN0ZWRUeXBlc1BvbGljeSA9IF9jcmVhdGVUcnVzdGVkVHlwZXNQb2xpY3koXG4gICAgdHJ1c3RlZFR5cGVzLFxuICAgIG9yaWdpbmFsRG9jdW1lbnRcbiAgKTtcbiAgY29uc3QgZW1wdHlIVE1MID1cbiAgICB0cnVzdGVkVHlwZXNQb2xpY3kgJiYgUkVUVVJOX1RSVVNURURfVFlQRVxuICAgICAgPyB0cnVzdGVkVHlwZXNQb2xpY3kuY3JlYXRlSFRNTCgnJylcbiAgICAgIDogJyc7XG5cbiAgY29uc3Qge1xuICAgIGltcGxlbWVudGF0aW9uLFxuICAgIGNyZWF0ZU5vZGVJdGVyYXRvcixcbiAgICBnZXRFbGVtZW50c0J5VGFnTmFtZSxcbiAgICBjcmVhdGVEb2N1bWVudEZyYWdtZW50LFxuICB9ID0gZG9jdW1lbnQ7XG4gIGNvbnN0IHsgaW1wb3J0Tm9kZSB9ID0gb3JpZ2luYWxEb2N1bWVudDtcblxuICBsZXQgaG9va3MgPSB7fTtcblxuICAvKipcbiAgICogRXhwb3NlIHdoZXRoZXIgdGhpcyBicm93c2VyIHN1cHBvcnRzIHJ1bm5pbmcgdGhlIGZ1bGwgRE9NUHVyaWZ5LlxuICAgKi9cbiAgRE9NUHVyaWZ5LmlzU3VwcG9ydGVkID1cbiAgICBpbXBsZW1lbnRhdGlvbiAmJlxuICAgIHR5cGVvZiBpbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgZG9jdW1lbnQuZG9jdW1lbnRNb2RlICE9PSA5O1xuXG4gIGNvbnN0IHtcbiAgICBNVVNUQUNIRV9FWFBSLFxuICAgIEVSQl9FWFBSLFxuICAgIERBVEFfQVRUUixcbiAgICBBUklBX0FUVFIsXG4gICAgSVNfU0NSSVBUX09SX0RBVEEsXG4gICAgQVRUUl9XSElURVNQQUNFLFxuICB9ID0gRVhQUkVTU0lPTlM7XG5cbiAgbGV0IHsgSVNfQUxMT1dFRF9VUkkgfSA9IEVYUFJFU1NJT05TO1xuXG4gIC8qKlxuICAgKiBXZSBjb25zaWRlciB0aGUgZWxlbWVudHMgYW5kIGF0dHJpYnV0ZXMgYmVsb3cgdG8gYmUgc2FmZS4gSWRlYWxseVxuICAgKiBkb24ndCBhZGQgYW55IG5ldyBvbmVzIGJ1dCBmZWVsIGZyZWUgdG8gcmVtb3ZlIHVud2FudGVkIG9uZXMuXG4gICAqL1xuXG4gIC8qIGFsbG93ZWQgZWxlbWVudCBuYW1lcyAqL1xuICBsZXQgQUxMT1dFRF9UQUdTID0gbnVsbDtcbiAgY29uc3QgREVGQVVMVF9BTExPV0VEX1RBR1MgPSBhZGRUb1NldCh7fSwgW1xuICAgIC4uLlRBR1MuaHRtbCxcbiAgICAuLi5UQUdTLnN2ZyxcbiAgICAuLi5UQUdTLnN2Z0ZpbHRlcnMsXG4gICAgLi4uVEFHUy5tYXRoTWwsXG4gICAgLi4uVEFHUy50ZXh0LFxuICBdKTtcblxuICAvKiBBbGxvd2VkIGF0dHJpYnV0ZSBuYW1lcyAqL1xuICBsZXQgQUxMT1dFRF9BVFRSID0gbnVsbDtcbiAgY29uc3QgREVGQVVMVF9BTExPV0VEX0FUVFIgPSBhZGRUb1NldCh7fSwgW1xuICAgIC4uLkFUVFJTLmh0bWwsXG4gICAgLi4uQVRUUlMuc3ZnLFxuICAgIC4uLkFUVFJTLm1hdGhNbCxcbiAgICAuLi5BVFRSUy54bWwsXG4gIF0pO1xuXG4gIC8qIEV4cGxpY2l0bHkgZm9yYmlkZGVuIHRhZ3MgKG92ZXJyaWRlcyBBTExPV0VEX1RBR1MvQUREX1RBR1MpICovXG4gIGxldCBGT1JCSURfVEFHUyA9IG51bGw7XG5cbiAgLyogRXhwbGljaXRseSBmb3JiaWRkZW4gYXR0cmlidXRlcyAob3ZlcnJpZGVzIEFMTE9XRURfQVRUUi9BRERfQVRUUikgKi9cbiAgbGV0IEZPUkJJRF9BVFRSID0gbnVsbDtcblxuICAvKiBEZWNpZGUgaWYgQVJJQSBhdHRyaWJ1dGVzIGFyZSBva2F5ICovXG4gIGxldCBBTExPV19BUklBX0FUVFIgPSB0cnVlO1xuXG4gIC8qIERlY2lkZSBpZiBjdXN0b20gZGF0YSBhdHRyaWJ1dGVzIGFyZSBva2F5ICovXG4gIGxldCBBTExPV19EQVRBX0FUVFIgPSB0cnVlO1xuXG4gIC8qIERlY2lkZSBpZiB1bmtub3duIHByb3RvY29scyBhcmUgb2theSAqL1xuICBsZXQgQUxMT1dfVU5LTk9XTl9QUk9UT0NPTFMgPSBmYWxzZTtcblxuICAvKiBPdXRwdXQgc2hvdWxkIGJlIHNhZmUgZm9yIGpRdWVyeSdzICQoKSBmYWN0b3J5PyAqL1xuICBsZXQgU0FGRV9GT1JfSlFVRVJZID0gZmFsc2U7XG5cbiAgLyogT3V0cHV0IHNob3VsZCBiZSBzYWZlIGZvciBjb21tb24gdGVtcGxhdGUgZW5naW5lcy5cbiAgICogVGhpcyBtZWFucywgRE9NUHVyaWZ5IHJlbW92ZXMgZGF0YSBhdHRyaWJ1dGVzLCBtdXN0YWNoZXMgYW5kIEVSQlxuICAgKi9cbiAgbGV0IFNBRkVfRk9SX1RFTVBMQVRFUyA9IGZhbHNlO1xuXG4gIC8qIERlY2lkZSBpZiBkb2N1bWVudCB3aXRoIDxodG1sPi4uLiBzaG91bGQgYmUgcmV0dXJuZWQgKi9cbiAgbGV0IFdIT0xFX0RPQ1VNRU5UID0gZmFsc2U7XG5cbiAgLyogVHJhY2sgd2hldGhlciBjb25maWcgaXMgYWxyZWFkeSBzZXQgb24gdGhpcyBpbnN0YW5jZSBvZiBET01QdXJpZnkuICovXG4gIGxldCBTRVRfQ09ORklHID0gZmFsc2U7XG5cbiAgLyogRGVjaWRlIGlmIGFsbCBlbGVtZW50cyAoZS5nLiBzdHlsZSwgc2NyaXB0KSBtdXN0IGJlIGNoaWxkcmVuIG9mXG4gICAqIGRvY3VtZW50LmJvZHkuIEJ5IGRlZmF1bHQsIGJyb3dzZXJzIG1pZ2h0IG1vdmUgdGhlbSB0byBkb2N1bWVudC5oZWFkICovXG4gIGxldCBGT1JDRV9CT0RZID0gZmFsc2U7XG5cbiAgLyogRGVjaWRlIGlmIGEgRE9NIGBIVE1MQm9keUVsZW1lbnRgIHNob3VsZCBiZSByZXR1cm5lZCwgaW5zdGVhZCBvZiBhIGh0bWxcbiAgICogc3RyaW5nIChvciBhIFRydXN0ZWRIVE1MIG9iamVjdCBpZiBUcnVzdGVkIFR5cGVzIGFyZSBzdXBwb3J0ZWQpLlxuICAgKiBJZiBgV0hPTEVfRE9DVU1FTlRgIGlzIGVuYWJsZWQgYSBgSFRNTEh0bWxFbGVtZW50YCB3aWxsIGJlIHJldHVybmVkIGluc3RlYWRcbiAgICovXG4gIGxldCBSRVRVUk5fRE9NID0gZmFsc2U7XG5cbiAgLyogRGVjaWRlIGlmIGEgRE9NIGBEb2N1bWVudEZyYWdtZW50YCBzaG91bGQgYmUgcmV0dXJuZWQsIGluc3RlYWQgb2YgYSBodG1sXG4gICAqIHN0cmluZyAgKG9yIGEgVHJ1c3RlZEhUTUwgb2JqZWN0IGlmIFRydXN0ZWQgVHlwZXMgYXJlIHN1cHBvcnRlZCkgKi9cbiAgbGV0IFJFVFVSTl9ET01fRlJBR01FTlQgPSBmYWxzZTtcblxuICAvKiBJZiBgUkVUVVJOX0RPTWAgb3IgYFJFVFVSTl9ET01fRlJBR01FTlRgIGlzIGVuYWJsZWQsIGRlY2lkZSBpZiB0aGUgcmV0dXJuZWQgRE9NXG4gICAqIGBOb2RlYCBpcyBpbXBvcnRlZCBpbnRvIHRoZSBjdXJyZW50IGBEb2N1bWVudGAuIElmIHRoaXMgZmxhZyBpcyBub3QgZW5hYmxlZCB0aGVcbiAgICogYE5vZGVgIHdpbGwgYmVsb25nIChpdHMgb3duZXJEb2N1bWVudCkgdG8gYSBmcmVzaCBgSFRNTERvY3VtZW50YCwgY3JlYXRlZCBieVxuICAgKiBET01QdXJpZnkuICovXG4gIGxldCBSRVRVUk5fRE9NX0lNUE9SVCA9IGZhbHNlO1xuXG4gIC8qIFRyeSB0byByZXR1cm4gYSBUcnVzdGVkIFR5cGUgb2JqZWN0IGluc3RlYWQgb2YgYSBzdHJpbmcsIHJldHJ1biBhIHN0cmluZyBpblxuICAgKiBjYXNlIFRydXN0ZWQgVHlwZXMgYXJlIG5vdCBzdXBwb3J0ZWQgICovXG4gIGxldCBSRVRVUk5fVFJVU1RFRF9UWVBFID0gZmFsc2U7XG5cbiAgLyogT3V0cHV0IHNob3VsZCBiZSBmcmVlIGZyb20gRE9NIGNsb2JiZXJpbmcgYXR0YWNrcz8gKi9cbiAgbGV0IFNBTklUSVpFX0RPTSA9IHRydWU7XG5cbiAgLyogS2VlcCBlbGVtZW50IGNvbnRlbnQgd2hlbiByZW1vdmluZyBlbGVtZW50PyAqL1xuICBsZXQgS0VFUF9DT05URU5UID0gdHJ1ZTtcblxuICAvKiBJZiBhIGBOb2RlYCBpcyBwYXNzZWQgdG8gc2FuaXRpemUoKSwgdGhlbiBwZXJmb3JtcyBzYW5pdGl6YXRpb24gaW4tcGxhY2UgaW5zdGVhZFxuICAgKiBvZiBpbXBvcnRpbmcgaXQgaW50byBhIG5ldyBEb2N1bWVudCBhbmQgcmV0dXJuaW5nIGEgc2FuaXRpemVkIGNvcHkgKi9cbiAgbGV0IElOX1BMQUNFID0gZmFsc2U7XG5cbiAgLyogQWxsb3cgdXNhZ2Ugb2YgcHJvZmlsZXMgbGlrZSBodG1sLCBzdmcgYW5kIG1hdGhNbCAqL1xuICBsZXQgVVNFX1BST0ZJTEVTID0ge307XG5cbiAgLyogVGFncyB0byBpZ25vcmUgY29udGVudCBvZiB3aGVuIEtFRVBfQ09OVEVOVCBpcyB0cnVlICovXG4gIGNvbnN0IEZPUkJJRF9DT05URU5UUyA9IGFkZFRvU2V0KHt9LCBbXG4gICAgJ2Fubm90YXRpb24teG1sJyxcbiAgICAnYXVkaW8nLFxuICAgICdjb2xncm91cCcsXG4gICAgJ2Rlc2MnLFxuICAgICdmb3JlaWdub2JqZWN0JyxcbiAgICAnaGVhZCcsXG4gICAgJ2lmcmFtZScsXG4gICAgJ21hdGgnLFxuICAgICdtaScsXG4gICAgJ21uJyxcbiAgICAnbW8nLFxuICAgICdtcycsXG4gICAgJ210ZXh0JyxcbiAgICAnbm9lbWJlZCcsXG4gICAgJ25vZnJhbWVzJyxcbiAgICAncGxhaW50ZXh0JyxcbiAgICAnc2NyaXB0JyxcbiAgICAnc3R5bGUnLFxuICAgICdzdmcnLFxuICAgICd0ZW1wbGF0ZScsXG4gICAgJ3RoZWFkJyxcbiAgICAndGl0bGUnLFxuICAgICd2aWRlbycsXG4gICAgJ3htcCcsXG4gIF0pO1xuXG4gIC8qIFRhZ3MgdGhhdCBhcmUgc2FmZSBmb3IgZGF0YTogVVJJcyAqL1xuICBsZXQgREFUQV9VUklfVEFHUyA9IG51bGw7XG4gIGNvbnN0IERFRkFVTFRfREFUQV9VUklfVEFHUyA9IGFkZFRvU2V0KHt9LCBbXG4gICAgJ2F1ZGlvJyxcbiAgICAndmlkZW8nLFxuICAgICdpbWcnLFxuICAgICdzb3VyY2UnLFxuICAgICdpbWFnZScsXG4gICAgJ3RyYWNrJyxcbiAgXSk7XG5cbiAgLyogQXR0cmlidXRlcyBzYWZlIGZvciB2YWx1ZXMgbGlrZSBcImphdmFzY3JpcHQ6XCIgKi9cbiAgbGV0IFVSSV9TQUZFX0FUVFJJQlVURVMgPSBudWxsO1xuICBjb25zdCBERUZBVUxUX1VSSV9TQUZFX0FUVFJJQlVURVMgPSBhZGRUb1NldCh7fSwgW1xuICAgICdhbHQnLFxuICAgICdjbGFzcycsXG4gICAgJ2ZvcicsXG4gICAgJ2lkJyxcbiAgICAnbGFiZWwnLFxuICAgICduYW1lJyxcbiAgICAncGF0dGVybicsXG4gICAgJ3BsYWNlaG9sZGVyJyxcbiAgICAnc3VtbWFyeScsXG4gICAgJ3RpdGxlJyxcbiAgICAndmFsdWUnLFxuICAgICdzdHlsZScsXG4gICAgJ3htbG5zJyxcbiAgXSk7XG5cbiAgLyogS2VlcCBhIHJlZmVyZW5jZSB0byBjb25maWcgdG8gcGFzcyB0byBob29rcyAqL1xuICBsZXQgQ09ORklHID0gbnVsbDtcblxuICAvKiBJZGVhbGx5LCBkbyBub3QgdG91Y2ggYW55dGhpbmcgYmVsb3cgdGhpcyBsaW5lICovXG4gIC8qIF9fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX18gKi9cblxuICBjb25zdCBmb3JtRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Zvcm0nKTtcblxuICAvKipcbiAgICogX3BhcnNlQ29uZmlnXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gY2ZnIG9wdGlvbmFsIGNvbmZpZyBsaXRlcmFsXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuICBjb25zdCBfcGFyc2VDb25maWcgPSBmdW5jdGlvbiAoY2ZnKSB7XG4gICAgaWYgKENPTkZJRyAmJiBDT05GSUcgPT09IGNmZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8qIFNoaWVsZCBjb25maWd1cmF0aW9uIG9iamVjdCBmcm9tIHRhbXBlcmluZyAqL1xuICAgIGlmICghY2ZnIHx8IHR5cGVvZiBjZmcgIT09ICdvYmplY3QnKSB7XG4gICAgICBjZmcgPSB7fTtcbiAgICB9XG5cbiAgICAvKiBTZXQgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzICovXG4gICAgQUxMT1dFRF9UQUdTID1cbiAgICAgICdBTExPV0VEX1RBR1MnIGluIGNmZ1xuICAgICAgICA/IGFkZFRvU2V0KHt9LCBjZmcuQUxMT1dFRF9UQUdTKVxuICAgICAgICA6IERFRkFVTFRfQUxMT1dFRF9UQUdTO1xuICAgIEFMTE9XRURfQVRUUiA9XG4gICAgICAnQUxMT1dFRF9BVFRSJyBpbiBjZmdcbiAgICAgICAgPyBhZGRUb1NldCh7fSwgY2ZnLkFMTE9XRURfQVRUUilcbiAgICAgICAgOiBERUZBVUxUX0FMTE9XRURfQVRUUjtcbiAgICBVUklfU0FGRV9BVFRSSUJVVEVTID1cbiAgICAgICdBRERfVVJJX1NBRkVfQVRUUicgaW4gY2ZnXG4gICAgICAgID8gYWRkVG9TZXQoY2xvbmUoREVGQVVMVF9VUklfU0FGRV9BVFRSSUJVVEVTKSwgY2ZnLkFERF9VUklfU0FGRV9BVFRSKVxuICAgICAgICA6IERFRkFVTFRfVVJJX1NBRkVfQVRUUklCVVRFUztcbiAgICBEQVRBX1VSSV9UQUdTID1cbiAgICAgICdBRERfREFUQV9VUklfVEFHUycgaW4gY2ZnXG4gICAgICAgID8gYWRkVG9TZXQoY2xvbmUoREVGQVVMVF9EQVRBX1VSSV9UQUdTKSwgY2ZnLkFERF9EQVRBX1VSSV9UQUdTKVxuICAgICAgICA6IERFRkFVTFRfREFUQV9VUklfVEFHUztcbiAgICBGT1JCSURfVEFHUyA9ICdGT1JCSURfVEFHUycgaW4gY2ZnID8gYWRkVG9TZXQoe30sIGNmZy5GT1JCSURfVEFHUykgOiB7fTtcbiAgICBGT1JCSURfQVRUUiA9ICdGT1JCSURfQVRUUicgaW4gY2ZnID8gYWRkVG9TZXQoe30sIGNmZy5GT1JCSURfQVRUUikgOiB7fTtcbiAgICBVU0VfUFJPRklMRVMgPSAnVVNFX1BST0ZJTEVTJyBpbiBjZmcgPyBjZmcuVVNFX1BST0ZJTEVTIDogZmFsc2U7XG4gICAgQUxMT1dfQVJJQV9BVFRSID0gY2ZnLkFMTE9XX0FSSUFfQVRUUiAhPT0gZmFsc2U7IC8vIERlZmF1bHQgdHJ1ZVxuICAgIEFMTE9XX0RBVEFfQVRUUiA9IGNmZy5BTExPV19EQVRBX0FUVFIgIT09IGZhbHNlOyAvLyBEZWZhdWx0IHRydWVcbiAgICBBTExPV19VTktOT1dOX1BST1RPQ09MUyA9IGNmZy5BTExPV19VTktOT1dOX1BST1RPQ09MUyB8fCBmYWxzZTsgLy8gRGVmYXVsdCBmYWxzZVxuICAgIFNBRkVfRk9SX0pRVUVSWSA9IGNmZy5TQUZFX0ZPUl9KUVVFUlkgfHwgZmFsc2U7IC8vIERlZmF1bHQgZmFsc2VcbiAgICBTQUZFX0ZPUl9URU1QTEFURVMgPSBjZmcuU0FGRV9GT1JfVEVNUExBVEVTIHx8IGZhbHNlOyAvLyBEZWZhdWx0IGZhbHNlXG4gICAgV0hPTEVfRE9DVU1FTlQgPSBjZmcuV0hPTEVfRE9DVU1FTlQgfHwgZmFsc2U7IC8vIERlZmF1bHQgZmFsc2VcbiAgICBSRVRVUk5fRE9NID0gY2ZnLlJFVFVSTl9ET00gfHwgZmFsc2U7IC8vIERlZmF1bHQgZmFsc2VcbiAgICBSRVRVUk5fRE9NX0ZSQUdNRU5UID0gY2ZnLlJFVFVSTl9ET01fRlJBR01FTlQgfHwgZmFsc2U7IC8vIERlZmF1bHQgZmFsc2VcbiAgICBSRVRVUk5fRE9NX0lNUE9SVCA9IGNmZy5SRVRVUk5fRE9NX0lNUE9SVCB8fCBmYWxzZTsgLy8gRGVmYXVsdCBmYWxzZVxuICAgIFJFVFVSTl9UUlVTVEVEX1RZUEUgPSBjZmcuUkVUVVJOX1RSVVNURURfVFlQRSB8fCBmYWxzZTsgLy8gRGVmYXVsdCBmYWxzZVxuICAgIEZPUkNFX0JPRFkgPSBjZmcuRk9SQ0VfQk9EWSB8fCBmYWxzZTsgLy8gRGVmYXVsdCBmYWxzZVxuICAgIFNBTklUSVpFX0RPTSA9IGNmZy5TQU5JVElaRV9ET00gIT09IGZhbHNlOyAvLyBEZWZhdWx0IHRydWVcbiAgICBLRUVQX0NPTlRFTlQgPSBjZmcuS0VFUF9DT05URU5UICE9PSBmYWxzZTsgLy8gRGVmYXVsdCB0cnVlXG4gICAgSU5fUExBQ0UgPSBjZmcuSU5fUExBQ0UgfHwgZmFsc2U7IC8vIERlZmF1bHQgZmFsc2VcbiAgICBJU19BTExPV0VEX1VSSSA9IGNmZy5BTExPV0VEX1VSSV9SRUdFWFAgfHwgSVNfQUxMT1dFRF9VUkk7XG4gICAgaWYgKFNBRkVfRk9SX1RFTVBMQVRFUykge1xuICAgICAgQUxMT1dfREFUQV9BVFRSID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKFJFVFVSTl9ET01fRlJBR01FTlQpIHtcbiAgICAgIFJFVFVSTl9ET00gPSB0cnVlO1xuICAgIH1cblxuICAgIC8qIFBhcnNlIHByb2ZpbGUgaW5mbyAqL1xuICAgIGlmIChVU0VfUFJPRklMRVMpIHtcbiAgICAgIEFMTE9XRURfVEFHUyA9IGFkZFRvU2V0KHt9LCBbLi4uVEFHUy50ZXh0XSk7XG4gICAgICBBTExPV0VEX0FUVFIgPSBbXTtcbiAgICAgIGlmIChVU0VfUFJPRklMRVMuaHRtbCA9PT0gdHJ1ZSkge1xuICAgICAgICBhZGRUb1NldChBTExPV0VEX1RBR1MsIFRBR1MuaHRtbCk7XG4gICAgICAgIGFkZFRvU2V0KEFMTE9XRURfQVRUUiwgQVRUUlMuaHRtbCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChVU0VfUFJPRklMRVMuc3ZnID09PSB0cnVlKSB7XG4gICAgICAgIGFkZFRvU2V0KEFMTE9XRURfVEFHUywgVEFHUy5zdmcpO1xuICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIEFUVFJTLnN2Zyk7XG4gICAgICAgIGFkZFRvU2V0KEFMTE9XRURfQVRUUiwgQVRUUlMueG1sKTtcbiAgICAgIH1cblxuICAgICAgaWYgKFVTRV9QUk9GSUxFUy5zdmdGaWx0ZXJzID09PSB0cnVlKSB7XG4gICAgICAgIGFkZFRvU2V0KEFMTE9XRURfVEFHUywgVEFHUy5zdmdGaWx0ZXJzKTtcbiAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9BVFRSLCBBVFRSUy5zdmcpO1xuICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIEFUVFJTLnhtbCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChVU0VfUFJPRklMRVMubWF0aE1sID09PSB0cnVlKSB7XG4gICAgICAgIGFkZFRvU2V0KEFMTE9XRURfVEFHUywgVEFHUy5tYXRoTWwpO1xuICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIEFUVFJTLm1hdGhNbCk7XG4gICAgICAgIGFkZFRvU2V0KEFMTE9XRURfQVRUUiwgQVRUUlMueG1sKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBNZXJnZSBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnMgKi9cbiAgICBpZiAoY2ZnLkFERF9UQUdTKSB7XG4gICAgICBpZiAoQUxMT1dFRF9UQUdTID09PSBERUZBVUxUX0FMTE9XRURfVEFHUykge1xuICAgICAgICBBTExPV0VEX1RBR1MgPSBjbG9uZShBTExPV0VEX1RBR1MpO1xuICAgICAgfVxuXG4gICAgICBhZGRUb1NldChBTExPV0VEX1RBR1MsIGNmZy5BRERfVEFHUyk7XG4gICAgfVxuXG4gICAgaWYgKGNmZy5BRERfQVRUUikge1xuICAgICAgaWYgKEFMTE9XRURfQVRUUiA9PT0gREVGQVVMVF9BTExPV0VEX0FUVFIpIHtcbiAgICAgICAgQUxMT1dFRF9BVFRSID0gY2xvbmUoQUxMT1dFRF9BVFRSKTtcbiAgICAgIH1cblxuICAgICAgYWRkVG9TZXQoQUxMT1dFRF9BVFRSLCBjZmcuQUREX0FUVFIpO1xuICAgIH1cblxuICAgIGlmIChjZmcuQUREX1VSSV9TQUZFX0FUVFIpIHtcbiAgICAgIGFkZFRvU2V0KFVSSV9TQUZFX0FUVFJJQlVURVMsIGNmZy5BRERfVVJJX1NBRkVfQVRUUik7XG4gICAgfVxuXG4gICAgLyogQWRkICN0ZXh0IGluIGNhc2UgS0VFUF9DT05URU5UIGlzIHNldCB0byB0cnVlICovXG4gICAgaWYgKEtFRVBfQ09OVEVOVCkge1xuICAgICAgQUxMT1dFRF9UQUdTWycjdGV4dCddID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKiBBZGQgaHRtbCwgaGVhZCBhbmQgYm9keSB0byBBTExPV0VEX1RBR1MgaW4gY2FzZSBXSE9MRV9ET0NVTUVOVCBpcyB0cnVlICovXG4gICAgaWYgKFdIT0xFX0RPQ1VNRU5UKSB7XG4gICAgICBhZGRUb1NldChBTExPV0VEX1RBR1MsIFsnaHRtbCcsICdoZWFkJywgJ2JvZHknXSk7XG4gICAgfVxuXG4gICAgLyogQWRkIHRib2R5IHRvIEFMTE9XRURfVEFHUyBpbiBjYXNlIHRhYmxlcyBhcmUgcGVybWl0dGVkLCBzZWUgIzI4NiwgIzM2NSAqL1xuICAgIGlmIChBTExPV0VEX1RBR1MudGFibGUpIHtcbiAgICAgIGFkZFRvU2V0KEFMTE9XRURfVEFHUywgWyd0Ym9keSddKTtcbiAgICAgIGRlbGV0ZSBGT1JCSURfVEFHUy50Ym9keTtcbiAgICB9XG5cbiAgICAvLyBQcmV2ZW50IGZ1cnRoZXIgbWFuaXB1bGF0aW9uIG9mIGNvbmZpZ3VyYXRpb24uXG4gICAgLy8gTm90IGF2YWlsYWJsZSBpbiBJRTgsIFNhZmFyaSA1LCBldGMuXG4gICAgaWYgKGZyZWV6ZSkge1xuICAgICAgZnJlZXplKGNmZyk7XG4gICAgfVxuXG4gICAgQ09ORklHID0gY2ZnO1xuICB9O1xuXG4gIC8qKlxuICAgKiBfZm9yY2VSZW1vdmVcbiAgICpcbiAgICogQHBhcmFtICB7Tm9kZX0gbm9kZSBhIERPTSBub2RlXG4gICAqL1xuICBjb25zdCBfZm9yY2VSZW1vdmUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIGFycmF5UHVzaChET01QdXJpZnkucmVtb3ZlZCwgeyBlbGVtZW50OiBub2RlIH0pO1xuICAgIHRyeSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9wcmVmZXItbm9kZS1yZW1vdmVcbiAgICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICB9IGNhdGNoIChfKSB7XG4gICAgICBub2RlLm91dGVySFRNTCA9IGVtcHR5SFRNTDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIF9yZW1vdmVBdHRyaWJ1dGVcbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfSBuYW1lIGFuIEF0dHJpYnV0ZSBuYW1lXG4gICAqIEBwYXJhbSAge05vZGV9IG5vZGUgYSBET00gbm9kZVxuICAgKi9cbiAgY29uc3QgX3JlbW92ZUF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChuYW1lLCBub2RlKSB7XG4gICAgdHJ5IHtcbiAgICAgIGFycmF5UHVzaChET01QdXJpZnkucmVtb3ZlZCwge1xuICAgICAgICBhdHRyaWJ1dGU6IG5vZGUuZ2V0QXR0cmlidXRlTm9kZShuYW1lKSxcbiAgICAgICAgZnJvbTogbm9kZSxcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgIGFycmF5UHVzaChET01QdXJpZnkucmVtb3ZlZCwge1xuICAgICAgICBhdHRyaWJ1dGU6IG51bGwsXG4gICAgICAgIGZyb206IG5vZGUsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgfTtcblxuICAvKipcbiAgICogX2luaXREb2N1bWVudFxuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGRpcnR5IGEgc3RyaW5nIG9mIGRpcnR5IG1hcmt1cFxuICAgKiBAcmV0dXJuIHtEb2N1bWVudH0gYSBET00sIGZpbGxlZCB3aXRoIHRoZSBkaXJ0eSBtYXJrdXBcbiAgICovXG4gIGNvbnN0IF9pbml0RG9jdW1lbnQgPSBmdW5jdGlvbiAoZGlydHkpIHtcbiAgICAvKiBDcmVhdGUgYSBIVE1MIGRvY3VtZW50ICovXG4gICAgbGV0IGRvYztcbiAgICBsZXQgbGVhZGluZ1doaXRlc3BhY2U7XG5cbiAgICBpZiAoRk9SQ0VfQk9EWSkge1xuICAgICAgZGlydHkgPSAnPHJlbW92ZT48L3JlbW92ZT4nICsgZGlydHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIElmIEZPUkNFX0JPRFkgaXNuJ3QgdXNlZCwgbGVhZGluZyB3aGl0ZXNwYWNlIG5lZWRzIHRvIGJlIHByZXNlcnZlZCBtYW51YWxseSAqL1xuICAgICAgY29uc3QgbWF0Y2hlcyA9IHN0cmluZ01hdGNoKGRpcnR5LCAvXltcXHJcXG5cXHQgXSsvKTtcbiAgICAgIGxlYWRpbmdXaGl0ZXNwYWNlID0gbWF0Y2hlcyAmJiBtYXRjaGVzWzBdO1xuICAgIH1cblxuICAgIGNvbnN0IGRpcnR5UGF5bG9hZCA9IHRydXN0ZWRUeXBlc1BvbGljeVxuICAgICAgPyB0cnVzdGVkVHlwZXNQb2xpY3kuY3JlYXRlSFRNTChkaXJ0eSlcbiAgICAgIDogZGlydHk7XG4gICAgLyogVXNlIHRoZSBET01QYXJzZXIgQVBJIGJ5IGRlZmF1bHQsIGZhbGxiYWNrIGxhdGVyIGlmIG5lZWRzIGJlICovXG4gICAgdHJ5IHtcbiAgICAgIGRvYyA9IG5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcoZGlydHlQYXlsb2FkLCAndGV4dC9odG1sJyk7XG4gICAgfSBjYXRjaCAoXykge31cblxuICAgIC8qIFJlbW92ZSB0aXRsZSB0byBmaXggYSBtWFNTIGJ1ZyBpbiBvbGRlciBNUyBFZGdlICovXG4gICAgaWYgKHJlbW92ZVRpdGxlKSB7XG4gICAgICBhZGRUb1NldChGT1JCSURfVEFHUywgWyd0aXRsZSddKTtcbiAgICB9XG5cbiAgICAvKiBVc2UgY3JlYXRlSFRNTERvY3VtZW50IGluIGNhc2UgRE9NUGFyc2VyIGlzIG5vdCBhdmFpbGFibGUgKi9cbiAgICBpZiAoIWRvYyB8fCAhZG9jLmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgZG9jID0gaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCcnKTtcbiAgICAgIGNvbnN0IHsgYm9keSB9ID0gZG9jO1xuICAgICAgYm9keS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGJvZHkucGFyZW50Tm9kZS5maXJzdEVsZW1lbnRDaGlsZCk7XG4gICAgICBib2R5Lm91dGVySFRNTCA9IGRpcnR5UGF5bG9hZDtcbiAgICB9XG5cbiAgICBpZiAoZGlydHkgJiYgbGVhZGluZ1doaXRlc3BhY2UpIHtcbiAgICAgIGRvYy5ib2R5Lmluc2VydEJlZm9yZShcbiAgICAgICAgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobGVhZGluZ1doaXRlc3BhY2UpLFxuICAgICAgICBkb2MuYm9keS5jaGlsZE5vZGVzWzBdIHx8IG51bGxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLyogV29yayBvbiB3aG9sZSBkb2N1bWVudCBvciBqdXN0IGl0cyBib2R5ICovXG4gICAgcmV0dXJuIGdldEVsZW1lbnRzQnlUYWdOYW1lLmNhbGwoZG9jLCBXSE9MRV9ET0NVTUVOVCA/ICdodG1sJyA6ICdib2R5JylbMF07XG4gIH07XG5cbiAgLyogSGVyZSB3ZSB0ZXN0IGZvciBhIGJyb2tlbiBmZWF0dXJlIGluIEVkZ2UgdGhhdCBtaWdodCBjYXVzZSBtWFNTICovXG4gIGlmIChET01QdXJpZnkuaXNTdXBwb3J0ZWQpIHtcbiAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZG9jID0gX2luaXREb2N1bWVudCgnPHgvPjx0aXRsZT4mbHQ7L3RpdGxlJmd0OyZsdDtpbWcmZ3Q7Jyk7XG4gICAgICAgIGlmIChyZWdFeHBUZXN0KC88XFwvdGl0bGUvLCBkb2MucXVlcnlTZWxlY3RvcigndGl0bGUnKS5pbm5lckhUTUwpKSB7XG4gICAgICAgICAgcmVtb3ZlVGl0bGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChfKSB7fVxuICAgIH0pKCk7XG4gIH1cblxuICAvKipcbiAgICogX2NyZWF0ZUl0ZXJhdG9yXG4gICAqXG4gICAqIEBwYXJhbSAge0RvY3VtZW50fSByb290IGRvY3VtZW50L2ZyYWdtZW50IHRvIGNyZWF0ZSBpdGVyYXRvciBmb3JcbiAgICogQHJldHVybiB7SXRlcmF0b3J9IGl0ZXJhdG9yIGluc3RhbmNlXG4gICAqL1xuICBjb25zdCBfY3JlYXRlSXRlcmF0b3IgPSBmdW5jdGlvbiAocm9vdCkge1xuICAgIHJldHVybiBjcmVhdGVOb2RlSXRlcmF0b3IuY2FsbChcbiAgICAgIHJvb3Qub3duZXJEb2N1bWVudCB8fCByb290LFxuICAgICAgcm9vdCxcbiAgICAgIE5vZGVGaWx0ZXIuU0hPV19FTEVNRU5UIHwgTm9kZUZpbHRlci5TSE9XX0NPTU1FTlQgfCBOb2RlRmlsdGVyLlNIT1dfVEVYVCxcbiAgICAgICgpID0+IHtcbiAgICAgICAgcmV0dXJuIE5vZGVGaWx0ZXIuRklMVEVSX0FDQ0VQVDtcbiAgICAgIH0sXG4gICAgICBmYWxzZVxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqIF9pc0Nsb2JiZXJlZFxuICAgKlxuICAgKiBAcGFyYW0gIHtOb2RlfSBlbG0gZWxlbWVudCB0byBjaGVjayBmb3IgY2xvYmJlcmluZyBhdHRhY2tzXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgY2xvYmJlcmVkLCBmYWxzZSBpZiBzYWZlXG4gICAqL1xuICBjb25zdCBfaXNDbG9iYmVyZWQgPSBmdW5jdGlvbiAoZWxtKSB7XG4gICAgaWYgKGVsbSBpbnN0YW5jZW9mIFRleHQgfHwgZWxtIGluc3RhbmNlb2YgQ29tbWVudCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIHR5cGVvZiBlbG0ubm9kZU5hbWUgIT09ICdzdHJpbmcnIHx8XG4gICAgICB0eXBlb2YgZWxtLnRleHRDb250ZW50ICE9PSAnc3RyaW5nJyB8fFxuICAgICAgdHlwZW9mIGVsbS5yZW1vdmVDaGlsZCAhPT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgIShlbG0uYXR0cmlidXRlcyBpbnN0YW5jZW9mIE5hbWVkTm9kZU1hcCkgfHxcbiAgICAgIHR5cGVvZiBlbG0ucmVtb3ZlQXR0cmlidXRlICE9PSAnZnVuY3Rpb24nIHx8XG4gICAgICB0eXBlb2YgZWxtLnNldEF0dHJpYnV0ZSAhPT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgdHlwZW9mIGVsbS5uYW1lc3BhY2VVUkkgIT09ICdzdHJpbmcnXG4gICAgKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIF9pc05vZGVcbiAgICpcbiAgICogQHBhcmFtICB7Tm9kZX0gb2JqIG9iamVjdCB0byBjaGVjayB3aGV0aGVyIGl0J3MgYSBET00gbm9kZVxuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlzIG9iamVjdCBpcyBhIERPTSBub2RlXG4gICAqL1xuICBjb25zdCBfaXNOb2RlID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiB0eXBlb2YgTm9kZSA9PT0gJ29iamVjdCdcbiAgICAgID8gb2JqZWN0IGluc3RhbmNlb2YgTm9kZVxuICAgICAgOiBvYmplY3QgJiZcbiAgICAgICAgICB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgIHR5cGVvZiBvYmplY3Qubm9kZVR5cGUgPT09ICdudW1iZXInICYmXG4gICAgICAgICAgdHlwZW9mIG9iamVjdC5ub2RlTmFtZSA9PT0gJ3N0cmluZyc7XG4gIH07XG5cbiAgLyoqXG4gICAqIF9leGVjdXRlSG9va1xuICAgKiBFeGVjdXRlIHVzZXIgY29uZmlndXJhYmxlIGhvb2tzXG4gICAqXG4gICAqIEBwYXJhbSAge1N0cmluZ30gZW50cnlQb2ludCAgTmFtZSBvZiB0aGUgaG9vaydzIGVudHJ5IHBvaW50XG4gICAqIEBwYXJhbSAge05vZGV9IGN1cnJlbnROb2RlIG5vZGUgdG8gd29yayBvbiB3aXRoIHRoZSBob29rXG4gICAqIEBwYXJhbSAge09iamVjdH0gZGF0YSBhZGRpdGlvbmFsIGhvb2sgcGFyYW1ldGVyc1xuICAgKi9cbiAgY29uc3QgX2V4ZWN1dGVIb29rID0gZnVuY3Rpb24gKGVudHJ5UG9pbnQsIGN1cnJlbnROb2RlLCBkYXRhKSB7XG4gICAgaWYgKCFob29rc1tlbnRyeVBvaW50XSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGFycmF5Rm9yRWFjaChob29rc1tlbnRyeVBvaW50XSwgKGhvb2spID0+IHtcbiAgICAgIGhvb2suY2FsbChET01QdXJpZnksIGN1cnJlbnROb2RlLCBkYXRhLCBDT05GSUcpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBfc2FuaXRpemVFbGVtZW50c1xuICAgKlxuICAgKiBAcHJvdGVjdCBub2RlTmFtZVxuICAgKiBAcHJvdGVjdCB0ZXh0Q29udGVudFxuICAgKiBAcHJvdGVjdCByZW1vdmVDaGlsZFxuICAgKlxuICAgKiBAcGFyYW0gICB7Tm9kZX0gY3VycmVudE5vZGUgdG8gY2hlY2sgZm9yIHBlcm1pc3Npb24gdG8gZXhpc3RcbiAgICogQHJldHVybiAge0Jvb2xlYW59IHRydWUgaWYgbm9kZSB3YXMga2lsbGVkLCBmYWxzZSBpZiBsZWZ0IGFsaXZlXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuICBjb25zdCBfc2FuaXRpemVFbGVtZW50cyA9IGZ1bmN0aW9uIChjdXJyZW50Tm9kZSkge1xuICAgIGxldCBjb250ZW50O1xuXG4gICAgLyogRXhlY3V0ZSBhIGhvb2sgaWYgcHJlc2VudCAqL1xuICAgIF9leGVjdXRlSG9vaygnYmVmb3JlU2FuaXRpemVFbGVtZW50cycsIGN1cnJlbnROb2RlLCBudWxsKTtcblxuICAgIC8qIENoZWNrIGlmIGVsZW1lbnQgaXMgY2xvYmJlcmVkIG9yIGNhbiBjbG9iYmVyICovXG4gICAgaWYgKF9pc0Nsb2JiZXJlZChjdXJyZW50Tm9kZSkpIHtcbiAgICAgIF9mb3JjZVJlbW92ZShjdXJyZW50Tm9kZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKiBOb3cgbGV0J3MgY2hlY2sgdGhlIGVsZW1lbnQncyB0eXBlIGFuZCBuYW1lICovXG4gICAgY29uc3QgdGFnTmFtZSA9IHN0cmluZ1RvTG93ZXJDYXNlKGN1cnJlbnROb2RlLm5vZGVOYW1lKTtcblxuICAgIC8qIEV4ZWN1dGUgYSBob29rIGlmIHByZXNlbnQgKi9cbiAgICBfZXhlY3V0ZUhvb2soJ3Vwb25TYW5pdGl6ZUVsZW1lbnQnLCBjdXJyZW50Tm9kZSwge1xuICAgICAgdGFnTmFtZSxcbiAgICAgIGFsbG93ZWRUYWdzOiBBTExPV0VEX1RBR1MsXG4gICAgfSk7XG5cbiAgICAvKiBUYWtlIGNhcmUgb2YgYW4gbVhTUyBwYXR0ZXJuIHVzaW5nIHAsIGJyIGluc2lkZSBzdmcsIG1hdGggKi9cbiAgICBpZiAoXG4gICAgICAodGFnTmFtZSA9PT0gJ3N2ZycgfHwgdGFnTmFtZSA9PT0gJ21hdGgnKSAmJlxuICAgICAgY3VycmVudE5vZGUucXVlcnlTZWxlY3RvckFsbCgncCwgYnInKS5sZW5ndGggIT09IDBcbiAgICApIHtcbiAgICAgIF9mb3JjZVJlbW92ZShjdXJyZW50Tm9kZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKiBSZW1vdmUgZWxlbWVudCBpZiBhbnl0aGluZyBmb3JiaWRzIGl0cyBwcmVzZW5jZSAqL1xuICAgIGlmICghQUxMT1dFRF9UQUdTW3RhZ05hbWVdIHx8IEZPUkJJRF9UQUdTW3RhZ05hbWVdKSB7XG4gICAgICAvKiBLZWVwIGNvbnRlbnQgZXhjZXB0IGZvciBiYWQtbGlzdGVkIGVsZW1lbnRzICovXG4gICAgICBpZiAoXG4gICAgICAgIEtFRVBfQ09OVEVOVCAmJlxuICAgICAgICAhRk9SQklEX0NPTlRFTlRTW3RhZ05hbWVdICYmXG4gICAgICAgIHR5cGVvZiBjdXJyZW50Tm9kZS5pbnNlcnRBZGphY2VudEhUTUwgPT09ICdmdW5jdGlvbidcbiAgICAgICkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGh0bWxUb0luc2VydCA9IGN1cnJlbnROb2RlLmlubmVySFRNTDtcbiAgICAgICAgICBjdXJyZW50Tm9kZS5pbnNlcnRBZGphY2VudEhUTUwoXG4gICAgICAgICAgICAnQWZ0ZXJFbmQnLFxuICAgICAgICAgICAgdHJ1c3RlZFR5cGVzUG9saWN5XG4gICAgICAgICAgICAgID8gdHJ1c3RlZFR5cGVzUG9saWN5LmNyZWF0ZUhUTUwoaHRtbFRvSW5zZXJ0KVxuICAgICAgICAgICAgICA6IGh0bWxUb0luc2VydFxuICAgICAgICAgICk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHt9XG4gICAgICB9XG5cbiAgICAgIF9mb3JjZVJlbW92ZShjdXJyZW50Tm9kZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKiBSZW1vdmUgaW4gY2FzZSBhIG5vc2NyaXB0L25vZW1iZWQgWFNTIGlzIHN1c3BlY3RlZCAqL1xuICAgIGlmIChcbiAgICAgIHRhZ05hbWUgPT09ICdub3NjcmlwdCcgJiZcbiAgICAgIHJlZ0V4cFRlc3QoLzxcXC9ub3NjcmlwdC9pLCBjdXJyZW50Tm9kZS5pbm5lckhUTUwpXG4gICAgKSB7XG4gICAgICBfZm9yY2VSZW1vdmUoY3VycmVudE5vZGUpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgdGFnTmFtZSA9PT0gJ25vZW1iZWQnICYmXG4gICAgICByZWdFeHBUZXN0KC88XFwvbm9lbWJlZC9pLCBjdXJyZW50Tm9kZS5pbm5lckhUTUwpXG4gICAgKSB7XG4gICAgICBfZm9yY2VSZW1vdmUoY3VycmVudE5vZGUpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyogQ29udmVydCBtYXJrdXAgdG8gY292ZXIgalF1ZXJ5IGJlaGF2aW9yICovXG4gICAgaWYgKFxuICAgICAgU0FGRV9GT1JfSlFVRVJZICYmXG4gICAgICAhY3VycmVudE5vZGUuZmlyc3RFbGVtZW50Q2hpbGQgJiZcbiAgICAgICghY3VycmVudE5vZGUuY29udGVudCB8fCAhY3VycmVudE5vZGUuY29udGVudC5maXJzdEVsZW1lbnRDaGlsZCkgJiZcbiAgICAgIHJlZ0V4cFRlc3QoLzwvZywgY3VycmVudE5vZGUudGV4dENvbnRlbnQpXG4gICAgKSB7XG4gICAgICBhcnJheVB1c2goRE9NUHVyaWZ5LnJlbW92ZWQsIHsgZWxlbWVudDogY3VycmVudE5vZGUuY2xvbmVOb2RlKCkgfSk7XG4gICAgICBpZiAoY3VycmVudE5vZGUuaW5uZXJIVE1MKSB7XG4gICAgICAgIGN1cnJlbnROb2RlLmlubmVySFRNTCA9IHN0cmluZ1JlcGxhY2UoXG4gICAgICAgICAgY3VycmVudE5vZGUuaW5uZXJIVE1MLFxuICAgICAgICAgIC88L2csXG4gICAgICAgICAgJyZsdDsnXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50Tm9kZS5pbm5lckhUTUwgPSBzdHJpbmdSZXBsYWNlKFxuICAgICAgICAgIGN1cnJlbnROb2RlLnRleHRDb250ZW50LFxuICAgICAgICAgIC88L2csXG4gICAgICAgICAgJyZsdDsnXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogU2FuaXRpemUgZWxlbWVudCBjb250ZW50IHRvIGJlIHRlbXBsYXRlLXNhZmUgKi9cbiAgICBpZiAoU0FGRV9GT1JfVEVNUExBVEVTICYmIGN1cnJlbnROb2RlLm5vZGVUeXBlID09PSAzKSB7XG4gICAgICAvKiBHZXQgdGhlIGVsZW1lbnQncyB0ZXh0IGNvbnRlbnQgKi9cbiAgICAgIGNvbnRlbnQgPSBjdXJyZW50Tm9kZS50ZXh0Q29udGVudDtcbiAgICAgIGNvbnRlbnQgPSBzdHJpbmdSZXBsYWNlKGNvbnRlbnQsIE1VU1RBQ0hFX0VYUFIsICcgJyk7XG4gICAgICBjb250ZW50ID0gc3RyaW5nUmVwbGFjZShjb250ZW50LCBFUkJfRVhQUiwgJyAnKTtcbiAgICAgIGlmIChjdXJyZW50Tm9kZS50ZXh0Q29udGVudCAhPT0gY29udGVudCkge1xuICAgICAgICBhcnJheVB1c2goRE9NUHVyaWZ5LnJlbW92ZWQsIHsgZWxlbWVudDogY3VycmVudE5vZGUuY2xvbmVOb2RlKCkgfSk7XG4gICAgICAgIGN1cnJlbnROb2RlLnRleHRDb250ZW50ID0gY29udGVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBFeGVjdXRlIGEgaG9vayBpZiBwcmVzZW50ICovXG4gICAgX2V4ZWN1dGVIb29rKCdhZnRlclNhbml0aXplRWxlbWVudHMnLCBjdXJyZW50Tm9kZSwgbnVsbCk7XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIF9pc1ZhbGlkQXR0cmlidXRlXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gbGNUYWcgTG93ZXJjYXNlIHRhZyBuYW1lIG9mIGNvbnRhaW5pbmcgZWxlbWVudC5cbiAgICogQHBhcmFtICB7c3RyaW5nfSBsY05hbWUgTG93ZXJjYXNlIGF0dHJpYnV0ZSBuYW1lLlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHZhbHVlIEF0dHJpYnV0ZSB2YWx1ZS5cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgdmFsaWQsIG90aGVyd2lzZSBmYWxzZS5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gIGNvbnN0IF9pc1ZhbGlkQXR0cmlidXRlID0gZnVuY3Rpb24gKGxjVGFnLCBsY05hbWUsIHZhbHVlKSB7XG4gICAgLyogTWFrZSBzdXJlIGF0dHJpYnV0ZSBjYW5ub3QgY2xvYmJlciAqL1xuICAgIGlmIChcbiAgICAgIFNBTklUSVpFX0RPTSAmJlxuICAgICAgKGxjTmFtZSA9PT0gJ2lkJyB8fCBsY05hbWUgPT09ICduYW1lJykgJiZcbiAgICAgICh2YWx1ZSBpbiBkb2N1bWVudCB8fCB2YWx1ZSBpbiBmb3JtRWxlbWVudClcbiAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKiBBbGxvdyB2YWxpZCBkYXRhLSogYXR0cmlidXRlczogQXQgbGVhc3Qgb25lIGNoYXJhY3RlciBhZnRlciBcIi1cIlxuICAgICAgICAoaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZG9tLmh0bWwjZW1iZWRkaW5nLWN1c3RvbS1ub24tdmlzaWJsZS1kYXRhLXdpdGgtdGhlLWRhdGEtKi1hdHRyaWJ1dGVzKVxuICAgICAgICBYTUwtY29tcGF0aWJsZSAoaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5mcmFzdHJ1Y3R1cmUuaHRtbCN4bWwtY29tcGF0aWJsZSBhbmQgaHR0cDovL3d3dy53My5vcmcvVFIveG1sLyNkMGU4MDQpXG4gICAgICAgIFdlIGRvbid0IG5lZWQgdG8gY2hlY2sgdGhlIHZhbHVlOyBpdCdzIGFsd2F5cyBVUkkgc2FmZS4gKi9cbiAgICBpZiAoQUxMT1dfREFUQV9BVFRSICYmIHJlZ0V4cFRlc3QoREFUQV9BVFRSLCBsY05hbWUpKSB7XG4gICAgICAvLyBUaGlzIGF0dHJpYnV0ZSBpcyBzYWZlXG4gICAgfSBlbHNlIGlmIChBTExPV19BUklBX0FUVFIgJiYgcmVnRXhwVGVzdChBUklBX0FUVFIsIGxjTmFtZSkpIHtcbiAgICAgIC8vIFRoaXMgYXR0cmlidXRlIGlzIHNhZmVcbiAgICAgIC8qIE90aGVyd2lzZSwgY2hlY2sgdGhlIG5hbWUgaXMgcGVybWl0dGVkICovXG4gICAgfSBlbHNlIGlmICghQUxMT1dFRF9BVFRSW2xjTmFtZV0gfHwgRk9SQklEX0FUVFJbbGNOYW1lXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAvKiBDaGVjayB2YWx1ZSBpcyBzYWZlLiBGaXJzdCwgaXMgYXR0ciBpbmVydD8gSWYgc28sIGlzIHNhZmUgKi9cbiAgICB9IGVsc2UgaWYgKFVSSV9TQUZFX0FUVFJJQlVURVNbbGNOYW1lXSkge1xuICAgICAgLy8gVGhpcyBhdHRyaWJ1dGUgaXMgc2FmZVxuICAgICAgLyogQ2hlY2sgbm8gc2NyaXB0LCBkYXRhIG9yIHVua25vd24gcG9zc2libHkgdW5zYWZlIFVSSVxuICAgICAgICB1bmxlc3Mgd2Uga25vdyBVUkkgdmFsdWVzIGFyZSBzYWZlIGZvciB0aGF0IGF0dHJpYnV0ZSAqL1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICByZWdFeHBUZXN0KElTX0FMTE9XRURfVVJJLCBzdHJpbmdSZXBsYWNlKHZhbHVlLCBBVFRSX1dISVRFU1BBQ0UsICcnKSlcbiAgICApIHtcbiAgICAgIC8vIFRoaXMgYXR0cmlidXRlIGlzIHNhZmVcbiAgICAgIC8qIEtlZXAgaW1hZ2UgZGF0YSBVUklzIGFsaXZlIGlmIHNyYy94bGluazpocmVmIGlzIGFsbG93ZWQgKi9cbiAgICAgIC8qIEZ1cnRoZXIgcHJldmVudCBnYWRnZXQgWFNTIGZvciBkeW5hbWljYWxseSBidWlsdCBzY3JpcHQgdGFncyAqL1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICAobGNOYW1lID09PSAnc3JjJyB8fCBsY05hbWUgPT09ICd4bGluazpocmVmJyB8fCBsY05hbWUgPT09ICdocmVmJykgJiZcbiAgICAgIGxjVGFnICE9PSAnc2NyaXB0JyAmJlxuICAgICAgc3RyaW5nSW5kZXhPZih2YWx1ZSwgJ2RhdGE6JykgPT09IDAgJiZcbiAgICAgIERBVEFfVVJJX1RBR1NbbGNUYWddXG4gICAgKSB7XG4gICAgICAvLyBUaGlzIGF0dHJpYnV0ZSBpcyBzYWZlXG4gICAgICAvKiBBbGxvdyB1bmtub3duIHByb3RvY29sczogVGhpcyBwcm92aWRlcyBzdXBwb3J0IGZvciBsaW5rcyB0aGF0XG4gICAgICAgIGFyZSBoYW5kbGVkIGJ5IHByb3RvY29sIGhhbmRsZXJzIHdoaWNoIG1heSBiZSB1bmtub3duIGFoZWFkIG9mXG4gICAgICAgIHRpbWUsIGUuZy4gZmI6LCBzcG90aWZ5OiAqL1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICBBTExPV19VTktOT1dOX1BST1RPQ09MUyAmJlxuICAgICAgIXJlZ0V4cFRlc3QoSVNfU0NSSVBUX09SX0RBVEEsIHN0cmluZ1JlcGxhY2UodmFsdWUsIEFUVFJfV0hJVEVTUEFDRSwgJycpKVxuICAgICkge1xuICAgICAgLy8gVGhpcyBhdHRyaWJ1dGUgaXMgc2FmZVxuICAgICAgLyogQ2hlY2sgZm9yIGJpbmFyeSBhdHRyaWJ1dGVzICovXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmVnYXRlZC1jb25kaXRpb25cbiAgICB9IGVsc2UgaWYgKCF2YWx1ZSkge1xuICAgICAgLy8gQmluYXJ5IGF0dHJpYnV0ZXMgYXJlIHNhZmUgYXQgdGhpcyBwb2ludFxuICAgICAgLyogQW55dGhpbmcgZWxzZSwgcHJlc3VtZSB1bnNhZmUsIGRvIG5vdCBhZGQgaXQgYmFjayAqL1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIF9zYW5pdGl6ZUF0dHJpYnV0ZXNcbiAgICpcbiAgICogQHByb3RlY3QgYXR0cmlidXRlc1xuICAgKiBAcHJvdGVjdCBub2RlTmFtZVxuICAgKiBAcHJvdGVjdCByZW1vdmVBdHRyaWJ1dGVcbiAgICogQHByb3RlY3Qgc2V0QXR0cmlidXRlXG4gICAqXG4gICAqIEBwYXJhbSAge05vZGV9IGN1cnJlbnROb2RlIHRvIHNhbml0aXplXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuICBjb25zdCBfc2FuaXRpemVBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKGN1cnJlbnROb2RlKSB7XG4gICAgbGV0IGF0dHI7XG4gICAgbGV0IHZhbHVlO1xuICAgIGxldCBsY05hbWU7XG4gICAgbGV0IGlkQXR0cjtcbiAgICBsZXQgbDtcbiAgICAvKiBFeGVjdXRlIGEgaG9vayBpZiBwcmVzZW50ICovXG4gICAgX2V4ZWN1dGVIb29rKCdiZWZvcmVTYW5pdGl6ZUF0dHJpYnV0ZXMnLCBjdXJyZW50Tm9kZSwgbnVsbCk7XG5cbiAgICBsZXQgeyBhdHRyaWJ1dGVzIH0gPSBjdXJyZW50Tm9kZTtcblxuICAgIC8qIENoZWNrIGlmIHdlIGhhdmUgYXR0cmlidXRlczsgaWYgbm90IHdlIG1pZ2h0IGhhdmUgYSB0ZXh0IG5vZGUgKi9cbiAgICBpZiAoIWF0dHJpYnV0ZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBob29rRXZlbnQgPSB7XG4gICAgICBhdHRyTmFtZTogJycsXG4gICAgICBhdHRyVmFsdWU6ICcnLFxuICAgICAga2VlcEF0dHI6IHRydWUsXG4gICAgICBhbGxvd2VkQXR0cmlidXRlczogQUxMT1dFRF9BVFRSLFxuICAgIH07XG4gICAgbCA9IGF0dHJpYnV0ZXMubGVuZ3RoO1xuXG4gICAgLyogR28gYmFja3dhcmRzIG92ZXIgYWxsIGF0dHJpYnV0ZXM7IHNhZmVseSByZW1vdmUgYmFkIG9uZXMgKi9cbiAgICB3aGlsZSAobC0tKSB7XG4gICAgICBhdHRyID0gYXR0cmlidXRlc1tsXTtcbiAgICAgIGNvbnN0IHsgbmFtZSwgbmFtZXNwYWNlVVJJIH0gPSBhdHRyO1xuICAgICAgdmFsdWUgPSBzdHJpbmdUcmltKGF0dHIudmFsdWUpO1xuICAgICAgbGNOYW1lID0gc3RyaW5nVG9Mb3dlckNhc2UobmFtZSk7XG5cbiAgICAgIC8qIEV4ZWN1dGUgYSBob29rIGlmIHByZXNlbnQgKi9cbiAgICAgIGhvb2tFdmVudC5hdHRyTmFtZSA9IGxjTmFtZTtcbiAgICAgIGhvb2tFdmVudC5hdHRyVmFsdWUgPSB2YWx1ZTtcbiAgICAgIGhvb2tFdmVudC5rZWVwQXR0ciA9IHRydWU7XG4gICAgICBob29rRXZlbnQuZm9yY2VLZWVwQXR0ciA9IHVuZGVmaW5lZDsgLy8gQWxsb3dzIGRldmVsb3BlcnMgdG8gc2VlIHRoaXMgaXMgYSBwcm9wZXJ0eSB0aGV5IGNhbiBzZXRcbiAgICAgIF9leGVjdXRlSG9vaygndXBvblNhbml0aXplQXR0cmlidXRlJywgY3VycmVudE5vZGUsIGhvb2tFdmVudCk7XG4gICAgICB2YWx1ZSA9IGhvb2tFdmVudC5hdHRyVmFsdWU7XG4gICAgICAvKiBEaWQgdGhlIGhvb2tzIGFwcHJvdmUgb2YgdGhlIGF0dHJpYnV0ZT8gKi9cbiAgICAgIGlmIChob29rRXZlbnQuZm9yY2VLZWVwQXR0cikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLyogUmVtb3ZlIGF0dHJpYnV0ZSAqL1xuICAgICAgLy8gU2FmYXJpIChpT1MgKyBNYWMpLCBsYXN0IHRlc3RlZCB2OC4wLjUsIGNyYXNoZXMgaWYgeW91IHRyeSB0b1xuICAgICAgLy8gcmVtb3ZlIGEgXCJuYW1lXCIgYXR0cmlidXRlIGZyb20gYW4gPGltZz4gdGFnIHRoYXQgaGFzIGFuIFwiaWRcIlxuICAgICAgLy8gYXR0cmlidXRlIGF0IHRoZSB0aW1lLlxuICAgICAgaWYgKFxuICAgICAgICBsY05hbWUgPT09ICduYW1lJyAmJlxuICAgICAgICBjdXJyZW50Tm9kZS5ub2RlTmFtZSA9PT0gJ0lNRycgJiZcbiAgICAgICAgYXR0cmlidXRlcy5pZFxuICAgICAgKSB7XG4gICAgICAgIGlkQXR0ciA9IGF0dHJpYnV0ZXMuaWQ7XG4gICAgICAgIGF0dHJpYnV0ZXMgPSBhcnJheVNsaWNlKGF0dHJpYnV0ZXMsIFtdKTtcbiAgICAgICAgX3JlbW92ZUF0dHJpYnV0ZSgnaWQnLCBjdXJyZW50Tm9kZSk7XG4gICAgICAgIF9yZW1vdmVBdHRyaWJ1dGUobmFtZSwgY3VycmVudE5vZGUpO1xuICAgICAgICBpZiAoYXJyYXlJbmRleE9mKGF0dHJpYnV0ZXMsIGlkQXR0cikgPiBsKSB7XG4gICAgICAgICAgY3VycmVudE5vZGUuc2V0QXR0cmlidXRlKCdpZCcsIGlkQXR0ci52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIC8vIFRoaXMgd29ya3MgYXJvdW5kIGEgYnVnIGluIFNhZmFyaSwgd2hlcmUgaW5wdXRbdHlwZT1maWxlXVxuICAgICAgICAvLyBjYW5ub3QgYmUgZHluYW1pY2FsbHkgc2V0IGFmdGVyIHR5cGUgaGFzIGJlZW4gcmVtb3ZlZFxuICAgICAgICBjdXJyZW50Tm9kZS5ub2RlTmFtZSA9PT0gJ0lOUFVUJyAmJlxuICAgICAgICBsY05hbWUgPT09ICd0eXBlJyAmJlxuICAgICAgICB2YWx1ZSA9PT0gJ2ZpbGUnICYmXG4gICAgICAgIGhvb2tFdmVudC5rZWVwQXR0ciAmJlxuICAgICAgICAoQUxMT1dFRF9BVFRSW2xjTmFtZV0gfHwgIUZPUkJJRF9BVFRSW2xjTmFtZV0pXG4gICAgICApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGF2b2lkcyBhIGNyYXNoIGluIFNhZmFyaSB2OS4wIHdpdGggZG91YmxlLWlkcy5cbiAgICAgICAgLy8gVGhlIHRyaWNrIGlzIHRvIGZpcnN0IHNldCB0aGUgaWQgdG8gYmUgZW1wdHkgYW5kIHRoZW4gdG9cbiAgICAgICAgLy8gcmVtb3ZlIHRoZSBhdHRyaWJ1dGVcbiAgICAgICAgaWYgKG5hbWUgPT09ICdpZCcpIHtcbiAgICAgICAgICBjdXJyZW50Tm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3JlbW92ZUF0dHJpYnV0ZShuYW1lLCBjdXJyZW50Tm9kZSk7XG4gICAgICB9XG5cbiAgICAgIC8qIERpZCB0aGUgaG9va3MgYXBwcm92ZSBvZiB0aGUgYXR0cmlidXRlPyAqL1xuICAgICAgaWYgKCFob29rRXZlbnQua2VlcEF0dHIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8qIFdvcmsgYXJvdW5kIGEgc2VjdXJpdHkgaXNzdWUgaW4galF1ZXJ5IDMuMCAqL1xuICAgICAgaWYgKFNBRkVfRk9SX0pRVUVSWSAmJiByZWdFeHBUZXN0KC9cXC8+L2ksIHZhbHVlKSkge1xuICAgICAgICBfcmVtb3ZlQXR0cmlidXRlKG5hbWUsIGN1cnJlbnROb2RlKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8qIFRha2UgY2FyZSBvZiBhbiBtWFNTIHBhdHRlcm4gdXNpbmcgbmFtZXNwYWNlIHN3aXRjaGVzICovXG4gICAgICBpZiAoXG4gICAgICAgIHJlZ0V4cFRlc3QoL3N2Z3xtYXRoL2ksIGN1cnJlbnROb2RlLm5hbWVzcGFjZVVSSSkgJiZcbiAgICAgICAgcmVnRXhwVGVzdChcbiAgICAgICAgICByZWdFeHBDcmVhdGUoXG4gICAgICAgICAgICAnPC8oJyArIGFycmF5Sm9pbihvYmplY3RLZXlzKEZPUkJJRF9DT05URU5UUyksICd8JykgKyAnKScsXG4gICAgICAgICAgICAnaSdcbiAgICAgICAgICApLFxuICAgICAgICAgIHZhbHVlXG4gICAgICAgIClcbiAgICAgICkge1xuICAgICAgICBfcmVtb3ZlQXR0cmlidXRlKG5hbWUsIGN1cnJlbnROb2RlKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8qIFNhbml0aXplIGF0dHJpYnV0ZSBjb250ZW50IHRvIGJlIHRlbXBsYXRlLXNhZmUgKi9cbiAgICAgIGlmIChTQUZFX0ZPUl9URU1QTEFURVMpIHtcbiAgICAgICAgdmFsdWUgPSBzdHJpbmdSZXBsYWNlKHZhbHVlLCBNVVNUQUNIRV9FWFBSLCAnICcpO1xuICAgICAgICB2YWx1ZSA9IHN0cmluZ1JlcGxhY2UodmFsdWUsIEVSQl9FWFBSLCAnICcpO1xuICAgICAgfVxuXG4gICAgICAvKiBJcyBgdmFsdWVgIHZhbGlkIGZvciB0aGlzIGF0dHJpYnV0ZT8gKi9cbiAgICAgIGNvbnN0IGxjVGFnID0gY3VycmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmICghX2lzVmFsaWRBdHRyaWJ1dGUobGNUYWcsIGxjTmFtZSwgdmFsdWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvKiBIYW5kbGUgaW52YWxpZCBkYXRhLSogYXR0cmlidXRlIHNldCBieSB0cnktY2F0Y2hpbmcgaXQgKi9cbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChuYW1lc3BhY2VVUkkpIHtcbiAgICAgICAgICBjdXJyZW50Tm9kZS5zZXRBdHRyaWJ1dGVOUyhuYW1lc3BhY2VVUkksIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvKiBGYWxsYmFjayB0byBzZXRBdHRyaWJ1dGUoKSBmb3IgYnJvd3Nlci11bnJlY29nbml6ZWQgbmFtZXNwYWNlcyBlLmcuIFwieC1zY2hlbWFcIi4gKi9cbiAgICAgICAgICBjdXJyZW50Tm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXJyYXlQb3AoRE9NUHVyaWZ5LnJlbW92ZWQpO1xuICAgICAgfSBjYXRjaCAoXykge31cbiAgICB9XG5cbiAgICAvKiBFeGVjdXRlIGEgaG9vayBpZiBwcmVzZW50ICovXG4gICAgX2V4ZWN1dGVIb29rKCdhZnRlclNhbml0aXplQXR0cmlidXRlcycsIGN1cnJlbnROb2RlLCBudWxsKTtcbiAgfTtcblxuICAvKipcbiAgICogX3Nhbml0aXplU2hhZG93RE9NXG4gICAqXG4gICAqIEBwYXJhbSAge0RvY3VtZW50RnJhZ21lbnR9IGZyYWdtZW50IHRvIGl0ZXJhdGUgb3ZlciByZWN1cnNpdmVseVxuICAgKi9cbiAgY29uc3QgX3Nhbml0aXplU2hhZG93RE9NID0gZnVuY3Rpb24gKGZyYWdtZW50KSB7XG4gICAgbGV0IHNoYWRvd05vZGU7XG4gICAgY29uc3Qgc2hhZG93SXRlcmF0b3IgPSBfY3JlYXRlSXRlcmF0b3IoZnJhZ21lbnQpO1xuXG4gICAgLyogRXhlY3V0ZSBhIGhvb2sgaWYgcHJlc2VudCAqL1xuICAgIF9leGVjdXRlSG9vaygnYmVmb3JlU2FuaXRpemVTaGFkb3dET00nLCBmcmFnbWVudCwgbnVsbCk7XG5cbiAgICB3aGlsZSAoKHNoYWRvd05vZGUgPSBzaGFkb3dJdGVyYXRvci5uZXh0Tm9kZSgpKSkge1xuICAgICAgLyogRXhlY3V0ZSBhIGhvb2sgaWYgcHJlc2VudCAqL1xuICAgICAgX2V4ZWN1dGVIb29rKCd1cG9uU2FuaXRpemVTaGFkb3dOb2RlJywgc2hhZG93Tm9kZSwgbnVsbCk7XG5cbiAgICAgIC8qIFNhbml0aXplIHRhZ3MgYW5kIGVsZW1lbnRzICovXG4gICAgICBpZiAoX3Nhbml0aXplRWxlbWVudHMoc2hhZG93Tm9kZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8qIERlZXAgc2hhZG93IERPTSBkZXRlY3RlZCAqL1xuICAgICAgaWYgKHNoYWRvd05vZGUuY29udGVudCBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpIHtcbiAgICAgICAgX3Nhbml0aXplU2hhZG93RE9NKHNoYWRvd05vZGUuY29udGVudCk7XG4gICAgICB9XG5cbiAgICAgIC8qIENoZWNrIGF0dHJpYnV0ZXMsIHNhbml0aXplIGlmIG5lY2Vzc2FyeSAqL1xuICAgICAgX3Nhbml0aXplQXR0cmlidXRlcyhzaGFkb3dOb2RlKTtcbiAgICB9XG5cbiAgICAvKiBFeGVjdXRlIGEgaG9vayBpZiBwcmVzZW50ICovXG4gICAgX2V4ZWN1dGVIb29rKCdhZnRlclNhbml0aXplU2hhZG93RE9NJywgZnJhZ21lbnQsIG51bGwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTYW5pdGl6ZVxuICAgKiBQdWJsaWMgbWV0aG9kIHByb3ZpZGluZyBjb3JlIHNhbml0YXRpb24gZnVuY3Rpb25hbGl0eVxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ3xOb2RlfSBkaXJ0eSBzdHJpbmcgb3IgRE9NIG5vZGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuICBET01QdXJpZnkuc2FuaXRpemUgPSBmdW5jdGlvbiAoZGlydHksIGNmZykge1xuICAgIGxldCBib2R5O1xuICAgIGxldCBpbXBvcnRlZE5vZGU7XG4gICAgbGV0IGN1cnJlbnROb2RlO1xuICAgIGxldCBvbGROb2RlO1xuICAgIGxldCByZXR1cm5Ob2RlO1xuICAgIC8qIE1ha2Ugc3VyZSB3ZSBoYXZlIGEgc3RyaW5nIHRvIHNhbml0aXplLlxuICAgICAgRE8gTk9UIHJldHVybiBlYXJseSwgYXMgdGhpcyB3aWxsIHJldHVybiB0aGUgd3JvbmcgdHlwZSBpZlxuICAgICAgdGhlIHVzZXIgaGFzIHJlcXVlc3RlZCBhIERPTSBvYmplY3QgcmF0aGVyIHRoYW4gYSBzdHJpbmcgKi9cbiAgICBpZiAoIWRpcnR5KSB7XG4gICAgICBkaXJ0eSA9ICc8IS0tPic7XG4gICAgfVxuXG4gICAgLyogU3RyaW5naWZ5LCBpbiBjYXNlIGRpcnR5IGlzIGFuIG9iamVjdCAqL1xuICAgIGlmICh0eXBlb2YgZGlydHkgIT09ICdzdHJpbmcnICYmICFfaXNOb2RlKGRpcnR5KSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5lZ2F0ZWQtY29uZGl0aW9uXG4gICAgICBpZiAodHlwZW9mIGRpcnR5LnRvU3RyaW5nICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IHR5cGVFcnJvckNyZWF0ZSgndG9TdHJpbmcgaXMgbm90IGEgZnVuY3Rpb24nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpcnR5ID0gZGlydHkudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBkaXJ0eSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aHJvdyB0eXBlRXJyb3JDcmVhdGUoJ2RpcnR5IGlzIG5vdCBhIHN0cmluZywgYWJvcnRpbmcnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qIENoZWNrIHdlIGNhbiBydW4uIE90aGVyd2lzZSBmYWxsIGJhY2sgb3IgaWdub3JlICovXG4gICAgaWYgKCFET01QdXJpZnkuaXNTdXBwb3J0ZWQpIHtcbiAgICAgIGlmIChcbiAgICAgICAgdHlwZW9mIHdpbmRvdy50b1N0YXRpY0hUTUwgPT09ICdvYmplY3QnIHx8XG4gICAgICAgIHR5cGVvZiB3aW5kb3cudG9TdGF0aWNIVE1MID09PSAnZnVuY3Rpb24nXG4gICAgICApIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkaXJ0eSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByZXR1cm4gd2luZG93LnRvU3RhdGljSFRNTChkaXJ0eSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX2lzTm9kZShkaXJ0eSkpIHtcbiAgICAgICAgICByZXR1cm4gd2luZG93LnRvU3RhdGljSFRNTChkaXJ0eS5vdXRlckhUTUwpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkaXJ0eTtcbiAgICB9XG5cbiAgICAvKiBBc3NpZ24gY29uZmlnIHZhcnMgKi9cbiAgICBpZiAoIVNFVF9DT05GSUcpIHtcbiAgICAgIF9wYXJzZUNvbmZpZyhjZmcpO1xuICAgIH1cblxuICAgIC8qIENsZWFuIHVwIHJlbW92ZWQgZWxlbWVudHMgKi9cbiAgICBET01QdXJpZnkucmVtb3ZlZCA9IFtdO1xuXG4gICAgLyogQ2hlY2sgaWYgZGlydHkgaXMgY29ycmVjdGx5IHR5cGVkIGZvciBJTl9QTEFDRSAqL1xuICAgIGlmICh0eXBlb2YgZGlydHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICBJTl9QTEFDRSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChJTl9QTEFDRSkge1xuICAgICAgLyogTm8gc3BlY2lhbCBoYW5kbGluZyBuZWNlc3NhcnkgZm9yIGluLXBsYWNlIHNhbml0aXphdGlvbiAqL1xuICAgIH0gZWxzZSBpZiAoZGlydHkgaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgICAvKiBJZiBkaXJ0eSBpcyBhIERPTSBlbGVtZW50LCBhcHBlbmQgdG8gYW4gZW1wdHkgZG9jdW1lbnQgdG8gYXZvaWRcbiAgICAgICAgIGVsZW1lbnRzIGJlaW5nIHN0cmlwcGVkIGJ5IHRoZSBwYXJzZXIgKi9cbiAgICAgIGJvZHkgPSBfaW5pdERvY3VtZW50KCc8IS0tPicpO1xuICAgICAgaW1wb3J0ZWROb2RlID0gYm9keS5vd25lckRvY3VtZW50LmltcG9ydE5vZGUoZGlydHksIHRydWUpO1xuICAgICAgaWYgKGltcG9ydGVkTm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBpbXBvcnRlZE5vZGUubm9kZU5hbWUgPT09ICdCT0RZJykge1xuICAgICAgICAvKiBOb2RlIGlzIGFscmVhZHkgYSBib2R5LCB1c2UgYXMgaXMgKi9cbiAgICAgICAgYm9keSA9IGltcG9ydGVkTm9kZTtcbiAgICAgIH0gZWxzZSBpZiAoaW1wb3J0ZWROb2RlLm5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICAgICAgYm9keSA9IGltcG9ydGVkTm9kZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL3ByZWZlci1ub2RlLWFwcGVuZFxuICAgICAgICBib2R5LmFwcGVuZENoaWxkKGltcG9ydGVkTm9kZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIEV4aXQgZGlyZWN0bHkgaWYgd2UgaGF2ZSBub3RoaW5nIHRvIGRvICovXG4gICAgICBpZiAoXG4gICAgICAgICFSRVRVUk5fRE9NICYmXG4gICAgICAgICFTQUZFX0ZPUl9URU1QTEFURVMgJiZcbiAgICAgICAgIVdIT0xFX0RPQ1VNRU5UICYmXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL3ByZWZlci1pbmNsdWRlc1xuICAgICAgICBkaXJ0eS5pbmRleE9mKCc8JykgPT09IC0xXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHRydXN0ZWRUeXBlc1BvbGljeSAmJiBSRVRVUk5fVFJVU1RFRF9UWVBFXG4gICAgICAgICAgPyB0cnVzdGVkVHlwZXNQb2xpY3kuY3JlYXRlSFRNTChkaXJ0eSlcbiAgICAgICAgICA6IGRpcnR5O1xuICAgICAgfVxuXG4gICAgICAvKiBJbml0aWFsaXplIHRoZSBkb2N1bWVudCB0byB3b3JrIG9uICovXG4gICAgICBib2R5ID0gX2luaXREb2N1bWVudChkaXJ0eSk7XG5cbiAgICAgIC8qIENoZWNrIHdlIGhhdmUgYSBET00gbm9kZSBmcm9tIHRoZSBkYXRhICovXG4gICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgcmV0dXJuIFJFVFVSTl9ET00gPyBudWxsIDogZW1wdHlIVE1MO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qIFJlbW92ZSBmaXJzdCBlbGVtZW50IG5vZGUgKG91cnMpIGlmIEZPUkNFX0JPRFkgaXMgc2V0ICovXG4gICAgaWYgKGJvZHkgJiYgRk9SQ0VfQk9EWSkge1xuICAgICAgX2ZvcmNlUmVtb3ZlKGJvZHkuZmlyc3RDaGlsZCk7XG4gICAgfVxuXG4gICAgLyogR2V0IG5vZGUgaXRlcmF0b3IgKi9cbiAgICBjb25zdCBub2RlSXRlcmF0b3IgPSBfY3JlYXRlSXRlcmF0b3IoSU5fUExBQ0UgPyBkaXJ0eSA6IGJvZHkpO1xuXG4gICAgLyogTm93IHN0YXJ0IGl0ZXJhdGluZyBvdmVyIHRoZSBjcmVhdGVkIGRvY3VtZW50ICovXG4gICAgd2hpbGUgKChjdXJyZW50Tm9kZSA9IG5vZGVJdGVyYXRvci5uZXh0Tm9kZSgpKSkge1xuICAgICAgLyogRml4IElFJ3Mgc3RyYW5nZSBiZWhhdmlvciB3aXRoIG1hbmlwdWxhdGVkIHRleHROb2RlcyAjODkgKi9cbiAgICAgIGlmIChjdXJyZW50Tm9kZS5ub2RlVHlwZSA9PT0gMyAmJiBjdXJyZW50Tm9kZSA9PT0gb2xkTm9kZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLyogU2FuaXRpemUgdGFncyBhbmQgZWxlbWVudHMgKi9cbiAgICAgIGlmIChfc2FuaXRpemVFbGVtZW50cyhjdXJyZW50Tm9kZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8qIFNoYWRvdyBET00gZGV0ZWN0ZWQsIHNhbml0aXplIGl0ICovXG4gICAgICBpZiAoY3VycmVudE5vZGUuY29udGVudCBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpIHtcbiAgICAgICAgX3Nhbml0aXplU2hhZG93RE9NKGN1cnJlbnROb2RlLmNvbnRlbnQpO1xuICAgICAgfVxuXG4gICAgICAvKiBDaGVjayBhdHRyaWJ1dGVzLCBzYW5pdGl6ZSBpZiBuZWNlc3NhcnkgKi9cbiAgICAgIF9zYW5pdGl6ZUF0dHJpYnV0ZXMoY3VycmVudE5vZGUpO1xuXG4gICAgICBvbGROb2RlID0gY3VycmVudE5vZGU7XG4gICAgfVxuXG4gICAgb2xkTm9kZSA9IG51bGw7XG5cbiAgICAvKiBJZiB3ZSBzYW5pdGl6ZWQgYGRpcnR5YCBpbi1wbGFjZSwgcmV0dXJuIGl0LiAqL1xuICAgIGlmIChJTl9QTEFDRSkge1xuICAgICAgcmV0dXJuIGRpcnR5O1xuICAgIH1cblxuICAgIC8qIFJldHVybiBzYW5pdGl6ZWQgc3RyaW5nIG9yIERPTSAqL1xuICAgIGlmIChSRVRVUk5fRE9NKSB7XG4gICAgICBpZiAoUkVUVVJOX0RPTV9GUkFHTUVOVCkge1xuICAgICAgICByZXR1cm5Ob2RlID0gY3JlYXRlRG9jdW1lbnRGcmFnbWVudC5jYWxsKGJvZHkub3duZXJEb2N1bWVudCk7XG5cbiAgICAgICAgd2hpbGUgKGJvZHkuZmlyc3RDaGlsZCkge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL3ByZWZlci1ub2RlLWFwcGVuZFxuICAgICAgICAgIHJldHVybk5vZGUuYXBwZW5kQ2hpbGQoYm9keS5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuTm9kZSA9IGJvZHk7XG4gICAgICB9XG5cbiAgICAgIGlmIChSRVRVUk5fRE9NX0lNUE9SVCkge1xuICAgICAgICAvKlxuICAgICAgICAgIEFkb3B0Tm9kZSgpIGlzIG5vdCB1c2VkIGJlY2F1c2UgaW50ZXJuYWwgc3RhdGUgaXMgbm90IHJlc2V0XG4gICAgICAgICAgKGUuZy4gdGhlIHBhc3QgbmFtZXMgbWFwIG9mIGEgSFRNTEZvcm1FbGVtZW50KSwgdGhpcyBpcyBzYWZlXG4gICAgICAgICAgaW4gdGhlb3J5IGJ1dCB3ZSB3b3VsZCByYXRoZXIgbm90IHJpc2sgYW5vdGhlciBhdHRhY2sgdmVjdG9yLlxuICAgICAgICAgIFRoZSBzdGF0ZSB0aGF0IGlzIGNsb25lZCBieSBpbXBvcnROb2RlKCkgaXMgZXhwbGljaXRseSBkZWZpbmVkXG4gICAgICAgICAgYnkgdGhlIHNwZWNzLlxuICAgICAgICAqL1xuICAgICAgICByZXR1cm5Ob2RlID0gaW1wb3J0Tm9kZS5jYWxsKG9yaWdpbmFsRG9jdW1lbnQsIHJldHVybk5vZGUsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0dXJuTm9kZTtcbiAgICB9XG5cbiAgICBsZXQgc2VyaWFsaXplZEhUTUwgPSBXSE9MRV9ET0NVTUVOVCA/IGJvZHkub3V0ZXJIVE1MIDogYm9keS5pbm5lckhUTUw7XG5cbiAgICAvKiBTYW5pdGl6ZSBmaW5hbCBzdHJpbmcgdGVtcGxhdGUtc2FmZSAqL1xuICAgIGlmIChTQUZFX0ZPUl9URU1QTEFURVMpIHtcbiAgICAgIHNlcmlhbGl6ZWRIVE1MID0gc3RyaW5nUmVwbGFjZShzZXJpYWxpemVkSFRNTCwgTVVTVEFDSEVfRVhQUiwgJyAnKTtcbiAgICAgIHNlcmlhbGl6ZWRIVE1MID0gc3RyaW5nUmVwbGFjZShzZXJpYWxpemVkSFRNTCwgRVJCX0VYUFIsICcgJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydXN0ZWRUeXBlc1BvbGljeSAmJiBSRVRVUk5fVFJVU1RFRF9UWVBFXG4gICAgICA/IHRydXN0ZWRUeXBlc1BvbGljeS5jcmVhdGVIVE1MKHNlcmlhbGl6ZWRIVE1MKVxuICAgICAgOiBzZXJpYWxpemVkSFRNTDtcbiAgfTtcblxuICAvKipcbiAgICogUHVibGljIG1ldGhvZCB0byBzZXQgdGhlIGNvbmZpZ3VyYXRpb24gb25jZVxuICAgKiBzZXRDb25maWdcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGNmZyBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgKi9cbiAgRE9NUHVyaWZ5LnNldENvbmZpZyA9IGZ1bmN0aW9uIChjZmcpIHtcbiAgICBfcGFyc2VDb25maWcoY2ZnKTtcbiAgICBTRVRfQ09ORklHID0gdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICogUHVibGljIG1ldGhvZCB0byByZW1vdmUgdGhlIGNvbmZpZ3VyYXRpb25cbiAgICogY2xlYXJDb25maWdcbiAgICpcbiAgICovXG4gIERPTVB1cmlmeS5jbGVhckNvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICBDT05GSUcgPSBudWxsO1xuICAgIFNFVF9DT05GSUcgPSBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogUHVibGljIG1ldGhvZCB0byBjaGVjayBpZiBhbiBhdHRyaWJ1dGUgdmFsdWUgaXMgdmFsaWQuXG4gICAqIFVzZXMgbGFzdCBzZXQgY29uZmlnLCBpZiBhbnkuIE90aGVyd2lzZSwgdXNlcyBjb25maWcgZGVmYXVsdHMuXG4gICAqIGlzVmFsaWRBdHRyaWJ1dGVcbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSB0YWcgVGFnIG5hbWUgb2YgY29udGFpbmluZyBlbGVtZW50LlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGF0dHIgQXR0cmlidXRlIG5hbWUuXG4gICAqIEBwYXJhbSAge3N0cmluZ30gdmFsdWUgQXR0cmlidXRlIHZhbHVlLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyB2YWxpZC4gT3RoZXJ3aXNlLCByZXR1cm5zIGZhbHNlLlxuICAgKi9cbiAgRE9NUHVyaWZ5LmlzVmFsaWRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAodGFnLCBhdHRyLCB2YWx1ZSkge1xuICAgIC8qIEluaXRpYWxpemUgc2hhcmVkIGNvbmZpZyB2YXJzIGlmIG5lY2Vzc2FyeS4gKi9cbiAgICBpZiAoIUNPTkZJRykge1xuICAgICAgX3BhcnNlQ29uZmlnKHt9KTtcbiAgICB9XG5cbiAgICBjb25zdCBsY1RhZyA9IHN0cmluZ1RvTG93ZXJDYXNlKHRhZyk7XG4gICAgY29uc3QgbGNOYW1lID0gc3RyaW5nVG9Mb3dlckNhc2UoYXR0cik7XG4gICAgcmV0dXJuIF9pc1ZhbGlkQXR0cmlidXRlKGxjVGFnLCBsY05hbWUsIHZhbHVlKTtcbiAgfTtcblxuICAvKipcbiAgICogQWRkSG9va1xuICAgKiBQdWJsaWMgbWV0aG9kIHRvIGFkZCBET01QdXJpZnkgaG9va3NcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGVudHJ5UG9pbnQgZW50cnkgcG9pbnQgZm9yIHRoZSBob29rIHRvIGFkZFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBob29rRnVuY3Rpb24gZnVuY3Rpb24gdG8gZXhlY3V0ZVxuICAgKi9cbiAgRE9NUHVyaWZ5LmFkZEhvb2sgPSBmdW5jdGlvbiAoZW50cnlQb2ludCwgaG9va0Z1bmN0aW9uKSB7XG4gICAgaWYgKHR5cGVvZiBob29rRnVuY3Rpb24gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBob29rc1tlbnRyeVBvaW50XSA9IGhvb2tzW2VudHJ5UG9pbnRdIHx8IFtdO1xuICAgIGFycmF5UHVzaChob29rc1tlbnRyeVBvaW50XSwgaG9va0Z1bmN0aW9uKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlSG9va1xuICAgKiBQdWJsaWMgbWV0aG9kIHRvIHJlbW92ZSBhIERPTVB1cmlmeSBob29rIGF0IGEgZ2l2ZW4gZW50cnlQb2ludFxuICAgKiAocG9wcyBpdCBmcm9tIHRoZSBzdGFjayBvZiBob29rcyBpZiBtb3JlIGFyZSBwcmVzZW50KVxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZW50cnlQb2ludCBlbnRyeSBwb2ludCBmb3IgdGhlIGhvb2sgdG8gcmVtb3ZlXG4gICAqL1xuICBET01QdXJpZnkucmVtb3ZlSG9vayA9IGZ1bmN0aW9uIChlbnRyeVBvaW50KSB7XG4gICAgaWYgKGhvb2tzW2VudHJ5UG9pbnRdKSB7XG4gICAgICBhcnJheVBvcChob29rc1tlbnRyeVBvaW50XSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmVIb29rc1xuICAgKiBQdWJsaWMgbWV0aG9kIHRvIHJlbW92ZSBhbGwgRE9NUHVyaWZ5IGhvb2tzIGF0IGEgZ2l2ZW4gZW50cnlQb2ludFxuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGVudHJ5UG9pbnQgZW50cnkgcG9pbnQgZm9yIHRoZSBob29rcyB0byByZW1vdmVcbiAgICovXG4gIERPTVB1cmlmeS5yZW1vdmVIb29rcyA9IGZ1bmN0aW9uIChlbnRyeVBvaW50KSB7XG4gICAgaWYgKGhvb2tzW2VudHJ5UG9pbnRdKSB7XG4gICAgICBob29rc1tlbnRyeVBvaW50XSA9IFtdO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlQWxsSG9va3NcbiAgICogUHVibGljIG1ldGhvZCB0byByZW1vdmUgYWxsIERPTVB1cmlmeSBob29rc1xuICAgKlxuICAgKi9cbiAgRE9NUHVyaWZ5LnJlbW92ZUFsbEhvb2tzID0gZnVuY3Rpb24gKCkge1xuICAgIGhvb2tzID0ge307XG4gIH07XG5cbiAgcmV0dXJuIERPTVB1cmlmeTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlRE9NUHVyaWZ5KCk7XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNoR0E7QUFDQTtBQXVIQTtBQWlEQTtBQTBCQTtBQWdDQTtBQ25PQTtBQThHQTtBQXNMQTtBQXdEQTtBQUNBO0FDNVZBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDWUE7QUFBQTtBQUFBO0FBRUE7Ozs7Ozs7Ozs7QUFRQTtBQUNBO0FBSUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBREE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFwQ0E7QUFDQTtBQXNDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTs7Ozs7O0FBSUE7QUFFQTs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBeEJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUF3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQXhEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFxRUE7QUFFQTs7OztBQUdBO0FBMUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBMEZBOzs7OztBQUtBO0FBQ0E7QUFBQTtBQUNBO0FBUUE7QUFDQTtBQUFBO0FBQ0E7QUFPQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQUE7QUFFQTs7OztBQUdBO0FBRUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUFBO0FBRUE7OztBQUVBO0FBRUE7Ozs7O0FBSUE7QUFFQTs7O0FBRUE7QUFFQTs7Ozs7QUFJQTtBQUVBOzs7QUFFQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUVBOzs7QUFFQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQTJCQTtBQUNBO0FBQUE7QUFDQTtBQVNBO0FBQ0E7QUFBQTtBQUNBO0FBZ0JBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFLQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQUlBO0FBSUE7QUFJQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUE1SEE7QUErSEE7Ozs7Ozs7QUFLQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBUEE7QUFVQTs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQU1BO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBYkE7QUFnQkE7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFJQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBREE7QUExQ0E7QUE2Q0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUpBO0FBREE7QUFRQTtBQUVBOzs7Ozs7OztBQU1BO0FBQ0E7QUFLQTtBQUxBO0FBREE7QUFZQTs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQWpCQTtBQW9CQTs7Ozs7Ozs7QUFNQTtBQUNBO0FBREE7QUFTQTs7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFMQTtBQVVBOzs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFGQTtBQUtBO0FBQ0E7QUFDQTtBQURBO0FBSUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFGQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQURBO0FBSUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQU1BO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBT0E7QUFLQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUE1R0E7QUErR0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUVBOzs7Ozs7QUFJQTtBQU1BO0FBRUE7QUFIQTtBQW1DQTtBQUNBO0FBRUE7QUF6REE7QUE0REE7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQVJBO0FBV0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBWEE7QUFjQTtBQUNBO0FBTUE7QUFUQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQVVBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFVQTtBQUVBO0FBQ0E7QUFDQTtBQURBO0FBcElBO0FBdUlBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQURBO0FBMUJBO0FBNkJBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQURBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFiQTtBQWVBO0FBQ0E7QUFLQTtBQUVBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQUVBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXpLQTtBQThLQTs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFBQTtBQUZBO0FBS0E7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFGQTtBQUtBOzs7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQVdBOzs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBU0E7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFNQTs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBTUE7Ozs7Ozs7QUFLQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/dompurify/dist/purify.js\n");

/***/ }),

/***/ "./node_modules/ethers/dist/ethers.umd.js":
/*!************************************************!*\
  !*** ./node_modules/ethers/dist/ethers.umd.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, process, setImmediate) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj){\"@babel/helpers - typeof\";if(typeof Symbol===\"function\"&&typeof Symbol.iterator===\"symbol\"){_typeof=function _typeof(obj){return typeof obj;};}else{_typeof=function _typeof(obj){return obj&&typeof Symbol===\"function\"&&obj.constructor===Symbol&&obj!==Symbol.prototype?\"symbol\":typeof obj;};}return _typeof(obj);}(function(global,factory){( false?undefined:_typeof(exports))==='object'&&typeof module!=='undefined'?factory(exports): true?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)):(undefined);})(this,function(exports){'use strict';var commonjsGlobal=typeof globalThis!=='undefined'?globalThis:typeof window!=='undefined'?window:typeof global!=='undefined'?global:typeof self!=='undefined'?self:{};function commonjsRequire(){throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');}function unwrapExports(x){return x&&x.__esModule&&Object.prototype.hasOwnProperty.call(x,'default')?x['default']:x;}function createCommonjsModule(fn,module){return module={exports:{}},fn(module,module.exports),module.exports;}function getCjsExportFromNamespace(n){return n&&n['default']||n;}var _nodeResolve_empty={};var _nodeResolve_empty$1=/*#__PURE__*/Object.freeze({'default':_nodeResolve_empty});var require$$0=getCjsExportFromNamespace(_nodeResolve_empty$1);var bn=createCommonjsModule(function(module){(function(module,exports){'use strict';// Utils\nfunction assert(val,msg){if(!val)throw new Error(msg||'Assertion failed');}// Could use `inherits` module, but don't want to move from single file\n// architecture yet.\nfunction inherits(ctor,superCtor){ctor.super_=superCtor;var TempCtor=function TempCtor(){};TempCtor.prototype=superCtor.prototype;ctor.prototype=new TempCtor();ctor.prototype.constructor=ctor;}// BN\nfunction BN(number,base,endian){if(BN.isBN(number)){return number;}this.negative=0;this.words=null;this.length=0;// Reduction context\nthis.red=null;if(number!==null){if(base==='le'||base==='be'){endian=base;base=10;}this._init(number||0,base||10,endian||'be');}}if(_typeof(module)==='object'){module.exports=BN;}else{exports.BN=BN;}BN.BN=BN;BN.wordSize=26;var Buffer;try{Buffer=require$$0.Buffer;}catch(e){}BN.isBN=function isBN(num){if(num instanceof BN){return true;}return num!==null&&_typeof(num)==='object'&&num.constructor.wordSize===BN.wordSize&&Array.isArray(num.words);};BN.max=function max(left,right){if(left.cmp(right)>0)return left;return right;};BN.min=function min(left,right){if(left.cmp(right)<0)return left;return right;};BN.prototype._init=function init(number,base,endian){if(typeof number==='number'){return this._initNumber(number,base,endian);}if(_typeof(number)==='object'){return this._initArray(number,base,endian);}if(base==='hex'){base=16;}assert(base===(base|0)&&base>=2&&base<=36);number=number.toString().replace(/\\s+/g,'');var start=0;if(number[0]==='-'){start++;}if(base===16){this._parseHex(number,start);}else{this._parseBase(number,base,start);}if(number[0]==='-'){this.negative=1;}this.strip();if(endian!=='le')return;this._initArray(this.toArray(),base,endian);};BN.prototype._initNumber=function _initNumber(number,base,endian){if(number<0){this.negative=1;number=-number;}if(number<0x4000000){this.words=[number&0x3ffffff];this.length=1;}else if(number<0x10000000000000){this.words=[number&0x3ffffff,number/0x4000000&0x3ffffff];this.length=2;}else{assert(number<0x20000000000000);// 2 ^ 53 (unsafe)\nthis.words=[number&0x3ffffff,number/0x4000000&0x3ffffff,1];this.length=3;}if(endian!=='le')return;// Reverse the bytes\nthis._initArray(this.toArray(),base,endian);};BN.prototype._initArray=function _initArray(number,base,endian){// Perhaps a Uint8Array\nassert(typeof number.length==='number');if(number.length<=0){this.words=[0];this.length=1;return this;}this.length=Math.ceil(number.length/3);this.words=new Array(this.length);for(var i=0;i<this.length;i++){this.words[i]=0;}var j,w;var off=0;if(endian==='be'){for(i=number.length-1,j=0;i>=0;i-=3){w=number[i]|number[i-1]<<8|number[i-2]<<16;this.words[j]|=w<<off&0x3ffffff;this.words[j+1]=w>>>26-off&0x3ffffff;off+=24;if(off>=26){off-=26;j++;}}}else if(endian==='le'){for(i=0,j=0;i<number.length;i+=3){w=number[i]|number[i+1]<<8|number[i+2]<<16;this.words[j]|=w<<off&0x3ffffff;this.words[j+1]=w>>>26-off&0x3ffffff;off+=24;if(off>=26){off-=26;j++;}}}return this.strip();};function parseHex(str,start,end){var r=0;var len=Math.min(str.length,end);for(var i=start;i<len;i++){var c=str.charCodeAt(i)-48;r<<=4;// 'a' - 'f'\nif(c>=49&&c<=54){r|=c-49+0xa;// 'A' - 'F'\n}else if(c>=17&&c<=22){r|=c-17+0xa;// '0' - '9'\n}else{r|=c&0xf;}}return r;}BN.prototype._parseHex=function _parseHex(number,start){// Create possibly bigger array to ensure that it fits the number\nthis.length=Math.ceil((number.length-start)/6);this.words=new Array(this.length);for(var i=0;i<this.length;i++){this.words[i]=0;}var j,w;// Scan 24-bit chunks and add them to the number\nvar off=0;for(i=number.length-6,j=0;i>=start;i-=6){w=parseHex(number,i,i+6);this.words[j]|=w<<off&0x3ffffff;// NOTE: `0x3fffff` is intentional here, 26bits max shift + 24bit hex limb\nthis.words[j+1]|=w>>>26-off&0x3fffff;off+=24;if(off>=26){off-=26;j++;}}if(i+6!==start){w=parseHex(number,start,i+6);this.words[j]|=w<<off&0x3ffffff;this.words[j+1]|=w>>>26-off&0x3fffff;}this.strip();};function parseBase(str,start,end,mul){var r=0;var len=Math.min(str.length,end);for(var i=start;i<len;i++){var c=str.charCodeAt(i)-48;r*=mul;// 'a'\nif(c>=49){r+=c-49+0xa;// 'A'\n}else if(c>=17){r+=c-17+0xa;// '0' - '9'\n}else{r+=c;}}return r;}BN.prototype._parseBase=function _parseBase(number,base,start){// Initialize as zero\nthis.words=[0];this.length=1;// Find length of limb in base\nfor(var limbLen=0,limbPow=1;limbPow<=0x3ffffff;limbPow*=base){limbLen++;}limbLen--;limbPow=limbPow/base|0;var total=number.length-start;var mod=total%limbLen;var end=Math.min(total,total-mod)+start;var word=0;for(var i=start;i<end;i+=limbLen){word=parseBase(number,i,i+limbLen,base);this.imuln(limbPow);if(this.words[0]+word<0x4000000){this.words[0]+=word;}else{this._iaddn(word);}}if(mod!==0){var pow=1;word=parseBase(number,i,number.length,base);for(i=0;i<mod;i++){pow*=base;}this.imuln(pow);if(this.words[0]+word<0x4000000){this.words[0]+=word;}else{this._iaddn(word);}}};BN.prototype.copy=function copy(dest){dest.words=new Array(this.length);for(var i=0;i<this.length;i++){dest.words[i]=this.words[i];}dest.length=this.length;dest.negative=this.negative;dest.red=this.red;};BN.prototype.clone=function clone(){var r=new BN(null);this.copy(r);return r;};BN.prototype._expand=function _expand(size){while(this.length<size){this.words[this.length++]=0;}return this;};// Remove leading `0` from `this`\nBN.prototype.strip=function strip(){while(this.length>1&&this.words[this.length-1]===0){this.length--;}return this._normSign();};BN.prototype._normSign=function _normSign(){// -0 = 0\nif(this.length===1&&this.words[0]===0){this.negative=0;}return this;};BN.prototype.inspect=function inspect(){return(this.red?'<BN-R: ':'<BN: ')+this.toString(16)+'>';};/*\n\n\t  var zeros = [];\n\t  var groupSizes = [];\n\t  var groupBases = [];\n\n\t  var s = '';\n\t  var i = -1;\n\t  while (++i < BN.wordSize) {\n\t    zeros[i] = s;\n\t    s += '0';\n\t  }\n\t  groupSizes[0] = 0;\n\t  groupSizes[1] = 0;\n\t  groupBases[0] = 0;\n\t  groupBases[1] = 0;\n\t  var base = 2 - 1;\n\t  while (++base < 36 + 1) {\n\t    var groupSize = 0;\n\t    var groupBase = 1;\n\t    while (groupBase < (1 << BN.wordSize) / base) {\n\t      groupBase *= base;\n\t      groupSize += 1;\n\t    }\n\t    groupSizes[base] = groupSize;\n\t    groupBases[base] = groupBase;\n\t  }\n\n\t  */var zeros=['','0','00','000','0000','00000','000000','0000000','00000000','000000000','0000000000','00000000000','000000000000','0000000000000','00000000000000','000000000000000','0000000000000000','00000000000000000','000000000000000000','0000000000000000000','00000000000000000000','000000000000000000000','0000000000000000000000','00000000000000000000000','000000000000000000000000','0000000000000000000000000'];var groupSizes=[0,0,25,16,12,11,10,9,8,8,7,7,7,7,6,6,6,6,6,6,6,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5];var groupBases=[0,0,33554432,43046721,16777216,48828125,60466176,40353607,16777216,43046721,10000000,19487171,35831808,62748517,7529536,11390625,16777216,24137569,34012224,47045881,64000000,4084101,5153632,6436343,7962624,9765625,11881376,14348907,17210368,20511149,24300000,28629151,33554432,39135393,45435424,52521875,60466176];BN.prototype.toString=function toString(base,padding){base=base||10;padding=padding|0||1;var out;if(base===16||base==='hex'){out='';var off=0;var carry=0;for(var i=0;i<this.length;i++){var w=this.words[i];var word=((w<<off|carry)&0xffffff).toString(16);carry=w>>>24-off&0xffffff;if(carry!==0||i!==this.length-1){out=zeros[6-word.length]+word+out;}else{out=word+out;}off+=2;if(off>=26){off-=26;i--;}}if(carry!==0){out=carry.toString(16)+out;}while(out.length%padding!==0){out='0'+out;}if(this.negative!==0){out='-'+out;}return out;}if(base===(base|0)&&base>=2&&base<=36){// var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));\nvar groupSize=groupSizes[base];// var groupBase = Math.pow(base, groupSize);\nvar groupBase=groupBases[base];out='';var c=this.clone();c.negative=0;while(!c.isZero()){var r=c.modn(groupBase).toString(base);c=c.idivn(groupBase);if(!c.isZero()){out=zeros[groupSize-r.length]+r+out;}else{out=r+out;}}if(this.isZero()){out='0'+out;}while(out.length%padding!==0){out='0'+out;}if(this.negative!==0){out='-'+out;}return out;}assert(false,'Base should be between 2 and 36');};BN.prototype.toNumber=function toNumber(){var ret=this.words[0];if(this.length===2){ret+=this.words[1]*0x4000000;}else if(this.length===3&&this.words[2]===0x01){// NOTE: at this stage it is known that the top bit is set\nret+=0x10000000000000+this.words[1]*0x4000000;}else if(this.length>2){assert(false,'Number can only safely store up to 53 bits');}return this.negative!==0?-ret:ret;};BN.prototype.toJSON=function toJSON(){return this.toString(16);};BN.prototype.toBuffer=function toBuffer(endian,length){assert(typeof Buffer!=='undefined');return this.toArrayLike(Buffer,endian,length);};BN.prototype.toArray=function toArray(endian,length){return this.toArrayLike(Array,endian,length);};BN.prototype.toArrayLike=function toArrayLike(ArrayType,endian,length){var byteLength=this.byteLength();var reqLength=length||Math.max(1,byteLength);assert(byteLength<=reqLength,'byte array longer than desired length');assert(reqLength>0,'Requested array length <= 0');this.strip();var littleEndian=endian==='le';var res=new ArrayType(reqLength);var b,i;var q=this.clone();if(!littleEndian){// Assume big-endian\nfor(i=0;i<reqLength-byteLength;i++){res[i]=0;}for(i=0;!q.isZero();i++){b=q.andln(0xff);q.iushrn(8);res[reqLength-i-1]=b;}}else{for(i=0;!q.isZero();i++){b=q.andln(0xff);q.iushrn(8);res[i]=b;}for(;i<reqLength;i++){res[i]=0;}}return res;};if(Math.clz32){BN.prototype._countBits=function _countBits(w){return 32-Math.clz32(w);};}else{BN.prototype._countBits=function _countBits(w){var t=w;var r=0;if(t>=0x1000){r+=13;t>>>=13;}if(t>=0x40){r+=7;t>>>=7;}if(t>=0x8){r+=4;t>>>=4;}if(t>=0x02){r+=2;t>>>=2;}return r+t;};}BN.prototype._zeroBits=function _zeroBits(w){// Short-cut\nif(w===0)return 26;var t=w;var r=0;if((t&0x1fff)===0){r+=13;t>>>=13;}if((t&0x7f)===0){r+=7;t>>>=7;}if((t&0xf)===0){r+=4;t>>>=4;}if((t&0x3)===0){r+=2;t>>>=2;}if((t&0x1)===0){r++;}return r;};// Return number of used bits in a BN\nBN.prototype.bitLength=function bitLength(){var w=this.words[this.length-1];var hi=this._countBits(w);return(this.length-1)*26+hi;};function toBitArray(num){var w=new Array(num.bitLength());for(var bit=0;bit<w.length;bit++){var off=bit/26|0;var wbit=bit%26;w[bit]=(num.words[off]&1<<wbit)>>>wbit;}return w;}// Number of trailing zero bits\nBN.prototype.zeroBits=function zeroBits(){if(this.isZero())return 0;var r=0;for(var i=0;i<this.length;i++){var b=this._zeroBits(this.words[i]);r+=b;if(b!==26)break;}return r;};BN.prototype.byteLength=function byteLength(){return Math.ceil(this.bitLength()/8);};BN.prototype.toTwos=function toTwos(width){if(this.negative!==0){return this.abs().inotn(width).iaddn(1);}return this.clone();};BN.prototype.fromTwos=function fromTwos(width){if(this.testn(width-1)){return this.notn(width).iaddn(1).ineg();}return this.clone();};BN.prototype.isNeg=function isNeg(){return this.negative!==0;};// Return negative clone of `this`\nBN.prototype.neg=function neg(){return this.clone().ineg();};BN.prototype.ineg=function ineg(){if(!this.isZero()){this.negative^=1;}return this;};// Or `num` with `this` in-place\nBN.prototype.iuor=function iuor(num){while(this.length<num.length){this.words[this.length++]=0;}for(var i=0;i<num.length;i++){this.words[i]=this.words[i]|num.words[i];}return this.strip();};BN.prototype.ior=function ior(num){assert((this.negative|num.negative)===0);return this.iuor(num);};// Or `num` with `this`\nBN.prototype.or=function or(num){if(this.length>num.length)return this.clone().ior(num);return num.clone().ior(this);};BN.prototype.uor=function uor(num){if(this.length>num.length)return this.clone().iuor(num);return num.clone().iuor(this);};// And `num` with `this` in-place\nBN.prototype.iuand=function iuand(num){// b = min-length(num, this)\nvar b;if(this.length>num.length){b=num;}else{b=this;}for(var i=0;i<b.length;i++){this.words[i]=this.words[i]&num.words[i];}this.length=b.length;return this.strip();};BN.prototype.iand=function iand(num){assert((this.negative|num.negative)===0);return this.iuand(num);};// And `num` with `this`\nBN.prototype.and=function and(num){if(this.length>num.length)return this.clone().iand(num);return num.clone().iand(this);};BN.prototype.uand=function uand(num){if(this.length>num.length)return this.clone().iuand(num);return num.clone().iuand(this);};// Xor `num` with `this` in-place\nBN.prototype.iuxor=function iuxor(num){// a.length > b.length\nvar a;var b;if(this.length>num.length){a=this;b=num;}else{a=num;b=this;}for(var i=0;i<b.length;i++){this.words[i]=a.words[i]^b.words[i];}if(this!==a){for(;i<a.length;i++){this.words[i]=a.words[i];}}this.length=a.length;return this.strip();};BN.prototype.ixor=function ixor(num){assert((this.negative|num.negative)===0);return this.iuxor(num);};// Xor `num` with `this`\nBN.prototype.xor=function xor(num){if(this.length>num.length)return this.clone().ixor(num);return num.clone().ixor(this);};BN.prototype.uxor=function uxor(num){if(this.length>num.length)return this.clone().iuxor(num);return num.clone().iuxor(this);};// Not ``this`` with ``width`` bitwidth\nBN.prototype.inotn=function inotn(width){assert(typeof width==='number'&&width>=0);var bytesNeeded=Math.ceil(width/26)|0;var bitsLeft=width%26;// Extend the buffer with leading zeroes\nthis._expand(bytesNeeded);if(bitsLeft>0){bytesNeeded--;}// Handle complete words\nfor(var i=0;i<bytesNeeded;i++){this.words[i]=~this.words[i]&0x3ffffff;}// Handle the residue\nif(bitsLeft>0){this.words[i]=~this.words[i]&0x3ffffff>>26-bitsLeft;}// And remove leading zeroes\nreturn this.strip();};BN.prototype.notn=function notn(width){return this.clone().inotn(width);};// Set `bit` of `this`\nBN.prototype.setn=function setn(bit,val){assert(typeof bit==='number'&&bit>=0);var off=bit/26|0;var wbit=bit%26;this._expand(off+1);if(val){this.words[off]=this.words[off]|1<<wbit;}else{this.words[off]=this.words[off]&~(1<<wbit);}return this.strip();};// Add `num` to `this` in-place\nBN.prototype.iadd=function iadd(num){var r;// negative + positive\nif(this.negative!==0&&num.negative===0){this.negative=0;r=this.isub(num);this.negative^=1;return this._normSign();// positive + negative\n}else if(this.negative===0&&num.negative!==0){num.negative=0;r=this.isub(num);num.negative=1;return r._normSign();}// a.length > b.length\nvar a,b;if(this.length>num.length){a=this;b=num;}else{a=num;b=this;}var carry=0;for(var i=0;i<b.length;i++){r=(a.words[i]|0)+(b.words[i]|0)+carry;this.words[i]=r&0x3ffffff;carry=r>>>26;}for(;carry!==0&&i<a.length;i++){r=(a.words[i]|0)+carry;this.words[i]=r&0x3ffffff;carry=r>>>26;}this.length=a.length;if(carry!==0){this.words[this.length]=carry;this.length++;// Copy the rest of the words\n}else if(a!==this){for(;i<a.length;i++){this.words[i]=a.words[i];}}return this;};// Add `num` to `this`\nBN.prototype.add=function add(num){var res;if(num.negative!==0&&this.negative===0){num.negative=0;res=this.sub(num);num.negative^=1;return res;}else if(num.negative===0&&this.negative!==0){this.negative=0;res=num.sub(this);this.negative=1;return res;}if(this.length>num.length)return this.clone().iadd(num);return num.clone().iadd(this);};// Subtract `num` from `this` in-place\nBN.prototype.isub=function isub(num){// this - (-num) = this + num\nif(num.negative!==0){num.negative=0;var r=this.iadd(num);num.negative=1;return r._normSign();// -this - num = -(this + num)\n}else if(this.negative!==0){this.negative=0;this.iadd(num);this.negative=1;return this._normSign();}// At this point both numbers are positive\nvar cmp=this.cmp(num);// Optimization - zeroify\nif(cmp===0){this.negative=0;this.length=1;this.words[0]=0;return this;}// a > b\nvar a,b;if(cmp>0){a=this;b=num;}else{a=num;b=this;}var carry=0;for(var i=0;i<b.length;i++){r=(a.words[i]|0)-(b.words[i]|0)+carry;carry=r>>26;this.words[i]=r&0x3ffffff;}for(;carry!==0&&i<a.length;i++){r=(a.words[i]|0)+carry;carry=r>>26;this.words[i]=r&0x3ffffff;}// Copy rest of the words\nif(carry===0&&i<a.length&&a!==this){for(;i<a.length;i++){this.words[i]=a.words[i];}}this.length=Math.max(this.length,i);if(a!==this){this.negative=1;}return this.strip();};// Subtract `num` from `this`\nBN.prototype.sub=function sub(num){return this.clone().isub(num);};function smallMulTo(self,num,out){out.negative=num.negative^self.negative;var len=self.length+num.length|0;out.length=len;len=len-1|0;// Peel one iteration (compiler can't do it, because of code complexity)\nvar a=self.words[0]|0;var b=num.words[0]|0;var r=a*b;var lo=r&0x3ffffff;var carry=r/0x4000000|0;out.words[0]=lo;for(var k=1;k<len;k++){// Sum all words with the same `i + j = k` and accumulate `ncarry`,\n// note that ncarry could be >= 0x3ffffff\nvar ncarry=carry>>>26;var rword=carry&0x3ffffff;var maxJ=Math.min(k,num.length-1);for(var j=Math.max(0,k-self.length+1);j<=maxJ;j++){var i=k-j|0;a=self.words[i]|0;b=num.words[j]|0;r=a*b+rword;ncarry+=r/0x4000000|0;rword=r&0x3ffffff;}out.words[k]=rword|0;carry=ncarry|0;}if(carry!==0){out.words[k]=carry|0;}else{out.length--;}return out.strip();}// TODO(indutny): it may be reasonable to omit it for users who don't need\n// to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit\n// multiplication (like elliptic secp256k1).\nvar comb10MulTo=function comb10MulTo(self,num,out){var a=self.words;var b=num.words;var o=out.words;var c=0;var lo;var mid;var hi;var a0=a[0]|0;var al0=a0&0x1fff;var ah0=a0>>>13;var a1=a[1]|0;var al1=a1&0x1fff;var ah1=a1>>>13;var a2=a[2]|0;var al2=a2&0x1fff;var ah2=a2>>>13;var a3=a[3]|0;var al3=a3&0x1fff;var ah3=a3>>>13;var a4=a[4]|0;var al4=a4&0x1fff;var ah4=a4>>>13;var a5=a[5]|0;var al5=a5&0x1fff;var ah5=a5>>>13;var a6=a[6]|0;var al6=a6&0x1fff;var ah6=a6>>>13;var a7=a[7]|0;var al7=a7&0x1fff;var ah7=a7>>>13;var a8=a[8]|0;var al8=a8&0x1fff;var ah8=a8>>>13;var a9=a[9]|0;var al9=a9&0x1fff;var ah9=a9>>>13;var b0=b[0]|0;var bl0=b0&0x1fff;var bh0=b0>>>13;var b1=b[1]|0;var bl1=b1&0x1fff;var bh1=b1>>>13;var b2=b[2]|0;var bl2=b2&0x1fff;var bh2=b2>>>13;var b3=b[3]|0;var bl3=b3&0x1fff;var bh3=b3>>>13;var b4=b[4]|0;var bl4=b4&0x1fff;var bh4=b4>>>13;var b5=b[5]|0;var bl5=b5&0x1fff;var bh5=b5>>>13;var b6=b[6]|0;var bl6=b6&0x1fff;var bh6=b6>>>13;var b7=b[7]|0;var bl7=b7&0x1fff;var bh7=b7>>>13;var b8=b[8]|0;var bl8=b8&0x1fff;var bh8=b8>>>13;var b9=b[9]|0;var bl9=b9&0x1fff;var bh9=b9>>>13;out.negative=self.negative^num.negative;out.length=19;/* k = 0 */lo=Math.imul(al0,bl0);mid=Math.imul(al0,bh0);mid=mid+Math.imul(ah0,bl0)|0;hi=Math.imul(ah0,bh0);var w0=(c+lo|0)+((mid&0x1fff)<<13)|0;c=(hi+(mid>>>13)|0)+(w0>>>26)|0;w0&=0x3ffffff;/* k = 1 */lo=Math.imul(al1,bl0);mid=Math.imul(al1,bh0);mid=mid+Math.imul(ah1,bl0)|0;hi=Math.imul(ah1,bh0);lo=lo+Math.imul(al0,bl1)|0;mid=mid+Math.imul(al0,bh1)|0;mid=mid+Math.imul(ah0,bl1)|0;hi=hi+Math.imul(ah0,bh1)|0;var w1=(c+lo|0)+((mid&0x1fff)<<13)|0;c=(hi+(mid>>>13)|0)+(w1>>>26)|0;w1&=0x3ffffff;/* k = 2 */lo=Math.imul(al2,bl0);mid=Math.imul(al2,bh0);mid=mid+Math.imul(ah2,bl0)|0;hi=Math.imul(ah2,bh0);lo=lo+Math.imul(al1,bl1)|0;mid=mid+Math.imul(al1,bh1)|0;mid=mid+Math.imul(ah1,bl1)|0;hi=hi+Math.imul(ah1,bh1)|0;lo=lo+Math.imul(al0,bl2)|0;mid=mid+Math.imul(al0,bh2)|0;mid=mid+Math.imul(ah0,bl2)|0;hi=hi+Math.imul(ah0,bh2)|0;var w2=(c+lo|0)+((mid&0x1fff)<<13)|0;c=(hi+(mid>>>13)|0)+(w2>>>26)|0;w2&=0x3ffffff;/* k = 3 */lo=Math.imul(al3,bl0);mid=Math.imul(al3,bh0);mid=mid+Math.imul(ah3,bl0)|0;hi=Math.imul(ah3,bh0);lo=lo+Math.imul(al2,bl1)|0;mid=mid+Math.imul(al2,bh1)|0;mid=mid+Math.imul(ah2,bl1)|0;hi=hi+Math.imul(ah2,bh1)|0;lo=lo+Math.imul(al1,bl2)|0;mid=mid+Math.imul(al1,bh2)|0;mid=mid+Math.imul(ah1,bl2)|0;hi=hi+Math.imul(ah1,bh2)|0;lo=lo+Math.imul(al0,bl3)|0;mid=mid+Math.imul(al0,bh3)|0;mid=mid+Math.imul(ah0,bl3)|0;hi=hi+Math.imul(ah0,bh3)|0;var w3=(c+lo|0)+((mid&0x1fff)<<13)|0;c=(hi+(mid>>>13)|0)+(w3>>>26)|0;w3&=0x3ffffff;/* k = 4 */lo=Math.imul(al4,bl0);mid=Math.imul(al4,bh0);mid=mid+Math.imul(ah4,bl0)|0;hi=Math.imul(ah4,bh0);lo=lo+Math.imul(al3,bl1)|0;mid=mid+Math.imul(al3,bh1)|0;mid=mid+Math.imul(ah3,bl1)|0;hi=hi+Math.imul(ah3,bh1)|0;lo=lo+Math.imul(al2,bl2)|0;mid=mid+Math.imul(al2,bh2)|0;mid=mid+Math.imul(ah2,bl2)|0;hi=hi+Math.imul(ah2,bh2)|0;lo=lo+Math.imul(al1,bl3)|0;mid=mid+Math.imul(al1,bh3)|0;mid=mid+Math.imul(ah1,bl3)|0;hi=hi+Math.imul(ah1,bh3)|0;lo=lo+Math.imul(al0,bl4)|0;mid=mid+Math.imul(al0,bh4)|0;mid=mid+Math.imul(ah0,bl4)|0;hi=hi+Math.imul(ah0,bh4)|0;var w4=(c+lo|0)+((mid&0x1fff)<<13)|0;c=(hi+(mid>>>13)|0)+(w4>>>26)|0;w4&=0x3ffffff;/* k = 5 */lo=Math.imul(al5,bl0);mid=Math.imul(al5,bh0);mid=mid+Math.imul(ah5,bl0)|0;hi=Math.imul(ah5,bh0);lo=lo+Math.imul(al4,bl1)|0;mid=mid+Math.imul(al4,bh1)|0;mid=mid+Math.imul(ah4,bl1)|0;hi=hi+Math.imul(ah4,bh1)|0;lo=lo+Math.imul(al3,bl2)|0;mid=mid+Math.imul(al3,bh2)|0;mid=mid+Math.imul(ah3,bl2)|0;hi=hi+Math.imul(ah3,bh2)|0;lo=lo+Math.imul(al2,bl3)|0;mid=mid+Math.imul(al2,bh3)|0;mid=mid+Math.imul(ah2,bl3)|0;hi=hi+Math.imul(ah2,bh3)|0;lo=lo+Math.imul(al1,bl4)|0;mid=mid+Math.imul(al1,bh4)|0;mid=mid+Math.imul(ah1,bl4)|0;hi=hi+Math.imul(ah1,bh4)|0;lo=lo+Math.imul(al0,bl5)|0;mid=mid+Math.imul(al0,bh5)|0;mid=mid+Math.imul(ah0,bl5)|0;hi=hi+Math.imul(ah0,bh5)|0;var w5=(c+lo|0)+((mid&0x1fff)<<13)|0;c=(hi+(mid>>>13)|0)+(w5>>>26)|0;w5&=0x3ffffff;/* k = 6 */lo=Math.imul(al6,bl0);mid=Math.imul(al6,bh0);mid=mid+Math.imul(ah6,bl0)|0;hi=Math.imul(ah6,bh0);lo=lo+Math.imul(al5,bl1)|0;mid=mid+Math.imul(al5,bh1)|0;mid=mid+Math.imul(ah5,bl1)|0;hi=hi+Math.imul(ah5,bh1)|0;lo=lo+Math.imul(al4,bl2)|0;mid=mid+Math.imul(al4,bh2)|0;mid=mid+Math.imul(ah4,bl2)|0;hi=hi+Math.imul(ah4,bh2)|0;lo=lo+Math.imul(al3,bl3)|0;mid=mid+Math.imul(al3,bh3)|0;mid=mid+Math.imul(ah3,bl3)|0;hi=hi+Math.imul(ah3,bh3)|0;lo=lo+Math.imul(al2,bl4)|0;mid=mid+Math.imul(al2,bh4)|0;mid=mid+Math.imul(ah2,bl4)|0;hi=hi+Math.imul(ah2,bh4)|0;lo=lo+Math.imul(al1,bl5)|0;mid=mid+Math.imul(al1,bh5)|0;mid=mid+Math.imul(ah1,bl5)|0;hi=hi+Math.imul(ah1,bh5)|0;lo=lo+Math.imul(al0,bl6)|0;mid=mid+Math.imul(al0,bh6)|0;mid=mid+Math.imul(ah0,bl6)|0;hi=hi+Math.imul(ah0,bh6)|0;var w6=(c+lo|0)+((mid&0x1fff)<<13)|0;c=(hi+(mid>>>13)|0)+(w6>>>26)|0;w6&=0x3ffffff;/* k = 7 */lo=Math.imul(al7,bl0);mid=Math.imul(al7,bh0);mid=mid+Math.imul(ah7,bl0)|0;hi=Math.imul(ah7,bh0);lo=lo+Math.imul(al6,bl1)|0;mid=mid+Math.imul(al6,bh1)|0;mid=mid+Math.imul(ah6,bl1)|0;hi=hi+Math.imul(ah6,bh1)|0;lo=lo+Math.imul(al5,bl2)|0;mid=mid+Math.imul(al5,bh2)|0;mid=mid+Math.imul(ah5,bl2)|0;hi=hi+Math.imul(ah5,bh2)|0;lo=lo+Math.imul(al4,bl3)|0;mid=mid+Math.imul(al4,bh3)|0;mid=mid+Math.imul(ah4,bl3)|0;hi=hi+Math.imul(ah4,bh3)|0;lo=lo+Math.imul(al3,bl4)|0;mid=mid+Math.imul(al3,bh4)|0;mid=mid+Math.imul(ah3,bl4)|0;hi=hi+Math.imul(ah3,bh4)|0;lo=lo+Math.imul(al2,bl5)|0;mid=mid+Math.imul(al2,bh5)|0;mid=mid+Math.imul(ah2,bl5)|0;hi=hi+Math.imul(ah2,bh5)|0;lo=lo+Math.imul(al1,bl6)|0;mid=mid+Math.imul(al1,bh6)|0;mid=mid+Math.imul(ah1,bl6)|0;hi=hi+Math.imul(ah1,bh6)|0;lo=lo+Math.imul(al0,bl7)|0;mid=mid+Math.imul(al0,bh7)|0;mid=mid+Math.imul(ah0,bl7)|0;hi=hi+Math.imul(ah0,bh7)|0;var w7=(c+lo|0)+((mid&0x1fff)<<13)|0;c=(hi+(mid>>>13)|0)+(w7>>>26)|0;w7&=0x3ffffff;/* k = 8 */lo=Math.imul(al8,bl0);mid=Math.imul(al8,bh0);mid=mid+Math.imul(ah8,bl0)|0;hi=Math.imul(ah8,bh0);lo=lo+Math.imul(al7,bl1)|0;mid=mid+Math.imul(al7,bh1)|0;mid=mid+Math.imul(ah7,bl1)|0;hi=hi+Math.imul(ah7,bh1)|0;lo=lo+Math.imul(al6,bl2)|0;mid=mid+Math.imul(al6,bh2)|0;mid=mid+Math.imul(ah6,bl2)|0;hi=hi+Math.imul(ah6,bh2)|0;lo=lo+Math.imul(al5,bl3)|0;mid=mid+Math.imul(al5,bh3)|0;mid=mid+Math.imul(ah5,bl3)|0;hi=hi+Math.imul(ah5,bh3)|0;lo=lo+Math.imul(al4,bl4)|0;mid=mid+Math.imul(al4,bh4)|0;mid=mid+Math.imul(ah4,bl4)|0;hi=hi+Math.imul(ah4,bh4)|0;lo=lo+Math.imul(al3,bl5)|0;mid=mid+Math.imul(al3,bh5)|0;mid=mid+Math.imul(ah3,bl5)|0;hi=hi+Math.imul(ah3,bh5)|0;lo=lo+Math.imul(al2,bl6)|0;mid=mid+Math.imul(al2,bh6)|0;mid=mid+Math.imul(ah2,bl6)|0;hi=hi+Math.imul(ah2,bh6)|0;lo=lo+Math.imul(al1,bl7)|0;mid=mid+Math.imul(al1,bh7)|0;mid=mid+Math.imul(ah1,bl7)|0;hi=hi+Math.imul(ah1,bh7)|0;lo=lo+Math.imul(al0,bl8)|0;mid=mid+Math.imul(al0,bh8)|0;mid=mid+Math.imul(ah0,bl8)|0;hi=hi+Math.imul(ah0,bh8)|0;var w8=(c+lo|0)+((mid&0x1fff)<<13)|0;c=(hi+(mid>>>13)|0)+(w8>>>26)|0;w8&=0x3ffffff;/* k = 9 */lo=Math.imul(al9,bl0);mid=Math.imul(al9,bh0);mid=mid+Math.imul(ah9,bl0)|0;hi=Math.imul(ah9,bh0);lo=lo+Math.imul(al8,bl1)|0;mid=mid+Math.imul(al8,bh1)|0;mid=mid+Math.imul(ah8,bl1)|0;hi=hi+Math.imul(ah8,bh1)|0;lo=lo+Math.imul(al7,bl2)|0;mid=mid+Math.imul(al7,bh2)|0;mid=mid+Math.imul(ah7,bl2)|0;hi=hi+Math.imul(ah7,bh2)|0;lo=lo+Math.imul(al6,bl3)|0;mid=mid+Math.imul(al6,bh3)|0;mid=mid+Math.imul(ah6,bl3)|0;hi=hi+Math.imul(ah6,bh3)|0;lo=lo+Math.imul(al5,bl4)|0;mid=mid+Math.imul(al5,bh4)|0;mid=mid+Math.imul(ah5,bl4)|0;hi=hi+Math.imul(ah5,bh4)|0;lo=lo+Math.imul(al4,bl5)|0;mid=mid+Math.imul(al4,bh5)|0;mid=mid+Math.imul(ah4,bl5)|0;hi=hi+Math.imul(ah4,bh5)|0;lo=lo+Math.imul(al3,bl6)|0;mid=mid+Math.imul(al3,bh6)|0;mid=mid+Math.imul(ah3,bl6)|0;hi=hi+Math.imul(ah3,bh6)|0;lo=lo+Math.imul(al2,bl7)|0;mid=mid+Math.imul(al2,bh7)|0;mid=mid+Math.imul(ah2,bl7)|0;hi=hi+Math.imul(ah2,bh7)|0;lo=lo+Math.imul(al1,bl8)|0;mid=mid+Math.imul(al1,bh8)|0;mid=mid+Math.imul(ah1,bl8)|0;hi=hi+Math.imul(ah1,bh8)|0;lo=lo+Math.imul(al0,bl9)|0;mid=mid+Math.imul(al0,bh9)|0;mid=mid+Math.imul(ah0,bl9)|0;hi=hi+Math.imul(ah0,bh9)|0;var w9=(c+lo|0)+((mid&0x1fff)<<13)|0;c=(hi+(mid>>>13)|0)+(w9>>>26)|0;w9&=0x3ffffff;/* k = 10 */lo=Math.imul(al9,bl1);mid=Math.imul(al9,bh1);mid=mid+Math.imul(ah9,bl1)|0;hi=Math.imul(ah9,bh1);lo=lo+Math.imul(al8,bl2)|0;mid=mid+Math.imul(al8,bh2)|0;mid=mid+Math.imul(ah8,bl2)|0;hi=hi+Math.imul(ah8,bh2)|0;lo=lo+Math.imul(al7,bl3)|0;mid=mid+Math.imul(al7,bh3)|0;mid=mid+Math.imul(ah7,bl3)|0;hi=hi+Math.imul(ah7,bh3)|0;lo=lo+Math.imul(al6,bl4)|0;mid=mid+Math.imul(al6,bh4)|0;mid=mid+Math.imul(ah6,bl4)|0;hi=hi+Math.imul(ah6,bh4)|0;lo=lo+Math.imul(al5,bl5)|0;mid=mid+Math.imul(al5,bh5)|0;mid=mid+Math.imul(ah5,bl5)|0;hi=hi+Math.imul(ah5,bh5)|0;lo=lo+Math.imul(al4,bl6)|0;mid=mid+Math.imul(al4,bh6)|0;mid=mid+Math.imul(ah4,bl6)|0;hi=hi+Math.imul(ah4,bh6)|0;lo=lo+Math.imul(al3,bl7)|0;mid=mid+Math.imul(al3,bh7)|0;mid=mid+Math.imul(ah3,bl7)|0;hi=hi+Math.imul(ah3,bh7)|0;lo=lo+Math.imul(al2,bl8)|0;mid=mid+Math.imul(al2,bh8)|0;mid=mid+Math.imul(ah2,bl8)|0;hi=hi+Math.imul(ah2,bh8)|0;lo=lo+Math.imul(al1,bl9)|0;mid=mid+Math.imul(al1,bh9)|0;mid=mid+Math.imul(ah1,bl9)|0;hi=hi+Math.imul(ah1,bh9)|0;var w10=(c+lo|0)+((mid&0x1fff)<<13)|0;c=(hi+(mid>>>13)|0)+(w10>>>26)|0;w10&=0x3ffffff;/* k = 11 */lo=Math.imul(al9,bl2);mid=Math.imul(al9,bh2);mid=mid+Math.imul(ah9,bl2)|0;hi=Math.imul(ah9,bh2);lo=lo+Math.imul(al8,bl3)|0;mid=mid+Math.imul(al8,bh3)|0;mid=mid+Math.imul(ah8,bl3)|0;hi=hi+Math.imul(ah8,bh3)|0;lo=lo+Math.imul(al7,bl4)|0;mid=mid+Math.imul(al7,bh4)|0;mid=mid+Math.imul(ah7,bl4)|0;hi=hi+Math.imul(ah7,bh4)|0;lo=lo+Math.imul(al6,bl5)|0;mid=mid+Math.imul(al6,bh5)|0;mid=mid+Math.imul(ah6,bl5)|0;hi=hi+Math.imul(ah6,bh5)|0;lo=lo+Math.imul(al5,bl6)|0;mid=mid+Math.imul(al5,bh6)|0;mid=mid+Math.imul(ah5,bl6)|0;hi=hi+Math.imul(ah5,bh6)|0;lo=lo+Math.imul(al4,bl7)|0;mid=mid+Math.imul(al4,bh7)|0;mid=mid+Math.imul(ah4,bl7)|0;hi=hi+Math.imul(ah4,bh7)|0;lo=lo+Math.imul(al3,bl8)|0;mid=mid+Math.imul(al3,bh8)|0;mid=mid+Math.imul(ah3,bl8)|0;hi=hi+Math.imul(ah3,bh8)|0;lo=lo+Math.imul(al2,bl9)|0;mid=mid+Math.imul(al2,bh9)|0;mid=mid+Math.imul(ah2,bl9)|0;hi=hi+Math.imul(ah2,bh9)|0;var w11=(c+lo|0)+((mid&0x1fff)<<13)|0;c=(hi+(mid>>>13)|0)+(w11>>>26)|0;w11&=0x3ffffff;/* k = 12 */lo=Math.imul(al9,bl3);mid=Math.imul(al9,bh3);mid=mid+Math.imul(ah9,bl3)|0;hi=Math.imul(ah9,bh3);lo=lo+Math.imul(al8,bl4)|0;mid=mid+Math.imul(al8,bh4)|0;mid=mid+Math.imul(ah8,bl4)|0;hi=hi+Math.imul(ah8,bh4)|0;lo=lo+Math.imul(al7,bl5)|0;mid=mid+Math.imul(al7,bh5)|0;mid=mid+Math.imul(ah7,bl5)|0;hi=hi+Math.imul(ah7,bh5)|0;lo=lo+Math.imul(al6,bl6)|0;mid=mid+Math.imul(al6,bh6)|0;mid=mid+Math.imul(ah6,bl6)|0;hi=hi+Math.imul(ah6,bh6)|0;lo=lo+Math.imul(al5,bl7)|0;mid=mid+Math.imul(al5,bh7)|0;mid=mid+Math.imul(ah5,bl7)|0;hi=hi+Math.imul(ah5,bh7)|0;lo=lo+Math.imul(al4,bl8)|0;mid=mid+Math.imul(al4,bh8)|0;mid=mid+Math.imul(ah4,bl8)|0;hi=hi+Math.imul(ah4,bh8)|0;lo=lo+Math.imul(al3,bl9)|0;mid=mid+Math.imul(al3,bh9)|0;mid=mid+Math.imul(ah3,bl9)|0;hi=hi+Math.imul(ah3,bh9)|0;var w12=(c+lo|0)+((mid&0x1fff)<<13)|0;c=(hi+(mid>>>13)|0)+(w12>>>26)|0;w12&=0x3ffffff;/* k = 13 */lo=Math.imul(al9,bl4);mid=Math.imul(al9,bh4);mid=mid+Math.imul(ah9,bl4)|0;hi=Math.imul(ah9,bh4);lo=lo+Math.imul(al8,bl5)|0;mid=mid+Math.imul(al8,bh5)|0;mid=mid+Math.imul(ah8,bl5)|0;hi=hi+Math.imul(ah8,bh5)|0;lo=lo+Math.imul(al7,bl6)|0;mid=mid+Math.imul(al7,bh6)|0;mid=mid+Math.imul(ah7,bl6)|0;hi=hi+Math.imul(ah7,bh6)|0;lo=lo+Math.imul(al6,bl7)|0;mid=mid+Math.imul(al6,bh7)|0;mid=mid+Math.imul(ah6,bl7)|0;hi=hi+Math.imul(ah6,bh7)|0;lo=lo+Math.imul(al5,bl8)|0;mid=mid+Math.imul(al5,bh8)|0;mid=mid+Math.imul(ah5,bl8)|0;hi=hi+Math.imul(ah5,bh8)|0;lo=lo+Math.imul(al4,bl9)|0;mid=mid+Math.imul(al4,bh9)|0;mid=mid+Math.imul(ah4,bl9)|0;hi=hi+Math.imul(ah4,bh9)|0;var w13=(c+lo|0)+((mid&0x1fff)<<13)|0;c=(hi+(mid>>>13)|0)+(w13>>>26)|0;w13&=0x3ffffff;/* k = 14 */lo=Math.imul(al9,bl5);mid=Math.imul(al9,bh5);mid=mid+Math.imul(ah9,bl5)|0;hi=Math.imul(ah9,bh5);lo=lo+Math.imul(al8,bl6)|0;mid=mid+Math.imul(al8,bh6)|0;mid=mid+Math.imul(ah8,bl6)|0;hi=hi+Math.imul(ah8,bh6)|0;lo=lo+Math.imul(al7,bl7)|0;mid=mid+Math.imul(al7,bh7)|0;mid=mid+Math.imul(ah7,bl7)|0;hi=hi+Math.imul(ah7,bh7)|0;lo=lo+Math.imul(al6,bl8)|0;mid=mid+Math.imul(al6,bh8)|0;mid=mid+Math.imul(ah6,bl8)|0;hi=hi+Math.imul(ah6,bh8)|0;lo=lo+Math.imul(al5,bl9)|0;mid=mid+Math.imul(al5,bh9)|0;mid=mid+Math.imul(ah5,bl9)|0;hi=hi+Math.imul(ah5,bh9)|0;var w14=(c+lo|0)+((mid&0x1fff)<<13)|0;c=(hi+(mid>>>13)|0)+(w14>>>26)|0;w14&=0x3ffffff;/* k = 15 */lo=Math.imul(al9,bl6);mid=Math.imul(al9,bh6);mid=mid+Math.imul(ah9,bl6)|0;hi=Math.imul(ah9,bh6);lo=lo+Math.imul(al8,bl7)|0;mid=mid+Math.imul(al8,bh7)|0;mid=mid+Math.imul(ah8,bl7)|0;hi=hi+Math.imul(ah8,bh7)|0;lo=lo+Math.imul(al7,bl8)|0;mid=mid+Math.imul(al7,bh8)|0;mid=mid+Math.imul(ah7,bl8)|0;hi=hi+Math.imul(ah7,bh8)|0;lo=lo+Math.imul(al6,bl9)|0;mid=mid+Math.imul(al6,bh9)|0;mid=mid+Math.imul(ah6,bl9)|0;hi=hi+Math.imul(ah6,bh9)|0;var w15=(c+lo|0)+((mid&0x1fff)<<13)|0;c=(hi+(mid>>>13)|0)+(w15>>>26)|0;w15&=0x3ffffff;/* k = 16 */lo=Math.imul(al9,bl7);mid=Math.imul(al9,bh7);mid=mid+Math.imul(ah9,bl7)|0;hi=Math.imul(ah9,bh7);lo=lo+Math.imul(al8,bl8)|0;mid=mid+Math.imul(al8,bh8)|0;mid=mid+Math.imul(ah8,bl8)|0;hi=hi+Math.imul(ah8,bh8)|0;lo=lo+Math.imul(al7,bl9)|0;mid=mid+Math.imul(al7,bh9)|0;mid=mid+Math.imul(ah7,bl9)|0;hi=hi+Math.imul(ah7,bh9)|0;var w16=(c+lo|0)+((mid&0x1fff)<<13)|0;c=(hi+(mid>>>13)|0)+(w16>>>26)|0;w16&=0x3ffffff;/* k = 17 */lo=Math.imul(al9,bl8);mid=Math.imul(al9,bh8);mid=mid+Math.imul(ah9,bl8)|0;hi=Math.imul(ah9,bh8);lo=lo+Math.imul(al8,bl9)|0;mid=mid+Math.imul(al8,bh9)|0;mid=mid+Math.imul(ah8,bl9)|0;hi=hi+Math.imul(ah8,bh9)|0;var w17=(c+lo|0)+((mid&0x1fff)<<13)|0;c=(hi+(mid>>>13)|0)+(w17>>>26)|0;w17&=0x3ffffff;/* k = 18 */lo=Math.imul(al9,bl9);mid=Math.imul(al9,bh9);mid=mid+Math.imul(ah9,bl9)|0;hi=Math.imul(ah9,bh9);var w18=(c+lo|0)+((mid&0x1fff)<<13)|0;c=(hi+(mid>>>13)|0)+(w18>>>26)|0;w18&=0x3ffffff;o[0]=w0;o[1]=w1;o[2]=w2;o[3]=w3;o[4]=w4;o[5]=w5;o[6]=w6;o[7]=w7;o[8]=w8;o[9]=w9;o[10]=w10;o[11]=w11;o[12]=w12;o[13]=w13;o[14]=w14;o[15]=w15;o[16]=w16;o[17]=w17;o[18]=w18;if(c!==0){o[19]=c;out.length++;}return out;};// Polyfill comb\nif(!Math.imul){comb10MulTo=smallMulTo;}function bigMulTo(self,num,out){out.negative=num.negative^self.negative;out.length=self.length+num.length;var carry=0;var hncarry=0;for(var k=0;k<out.length-1;k++){// Sum all words with the same `i + j = k` and accumulate `ncarry`,\n// note that ncarry could be >= 0x3ffffff\nvar ncarry=hncarry;hncarry=0;var rword=carry&0x3ffffff;var maxJ=Math.min(k,num.length-1);for(var j=Math.max(0,k-self.length+1);j<=maxJ;j++){var i=k-j;var a=self.words[i]|0;var b=num.words[j]|0;var r=a*b;var lo=r&0x3ffffff;ncarry=ncarry+(r/0x4000000|0)|0;lo=lo+rword|0;rword=lo&0x3ffffff;ncarry=ncarry+(lo>>>26)|0;hncarry+=ncarry>>>26;ncarry&=0x3ffffff;}out.words[k]=rword;carry=ncarry;ncarry=hncarry;}if(carry!==0){out.words[k]=carry;}else{out.length--;}return out.strip();}function jumboMulTo(self,num,out){var fftm=new FFTM();return fftm.mulp(self,num,out);}BN.prototype.mulTo=function mulTo(num,out){var res;var len=this.length+num.length;if(this.length===10&&num.length===10){res=comb10MulTo(this,num,out);}else if(len<63){res=smallMulTo(this,num,out);}else if(len<1024){res=bigMulTo(this,num,out);}else{res=jumboMulTo(this,num,out);}return res;};// Cooley-Tukey algorithm for FFT\n// slightly revisited to rely on looping instead of recursion\nfunction FFTM(x,y){this.x=x;this.y=y;}FFTM.prototype.makeRBT=function makeRBT(N){var t=new Array(N);var l=BN.prototype._countBits(N)-1;for(var i=0;i<N;i++){t[i]=this.revBin(i,l,N);}return t;};// Returns binary-reversed representation of `x`\nFFTM.prototype.revBin=function revBin(x,l,N){if(x===0||x===N-1)return x;var rb=0;for(var i=0;i<l;i++){rb|=(x&1)<<l-i-1;x>>=1;}return rb;};// Performs \"tweedling\" phase, therefore 'emulating'\n// behaviour of the recursive algorithm\nFFTM.prototype.permute=function permute(rbt,rws,iws,rtws,itws,N){for(var i=0;i<N;i++){rtws[i]=rws[rbt[i]];itws[i]=iws[rbt[i]];}};FFTM.prototype.transform=function transform(rws,iws,rtws,itws,N,rbt){this.permute(rbt,rws,iws,rtws,itws,N);for(var s=1;s<N;s<<=1){var l=s<<1;var rtwdf=Math.cos(2*Math.PI/l);var itwdf=Math.sin(2*Math.PI/l);for(var p=0;p<N;p+=l){var rtwdf_=rtwdf;var itwdf_=itwdf;for(var j=0;j<s;j++){var re=rtws[p+j];var ie=itws[p+j];var ro=rtws[p+j+s];var io=itws[p+j+s];var rx=rtwdf_*ro-itwdf_*io;io=rtwdf_*io+itwdf_*ro;ro=rx;rtws[p+j]=re+ro;itws[p+j]=ie+io;rtws[p+j+s]=re-ro;itws[p+j+s]=ie-io;/* jshint maxdepth : false */if(j!==l){rx=rtwdf*rtwdf_-itwdf*itwdf_;itwdf_=rtwdf*itwdf_+itwdf*rtwdf_;rtwdf_=rx;}}}}};FFTM.prototype.guessLen13b=function guessLen13b(n,m){var N=Math.max(m,n)|1;var odd=N&1;var i=0;for(N=N/2|0;N;N=N>>>1){i++;}return 1<<i+1+odd;};FFTM.prototype.conjugate=function conjugate(rws,iws,N){if(N<=1)return;for(var i=0;i<N/2;i++){var t=rws[i];rws[i]=rws[N-i-1];rws[N-i-1]=t;t=iws[i];iws[i]=-iws[N-i-1];iws[N-i-1]=-t;}};FFTM.prototype.normalize13b=function normalize13b(ws,N){var carry=0;for(var i=0;i<N/2;i++){var w=Math.round(ws[2*i+1]/N)*0x2000+Math.round(ws[2*i]/N)+carry;ws[i]=w&0x3ffffff;if(w<0x4000000){carry=0;}else{carry=w/0x4000000|0;}}return ws;};FFTM.prototype.convert13b=function convert13b(ws,len,rws,N){var carry=0;for(var i=0;i<len;i++){carry=carry+(ws[i]|0);rws[2*i]=carry&0x1fff;carry=carry>>>13;rws[2*i+1]=carry&0x1fff;carry=carry>>>13;}// Pad with zeroes\nfor(i=2*len;i<N;++i){rws[i]=0;}assert(carry===0);assert((carry&~0x1fff)===0);};FFTM.prototype.stub=function stub(N){var ph=new Array(N);for(var i=0;i<N;i++){ph[i]=0;}return ph;};FFTM.prototype.mulp=function mulp(x,y,out){var N=2*this.guessLen13b(x.length,y.length);var rbt=this.makeRBT(N);var _=this.stub(N);var rws=new Array(N);var rwst=new Array(N);var iwst=new Array(N);var nrws=new Array(N);var nrwst=new Array(N);var niwst=new Array(N);var rmws=out.words;rmws.length=N;this.convert13b(x.words,x.length,rws,N);this.convert13b(y.words,y.length,nrws,N);this.transform(rws,_,rwst,iwst,N,rbt);this.transform(nrws,_,nrwst,niwst,N,rbt);for(var i=0;i<N;i++){var rx=rwst[i]*nrwst[i]-iwst[i]*niwst[i];iwst[i]=rwst[i]*niwst[i]+iwst[i]*nrwst[i];rwst[i]=rx;}this.conjugate(rwst,iwst,N);this.transform(rwst,iwst,rmws,_,N,rbt);this.conjugate(rmws,_,N);this.normalize13b(rmws,N);out.negative=x.negative^y.negative;out.length=x.length+y.length;return out.strip();};// Multiply `this` by `num`\nBN.prototype.mul=function mul(num){var out=new BN(null);out.words=new Array(this.length+num.length);return this.mulTo(num,out);};// Multiply employing FFT\nBN.prototype.mulf=function mulf(num){var out=new BN(null);out.words=new Array(this.length+num.length);return jumboMulTo(this,num,out);};// In-place Multiplication\nBN.prototype.imul=function imul(num){return this.clone().mulTo(num,this);};BN.prototype.imuln=function imuln(num){assert(typeof num==='number');assert(num<0x4000000);// Carry\nvar carry=0;for(var i=0;i<this.length;i++){var w=(this.words[i]|0)*num;var lo=(w&0x3ffffff)+(carry&0x3ffffff);carry>>=26;carry+=w/0x4000000|0;// NOTE: lo is 27bit maximum\ncarry+=lo>>>26;this.words[i]=lo&0x3ffffff;}if(carry!==0){this.words[i]=carry;this.length++;}return this;};BN.prototype.muln=function muln(num){return this.clone().imuln(num);};// `this` * `this`\nBN.prototype.sqr=function sqr(){return this.mul(this);};// `this` * `this` in-place\nBN.prototype.isqr=function isqr(){return this.imul(this.clone());};// Math.pow(`this`, `num`)\nBN.prototype.pow=function pow(num){var w=toBitArray(num);if(w.length===0)return new BN(1);// Skip leading zeroes\nvar res=this;for(var i=0;i<w.length;i++,res=res.sqr()){if(w[i]!==0)break;}if(++i<w.length){for(var q=res.sqr();i<w.length;i++,q=q.sqr()){if(w[i]===0)continue;res=res.mul(q);}}return res;};// Shift-left in-place\nBN.prototype.iushln=function iushln(bits){assert(typeof bits==='number'&&bits>=0);var r=bits%26;var s=(bits-r)/26;var carryMask=0x3ffffff>>>26-r<<26-r;var i;if(r!==0){var carry=0;for(i=0;i<this.length;i++){var newCarry=this.words[i]&carryMask;var c=(this.words[i]|0)-newCarry<<r;this.words[i]=c|carry;carry=newCarry>>>26-r;}if(carry){this.words[i]=carry;this.length++;}}if(s!==0){for(i=this.length-1;i>=0;i--){this.words[i+s]=this.words[i];}for(i=0;i<s;i++){this.words[i]=0;}this.length+=s;}return this.strip();};BN.prototype.ishln=function ishln(bits){// TODO(indutny): implement me\nassert(this.negative===0);return this.iushln(bits);};// Shift-right in-place\n// NOTE: `hint` is a lowest bit before trailing zeroes\n// NOTE: if `extended` is present - it will be filled with destroyed bits\nBN.prototype.iushrn=function iushrn(bits,hint,extended){assert(typeof bits==='number'&&bits>=0);var h;if(hint){h=(hint-hint%26)/26;}else{h=0;}var r=bits%26;var s=Math.min((bits-r)/26,this.length);var mask=0x3ffffff^0x3ffffff>>>r<<r;var maskedWords=extended;h-=s;h=Math.max(0,h);// Extended mode, copy masked part\nif(maskedWords){for(var i=0;i<s;i++){maskedWords.words[i]=this.words[i];}maskedWords.length=s;}if(s===0){// No-op, we should not move anything at all\n}else if(this.length>s){this.length-=s;for(i=0;i<this.length;i++){this.words[i]=this.words[i+s];}}else{this.words[0]=0;this.length=1;}var carry=0;for(i=this.length-1;i>=0&&(carry!==0||i>=h);i--){var word=this.words[i]|0;this.words[i]=carry<<26-r|word>>>r;carry=word&mask;}// Push carried bits as a mask\nif(maskedWords&&carry!==0){maskedWords.words[maskedWords.length++]=carry;}if(this.length===0){this.words[0]=0;this.length=1;}return this.strip();};BN.prototype.ishrn=function ishrn(bits,hint,extended){// TODO(indutny): implement me\nassert(this.negative===0);return this.iushrn(bits,hint,extended);};// Shift-left\nBN.prototype.shln=function shln(bits){return this.clone().ishln(bits);};BN.prototype.ushln=function ushln(bits){return this.clone().iushln(bits);};// Shift-right\nBN.prototype.shrn=function shrn(bits){return this.clone().ishrn(bits);};BN.prototype.ushrn=function ushrn(bits){return this.clone().iushrn(bits);};// Test if n bit is set\nBN.prototype.testn=function testn(bit){assert(typeof bit==='number'&&bit>=0);var r=bit%26;var s=(bit-r)/26;var q=1<<r;// Fast case: bit is much higher than all existing words\nif(this.length<=s)return false;// Check bit and return\nvar w=this.words[s];return!!(w&q);};// Return only lowers bits of number (in-place)\nBN.prototype.imaskn=function imaskn(bits){assert(typeof bits==='number'&&bits>=0);var r=bits%26;var s=(bits-r)/26;assert(this.negative===0,'imaskn works only with positive numbers');if(this.length<=s){return this;}if(r!==0){s++;}this.length=Math.min(s,this.length);if(r!==0){var mask=0x3ffffff^0x3ffffff>>>r<<r;this.words[this.length-1]&=mask;}return this.strip();};// Return only lowers bits of number\nBN.prototype.maskn=function maskn(bits){return this.clone().imaskn(bits);};// Add plain number `num` to `this`\nBN.prototype.iaddn=function iaddn(num){assert(typeof num==='number');assert(num<0x4000000);if(num<0)return this.isubn(-num);// Possible sign change\nif(this.negative!==0){if(this.length===1&&(this.words[0]|0)<num){this.words[0]=num-(this.words[0]|0);this.negative=0;return this;}this.negative=0;this.isubn(num);this.negative=1;return this;}// Add without checks\nreturn this._iaddn(num);};BN.prototype._iaddn=function _iaddn(num){this.words[0]+=num;// Carry\nfor(var i=0;i<this.length&&this.words[i]>=0x4000000;i++){this.words[i]-=0x4000000;if(i===this.length-1){this.words[i+1]=1;}else{this.words[i+1]++;}}this.length=Math.max(this.length,i+1);return this;};// Subtract plain number `num` from `this`\nBN.prototype.isubn=function isubn(num){assert(typeof num==='number');assert(num<0x4000000);if(num<0)return this.iaddn(-num);if(this.negative!==0){this.negative=0;this.iaddn(num);this.negative=1;return this;}this.words[0]-=num;if(this.length===1&&this.words[0]<0){this.words[0]=-this.words[0];this.negative=1;}else{// Carry\nfor(var i=0;i<this.length&&this.words[i]<0;i++){this.words[i]+=0x4000000;this.words[i+1]-=1;}}return this.strip();};BN.prototype.addn=function addn(num){return this.clone().iaddn(num);};BN.prototype.subn=function subn(num){return this.clone().isubn(num);};BN.prototype.iabs=function iabs(){this.negative=0;return this;};BN.prototype.abs=function abs(){return this.clone().iabs();};BN.prototype._ishlnsubmul=function _ishlnsubmul(num,mul,shift){var len=num.length+shift;var i;this._expand(len);var w;var carry=0;for(i=0;i<num.length;i++){w=(this.words[i+shift]|0)+carry;var right=(num.words[i]|0)*mul;w-=right&0x3ffffff;carry=(w>>26)-(right/0x4000000|0);this.words[i+shift]=w&0x3ffffff;}for(;i<this.length-shift;i++){w=(this.words[i+shift]|0)+carry;carry=w>>26;this.words[i+shift]=w&0x3ffffff;}if(carry===0)return this.strip();// Subtraction overflow\nassert(carry===-1);carry=0;for(i=0;i<this.length;i++){w=-(this.words[i]|0)+carry;carry=w>>26;this.words[i]=w&0x3ffffff;}this.negative=1;return this.strip();};BN.prototype._wordDiv=function _wordDiv(num,mode){var shift=this.length-num.length;var a=this.clone();var b=num;// Normalize\nvar bhi=b.words[b.length-1]|0;var bhiBits=this._countBits(bhi);shift=26-bhiBits;if(shift!==0){b=b.ushln(shift);a.iushln(shift);bhi=b.words[b.length-1]|0;}// Initialize quotient\nvar m=a.length-b.length;var q;if(mode!=='mod'){q=new BN(null);q.length=m+1;q.words=new Array(q.length);for(var i=0;i<q.length;i++){q.words[i]=0;}}var diff=a.clone()._ishlnsubmul(b,1,m);if(diff.negative===0){a=diff;if(q){q.words[m]=1;}}for(var j=m-1;j>=0;j--){var qj=(a.words[b.length+j]|0)*0x4000000+(a.words[b.length+j-1]|0);// NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max\n// (0x7ffffff)\nqj=Math.min(qj/bhi|0,0x3ffffff);a._ishlnsubmul(b,qj,j);while(a.negative!==0){qj--;a.negative=0;a._ishlnsubmul(b,1,j);if(!a.isZero()){a.negative^=1;}}if(q){q.words[j]=qj;}}if(q){q.strip();}a.strip();// Denormalize\nif(mode!=='div'&&shift!==0){a.iushrn(shift);}return{div:q||null,mod:a};};// NOTE: 1) `mode` can be set to `mod` to request mod only,\n//       to `div` to request div only, or be absent to\n//       request both div & mod\n//       2) `positive` is true if unsigned mod is requested\nBN.prototype.divmod=function divmod(num,mode,positive){assert(!num.isZero());if(this.isZero()){return{div:new BN(0),mod:new BN(0)};}var div,mod,res;if(this.negative!==0&&num.negative===0){res=this.neg().divmod(num,mode);if(mode!=='mod'){div=res.div.neg();}if(mode!=='div'){mod=res.mod.neg();if(positive&&mod.negative!==0){mod.iadd(num);}}return{div:div,mod:mod};}if(this.negative===0&&num.negative!==0){res=this.divmod(num.neg(),mode);if(mode!=='mod'){div=res.div.neg();}return{div:div,mod:res.mod};}if((this.negative&num.negative)!==0){res=this.neg().divmod(num.neg(),mode);if(mode!=='div'){mod=res.mod.neg();if(positive&&mod.negative!==0){mod.isub(num);}}return{div:res.div,mod:mod};}// Both numbers are positive at this point\n// Strip both numbers to approximate shift value\nif(num.length>this.length||this.cmp(num)<0){return{div:new BN(0),mod:this};}// Very short reduction\nif(num.length===1){if(mode==='div'){return{div:this.divn(num.words[0]),mod:null};}if(mode==='mod'){return{div:null,mod:new BN(this.modn(num.words[0]))};}return{div:this.divn(num.words[0]),mod:new BN(this.modn(num.words[0]))};}return this._wordDiv(num,mode);};// Find `this` / `num`\nBN.prototype.div=function div(num){return this.divmod(num,'div',false).div;};// Find `this` % `num`\nBN.prototype.mod=function mod(num){return this.divmod(num,'mod',false).mod;};BN.prototype.umod=function umod(num){return this.divmod(num,'mod',true).mod;};// Find Round(`this` / `num`)\nBN.prototype.divRound=function divRound(num){var dm=this.divmod(num);// Fast case - exact division\nif(dm.mod.isZero())return dm.div;var mod=dm.div.negative!==0?dm.mod.isub(num):dm.mod;var half=num.ushrn(1);var r2=num.andln(1);var cmp=mod.cmp(half);// Round down\nif(cmp<0||r2===1&&cmp===0)return dm.div;// Round up\nreturn dm.div.negative!==0?dm.div.isubn(1):dm.div.iaddn(1);};BN.prototype.modn=function modn(num){assert(num<=0x3ffffff);var p=(1<<26)%num;var acc=0;for(var i=this.length-1;i>=0;i--){acc=(p*acc+(this.words[i]|0))%num;}return acc;};// In-place division by number\nBN.prototype.idivn=function idivn(num){assert(num<=0x3ffffff);var carry=0;for(var i=this.length-1;i>=0;i--){var w=(this.words[i]|0)+carry*0x4000000;this.words[i]=w/num|0;carry=w%num;}return this.strip();};BN.prototype.divn=function divn(num){return this.clone().idivn(num);};BN.prototype.egcd=function egcd(p){assert(p.negative===0);assert(!p.isZero());var x=this;var y=p.clone();if(x.negative!==0){x=x.umod(p);}else{x=x.clone();}// A * x + B * y = x\nvar A=new BN(1);var B=new BN(0);// C * x + D * y = y\nvar C=new BN(0);var D=new BN(1);var g=0;while(x.isEven()&&y.isEven()){x.iushrn(1);y.iushrn(1);++g;}var yp=y.clone();var xp=x.clone();while(!x.isZero()){for(var i=0,im=1;(x.words[0]&im)===0&&i<26;++i,im<<=1){;}if(i>0){x.iushrn(i);while(i-->0){if(A.isOdd()||B.isOdd()){A.iadd(yp);B.isub(xp);}A.iushrn(1);B.iushrn(1);}}for(var j=0,jm=1;(y.words[0]&jm)===0&&j<26;++j,jm<<=1){;}if(j>0){y.iushrn(j);while(j-->0){if(C.isOdd()||D.isOdd()){C.iadd(yp);D.isub(xp);}C.iushrn(1);D.iushrn(1);}}if(x.cmp(y)>=0){x.isub(y);A.isub(C);B.isub(D);}else{y.isub(x);C.isub(A);D.isub(B);}}return{a:C,b:D,gcd:y.iushln(g)};};// This is reduced incarnation of the binary EEA\n// above, designated to invert members of the\n// _prime_ fields F(p) at a maximal speed\nBN.prototype._invmp=function _invmp(p){assert(p.negative===0);assert(!p.isZero());var a=this;var b=p.clone();if(a.negative!==0){a=a.umod(p);}else{a=a.clone();}var x1=new BN(1);var x2=new BN(0);var delta=b.clone();while(a.cmpn(1)>0&&b.cmpn(1)>0){for(var i=0,im=1;(a.words[0]&im)===0&&i<26;++i,im<<=1){;}if(i>0){a.iushrn(i);while(i-->0){if(x1.isOdd()){x1.iadd(delta);}x1.iushrn(1);}}for(var j=0,jm=1;(b.words[0]&jm)===0&&j<26;++j,jm<<=1){;}if(j>0){b.iushrn(j);while(j-->0){if(x2.isOdd()){x2.iadd(delta);}x2.iushrn(1);}}if(a.cmp(b)>=0){a.isub(b);x1.isub(x2);}else{b.isub(a);x2.isub(x1);}}var res;if(a.cmpn(1)===0){res=x1;}else{res=x2;}if(res.cmpn(0)<0){res.iadd(p);}return res;};BN.prototype.gcd=function gcd(num){if(this.isZero())return num.abs();if(num.isZero())return this.abs();var a=this.clone();var b=num.clone();a.negative=0;b.negative=0;// Remove common factor of two\nfor(var shift=0;a.isEven()&&b.isEven();shift++){a.iushrn(1);b.iushrn(1);}do{while(a.isEven()){a.iushrn(1);}while(b.isEven()){b.iushrn(1);}var r=a.cmp(b);if(r<0){// Swap `a` and `b` to make `a` always bigger than `b`\nvar t=a;a=b;b=t;}else if(r===0||b.cmpn(1)===0){break;}a.isub(b);}while(true);return b.iushln(shift);};// Invert number in the field F(num)\nBN.prototype.invm=function invm(num){return this.egcd(num).a.umod(num);};BN.prototype.isEven=function isEven(){return(this.words[0]&1)===0;};BN.prototype.isOdd=function isOdd(){return(this.words[0]&1)===1;};// And first word and num\nBN.prototype.andln=function andln(num){return this.words[0]&num;};// Increment at the bit position in-line\nBN.prototype.bincn=function bincn(bit){assert(typeof bit==='number');var r=bit%26;var s=(bit-r)/26;var q=1<<r;// Fast case: bit is much higher than all existing words\nif(this.length<=s){this._expand(s+1);this.words[s]|=q;return this;}// Add bit and propagate, if needed\nvar carry=q;for(var i=s;carry!==0&&i<this.length;i++){var w=this.words[i]|0;w+=carry;carry=w>>>26;w&=0x3ffffff;this.words[i]=w;}if(carry!==0){this.words[i]=carry;this.length++;}return this;};BN.prototype.isZero=function isZero(){return this.length===1&&this.words[0]===0;};BN.prototype.cmpn=function cmpn(num){var negative=num<0;if(this.negative!==0&&!negative)return-1;if(this.negative===0&&negative)return 1;this.strip();var res;if(this.length>1){res=1;}else{if(negative){num=-num;}assert(num<=0x3ffffff,'Number is too big');var w=this.words[0]|0;res=w===num?0:w<num?-1:1;}if(this.negative!==0)return-res|0;return res;};// Compare two numbers and return:\n// 1 - if `this` > `num`\n// 0 - if `this` == `num`\n// -1 - if `this` < `num`\nBN.prototype.cmp=function cmp(num){if(this.negative!==0&&num.negative===0)return-1;if(this.negative===0&&num.negative!==0)return 1;var res=this.ucmp(num);if(this.negative!==0)return-res|0;return res;};// Unsigned comparison\nBN.prototype.ucmp=function ucmp(num){// At this point both numbers have the same sign\nif(this.length>num.length)return 1;if(this.length<num.length)return-1;var res=0;for(var i=this.length-1;i>=0;i--){var a=this.words[i]|0;var b=num.words[i]|0;if(a===b)continue;if(a<b){res=-1;}else if(a>b){res=1;}break;}return res;};BN.prototype.gtn=function gtn(num){return this.cmpn(num)===1;};BN.prototype.gt=function gt(num){return this.cmp(num)===1;};BN.prototype.gten=function gten(num){return this.cmpn(num)>=0;};BN.prototype.gte=function gte(num){return this.cmp(num)>=0;};BN.prototype.ltn=function ltn(num){return this.cmpn(num)===-1;};BN.prototype.lt=function lt(num){return this.cmp(num)===-1;};BN.prototype.lten=function lten(num){return this.cmpn(num)<=0;};BN.prototype.lte=function lte(num){return this.cmp(num)<=0;};BN.prototype.eqn=function eqn(num){return this.cmpn(num)===0;};BN.prototype.eq=function eq(num){return this.cmp(num)===0;};//\n// A reduce context, could be using montgomery or something better, depending\n// on the `m` itself.\n//\nBN.red=function red(num){return new Red(num);};BN.prototype.toRed=function toRed(ctx){assert(!this.red,'Already a number in reduction context');assert(this.negative===0,'red works only with positives');return ctx.convertTo(this)._forceRed(ctx);};BN.prototype.fromRed=function fromRed(){assert(this.red,'fromRed works only with numbers in reduction context');return this.red.convertFrom(this);};BN.prototype._forceRed=function _forceRed(ctx){this.red=ctx;return this;};BN.prototype.forceRed=function forceRed(ctx){assert(!this.red,'Already a number in reduction context');return this._forceRed(ctx);};BN.prototype.redAdd=function redAdd(num){assert(this.red,'redAdd works only with red numbers');return this.red.add(this,num);};BN.prototype.redIAdd=function redIAdd(num){assert(this.red,'redIAdd works only with red numbers');return this.red.iadd(this,num);};BN.prototype.redSub=function redSub(num){assert(this.red,'redSub works only with red numbers');return this.red.sub(this,num);};BN.prototype.redISub=function redISub(num){assert(this.red,'redISub works only with red numbers');return this.red.isub(this,num);};BN.prototype.redShl=function redShl(num){assert(this.red,'redShl works only with red numbers');return this.red.shl(this,num);};BN.prototype.redMul=function redMul(num){assert(this.red,'redMul works only with red numbers');this.red._verify2(this,num);return this.red.mul(this,num);};BN.prototype.redIMul=function redIMul(num){assert(this.red,'redMul works only with red numbers');this.red._verify2(this,num);return this.red.imul(this,num);};BN.prototype.redSqr=function redSqr(){assert(this.red,'redSqr works only with red numbers');this.red._verify1(this);return this.red.sqr(this);};BN.prototype.redISqr=function redISqr(){assert(this.red,'redISqr works only with red numbers');this.red._verify1(this);return this.red.isqr(this);};// Square root over p\nBN.prototype.redSqrt=function redSqrt(){assert(this.red,'redSqrt works only with red numbers');this.red._verify1(this);return this.red.sqrt(this);};BN.prototype.redInvm=function redInvm(){assert(this.red,'redInvm works only with red numbers');this.red._verify1(this);return this.red.invm(this);};// Return negative clone of `this` % `red modulo`\nBN.prototype.redNeg=function redNeg(){assert(this.red,'redNeg works only with red numbers');this.red._verify1(this);return this.red.neg(this);};BN.prototype.redPow=function redPow(num){assert(this.red&&!num.red,'redPow(normalNum)');this.red._verify1(this);return this.red.pow(this,num);};// Prime numbers with efficient reduction\nvar primes={k256:null,p224:null,p192:null,p25519:null};// Pseudo-Mersenne prime\nfunction MPrime(name,p){// P = 2 ^ N - K\nthis.name=name;this.p=new BN(p,16);this.n=this.p.bitLength();this.k=new BN(1).iushln(this.n).isub(this.p);this.tmp=this._tmp();}MPrime.prototype._tmp=function _tmp(){var tmp=new BN(null);tmp.words=new Array(Math.ceil(this.n/13));return tmp;};MPrime.prototype.ireduce=function ireduce(num){// Assumes that `num` is less than `P^2`\n// num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)\nvar r=num;var rlen;do{this.split(r,this.tmp);r=this.imulK(r);r=r.iadd(this.tmp);rlen=r.bitLength();}while(rlen>this.n);var cmp=rlen<this.n?-1:r.ucmp(this.p);if(cmp===0){r.words[0]=0;r.length=1;}else if(cmp>0){r.isub(this.p);}else{if(r.strip!==undefined){// r is BN v4 instance\nr.strip();}else{// r is BN v5 instance\nr._strip();}}return r;};MPrime.prototype.split=function split(input,out){input.iushrn(this.n,0,out);};MPrime.prototype.imulK=function imulK(num){return num.imul(this.k);};function K256(){MPrime.call(this,'k256','ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');}inherits(K256,MPrime);K256.prototype.split=function split(input,output){// 256 = 9 * 26 + 22\nvar mask=0x3fffff;var outLen=Math.min(input.length,9);for(var i=0;i<outLen;i++){output.words[i]=input.words[i];}output.length=outLen;if(input.length<=9){input.words[0]=0;input.length=1;return;}// Shift by 9 limbs\nvar prev=input.words[9];output.words[output.length++]=prev&mask;for(i=10;i<input.length;i++){var next=input.words[i]|0;input.words[i-10]=(next&mask)<<4|prev>>>22;prev=next;}prev>>>=22;input.words[i-10]=prev;if(prev===0&&input.length>10){input.length-=10;}else{input.length-=9;}};K256.prototype.imulK=function imulK(num){// K = 0x1000003d1 = [ 0x40, 0x3d1 ]\nnum.words[num.length]=0;num.words[num.length+1]=0;num.length+=2;// bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390\nvar lo=0;for(var i=0;i<num.length;i++){var w=num.words[i]|0;lo+=w*0x3d1;num.words[i]=lo&0x3ffffff;lo=w*0x40+(lo/0x4000000|0);}// Fast length reduction\nif(num.words[num.length-1]===0){num.length--;if(num.words[num.length-1]===0){num.length--;}}return num;};function P224(){MPrime.call(this,'p224','ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');}inherits(P224,MPrime);function P192(){MPrime.call(this,'p192','ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');}inherits(P192,MPrime);function P25519(){// 2 ^ 255 - 19\nMPrime.call(this,'25519','7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');}inherits(P25519,MPrime);P25519.prototype.imulK=function imulK(num){// K = 0x13\nvar carry=0;for(var i=0;i<num.length;i++){var hi=(num.words[i]|0)*0x13+carry;var lo=hi&0x3ffffff;hi>>>=26;num.words[i]=lo;carry=hi;}if(carry!==0){num.words[num.length++]=carry;}return num;};// Exported mostly for testing purposes, use plain name instead\nBN._prime=function prime(name){// Cached version of prime\nif(primes[name])return primes[name];var prime;if(name==='k256'){prime=new K256();}else if(name==='p224'){prime=new P224();}else if(name==='p192'){prime=new P192();}else if(name==='p25519'){prime=new P25519();}else{throw new Error('Unknown prime '+name);}primes[name]=prime;return prime;};//\n// Base reduction engine\n//\nfunction Red(m){if(typeof m==='string'){var prime=BN._prime(m);this.m=prime.p;this.prime=prime;}else{assert(m.gtn(1),'modulus must be greater than 1');this.m=m;this.prime=null;}}Red.prototype._verify1=function _verify1(a){assert(a.negative===0,'red works only with positives');assert(a.red,'red works only with red numbers');};Red.prototype._verify2=function _verify2(a,b){assert((a.negative|b.negative)===0,'red works only with positives');assert(a.red&&a.red===b.red,'red works only with red numbers');};Red.prototype.imod=function imod(a){if(this.prime)return this.prime.ireduce(a)._forceRed(this);return a.umod(this.m)._forceRed(this);};Red.prototype.neg=function neg(a){if(a.isZero()){return a.clone();}return this.m.sub(a)._forceRed(this);};Red.prototype.add=function add(a,b){this._verify2(a,b);var res=a.add(b);if(res.cmp(this.m)>=0){res.isub(this.m);}return res._forceRed(this);};Red.prototype.iadd=function iadd(a,b){this._verify2(a,b);var res=a.iadd(b);if(res.cmp(this.m)>=0){res.isub(this.m);}return res;};Red.prototype.sub=function sub(a,b){this._verify2(a,b);var res=a.sub(b);if(res.cmpn(0)<0){res.iadd(this.m);}return res._forceRed(this);};Red.prototype.isub=function isub(a,b){this._verify2(a,b);var res=a.isub(b);if(res.cmpn(0)<0){res.iadd(this.m);}return res;};Red.prototype.shl=function shl(a,num){this._verify1(a);return this.imod(a.ushln(num));};Red.prototype.imul=function imul(a,b){this._verify2(a,b);return this.imod(a.imul(b));};Red.prototype.mul=function mul(a,b){this._verify2(a,b);return this.imod(a.mul(b));};Red.prototype.isqr=function isqr(a){return this.imul(a,a.clone());};Red.prototype.sqr=function sqr(a){return this.mul(a,a);};Red.prototype.sqrt=function sqrt(a){if(a.isZero())return a.clone();var mod3=this.m.andln(3);assert(mod3%2===1);// Fast case\nif(mod3===3){var pow=this.m.add(new BN(1)).iushrn(2);return this.pow(a,pow);}// Tonelli-Shanks algorithm (Totally unoptimized and slow)\n//\n// Find Q and S, that Q * 2 ^ S = (P - 1)\nvar q=this.m.subn(1);var s=0;while(!q.isZero()&&q.andln(1)===0){s++;q.iushrn(1);}assert(!q.isZero());var one=new BN(1).toRed(this);var nOne=one.redNeg();// Find quadratic non-residue\n// NOTE: Max is such because of generalized Riemann hypothesis.\nvar lpow=this.m.subn(1).iushrn(1);var z=this.m.bitLength();z=new BN(2*z*z).toRed(this);while(this.pow(z,lpow).cmp(nOne)!==0){z.redIAdd(nOne);}var c=this.pow(z,q);var r=this.pow(a,q.addn(1).iushrn(1));var t=this.pow(a,q);var m=s;while(t.cmp(one)!==0){var tmp=t;for(var i=0;tmp.cmp(one)!==0;i++){tmp=tmp.redSqr();}assert(i<m);var b=this.pow(c,new BN(1).iushln(m-i-1));r=r.redMul(b);c=b.redSqr();t=t.redMul(c);m=i;}return r;};Red.prototype.invm=function invm(a){var inv=a._invmp(this.m);if(inv.negative!==0){inv.negative=0;return this.imod(inv).redNeg();}else{return this.imod(inv);}};Red.prototype.pow=function pow(a,num){if(num.isZero())return new BN(1).toRed(this);if(num.cmpn(1)===0)return a.clone();var windowSize=4;var wnd=new Array(1<<windowSize);wnd[0]=new BN(1).toRed(this);wnd[1]=a;for(var i=2;i<wnd.length;i++){wnd[i]=this.mul(wnd[i-1],a);}var res=wnd[0];var current=0;var currentLen=0;var start=num.bitLength()%26;if(start===0){start=26;}for(i=num.length-1;i>=0;i--){var word=num.words[i];for(var j=start-1;j>=0;j--){var bit=word>>j&1;if(res!==wnd[0]){res=this.sqr(res);}if(bit===0&&current===0){currentLen=0;continue;}current<<=1;current|=bit;currentLen++;if(currentLen!==windowSize&&(i!==0||j!==0))continue;res=this.mul(res,wnd[current]);currentLen=0;current=0;}start=26;}return res;};Red.prototype.convertTo=function convertTo(num){var r=num.umod(this.m);return r===num?r.clone():r;};Red.prototype.convertFrom=function convertFrom(num){var res=num.clone();res.red=null;return res;};//\n// Montgomery method engine\n//\nBN.mont=function mont(num){return new Mont(num);};function Mont(m){Red.call(this,m);this.shift=this.m.bitLength();if(this.shift%26!==0){this.shift+=26-this.shift%26;}this.r=new BN(1).iushln(this.shift);this.r2=this.imod(this.r.sqr());this.rinv=this.r._invmp(this.m);this.minv=this.rinv.mul(this.r).isubn(1).div(this.m);this.minv=this.minv.umod(this.r);this.minv=this.r.sub(this.minv);}inherits(Mont,Red);Mont.prototype.convertTo=function convertTo(num){return this.imod(num.ushln(this.shift));};Mont.prototype.convertFrom=function convertFrom(num){var r=this.imod(num.mul(this.rinv));r.red=null;return r;};Mont.prototype.imul=function imul(a,b){if(a.isZero()||b.isZero()){a.words[0]=0;a.length=1;return a;}var t=a.imul(b);var c=t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);var u=t.isub(c).iushrn(this.shift);var res=u;if(u.cmp(this.m)>=0){res=u.isub(this.m);}else if(u.cmpn(0)<0){res=u.iadd(this.m);}return res._forceRed(this);};Mont.prototype.mul=function mul(a,b){if(a.isZero()||b.isZero())return new BN(0)._forceRed(this);var t=a.mul(b);var c=t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);var u=t.isub(c).iushrn(this.shift);var res=u;if(u.cmp(this.m)>=0){res=u.isub(this.m);}else if(u.cmpn(0)<0){res=u.iadd(this.m);}return res._forceRed(this);};Mont.prototype.invm=function invm(a){// (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R\nvar res=this.imod(a._invmp(this.m).mul(this.r2));return res._forceRed(this);};})( false||module,commonjsGlobal);});var bn_1=bn.BN;var _version=createCommonjsModule(function(module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});exports.version=\"logger/5.0.4\";});var _version$1=unwrapExports(_version);var _version_1=_version.version;var lib=createCommonjsModule(function(module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});var _permanentCensorErrors=false;var _censorErrors=false;var LogLevels={debug:1,\"default\":2,info:2,warning:3,error:4,off:5};var _logLevel=LogLevels[\"default\"];var _globalLogger=null;function _checkNormalize(){try{var missing_1=[];// Make sure all forms of normalization are supported\n[\"NFD\",\"NFC\",\"NFKD\",\"NFKC\"].forEach(function(form){try{if(\"test\".normalize(form)!==\"test\"){throw new Error(\"bad normalize\");};}catch(error){missing_1.push(form);}});if(missing_1.length){throw new Error(\"missing \"+missing_1.join(\", \"));}if(String.fromCharCode(0xe9).normalize(\"NFD\")!==String.fromCharCode(0x65,0x0301)){throw new Error(\"broken implementation\");}}catch(error){return error.message;}return null;}var _normalizeError=_checkNormalize();var LogLevel;(function(LogLevel){LogLevel[\"DEBUG\"]=\"DEBUG\";LogLevel[\"INFO\"]=\"INFO\";LogLevel[\"WARNING\"]=\"WARNING\";LogLevel[\"ERROR\"]=\"ERROR\";LogLevel[\"OFF\"]=\"OFF\";})(LogLevel=exports.LogLevel||(exports.LogLevel={}));var ErrorCode;(function(ErrorCode){///////////////////\n// Generic Errors\n// Unknown Error\nErrorCode[\"UNKNOWN_ERROR\"]=\"UNKNOWN_ERROR\";// Not Implemented\nErrorCode[\"NOT_IMPLEMENTED\"]=\"NOT_IMPLEMENTED\";// Unsupported Operation\n//   - operation\nErrorCode[\"UNSUPPORTED_OPERATION\"]=\"UNSUPPORTED_OPERATION\";// Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n//   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\nErrorCode[\"NETWORK_ERROR\"]=\"NETWORK_ERROR\";// Some sort of bad response from the server\nErrorCode[\"SERVER_ERROR\"]=\"SERVER_ERROR\";// Timeout\nErrorCode[\"TIMEOUT\"]=\"TIMEOUT\";///////////////////\n// Operational  Errors\n// Buffer Overrun\nErrorCode[\"BUFFER_OVERRUN\"]=\"BUFFER_OVERRUN\";// Numeric Fault\n//   - operation: the operation being executed\n//   - fault: the reason this faulted\nErrorCode[\"NUMERIC_FAULT\"]=\"NUMERIC_FAULT\";///////////////////\n// Argument Errors\n// Missing new operator to an object\n//  - name: The name of the class\nErrorCode[\"MISSING_NEW\"]=\"MISSING_NEW\";// Invalid argument (e.g. value is incompatible with type) to a function:\n//   - argument: The argument name that was invalid\n//   - value: The value of the argument\nErrorCode[\"INVALID_ARGUMENT\"]=\"INVALID_ARGUMENT\";// Missing argument to a function:\n//   - count: The number of arguments received\n//   - expectedCount: The number of arguments expected\nErrorCode[\"MISSING_ARGUMENT\"]=\"MISSING_ARGUMENT\";// Too many arguments\n//   - count: The number of arguments received\n//   - expectedCount: The number of arguments expected\nErrorCode[\"UNEXPECTED_ARGUMENT\"]=\"UNEXPECTED_ARGUMENT\";///////////////////\n// Blockchain Errors\n// Call exception\n//  - transaction: the transaction\n//  - address?: the contract address\n//  - args?: The arguments passed into the function\n//  - method?: The Solidity method signature\n//  - errorSignature?: The EIP848 error signature\n//  - errorArgs?: The EIP848 error parameters\n//  - reason: The reason (only for EIP848 \"Error(string)\")\nErrorCode[\"CALL_EXCEPTION\"]=\"CALL_EXCEPTION\";// Insufficien funds (< value + gasLimit * gasPrice)\n//   - transaction: the transaction attempted\nErrorCode[\"INSUFFICIENT_FUNDS\"]=\"INSUFFICIENT_FUNDS\";// Nonce has already been used\n//   - transaction: the transaction attempted\nErrorCode[\"NONCE_EXPIRED\"]=\"NONCE_EXPIRED\";// The replacement fee for the transaction is too low\n//   - transaction: the transaction attempted\nErrorCode[\"REPLACEMENT_UNDERPRICED\"]=\"REPLACEMENT_UNDERPRICED\";// The gas limit could not be estimated\n//   - transaction: the transaction passed to estimateGas\nErrorCode[\"UNPREDICTABLE_GAS_LIMIT\"]=\"UNPREDICTABLE_GAS_LIMIT\";})(ErrorCode=exports.ErrorCode||(exports.ErrorCode={}));;var Logger=/** @class */function(){function Logger(version){Object.defineProperty(this,\"version\",{enumerable:true,value:version,writable:false});}Logger.prototype._log=function(logLevel,args){var level=logLevel.toLowerCase();if(LogLevels[level]==null){this.throwArgumentError(\"invalid log level name\",\"logLevel\",logLevel);}if(_logLevel>LogLevels[level]){return;}console.log.apply(console,args);};Logger.prototype.debug=function(){var args=[];for(var _i=0;_i<arguments.length;_i++){args[_i]=arguments[_i];}this._log(Logger.levels.DEBUG,args);};Logger.prototype.info=function(){var args=[];for(var _i=0;_i<arguments.length;_i++){args[_i]=arguments[_i];}this._log(Logger.levels.INFO,args);};Logger.prototype.warn=function(){var args=[];for(var _i=0;_i<arguments.length;_i++){args[_i]=arguments[_i];}this._log(Logger.levels.WARNING,args);};Logger.prototype.makeError=function(message,code,params){// Errors are being censored\nif(_censorErrors){return this.makeError(\"censored error\",code,{});}if(!code){code=Logger.errors.UNKNOWN_ERROR;}if(!params){params={};}var messageDetails=[];Object.keys(params).forEach(function(key){try{messageDetails.push(key+\"=\"+JSON.stringify(params[key]));}catch(error){messageDetails.push(key+\"=\"+JSON.stringify(params[key].toString()));}});messageDetails.push(\"code=\"+code);messageDetails.push(\"version=\"+this.version);var reason=message;if(messageDetails.length){message+=\" (\"+messageDetails.join(\", \")+\")\";}// @TODO: Any??\nvar error=new Error(message);error.reason=reason;error.code=code;Object.keys(params).forEach(function(key){error[key]=params[key];});return error;};Logger.prototype.throwError=function(message,code,params){throw this.makeError(message,code,params);};Logger.prototype.throwArgumentError=function(message,name,value){return this.throwError(message,Logger.errors.INVALID_ARGUMENT,{argument:name,value:value});};Logger.prototype.assert=function(condition,message,code,params){if(!!condition){return;}this.throwError(message,code,params);};Logger.prototype.assertArgument=function(condition,message,name,value){if(!!condition){return;}this.throwArgumentError(message,name,value);};Logger.prototype.checkNormalize=function(message){if(message==null){message=\"platform missing String.prototype.normalize\";}if(_normalizeError){this.throwError(\"platform missing String.prototype.normalize\",Logger.errors.UNSUPPORTED_OPERATION,{operation:\"String.prototype.normalize\",form:_normalizeError});}};Logger.prototype.checkSafeUint53=function(value,message){if(typeof value!==\"number\"){return;}if(message==null){message=\"value not safe\";}if(value<0||value>=0x1fffffffffffff){this.throwError(message,Logger.errors.NUMERIC_FAULT,{operation:\"checkSafeInteger\",fault:\"out-of-safe-range\",value:value});}if(value%1){this.throwError(message,Logger.errors.NUMERIC_FAULT,{operation:\"checkSafeInteger\",fault:\"non-integer\",value:value});}};Logger.prototype.checkArgumentCount=function(count,expectedCount,message){if(message){message=\": \"+message;}else{message=\"\";}if(count<expectedCount){this.throwError(\"missing argument\"+message,Logger.errors.MISSING_ARGUMENT,{count:count,expectedCount:expectedCount});}if(count>expectedCount){this.throwError(\"too many arguments\"+message,Logger.errors.UNEXPECTED_ARGUMENT,{count:count,expectedCount:expectedCount});}};Logger.prototype.checkNew=function(target,kind){if(target===Object||target==null){this.throwError(\"missing new\",Logger.errors.MISSING_NEW,{name:kind.name});}};Logger.prototype.checkAbstract=function(target,kind){if(target===kind){this.throwError(\"cannot instantiate abstract class \"+JSON.stringify(kind.name)+\" directly; use a sub-class\",Logger.errors.UNSUPPORTED_OPERATION,{name:target.name,operation:\"new\"});}else if(target===Object||target==null){this.throwError(\"missing new\",Logger.errors.MISSING_NEW,{name:kind.name});}};Logger.globalLogger=function(){if(!_globalLogger){_globalLogger=new Logger(_version.version);}return _globalLogger;};Logger.setCensorship=function(censorship,permanent){if(!censorship&&permanent){this.globalLogger().throwError(\"cannot permanently disable censorship\",Logger.errors.UNSUPPORTED_OPERATION,{operation:\"setCensorship\"});}if(_permanentCensorErrors){if(!censorship){return;}this.globalLogger().throwError(\"error censorship permanent\",Logger.errors.UNSUPPORTED_OPERATION,{operation:\"setCensorship\"});}_censorErrors=!!censorship;_permanentCensorErrors=!!permanent;};Logger.setLogLevel=function(logLevel){var level=LogLevels[logLevel.toLowerCase()];if(level==null){Logger.globalLogger().warn(\"invalid log level - \"+logLevel);return;}_logLevel=level;};Logger.errors=ErrorCode;Logger.levels=LogLevel;return Logger;}();exports.Logger=Logger;});var index=unwrapExports(lib);var lib_1=lib.LogLevel;var lib_2=lib.ErrorCode;var lib_3=lib.Logger;var _version$2=createCommonjsModule(function(module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});exports.version=\"bytes/5.0.3\";});var _version$3=unwrapExports(_version$2);var _version_1$1=_version$2.version;var lib$1=createCommonjsModule(function(module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});var logger=new lib.Logger(_version$2.version);///////////////////////////////\nfunction isHexable(value){return!!value.toHexString;}function addSlice(array){if(array.slice){return array;}array.slice=function(){var args=Array.prototype.slice.call(arguments);return addSlice(new Uint8Array(Array.prototype.slice.apply(array,args)));};return array;}function isBytesLike(value){return isHexString(value)&&!(value.length%2)||isBytes(value);}exports.isBytesLike=isBytesLike;function isBytes(value){if(value==null){return false;}if(value.constructor===Uint8Array){return true;}if(typeof value===\"string\"){return false;}if(value.length==null){return false;}for(var i=0;i<value.length;i++){var v=value[i];if(v<0||v>=256||v%1){return false;}}return true;}exports.isBytes=isBytes;function arrayify(value,options){if(!options){options={};}if(typeof value===\"number\"){logger.checkSafeUint53(value,\"invalid arrayify value\");var result=[];while(value){result.unshift(value&0xff);value=parseInt(String(value/256));}if(result.length===0){result.push(0);}return addSlice(new Uint8Array(result));}if(options.allowMissingPrefix&&typeof value===\"string\"&&value.substring(0,2)!==\"0x\"){value=\"0x\"+value;}if(isHexable(value)){value=value.toHexString();}if(isHexString(value)){var hex=value.substring(2);if(hex.length%2){if(options.hexPad===\"left\"){hex=\"0x0\"+hex.substring(2);}else if(options.hexPad===\"right\"){hex+=\"0\";}else{logger.throwArgumentError(\"hex data is odd-length\",\"value\",value);}}var result=[];for(var i=0;i<hex.length;i+=2){result.push(parseInt(hex.substring(i,i+2),16));}return addSlice(new Uint8Array(result));}if(isBytes(value)){return addSlice(new Uint8Array(value));}return logger.throwArgumentError(\"invalid arrayify value\",\"value\",value);}exports.arrayify=arrayify;function concat(items){var objects=items.map(function(item){return arrayify(item);});var length=objects.reduce(function(accum,item){return accum+item.length;},0);var result=new Uint8Array(length);objects.reduce(function(offset,object){result.set(object,offset);return offset+object.length;},0);return addSlice(result);}exports.concat=concat;function stripZeros(value){var result=arrayify(value);if(result.length===0){return result;}// Find the first non-zero entry\nvar start=0;while(start<result.length&&result[start]===0){start++;}// If we started with zeros, strip them\nif(start){result=result.slice(start);}return result;}exports.stripZeros=stripZeros;function zeroPad(value,length){value=arrayify(value);if(value.length>length){logger.throwArgumentError(\"value out of range\",\"value\",arguments[0]);}var result=new Uint8Array(length);result.set(value,length-value.length);return addSlice(result);}exports.zeroPad=zeroPad;function isHexString(value,length){if(typeof value!==\"string\"||!value.match(/^0x[0-9A-Fa-f]*$/)){return false;}if(length&&value.length!==2+2*length){return false;}return true;}exports.isHexString=isHexString;var HexCharacters=\"0123456789abcdef\";function hexlify(value,options){if(!options){options={};}if(typeof value===\"number\"){logger.checkSafeUint53(value,\"invalid hexlify value\");var hex=\"\";while(value){hex=HexCharacters[value&0x0f]+hex;value=Math.floor(value/16);}if(hex.length){if(hex.length%2){hex=\"0\"+hex;}return\"0x\"+hex;}return\"0x00\";}if(options.allowMissingPrefix&&typeof value===\"string\"&&value.substring(0,2)!==\"0x\"){value=\"0x\"+value;}if(isHexable(value)){return value.toHexString();}if(isHexString(value)){if(value.length%2){if(options.hexPad===\"left\"){value=\"0x0\"+value.substring(2);}else if(options.hexPad===\"right\"){value+=\"0\";}else{logger.throwArgumentError(\"hex data is odd-length\",\"value\",value);}}return value.toLowerCase();}if(isBytes(value)){var result=\"0x\";for(var i=0;i<value.length;i++){var v=value[i];result+=HexCharacters[(v&0xf0)>>4]+HexCharacters[v&0x0f];}return result;}return logger.throwArgumentError(\"invalid hexlify value\",\"value\",value);}exports.hexlify=hexlify;/*\n\tfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n\t    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n\t        return \"0x0\" + value.substring(2);\n\t    }\n\t    return value;\n\t}\n\t*/function hexDataLength(data){if(typeof data!==\"string\"){data=hexlify(data);}else if(!isHexString(data)||data.length%2){return null;}return(data.length-2)/2;}exports.hexDataLength=hexDataLength;function hexDataSlice(data,offset,endOffset){if(typeof data!==\"string\"){data=hexlify(data);}else if(!isHexString(data)||data.length%2){logger.throwArgumentError(\"invalid hexData\",\"value\",data);}offset=2+2*offset;if(endOffset!=null){return\"0x\"+data.substring(offset,2+2*endOffset);}return\"0x\"+data.substring(offset);}exports.hexDataSlice=hexDataSlice;function hexConcat(items){var result=\"0x\";items.forEach(function(item){result+=hexlify(item).substring(2);});return result;}exports.hexConcat=hexConcat;function hexValue(value){var trimmed=hexStripZeros(hexlify(value,{hexPad:\"left\"}));if(trimmed===\"0x\"){return\"0x0\";}return trimmed;}exports.hexValue=hexValue;function hexStripZeros(value){if(typeof value!==\"string\"){value=hexlify(value);}if(!isHexString(value)){logger.throwArgumentError(\"invalid hex string\",\"value\",value);}value=value.substring(2);var offset=0;while(offset<value.length&&value[offset]===\"0\"){offset++;}return\"0x\"+value.substring(offset);}exports.hexStripZeros=hexStripZeros;function hexZeroPad(value,length){if(typeof value!==\"string\"){value=hexlify(value);}else if(!isHexString(value)){logger.throwArgumentError(\"invalid hex string\",\"value\",value);}if(value.length>2*length+2){logger.throwArgumentError(\"value out of range\",\"value\",arguments[1]);}while(value.length<2*length+2){value=\"0x0\"+value.substring(2);}return value;}exports.hexZeroPad=hexZeroPad;function splitSignature(signature){var result={r:\"0x\",s:\"0x\",_vs:\"0x\",recoveryParam:0,v:0};if(isBytesLike(signature)){var bytes=arrayify(signature);if(bytes.length!==65){logger.throwArgumentError(\"invalid signature string; must be 65 bytes\",\"signature\",signature);}// Get the r, s and v\nresult.r=hexlify(bytes.slice(0,32));result.s=hexlify(bytes.slice(32,64));result.v=bytes[64];// Allow a recid to be used as the v\nif(result.v<27){if(result.v===0||result.v===1){result.v+=27;}else{logger.throwArgumentError(\"signature invalid v byte\",\"signature\",signature);}}// Compute recoveryParam from v\nresult.recoveryParam=1-result.v%2;// Compute _vs from recoveryParam and s\nif(result.recoveryParam){bytes[32]|=0x80;}result._vs=hexlify(bytes.slice(32,64));}else{result.r=signature.r;result.s=signature.s;result.v=signature.v;result.recoveryParam=signature.recoveryParam;result._vs=signature._vs;// If the _vs is available, use it to populate missing s, v and recoveryParam\n// and verify non-missing s, v and recoveryParam\nif(result._vs!=null){var vs_1=zeroPad(arrayify(result._vs),32);result._vs=hexlify(vs_1);// Set or check the recid\nvar recoveryParam=vs_1[0]>=128?1:0;if(result.recoveryParam==null){result.recoveryParam=recoveryParam;}else if(result.recoveryParam!==recoveryParam){logger.throwArgumentError(\"signature recoveryParam mismatch _vs\",\"signature\",signature);}// Set or check the s\nvs_1[0]&=0x7f;var s=hexlify(vs_1);if(result.s==null){result.s=s;}else if(result.s!==s){logger.throwArgumentError(\"signature v mismatch _vs\",\"signature\",signature);}}// Use recid and v to populate each other\nif(result.recoveryParam==null){if(result.v==null){logger.throwArgumentError(\"signature missing v and recoveryParam\",\"signature\",signature);}else{result.recoveryParam=1-result.v%2;}}else{if(result.v==null){result.v=27+result.recoveryParam;}else if(result.recoveryParam!==1-result.v%2){logger.throwArgumentError(\"signature recoveryParam mismatch v\",\"signature\",signature);}}if(result.r==null||!isHexString(result.r)){logger.throwArgumentError(\"signature missing or invalid r\",\"signature\",signature);}else{result.r=hexZeroPad(result.r,32);}if(result.s==null||!isHexString(result.s)){logger.throwArgumentError(\"signature missing or invalid s\",\"signature\",signature);}else{result.s=hexZeroPad(result.s,32);}var vs=arrayify(result.s);if(vs[0]>=128){logger.throwArgumentError(\"signature s out of range\",\"signature\",signature);}if(result.recoveryParam){vs[0]|=0x80;}var _vs=hexlify(vs);if(result._vs){if(!isHexString(result._vs)){logger.throwArgumentError(\"signature invalid _vs\",\"signature\",signature);}result._vs=hexZeroPad(result._vs,32);}// Set or check the _vs\nif(result._vs==null){result._vs=_vs;}else if(result._vs!==_vs){logger.throwArgumentError(\"signature _vs mismatch v and s\",\"signature\",signature);}}return result;}exports.splitSignature=splitSignature;function joinSignature(signature){signature=splitSignature(signature);return hexlify(concat([signature.r,signature.s,signature.recoveryParam?\"0x1c\":\"0x1b\"]));}exports.joinSignature=joinSignature;});var index$1=unwrapExports(lib$1);var lib_1$1=lib$1.isBytesLike;var lib_2$1=lib$1.isBytes;var lib_3$1=lib$1.arrayify;var lib_4=lib$1.concat;var lib_5=lib$1.stripZeros;var lib_6=lib$1.zeroPad;var lib_7=lib$1.isHexString;var lib_8=lib$1.hexlify;var lib_9=lib$1.hexDataLength;var lib_10=lib$1.hexDataSlice;var lib_11=lib$1.hexConcat;var lib_12=lib$1.hexValue;var lib_13=lib$1.hexStripZeros;var lib_14=lib$1.hexZeroPad;var lib_15=lib$1.splitSignature;var lib_16=lib$1.joinSignature;var _version$4=createCommonjsModule(function(module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});exports.version=\"bignumber/5.0.5\";});var _version$5=unwrapExports(_version$4);var _version_1$2=_version$4.version;var bignumber=createCommonjsModule(function(module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});/**\n\t *  BigNumber\n\t *\n\t *  A wrapper around the BN.js object. We use the BN.js library\n\t *  because it is used by elliptic, so it is required regardles.\n\t *\n\t */var logger=new lib.Logger(_version$4.version);var _constructorGuard={};var MAX_SAFE=0x1fffffffffffff;function isBigNumberish(value){return value!=null&&(BigNumber.isBigNumber(value)||typeof value===\"number\"&&value%1===0||typeof value===\"string\"&&!!value.match(/^-?[0-9]+$/)||lib$1.isHexString(value)||typeof value===\"bigint\"||lib$1.isBytes(value));}exports.isBigNumberish=isBigNumberish;var BigNumber=/** @class */function(){function BigNumber(constructorGuard,hex){var _newTarget=this.constructor;logger.checkNew(_newTarget,BigNumber);if(constructorGuard!==_constructorGuard){logger.throwError(\"cannot call constructor directly; use BigNumber.from\",lib.Logger.errors.UNSUPPORTED_OPERATION,{operation:\"new (BigNumber)\"});}this._hex=hex;this._isBigNumber=true;Object.freeze(this);}BigNumber.prototype.fromTwos=function(value){return toBigNumber(toBN(this).fromTwos(value));};BigNumber.prototype.toTwos=function(value){return toBigNumber(toBN(this).toTwos(value));};BigNumber.prototype.abs=function(){if(this._hex[0]===\"-\"){return BigNumber.from(this._hex.substring(1));}return this;};BigNumber.prototype.add=function(other){return toBigNumber(toBN(this).add(toBN(other)));};BigNumber.prototype.sub=function(other){return toBigNumber(toBN(this).sub(toBN(other)));};BigNumber.prototype.div=function(other){var o=BigNumber.from(other);if(o.isZero()){throwFault(\"division by zero\",\"div\");}return toBigNumber(toBN(this).div(toBN(other)));};BigNumber.prototype.mul=function(other){return toBigNumber(toBN(this).mul(toBN(other)));};BigNumber.prototype.mod=function(other){var value=toBN(other);if(value.isNeg()){throwFault(\"cannot modulo negative values\",\"mod\");}return toBigNumber(toBN(this).umod(value));};BigNumber.prototype.pow=function(other){var value=toBN(other);if(value.isNeg()){throwFault(\"cannot raise to negative values\",\"pow\");}return toBigNumber(toBN(this).pow(value));};BigNumber.prototype.and=function(other){var value=toBN(other);if(this.isNegative()||value.isNeg()){throwFault(\"cannot 'and' negative values\",\"and\");}return toBigNumber(toBN(this).and(value));};BigNumber.prototype.or=function(other){var value=toBN(other);if(this.isNegative()||value.isNeg()){throwFault(\"cannot 'or' negative values\",\"or\");}return toBigNumber(toBN(this).or(value));};BigNumber.prototype.xor=function(other){var value=toBN(other);if(this.isNegative()||value.isNeg()){throwFault(\"cannot 'xor' negative values\",\"xor\");}return toBigNumber(toBN(this).xor(value));};BigNumber.prototype.mask=function(value){if(this.isNegative()||value<0){throwFault(\"cannot mask negative values\",\"mask\");}return toBigNumber(toBN(this).maskn(value));};BigNumber.prototype.shl=function(value){if(this.isNegative()||value<0){throwFault(\"cannot shift negative values\",\"shl\");}return toBigNumber(toBN(this).shln(value));};BigNumber.prototype.shr=function(value){if(this.isNegative()||value<0){throwFault(\"cannot shift negative values\",\"shr\");}return toBigNumber(toBN(this).shrn(value));};BigNumber.prototype.eq=function(other){return toBN(this).eq(toBN(other));};BigNumber.prototype.lt=function(other){return toBN(this).lt(toBN(other));};BigNumber.prototype.lte=function(other){return toBN(this).lte(toBN(other));};BigNumber.prototype.gt=function(other){return toBN(this).gt(toBN(other));};BigNumber.prototype.gte=function(other){return toBN(this).gte(toBN(other));};BigNumber.prototype.isNegative=function(){return this._hex[0]===\"-\";};BigNumber.prototype.isZero=function(){return toBN(this).isZero();};BigNumber.prototype.toNumber=function(){try{return toBN(this).toNumber();}catch(error){throwFault(\"overflow\",\"toNumber\",this.toString());}return null;};BigNumber.prototype.toString=function(){// Lots of people expect this, which we do not support, so check\nif(arguments.length!==0){logger.throwError(\"bigNumber.toString does not accept parameters\",lib.Logger.errors.UNEXPECTED_ARGUMENT,{});}return toBN(this).toString(10);};BigNumber.prototype.toHexString=function(){return this._hex;};BigNumber.from=function(value){if(value instanceof BigNumber){return value;}if(typeof value===\"string\"){if(value.match(/^-?0x[0-9a-f]+$/i)){return new BigNumber(_constructorGuard,toHex(value));}if(value.match(/^-?[0-9]+$/)){return new BigNumber(_constructorGuard,toHex(new bn.BN(value)));}return logger.throwArgumentError(\"invalid BigNumber string\",\"value\",value);}if(typeof value===\"number\"){if(value%1){throwFault(\"underflow\",\"BigNumber.from\",value);}if(value>=MAX_SAFE||value<=-MAX_SAFE){throwFault(\"overflow\",\"BigNumber.from\",value);}return BigNumber.from(String(value));}if(typeof value===\"bigint\"){return BigNumber.from(value.toString());}if(lib$1.isBytes(value)){return BigNumber.from(lib$1.hexlify(value));}if(value._hex&&lib$1.isHexString(value._hex)){return BigNumber.from(value._hex);}if(value.toHexString){value=value.toHexString();if(typeof value===\"string\"){return BigNumber.from(value);}}return logger.throwArgumentError(\"invalid BigNumber value\",\"value\",value);};BigNumber.isBigNumber=function(value){return!!(value&&value._isBigNumber);};return BigNumber;}();exports.BigNumber=BigNumber;// Normalize the hex string\nfunction toHex(value){// For BN, call on the hex string\nif(typeof value!==\"string\"){return toHex(value.toString(16));}// If negative, prepend the negative sign to the normalized positive value\nif(value[0]===\"-\"){// Strip off the negative sign\nvalue=value.substring(1);// Cannot have mulitple negative signs (e.g. \"--0x04\")\nif(value[0]===\"-\"){logger.throwArgumentError(\"invalid hex\",\"value\",value);}// Call toHex on the positive component\nvalue=toHex(value);// Do not allow \"-0x00\"\nif(value===\"0x00\"){return value;}// Negate the value\nreturn\"-\"+value;}// Add a \"0x\" prefix if missing\nif(value.substring(0,2)!==\"0x\"){value=\"0x\"+value;}// Normalize zero\nif(value===\"0x\"){return\"0x00\";}// Make the string even length\nif(value.length%2){value=\"0x0\"+value.substring(2);}// Trim to smallest even-length string\nwhile(value.length>4&&value.substring(0,4)===\"0x00\"){value=\"0x\"+value.substring(4);}return value;}function toBigNumber(value){return BigNumber.from(toHex(value));}function toBN(value){var hex=BigNumber.from(value).toHexString();if(hex[0]===\"-\"){return new bn.BN(\"-\"+hex.substring(3),16);}return new bn.BN(hex.substring(2),16);}function throwFault(fault,operation,value){var params={fault:fault,operation:operation};if(value!=null){params.value=value;}return logger.throwError(fault,lib.Logger.errors.NUMERIC_FAULT,params);}});var bignumber$1=unwrapExports(bignumber);var bignumber_1=bignumber.isBigNumberish;var bignumber_2=bignumber.BigNumber;var fixednumber=createCommonjsModule(function(module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});var logger=new lib.Logger(_version$4.version);var _constructorGuard={};var Zero=bignumber.BigNumber.from(0);var NegativeOne=bignumber.BigNumber.from(-1);function throwFault(message,fault,operation,value){var params={fault:fault,operation:operation};if(value!==undefined){params.value=value;}return logger.throwError(message,lib.Logger.errors.NUMERIC_FAULT,params);}// Constant to pull zeros from for multipliers\nvar zeros=\"0\";while(zeros.length<256){zeros+=zeros;}// Returns a string \"1\" followed by decimal \"0\"s\nfunction getMultiplier(decimals){if(typeof decimals!==\"number\"){try{decimals=bignumber.BigNumber.from(decimals).toNumber();}catch(e){}}if(typeof decimals===\"number\"&&decimals>=0&&decimals<=256&&!(decimals%1)){return\"1\"+zeros.substring(0,decimals);}return logger.throwArgumentError(\"invalid decimal size\",\"decimals\",decimals);}function formatFixed(value,decimals){if(decimals==null){decimals=0;}var multiplier=getMultiplier(decimals);// Make sure wei is a big number (convert as necessary)\nvalue=bignumber.BigNumber.from(value);var negative=value.lt(Zero);if(negative){value=value.mul(NegativeOne);}var fraction=value.mod(multiplier).toString();while(fraction.length<multiplier.length-1){fraction=\"0\"+fraction;}// Strip training 0\nfraction=fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];var whole=value.div(multiplier).toString();value=whole+\".\"+fraction;if(negative){value=\"-\"+value;}return value;}exports.formatFixed=formatFixed;function parseFixed(value,decimals){if(decimals==null){decimals=0;}var multiplier=getMultiplier(decimals);if(typeof value!==\"string\"||!value.match(/^-?[0-9.,]+$/)){logger.throwArgumentError(\"invalid decimal value\",\"value\",value);}if(multiplier.length-1===0){return bignumber.BigNumber.from(value);}// Is it negative?\nvar negative=value.substring(0,1)===\"-\";if(negative){value=value.substring(1);}if(value===\".\"){logger.throwArgumentError(\"missing value\",\"value\",value);}// Split it into a whole and fractional part\nvar comps=value.split(\".\");if(comps.length>2){logger.throwArgumentError(\"too many decimal points\",\"value\",value);}var whole=comps[0],fraction=comps[1];if(!whole){whole=\"0\";}if(!fraction){fraction=\"0\";}// Prevent underflow\nif(fraction.length>multiplier.length-1){throwFault(\"fractional component exceeds decimals\",\"underflow\",\"parseFixed\");}// Fully pad the string with zeros to get to wei\nwhile(fraction.length<multiplier.length-1){fraction+=\"0\";}var wholeValue=bignumber.BigNumber.from(whole);var fractionValue=bignumber.BigNumber.from(fraction);var wei=wholeValue.mul(multiplier).add(fractionValue);if(negative){wei=wei.mul(NegativeOne);}return wei;}exports.parseFixed=parseFixed;var FixedFormat=/** @class */function(){function FixedFormat(constructorGuard,signed,width,decimals){if(constructorGuard!==_constructorGuard){logger.throwError(\"cannot use FixedFormat constructor; use FixedFormat.from\",lib.Logger.errors.UNSUPPORTED_OPERATION,{operation:\"new FixedFormat\"});}this.signed=signed;this.width=width;this.decimals=decimals;this.name=(signed?\"\":\"u\")+\"fixed\"+String(width)+\"x\"+String(decimals);this._multiplier=getMultiplier(decimals);Object.freeze(this);}FixedFormat.from=function(value){if(value instanceof FixedFormat){return value;}var signed=true;var width=128;var decimals=18;if(typeof value===\"string\"){if(value===\"fixed\"){// defaults...\n}else if(value===\"ufixed\"){signed=false;}else if(value!=null){var match=value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);if(!match){logger.throwArgumentError(\"invalid fixed format\",\"format\",value);}signed=match[1]!==\"u\";width=parseInt(match[2]);decimals=parseInt(match[3]);}}else if(value){var check=function check(key,type,defaultValue){if(value[key]==null){return defaultValue;}if(_typeof(value[key])!==type){logger.throwArgumentError(\"invalid fixed format (\"+key+\" not \"+type+\")\",\"format.\"+key,value[key]);}return value[key];};signed=check(\"signed\",\"boolean\",signed);width=check(\"width\",\"number\",width);decimals=check(\"decimals\",\"number\",decimals);}if(width%8){logger.throwArgumentError(\"invalid fixed format width (not byte aligned)\",\"format.width\",width);}if(decimals>80){logger.throwArgumentError(\"invalid fixed format (decimals too large)\",\"format.decimals\",decimals);}return new FixedFormat(_constructorGuard,signed,width,decimals);};return FixedFormat;}();exports.FixedFormat=FixedFormat;var FixedNumber=/** @class */function(){function FixedNumber(constructorGuard,hex,value,format){var _newTarget=this.constructor;logger.checkNew(_newTarget,FixedNumber);if(constructorGuard!==_constructorGuard){logger.throwError(\"cannot use FixedNumber constructor; use FixedNumber.from\",lib.Logger.errors.UNSUPPORTED_OPERATION,{operation:\"new FixedFormat\"});}this.format=format;this._hex=hex;this._value=value;this._isFixedNumber=true;Object.freeze(this);}FixedNumber.prototype._checkFormat=function(other){if(this.format.name!==other.format.name){logger.throwArgumentError(\"incompatible format; use fixedNumber.toFormat\",\"other\",other);}};FixedNumber.prototype.addUnsafe=function(other){this._checkFormat(other);var a=parseFixed(this._value,this.format.decimals);var b=parseFixed(other._value,other.format.decimals);return FixedNumber.fromValue(a.add(b),this.format.decimals,this.format);};FixedNumber.prototype.subUnsafe=function(other){this._checkFormat(other);var a=parseFixed(this._value,this.format.decimals);var b=parseFixed(other._value,other.format.decimals);return FixedNumber.fromValue(a.sub(b),this.format.decimals,this.format);};FixedNumber.prototype.mulUnsafe=function(other){this._checkFormat(other);var a=parseFixed(this._value,this.format.decimals);var b=parseFixed(other._value,other.format.decimals);return FixedNumber.fromValue(a.mul(b).div(this.format._multiplier),this.format.decimals,this.format);};FixedNumber.prototype.divUnsafe=function(other){this._checkFormat(other);var a=parseFixed(this._value,this.format.decimals);var b=parseFixed(other._value,other.format.decimals);return FixedNumber.fromValue(a.mul(this.format._multiplier).div(b),this.format.decimals,this.format);};// @TODO: Support other rounding algorithms\nFixedNumber.prototype.round=function(decimals){if(decimals==null){decimals=0;}if(decimals<0||decimals>80||decimals%1){logger.throwArgumentError(\"invalid decimal count\",\"decimals\",decimals);}// If we are already in range, we're done\nvar comps=this.toString().split(\".\");if(comps[1].length<=decimals){return this;}// Bump the value up by the 0.00...0005\nvar bump=\"0.\"+zeros.substring(0,decimals)+\"5\";comps=this.addUnsafe(FixedNumber.fromString(bump,this.format))._value.split(\".\");// Now it is safe to truncate\nreturn FixedNumber.fromString(comps[0]+\".\"+comps[1].substring(0,decimals));};FixedNumber.prototype.isZero=function(){return this._value===\"0.0\";};FixedNumber.prototype.toString=function(){return this._value;};FixedNumber.prototype.toHexString=function(width){if(width==null){return this._hex;}if(width%8){logger.throwArgumentError(\"invalid byte width\",\"width\",width);}var hex=bignumber.BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();return lib$1.hexZeroPad(hex,width/8);};FixedNumber.prototype.toUnsafeFloat=function(){return parseFloat(this.toString());};FixedNumber.prototype.toFormat=function(format){return FixedNumber.fromString(this._value,format);};FixedNumber.fromValue=function(value,decimals,format){// If decimals looks more like a format, and there is no format, shift the parameters\nif(format==null&&decimals!=null&&!bignumber.isBigNumberish(decimals)){format=decimals;decimals=null;}if(decimals==null){decimals=0;}if(format==null){format=\"fixed\";}return FixedNumber.fromString(formatFixed(value,decimals),FixedFormat.from(format));};FixedNumber.fromString=function(value,format){if(format==null){format=\"fixed\";}var fixedFormat=FixedFormat.from(format);var numeric=parseFixed(value,fixedFormat.decimals);if(!fixedFormat.signed&&numeric.lt(Zero)){throwFault(\"unsigned value cannot be negative\",\"overflow\",\"value\",value);}var hex=null;if(fixedFormat.signed){hex=numeric.toTwos(fixedFormat.width).toHexString();}else{hex=numeric.toHexString();hex=lib$1.hexZeroPad(hex,fixedFormat.width/8);}var decimal=formatFixed(numeric,fixedFormat.decimals);return new FixedNumber(_constructorGuard,hex,decimal,fixedFormat);};FixedNumber.fromBytes=function(value,format){if(format==null){format=\"fixed\";}var fixedFormat=FixedFormat.from(format);if(lib$1.arrayify(value).length>fixedFormat.width/8){throw new Error(\"overflow\");}var numeric=bignumber.BigNumber.from(value);if(fixedFormat.signed){numeric=numeric.fromTwos(fixedFormat.width);}var hex=numeric.toTwos((fixedFormat.signed?0:1)+fixedFormat.width).toHexString();var decimal=formatFixed(numeric,fixedFormat.decimals);return new FixedNumber(_constructorGuard,hex,decimal,fixedFormat);};FixedNumber.from=function(value,format){if(typeof value===\"string\"){return FixedNumber.fromString(value,format);}if(lib$1.isBytes(value)){return FixedNumber.fromBytes(value,format);}try{return FixedNumber.fromValue(value,0,format);}catch(error){// Allow NUMERIC_FAULT to bubble up\nif(error.code!==lib.Logger.errors.INVALID_ARGUMENT){throw error;}}return logger.throwArgumentError(\"invalid FixedNumber value\",\"value\",value);};FixedNumber.isFixedNumber=function(value){return!!(value&&value._isFixedNumber);};return FixedNumber;}();exports.FixedNumber=FixedNumber;});var fixednumber$1=unwrapExports(fixednumber);var fixednumber_1=fixednumber.formatFixed;var fixednumber_2=fixednumber.parseFixed;var fixednumber_3=fixednumber.FixedFormat;var fixednumber_4=fixednumber.FixedNumber;var lib$2=createCommonjsModule(function(module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});exports.BigNumber=bignumber.BigNumber;exports.formatFixed=fixednumber.formatFixed;exports.FixedFormat=fixednumber.FixedFormat;exports.FixedNumber=fixednumber.FixedNumber;exports.parseFixed=fixednumber.parseFixed;});var index$2=unwrapExports(lib$2);var lib_1$2=lib$2.BigNumber;var lib_2$2=lib$2.formatFixed;var lib_3$2=lib$2.FixedFormat;var lib_4$1=lib$2.FixedNumber;var lib_5$1=lib$2.parseFixed;var _version$6=createCommonjsModule(function(module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});exports.version=\"properties/5.0.2\";});var _version$7=unwrapExports(_version$6);var _version_1$3=_version$6.version;var lib$3=createCommonjsModule(function(module,exports){\"use strict\";var __awaiter=commonjsGlobal&&commonjsGlobal.__awaiter||function(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P(function(resolve){resolve(value);});}return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value));}catch(e){reject(e);}}function rejected(value){try{step(generator[\"throw\"](value));}catch(e){reject(e);}}function step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected);}step((generator=generator.apply(thisArg,_arguments||[])).next());});};var __generator=commonjsGlobal&&commonjsGlobal.__generator||function(thisArg,body){var _={label:0,sent:function sent(){if(t[0]&1)throw t[1];return t[1];},trys:[],ops:[]},f,y,t,g;return g={next:verb(0),\"throw\":verb(1),\"return\":verb(2)},typeof Symbol===\"function\"&&(g[Symbol.iterator]=function(){return this;}),g;function verb(n){return function(v){return step([n,v]);};}function step(op){if(f)throw new TypeError(\"Generator is already executing.\");while(_){try{if(f=1,y&&(t=op[0]&2?y[\"return\"]:op[0]?y[\"throw\"]||((t=y[\"return\"])&&t.call(y),0):y.next)&&!(t=t.call(y,op[1])).done)return t;if(y=0,t)op=[op[0]&2,t.value];switch(op[0]){case 0:case 1:t=op;break;case 4:_.label++;return{value:op[1],done:false};case 5:_.label++;y=op[1];op=[0];continue;case 7:op=_.ops.pop();_.trys.pop();continue;default:if(!(t=_.trys,t=t.length>0&&t[t.length-1])&&(op[0]===6||op[0]===2)){_=0;continue;}if(op[0]===3&&(!t||op[1]>t[0]&&op[1]<t[3])){_.label=op[1];break;}if(op[0]===6&&_.label<t[1]){_.label=t[1];t=op;break;}if(t&&_.label<t[2]){_.label=t[2];_.ops.push(op);break;}if(t[2])_.ops.pop();_.trys.pop();continue;}op=body.call(thisArg,_);}catch(e){op=[6,e];y=0;}finally{f=t=0;}}if(op[0]&5)throw op[1];return{value:op[0]?op[1]:void 0,done:true};}};Object.defineProperty(exports,\"__esModule\",{value:true});var logger=new lib.Logger(_version$6.version);function defineReadOnly(object,name,value){Object.defineProperty(object,name,{enumerable:true,value:value,writable:false});}exports.defineReadOnly=defineReadOnly;// Crawl up the constructor chain to find a static method\nfunction getStatic(ctor,key){for(var i=0;i<32;i++){if(ctor[key]){return ctor[key];}if(!ctor.prototype||_typeof(ctor.prototype)!==\"object\"){break;}ctor=Object.getPrototypeOf(ctor.prototype).constructor;}return null;}exports.getStatic=getStatic;function resolveProperties(object){return __awaiter(this,void 0,void 0,function(){var promises,results;return __generator(this,function(_a){switch(_a.label){case 0:promises=Object.keys(object).map(function(key){var value=object[key];return Promise.resolve(value).then(function(v){return{key:key,value:v};});});return[4/*yield*/,Promise.all(promises)];case 1:results=_a.sent();return[2/*return*/,results.reduce(function(accum,result){accum[result.key]=result.value;return accum;},{})];}});});}exports.resolveProperties=resolveProperties;function checkProperties(object,properties){if(!object||_typeof(object)!==\"object\"){logger.throwArgumentError(\"invalid object\",\"object\",object);}Object.keys(object).forEach(function(key){if(!properties[key]){logger.throwArgumentError(\"invalid object key - \"+key,\"transaction:\"+key,object);}});}exports.checkProperties=checkProperties;function shallowCopy(object){var result={};for(var key in object){result[key]=object[key];}return result;}exports.shallowCopy=shallowCopy;var opaque={bigint:true,boolean:true,\"function\":true,number:true,string:true};function _isFrozen(object){// Opaque objects are not mutable, so safe to copy by assignment\nif(object===undefined||object===null||opaque[_typeof(object)]){return true;}if(Array.isArray(object)||_typeof(object)===\"object\"){if(!Object.isFrozen(object)){return false;}var keys=Object.keys(object);for(var i=0;i<keys.length;i++){if(!_isFrozen(object[keys[i]])){return false;}}return true;}return logger.throwArgumentError(\"Cannot deepCopy \"+_typeof(object),\"object\",object);}// Returns a new copy of object, such that no properties may be replaced.\n// New properties may be added only to objects.\nfunction _deepCopy(object){if(_isFrozen(object)){return object;}// Arrays are mutable, so we need to create a copy\nif(Array.isArray(object)){return Object.freeze(object.map(function(item){return deepCopy(item);}));}if(_typeof(object)===\"object\"){var result={};for(var key in object){var value=object[key];if(value===undefined){continue;}defineReadOnly(result,key,deepCopy(value));}return result;}return logger.throwArgumentError(\"Cannot deepCopy \"+_typeof(object),\"object\",object);}function deepCopy(object){return _deepCopy(object);}exports.deepCopy=deepCopy;var Description=/** @class */function(){function Description(info){for(var key in info){this[key]=deepCopy(info[key]);}}return Description;}();exports.Description=Description;});var index$3=unwrapExports(lib$3);var lib_1$3=lib$3.defineReadOnly;var lib_2$3=lib$3.getStatic;var lib_3$3=lib$3.resolveProperties;var lib_4$2=lib$3.checkProperties;var lib_5$2=lib$3.shallowCopy;var lib_6$1=lib$3.deepCopy;var lib_7$1=lib$3.Description;var _version$8=createCommonjsModule(function(module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});exports.version=\"abi/5.0.2\";});var _version$9=unwrapExports(_version$8);var _version_1$4=_version$8.version;var fragments=createCommonjsModule(function(module,exports){\"use strict\";var __extends=commonjsGlobal&&commonjsGlobal.__extends||function(){var _extendStatics=function extendStatics(d,b){_extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return _extendStatics(d,b);};return function(d,b){_extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,\"__esModule\",{value:true});var logger=new lib.Logger(_version$8.version);;var _constructorGuard={};var ModifiersBytes={calldata:true,memory:true,storage:true};var ModifiersNest={calldata:true,memory:true};function checkModifier(type,name){if(type===\"bytes\"||type===\"string\"){if(ModifiersBytes[name]){return true;}}else if(type===\"address\"){if(name===\"payable\"){return true;}}else if(type.indexOf(\"[\")>=0||type===\"tuple\"){if(ModifiersNest[name]){return true;}}if(ModifiersBytes[name]||name===\"payable\"){logger.throwArgumentError(\"invalid modifier\",\"name\",name);}return false;}// @TODO: Make sure that children of an indexed tuple are marked with a null indexed\nfunction parseParamType(param,allowIndexed){var originalParam=param;function throwError(i){logger.throwArgumentError(\"unexpected character at position \"+i,\"param\",param);}param=param.replace(/\\s/g,\" \");function newNode(parent){var node={type:\"\",name:\"\",parent:parent,state:{allowType:true}};if(allowIndexed){node.indexed=false;}return node;}var parent={type:\"\",name:\"\",state:{allowType:true}};var node=parent;for(var i=0;i<param.length;i++){var c=param[i];switch(c){case\"(\":if(node.state.allowType&&node.type===\"\"){node.type=\"tuple\";}else if(!node.state.allowParams){throwError(i);}node.state.allowType=false;node.type=verifyType(node.type);node.components=[newNode(node)];node=node.components[0];break;case\")\":delete node.state;if(node.name===\"indexed\"){if(!allowIndexed){throwError(i);}node.indexed=true;node.name=\"\";}if(checkModifier(node.type,node.name)){node.name=\"\";}node.type=verifyType(node.type);var child=node;node=node.parent;if(!node){throwError(i);}delete child.parent;node.state.allowParams=false;node.state.allowName=true;node.state.allowArray=true;break;case\",\":delete node.state;if(node.name===\"indexed\"){if(!allowIndexed){throwError(i);}node.indexed=true;node.name=\"\";}if(checkModifier(node.type,node.name)){node.name=\"\";}node.type=verifyType(node.type);var sibling=newNode(node.parent);//{ type: \"\", name: \"\", parent: node.parent, state: { allowType: true } };\nnode.parent.components.push(sibling);delete node.parent;node=sibling;break;// Hit a space...\ncase\" \":// If reading type, the type is done and may read a param or name\nif(node.state.allowType){if(node.type!==\"\"){node.type=verifyType(node.type);delete node.state.allowType;node.state.allowName=true;node.state.allowParams=true;}}// If reading name, the name is done\nif(node.state.allowName){if(node.name!==\"\"){if(node.name===\"indexed\"){if(!allowIndexed){throwError(i);}if(node.indexed){throwError(i);}node.indexed=true;node.name=\"\";}else if(checkModifier(node.type,node.name)){node.name=\"\";}else{node.state.allowName=false;}}}break;case\"[\":if(!node.state.allowArray){throwError(i);}node.type+=c;node.state.allowArray=false;node.state.allowName=false;node.state.readArray=true;break;case\"]\":if(!node.state.readArray){throwError(i);}node.type+=c;node.state.readArray=false;node.state.allowArray=true;node.state.allowName=true;break;default:if(node.state.allowType){node.type+=c;node.state.allowParams=true;node.state.allowArray=true;}else if(node.state.allowName){node.name+=c;delete node.state.allowArray;}else if(node.state.readArray){node.type+=c;}else{throwError(i);}}}if(node.parent){logger.throwArgumentError(\"unexpected eof\",\"param\",param);}delete parent.state;if(node.name===\"indexed\"){if(!allowIndexed){throwError(originalParam.length-7);}if(node.indexed){throwError(originalParam.length-7);}node.indexed=true;node.name=\"\";}else if(checkModifier(node.type,node.name)){node.name=\"\";}parent.type=verifyType(parent.type);return parent;}function populate(object,params){for(var key in params){lib$3.defineReadOnly(object,key,params[key]);}}exports.FormatTypes=Object.freeze({// Bare formatting, as is needed for computing a sighash of an event or function\nsighash:\"sighash\",// Human-Readable with Minimal spacing and without names (compact human-readable)\nminimal:\"minimal\",// Human-Readble with nice spacing, including all names\nfull:\"full\",// JSON-format a la Solidity\njson:\"json\"});var paramTypeArray=new RegExp(/^(.*)\\[([0-9]*)\\]$/);var ParamType=/** @class */function(){function ParamType(constructorGuard,params){if(constructorGuard!==_constructorGuard){logger.throwError(\"use fromString\",lib.Logger.errors.UNSUPPORTED_OPERATION,{operation:\"new ParamType()\"});}populate(this,params);var match=this.type.match(paramTypeArray);if(match){populate(this,{arrayLength:parseInt(match[2]||\"-1\"),arrayChildren:ParamType.fromObject({type:match[1],components:this.components}),baseType:\"array\"});}else{populate(this,{arrayLength:null,arrayChildren:null,baseType:this.components!=null?\"tuple\":this.type});}this._isParamType=true;Object.freeze(this);}// Format the parameter fragment\n//   - sighash: \"(uint256,address)\"\n//   - minimal: \"tuple(uint256,address) indexed\"\n//   - full:    \"tuple(uint256 foo, addres bar) indexed baz\"\nParamType.prototype.format=function(format){if(!format){format=exports.FormatTypes.sighash;}if(!exports.FormatTypes[format]){logger.throwArgumentError(\"invalid format type\",\"format\",format);}if(format===exports.FormatTypes.json){var result_1={type:this.baseType===\"tuple\"?\"tuple\":this.type,name:this.name||undefined};if(typeof this.indexed===\"boolean\"){result_1.indexed=this.indexed;}if(this.components){result_1.components=this.components.map(function(comp){return JSON.parse(comp.format(format));});}return JSON.stringify(result_1);}var result=\"\";// Array\nif(this.baseType===\"array\"){result+=this.arrayChildren.format(format);result+=\"[\"+(this.arrayLength<0?\"\":String(this.arrayLength))+\"]\";}else{if(this.baseType===\"tuple\"){if(format!==exports.FormatTypes.sighash){result+=this.type;}result+=\"(\"+this.components.map(function(comp){return comp.format(format);}).join(format===exports.FormatTypes.full?\", \":\",\")+\")\";}else{result+=this.type;}}if(format!==exports.FormatTypes.sighash){if(this.indexed===true){result+=\" indexed\";}if(format===exports.FormatTypes.full&&this.name){result+=\" \"+this.name;}}return result;};ParamType.from=function(value,allowIndexed){if(typeof value===\"string\"){return ParamType.fromString(value,allowIndexed);}return ParamType.fromObject(value);};ParamType.fromObject=function(value){if(ParamType.isParamType(value)){return value;}return new ParamType(_constructorGuard,{name:value.name||null,type:verifyType(value.type),indexed:value.indexed==null?null:!!value.indexed,components:value.components?value.components.map(ParamType.fromObject):null});};ParamType.fromString=function(value,allowIndexed){function ParamTypify(node){return ParamType.fromObject({name:node.name,type:node.type,indexed:node.indexed,components:node.components});}return ParamTypify(parseParamType(value,!!allowIndexed));};ParamType.isParamType=function(value){return!!(value!=null&&value._isParamType);};return ParamType;}();exports.ParamType=ParamType;;function parseParams(value,allowIndex){return splitNesting(value).map(function(param){return ParamType.fromString(param,allowIndex);});}var Fragment=/** @class */function(){function Fragment(constructorGuard,params){if(constructorGuard!==_constructorGuard){logger.throwError(\"use a static from method\",lib.Logger.errors.UNSUPPORTED_OPERATION,{operation:\"new Fragment()\"});}populate(this,params);this._isFragment=true;Object.freeze(this);}Fragment.from=function(value){if(Fragment.isFragment(value)){return value;}if(typeof value===\"string\"){return Fragment.fromString(value);}return Fragment.fromObject(value);};Fragment.fromObject=function(value){if(Fragment.isFragment(value)){return value;}switch(value.type){case\"function\":return FunctionFragment.fromObject(value);case\"event\":return EventFragment.fromObject(value);case\"constructor\":return ConstructorFragment.fromObject(value);case\"fallback\":case\"receive\":// @TODO: Something? Maybe return a FunctionFragment? A custom DefaultFunctionFragment?\nreturn null;}return logger.throwArgumentError(\"invalid fragment object\",\"value\",value);};Fragment.fromString=function(value){// Make sure the \"returns\" is surrounded by a space and all whitespace is exactly one space\nvalue=value.replace(/\\s/g,\" \");value=value.replace(/\\(/g,\" (\").replace(/\\)/g,\") \").replace(/\\s+/g,\" \");value=value.trim();if(value.split(\" \")[0]===\"event\"){return EventFragment.fromString(value.substring(5).trim());}else if(value.split(\" \")[0]===\"function\"){return FunctionFragment.fromString(value.substring(8).trim());}else if(value.split(\"(\")[0].trim()===\"constructor\"){return ConstructorFragment.fromString(value.trim());}return logger.throwArgumentError(\"unsupported fragment\",\"value\",value);};Fragment.isFragment=function(value){return!!(value&&value._isFragment);};return Fragment;}();exports.Fragment=Fragment;var EventFragment=/** @class */function(_super){__extends(EventFragment,_super);function EventFragment(){return _super!==null&&_super.apply(this,arguments)||this;}EventFragment.prototype.format=function(format){if(!format){format=exports.FormatTypes.sighash;}if(!exports.FormatTypes[format]){logger.throwArgumentError(\"invalid format type\",\"format\",format);}if(format===exports.FormatTypes.json){return JSON.stringify({type:\"event\",anonymous:this.anonymous,name:this.name,inputs:this.inputs.map(function(input){return JSON.parse(input.format(format));})});}var result=\"\";if(format!==exports.FormatTypes.sighash){result+=\"event \";}result+=this.name+\"(\"+this.inputs.map(function(input){return input.format(format);}).join(format===exports.FormatTypes.full?\", \":\",\")+\") \";if(format!==exports.FormatTypes.sighash){if(this.anonymous){result+=\"anonymous \";}}return result.trim();};EventFragment.from=function(value){if(typeof value===\"string\"){return EventFragment.fromString(value);}return EventFragment.fromObject(value);};EventFragment.fromObject=function(value){if(EventFragment.isEventFragment(value)){return value;}if(value.type!==\"event\"){logger.throwArgumentError(\"invalid event object\",\"value\",value);}var params={name:verifyIdentifier(value.name),anonymous:value.anonymous,inputs:value.inputs?value.inputs.map(ParamType.fromObject):[],type:\"event\"};return new EventFragment(_constructorGuard,params);};EventFragment.fromString=function(value){var match=value.match(regexParen);if(!match){logger.throwArgumentError(\"invalid event string\",\"value\",value);}var anonymous=false;match[3].split(\" \").forEach(function(modifier){switch(modifier.trim()){case\"anonymous\":anonymous=true;break;case\"\":break;default:logger.warn(\"unknown modifier: \"+modifier);}});return EventFragment.fromObject({name:match[1].trim(),anonymous:anonymous,inputs:parseParams(match[2],true),type:\"event\"});};EventFragment.isEventFragment=function(value){return value&&value._isFragment&&value.type===\"event\";};return EventFragment;}(Fragment);exports.EventFragment=EventFragment;function parseGas(value,params){params.gas=null;var comps=value.split(\"@\");if(comps.length!==1){if(comps.length>2){logger.throwArgumentError(\"invalid human-readable ABI signature\",\"value\",value);}if(!comps[1].match(/^[0-9]+$/)){logger.throwArgumentError(\"invalid human-readable ABI signature gas\",\"value\",value);}params.gas=lib$2.BigNumber.from(comps[1]);return comps[0];}return value;}function parseModifiers(value,params){params.constant=false;params.payable=false;params.stateMutability=\"nonpayable\";value.split(\" \").forEach(function(modifier){switch(modifier.trim()){case\"constant\":params.constant=true;break;case\"payable\":params.payable=true;params.stateMutability=\"payable\";break;case\"nonpayable\":params.payable=false;params.stateMutability=\"nonpayable\";break;case\"pure\":params.constant=true;params.stateMutability=\"pure\";break;case\"view\":params.constant=true;params.stateMutability=\"view\";break;case\"external\":case\"public\":case\"\":break;default:console.log(\"unknown modifier: \"+modifier);}});}function verifyState(value){var result={constant:false,payable:true,stateMutability:\"payable\"};if(value.stateMutability!=null){result.stateMutability=value.stateMutability;// Set (and check things are consistent) the constant property\nresult.constant=result.stateMutability===\"view\"||result.stateMutability===\"pure\";if(value.constant!=null){if(!!value.constant!==result.constant){logger.throwArgumentError(\"cannot have constant function with mutability \"+result.stateMutability,\"value\",value);}}// Set (and check things are consistent) the payable property\nresult.payable=result.stateMutability===\"payable\";if(value.payable!=null){if(!!value.payable!==result.payable){logger.throwArgumentError(\"cannot have payable function with mutability \"+result.stateMutability,\"value\",value);}}}else if(value.payable!=null){result.payable=!!value.payable;// If payable we can assume non-constant; otherwise we can't assume\nif(value.constant==null&&!result.payable&&value.type!==\"constructor\"){logger.throwArgumentError(\"unable to determine stateMutability\",\"value\",value);}result.constant=!!value.constant;if(result.constant){result.stateMutability=\"view\";}else{result.stateMutability=result.payable?\"payable\":\"nonpayable\";}if(result.payable&&result.constant){logger.throwArgumentError(\"cannot have constant payable function\",\"value\",value);}}else if(value.constant!=null){result.constant=!!value.constant;result.payable=!result.constant;result.stateMutability=result.constant?\"view\":\"payable\";}else if(value.type!==\"constructor\"){logger.throwArgumentError(\"unable to determine stateMutability\",\"value\",value);}return result;}var ConstructorFragment=/** @class */function(_super){__extends(ConstructorFragment,_super);function ConstructorFragment(){return _super!==null&&_super.apply(this,arguments)||this;}ConstructorFragment.prototype.format=function(format){if(!format){format=exports.FormatTypes.sighash;}if(!exports.FormatTypes[format]){logger.throwArgumentError(\"invalid format type\",\"format\",format);}if(format===exports.FormatTypes.json){return JSON.stringify({type:\"constructor\",stateMutability:this.stateMutability!==\"nonpayable\"?this.stateMutability:undefined,payble:this.payable,gas:this.gas?this.gas.toNumber():undefined,inputs:this.inputs.map(function(input){return JSON.parse(input.format(format));})});}if(format===exports.FormatTypes.sighash){logger.throwError(\"cannot format a constructor for sighash\",lib.Logger.errors.UNSUPPORTED_OPERATION,{operation:\"format(sighash)\"});}var result=\"constructor(\"+this.inputs.map(function(input){return input.format(format);}).join(format===exports.FormatTypes.full?\", \":\",\")+\") \";if(this.stateMutability&&this.stateMutability!==\"nonpayable\"){result+=this.stateMutability+\" \";}return result.trim();};ConstructorFragment.from=function(value){if(typeof value===\"string\"){return ConstructorFragment.fromString(value);}return ConstructorFragment.fromObject(value);};ConstructorFragment.fromObject=function(value){if(ConstructorFragment.isConstructorFragment(value)){return value;}if(value.type!==\"constructor\"){logger.throwArgumentError(\"invalid constructor object\",\"value\",value);}var state=verifyState(value);if(state.constant){logger.throwArgumentError(\"constructor cannot be constant\",\"value\",value);}var params={name:null,type:value.type,inputs:value.inputs?value.inputs.map(ParamType.fromObject):[],payable:state.payable,stateMutability:state.stateMutability,gas:value.gas?lib$2.BigNumber.from(value.gas):null};return new ConstructorFragment(_constructorGuard,params);};ConstructorFragment.fromString=function(value){var params={type:\"constructor\"};value=parseGas(value,params);var parens=value.match(regexParen);if(!parens||parens[1].trim()!==\"constructor\"){logger.throwArgumentError(\"invalid constructor string\",\"value\",value);}params.inputs=parseParams(parens[2].trim(),false);parseModifiers(parens[3].trim(),params);return ConstructorFragment.fromObject(params);};ConstructorFragment.isConstructorFragment=function(value){return value&&value._isFragment&&value.type===\"constructor\";};return ConstructorFragment;}(Fragment);exports.ConstructorFragment=ConstructorFragment;var FunctionFragment=/** @class */function(_super){__extends(FunctionFragment,_super);function FunctionFragment(){return _super!==null&&_super.apply(this,arguments)||this;}FunctionFragment.prototype.format=function(format){if(!format){format=exports.FormatTypes.sighash;}if(!exports.FormatTypes[format]){logger.throwArgumentError(\"invalid format type\",\"format\",format);}if(format===exports.FormatTypes.json){return JSON.stringify({type:\"function\",name:this.name,constant:this.constant,stateMutability:this.stateMutability!==\"nonpayable\"?this.stateMutability:undefined,payble:this.payable,gas:this.gas?this.gas.toNumber():undefined,inputs:this.inputs.map(function(input){return JSON.parse(input.format(format));}),ouputs:this.outputs.map(function(output){return JSON.parse(output.format(format));})});}var result=\"\";if(format!==exports.FormatTypes.sighash){result+=\"function \";}result+=this.name+\"(\"+this.inputs.map(function(input){return input.format(format);}).join(format===exports.FormatTypes.full?\", \":\",\")+\") \";if(format!==exports.FormatTypes.sighash){if(this.stateMutability){if(this.stateMutability!==\"nonpayable\"){result+=this.stateMutability+\" \";}}else if(this.constant){result+=\"view \";}if(this.outputs&&this.outputs.length){result+=\"returns (\"+this.outputs.map(function(output){return output.format(format);}).join(\", \")+\") \";}if(this.gas!=null){result+=\"@\"+this.gas.toString()+\" \";}}return result.trim();};FunctionFragment.from=function(value){if(typeof value===\"string\"){return FunctionFragment.fromString(value);}return FunctionFragment.fromObject(value);};FunctionFragment.fromObject=function(value){if(FunctionFragment.isFunctionFragment(value)){return value;}if(value.type!==\"function\"){logger.throwArgumentError(\"invalid function object\",\"value\",value);}var state=verifyState(value);var params={type:value.type,name:verifyIdentifier(value.name),constant:state.constant,inputs:value.inputs?value.inputs.map(ParamType.fromObject):[],outputs:value.outputs?value.outputs.map(ParamType.fromObject):[],payable:state.payable,stateMutability:state.stateMutability,gas:value.gas?lib$2.BigNumber.from(value.gas):null};return new FunctionFragment(_constructorGuard,params);};FunctionFragment.fromString=function(value){var params={type:\"function\"};value=parseGas(value,params);var comps=value.split(\" returns \");if(comps.length>2){logger.throwArgumentError(\"invalid function string\",\"value\",value);}var parens=comps[0].match(regexParen);if(!parens){logger.throwArgumentError(\"invalid function signature\",\"value\",value);}params.name=parens[1].trim();if(params.name){verifyIdentifier(params.name);}params.inputs=parseParams(parens[2],false);parseModifiers(parens[3].trim(),params);// We have outputs\nif(comps.length>1){var returns=comps[1].match(regexParen);if(returns[1].trim()!=\"\"||returns[3].trim()!=\"\"){logger.throwArgumentError(\"unexpected tokens\",\"value\",value);}params.outputs=parseParams(returns[2],false);}else{params.outputs=[];}return FunctionFragment.fromObject(params);};FunctionFragment.isFunctionFragment=function(value){return value&&value._isFragment&&value.type===\"function\";};return FunctionFragment;}(ConstructorFragment);exports.FunctionFragment=FunctionFragment;//export class ErrorFragment extends Fragment {\n//}\n//export class StructFragment extends Fragment {\n//}\nfunction verifyType(type){// These need to be transformed to their full description\nif(type.match(/^uint($|[^1-9])/)){type=\"uint256\"+type.substring(4);}else if(type.match(/^int($|[^1-9])/)){type=\"int256\"+type.substring(3);}// @TODO: more verification\nreturn type;}var regexIdentifier=new RegExp(\"^[A-Za-z_][A-Za-z0-9_]*$\");function verifyIdentifier(value){if(!value||!value.match(regexIdentifier)){logger.throwArgumentError(\"invalid identifier \\\"\"+value+\"\\\"\",\"value\",value);}return value;}var regexParen=new RegExp(\"^([^)(]*)\\\\((.*)\\\\)([^)(]*)$\");function splitNesting(value){value=value.trim();var result=[];var accum=\"\";var depth=0;for(var offset=0;offset<value.length;offset++){var c=value[offset];if(c===\",\"&&depth===0){result.push(accum);accum=\"\";}else{accum+=c;if(c===\"(\"){depth++;}else if(c===\")\"){depth--;if(depth===-1){logger.throwArgumentError(\"unbalanced parenthesis\",\"value\",value);}}}}if(accum){result.push(accum);}return result;}});var fragments$1=unwrapExports(fragments);var fragments_1=fragments.FormatTypes;var fragments_2=fragments.ParamType;var fragments_3=fragments.Fragment;var fragments_4=fragments.EventFragment;var fragments_5=fragments.ConstructorFragment;var fragments_6=fragments.FunctionFragment;var abstractCoder=createCommonjsModule(function(module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});var logger=new lib.Logger(_version$8.version);function checkResultErrors(result){// Find the first error (if any)\nvar errors=[];var checkErrors=function checkErrors(path,object){if(!Array.isArray(object)){return;}for(var key in object){var childPath=path.slice();childPath.push(key);try{checkErrors(childPath,object[key]);}catch(error){errors.push({path:childPath,error:error});}}};checkErrors([],result);return errors;}exports.checkResultErrors=checkResultErrors;var Coder=/** @class */function(){function Coder(name,type,localName,dynamic){// @TODO: defineReadOnly these\nthis.name=name;this.type=type;this.localName=localName;this.dynamic=dynamic;}Coder.prototype._throwError=function(message,value){logger.throwArgumentError(message,this.localName,value);};return Coder;}();exports.Coder=Coder;var Writer=/** @class */function(){function Writer(wordSize){lib$3.defineReadOnly(this,\"wordSize\",wordSize||32);this._data=lib$1.arrayify([]);this._padding=new Uint8Array(wordSize);}Object.defineProperty(Writer.prototype,\"data\",{get:function get(){return lib$1.hexlify(this._data);},enumerable:true,configurable:true});Object.defineProperty(Writer.prototype,\"length\",{get:function get(){return this._data.length;},enumerable:true,configurable:true});Writer.prototype._writeData=function(data){this._data=lib$1.concat([this._data,data]);return data.length;};// Arrayish items; padded on the right to wordSize\nWriter.prototype.writeBytes=function(value){var bytes=lib$1.arrayify(value);if(bytes.length%this.wordSize){bytes=lib$1.concat([bytes,this._padding.slice(bytes.length%this.wordSize)]);}return this._writeData(bytes);};Writer.prototype._getValue=function(value){var bytes=lib$1.arrayify(lib$2.BigNumber.from(value));if(bytes.length>this.wordSize){logger.throwError(\"value out-of-bounds\",lib.Logger.errors.BUFFER_OVERRUN,{length:this.wordSize,offset:bytes.length});}if(bytes.length%this.wordSize){bytes=lib$1.concat([this._padding.slice(bytes.length%this.wordSize),bytes]);}return bytes;};// BigNumberish items; padded on the left to wordSize\nWriter.prototype.writeValue=function(value){return this._writeData(this._getValue(value));};Writer.prototype.writeUpdatableValue=function(){var _this=this;var offset=this.length;this.writeValue(0);return function(value){_this._data.set(_this._getValue(value),offset);};};return Writer;}();exports.Writer=Writer;var Reader=/** @class */function(){function Reader(data,wordSize,coerceFunc){lib$3.defineReadOnly(this,\"_data\",lib$1.arrayify(data));lib$3.defineReadOnly(this,\"wordSize\",wordSize||32);lib$3.defineReadOnly(this,\"_coerceFunc\",coerceFunc);this._offset=0;}Object.defineProperty(Reader.prototype,\"data\",{get:function get(){return lib$1.hexlify(this._data);},enumerable:true,configurable:true});Object.defineProperty(Reader.prototype,\"consumed\",{get:function get(){return this._offset;},enumerable:true,configurable:true});// The default Coerce function\nReader.coerce=function(name,value){var match=name.match(\"^u?int([0-9]+)$\");if(match&&parseInt(match[1])<=48){value=value.toNumber();}return value;};Reader.prototype.coerce=function(name,value){if(this._coerceFunc){return this._coerceFunc(name,value);}return Reader.coerce(name,value);};Reader.prototype._peekBytes=function(offset,length){var alignedLength=Math.ceil(length/this.wordSize)*this.wordSize;if(this._offset+alignedLength>this._data.length){logger.throwError(\"data out-of-bounds\",lib.Logger.errors.BUFFER_OVERRUN,{length:this._data.length,offset:this._offset+alignedLength});}return this._data.slice(this._offset,this._offset+alignedLength);};Reader.prototype.subReader=function(offset){return new Reader(this._data.slice(this._offset+offset),this.wordSize,this._coerceFunc);};Reader.prototype.readBytes=function(length){var bytes=this._peekBytes(0,length);this._offset+=bytes.length;// @TODO: Make sure the length..end bytes are all 0?\nreturn bytes.slice(0,length);};Reader.prototype.readValue=function(){return lib$2.BigNumber.from(this.readBytes(this.wordSize));};return Reader;}();exports.Reader=Reader;});var abstractCoder$1=unwrapExports(abstractCoder);var abstractCoder_1=abstractCoder.checkResultErrors;var abstractCoder_2=abstractCoder.Coder;var abstractCoder_3=abstractCoder.Writer;var abstractCoder_4=abstractCoder.Reader;var sha3=createCommonjsModule(function(module){/**\r\n\t * [js-sha3]{@link https://github.com/emn178/js-sha3}\r\n\t *\r\n\t * @version 0.5.7\r\n\t * @author Chen, Yi-Cyuan [emn178@gmail.com]\r\n\t * @copyright Chen, Yi-Cyuan 2015-2016\r\n\t * @license MIT\r\n\t */ /*jslint bitwise: true */(function(){'use strict';var root=(typeof window===\"undefined\"?\"undefined\":_typeof(window))==='object'?window:{};var NODE_JS=!root.JS_SHA3_NO_NODE_JS&&(typeof process===\"undefined\"?\"undefined\":_typeof(process))==='object'&&process.versions&&process.versions.node;if(NODE_JS){root=commonjsGlobal;}var COMMON_JS=!root.JS_SHA3_NO_COMMON_JS&&'object'==='object'&&module.exports;var HEX_CHARS='0123456789abcdef'.split('');var SHAKE_PADDING=[31,7936,2031616,520093696];var KECCAK_PADDING=[1,256,65536,16777216];var PADDING=[6,1536,393216,100663296];var SHIFT=[0,8,16,24];var RC=[1,0,32898,0,32906,2147483648,2147516416,2147483648,32907,0,2147483649,0,2147516545,2147483648,32777,2147483648,138,0,136,0,2147516425,0,2147483658,0,2147516555,0,139,2147483648,32905,2147483648,32771,2147483648,32770,2147483648,128,2147483648,32778,0,2147483658,2147483648,2147516545,2147483648,32896,2147483648,2147483649,0,2147516424,2147483648];var BITS=[224,256,384,512];var SHAKE_BITS=[128,256];var OUTPUT_TYPES=['hex','buffer','arrayBuffer','array'];var createOutputMethod=function createOutputMethod(bits,padding,outputType){return function(message){return new Keccak(bits,padding,bits).update(message)[outputType]();};};var createShakeOutputMethod=function createShakeOutputMethod(bits,padding,outputType){return function(message,outputBits){return new Keccak(bits,padding,outputBits).update(message)[outputType]();};};var createMethod=function createMethod(bits,padding){var method=createOutputMethod(bits,padding,'hex');method.create=function(){return new Keccak(bits,padding,bits);};method.update=function(message){return method.create().update(message);};for(var i=0;i<OUTPUT_TYPES.length;++i){var type=OUTPUT_TYPES[i];method[type]=createOutputMethod(bits,padding,type);}return method;};var createShakeMethod=function createShakeMethod(bits,padding){var method=createShakeOutputMethod(bits,padding,'hex');method.create=function(outputBits){return new Keccak(bits,padding,outputBits);};method.update=function(message,outputBits){return method.create(outputBits).update(message);};for(var i=0;i<OUTPUT_TYPES.length;++i){var type=OUTPUT_TYPES[i];method[type]=createShakeOutputMethod(bits,padding,type);}return method;};var algorithms=[{name:'keccak',padding:KECCAK_PADDING,bits:BITS,createMethod:createMethod},{name:'sha3',padding:PADDING,bits:BITS,createMethod:createMethod},{name:'shake',padding:SHAKE_PADDING,bits:SHAKE_BITS,createMethod:createShakeMethod}];var methods={},methodNames=[];for(var i=0;i<algorithms.length;++i){var algorithm=algorithms[i];var bits=algorithm.bits;for(var j=0;j<bits.length;++j){var methodName=algorithm.name+'_'+bits[j];methodNames.push(methodName);methods[methodName]=algorithm.createMethod(bits[j],algorithm.padding);}}function Keccak(bits,padding,outputBits){this.blocks=[];this.s=[];this.padding=padding;this.outputBits=outputBits;this.reset=true;this.block=0;this.start=0;this.blockCount=1600-(bits<<1)>>5;this.byteCount=this.blockCount<<2;this.outputBlocks=outputBits>>5;this.extraBytes=(outputBits&31)>>3;for(var i=0;i<50;++i){this.s[i]=0;}}Keccak.prototype.update=function(message){var notString=typeof message!=='string';if(notString&&message.constructor===ArrayBuffer){message=new Uint8Array(message);}var length=message.length,blocks=this.blocks,byteCount=this.byteCount,blockCount=this.blockCount,index=0,s=this.s,i,code;while(index<length){if(this.reset){this.reset=false;blocks[0]=this.block;for(i=1;i<blockCount+1;++i){blocks[i]=0;}}if(notString){for(i=this.start;index<length&&i<byteCount;++index){blocks[i>>2]|=message[index]<<SHIFT[i++&3];}}else{for(i=this.start;index<length&&i<byteCount;++index){code=message.charCodeAt(index);if(code<0x80){blocks[i>>2]|=code<<SHIFT[i++&3];}else if(code<0x800){blocks[i>>2]|=(0xc0|code>>6)<<SHIFT[i++&3];blocks[i>>2]|=(0x80|code&0x3f)<<SHIFT[i++&3];}else if(code<0xd800||code>=0xe000){blocks[i>>2]|=(0xe0|code>>12)<<SHIFT[i++&3];blocks[i>>2]|=(0x80|code>>6&0x3f)<<SHIFT[i++&3];blocks[i>>2]|=(0x80|code&0x3f)<<SHIFT[i++&3];}else{code=0x10000+((code&0x3ff)<<10|message.charCodeAt(++index)&0x3ff);blocks[i>>2]|=(0xf0|code>>18)<<SHIFT[i++&3];blocks[i>>2]|=(0x80|code>>12&0x3f)<<SHIFT[i++&3];blocks[i>>2]|=(0x80|code>>6&0x3f)<<SHIFT[i++&3];blocks[i>>2]|=(0x80|code&0x3f)<<SHIFT[i++&3];}}}this.lastByteIndex=i;if(i>=byteCount){this.start=i-byteCount;this.block=blocks[blockCount];for(i=0;i<blockCount;++i){s[i]^=blocks[i];}f(s);this.reset=true;}else{this.start=i;}}return this;};Keccak.prototype.finalize=function(){var blocks=this.blocks,i=this.lastByteIndex,blockCount=this.blockCount,s=this.s;blocks[i>>2]|=this.padding[i&3];if(this.lastByteIndex===this.byteCount){blocks[0]=blocks[blockCount];for(i=1;i<blockCount+1;++i){blocks[i]=0;}}blocks[blockCount-1]|=0x80000000;for(i=0;i<blockCount;++i){s[i]^=blocks[i];}f(s);};Keccak.prototype.toString=Keccak.prototype.hex=function(){this.finalize();var blockCount=this.blockCount,s=this.s,outputBlocks=this.outputBlocks,extraBytes=this.extraBytes,i=0,j=0;var hex='',block;while(j<outputBlocks){for(i=0;i<blockCount&&j<outputBlocks;++i,++j){block=s[i];hex+=HEX_CHARS[block>>4&0x0F]+HEX_CHARS[block&0x0F]+HEX_CHARS[block>>12&0x0F]+HEX_CHARS[block>>8&0x0F]+HEX_CHARS[block>>20&0x0F]+HEX_CHARS[block>>16&0x0F]+HEX_CHARS[block>>28&0x0F]+HEX_CHARS[block>>24&0x0F];}if(j%blockCount===0){f(s);i=0;}}if(extraBytes){block=s[i];if(extraBytes>0){hex+=HEX_CHARS[block>>4&0x0F]+HEX_CHARS[block&0x0F];}if(extraBytes>1){hex+=HEX_CHARS[block>>12&0x0F]+HEX_CHARS[block>>8&0x0F];}if(extraBytes>2){hex+=HEX_CHARS[block>>20&0x0F]+HEX_CHARS[block>>16&0x0F];}}return hex;};Keccak.prototype.arrayBuffer=function(){this.finalize();var blockCount=this.blockCount,s=this.s,outputBlocks=this.outputBlocks,extraBytes=this.extraBytes,i=0,j=0;var bytes=this.outputBits>>3;var buffer;if(extraBytes){buffer=new ArrayBuffer(outputBlocks+1<<2);}else{buffer=new ArrayBuffer(bytes);}var array=new Uint32Array(buffer);while(j<outputBlocks){for(i=0;i<blockCount&&j<outputBlocks;++i,++j){array[j]=s[i];}if(j%blockCount===0){f(s);}}if(extraBytes){array[i]=s[i];buffer=buffer.slice(0,bytes);}return buffer;};Keccak.prototype.buffer=Keccak.prototype.arrayBuffer;Keccak.prototype.digest=Keccak.prototype.array=function(){this.finalize();var blockCount=this.blockCount,s=this.s,outputBlocks=this.outputBlocks,extraBytes=this.extraBytes,i=0,j=0;var array=[],offset,block;while(j<outputBlocks){for(i=0;i<blockCount&&j<outputBlocks;++i,++j){offset=j<<2;block=s[i];array[offset]=block&0xFF;array[offset+1]=block>>8&0xFF;array[offset+2]=block>>16&0xFF;array[offset+3]=block>>24&0xFF;}if(j%blockCount===0){f(s);}}if(extraBytes){offset=j<<2;block=s[i];if(extraBytes>0){array[offset]=block&0xFF;}if(extraBytes>1){array[offset+1]=block>>8&0xFF;}if(extraBytes>2){array[offset+2]=block>>16&0xFF;}}return array;};var f=function f(s){var h,l,n,c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,b0,b1,b2,b3,b4,b5,b6,b7,b8,b9,b10,b11,b12,b13,b14,b15,b16,b17,b18,b19,b20,b21,b22,b23,b24,b25,b26,b27,b28,b29,b30,b31,b32,b33,b34,b35,b36,b37,b38,b39,b40,b41,b42,b43,b44,b45,b46,b47,b48,b49;for(n=0;n<48;n+=2){c0=s[0]^s[10]^s[20]^s[30]^s[40];c1=s[1]^s[11]^s[21]^s[31]^s[41];c2=s[2]^s[12]^s[22]^s[32]^s[42];c3=s[3]^s[13]^s[23]^s[33]^s[43];c4=s[4]^s[14]^s[24]^s[34]^s[44];c5=s[5]^s[15]^s[25]^s[35]^s[45];c6=s[6]^s[16]^s[26]^s[36]^s[46];c7=s[7]^s[17]^s[27]^s[37]^s[47];c8=s[8]^s[18]^s[28]^s[38]^s[48];c9=s[9]^s[19]^s[29]^s[39]^s[49];h=c8^(c2<<1|c3>>>31);l=c9^(c3<<1|c2>>>31);s[0]^=h;s[1]^=l;s[10]^=h;s[11]^=l;s[20]^=h;s[21]^=l;s[30]^=h;s[31]^=l;s[40]^=h;s[41]^=l;h=c0^(c4<<1|c5>>>31);l=c1^(c5<<1|c4>>>31);s[2]^=h;s[3]^=l;s[12]^=h;s[13]^=l;s[22]^=h;s[23]^=l;s[32]^=h;s[33]^=l;s[42]^=h;s[43]^=l;h=c2^(c6<<1|c7>>>31);l=c3^(c7<<1|c6>>>31);s[4]^=h;s[5]^=l;s[14]^=h;s[15]^=l;s[24]^=h;s[25]^=l;s[34]^=h;s[35]^=l;s[44]^=h;s[45]^=l;h=c4^(c8<<1|c9>>>31);l=c5^(c9<<1|c8>>>31);s[6]^=h;s[7]^=l;s[16]^=h;s[17]^=l;s[26]^=h;s[27]^=l;s[36]^=h;s[37]^=l;s[46]^=h;s[47]^=l;h=c6^(c0<<1|c1>>>31);l=c7^(c1<<1|c0>>>31);s[8]^=h;s[9]^=l;s[18]^=h;s[19]^=l;s[28]^=h;s[29]^=l;s[38]^=h;s[39]^=l;s[48]^=h;s[49]^=l;b0=s[0];b1=s[1];b32=s[11]<<4|s[10]>>>28;b33=s[10]<<4|s[11]>>>28;b14=s[20]<<3|s[21]>>>29;b15=s[21]<<3|s[20]>>>29;b46=s[31]<<9|s[30]>>>23;b47=s[30]<<9|s[31]>>>23;b28=s[40]<<18|s[41]>>>14;b29=s[41]<<18|s[40]>>>14;b20=s[2]<<1|s[3]>>>31;b21=s[3]<<1|s[2]>>>31;b2=s[13]<<12|s[12]>>>20;b3=s[12]<<12|s[13]>>>20;b34=s[22]<<10|s[23]>>>22;b35=s[23]<<10|s[22]>>>22;b16=s[33]<<13|s[32]>>>19;b17=s[32]<<13|s[33]>>>19;b48=s[42]<<2|s[43]>>>30;b49=s[43]<<2|s[42]>>>30;b40=s[5]<<30|s[4]>>>2;b41=s[4]<<30|s[5]>>>2;b22=s[14]<<6|s[15]>>>26;b23=s[15]<<6|s[14]>>>26;b4=s[25]<<11|s[24]>>>21;b5=s[24]<<11|s[25]>>>21;b36=s[34]<<15|s[35]>>>17;b37=s[35]<<15|s[34]>>>17;b18=s[45]<<29|s[44]>>>3;b19=s[44]<<29|s[45]>>>3;b10=s[6]<<28|s[7]>>>4;b11=s[7]<<28|s[6]>>>4;b42=s[17]<<23|s[16]>>>9;b43=s[16]<<23|s[17]>>>9;b24=s[26]<<25|s[27]>>>7;b25=s[27]<<25|s[26]>>>7;b6=s[36]<<21|s[37]>>>11;b7=s[37]<<21|s[36]>>>11;b38=s[47]<<24|s[46]>>>8;b39=s[46]<<24|s[47]>>>8;b30=s[8]<<27|s[9]>>>5;b31=s[9]<<27|s[8]>>>5;b12=s[18]<<20|s[19]>>>12;b13=s[19]<<20|s[18]>>>12;b44=s[29]<<7|s[28]>>>25;b45=s[28]<<7|s[29]>>>25;b26=s[38]<<8|s[39]>>>24;b27=s[39]<<8|s[38]>>>24;b8=s[48]<<14|s[49]>>>18;b9=s[49]<<14|s[48]>>>18;s[0]=b0^~b2&b4;s[1]=b1^~b3&b5;s[10]=b10^~b12&b14;s[11]=b11^~b13&b15;s[20]=b20^~b22&b24;s[21]=b21^~b23&b25;s[30]=b30^~b32&b34;s[31]=b31^~b33&b35;s[40]=b40^~b42&b44;s[41]=b41^~b43&b45;s[2]=b2^~b4&b6;s[3]=b3^~b5&b7;s[12]=b12^~b14&b16;s[13]=b13^~b15&b17;s[22]=b22^~b24&b26;s[23]=b23^~b25&b27;s[32]=b32^~b34&b36;s[33]=b33^~b35&b37;s[42]=b42^~b44&b46;s[43]=b43^~b45&b47;s[4]=b4^~b6&b8;s[5]=b5^~b7&b9;s[14]=b14^~b16&b18;s[15]=b15^~b17&b19;s[24]=b24^~b26&b28;s[25]=b25^~b27&b29;s[34]=b34^~b36&b38;s[35]=b35^~b37&b39;s[44]=b44^~b46&b48;s[45]=b45^~b47&b49;s[6]=b6^~b8&b0;s[7]=b7^~b9&b1;s[16]=b16^~b18&b10;s[17]=b17^~b19&b11;s[26]=b26^~b28&b20;s[27]=b27^~b29&b21;s[36]=b36^~b38&b30;s[37]=b37^~b39&b31;s[46]=b46^~b48&b40;s[47]=b47^~b49&b41;s[8]=b8^~b0&b2;s[9]=b9^~b1&b3;s[18]=b18^~b10&b12;s[19]=b19^~b11&b13;s[28]=b28^~b20&b22;s[29]=b29^~b21&b23;s[38]=b38^~b30&b32;s[39]=b39^~b31&b33;s[48]=b48^~b40&b42;s[49]=b49^~b41&b43;s[0]^=RC[n];s[1]^=RC[n+1];}};if(COMMON_JS){module.exports=methods;}else{for(var i=0;i<methodNames.length;++i){root[methodNames[i]]=methods[methodNames[i]];}}})();});var lib$4=createCommonjsModule(function(module,exports){\"use strict\";var __importDefault=commonjsGlobal&&commonjsGlobal.__importDefault||function(mod){return mod&&mod.__esModule?mod:{\"default\":mod};};Object.defineProperty(exports,\"__esModule\",{value:true});var js_sha3_1=__importDefault(sha3);function keccak256(data){return'0x'+js_sha3_1.default.keccak_256(lib$1.arrayify(data));}exports.keccak256=keccak256;});var index$4=unwrapExports(lib$4);var lib_1$4=lib$4.keccak256;var _version$a=createCommonjsModule(function(module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});exports.version=\"rlp/5.0.2\";});var _version$b=unwrapExports(_version$a);var _version_1$5=_version$a.version;var lib$5=createCommonjsModule(function(module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});//See: https://github.com/ethereum/wiki/wiki/RLP\nvar logger=new lib.Logger(_version$a.version);function arrayifyInteger(value){var result=[];while(value){result.unshift(value&0xff);value>>=8;}return result;}function unarrayifyInteger(data,offset,length){var result=0;for(var i=0;i<length;i++){result=result*256+data[offset+i];}return result;}function _encode(object){if(Array.isArray(object)){var payload_1=[];object.forEach(function(child){payload_1=payload_1.concat(_encode(child));});if(payload_1.length<=55){payload_1.unshift(0xc0+payload_1.length);return payload_1;}var length_1=arrayifyInteger(payload_1.length);length_1.unshift(0xf7+length_1.length);return length_1.concat(payload_1);}if(!lib$1.isBytesLike(object)){logger.throwArgumentError(\"RLP object must be BytesLike\",\"object\",object);}var data=Array.prototype.slice.call(lib$1.arrayify(object));if(data.length===1&&data[0]<=0x7f){return data;}else if(data.length<=55){data.unshift(0x80+data.length);return data;}var length=arrayifyInteger(data.length);length.unshift(0xb7+length.length);return length.concat(data);}function encode(object){return lib$1.hexlify(_encode(object));}exports.encode=encode;function _decodeChildren(data,offset,childOffset,length){var result=[];while(childOffset<offset+1+length){var decoded=_decode(data,childOffset);result.push(decoded.result);childOffset+=decoded.consumed;if(childOffset>offset+1+length){logger.throwError(\"child data too short\",lib.Logger.errors.BUFFER_OVERRUN,{});}}return{consumed:1+length,result:result};}// returns { consumed: number, result: Object }\nfunction _decode(data,offset){if(data.length===0){logger.throwError(\"data too short\",lib.Logger.errors.BUFFER_OVERRUN,{});}// Array with extra length prefix\nif(data[offset]>=0xf8){var lengthLength=data[offset]-0xf7;if(offset+1+lengthLength>data.length){logger.throwError(\"data short segment too short\",lib.Logger.errors.BUFFER_OVERRUN,{});}var length_2=unarrayifyInteger(data,offset+1,lengthLength);if(offset+1+lengthLength+length_2>data.length){logger.throwError(\"data long segment too short\",lib.Logger.errors.BUFFER_OVERRUN,{});}return _decodeChildren(data,offset,offset+1+lengthLength,lengthLength+length_2);}else if(data[offset]>=0xc0){var length_3=data[offset]-0xc0;if(offset+1+length_3>data.length){logger.throwError(\"data array too short\",lib.Logger.errors.BUFFER_OVERRUN,{});}return _decodeChildren(data,offset,offset+1,length_3);}else if(data[offset]>=0xb8){var lengthLength=data[offset]-0xb7;if(offset+1+lengthLength>data.length){logger.throwError(\"data array too short\",lib.Logger.errors.BUFFER_OVERRUN,{});}var length_4=unarrayifyInteger(data,offset+1,lengthLength);if(offset+1+lengthLength+length_4>data.length){logger.throwError(\"data array too short\",lib.Logger.errors.BUFFER_OVERRUN,{});}var result=lib$1.hexlify(data.slice(offset+1+lengthLength,offset+1+lengthLength+length_4));return{consumed:1+lengthLength+length_4,result:result};}else if(data[offset]>=0x80){var length_5=data[offset]-0x80;if(offset+1+length_5>data.length){logger.throwError(\"data too short\",lib.Logger.errors.BUFFER_OVERRUN,{});}var result=lib$1.hexlify(data.slice(offset+1,offset+1+length_5));return{consumed:1+length_5,result:result};}return{consumed:1,result:lib$1.hexlify(data[offset])};}function decode(data){var bytes=lib$1.arrayify(data);var decoded=_decode(bytes,0);if(decoded.consumed!==bytes.length){logger.throwArgumentError(\"invalid rlp data\",\"data\",data);}return decoded.result;}exports.decode=decode;});var index$5=unwrapExports(lib$5);var lib_1$5=lib$5.encode;var lib_2$4=lib$5.decode;var _version$c=createCommonjsModule(function(module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});exports.version=\"address/5.0.2\";});var _version$d=unwrapExports(_version$c);var _version_1$6=_version$c.version;var lib$6=createCommonjsModule(function(module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});// We use this for base 36 maths\nvar logger=new lib.Logger(_version$c.version);function getChecksumAddress(address){if(!lib$1.isHexString(address,20)){logger.throwArgumentError(\"invalid address\",\"address\",address);}address=address.toLowerCase();var chars=address.substring(2).split(\"\");var expanded=new Uint8Array(40);for(var i=0;i<40;i++){expanded[i]=chars[i].charCodeAt(0);}var hashed=lib$1.arrayify(lib$4.keccak256(expanded));for(var i=0;i<40;i+=2){if(hashed[i>>1]>>4>=8){chars[i]=chars[i].toUpperCase();}if((hashed[i>>1]&0x0f)>=8){chars[i+1]=chars[i+1].toUpperCase();}}return\"0x\"+chars.join(\"\");}// Shims for environments that are missing some required constants and functions\nvar MAX_SAFE_INTEGER=0x1fffffffffffff;function log10(x){if(Math.log10){return Math.log10(x);}return Math.log(x)/Math.LN10;}// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n// Create lookup table\nvar ibanLookup={};for(var i=0;i<10;i++){ibanLookup[String(i)]=String(i);}for(var i=0;i<26;i++){ibanLookup[String.fromCharCode(65+i)]=String(10+i);}// How many decimal digits can we process? (for 64-bit float, this is 15)\nvar safeDigits=Math.floor(log10(MAX_SAFE_INTEGER));function ibanChecksum(address){address=address.toUpperCase();address=address.substring(4)+address.substring(0,2)+\"00\";var expanded=address.split(\"\").map(function(c){return ibanLookup[c];}).join(\"\");// Javascript can handle integers safely up to 15 (decimal) digits\nwhile(expanded.length>=safeDigits){var block=expanded.substring(0,safeDigits);expanded=parseInt(block,10)%97+expanded.substring(block.length);}var checksum=String(98-parseInt(expanded,10)%97);while(checksum.length<2){checksum=\"0\"+checksum;}return checksum;};function getAddress(address){var result=null;if(typeof address!==\"string\"){logger.throwArgumentError(\"invalid address\",\"address\",address);}if(address.match(/^(0x)?[0-9a-fA-F]{40}$/)){// Missing the 0x prefix\nif(address.substring(0,2)!==\"0x\"){address=\"0x\"+address;}result=getChecksumAddress(address);// It is a checksummed address with a bad checksum\nif(address.match(/([A-F].*[a-f])|([a-f].*[A-F])/)&&result!==address){logger.throwArgumentError(\"bad address checksum\",\"address\",address);}// Maybe ICAP? (we only support direct mode)\n}else if(address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)){// It is an ICAP address with a bad checksum\nif(address.substring(2,4)!==ibanChecksum(address)){logger.throwArgumentError(\"bad icap checksum\",\"address\",address);}result=new bn.BN(address.substring(4),36).toString(16);while(result.length<40){result=\"0\"+result;}result=getChecksumAddress(\"0x\"+result);}else{logger.throwArgumentError(\"invalid address\",\"address\",address);}return result;}exports.getAddress=getAddress;function isAddress(address){try{getAddress(address);return true;}catch(error){}return false;}exports.isAddress=isAddress;function getIcapAddress(address){var base36=new bn.BN(getAddress(address).substring(2),16).toString(36).toUpperCase();while(base36.length<30){base36=\"0\"+base36;}return\"XE\"+ibanChecksum(\"XE00\"+base36)+base36;}exports.getIcapAddress=getIcapAddress;// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed\nfunction getContractAddress(transaction){var from=null;try{from=getAddress(transaction.from);}catch(error){logger.throwArgumentError(\"missing from address\",\"transaction\",transaction);}var nonce=lib$1.stripZeros(lib$1.arrayify(lib$2.BigNumber.from(transaction.nonce).toHexString()));return getAddress(lib$1.hexDataSlice(lib$4.keccak256(lib$5.encode([from,nonce])),12));}exports.getContractAddress=getContractAddress;function getCreate2Address(from,salt,initCodeHash){if(lib$1.hexDataLength(salt)!==32){logger.throwArgumentError(\"salt must be 32 bytes\",\"salt\",salt);}if(lib$1.hexDataLength(initCodeHash)!==32){logger.throwArgumentError(\"initCodeHash must be 32 bytes\",\"initCodeHash\",initCodeHash);}return getAddress(lib$1.hexDataSlice(lib$4.keccak256(lib$1.concat([\"0xff\",getAddress(from),salt,initCodeHash])),12));}exports.getCreate2Address=getCreate2Address;});var index$6=unwrapExports(lib$6);var lib_1$6=lib$6.getAddress;var lib_2$5=lib$6.isAddress;var lib_3$4=lib$6.getIcapAddress;var lib_4$3=lib$6.getContractAddress;var lib_5$3=lib$6.getCreate2Address;var address=createCommonjsModule(function(module,exports){\"use strict\";var __extends=commonjsGlobal&&commonjsGlobal.__extends||function(){var _extendStatics2=function extendStatics(d,b){_extendStatics2=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return _extendStatics2(d,b);};return function(d,b){_extendStatics2(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,\"__esModule\",{value:true});var AddressCoder=/** @class */function(_super){__extends(AddressCoder,_super);function AddressCoder(localName){return _super.call(this,\"address\",\"address\",localName,false)||this;}AddressCoder.prototype.encode=function(writer,value){try{lib$6.getAddress(value);}catch(error){this._throwError(error.message,value);}return writer.writeValue(value);};AddressCoder.prototype.decode=function(reader){return lib$6.getAddress(lib$1.hexZeroPad(reader.readValue().toHexString(),20));};return AddressCoder;}(abstractCoder.Coder);exports.AddressCoder=AddressCoder;});var address$1=unwrapExports(address);var address_2=address.AddressCoder;var anonymous=createCommonjsModule(function(module,exports){\"use strict\";var __extends=commonjsGlobal&&commonjsGlobal.__extends||function(){var _extendStatics3=function extendStatics(d,b){_extendStatics3=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return _extendStatics3(d,b);};return function(d,b){_extendStatics3(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,\"__esModule\",{value:true});// Clones the functionality of an existing Coder, but without a localName\nvar AnonymousCoder=/** @class */function(_super){__extends(AnonymousCoder,_super);function AnonymousCoder(coder){var _this=_super.call(this,coder.name,coder.type,undefined,coder.dynamic)||this;_this.coder=coder;return _this;}AnonymousCoder.prototype.encode=function(writer,value){return this.coder.encode(writer,value);};AnonymousCoder.prototype.decode=function(reader){return this.coder.decode(reader);};return AnonymousCoder;}(abstractCoder.Coder);exports.AnonymousCoder=AnonymousCoder;});var anonymous$1=unwrapExports(anonymous);var anonymous_1=anonymous.AnonymousCoder;var array=createCommonjsModule(function(module,exports){\"use strict\";var __extends=commonjsGlobal&&commonjsGlobal.__extends||function(){var _extendStatics4=function extendStatics(d,b){_extendStatics4=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return _extendStatics4(d,b);};return function(d,b){_extendStatics4(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,\"__esModule\",{value:true});var logger=new lib.Logger(_version$8.version);function pack(writer,coders,values){var arrayValues=null;if(Array.isArray(values)){arrayValues=values;}else if(values&&_typeof(values)===\"object\"){var unique_1={};arrayValues=coders.map(function(coder){var name=coder.localName;if(!name){logger.throwError(\"cannot encode object for signature with missing names\",lib.Logger.errors.INVALID_ARGUMENT,{argument:\"values\",coder:coder,value:values});}if(unique_1[name]){logger.throwError(\"cannot encode object for signature with duplicate names\",lib.Logger.errors.INVALID_ARGUMENT,{argument:\"values\",coder:coder,value:values});}unique_1[name]=true;return values[name];});}else{logger.throwArgumentError(\"invalid tuple value\",\"tuple\",values);}if(coders.length!==arrayValues.length){logger.throwArgumentError(\"types/value length mismatch\",\"tuple\",values);}var staticWriter=new abstractCoder.Writer(writer.wordSize);var dynamicWriter=new abstractCoder.Writer(writer.wordSize);var updateFuncs=[];coders.forEach(function(coder,index){var value=arrayValues[index];if(coder.dynamic){// Get current dynamic offset (for the future pointer)\nvar dynamicOffset_1=dynamicWriter.length;// Encode the dynamic value into the dynamicWriter\ncoder.encode(dynamicWriter,value);// Prepare to populate the correct offset once we are done\nvar updateFunc_1=staticWriter.writeUpdatableValue();updateFuncs.push(function(baseOffset){updateFunc_1(baseOffset+dynamicOffset_1);});}else{coder.encode(staticWriter,value);}});// Backfill all the dynamic offsets, now that we know the static length\nupdateFuncs.forEach(function(func){func(staticWriter.length);});var length=writer.writeBytes(staticWriter.data);length+=writer.writeBytes(dynamicWriter.data);return length;}exports.pack=pack;function unpack(reader,coders){var values=[];// A reader anchored to this base\nvar baseReader=reader.subReader(0);// The amount of dynamic data read; to consume later to synchronize\nvar dynamicLength=0;coders.forEach(function(coder){var value=null;if(coder.dynamic){var offset=reader.readValue();var offsetReader=baseReader.subReader(offset.toNumber());try{value=coder.decode(offsetReader);}catch(error){// Cannot recover from this\nif(error.code===lib.Logger.errors.BUFFER_OVERRUN){throw error;}value=error;value.baseType=coder.name;value.name=coder.localName;value.type=coder.type;}dynamicLength+=offsetReader.consumed;}else{try{value=coder.decode(reader);}catch(error){// Cannot recover from this\nif(error.code===lib.Logger.errors.BUFFER_OVERRUN){throw error;}value=error;value.baseType=coder.name;value.name=coder.localName;value.type=coder.type;}}if(value!=undefined){values.push(value);}});// @TODO: get rid of this an see if it still works?\n// Consume the dynamic components in the main reader\nreader.readBytes(dynamicLength);// We only output named properties for uniquely named coders\nvar uniqueNames=coders.reduce(function(accum,coder){var name=coder.localName;if(name){if(!accum[name]){accum[name]=0;}accum[name]++;}return accum;},{});// Add any named parameters (i.e. tuples)\ncoders.forEach(function(coder,index){var name=coder.localName;if(!name||uniqueNames[name]!==1){return;}if(name===\"length\"){name=\"_length\";}if(values[name]!=null){return;}var value=values[index];if(value instanceof Error){Object.defineProperty(values,name,{get:function get(){throw value;}});}else{values[name]=value;}});var _loop_1=function _loop_1(i){var value=values[i];if(value instanceof Error){Object.defineProperty(values,i,{get:function get(){throw value;}});}};for(var i=0;i<values.length;i++){_loop_1(i);}return Object.freeze(values);}exports.unpack=unpack;var ArrayCoder=/** @class */function(_super){__extends(ArrayCoder,_super);function ArrayCoder(coder,length,localName){var _this=this;var type=coder.type+\"[\"+(length>=0?length:\"\")+\"]\";var dynamic=length===-1||coder.dynamic;_this=_super.call(this,\"array\",type,localName,dynamic)||this;_this.coder=coder;_this.length=length;return _this;}ArrayCoder.prototype.encode=function(writer,value){if(!Array.isArray(value)){this._throwError(\"expected array value\",value);}var count=this.length;if(count===-1){count=value.length;writer.writeValue(value.length);}logger.checkArgumentCount(count,value.length,\"coder array\"+(this.localName?\" \"+this.localName:\"\"));var coders=[];for(var i=0;i<value.length;i++){coders.push(this.coder);}return pack(writer,coders,value);};ArrayCoder.prototype.decode=function(reader){var count=this.length;if(count===-1){count=reader.readValue().toNumber();}var coders=[];for(var i=0;i<count;i++){coders.push(new anonymous.AnonymousCoder(this.coder));}return reader.coerce(this.name,unpack(reader,coders));};return ArrayCoder;}(abstractCoder.Coder);exports.ArrayCoder=ArrayCoder;});var array$1=unwrapExports(array);var array_1=array.pack;var array_2=array.unpack;var array_3=array.ArrayCoder;var boolean_1=createCommonjsModule(function(module,exports){\"use strict\";var __extends=commonjsGlobal&&commonjsGlobal.__extends||function(){var _extendStatics5=function extendStatics(d,b){_extendStatics5=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return _extendStatics5(d,b);};return function(d,b){_extendStatics5(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,\"__esModule\",{value:true});var BooleanCoder=/** @class */function(_super){__extends(BooleanCoder,_super);function BooleanCoder(localName){return _super.call(this,\"bool\",\"bool\",localName,false)||this;}BooleanCoder.prototype.encode=function(writer,value){return writer.writeValue(value?1:0);};BooleanCoder.prototype.decode=function(reader){return reader.coerce(this.type,!reader.readValue().isZero());};return BooleanCoder;}(abstractCoder.Coder);exports.BooleanCoder=BooleanCoder;});var boolean=unwrapExports(boolean_1);var boolean_2=boolean_1.BooleanCoder;var bytes=createCommonjsModule(function(module,exports){\"use strict\";var __extends=commonjsGlobal&&commonjsGlobal.__extends||function(){var _extendStatics6=function extendStatics(d,b){_extendStatics6=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return _extendStatics6(d,b);};return function(d,b){_extendStatics6(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,\"__esModule\",{value:true});var DynamicBytesCoder=/** @class */function(_super){__extends(DynamicBytesCoder,_super);function DynamicBytesCoder(type,localName){return _super.call(this,type,type,localName,true)||this;}DynamicBytesCoder.prototype.encode=function(writer,value){value=lib$1.arrayify(value);var length=writer.writeValue(value.length);length+=writer.writeBytes(value);return length;};DynamicBytesCoder.prototype.decode=function(reader){return reader.readBytes(reader.readValue().toNumber());};return DynamicBytesCoder;}(abstractCoder.Coder);exports.DynamicBytesCoder=DynamicBytesCoder;var BytesCoder=/** @class */function(_super){__extends(BytesCoder,_super);function BytesCoder(localName){return _super.call(this,\"bytes\",localName)||this;}BytesCoder.prototype.decode=function(reader){return reader.coerce(this.name,lib$1.hexlify(_super.prototype.decode.call(this,reader)));};return BytesCoder;}(DynamicBytesCoder);exports.BytesCoder=BytesCoder;});var bytes$1=unwrapExports(bytes);var bytes_2=bytes.DynamicBytesCoder;var bytes_3=bytes.BytesCoder;var fixedBytes=createCommonjsModule(function(module,exports){\"use strict\";var __extends=commonjsGlobal&&commonjsGlobal.__extends||function(){var _extendStatics7=function extendStatics(d,b){_extendStatics7=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return _extendStatics7(d,b);};return function(d,b){_extendStatics7(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,\"__esModule\",{value:true});// @TODO: Merge this with bytes\nvar FixedBytesCoder=/** @class */function(_super){__extends(FixedBytesCoder,_super);function FixedBytesCoder(size,localName){var _this=this;var name=\"bytes\"+String(size);_this=_super.call(this,name,name,localName,false)||this;_this.size=size;return _this;}FixedBytesCoder.prototype.encode=function(writer,value){var data=lib$1.arrayify(value);if(data.length!==this.size){this._throwError(\"incorrect data length\",value);}return writer.writeBytes(data);};FixedBytesCoder.prototype.decode=function(reader){return reader.coerce(this.name,lib$1.hexlify(reader.readBytes(this.size)));};return FixedBytesCoder;}(abstractCoder.Coder);exports.FixedBytesCoder=FixedBytesCoder;});var fixedBytes$1=unwrapExports(fixedBytes);var fixedBytes_1=fixedBytes.FixedBytesCoder;var _null=createCommonjsModule(function(module,exports){\"use strict\";var __extends=commonjsGlobal&&commonjsGlobal.__extends||function(){var _extendStatics8=function extendStatics(d,b){_extendStatics8=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return _extendStatics8(d,b);};return function(d,b){_extendStatics8(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,\"__esModule\",{value:true});var NullCoder=/** @class */function(_super){__extends(NullCoder,_super);function NullCoder(localName){return _super.call(this,\"null\",\"\",localName,false)||this;}NullCoder.prototype.encode=function(writer,value){if(value!=null){this._throwError(\"not null\",value);}return writer.writeBytes([]);};NullCoder.prototype.decode=function(reader){reader.readBytes(0);return reader.coerce(this.name,null);};return NullCoder;}(abstractCoder.Coder);exports.NullCoder=NullCoder;});var _null$1=unwrapExports(_null);var _null_1=_null.NullCoder;var lib$7=createCommonjsModule(function(module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});var AddressZero=\"0x0000000000000000000000000000000000000000\";exports.AddressZero=AddressZero;var HashZero=\"0x0000000000000000000000000000000000000000000000000000000000000000\";exports.HashZero=HashZero;// NFKC (composed)             // (decomposed)\nvar EtherSymbol=\"\\u039E\";// \"\\uD835\\uDF63\";\nexports.EtherSymbol=EtherSymbol;var NegativeOne=lib$2.BigNumber.from(-1);exports.NegativeOne=NegativeOne;var Zero=lib$2.BigNumber.from(0);exports.Zero=Zero;var One=lib$2.BigNumber.from(1);exports.One=One;var Two=lib$2.BigNumber.from(2);exports.Two=Two;var WeiPerEther=lib$2.BigNumber.from(\"1000000000000000000\");exports.WeiPerEther=WeiPerEther;var MaxUint256=lib$2.BigNumber.from(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");exports.MaxUint256=MaxUint256;});var index$7=unwrapExports(lib$7);var lib_1$7=lib$7.AddressZero;var lib_2$6=lib$7.HashZero;var lib_3$5=lib$7.EtherSymbol;var lib_4$4=lib$7.NegativeOne;var lib_5$4=lib$7.Zero;var lib_6$2=lib$7.One;var lib_7$2=lib$7.Two;var lib_8$1=lib$7.WeiPerEther;var lib_9$1=lib$7.MaxUint256;var number=createCommonjsModule(function(module,exports){\"use strict\";var __extends=commonjsGlobal&&commonjsGlobal.__extends||function(){var _extendStatics9=function extendStatics(d,b){_extendStatics9=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return _extendStatics9(d,b);};return function(d,b){_extendStatics9(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,\"__esModule\",{value:true});var NumberCoder=/** @class */function(_super){__extends(NumberCoder,_super);function NumberCoder(size,signed,localName){var _this=this;var name=(signed?\"int\":\"uint\")+size*8;_this=_super.call(this,name,name,localName,false)||this;_this.size=size;_this.signed=signed;return _this;}NumberCoder.prototype.encode=function(writer,value){var v=lib$2.BigNumber.from(value);// Check bounds are safe for encoding\nvar maxUintValue=lib$7.MaxUint256.mask(writer.wordSize*8);if(this.signed){var bounds=maxUintValue.mask(this.size*8-1);if(v.gt(bounds)||v.lt(bounds.add(lib$7.One).mul(lib$7.NegativeOne))){this._throwError(\"value out-of-bounds\",value);}}else if(v.lt(lib$7.Zero)||v.gt(maxUintValue.mask(this.size*8))){this._throwError(\"value out-of-bounds\",value);}v=v.toTwos(this.size*8).mask(this.size*8);if(this.signed){v=v.fromTwos(this.size*8).toTwos(8*writer.wordSize);}return writer.writeValue(v);};NumberCoder.prototype.decode=function(reader){var value=reader.readValue().mask(this.size*8);if(this.signed){value=value.fromTwos(this.size*8);}return reader.coerce(this.name,value);};return NumberCoder;}(abstractCoder.Coder);exports.NumberCoder=NumberCoder;});var number$1=unwrapExports(number);var number_1=number.NumberCoder;var _version$e=createCommonjsModule(function(module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});exports.version=\"strings/5.0.2\";});var _version$f=unwrapExports(_version$e);var _version_1$7=_version$e.version;var utf8=createCommonjsModule(function(module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});var logger=new lib.Logger(_version$e.version);///////////////////////////////\nvar UnicodeNormalizationForm;(function(UnicodeNormalizationForm){UnicodeNormalizationForm[\"current\"]=\"\";UnicodeNormalizationForm[\"NFC\"]=\"NFC\";UnicodeNormalizationForm[\"NFD\"]=\"NFD\";UnicodeNormalizationForm[\"NFKC\"]=\"NFKC\";UnicodeNormalizationForm[\"NFKD\"]=\"NFKD\";})(UnicodeNormalizationForm=exports.UnicodeNormalizationForm||(exports.UnicodeNormalizationForm={}));;var Utf8ErrorReason;(function(Utf8ErrorReason){// A continuation byte was present where there was nothing to continue\n// - offset = the index the codepoint began in\nUtf8ErrorReason[\"UNEXPECTED_CONTINUE\"]=\"unexpected continuation byte\";// An invalid (non-continuation) byte to start a UTF-8 codepoint was found\n// - offset = the index the codepoint began in\nUtf8ErrorReason[\"BAD_PREFIX\"]=\"bad codepoint prefix\";// The string is too short to process the expected codepoint\n// - offset = the index the codepoint began in\nUtf8ErrorReason[\"OVERRUN\"]=\"string overrun\";// A missing continuation byte was expected but not found\n// - offset = the index the continuation byte was expected at\nUtf8ErrorReason[\"MISSING_CONTINUE\"]=\"missing continuation byte\";// The computed code point is outside the range for UTF-8\n// - offset       = start of this codepoint\n// - badCodepoint = the computed codepoint; outside the UTF-8 range\nUtf8ErrorReason[\"OUT_OF_RANGE\"]=\"out of UTF-8 range\";// UTF-8 strings may not contain UTF-16 surrogate pairs\n// - offset       = start of this codepoint\n// - badCodepoint = the computed codepoint; inside the UTF-16 surrogate range\nUtf8ErrorReason[\"UTF16_SURROGATE\"]=\"UTF-16 surrogate\";// The string is an overlong reperesentation\n// - offset       = start of this codepoint\n// - badCodepoint = the computed codepoint; already bounds checked\nUtf8ErrorReason[\"OVERLONG\"]=\"overlong representation\";})(Utf8ErrorReason=exports.Utf8ErrorReason||(exports.Utf8ErrorReason={}));;function errorFunc(reason,offset,bytes,output,badCodepoint){return logger.throwArgumentError(\"invalid codepoint at offset \"+offset+\"; \"+reason,\"bytes\",bytes);}function ignoreFunc(reason,offset,bytes,output,badCodepoint){// If there is an invalid prefix (including stray continuation), skip any additional continuation bytes\nif(reason===Utf8ErrorReason.BAD_PREFIX||reason===Utf8ErrorReason.UNEXPECTED_CONTINUE){var i=0;for(var o=offset+1;o<bytes.length;o++){if(bytes[o]>>6!==0x02){break;}i++;}return i;}// This byte runs us past the end of the string, so just jump to the end\n// (but the first byte was read already read and therefore skipped)\nif(reason===Utf8ErrorReason.OVERRUN){return bytes.length-offset-1;}// Nothing to skip\nreturn 0;}function replaceFunc(reason,offset,bytes,output,badCodepoint){// Overlong representations are otherwise \"valid\" code points; just non-deistingtished\nif(reason===Utf8ErrorReason.OVERLONG){output.push(badCodepoint);return 0;}// Put the replacement character into the output\noutput.push(0xfffd);// Otherwise, process as if ignoring errors\nreturn ignoreFunc(reason,offset,bytes,output,badCodepoint);}// Common error handing strategies\nexports.Utf8ErrorFuncs=Object.freeze({error:errorFunc,ignore:ignoreFunc,replace:replaceFunc});// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\nfunction getUtf8CodePoints(bytes,onError){if(onError==null){onError=exports.Utf8ErrorFuncs.error;}bytes=lib$1.arrayify(bytes);var result=[];var i=0;// Invalid bytes are ignored\nwhile(i<bytes.length){var c=bytes[i++];// 0xxx xxxx\nif(c>>7===0){result.push(c);continue;}// Multibyte; how many bytes left for this character?\nvar extraLength=null;var overlongMask=null;// 110x xxxx 10xx xxxx\nif((c&0xe0)===0xc0){extraLength=1;overlongMask=0x7f;// 1110 xxxx 10xx xxxx 10xx xxxx\n}else if((c&0xf0)===0xe0){extraLength=2;overlongMask=0x7ff;// 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n}else if((c&0xf8)===0xf0){extraLength=3;overlongMask=0xffff;}else{if((c&0xc0)===0x80){i+=onError(Utf8ErrorReason.UNEXPECTED_CONTINUE,i-1,bytes,result);}else{i+=onError(Utf8ErrorReason.BAD_PREFIX,i-1,bytes,result);}continue;}// Do we have enough bytes in our data?\nif(i-1+extraLength>=bytes.length){i+=onError(Utf8ErrorReason.OVERRUN,i-1,bytes,result);continue;}// Remove the length prefix from the char\nvar res=c&(1<<8-extraLength-1)-1;for(var j=0;j<extraLength;j++){var nextChar=bytes[i];// Invalid continuation byte\nif((nextChar&0xc0)!=0x80){i+=onError(Utf8ErrorReason.MISSING_CONTINUE,i,bytes,result);res=null;break;};res=res<<6|nextChar&0x3f;i++;}// See above loop for invalid contimuation byte\nif(res===null){continue;}// Maximum code point\nif(res>0x10ffff){i+=onError(Utf8ErrorReason.OUT_OF_RANGE,i-1-extraLength,bytes,result,res);continue;}// Reserved for UTF-16 surrogate halves\nif(res>=0xd800&&res<=0xdfff){i+=onError(Utf8ErrorReason.UTF16_SURROGATE,i-1-extraLength,bytes,result,res);continue;}// Check for overlong sequences (more bytes than needed)\nif(res<=overlongMask){i+=onError(Utf8ErrorReason.OVERLONG,i-1-extraLength,bytes,result,res);continue;}result.push(res);}return result;}// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\nfunction toUtf8Bytes(str,form){if(form===void 0){form=UnicodeNormalizationForm.current;}if(form!=UnicodeNormalizationForm.current){logger.checkNormalize();str=str.normalize(form);}var result=[];for(var i=0;i<str.length;i++){var c=str.charCodeAt(i);if(c<0x80){result.push(c);}else if(c<0x800){result.push(c>>6|0xc0);result.push(c&0x3f|0x80);}else if((c&0xfc00)==0xd800){i++;var c2=str.charCodeAt(i);if(i>=str.length||(c2&0xfc00)!==0xdc00){throw new Error(\"invalid utf-8 string\");}// Surrogate Pair\nvar pair=0x10000+((c&0x03ff)<<10)+(c2&0x03ff);result.push(pair>>18|0xf0);result.push(pair>>12&0x3f|0x80);result.push(pair>>6&0x3f|0x80);result.push(pair&0x3f|0x80);}else{result.push(c>>12|0xe0);result.push(c>>6&0x3f|0x80);result.push(c&0x3f|0x80);}}return lib$1.arrayify(result);}exports.toUtf8Bytes=toUtf8Bytes;;function escapeChar(value){var hex=\"0000\"+value.toString(16);return\"\\\\u\"+hex.substring(hex.length-4);}function _toEscapedUtf8String(bytes,onError){return'\"'+getUtf8CodePoints(bytes,onError).map(function(codePoint){if(codePoint<256){switch(codePoint){case 8:return\"\\\\b\";case 9:return\"\\\\t\";case 10:return\"\\\\n\";case 13:return\"\\\\r\";case 34:return\"\\\\\\\"\";case 92:return\"\\\\\\\\\";}if(codePoint>=32&&codePoint<127){return String.fromCharCode(codePoint);}}if(codePoint<=0xffff){return escapeChar(codePoint);}codePoint-=0x10000;return escapeChar((codePoint>>10&0x3ff)+0xd800)+escapeChar((codePoint&0x3ff)+0xdc00);}).join(\"\")+'\"';}exports._toEscapedUtf8String=_toEscapedUtf8String;function _toUtf8String(codePoints){return codePoints.map(function(codePoint){if(codePoint<=0xffff){return String.fromCharCode(codePoint);}codePoint-=0x10000;return String.fromCharCode((codePoint>>10&0x3ff)+0xd800,(codePoint&0x3ff)+0xdc00);}).join(\"\");}exports._toUtf8String=_toUtf8String;function toUtf8String(bytes,onError){return _toUtf8String(getUtf8CodePoints(bytes,onError));}exports.toUtf8String=toUtf8String;function toUtf8CodePoints(str,form){if(form===void 0){form=UnicodeNormalizationForm.current;}return getUtf8CodePoints(toUtf8Bytes(str,form));}exports.toUtf8CodePoints=toUtf8CodePoints;});var utf8$1=unwrapExports(utf8);var utf8_1=utf8.UnicodeNormalizationForm;var utf8_2=utf8.Utf8ErrorReason;var utf8_3=utf8.Utf8ErrorFuncs;var utf8_4=utf8.toUtf8Bytes;var utf8_5=utf8._toEscapedUtf8String;var utf8_6=utf8._toUtf8String;var utf8_7=utf8.toUtf8String;var utf8_8=utf8.toUtf8CodePoints;var bytes32=createCommonjsModule(function(module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});function formatBytes32String(text){// Get the bytes\nvar bytes=utf8.toUtf8Bytes(text);// Check we have room for null-termination\nif(bytes.length>31){throw new Error(\"bytes32 string must be less than 32 bytes\");}// Zero-pad (implicitly null-terminates)\nreturn lib$1.hexlify(lib$1.concat([bytes,lib$7.HashZero]).slice(0,32));}exports.formatBytes32String=formatBytes32String;function parseBytes32String(bytes){var data=lib$1.arrayify(bytes);// Must be 32 bytes with a null-termination\nif(data.length!==32){throw new Error(\"invalid bytes32 - not 32 bytes long\");}if(data[31]!==0){throw new Error(\"invalid bytes32 string - no null terminator\");}// Find the null termination\nvar length=31;while(data[length-1]===0){length--;}// Determine the string value\nreturn utf8.toUtf8String(data.slice(0,length));}exports.parseBytes32String=parseBytes32String;});var bytes32$1=unwrapExports(bytes32);var bytes32_1=bytes32.formatBytes32String;var bytes32_2=bytes32.parseBytes32String;var idna=createCommonjsModule(function(module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});function bytes2(data){if(data.length%4!==0){throw new Error(\"bad data\");}var result=[];for(var i=0;i<data.length;i+=4){result.push(parseInt(data.substring(i,i+4),16));}return result;}function createTable(data,func){if(!func){func=function func(value){return[parseInt(value,16)];};}var lo=0;var result={};data.split(\",\").forEach(function(pair){var comps=pair.split(\":\");lo+=parseInt(comps[0],16);result[lo]=func(comps[1]);});return result;}function createRangeTable(data){var hi=0;return data.split(\",\").map(function(v){var comps=v.split(\"-\");if(comps.length===1){comps[1]=\"0\";}else if(comps[1]===\"\"){comps[1]=\"1\";}var lo=hi+parseInt(comps[0],16);hi=parseInt(comps[1],16);return{l:lo,h:hi};});}function matchMap(value,ranges){var lo=0;for(var i=0;i<ranges.length;i++){var range=ranges[i];lo+=range.l;if(value>=lo&&value<=lo+range.h&&(value-lo)%(range.d||1)===0){if(range.e&&range.e.indexOf(value-lo)!==-1){continue;}return range;}}return null;}var Table_A_1_ranges=createRangeTable(\"221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d\");// @TODO: Make this relative...\nvar Table_B_1_flags=\"ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff\".split(\",\").map(function(v){return parseInt(v,16);});var Table_B_2_ranges=[{h:25,s:32,l:65},{h:30,s:32,e:[23],l:127},{h:54,s:1,e:[48],l:64,d:2},{h:14,s:1,l:57,d:2},{h:44,s:1,l:17,d:2},{h:10,s:1,e:[2,6,8],l:61,d:2},{h:16,s:1,l:68,d:2},{h:84,s:1,e:[18,24,66],l:19,d:2},{h:26,s:32,e:[17],l:435},{h:22,s:1,l:71,d:2},{h:15,s:80,l:40},{h:31,s:32,l:16},{h:32,s:1,l:80,d:2},{h:52,s:1,l:42,d:2},{h:12,s:1,l:55,d:2},{h:40,s:1,e:[38],l:15,d:2},{h:14,s:1,l:48,d:2},{h:37,s:48,l:49},{h:148,s:1,l:6351,d:2},{h:88,s:1,l:160,d:2},{h:15,s:16,l:704},{h:25,s:26,l:854},{h:25,s:32,l:55915},{h:37,s:40,l:1247},{h:25,s:-119711,l:53248},{h:25,s:-119763,l:52},{h:25,s:-119815,l:52},{h:25,s:-119867,e:[1,4,5,7,8,11,12,17],l:52},{h:25,s:-119919,l:52},{h:24,s:-119971,e:[2,7,8,17],l:52},{h:24,s:-120023,e:[2,7,13,15,16,17],l:52},{h:25,s:-120075,l:52},{h:25,s:-120127,l:52},{h:25,s:-120179,l:52},{h:25,s:-120231,l:52},{h:25,s:-120283,l:52},{h:25,s:-120335,l:52},{h:24,s:-119543,e:[17],l:56},{h:24,s:-119601,e:[17],l:58},{h:24,s:-119659,e:[17],l:58},{h:24,s:-119717,e:[17],l:58},{h:24,s:-119775,e:[17],l:58}];var Table_B_2_lut_abs=createTable(\"b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3\");var Table_B_2_lut_rel=createTable(\"179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7\");var Table_B_2_complex=createTable(\"df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D\",bytes2);var Table_C_ranges=createRangeTable(\"80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001\");function flatten(values){return values.reduce(function(accum,value){value.forEach(function(value){accum.push(value);});return accum;},[]);}function _nameprepTableA1(codepoint){return!!matchMap(codepoint,Table_A_1_ranges);}exports._nameprepTableA1=_nameprepTableA1;function _nameprepTableB2(codepoint){var range=matchMap(codepoint,Table_B_2_ranges);if(range){return[codepoint+range.s];}var codes=Table_B_2_lut_abs[codepoint];if(codes){return codes;}var shift=Table_B_2_lut_rel[codepoint];if(shift){return[codepoint+shift[0]];}var complex=Table_B_2_complex[codepoint];if(complex){return complex;}return null;}exports._nameprepTableB2=_nameprepTableB2;function _nameprepTableC(codepoint){return!!matchMap(codepoint,Table_C_ranges);}exports._nameprepTableC=_nameprepTableC;function nameprep(value){// This allows platforms with incomplete normalize to bypass\n// it for very basic names which the built-in toLowerCase\n// will certainly handle correctly\nif(value.match(/^[a-z0-9-]*$/i)&&value.length<=59){return value.toLowerCase();}// Get the code points (keeping the current normalization)\nvar codes=utf8.toUtf8CodePoints(value);codes=flatten(codes.map(function(code){// Substitute Table B.1 (Maps to Nothing)\nif(Table_B_1_flags.indexOf(code)>=0){return[];}if(code>=0xfe00&&code<=0xfe0f){return[];}// Substitute Table B.2 (Case Folding)\nvar codesTableB2=_nameprepTableB2(code);if(codesTableB2){return codesTableB2;}// No Substitution\nreturn[code];}));// Normalize using form KC\ncodes=utf8.toUtf8CodePoints(utf8._toUtf8String(codes),utf8.UnicodeNormalizationForm.NFKC);// Prohibit Tables C.1.2, C.2.2, C.3, C.4, C.5, C.6, C.7, C.8, C.9\ncodes.forEach(function(code){if(_nameprepTableC(code)){throw new Error(\"STRINGPREP_CONTAINS_PROHIBITED\");}});// Prohibit Unassigned Code Points (Table A.1)\ncodes.forEach(function(code){if(_nameprepTableA1(code)){throw new Error(\"STRINGPREP_CONTAINS_UNASSIGNED\");}});// IDNA extras\nvar name=utf8._toUtf8String(codes);// IDNA: 4.2.3.1\nif(name.substring(0,1)===\"-\"||name.substring(2,4)===\"--\"||name.substring(name.length-1)===\"-\"){throw new Error(\"invalid hyphen\");}// IDNA: 4.2.4\nif(name.length>63){throw new Error(\"too long\");}return name;}exports.nameprep=nameprep;});var idna$1=unwrapExports(idna);var idna_1=idna._nameprepTableA1;var idna_2=idna._nameprepTableB2;var idna_3=idna._nameprepTableC;var idna_4=idna.nameprep;var lib$8=createCommonjsModule(function(module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});exports.formatBytes32String=bytes32.formatBytes32String;exports.parseBytes32String=bytes32.parseBytes32String;exports.nameprep=idna.nameprep;exports._toEscapedUtf8String=utf8._toEscapedUtf8String;exports.toUtf8Bytes=utf8.toUtf8Bytes;exports.toUtf8CodePoints=utf8.toUtf8CodePoints;exports.toUtf8String=utf8.toUtf8String;exports.UnicodeNormalizationForm=utf8.UnicodeNormalizationForm;exports.Utf8ErrorFuncs=utf8.Utf8ErrorFuncs;exports.Utf8ErrorReason=utf8.Utf8ErrorReason;});var index$8=unwrapExports(lib$8);var lib_1$8=lib$8.formatBytes32String;var lib_2$7=lib$8.parseBytes32String;var lib_3$6=lib$8.nameprep;var lib_4$5=lib$8._toEscapedUtf8String;var lib_5$5=lib$8.toUtf8Bytes;var lib_6$3=lib$8.toUtf8CodePoints;var lib_7$3=lib$8.toUtf8String;var lib_8$2=lib$8.UnicodeNormalizationForm;var lib_9$2=lib$8.Utf8ErrorFuncs;var lib_10$1=lib$8.Utf8ErrorReason;var string=createCommonjsModule(function(module,exports){\"use strict\";var __extends=commonjsGlobal&&commonjsGlobal.__extends||function(){var _extendStatics10=function extendStatics(d,b){_extendStatics10=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return _extendStatics10(d,b);};return function(d,b){_extendStatics10(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,\"__esModule\",{value:true});var StringCoder=/** @class */function(_super){__extends(StringCoder,_super);function StringCoder(localName){return _super.call(this,\"string\",localName)||this;}StringCoder.prototype.encode=function(writer,value){return _super.prototype.encode.call(this,writer,lib$8.toUtf8Bytes(value));};StringCoder.prototype.decode=function(reader){return lib$8.toUtf8String(_super.prototype.decode.call(this,reader));};return StringCoder;}(bytes.DynamicBytesCoder);exports.StringCoder=StringCoder;});var string$1=unwrapExports(string);var string_1=string.StringCoder;var tuple=createCommonjsModule(function(module,exports){\"use strict\";var __extends=commonjsGlobal&&commonjsGlobal.__extends||function(){var _extendStatics11=function extendStatics(d,b){_extendStatics11=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return _extendStatics11(d,b);};return function(d,b){_extendStatics11(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,\"__esModule\",{value:true});var TupleCoder=/** @class */function(_super){__extends(TupleCoder,_super);function TupleCoder(coders,localName){var _this=this;var dynamic=false;var types=[];coders.forEach(function(coder){if(coder.dynamic){dynamic=true;}types.push(coder.type);});var type=\"tuple(\"+types.join(\",\")+\")\";_this=_super.call(this,\"tuple\",type,localName,dynamic)||this;_this.coders=coders;return _this;}TupleCoder.prototype.encode=function(writer,value){return array.pack(writer,this.coders,value);};TupleCoder.prototype.decode=function(reader){return reader.coerce(this.name,array.unpack(reader,this.coders));};return TupleCoder;}(abstractCoder.Coder);exports.TupleCoder=TupleCoder;});var tuple$1=unwrapExports(tuple);var tuple_1=tuple.TupleCoder;var abiCoder=createCommonjsModule(function(module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});// See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\nvar logger=new lib.Logger(_version$8.version);var paramTypeBytes=new RegExp(/^bytes([0-9]*)$/);var paramTypeNumber=new RegExp(/^(u?int)([0-9]*)$/);var AbiCoder=/** @class */function(){function AbiCoder(coerceFunc){var _newTarget=this.constructor;logger.checkNew(_newTarget,AbiCoder);lib$3.defineReadOnly(this,\"coerceFunc\",coerceFunc||null);}AbiCoder.prototype._getCoder=function(param){var _this=this;switch(param.baseType){case\"address\":return new address.AddressCoder(param.name);case\"bool\":return new boolean_1.BooleanCoder(param.name);case\"string\":return new string.StringCoder(param.name);case\"bytes\":return new bytes.BytesCoder(param.name);case\"array\":return new array.ArrayCoder(this._getCoder(param.arrayChildren),param.arrayLength,param.name);case\"tuple\":return new tuple.TupleCoder((param.components||[]).map(function(component){return _this._getCoder(component);}),param.name);case\"\":return new _null.NullCoder(param.name);}// u?int[0-9]*\nvar match=param.type.match(paramTypeNumber);if(match){var size=parseInt(match[2]||\"256\");if(size===0||size>256||size%8!==0){logger.throwArgumentError(\"invalid \"+match[1]+\" bit length\",\"param\",param);}return new number.NumberCoder(size/8,match[1]===\"int\",param.name);}// bytes[0-9]+\nmatch=param.type.match(paramTypeBytes);if(match){var size=parseInt(match[1]);if(size===0||size>32){logger.throwArgumentError(\"invalid bytes length\",\"param\",param);}return new fixedBytes.FixedBytesCoder(size,param.name);}return logger.throwArgumentError(\"invalid type\",\"type\",param.type);};AbiCoder.prototype._getWordSize=function(){return 32;};AbiCoder.prototype._getReader=function(data){return new abstractCoder.Reader(data,this._getWordSize(),this.coerceFunc);};AbiCoder.prototype._getWriter=function(){return new abstractCoder.Writer(this._getWordSize());};AbiCoder.prototype.encode=function(types,values){var _this=this;if(types.length!==values.length){logger.throwError(\"types/values length mismatch\",lib.Logger.errors.INVALID_ARGUMENT,{count:{types:types.length,values:values.length},value:{types:types,values:values}});}var coders=types.map(function(type){return _this._getCoder(fragments.ParamType.from(type));});var coder=new tuple.TupleCoder(coders,\"_\");var writer=this._getWriter();coder.encode(writer,values);return writer.data;};AbiCoder.prototype.decode=function(types,data){var _this=this;var coders=types.map(function(type){return _this._getCoder(fragments.ParamType.from(type));});var coder=new tuple.TupleCoder(coders,\"_\");return coder.decode(this._getReader(lib$1.arrayify(data)));};return AbiCoder;}();exports.AbiCoder=AbiCoder;exports.defaultAbiCoder=new AbiCoder();});var abiCoder$1=unwrapExports(abiCoder);var abiCoder_1=abiCoder.AbiCoder;var abiCoder_2=abiCoder.defaultAbiCoder;var _version$g=createCommonjsModule(function(module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});exports.version=\"hash/5.0.2\";});var _version$h=unwrapExports(_version$g);var _version_1$8=_version$g.version;var lib$9=createCommonjsModule(function(module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});var logger=new lib.Logger(_version$g.version);///////////////////////////////\nvar Zeros=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]);var Partition=new RegExp(\"^((.*)\\\\.)?([^.]+)$\");function isValidName(name){try{var comps=name.split(\".\");for(var i=0;i<comps.length;i++){if(lib$8.nameprep(comps[i]).length===0){throw new Error(\"empty\");}}return true;}catch(error){}return false;}exports.isValidName=isValidName;function namehash(name){/* istanbul ignore if */if(typeof name!==\"string\"){logger.throwArgumentError(\"invalid address - \"+String(name),\"name\",name);}var result=Zeros;while(name.length){var partition=name.match(Partition);var label=lib$8.toUtf8Bytes(lib$8.nameprep(partition[3]));result=lib$4.keccak256(lib$1.concat([result,lib$4.keccak256(label)]));name=partition[2]||\"\";}return lib$1.hexlify(result);}exports.namehash=namehash;function id(text){return lib$4.keccak256(lib$8.toUtf8Bytes(text));}exports.id=id;exports.messagePrefix=\"\\x19Ethereum Signed Message:\\n\";function hashMessage(message){if(typeof message===\"string\"){message=lib$8.toUtf8Bytes(message);}return lib$4.keccak256(lib$1.concat([lib$8.toUtf8Bytes(exports.messagePrefix),lib$8.toUtf8Bytes(String(message.length)),message]));}exports.hashMessage=hashMessage;});var index$9=unwrapExports(lib$9);var lib_1$9=lib$9.isValidName;var lib_2$8=lib$9.namehash;var lib_3$7=lib$9.id;var lib_4$6=lib$9.messagePrefix;var lib_5$6=lib$9.hashMessage;var _interface=createCommonjsModule(function(module,exports){\"use strict\";var __extends=commonjsGlobal&&commonjsGlobal.__extends||function(){var _extendStatics12=function extendStatics(d,b){_extendStatics12=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return _extendStatics12(d,b);};return function(d,b){_extendStatics12(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,\"__esModule\",{value:true});exports.checkResultErrors=abstractCoder.checkResultErrors;var logger=new lib.Logger(_version$8.version);var LogDescription=/** @class */function(_super){__extends(LogDescription,_super);function LogDescription(){return _super!==null&&_super.apply(this,arguments)||this;}return LogDescription;}(lib$3.Description);exports.LogDescription=LogDescription;var TransactionDescription=/** @class */function(_super){__extends(TransactionDescription,_super);function TransactionDescription(){return _super!==null&&_super.apply(this,arguments)||this;}return TransactionDescription;}(lib$3.Description);exports.TransactionDescription=TransactionDescription;var Indexed=/** @class */function(_super){__extends(Indexed,_super);function Indexed(){return _super!==null&&_super.apply(this,arguments)||this;}Indexed.isIndexed=function(value){return!!(value&&value._isIndexed);};return Indexed;}(lib$3.Description);exports.Indexed=Indexed;function wrapAccessError(property,error){var wrap=new Error(\"deferred error during ABI decoding triggered accessing \"+property);wrap.error=error;return wrap;}/*\n\tfunction checkNames(fragment: Fragment, type: \"input\" | \"output\", params: Array<ParamType>): void {\n\t    params.reduce((accum, param) => {\n\t        if (param.name) {\n\t            if (accum[param.name]) {\n\t                logger.throwArgumentError(`duplicate ${ type } parameter ${ JSON.stringify(param.name) } in ${ fragment.format(\"full\") }`, \"fragment\", fragment);\n\t            }\n\t            accum[param.name] = true;\n\t        }\n\t        return accum;\n\t    }, <{ [ name: string ]: boolean }>{ });\n\t}\n\t*/var Interface=/** @class */function(){function Interface(fragments$1){var _newTarget=this.constructor;var _this=this;logger.checkNew(_newTarget,Interface);var abi=[];if(typeof fragments$1===\"string\"){abi=JSON.parse(fragments$1);}else{abi=fragments$1;}lib$3.defineReadOnly(this,\"fragments\",abi.map(function(fragment){return fragments.Fragment.from(fragment);}).filter(function(fragment){return fragment!=null;}));lib$3.defineReadOnly(this,\"_abiCoder\",lib$3.getStatic(_newTarget,\"getAbiCoder\")());lib$3.defineReadOnly(this,\"functions\",{});lib$3.defineReadOnly(this,\"errors\",{});lib$3.defineReadOnly(this,\"events\",{});lib$3.defineReadOnly(this,\"structs\",{});// Add all fragments by their signature\nthis.fragments.forEach(function(fragment){var bucket=null;switch(fragment.type){case\"constructor\":if(_this.deploy){logger.warn(\"duplicate definition - constructor\");return;}//checkNames(fragment, \"input\", fragment.inputs);\nlib$3.defineReadOnly(_this,\"deploy\",fragment);return;case\"function\"://checkNames(fragment, \"input\", fragment.inputs);\n//checkNames(fragment, \"output\", (<FunctionFragment>fragment).outputs);\nbucket=_this.functions;break;case\"event\"://checkNames(fragment, \"input\", fragment.inputs);\nbucket=_this.events;break;default:return;}var signature=fragment.format();if(bucket[signature]){logger.warn(\"duplicate definition - \"+signature);return;}bucket[signature]=fragment;});// If we do not have a constructor add a default\nif(!this.deploy){lib$3.defineReadOnly(this,\"deploy\",fragments.ConstructorFragment.from({payable:false,type:\"constructor\"}));}lib$3.defineReadOnly(this,\"_isInterface\",true);}Interface.prototype.format=function(format){if(!format){format=fragments.FormatTypes.full;}if(format===fragments.FormatTypes.sighash){logger.throwArgumentError(\"interface does not support formatting sighash\",\"format\",format);}var abi=this.fragments.map(function(fragment){return fragment.format(format);});// We need to re-bundle the JSON fragments a bit\nif(format===fragments.FormatTypes.json){return JSON.stringify(abi.map(function(j){return JSON.parse(j);}));}return abi;};// Sub-classes can override these to handle other blockchains\nInterface.getAbiCoder=function(){return abiCoder.defaultAbiCoder;};Interface.getAddress=function(address){return lib$6.getAddress(address);};Interface.getSighash=function(functionFragment){return lib$1.hexDataSlice(lib$9.id(functionFragment.format()),0,4);};Interface.getEventTopic=function(eventFragment){return lib$9.id(eventFragment.format());};// Find a function definition by any means necessary (unless it is ambiguous)\nInterface.prototype.getFunction=function(nameOrSignatureOrSighash){if(lib$1.isHexString(nameOrSignatureOrSighash)){for(var name_1 in this.functions){if(nameOrSignatureOrSighash===this.getSighash(name_1)){return this.functions[name_1];}}logger.throwArgumentError(\"no matching function\",\"sighash\",nameOrSignatureOrSighash);}// It is a bare name, look up the function (will return null if ambiguous)\nif(nameOrSignatureOrSighash.indexOf(\"(\")===-1){var name_2=nameOrSignatureOrSighash.trim();var matching=Object.keys(this.functions).filter(function(f){return f.split(\"(\"/* fix:) */)[0]===name_2;});if(matching.length===0){logger.throwArgumentError(\"no matching function\",\"name\",name_2);}else if(matching.length>1){logger.throwArgumentError(\"multiple matching functions\",\"name\",name_2);}return this.functions[matching[0]];}// Normlize the signature and lookup the function\nvar result=this.functions[fragments.FunctionFragment.fromString(nameOrSignatureOrSighash).format()];if(!result){logger.throwArgumentError(\"no matching function\",\"signature\",nameOrSignatureOrSighash);}return result;};// Find an event definition by any means necessary (unless it is ambiguous)\nInterface.prototype.getEvent=function(nameOrSignatureOrTopic){if(lib$1.isHexString(nameOrSignatureOrTopic)){var topichash=nameOrSignatureOrTopic.toLowerCase();for(var name_3 in this.events){if(topichash===this.getEventTopic(name_3)){return this.events[name_3];}}logger.throwArgumentError(\"no matching event\",\"topichash\",topichash);}// It is a bare name, look up the function (will return null if ambiguous)\nif(nameOrSignatureOrTopic.indexOf(\"(\")===-1){var name_4=nameOrSignatureOrTopic.trim();var matching=Object.keys(this.events).filter(function(f){return f.split(\"(\"/* fix:) */)[0]===name_4;});if(matching.length===0){logger.throwArgumentError(\"no matching event\",\"name\",name_4);}else if(matching.length>1){logger.throwArgumentError(\"multiple matching events\",\"name\",name_4);}return this.events[matching[0]];}// Normlize the signature and lookup the function\nvar result=this.events[fragments.EventFragment.fromString(nameOrSignatureOrTopic).format()];if(!result){logger.throwArgumentError(\"no matching event\",\"signature\",nameOrSignatureOrTopic);}return result;};// Get the sighash (the bytes4 selector) used by Solidity to identify a function\nInterface.prototype.getSighash=function(functionFragment){if(typeof functionFragment===\"string\"){functionFragment=this.getFunction(functionFragment);}return lib$3.getStatic(this.constructor,\"getSighash\")(functionFragment);};// Get the topic (the bytes32 hash) used by Solidity to identify an event\nInterface.prototype.getEventTopic=function(eventFragment){if(typeof eventFragment===\"string\"){eventFragment=this.getEvent(eventFragment);}return lib$3.getStatic(this.constructor,\"getEventTopic\")(eventFragment);};Interface.prototype._decodeParams=function(params,data){return this._abiCoder.decode(params,data);};Interface.prototype._encodeParams=function(params,values){return this._abiCoder.encode(params,values);};Interface.prototype.encodeDeploy=function(values){return this._encodeParams(this.deploy.inputs,values||[]);};// Decode the data for a function call (e.g. tx.data)\nInterface.prototype.decodeFunctionData=function(functionFragment,data){if(typeof functionFragment===\"string\"){functionFragment=this.getFunction(functionFragment);}var bytes=lib$1.arrayify(data);if(lib$1.hexlify(bytes.slice(0,4))!==this.getSighash(functionFragment)){logger.throwArgumentError(\"data signature does not match function \"+functionFragment.name+\".\",\"data\",lib$1.hexlify(bytes));}return this._decodeParams(functionFragment.inputs,bytes.slice(4));};// Encode the data for a function call (e.g. tx.data)\nInterface.prototype.encodeFunctionData=function(functionFragment,values){if(typeof functionFragment===\"string\"){functionFragment=this.getFunction(functionFragment);}return lib$1.hexlify(lib$1.concat([this.getSighash(functionFragment),this._encodeParams(functionFragment.inputs,values||[])]));};// Decode the result from a function call (e.g. from eth_call)\nInterface.prototype.decodeFunctionResult=function(functionFragment,data){if(typeof functionFragment===\"string\"){functionFragment=this.getFunction(functionFragment);}var bytes=lib$1.arrayify(data);var reason=null;var errorSignature=null;switch(bytes.length%this._abiCoder._getWordSize()){case 0:try{return this._abiCoder.decode(functionFragment.outputs,bytes);}catch(error){}break;case 4:if(lib$1.hexlify(bytes.slice(0,4))===\"0x08c379a0\"){errorSignature=\"Error(string)\";reason=this._abiCoder.decode([\"string\"],bytes.slice(4))[0];}break;}return logger.throwError(\"call revert exception\",lib.Logger.errors.CALL_EXCEPTION,{method:functionFragment.format(),errorSignature:errorSignature,errorArgs:[reason],reason:reason});};// Encode the result for a function call (e.g. for eth_call)\nInterface.prototype.encodeFunctionResult=function(functionFragment,values){if(typeof functionFragment===\"string\"){functionFragment=this.getFunction(functionFragment);}return lib$1.hexlify(this._abiCoder.encode(functionFragment.outputs,values||[]));};// Create the filter for the event with search criteria (e.g. for eth_filterLog)\nInterface.prototype.encodeFilterTopics=function(eventFragment,values){var _this=this;if(typeof eventFragment===\"string\"){eventFragment=this.getEvent(eventFragment);}if(values.length>eventFragment.inputs.length){logger.throwError(\"too many arguments for \"+eventFragment.format(),lib.Logger.errors.UNEXPECTED_ARGUMENT,{argument:\"values\",value:values});}var topics=[];if(!eventFragment.anonymous){topics.push(this.getEventTopic(eventFragment));}var encodeTopic=function encodeTopic(param,value){if(param.type===\"string\"){return lib$9.id(value);}else if(param.type===\"bytes\"){return lib$4.keccak256(lib$1.hexlify(value));}// Check addresses are valid\nif(param.type===\"address\"){_this._abiCoder.encode([\"address\"],[value]);}return lib$1.hexZeroPad(lib$1.hexlify(value),32);};values.forEach(function(value,index){var param=eventFragment.inputs[index];if(!param.indexed){if(value!=null){logger.throwArgumentError(\"cannot filter non-indexed parameters; must be null\",\"contract.\"+param.name,value);}return;}if(value==null){topics.push(null);}else if(param.baseType===\"array\"||param.baseType===\"tuple\"){logger.throwArgumentError(\"filtering with tuples or arrays not supported\",\"contract.\"+param.name,value);}else if(Array.isArray(value)){topics.push(value.map(function(value){return encodeTopic(param,value);}));}else{topics.push(encodeTopic(param,value));}});// Trim off trailing nulls\nwhile(topics.length&&topics[topics.length-1]===null){topics.pop();}return topics;};Interface.prototype.encodeEventLog=function(eventFragment,values){var _this=this;if(typeof eventFragment===\"string\"){eventFragment=this.getEvent(eventFragment);}var topics=[];var dataTypes=[];var dataValues=[];if(!eventFragment.anonymous){topics.push(this.getEventTopic(eventFragment));}if(values.length!==eventFragment.inputs.length){logger.throwArgumentError(\"event arguments/values mismatch\",\"values\",values);}eventFragment.inputs.forEach(function(param,index){var value=values[index];if(param.indexed){if(param.type===\"string\"){topics.push(lib$9.id(value));}else if(param.type===\"bytes\"){topics.push(lib$4.keccak256(value));}else if(param.baseType===\"tuple\"||param.baseType===\"array\"){// @TOOD\nthrow new Error(\"not implemented\");}else{topics.push(_this._abiCoder.encode([param.type],[value]));}}else{dataTypes.push(param);dataValues.push(value);}});return{data:this._abiCoder.encode(dataTypes,dataValues),topics:topics};};// Decode a filter for the event and the search criteria\nInterface.prototype.decodeEventLog=function(eventFragment,data,topics){if(typeof eventFragment===\"string\"){eventFragment=this.getEvent(eventFragment);}if(topics!=null&&!eventFragment.anonymous){var topicHash=this.getEventTopic(eventFragment);if(!lib$1.isHexString(topics[0],32)||topics[0].toLowerCase()!==topicHash){logger.throwError(\"fragment/topic mismatch\",lib.Logger.errors.INVALID_ARGUMENT,{argument:\"topics[0]\",expected:topicHash,value:topics[0]});}topics=topics.slice(1);}var indexed=[];var nonIndexed=[];var dynamic=[];eventFragment.inputs.forEach(function(param,index){if(param.indexed){if(param.type===\"string\"||param.type===\"bytes\"||param.baseType===\"tuple\"||param.baseType===\"array\"){indexed.push(fragments.ParamType.fromObject({type:\"bytes32\",name:param.name}));dynamic.push(true);}else{indexed.push(param);dynamic.push(false);}}else{nonIndexed.push(param);dynamic.push(false);}});var resultIndexed=topics!=null?this._abiCoder.decode(indexed,lib$1.concat(topics)):null;var resultNonIndexed=this._abiCoder.decode(nonIndexed,data);var result=[];var nonIndexedIndex=0,indexedIndex=0;eventFragment.inputs.forEach(function(param,index){if(param.indexed){if(resultIndexed==null){result[index]=new Indexed({_isIndexed:true,hash:null});}else if(dynamic[index]){result[index]=new Indexed({_isIndexed:true,hash:resultIndexed[indexedIndex++]});}else{try{result[index]=resultIndexed[indexedIndex++];}catch(error){result[index]=error;}}}else{try{result[index]=resultNonIndexed[nonIndexedIndex++];}catch(error){result[index]=error;}}// Add the keyword argument if named and safe\nif(param.name&&result[param.name]==null){var value_1=result[index];// Make error named values throw on access\nif(value_1 instanceof Error){Object.defineProperty(result,param.name,{get:function get(){throw wrapAccessError(\"property \"+JSON.stringify(param.name),value_1);}});}else{result[param.name]=value_1;}}});var _loop_1=function _loop_1(i){var value=result[i];if(value instanceof Error){Object.defineProperty(result,i,{get:function get(){throw wrapAccessError(\"index \"+i,value);}});}};// Make all error indexed values throw on access\nfor(var i=0;i<result.length;i++){_loop_1(i);}return Object.freeze(result);};// Given a transaction, find the matching function fragment (if any) and\n// determine all its properties and call parameters\nInterface.prototype.parseTransaction=function(tx){var fragment=this.getFunction(tx.data.substring(0,10).toLowerCase());if(!fragment){return null;}return new TransactionDescription({args:this._abiCoder.decode(fragment.inputs,\"0x\"+tx.data.substring(10)),functionFragment:fragment,name:fragment.name,signature:fragment.format(),sighash:this.getSighash(fragment),value:lib$2.BigNumber.from(tx.value||\"0\")});};// Given an event log, find the matching event fragment (if any) and\n// determine all its properties and values\nInterface.prototype.parseLog=function(log){var fragment=this.getEvent(log.topics[0]);if(!fragment||fragment.anonymous){return null;}// @TODO: If anonymous, and the only method, and the input count matches, should we parse?\n//        Probably not, because just because it is the only event in the ABI does\n//        not mean we have the full ABI; maybe jsut a fragment?\nreturn new LogDescription({eventFragment:fragment,name:fragment.name,signature:fragment.format(),topic:this.getEventTopic(fragment),args:this.decodeEventLog(fragment,log.data,log.topics)});};/*\n\t    static from(value: Array<Fragment | string | JsonAbi> | string | Interface) {\n\t        if (Interface.isInterface(value)) {\n\t            return value;\n\t        }\n\t        if (typeof(value) === \"string\") {\n\t            return new Interface(JSON.parse(value));\n\t        }\n\t        return new Interface(value);\n\t    }\n\t    */Interface.isInterface=function(value){return!!(value&&value._isInterface);};return Interface;}();exports.Interface=Interface;});var _interface$1=unwrapExports(_interface);var _interface_1=_interface.checkResultErrors;var _interface_2=_interface.LogDescription;var _interface_3=_interface.TransactionDescription;var _interface_4=_interface.Indexed;var _interface_5=_interface.Interface;var lib$a=createCommonjsModule(function(module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});exports.ConstructorFragment=fragments.ConstructorFragment;exports.EventFragment=fragments.EventFragment;exports.FormatTypes=fragments.FormatTypes;exports.Fragment=fragments.Fragment;exports.FunctionFragment=fragments.FunctionFragment;exports.ParamType=fragments.ParamType;exports.AbiCoder=abiCoder.AbiCoder;exports.defaultAbiCoder=abiCoder.defaultAbiCoder;exports.checkResultErrors=_interface.checkResultErrors;exports.Indexed=_interface.Indexed;exports.Interface=_interface.Interface;exports.LogDescription=_interface.LogDescription;exports.TransactionDescription=_interface.TransactionDescription;});var index$a=unwrapExports(lib$a);var lib_1$a=lib$a.ConstructorFragment;var lib_2$9=lib$a.EventFragment;var lib_3$8=lib$a.FormatTypes;var lib_4$7=lib$a.Fragment;var lib_5$7=lib$a.FunctionFragment;var lib_6$4=lib$a.ParamType;var lib_7$4=lib$a.AbiCoder;var lib_8$3=lib$a.defaultAbiCoder;var lib_9$3=lib$a.checkResultErrors;var lib_10$2=lib$a.Indexed;var lib_11$1=lib$a.Interface;var lib_12$1=lib$a.LogDescription;var lib_13$1=lib$a.TransactionDescription;var _version$i=createCommonjsModule(function(module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});exports.version=\"abstract-provider/5.0.2\";});var _version$j=unwrapExports(_version$i);var _version_1$9=_version$i.version;var lib$b=createCommonjsModule(function(module,exports){\"use strict\";var __extends=commonjsGlobal&&commonjsGlobal.__extends||function(){var _extendStatics13=function extendStatics(d,b){_extendStatics13=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return _extendStatics13(d,b);};return function(d,b){_extendStatics13(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,\"__esModule\",{value:true});var logger=new lib.Logger(_version$i.version);;;//export type CallTransactionable = {\n//    call(transaction: TransactionRequest): Promise<TransactionResponse>;\n//};\nvar ForkEvent=/** @class */function(_super){__extends(ForkEvent,_super);function ForkEvent(){return _super!==null&&_super.apply(this,arguments)||this;}ForkEvent.isForkEvent=function(value){return!!(value&&value._isForkEvent);};return ForkEvent;}(lib$3.Description);exports.ForkEvent=ForkEvent;var BlockForkEvent=/** @class */function(_super){__extends(BlockForkEvent,_super);function BlockForkEvent(blockHash,expiry){var _this=this;if(!lib$1.isHexString(blockHash,32)){logger.throwArgumentError(\"invalid blockHash\",\"blockHash\",blockHash);}_this=_super.call(this,{_isForkEvent:true,_isBlockForkEvent:true,expiry:expiry||0,blockHash:blockHash})||this;return _this;}return BlockForkEvent;}(ForkEvent);exports.BlockForkEvent=BlockForkEvent;var TransactionForkEvent=/** @class */function(_super){__extends(TransactionForkEvent,_super);function TransactionForkEvent(hash,expiry){var _this=this;if(!lib$1.isHexString(hash,32)){logger.throwArgumentError(\"invalid transaction hash\",\"hash\",hash);}_this=_super.call(this,{_isForkEvent:true,_isTransactionForkEvent:true,expiry:expiry||0,hash:hash})||this;return _this;}return TransactionForkEvent;}(ForkEvent);exports.TransactionForkEvent=TransactionForkEvent;var TransactionOrderForkEvent=/** @class */function(_super){__extends(TransactionOrderForkEvent,_super);function TransactionOrderForkEvent(beforeHash,afterHash,expiry){var _this=this;if(!lib$1.isHexString(beforeHash,32)){logger.throwArgumentError(\"invalid transaction hash\",\"beforeHash\",beforeHash);}if(!lib$1.isHexString(afterHash,32)){logger.throwArgumentError(\"invalid transaction hash\",\"afterHash\",afterHash);}_this=_super.call(this,{_isForkEvent:true,_isTransactionOrderForkEvent:true,expiry:expiry||0,beforeHash:beforeHash,afterHash:afterHash})||this;return _this;}return TransactionOrderForkEvent;}(ForkEvent);exports.TransactionOrderForkEvent=TransactionOrderForkEvent;///////////////////////////////\n// Exported Abstracts\nvar Provider=/** @class */function(){function Provider(){var _newTarget=this.constructor;logger.checkAbstract(_newTarget,Provider);lib$3.defineReadOnly(this,\"_isProvider\",true);}// Alias for \"on\"\nProvider.prototype.addListener=function(eventName,listener){return this.on(eventName,listener);};// Alias for \"off\"\nProvider.prototype.removeListener=function(eventName,listener){return this.off(eventName,listener);};Provider.isProvider=function(value){return!!(value&&value._isProvider);};return Provider;}();exports.Provider=Provider;});var index$b=unwrapExports(lib$b);var lib_1$b=lib$b.ForkEvent;var lib_2$a=lib$b.BlockForkEvent;var lib_3$9=lib$b.TransactionForkEvent;var lib_4$8=lib$b.TransactionOrderForkEvent;var lib_5$8=lib$b.Provider;var _version$k=createCommonjsModule(function(module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});exports.version=\"abstract-signer/5.0.2\";});var _version$l=unwrapExports(_version$k);var _version_1$a=_version$k.version;var lib$c=createCommonjsModule(function(module,exports){\"use strict\";var __extends=commonjsGlobal&&commonjsGlobal.__extends||function(){var _extendStatics14=function extendStatics(d,b){_extendStatics14=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return _extendStatics14(d,b);};return function(d,b){_extendStatics14(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();var __awaiter=commonjsGlobal&&commonjsGlobal.__awaiter||function(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P(function(resolve){resolve(value);});}return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value));}catch(e){reject(e);}}function rejected(value){try{step(generator[\"throw\"](value));}catch(e){reject(e);}}function step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected);}step((generator=generator.apply(thisArg,_arguments||[])).next());});};var __generator=commonjsGlobal&&commonjsGlobal.__generator||function(thisArg,body){var _={label:0,sent:function sent(){if(t[0]&1)throw t[1];return t[1];},trys:[],ops:[]},f,y,t,g;return g={next:verb(0),\"throw\":verb(1),\"return\":verb(2)},typeof Symbol===\"function\"&&(g[Symbol.iterator]=function(){return this;}),g;function verb(n){return function(v){return step([n,v]);};}function step(op){if(f)throw new TypeError(\"Generator is already executing.\");while(_){try{if(f=1,y&&(t=op[0]&2?y[\"return\"]:op[0]?y[\"throw\"]||((t=y[\"return\"])&&t.call(y),0):y.next)&&!(t=t.call(y,op[1])).done)return t;if(y=0,t)op=[op[0]&2,t.value];switch(op[0]){case 0:case 1:t=op;break;case 4:_.label++;return{value:op[1],done:false};case 5:_.label++;y=op[1];op=[0];continue;case 7:op=_.ops.pop();_.trys.pop();continue;default:if(!(t=_.trys,t=t.length>0&&t[t.length-1])&&(op[0]===6||op[0]===2)){_=0;continue;}if(op[0]===3&&(!t||op[1]>t[0]&&op[1]<t[3])){_.label=op[1];break;}if(op[0]===6&&_.label<t[1]){_.label=t[1];t=op;break;}if(t&&_.label<t[2]){_.label=t[2];_.ops.push(op);break;}if(t[2])_.ops.pop();_.trys.pop();continue;}op=body.call(thisArg,_);}catch(e){op=[6,e];y=0;}finally{f=t=0;}}if(op[0]&5)throw op[1];return{value:op[0]?op[1]:void 0,done:true};}};Object.defineProperty(exports,\"__esModule\",{value:true});var logger=new lib.Logger(_version$k.version);var allowedTransactionKeys=[\"chainId\",\"data\",\"from\",\"gasLimit\",\"gasPrice\",\"nonce\",\"to\",\"value\"];// Sub-Class Notes:\n//  - A Signer MUST always make sure, that if present, the \"from\" field\n//    matches the Signer, before sending or signing a transaction\n//  - A Signer SHOULD always wrap private information (such as a private\n//    key or mnemonic) in a function, so that console.log does not leak\n//    the data\nvar Signer=/** @class */function(){///////////////////\n// Sub-classes MUST call super\nfunction Signer(){var _newTarget=this.constructor;logger.checkAbstract(_newTarget,Signer);lib$3.defineReadOnly(this,\"_isSigner\",true);}///////////////////\n// Sub-classes MAY override these\nSigner.prototype.getBalance=function(blockTag){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(_a){switch(_a.label){case 0:this._checkProvider(\"getBalance\");return[4/*yield*/,this.provider.getBalance(this.getAddress(),blockTag)];case 1:return[2/*return*/,_a.sent()];}});});};Signer.prototype.getTransactionCount=function(blockTag){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(_a){switch(_a.label){case 0:this._checkProvider(\"getTransactionCount\");return[4/*yield*/,this.provider.getTransactionCount(this.getAddress(),blockTag)];case 1:return[2/*return*/,_a.sent()];}});});};// Populates \"from\" if unspecified, and estimates the gas for the transation\nSigner.prototype.estimateGas=function(transaction){return __awaiter(this,void 0,void 0,function(){var tx;return __generator(this,function(_a){switch(_a.label){case 0:this._checkProvider(\"estimateGas\");return[4/*yield*/,lib$3.resolveProperties(this.checkTransaction(transaction))];case 1:tx=_a.sent();return[4/*yield*/,this.provider.estimateGas(tx)];case 2:return[2/*return*/,_a.sent()];}});});};// Populates \"from\" if unspecified, and calls with the transation\nSigner.prototype.call=function(transaction,blockTag){return __awaiter(this,void 0,void 0,function(){var tx;return __generator(this,function(_a){switch(_a.label){case 0:this._checkProvider(\"call\");return[4/*yield*/,lib$3.resolveProperties(this.checkTransaction(transaction))];case 1:tx=_a.sent();return[4/*yield*/,this.provider.call(tx,blockTag)];case 2:return[2/*return*/,_a.sent()];}});});};// Populates all fields in a transaction, signs it and sends it to the network\nSigner.prototype.sendTransaction=function(transaction){var _this=this;this._checkProvider(\"sendTransaction\");return this.populateTransaction(transaction).then(function(tx){return _this.signTransaction(tx).then(function(signedTx){return _this.provider.sendTransaction(signedTx);});});};Signer.prototype.getChainId=function(){return __awaiter(this,void 0,void 0,function(){var network;return __generator(this,function(_a){switch(_a.label){case 0:this._checkProvider(\"getChainId\");return[4/*yield*/,this.provider.getNetwork()];case 1:network=_a.sent();return[2/*return*/,network.chainId];}});});};Signer.prototype.getGasPrice=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(_a){switch(_a.label){case 0:this._checkProvider(\"getGasPrice\");return[4/*yield*/,this.provider.getGasPrice()];case 1:return[2/*return*/,_a.sent()];}});});};Signer.prototype.resolveName=function(name){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(_a){switch(_a.label){case 0:this._checkProvider(\"resolveName\");return[4/*yield*/,this.provider.resolveName(name)];case 1:return[2/*return*/,_a.sent()];}});});};// Checks a transaction does not contain invalid keys and if\n// no \"from\" is provided, populates it.\n// - does NOT require a provider\n// - adds \"from\" is not present\n// - returns a COPY (safe to mutate the result)\n// By default called from: (overriding these prevents it)\n//   - call\n//   - estimateGas\n//   - populateTransaction (and therefor sendTransaction)\nSigner.prototype.checkTransaction=function(transaction){for(var key in transaction){if(allowedTransactionKeys.indexOf(key)===-1){logger.throwArgumentError(\"invalid transaction key: \"+key,\"transaction\",transaction);}}var tx=lib$3.shallowCopy(transaction);if(tx.from==null){tx.from=this.getAddress();}else{// Make sure any provided address matches this signer\ntx.from=Promise.all([Promise.resolve(tx.from),this.getAddress()]).then(function(result){if(result[0]!==result[1]){logger.throwArgumentError(\"from address mismatch\",\"transaction\",transaction);}return result[0];});}return tx;};// Populates ALL keys for a transaction and checks that \"from\" matches\n// this Signer. Should be used by sendTransaction but NOT by signTransaction.\n// By default called from: (overriding these prevents it)\n//   - sendTransaction\nSigner.prototype.populateTransaction=function(transaction){return __awaiter(this,void 0,void 0,function(){var tx;var _this=this;return __generator(this,function(_a){switch(_a.label){case 0:return[4/*yield*/,lib$3.resolveProperties(this.checkTransaction(transaction))];case 1:tx=_a.sent();if(tx.to!=null){tx.to=Promise.resolve(tx.to).then(function(to){return _this.resolveName(to);});}if(tx.gasPrice==null){tx.gasPrice=this.getGasPrice();}if(tx.nonce==null){tx.nonce=this.getTransactionCount(\"pending\");}if(tx.gasLimit==null){tx.gasLimit=this.estimateGas(tx).catch(function(error){return logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\",lib.Logger.errors.UNPREDICTABLE_GAS_LIMIT,{error:error,tx:tx});});}if(tx.chainId==null){tx.chainId=this.getChainId();}else{tx.chainId=Promise.all([Promise.resolve(tx.chainId),this.getChainId()]).then(function(results){if(results[1]!==0&&results[0]!==results[1]){logger.throwArgumentError(\"chainId address mismatch\",\"transaction\",transaction);}return results[0];});}return[4/*yield*/,lib$3.resolveProperties(tx)];case 2:return[2/*return*/,_a.sent()];}});});};///////////////////\n// Sub-classes SHOULD leave these alone\nSigner.prototype._checkProvider=function(operation){if(!this.provider){logger.throwError(\"missing provider\",lib.Logger.errors.UNSUPPORTED_OPERATION,{operation:operation||\"_checkProvider\"});}};Signer.isSigner=function(value){return!!(value&&value._isSigner);};return Signer;}();exports.Signer=Signer;var VoidSigner=/** @class */function(_super){__extends(VoidSigner,_super);function VoidSigner(address,provider){var _newTarget=this.constructor;var _this=this;logger.checkNew(_newTarget,VoidSigner);_this=_super.call(this)||this;lib$3.defineReadOnly(_this,\"address\",address);lib$3.defineReadOnly(_this,\"provider\",provider||null);return _this;}VoidSigner.prototype.getAddress=function(){return Promise.resolve(this.address);};VoidSigner.prototype._fail=function(message,operation){return Promise.resolve().then(function(){logger.throwError(message,lib.Logger.errors.UNSUPPORTED_OPERATION,{operation:operation});});};VoidSigner.prototype.signMessage=function(message){return this._fail(\"VoidSigner cannot sign messages\",\"signMessage\");};VoidSigner.prototype.signTransaction=function(transaction){return this._fail(\"VoidSigner cannot sign transactions\",\"signTransaction\");};VoidSigner.prototype.connect=function(provider){return new VoidSigner(this.address,provider);};return VoidSigner;}(Signer);exports.VoidSigner=VoidSigner;});var index$c=unwrapExports(lib$c);var lib_1$c=lib$c.Signer;var lib_2$b=lib$c.VoidSigner;var _version$m=createCommonjsModule(function(module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});exports.version=\"contracts/5.0.2\";});var _version$n=unwrapExports(_version$m);var _version_1$b=_version$m.version;var lib$d=createCommonjsModule(function(module,exports){\"use strict\";var __extends=commonjsGlobal&&commonjsGlobal.__extends||function(){var _extendStatics15=function extendStatics(d,b){_extendStatics15=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return _extendStatics15(d,b);};return function(d,b){_extendStatics15(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();var __awaiter=commonjsGlobal&&commonjsGlobal.__awaiter||function(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P(function(resolve){resolve(value);});}return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value));}catch(e){reject(e);}}function rejected(value){try{step(generator[\"throw\"](value));}catch(e){reject(e);}}function step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected);}step((generator=generator.apply(thisArg,_arguments||[])).next());});};var __generator=commonjsGlobal&&commonjsGlobal.__generator||function(thisArg,body){var _={label:0,sent:function sent(){if(t[0]&1)throw t[1];return t[1];},trys:[],ops:[]},f,y,t,g;return g={next:verb(0),\"throw\":verb(1),\"return\":verb(2)},typeof Symbol===\"function\"&&(g[Symbol.iterator]=function(){return this;}),g;function verb(n){return function(v){return step([n,v]);};}function step(op){if(f)throw new TypeError(\"Generator is already executing.\");while(_){try{if(f=1,y&&(t=op[0]&2?y[\"return\"]:op[0]?y[\"throw\"]||((t=y[\"return\"])&&t.call(y),0):y.next)&&!(t=t.call(y,op[1])).done)return t;if(y=0,t)op=[op[0]&2,t.value];switch(op[0]){case 0:case 1:t=op;break;case 4:_.label++;return{value:op[1],done:false};case 5:_.label++;y=op[1];op=[0];continue;case 7:op=_.ops.pop();_.trys.pop();continue;default:if(!(t=_.trys,t=t.length>0&&t[t.length-1])&&(op[0]===6||op[0]===2)){_=0;continue;}if(op[0]===3&&(!t||op[1]>t[0]&&op[1]<t[3])){_.label=op[1];break;}if(op[0]===6&&_.label<t[1]){_.label=t[1];t=op;break;}if(t&&_.label<t[2]){_.label=t[2];_.ops.push(op);break;}if(t[2])_.ops.pop();_.trys.pop();continue;}op=body.call(thisArg,_);}catch(e){op=[6,e];y=0;}finally{f=t=0;}}if(op[0]&5)throw op[1];return{value:op[0]?op[1]:void 0,done:true};}};var __spreadArrays=commonjsGlobal&&commonjsGlobal.__spreadArrays||function(){for(var s=0,i=0,il=arguments.length;i<il;i++){s+=arguments[i].length;}for(var r=Array(s),k=0,i=0;i<il;i++){for(var a=arguments[i],j=0,jl=a.length;j<jl;j++,k++){r[k]=a[j];}}return r;};Object.defineProperty(exports,\"__esModule\",{value:true});//import { AddressZero } from \"@ethersproject/constants\";\n// @TOOD remove dependences transactions\nvar logger=new lib.Logger(_version$m.version);;;///////////////////////////////\nvar allowedTransactionKeys={chainId:true,data:true,from:true,gasLimit:true,gasPrice:true,nonce:true,to:true,value:true};function resolveName(resolver,nameOrPromise){return __awaiter(this,void 0,void 0,function(){var name;return __generator(this,function(_a){switch(_a.label){case 0:return[4/*yield*/,nameOrPromise];case 1:name=_a.sent();// If it is already an address, just use it (after adding checksum)\ntry{return[2/*return*/,lib$6.getAddress(name)];}catch(error){}if(!resolver){logger.throwError(\"a provider or signer is needed to resolve ENS names\",lib.Logger.errors.UNSUPPORTED_OPERATION,{operation:\"resolveName\"});}return[4/*yield*/,resolver.resolveName(name)];case 2:return[2/*return*/,_a.sent()];}});});}// Recursively replaces ENS names with promises to resolve the name and resolves all properties\nfunction resolveAddresses(resolver,value,paramType){if(Array.isArray(paramType)){return Promise.all(paramType.map(function(paramType,index){return resolveAddresses(resolver,Array.isArray(value)?value[index]:value[paramType.name],paramType);}));}if(paramType.type===\"address\"){return resolveName(resolver,value);}if(paramType.type===\"tuple\"){return resolveAddresses(resolver,value,paramType.components);}if(paramType.baseType===\"array\"){if(!Array.isArray(value)){throw new Error(\"invalid value for array\");}return Promise.all(value.map(function(v){return resolveAddresses(resolver,v,paramType.arrayChildren);}));}return Promise.resolve(value);}function populateTransaction(contract,fragment,args){return __awaiter(this,void 0,void 0,function(){var overrides,resolved,tx,ro,roValue,leftovers;var _this=this;return __generator(this,function(_a){switch(_a.label){case 0:overrides={};if(args.length===fragment.inputs.length+1&&_typeof(args[args.length-1])===\"object\"){overrides=lib$3.shallowCopy(args.pop());}// Make sure the parameter count matches\nlogger.checkArgumentCount(args.length,fragment.inputs.length,\"passed to contract\");// Populate \"from\" override (allow promises)\nif(contract.signer){if(overrides.from){// Contracts with a Signer are from the Signer's frame-of-reference;\n// but we allow overriding \"from\" if it matches the signer\noverrides.from=lib$3.resolveProperties({override:resolveName(contract.signer,overrides.from),signer:contract.signer.getAddress()}).then(function(check){return __awaiter(_this,void 0,void 0,function(){return __generator(this,function(_a){if(lib$6.getAddress(check.signer)!==check.override){logger.throwError(\"Contract with a Signer cannot override from\",lib.Logger.errors.UNSUPPORTED_OPERATION,{operation:\"overrides.from\"});}return[2/*return*/,check.override];});});});}else{overrides.from=contract.signer.getAddress();}}else if(overrides.from){overrides.from=resolveName(contract.provider,overrides.from);//} else {\n// Contracts without a signer can override \"from\", and if\n// unspecified the zero address is used\n//overrides.from = AddressZero;\n}return[4/*yield*/,lib$3.resolveProperties({args:resolveAddresses(contract.signer||contract.provider,args,fragment.inputs),address:contract.resolvedAddress,overrides:lib$3.resolveProperties(overrides)||{}})];case 1:resolved=_a.sent();tx={data:contract.interface.encodeFunctionData(fragment,resolved.args),to:resolved.address};ro=resolved.overrides;// Populate simple overrides\nif(ro.nonce!=null){tx.nonce=lib$2.BigNumber.from(ro.nonce).toNumber();}if(ro.gasLimit!=null){tx.gasLimit=lib$2.BigNumber.from(ro.gasLimit);}if(ro.gasPrice!=null){tx.gasPrice=lib$2.BigNumber.from(ro.gasPrice);}if(ro.from!=null){tx.from=ro.from;}// If there was no \"gasLimit\" override, but the ABI specifies a default, use it\nif(tx.gasLimit==null&&fragment.gas!=null){tx.gasLimit=lib$2.BigNumber.from(fragment.gas).add(21000);}// Populate \"value\" override\nif(ro.value){roValue=lib$2.BigNumber.from(ro.value);if(!roValue.isZero()&&!fragment.payable){logger.throwError(\"non-payable method cannot override value\",lib.Logger.errors.UNSUPPORTED_OPERATION,{operation:\"overrides.value\",value:overrides.value});}tx.value=roValue;}// Remvoe the overrides\ndelete overrides.nonce;delete overrides.gasLimit;delete overrides.gasPrice;delete overrides.from;delete overrides.value;leftovers=Object.keys(overrides).filter(function(key){return overrides[key]!=null;});if(leftovers.length){logger.throwError(\"cannot override \"+leftovers.map(function(l){return JSON.stringify(l);}).join(\",\"),lib.Logger.errors.UNSUPPORTED_OPERATION,{operation:\"overrides\",overrides:leftovers});}return[2/*return*/,tx];}});});}function buildPopulate(contract,fragment){return function(){var args=[];for(var _i=0;_i<arguments.length;_i++){args[_i]=arguments[_i];}return __awaiter(this,void 0,void 0,function(){return __generator(this,function(_a){return[2/*return*/,populateTransaction(contract,fragment,args)];});});};}function buildEstimate(contract,fragment){var signerOrProvider=contract.signer||contract.provider;return function(){var args=[];for(var _i=0;_i<arguments.length;_i++){args[_i]=arguments[_i];}return __awaiter(this,void 0,void 0,function(){var tx;return __generator(this,function(_a){switch(_a.label){case 0:if(!signerOrProvider){logger.throwError(\"estimate require a provider or signer\",lib.Logger.errors.UNSUPPORTED_OPERATION,{operation:\"estimateGas\"});}return[4/*yield*/,populateTransaction(contract,fragment,args)];case 1:tx=_a.sent();return[4/*yield*/,signerOrProvider.estimateGas(tx)];case 2:return[2/*return*/,_a.sent()];}});});};}function buildCall(contract,fragment,collapseSimple){var signerOrProvider=contract.signer||contract.provider;return function(){var args=[];for(var _i=0;_i<arguments.length;_i++){args[_i]=arguments[_i];}return __awaiter(this,void 0,void 0,function(){var blockTag,overrides,tx,result,value;return __generator(this,function(_a){switch(_a.label){case 0:blockTag=undefined;if(!(args.length===fragment.inputs.length+1&&_typeof(args[args.length-1])===\"object\"))return[3/*break*/,3];overrides=lib$3.shallowCopy(args.pop());if(!(overrides.blockTag!=null))return[3/*break*/,2];return[4/*yield*/,overrides.blockTag];case 1:blockTag=_a.sent();_a.label=2;case 2:delete overrides.blockTag;args.push(overrides);_a.label=3;case 3:if(!(contract.deployTransaction!=null))return[3/*break*/,5];return[4/*yield*/,contract._deployed(blockTag)];case 4:_a.sent();_a.label=5;case 5:return[4/*yield*/,populateTransaction(contract,fragment,args)];case 6:tx=_a.sent();return[4/*yield*/,signerOrProvider.call(tx,blockTag)];case 7:result=_a.sent();try{value=contract.interface.decodeFunctionResult(fragment,result);if(collapseSimple&&fragment.outputs.length===1){value=value[0];}return[2/*return*/,value];}catch(error){if(error.code===lib.Logger.errors.CALL_EXCEPTION){error.address=contract.address;error.args=args;error.transaction=tx;}throw error;}return[2/*return*/];}});});};}function buildSend(contract,fragment){return function(){var args=[];for(var _i=0;_i<arguments.length;_i++){args[_i]=arguments[_i];}return __awaiter(this,void 0,void 0,function(){var txRequest,tx,wait;return __generator(this,function(_a){switch(_a.label){case 0:if(!contract.signer){logger.throwError(\"sending a transaction requires a signer\",lib.Logger.errors.UNSUPPORTED_OPERATION,{operation:\"sendTransaction\"});}if(!(contract.deployTransaction!=null))return[3/*break*/,2];return[4/*yield*/,contract._deployed()];case 1:_a.sent();_a.label=2;case 2:return[4/*yield*/,populateTransaction(contract,fragment,args)];case 3:txRequest=_a.sent();return[4/*yield*/,contract.signer.sendTransaction(txRequest)];case 4:tx=_a.sent();wait=tx.wait.bind(tx);tx.wait=function(confirmations){return wait(confirmations).then(function(receipt){receipt.events=receipt.logs.map(function(log){var event=lib$3.deepCopy(log);var parsed=null;try{parsed=contract.interface.parseLog(log);}catch(e){}// Successfully parsed the event log; include it\nif(parsed){event.args=parsed.args;event.decode=function(data,topics){return contract.interface.decodeEventLog(parsed.eventFragment,data,topics);};event.event=parsed.name;event.eventSignature=parsed.signature;}// Useful operations\nevent.removeListener=function(){return contract.provider;};event.getBlock=function(){return contract.provider.getBlock(receipt.blockHash);};event.getTransaction=function(){return contract.provider.getTransaction(receipt.transactionHash);};event.getTransactionReceipt=function(){return Promise.resolve(receipt);};return event;});return receipt;});};return[2/*return*/,tx];}});});};}function buildDefault(contract,fragment,collapseSimple){if(fragment.constant){return buildCall(contract,fragment,collapseSimple);}return buildSend(contract,fragment);}function getEventTag(filter){if(filter.address&&(filter.topics==null||filter.topics.length===0)){return\"*\";}return(filter.address||\"*\")+\"@\"+(filter.topics?filter.topics.map(function(topic){if(Array.isArray(topic)){return topic.join(\"|\");}return topic;}).join(\":\"):\"\");}var RunningEvent=/** @class */function(){function RunningEvent(tag,filter){lib$3.defineReadOnly(this,\"tag\",tag);lib$3.defineReadOnly(this,\"filter\",filter);this._listeners=[];}RunningEvent.prototype.addListener=function(listener,once){this._listeners.push({listener:listener,once:once});};RunningEvent.prototype.removeListener=function(listener){var done=false;this._listeners=this._listeners.filter(function(item){if(done||item.listener!==listener){return true;}done=true;return false;});};RunningEvent.prototype.removeAllListeners=function(){this._listeners=[];};RunningEvent.prototype.listeners=function(){return this._listeners.map(function(i){return i.listener;});};RunningEvent.prototype.listenerCount=function(){return this._listeners.length;};RunningEvent.prototype.run=function(args){var _this=this;var listenerCount=this.listenerCount();this._listeners=this._listeners.filter(function(item){var argsCopy=args.slice();// Call the callback in the next event loop\nsetTimeout(function(){item.listener.apply(_this,argsCopy);},0);// Reschedule it if it not \"once\"\nreturn!item.once;});return listenerCount;};RunningEvent.prototype.prepareEvent=function(event){};// Returns the array that will be applied to an emit\nRunningEvent.prototype.getEmit=function(event){return[event];};return RunningEvent;}();var ErrorRunningEvent=/** @class */function(_super){__extends(ErrorRunningEvent,_super);function ErrorRunningEvent(){return _super.call(this,\"error\",null)||this;}return ErrorRunningEvent;}(RunningEvent);// @TODO Fragment should inherit Wildcard? and just override getEmit?\n//       or have a common abstract super class, with enough constructor\n//       options to configure both.\n// A Fragment Event will populate all the properties that Wildcard\n// will, and additioanlly dereference the arguments when emitting\nvar FragmentRunningEvent=/** @class */function(_super){__extends(FragmentRunningEvent,_super);function FragmentRunningEvent(address,contractInterface,fragment,topics){var _this=this;var filter={address:address};var topic=contractInterface.getEventTopic(fragment);if(topics){if(topic!==topics[0]){logger.throwArgumentError(\"topic mismatch\",\"topics\",topics);}filter.topics=topics.slice();}else{filter.topics=[topic];}_this=_super.call(this,getEventTag(filter),filter)||this;lib$3.defineReadOnly(_this,\"address\",address);lib$3.defineReadOnly(_this,\"interface\",contractInterface);lib$3.defineReadOnly(_this,\"fragment\",fragment);return _this;}FragmentRunningEvent.prototype.prepareEvent=function(event){var _this=this;_super.prototype.prepareEvent.call(this,event);event.event=this.fragment.name;event.eventSignature=this.fragment.format();event.decode=function(data,topics){return _this.interface.decodeEventLog(_this.fragment,data,topics);};try{event.args=this.interface.decodeEventLog(this.fragment,event.data,event.topics);}catch(error){event.args=null;event.decodeError=error;}};FragmentRunningEvent.prototype.getEmit=function(event){var errors=lib$a.checkResultErrors(event.args);if(errors.length){throw errors[0].error;}var args=(event.args||[]).slice();args.push(event);return args;};return FragmentRunningEvent;}(RunningEvent);// A Wildard Event will attempt to populate:\n//  - event            The name of the event name\n//  - eventSignature   The full signature of the event\n//  - decode           A function to decode data and topics\n//  - args             The decoded data and topics\nvar WildcardRunningEvent=/** @class */function(_super){__extends(WildcardRunningEvent,_super);function WildcardRunningEvent(address,contractInterface){var _this=_super.call(this,\"*\",{address:address})||this;lib$3.defineReadOnly(_this,\"address\",address);lib$3.defineReadOnly(_this,\"interface\",contractInterface);return _this;}WildcardRunningEvent.prototype.prepareEvent=function(event){var _this=this;_super.prototype.prepareEvent.call(this,event);try{var parsed_1=this.interface.parseLog(event);event.event=parsed_1.name;event.eventSignature=parsed_1.signature;event.decode=function(data,topics){return _this.interface.decodeEventLog(parsed_1.eventFragment,data,topics);};event.args=parsed_1.args;}catch(error){// No matching event\n}};return WildcardRunningEvent;}(RunningEvent);var Contract=/** @class */function(){function Contract(addressOrName,contractInterface,signerOrProvider){var _newTarget=this.constructor;var _this=this;logger.checkNew(_newTarget,Contract);// @TODO: Maybe still check the addressOrName looks like a valid address or name?\n//address = getAddress(address);\nlib$3.defineReadOnly(this,\"interface\",lib$3.getStatic(_newTarget,\"getInterface\")(contractInterface));if(signerOrProvider==null){lib$3.defineReadOnly(this,\"provider\",null);lib$3.defineReadOnly(this,\"signer\",null);}else if(lib$c.Signer.isSigner(signerOrProvider)){lib$3.defineReadOnly(this,\"provider\",signerOrProvider.provider||null);lib$3.defineReadOnly(this,\"signer\",signerOrProvider);}else if(lib$b.Provider.isProvider(signerOrProvider)){lib$3.defineReadOnly(this,\"provider\",signerOrProvider);lib$3.defineReadOnly(this,\"signer\",null);}else{logger.throwArgumentError(\"invalid signer or provider\",\"signerOrProvider\",signerOrProvider);}lib$3.defineReadOnly(this,\"callStatic\",{});lib$3.defineReadOnly(this,\"estimateGas\",{});lib$3.defineReadOnly(this,\"functions\",{});lib$3.defineReadOnly(this,\"populateTransaction\",{});lib$3.defineReadOnly(this,\"filters\",{});{var uniqueFilters_1={};Object.keys(this.interface.events).forEach(function(eventSignature){var event=_this.interface.events[eventSignature];lib$3.defineReadOnly(_this.filters,eventSignature,function(){var args=[];for(var _i=0;_i<arguments.length;_i++){args[_i]=arguments[_i];}return{address:_this.address,topics:_this.interface.encodeFilterTopics(event,args)};});if(!uniqueFilters_1[event.name]){uniqueFilters_1[event.name]=[];}uniqueFilters_1[event.name].push(eventSignature);});Object.keys(uniqueFilters_1).forEach(function(name){var filters=uniqueFilters_1[name];if(filters.length===1){lib$3.defineReadOnly(_this.filters,name,_this.filters[filters[0]]);}else{logger.warn(\"Duplicate definition of \"+name+\" (\"+filters.join(\", \")+\")\");}});}lib$3.defineReadOnly(this,\"_runningEvents\",{});lib$3.defineReadOnly(this,\"_wrappedEmits\",{});lib$3.defineReadOnly(this,\"address\",addressOrName);if(this.provider){lib$3.defineReadOnly(this,\"resolvedAddress\",this.provider.resolveName(addressOrName).then(function(address){if(address==null){throw new Error(\"name not found\");}return address;}).catch(function(error){console.log(\"ERROR: Cannot find Contract - \"+addressOrName);throw error;}));}else{try{lib$3.defineReadOnly(this,\"resolvedAddress\",Promise.resolve(lib$6.getAddress(addressOrName)));}catch(error){// Without a provider, we cannot use ENS names\nlogger.throwError(\"provider is required to use ENS name as contract address\",lib.Logger.errors.UNSUPPORTED_OPERATION,{operation:\"new Contract\"});}}var uniqueNames={};var uniqueSignatures={};Object.keys(this.interface.functions).forEach(function(signature){var fragment=_this.interface.functions[signature];// Check that the signature is unique; if not the ABI generation has\n// not been cleaned or may be incorrectly generated\nif(uniqueSignatures[signature]){logger.warn(\"Duplicate ABI entry for \"+JSON.stringify(name));return;}uniqueSignatures[signature]=true;// Track unique names; we only expose bare named functions if they\n// are ambiguous\n{var name_1=fragment.name;if(!uniqueNames[name_1]){uniqueNames[name_1]=[];}uniqueNames[name_1].push(signature);}if(_this[signature]==null){lib$3.defineReadOnly(_this,signature,buildDefault(_this,fragment,true));}// We do not collapse simple calls on this bucket, which allows\n// frameworks to safely use this without introspection as well as\n// allows decoding error recovery.\nif(_this.functions[signature]==null){lib$3.defineReadOnly(_this.functions,signature,buildDefault(_this,fragment,false));}if(_this.callStatic[signature]==null){lib$3.defineReadOnly(_this.callStatic,signature,buildCall(_this,fragment,true));}if(_this.populateTransaction[signature]==null){lib$3.defineReadOnly(_this.populateTransaction,signature,buildPopulate(_this,fragment));}if(_this.estimateGas[signature]==null){lib$3.defineReadOnly(_this.estimateGas,signature,buildEstimate(_this,fragment));}});Object.keys(uniqueNames).forEach(function(name){// Ambiguous names to not get attached as bare names\nvar signatures=uniqueNames[name];if(signatures.length>1){return;}var signature=signatures[0];if(_this[name]==null){lib$3.defineReadOnly(_this,name,_this[signature]);}if(_this.functions[name]==null){lib$3.defineReadOnly(_this.functions,name,_this.functions[signature]);}if(_this.callStatic[name]==null){lib$3.defineReadOnly(_this.callStatic,name,_this.callStatic[signature]);}if(_this.populateTransaction[name]==null){lib$3.defineReadOnly(_this.populateTransaction,name,_this.populateTransaction[signature]);}if(_this.estimateGas[name]==null){lib$3.defineReadOnly(_this.estimateGas,name,_this.estimateGas[signature]);}});}Contract.getContractAddress=function(transaction){return lib$6.getContractAddress(transaction);};Contract.getInterface=function(contractInterface){if(lib$a.Interface.isInterface(contractInterface)){return contractInterface;}return new lib$a.Interface(contractInterface);};// @TODO: Allow timeout?\nContract.prototype.deployed=function(){return this._deployed();};Contract.prototype._deployed=function(blockTag){var _this=this;if(!this._deployedPromise){// If we were just deployed, we know the transaction we should occur in\nif(this.deployTransaction){this._deployedPromise=this.deployTransaction.wait().then(function(){return _this;});}else{// @TODO: Once we allow a timeout to be passed in, we will wait\n// up to that many blocks for getCode\n// Otherwise, poll for our code to be deployed\nthis._deployedPromise=this.provider.getCode(this.address,blockTag).then(function(code){if(code===\"0x\"){logger.throwError(\"contract not deployed\",lib.Logger.errors.UNSUPPORTED_OPERATION,{contractAddress:_this.address,operation:\"getDeployed\"});}return _this;});}}return this._deployedPromise;};// @TODO:\n// estimateFallback(overrides?: TransactionRequest): Promise<BigNumber>\n// @TODO:\n// estimateDeploy(bytecode: string, ...args): Promise<BigNumber>\nContract.prototype.fallback=function(overrides){var _this=this;if(!this.signer){logger.throwError(\"sending a transactions require a signer\",lib.Logger.errors.UNSUPPORTED_OPERATION,{operation:\"sendTransaction(fallback)\"});}var tx=lib$3.shallowCopy(overrides||{});[\"from\",\"to\"].forEach(function(key){if(tx[key]==null){return;}logger.throwError(\"cannot override \"+key,lib.Logger.errors.UNSUPPORTED_OPERATION,{operation:key});});tx.to=this.resolvedAddress;return this.deployed().then(function(){return _this.signer.sendTransaction(tx);});};// Reconnect to a different signer or provider\nContract.prototype.connect=function(signerOrProvider){if(typeof signerOrProvider===\"string\"){signerOrProvider=new lib$c.VoidSigner(signerOrProvider,this.provider);}var contract=new this.constructor(this.address,this.interface,signerOrProvider);if(this.deployTransaction){lib$3.defineReadOnly(contract,\"deployTransaction\",this.deployTransaction);}return contract;};// Re-attach to a different on-chain instance of this contract\nContract.prototype.attach=function(addressOrName){return new this.constructor(addressOrName,this.interface,this.signer||this.provider);};Contract.isIndexed=function(value){return lib$a.Indexed.isIndexed(value);};Contract.prototype._normalizeRunningEvent=function(runningEvent){// Already have an instance of this event running; we can re-use it\nif(this._runningEvents[runningEvent.tag]){return this._runningEvents[runningEvent.tag];}return runningEvent;};Contract.prototype._getRunningEvent=function(eventName){if(typeof eventName===\"string\"){// Listen for \"error\" events (if your contract has an error event, include\n// the full signature to bypass this special event keyword)\nif(eventName===\"error\"){return this._normalizeRunningEvent(new ErrorRunningEvent());}// Listen for any event that is registered\nif(eventName===\"event\"){return this._normalizeRunningEvent(new RunningEvent(\"event\",null));}// Listen for any event\nif(eventName===\"*\"){return this._normalizeRunningEvent(new WildcardRunningEvent(this.address,this.interface));}// Get the event Fragment (throws if ambiguous/unknown event)\nvar fragment=this.interface.getEvent(eventName);return this._normalizeRunningEvent(new FragmentRunningEvent(this.address,this.interface,fragment));}// We have topics to filter by...\nif(eventName.topics&&eventName.topics.length>0){// Is it a known topichash? (throws if no matching topichash)\ntry{var topic=eventName.topics[0];if(typeof topic!==\"string\"){throw new Error(\"invalid topic\");// @TODO: May happen for anonymous events\n}var fragment=this.interface.getEvent(topic);return this._normalizeRunningEvent(new FragmentRunningEvent(this.address,this.interface,fragment,eventName.topics));}catch(error){}// Filter by the unknown topichash\nvar filter={address:this.address,topics:eventName.topics};return this._normalizeRunningEvent(new RunningEvent(getEventTag(filter),filter));}return this._normalizeRunningEvent(new WildcardRunningEvent(this.address,this.interface));};Contract.prototype._checkRunningEvents=function(runningEvent){if(runningEvent.listenerCount()===0){delete this._runningEvents[runningEvent.tag];// If we have a poller for this, remove it\nvar emit=this._wrappedEmits[runningEvent.tag];if(emit){this.provider.off(runningEvent.filter,emit);delete this._wrappedEmits[runningEvent.tag];}}};// Subclasses can override this to gracefully recover\n// from parse errors if they wish\nContract.prototype._wrapEvent=function(runningEvent,log,listener){var _this=this;var event=lib$3.deepCopy(log);event.removeListener=function(){if(!listener){return;}runningEvent.removeListener(listener);_this._checkRunningEvents(runningEvent);};event.getBlock=function(){return _this.provider.getBlock(log.blockHash);};event.getTransaction=function(){return _this.provider.getTransaction(log.transactionHash);};event.getTransactionReceipt=function(){return _this.provider.getTransactionReceipt(log.transactionHash);};// This may throw if the topics and data mismatch the signature\nrunningEvent.prepareEvent(event);return event;};Contract.prototype._addEventListener=function(runningEvent,listener,once){var _this=this;if(!this.provider){logger.throwError(\"events require a provider or a signer with a provider\",lib.Logger.errors.UNSUPPORTED_OPERATION,{operation:\"once\"});}runningEvent.addListener(listener,once);// Track this running event and its listeners (may already be there; but no hard in updating)\nthis._runningEvents[runningEvent.tag]=runningEvent;// If we are not polling the provider, start polling\nif(!this._wrappedEmits[runningEvent.tag]){var wrappedEmit=function wrappedEmit(log){var event=_this._wrapEvent(runningEvent,log,listener);// Try to emit the result for the parameterized event...\nif(event.decodeError==null){try{var args=runningEvent.getEmit(event);_this.emit.apply(_this,__spreadArrays([runningEvent.filter],args));}catch(error){event.decodeError=error.error;}}// Always emit \"event\" for fragment-base events\nif(runningEvent.filter!=null){_this.emit(\"event\",event);}// Emit \"error\" if there was an error\nif(event.decodeError!=null){_this.emit(\"error\",event.decodeError,event);}};this._wrappedEmits[runningEvent.tag]=wrappedEmit;// Special events, like \"error\" do not have a filter\nif(runningEvent.filter!=null){this.provider.on(runningEvent.filter,wrappedEmit);}}};Contract.prototype.queryFilter=function(event,fromBlockOrBlockhash,toBlock){var _this=this;var runningEvent=this._getRunningEvent(event);var filter=lib$3.shallowCopy(runningEvent.filter);if(typeof fromBlockOrBlockhash===\"string\"&&lib$1.isHexString(fromBlockOrBlockhash,32)){if(toBlock!=null){logger.throwArgumentError(\"cannot specify toBlock with blockhash\",\"toBlock\",toBlock);}filter.blockHash=fromBlockOrBlockhash;}else{filter.fromBlock=fromBlockOrBlockhash!=null?fromBlockOrBlockhash:0;filter.toBlock=toBlock!=null?toBlock:\"latest\";}return this.provider.getLogs(filter).then(function(logs){return logs.map(function(log){return _this._wrapEvent(runningEvent,log,null);});});};Contract.prototype.on=function(event,listener){this._addEventListener(this._getRunningEvent(event),listener,false);return this;};Contract.prototype.once=function(event,listener){this._addEventListener(this._getRunningEvent(event),listener,true);return this;};Contract.prototype.emit=function(eventName){var args=[];for(var _i=1;_i<arguments.length;_i++){args[_i-1]=arguments[_i];}if(!this.provider){return false;}var runningEvent=this._getRunningEvent(eventName);var result=runningEvent.run(args)>0;// May have drained all the \"once\" events; check for living events\nthis._checkRunningEvents(runningEvent);return result;};Contract.prototype.listenerCount=function(eventName){if(!this.provider){return 0;}return this._getRunningEvent(eventName).listenerCount();};Contract.prototype.listeners=function(eventName){if(!this.provider){return[];}if(eventName==null){var result_1=[];for(var tag in this._runningEvents){this._runningEvents[tag].listeners().forEach(function(listener){result_1.push(listener);});}return result_1;}return this._getRunningEvent(eventName).listeners();};Contract.prototype.removeAllListeners=function(eventName){if(!this.provider){return this;}if(eventName==null){for(var tag in this._runningEvents){var runningEvent_1=this._runningEvents[tag];runningEvent_1.removeAllListeners();this._checkRunningEvents(runningEvent_1);}return this;}// Delete any listeners\nvar runningEvent=this._getRunningEvent(eventName);runningEvent.removeAllListeners();this._checkRunningEvents(runningEvent);return this;};Contract.prototype.off=function(eventName,listener){if(!this.provider){return this;}var runningEvent=this._getRunningEvent(eventName);runningEvent.removeListener(listener);this._checkRunningEvents(runningEvent);return this;};Contract.prototype.removeListener=function(eventName,listener){return this.off(eventName,listener);};return Contract;}();exports.Contract=Contract;var ContractFactory=/** @class */function(){function ContractFactory(contractInterface,bytecode,signer){var _newTarget=this.constructor;var bytecodeHex=null;if(typeof bytecode===\"string\"){bytecodeHex=bytecode;}else if(lib$1.isBytes(bytecode)){bytecodeHex=lib$1.hexlify(bytecode);}else if(bytecode&&typeof bytecode.object===\"string\"){// Allow the bytecode object from the Solidity compiler\nbytecodeHex=bytecode.object;}else{// Crash in the next verification step\nbytecodeHex=\"!\";}// Make sure it is 0x prefixed\nif(bytecodeHex.substring(0,2)!==\"0x\"){bytecodeHex=\"0x\"+bytecodeHex;}// Make sure the final result is valid bytecode\nif(!lib$1.isHexString(bytecodeHex)||bytecodeHex.length%2){logger.throwArgumentError(\"invalid bytecode\",\"bytecode\",bytecode);}// If we have a signer, make sure it is valid\nif(signer&&!lib$c.Signer.isSigner(signer)){logger.throwArgumentError(\"invalid signer\",\"signer\",signer);}lib$3.defineReadOnly(this,\"bytecode\",bytecodeHex);lib$3.defineReadOnly(this,\"interface\",lib$3.getStatic(_newTarget,\"getInterface\")(contractInterface));lib$3.defineReadOnly(this,\"signer\",signer||null);}// @TODO: Future; rename to populteTransaction?\nContractFactory.prototype.getDeployTransaction=function(){var args=[];for(var _i=0;_i<arguments.length;_i++){args[_i]=arguments[_i];}var tx={};// If we have 1 additional argument, we allow transaction overrides\nif(args.length===this.interface.deploy.inputs.length+1&&_typeof(args[args.length-1])===\"object\"){tx=lib$3.shallowCopy(args.pop());for(var key in tx){if(!allowedTransactionKeys[key]){throw new Error(\"unknown transaction override \"+key);}}}// Do not allow these to be overridden in a deployment transaction\n[\"data\",\"from\",\"to\"].forEach(function(key){if(tx[key]==null){return;}logger.throwError(\"cannot override \"+key,lib.Logger.errors.UNSUPPORTED_OPERATION,{operation:key});});// Make sure the call matches the constructor signature\nlogger.checkArgumentCount(args.length,this.interface.deploy.inputs.length,\" in Contract constructor\");// Set the data to the bytecode + the encoded constructor arguments\ntx.data=lib$1.hexlify(lib$1.concat([this.bytecode,this.interface.encodeDeploy(args)]));return tx;};ContractFactory.prototype.deploy=function(){var args=[];for(var _i=0;_i<arguments.length;_i++){args[_i]=arguments[_i];}return __awaiter(this,void 0,void 0,function(){var overrides,params,unsignedTx,tx,address,contract;return __generator(this,function(_a){switch(_a.label){case 0:overrides={};// If 1 extra parameter was passed in, it contains overrides\nif(args.length===this.interface.deploy.inputs.length+1){overrides=args.pop();}// Make sure the call matches the constructor signature\nlogger.checkArgumentCount(args.length,this.interface.deploy.inputs.length,\" in Contract constructor\");return[4/*yield*/,resolveAddresses(this.signer,args,this.interface.deploy.inputs)];case 1:params=_a.sent();params.push(overrides);unsignedTx=this.getDeployTransaction.apply(this,params);return[4/*yield*/,this.signer.sendTransaction(unsignedTx)];case 2:tx=_a.sent();address=lib$3.getStatic(this.constructor,\"getContractAddress\")(tx);contract=lib$3.getStatic(this.constructor,\"getContract\")(address,this.interface,this.signer);lib$3.defineReadOnly(contract,\"deployTransaction\",tx);return[2/*return*/,contract];}});});};ContractFactory.prototype.attach=function(address){return this.constructor.getContract(address,this.interface,this.signer);};ContractFactory.prototype.connect=function(signer){return new this.constructor(this.interface,this.bytecode,signer);};ContractFactory.fromSolidity=function(compilerOutput,signer){if(compilerOutput==null){logger.throwError(\"missing compiler output\",lib.Logger.errors.MISSING_ARGUMENT,{argument:\"compilerOutput\"});}if(typeof compilerOutput===\"string\"){compilerOutput=JSON.parse(compilerOutput);}var abi=compilerOutput.abi;var bytecode=null;if(compilerOutput.bytecode){bytecode=compilerOutput.bytecode;}else if(compilerOutput.evm&&compilerOutput.evm.bytecode){bytecode=compilerOutput.evm.bytecode;}return new this(abi,bytecode,signer);};ContractFactory.getInterface=function(contractInterface){return Contract.getInterface(contractInterface);};ContractFactory.getContractAddress=function(tx){return lib$6.getContractAddress(tx);};ContractFactory.getContract=function(address,contractInterface,signer){return new Contract(address,contractInterface,signer);};return ContractFactory;}();exports.ContractFactory=ContractFactory;});var index$d=unwrapExports(lib$d);var lib_1$d=lib$d.Contract;var lib_2$c=lib$d.ContractFactory;var lib$e=createCommonjsModule(function(module,exports){\"use strict\";/**\n\t * var basex = require(\"base-x\");\n\t *\n\t * This implementation is heavily based on base-x. The main reason to\n\t * deviate was to prevent the dependency of Buffer.\n\t *\n\t * Contributors:\n\t *\n\t * base-x encoding\n\t * Forked from https://github.com/cryptocoinjs/bs58\n\t * Originally written by Mike Hearn for BitcoinJ\n\t * Copyright (c) 2011 Google Inc\n\t * Ported to JavaScript by Stefan Thomas\n\t * Merged Buffer refactorings from base58-native by Stephen Pair\n\t * Copyright (c) 2013 BitPay Inc\n\t *\n\t * The MIT License (MIT)\n\t *\n\t * Copyright base-x contributors (c) 2016\n\t *\n\t * Permission is hereby granted, free of charge, to any person obtaining a\n\t * copy of this software and associated documentation files (the \"Software\"),\n\t * to deal in the Software without restriction, including without limitation\n\t * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n\t * and/or sell copies of the Software, and to permit persons to whom the\n\t * Software is furnished to do so, subject to the following conditions:\n\t *\n\t * The above copyright notice and this permission notice shall be included in\n\t * all copies or substantial portions of the Software.\n\n\t * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\t * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\t * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\t * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\t * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n\t * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n\t * IN THE SOFTWARE.\n\t *\n\t */Object.defineProperty(exports,\"__esModule\",{value:true});var BaseX=/** @class */function(){function BaseX(alphabet){lib$3.defineReadOnly(this,\"alphabet\",alphabet);lib$3.defineReadOnly(this,\"base\",alphabet.length);lib$3.defineReadOnly(this,\"_alphabetMap\",{});lib$3.defineReadOnly(this,\"_leader\",alphabet.charAt(0));// pre-compute lookup table\nfor(var i=0;i<alphabet.length;i++){this._alphabetMap[alphabet.charAt(i)]=i;}}BaseX.prototype.encode=function(value){var source=lib$1.arrayify(value);if(source.length===0){return\"\";}var digits=[0];for(var i=0;i<source.length;++i){var carry=source[i];for(var j=0;j<digits.length;++j){carry+=digits[j]<<8;digits[j]=carry%this.base;carry=carry/this.base|0;}while(carry>0){digits.push(carry%this.base);carry=carry/this.base|0;}}var string=\"\";// deal with leading zeros\nfor(var k=0;source[k]===0&&k<source.length-1;++k){string+=this._leader;}// convert digits to a string\nfor(var q=digits.length-1;q>=0;--q){string+=this.alphabet[digits[q]];}return string;};BaseX.prototype.decode=function(value){if(typeof value!==\"string\"){throw new TypeError(\"Expected String\");}var bytes=[];if(value.length===0){return new Uint8Array(bytes);}bytes.push(0);for(var i=0;i<value.length;i++){var byte=this._alphabetMap[value[i]];if(byte===undefined){throw new Error(\"Non-base\"+this.base+\" character\");}var carry=byte;for(var j=0;j<bytes.length;++j){carry+=bytes[j]*this.base;bytes[j]=carry&0xff;carry>>=8;}while(carry>0){bytes.push(carry&0xff);carry>>=8;}}// deal with leading zeros\nfor(var k=0;value[k]===this._leader&&k<value.length-1;++k){bytes.push(0);}return lib$1.arrayify(new Uint8Array(bytes.reverse()));};return BaseX;}();exports.BaseX=BaseX;var Base32=new BaseX(\"abcdefghijklmnopqrstuvwxyz234567\");exports.Base32=Base32;var Base58=new BaseX(\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\");exports.Base58=Base58;//console.log(Base58.decode(\"Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj\"))\n//console.log(Base58.encode(Base58.decode(\"Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj\")))\n});var index$e=unwrapExports(lib$e);var lib_1$e=lib$e.BaseX;var lib_2$d=lib$e.Base32;var lib_3$a=lib$e.Base58;var minimalisticAssert=assert;function assert(val,msg){if(!val)throw new Error(msg||'Assertion failed');}assert.equal=function assertEqual(l,r,msg){if(l!=r)throw new Error(msg||'Assertion failed: '+l+' != '+r);};var inherits_browser=createCommonjsModule(function(module){if(typeof Object.create==='function'){// implementation from standard node.js 'util' module\nmodule.exports=function inherits(ctor,superCtor){if(superCtor){ctor.super_=superCtor;ctor.prototype=Object.create(superCtor.prototype,{constructor:{value:ctor,enumerable:false,writable:true,configurable:true}});}};}else{// old school shim for old browsers\nmodule.exports=function inherits(ctor,superCtor){if(superCtor){ctor.super_=superCtor;var TempCtor=function TempCtor(){};TempCtor.prototype=superCtor.prototype;ctor.prototype=new TempCtor();ctor.prototype.constructor=ctor;}};}});'use strict';var inherits_1=inherits_browser;function toArray(msg,enc){if(Array.isArray(msg))return msg.slice();if(!msg)return[];var res=[];if(typeof msg==='string'){if(!enc){for(var i=0;i<msg.length;i++){var c=msg.charCodeAt(i);var hi=c>>8;var lo=c&0xff;if(hi)res.push(hi,lo);else res.push(lo);}}else if(enc==='hex'){msg=msg.replace(/[^a-z0-9]+/ig,'');if(msg.length%2!==0)msg='0'+msg;for(i=0;i<msg.length;i+=2){res.push(parseInt(msg[i]+msg[i+1],16));}}}else{for(i=0;i<msg.length;i++){res[i]=msg[i]|0;}}return res;}var toArray_1=toArray;function toHex(msg){var res='';for(var i=0;i<msg.length;i++){res+=zero2(msg[i].toString(16));}return res;}var toHex_1=toHex;function htonl(w){var res=w>>>24|w>>>8&0xff00|w<<8&0xff0000|(w&0xff)<<24;return res>>>0;}var htonl_1=htonl;function toHex32(msg,endian){var res='';for(var i=0;i<msg.length;i++){var w=msg[i];if(endian==='little')w=htonl(w);res+=zero8(w.toString(16));}return res;}var toHex32_1=toHex32;function zero2(word){if(word.length===1)return'0'+word;else return word;}var zero2_1=zero2;function zero8(word){if(word.length===7)return'0'+word;else if(word.length===6)return'00'+word;else if(word.length===5)return'000'+word;else if(word.length===4)return'0000'+word;else if(word.length===3)return'00000'+word;else if(word.length===2)return'000000'+word;else if(word.length===1)return'0000000'+word;else return word;}var zero8_1=zero8;function join32(msg,start,end,endian){var len=end-start;minimalisticAssert(len%4===0);var res=new Array(len/4);for(var i=0,k=start;i<res.length;i++,k+=4){var w;if(endian==='big')w=msg[k]<<24|msg[k+1]<<16|msg[k+2]<<8|msg[k+3];else w=msg[k+3]<<24|msg[k+2]<<16|msg[k+1]<<8|msg[k];res[i]=w>>>0;}return res;}var join32_1=join32;function split32(msg,endian){var res=new Array(msg.length*4);for(var i=0,k=0;i<msg.length;i++,k+=4){var m=msg[i];if(endian==='big'){res[k]=m>>>24;res[k+1]=m>>>16&0xff;res[k+2]=m>>>8&0xff;res[k+3]=m&0xff;}else{res[k+3]=m>>>24;res[k+2]=m>>>16&0xff;res[k+1]=m>>>8&0xff;res[k]=m&0xff;}}return res;}var split32_1=split32;function rotr32(w,b){return w>>>b|w<<32-b;}var rotr32_1=rotr32;function rotl32(w,b){return w<<b|w>>>32-b;}var rotl32_1=rotl32;function sum32(a,b){return a+b>>>0;}var sum32_1=sum32;function sum32_3(a,b,c){return a+b+c>>>0;}var sum32_3_1=sum32_3;function sum32_4(a,b,c,d){return a+b+c+d>>>0;}var sum32_4_1=sum32_4;function sum32_5(a,b,c,d,e){return a+b+c+d+e>>>0;}var sum32_5_1=sum32_5;function sum64(buf,pos,ah,al){var bh=buf[pos];var bl=buf[pos+1];var lo=al+bl>>>0;var hi=(lo<al?1:0)+ah+bh;buf[pos]=hi>>>0;buf[pos+1]=lo;}var sum64_1=sum64;function sum64_hi(ah,al,bh,bl){var lo=al+bl>>>0;var hi=(lo<al?1:0)+ah+bh;return hi>>>0;}var sum64_hi_1=sum64_hi;function sum64_lo(ah,al,bh,bl){var lo=al+bl;return lo>>>0;}var sum64_lo_1=sum64_lo;function sum64_4_hi(ah,al,bh,bl,ch,cl,dh,dl){var carry=0;var lo=al;lo=lo+bl>>>0;carry+=lo<al?1:0;lo=lo+cl>>>0;carry+=lo<cl?1:0;lo=lo+dl>>>0;carry+=lo<dl?1:0;var hi=ah+bh+ch+dh+carry;return hi>>>0;}var sum64_4_hi_1=sum64_4_hi;function sum64_4_lo(ah,al,bh,bl,ch,cl,dh,dl){var lo=al+bl+cl+dl;return lo>>>0;}var sum64_4_lo_1=sum64_4_lo;function sum64_5_hi(ah,al,bh,bl,ch,cl,dh,dl,eh,el){var carry=0;var lo=al;lo=lo+bl>>>0;carry+=lo<al?1:0;lo=lo+cl>>>0;carry+=lo<cl?1:0;lo=lo+dl>>>0;carry+=lo<dl?1:0;lo=lo+el>>>0;carry+=lo<el?1:0;var hi=ah+bh+ch+dh+eh+carry;return hi>>>0;}var sum64_5_hi_1=sum64_5_hi;function sum64_5_lo(ah,al,bh,bl,ch,cl,dh,dl,eh,el){var lo=al+bl+cl+dl+el;return lo>>>0;}var sum64_5_lo_1=sum64_5_lo;function rotr64_hi(ah,al,num){var r=al<<32-num|ah>>>num;return r>>>0;}var rotr64_hi_1=rotr64_hi;function rotr64_lo(ah,al,num){var r=ah<<32-num|al>>>num;return r>>>0;}var rotr64_lo_1=rotr64_lo;function shr64_hi(ah,al,num){return ah>>>num;}var shr64_hi_1=shr64_hi;function shr64_lo(ah,al,num){var r=ah<<32-num|al>>>num;return r>>>0;}var shr64_lo_1=shr64_lo;var utils={inherits:inherits_1,toArray:toArray_1,toHex:toHex_1,htonl:htonl_1,toHex32:toHex32_1,zero2:zero2_1,zero8:zero8_1,join32:join32_1,split32:split32_1,rotr32:rotr32_1,rotl32:rotl32_1,sum32:sum32_1,sum32_3:sum32_3_1,sum32_4:sum32_4_1,sum32_5:sum32_5_1,sum64:sum64_1,sum64_hi:sum64_hi_1,sum64_lo:sum64_lo_1,sum64_4_hi:sum64_4_hi_1,sum64_4_lo:sum64_4_lo_1,sum64_5_hi:sum64_5_hi_1,sum64_5_lo:sum64_5_lo_1,rotr64_hi:rotr64_hi_1,rotr64_lo:rotr64_lo_1,shr64_hi:shr64_hi_1,shr64_lo:shr64_lo_1};'use strict';function BlockHash(){this.pending=null;this.pendingTotal=0;this.blockSize=this.constructor.blockSize;this.outSize=this.constructor.outSize;this.hmacStrength=this.constructor.hmacStrength;this.padLength=this.constructor.padLength/8;this.endian='big';this._delta8=this.blockSize/8;this._delta32=this.blockSize/32;}var BlockHash_1=BlockHash;BlockHash.prototype.update=function update(msg,enc){// Convert message to array, pad it, and join into 32bit blocks\nmsg=utils.toArray(msg,enc);if(!this.pending)this.pending=msg;else this.pending=this.pending.concat(msg);this.pendingTotal+=msg.length;// Enough data, try updating\nif(this.pending.length>=this._delta8){msg=this.pending;// Process pending data in blocks\nvar r=msg.length%this._delta8;this.pending=msg.slice(msg.length-r,msg.length);if(this.pending.length===0)this.pending=null;msg=utils.join32(msg,0,msg.length-r,this.endian);for(var i=0;i<msg.length;i+=this._delta32){this._update(msg,i,i+this._delta32);}}return this;};BlockHash.prototype.digest=function digest(enc){this.update(this._pad());minimalisticAssert(this.pending===null);return this._digest(enc);};BlockHash.prototype._pad=function pad(){var len=this.pendingTotal;var bytes=this._delta8;var k=bytes-(len+this.padLength)%bytes;var res=new Array(k+this.padLength);res[0]=0x80;for(var i=1;i<k;i++){res[i]=0;}// Append length\nlen<<=3;if(this.endian==='big'){for(var t=8;t<this.padLength;t++){res[i++]=0;}res[i++]=0;res[i++]=0;res[i++]=0;res[i++]=0;res[i++]=len>>>24&0xff;res[i++]=len>>>16&0xff;res[i++]=len>>>8&0xff;res[i++]=len&0xff;}else{res[i++]=len&0xff;res[i++]=len>>>8&0xff;res[i++]=len>>>16&0xff;res[i++]=len>>>24&0xff;res[i++]=0;res[i++]=0;res[i++]=0;res[i++]=0;for(t=8;t<this.padLength;t++){res[i++]=0;}}return res;};var common={BlockHash:BlockHash_1};var _1={};var _224={};'use strict';var rotr32$1=utils.rotr32;function ft_1(s,x,y,z){if(s===0)return ch32(x,y,z);if(s===1||s===3)return p32(x,y,z);if(s===2)return maj32(x,y,z);}var ft_1_1=ft_1;function ch32(x,y,z){return x&y^~x&z;}var ch32_1=ch32;function maj32(x,y,z){return x&y^x&z^y&z;}var maj32_1=maj32;function p32(x,y,z){return x^y^z;}var p32_1=p32;function s0_256(x){return rotr32$1(x,2)^rotr32$1(x,13)^rotr32$1(x,22);}var s0_256_1=s0_256;function s1_256(x){return rotr32$1(x,6)^rotr32$1(x,11)^rotr32$1(x,25);}var s1_256_1=s1_256;function g0_256(x){return rotr32$1(x,7)^rotr32$1(x,18)^x>>>3;}var g0_256_1=g0_256;function g1_256(x){return rotr32$1(x,17)^rotr32$1(x,19)^x>>>10;}var g1_256_1=g1_256;var common$1={ft_1:ft_1_1,ch32:ch32_1,maj32:maj32_1,p32:p32_1,s0_256:s0_256_1,s1_256:s1_256_1,g0_256:g0_256_1,g1_256:g1_256_1};'use strict';var sum32$1=utils.sum32;var sum32_4$1=utils.sum32_4;var sum32_5$1=utils.sum32_5;var ch32$1=common$1.ch32;var maj32$1=common$1.maj32;var s0_256$1=common$1.s0_256;var s1_256$1=common$1.s1_256;var g0_256$1=common$1.g0_256;var g1_256$1=common$1.g1_256;var BlockHash$1=common.BlockHash;var sha256_K=[0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5,0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174,0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da,0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967,0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85,0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,0xd192e819,0xd6990624,0xf40e3585,0x106aa070,0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3,0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2];function SHA256(){if(!(this instanceof SHA256))return new SHA256();BlockHash$1.call(this);this.h=[0x6a09e667,0xbb67ae85,0x3c6ef372,0xa54ff53a,0x510e527f,0x9b05688c,0x1f83d9ab,0x5be0cd19];this.k=sha256_K;this.W=new Array(64);}utils.inherits(SHA256,BlockHash$1);var _256=SHA256;SHA256.blockSize=512;SHA256.outSize=256;SHA256.hmacStrength=192;SHA256.padLength=64;SHA256.prototype._update=function _update(msg,start){var W=this.W;for(var i=0;i<16;i++){W[i]=msg[start+i];}for(;i<W.length;i++){W[i]=sum32_4$1(g1_256$1(W[i-2]),W[i-7],g0_256$1(W[i-15]),W[i-16]);}var a=this.h[0];var b=this.h[1];var c=this.h[2];var d=this.h[3];var e=this.h[4];var f=this.h[5];var g=this.h[6];var h=this.h[7];minimalisticAssert(this.k.length===W.length);for(i=0;i<W.length;i++){var T1=sum32_5$1(h,s1_256$1(e),ch32$1(e,f,g),this.k[i],W[i]);var T2=sum32$1(s0_256$1(a),maj32$1(a,b,c));h=g;g=f;f=e;e=sum32$1(d,T1);d=c;c=b;b=a;a=sum32$1(T1,T2);}this.h[0]=sum32$1(this.h[0],a);this.h[1]=sum32$1(this.h[1],b);this.h[2]=sum32$1(this.h[2],c);this.h[3]=sum32$1(this.h[3],d);this.h[4]=sum32$1(this.h[4],e);this.h[5]=sum32$1(this.h[5],f);this.h[6]=sum32$1(this.h[6],g);this.h[7]=sum32$1(this.h[7],h);};SHA256.prototype._digest=function digest(enc){if(enc==='hex')return utils.toHex32(this.h,'big');else return utils.split32(this.h,'big');};var _384={};'use strict';var rotr64_hi$1=utils.rotr64_hi;var rotr64_lo$1=utils.rotr64_lo;var shr64_hi$1=utils.shr64_hi;var shr64_lo$1=utils.shr64_lo;var sum64$1=utils.sum64;var sum64_hi$1=utils.sum64_hi;var sum64_lo$1=utils.sum64_lo;var sum64_4_hi$1=utils.sum64_4_hi;var sum64_4_lo$1=utils.sum64_4_lo;var sum64_5_hi$1=utils.sum64_5_hi;var sum64_5_lo$1=utils.sum64_5_lo;var BlockHash$2=common.BlockHash;var sha512_K=[0x428a2f98,0xd728ae22,0x71374491,0x23ef65cd,0xb5c0fbcf,0xec4d3b2f,0xe9b5dba5,0x8189dbbc,0x3956c25b,0xf348b538,0x59f111f1,0xb605d019,0x923f82a4,0xaf194f9b,0xab1c5ed5,0xda6d8118,0xd807aa98,0xa3030242,0x12835b01,0x45706fbe,0x243185be,0x4ee4b28c,0x550c7dc3,0xd5ffb4e2,0x72be5d74,0xf27b896f,0x80deb1fe,0x3b1696b1,0x9bdc06a7,0x25c71235,0xc19bf174,0xcf692694,0xe49b69c1,0x9ef14ad2,0xefbe4786,0x384f25e3,0x0fc19dc6,0x8b8cd5b5,0x240ca1cc,0x77ac9c65,0x2de92c6f,0x592b0275,0x4a7484aa,0x6ea6e483,0x5cb0a9dc,0xbd41fbd4,0x76f988da,0x831153b5,0x983e5152,0xee66dfab,0xa831c66d,0x2db43210,0xb00327c8,0x98fb213f,0xbf597fc7,0xbeef0ee4,0xc6e00bf3,0x3da88fc2,0xd5a79147,0x930aa725,0x06ca6351,0xe003826f,0x14292967,0x0a0e6e70,0x27b70a85,0x46d22ffc,0x2e1b2138,0x5c26c926,0x4d2c6dfc,0x5ac42aed,0x53380d13,0x9d95b3df,0x650a7354,0x8baf63de,0x766a0abb,0x3c77b2a8,0x81c2c92e,0x47edaee6,0x92722c85,0x1482353b,0xa2bfe8a1,0x4cf10364,0xa81a664b,0xbc423001,0xc24b8b70,0xd0f89791,0xc76c51a3,0x0654be30,0xd192e819,0xd6ef5218,0xd6990624,0x5565a910,0xf40e3585,0x5771202a,0x106aa070,0x32bbd1b8,0x19a4c116,0xb8d2d0c8,0x1e376c08,0x5141ab53,0x2748774c,0xdf8eeb99,0x34b0bcb5,0xe19b48a8,0x391c0cb3,0xc5c95a63,0x4ed8aa4a,0xe3418acb,0x5b9cca4f,0x7763e373,0x682e6ff3,0xd6b2b8a3,0x748f82ee,0x5defb2fc,0x78a5636f,0x43172f60,0x84c87814,0xa1f0ab72,0x8cc70208,0x1a6439ec,0x90befffa,0x23631e28,0xa4506ceb,0xde82bde9,0xbef9a3f7,0xb2c67915,0xc67178f2,0xe372532b,0xca273ece,0xea26619c,0xd186b8c7,0x21c0c207,0xeada7dd6,0xcde0eb1e,0xf57d4f7f,0xee6ed178,0x06f067aa,0x72176fba,0x0a637dc5,0xa2c898a6,0x113f9804,0xbef90dae,0x1b710b35,0x131c471b,0x28db77f5,0x23047d84,0x32caab7b,0x40c72493,0x3c9ebe0a,0x15c9bebc,0x431d67c4,0x9c100d4c,0x4cc5d4be,0xcb3e42b6,0x597f299c,0xfc657e2a,0x5fcb6fab,0x3ad6faec,0x6c44198c,0x4a475817];function SHA512(){if(!(this instanceof SHA512))return new SHA512();BlockHash$2.call(this);this.h=[0x6a09e667,0xf3bcc908,0xbb67ae85,0x84caa73b,0x3c6ef372,0xfe94f82b,0xa54ff53a,0x5f1d36f1,0x510e527f,0xade682d1,0x9b05688c,0x2b3e6c1f,0x1f83d9ab,0xfb41bd6b,0x5be0cd19,0x137e2179];this.k=sha512_K;this.W=new Array(160);}utils.inherits(SHA512,BlockHash$2);var _512=SHA512;SHA512.blockSize=1024;SHA512.outSize=512;SHA512.hmacStrength=192;SHA512.padLength=128;SHA512.prototype._prepareBlock=function _prepareBlock(msg,start){var W=this.W;// 32 x 32bit words\nfor(var i=0;i<32;i++){W[i]=msg[start+i];}for(;i<W.length;i+=2){var c0_hi=g1_512_hi(W[i-4],W[i-3]);// i - 2\nvar c0_lo=g1_512_lo(W[i-4],W[i-3]);var c1_hi=W[i-14];// i - 7\nvar c1_lo=W[i-13];var c2_hi=g0_512_hi(W[i-30],W[i-29]);// i - 15\nvar c2_lo=g0_512_lo(W[i-30],W[i-29]);var c3_hi=W[i-32];// i - 16\nvar c3_lo=W[i-31];W[i]=sum64_4_hi$1(c0_hi,c0_lo,c1_hi,c1_lo,c2_hi,c2_lo,c3_hi,c3_lo);W[i+1]=sum64_4_lo$1(c0_hi,c0_lo,c1_hi,c1_lo,c2_hi,c2_lo,c3_hi,c3_lo);}};SHA512.prototype._update=function _update(msg,start){this._prepareBlock(msg,start);var W=this.W;var ah=this.h[0];var al=this.h[1];var bh=this.h[2];var bl=this.h[3];var ch=this.h[4];var cl=this.h[5];var dh=this.h[6];var dl=this.h[7];var eh=this.h[8];var el=this.h[9];var fh=this.h[10];var fl=this.h[11];var gh=this.h[12];var gl=this.h[13];var hh=this.h[14];var hl=this.h[15];minimalisticAssert(this.k.length===W.length);for(var i=0;i<W.length;i+=2){var c0_hi=hh;var c0_lo=hl;var c1_hi=s1_512_hi(eh,el);var c1_lo=s1_512_lo(eh,el);var c2_hi=ch64_hi(eh,el,fh,fl,gh,gl);var c2_lo=ch64_lo(eh,el,fh,fl,gh,gl);var c3_hi=this.k[i];var c3_lo=this.k[i+1];var c4_hi=W[i];var c4_lo=W[i+1];var T1_hi=sum64_5_hi$1(c0_hi,c0_lo,c1_hi,c1_lo,c2_hi,c2_lo,c3_hi,c3_lo,c4_hi,c4_lo);var T1_lo=sum64_5_lo$1(c0_hi,c0_lo,c1_hi,c1_lo,c2_hi,c2_lo,c3_hi,c3_lo,c4_hi,c4_lo);c0_hi=s0_512_hi(ah,al);c0_lo=s0_512_lo(ah,al);c1_hi=maj64_hi(ah,al,bh,bl,ch,cl);c1_lo=maj64_lo(ah,al,bh,bl,ch,cl);var T2_hi=sum64_hi$1(c0_hi,c0_lo,c1_hi,c1_lo);var T2_lo=sum64_lo$1(c0_hi,c0_lo,c1_hi,c1_lo);hh=gh;hl=gl;gh=fh;gl=fl;fh=eh;fl=el;eh=sum64_hi$1(dh,dl,T1_hi,T1_lo);el=sum64_lo$1(dl,dl,T1_hi,T1_lo);dh=ch;dl=cl;ch=bh;cl=bl;bh=ah;bl=al;ah=sum64_hi$1(T1_hi,T1_lo,T2_hi,T2_lo);al=sum64_lo$1(T1_hi,T1_lo,T2_hi,T2_lo);}sum64$1(this.h,0,ah,al);sum64$1(this.h,2,bh,bl);sum64$1(this.h,4,ch,cl);sum64$1(this.h,6,dh,dl);sum64$1(this.h,8,eh,el);sum64$1(this.h,10,fh,fl);sum64$1(this.h,12,gh,gl);sum64$1(this.h,14,hh,hl);};SHA512.prototype._digest=function digest(enc){if(enc==='hex')return utils.toHex32(this.h,'big');else return utils.split32(this.h,'big');};function ch64_hi(xh,xl,yh,yl,zh){var r=xh&yh^~xh&zh;if(r<0)r+=0x100000000;return r;}function ch64_lo(xh,xl,yh,yl,zh,zl){var r=xl&yl^~xl&zl;if(r<0)r+=0x100000000;return r;}function maj64_hi(xh,xl,yh,yl,zh){var r=xh&yh^xh&zh^yh&zh;if(r<0)r+=0x100000000;return r;}function maj64_lo(xh,xl,yh,yl,zh,zl){var r=xl&yl^xl&zl^yl&zl;if(r<0)r+=0x100000000;return r;}function s0_512_hi(xh,xl){var c0_hi=rotr64_hi$1(xh,xl,28);var c1_hi=rotr64_hi$1(xl,xh,2);// 34\nvar c2_hi=rotr64_hi$1(xl,xh,7);// 39\nvar r=c0_hi^c1_hi^c2_hi;if(r<0)r+=0x100000000;return r;}function s0_512_lo(xh,xl){var c0_lo=rotr64_lo$1(xh,xl,28);var c1_lo=rotr64_lo$1(xl,xh,2);// 34\nvar c2_lo=rotr64_lo$1(xl,xh,7);// 39\nvar r=c0_lo^c1_lo^c2_lo;if(r<0)r+=0x100000000;return r;}function s1_512_hi(xh,xl){var c0_hi=rotr64_hi$1(xh,xl,14);var c1_hi=rotr64_hi$1(xh,xl,18);var c2_hi=rotr64_hi$1(xl,xh,9);// 41\nvar r=c0_hi^c1_hi^c2_hi;if(r<0)r+=0x100000000;return r;}function s1_512_lo(xh,xl){var c0_lo=rotr64_lo$1(xh,xl,14);var c1_lo=rotr64_lo$1(xh,xl,18);var c2_lo=rotr64_lo$1(xl,xh,9);// 41\nvar r=c0_lo^c1_lo^c2_lo;if(r<0)r+=0x100000000;return r;}function g0_512_hi(xh,xl){var c0_hi=rotr64_hi$1(xh,xl,1);var c1_hi=rotr64_hi$1(xh,xl,8);var c2_hi=shr64_hi$1(xh,xl,7);var r=c0_hi^c1_hi^c2_hi;if(r<0)r+=0x100000000;return r;}function g0_512_lo(xh,xl){var c0_lo=rotr64_lo$1(xh,xl,1);var c1_lo=rotr64_lo$1(xh,xl,8);var c2_lo=shr64_lo$1(xh,xl,7);var r=c0_lo^c1_lo^c2_lo;if(r<0)r+=0x100000000;return r;}function g1_512_hi(xh,xl){var c0_hi=rotr64_hi$1(xh,xl,19);var c1_hi=rotr64_hi$1(xl,xh,29);// 61\nvar c2_hi=shr64_hi$1(xh,xl,6);var r=c0_hi^c1_hi^c2_hi;if(r<0)r+=0x100000000;return r;}function g1_512_lo(xh,xl){var c0_lo=rotr64_lo$1(xh,xl,19);var c1_lo=rotr64_lo$1(xl,xh,29);// 61\nvar c2_lo=shr64_lo$1(xh,xl,6);var r=c0_lo^c1_lo^c2_lo;if(r<0)r+=0x100000000;return r;}'use strict';var sha1=_1;var sha224=_224;var sha256=_256;var sha384=_384;var sha512=_512;var sha={sha1:sha1,sha224:sha224,sha256:sha256,sha384:sha384,sha512:sha512};'use strict';var rotl32$1=utils.rotl32;var sum32$2=utils.sum32;var sum32_3$1=utils.sum32_3;var sum32_4$2=utils.sum32_4;var BlockHash$3=common.BlockHash;function RIPEMD160(){if(!(this instanceof RIPEMD160))return new RIPEMD160();BlockHash$3.call(this);this.h=[0x67452301,0xefcdab89,0x98badcfe,0x10325476,0xc3d2e1f0];this.endian='little';}utils.inherits(RIPEMD160,BlockHash$3);var ripemd160=RIPEMD160;RIPEMD160.blockSize=512;RIPEMD160.outSize=160;RIPEMD160.hmacStrength=192;RIPEMD160.padLength=64;RIPEMD160.prototype._update=function update(msg,start){var A=this.h[0];var B=this.h[1];var C=this.h[2];var D=this.h[3];var E=this.h[4];var Ah=A;var Bh=B;var Ch=C;var Dh=D;var Eh=E;for(var j=0;j<80;j++){var T=sum32$2(rotl32$1(sum32_4$2(A,f(j,B,C,D),msg[r[j]+start],K(j)),s[j]),E);A=E;E=D;D=rotl32$1(C,10);C=B;B=T;T=sum32$2(rotl32$1(sum32_4$2(Ah,f(79-j,Bh,Ch,Dh),msg[rh[j]+start],Kh(j)),sh[j]),Eh);Ah=Eh;Eh=Dh;Dh=rotl32$1(Ch,10);Ch=Bh;Bh=T;}T=sum32_3$1(this.h[1],C,Dh);this.h[1]=sum32_3$1(this.h[2],D,Eh);this.h[2]=sum32_3$1(this.h[3],E,Ah);this.h[3]=sum32_3$1(this.h[4],A,Bh);this.h[4]=sum32_3$1(this.h[0],B,Ch);this.h[0]=T;};RIPEMD160.prototype._digest=function digest(enc){if(enc==='hex')return utils.toHex32(this.h,'little');else return utils.split32(this.h,'little');};function f(j,x,y,z){if(j<=15)return x^y^z;else if(j<=31)return x&y|~x&z;else if(j<=47)return(x|~y)^z;else if(j<=63)return x&z|y&~z;else return x^(y|~z);}function K(j){if(j<=15)return 0x00000000;else if(j<=31)return 0x5a827999;else if(j<=47)return 0x6ed9eba1;else if(j<=63)return 0x8f1bbcdc;else return 0xa953fd4e;}function Kh(j){if(j<=15)return 0x50a28be6;else if(j<=31)return 0x5c4dd124;else if(j<=47)return 0x6d703ef3;else if(j<=63)return 0x7a6d76e9;else return 0x00000000;}var r=[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8,3,10,14,4,9,15,8,1,2,7,0,6,13,11,5,12,1,9,11,10,0,8,12,4,13,3,7,15,14,5,6,2,4,0,5,9,7,12,2,10,14,1,3,8,11,6,15,13];var rh=[5,14,7,0,9,2,11,4,13,6,15,8,1,10,3,12,6,11,3,7,0,13,5,10,14,15,8,12,4,9,1,2,15,5,1,3,7,14,6,9,11,8,12,2,10,0,4,13,8,6,4,1,3,11,15,0,5,12,2,13,9,7,10,14,12,15,10,4,1,5,8,7,6,2,13,14,0,3,9,11];var s=[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8,7,6,8,13,11,9,7,15,7,12,15,9,11,7,13,12,11,13,6,7,14,9,13,15,14,8,13,6,5,12,7,5,11,12,14,15,14,15,9,8,9,14,5,6,8,6,5,12,9,15,5,11,6,8,13,12,5,12,13,14,11,8,5,6];var sh=[8,9,9,11,13,15,15,5,7,7,8,11,14,14,12,6,9,13,15,7,12,8,9,11,7,7,12,7,6,15,13,11,9,7,15,11,8,6,6,14,12,13,5,14,13,13,7,5,15,5,8,11,14,14,6,14,6,9,12,9,12,5,15,8,8,5,12,9,12,5,14,6,8,13,6,5,15,13,11,11];var ripemd={ripemd160:ripemd160};'use strict';function Hmac(hash,key,enc){if(!(this instanceof Hmac))return new Hmac(hash,key,enc);this.Hash=hash;this.blockSize=hash.blockSize/8;this.outSize=hash.outSize/8;this.inner=null;this.outer=null;this._init(utils.toArray(key,enc));}var hmac=Hmac;Hmac.prototype._init=function init(key){// Shorten key, if needed\nif(key.length>this.blockSize)key=new this.Hash().update(key).digest();minimalisticAssert(key.length<=this.blockSize);// Add padding to key\nfor(var i=key.length;i<this.blockSize;i++){key.push(0);}for(i=0;i<key.length;i++){key[i]^=0x36;}this.inner=new this.Hash().update(key);// 0x36 ^ 0x5c = 0x6a\nfor(i=0;i<key.length;i++){key[i]^=0x6a;}this.outer=new this.Hash().update(key);};Hmac.prototype.update=function update(msg,enc){this.inner.update(msg,enc);return this;};Hmac.prototype.digest=function digest(enc){this.outer.update(this.inner.digest());return this.outer.digest(enc);};var hash_1=createCommonjsModule(function(module,exports){var hash=exports;hash.utils=utils;hash.common=common;hash.sha=sha;hash.ripemd=ripemd;hash.hmac=hmac;// Proxy hash functions to the main object\nhash.sha1=hash.sha.sha1;hash.sha256=hash.sha.sha256;hash.sha224=hash.sha.sha224;hash.sha384=hash.sha.sha384;hash.sha512=hash.sha.sha512;hash.ripemd160=hash.ripemd.ripemd160;});var hash_2=hash_1.hmac;var hash_3=hash_1.ripemd160;var hash_4=hash_1.sha256;var hash_5=hash_1.sha512;var _version$o=createCommonjsModule(function(module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});exports.version=\"sha2/5.0.2\";});var _version$p=unwrapExports(_version$o);var _version_1$c=_version$o.version;var browser=createCommonjsModule(function(module,exports){\"use strict\";var __importStar=commonjsGlobal&&commonjsGlobal.__importStar||function(mod){if(mod&&mod.__esModule)return mod;var result={};if(mod!=null)for(var k in mod){if(Object.hasOwnProperty.call(mod,k))result[k]=mod[k];}result[\"default\"]=mod;return result;};Object.defineProperty(exports,\"__esModule\",{value:true});var hash=__importStar(hash_1);var logger=new lib.Logger(_version$o.version);var SupportedAlgorithm;(function(SupportedAlgorithm){SupportedAlgorithm[\"sha256\"]=\"sha256\";SupportedAlgorithm[\"sha512\"]=\"sha512\";})(SupportedAlgorithm=exports.SupportedAlgorithm||(exports.SupportedAlgorithm={}));;function ripemd160(data){return\"0x\"+hash.ripemd160().update(lib$1.arrayify(data)).digest(\"hex\");}exports.ripemd160=ripemd160;function sha256(data){return\"0x\"+hash.sha256().update(lib$1.arrayify(data)).digest(\"hex\");}exports.sha256=sha256;function sha512(data){return\"0x\"+hash.sha512().update(lib$1.arrayify(data)).digest(\"hex\");}exports.sha512=sha512;function computeHmac(algorithm,key,data){if(!SupportedAlgorithm[algorithm]){logger.throwError(\"unsupported algorithm \"+algorithm,lib.Logger.errors.UNSUPPORTED_OPERATION,{operation:\"hmac\",algorithm:algorithm});}return\"0x\"+hash.hmac(hash[algorithm],lib$1.arrayify(key)).update(lib$1.arrayify(data)).digest(\"hex\");}exports.computeHmac=computeHmac;});var browser$1=unwrapExports(browser);var browser_1=browser.SupportedAlgorithm;var browser_2=browser.ripemd160;var browser_3=browser.sha256;var browser_4=browser.sha512;var browser_5=browser.computeHmac;var browser$2=createCommonjsModule(function(module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});function pbkdf2(password,salt,iterations,keylen,hashAlgorithm){password=lib$1.arrayify(password);salt=lib$1.arrayify(salt);var hLen;var l=1;var DK=new Uint8Array(keylen);var block1=new Uint8Array(salt.length+4);block1.set(salt);//salt.copy(block1, 0, 0, salt.length)\nvar r;var T;for(var i=1;i<=l;i++){//block1.writeUInt32BE(i, salt.length)\nblock1[salt.length]=i>>24&0xff;block1[salt.length+1]=i>>16&0xff;block1[salt.length+2]=i>>8&0xff;block1[salt.length+3]=i&0xff;//let U = createHmac(password).update(block1).digest();\nvar U=lib$1.arrayify(browser.computeHmac(hashAlgorithm,password,block1));if(!hLen){hLen=U.length;T=new Uint8Array(hLen);l=Math.ceil(keylen/hLen);r=keylen-(l-1)*hLen;}//U.copy(T, 0, 0, hLen)\nT.set(U);for(var j=1;j<iterations;j++){//U = createHmac(password).update(U).digest();\nU=lib$1.arrayify(browser.computeHmac(hashAlgorithm,password,U));for(var k=0;k<hLen;k++){T[k]^=U[k];}}var destPos=(i-1)*hLen;var len=i===l?r:hLen;//T.copy(DK, destPos, 0, len)\nDK.set(lib$1.arrayify(T).slice(0,len),destPos);}return lib$1.hexlify(DK);}exports.pbkdf2=pbkdf2;});var browser$3=unwrapExports(browser$2);var browser_1$1=browser$2.pbkdf2;var version=\"6.5.3\";var _package={version:version};var _package$1=/*#__PURE__*/Object.freeze({version:version,'default':_package});var bn$1=createCommonjsModule(function(module){(function(module,exports){'use strict';// Utils\nfunction assert(val,msg){if(!val)throw new Error(msg||'Assertion failed');}// Could use `inherits` module, but don't want to move from single file\n// architecture yet.\nfunction inherits(ctor,superCtor){ctor.super_=superCtor;var TempCtor=function TempCtor(){};TempCtor.prototype=superCtor.prototype;ctor.prototype=new TempCtor();ctor.prototype.constructor=ctor;}// BN\nfunction BN(number,base,endian){if(BN.isBN(number)){return number;}this.negative=0;this.words=null;this.length=0;// Reduction context\nthis.red=null;if(number!==null){if(base==='le'||base==='be'){endian=base;base=10;}this._init(number||0,base||10,endian||'be');}}if(_typeof(module)==='object'){module.exports=BN;}else{exports.BN=BN;}BN.BN=BN;BN.wordSize=26;var Buffer;try{Buffer=require$$0.Buffer;}catch(e){}BN.isBN=function isBN(num){if(num instanceof BN){return true;}return num!==null&&_typeof(num)==='object'&&num.constructor.wordSize===BN.wordSize&&Array.isArray(num.words);};BN.max=function max(left,right){if(left.cmp(right)>0)return left;return right;};BN.min=function min(left,right){if(left.cmp(right)<0)return left;return right;};BN.prototype._init=function init(number,base,endian){if(typeof number==='number'){return this._initNumber(number,base,endian);}if(_typeof(number)==='object'){return this._initArray(number,base,endian);}if(base==='hex'){base=16;}assert(base===(base|0)&&base>=2&&base<=36);number=number.toString().replace(/\\s+/g,'');var start=0;if(number[0]==='-'){start++;}if(base===16){this._parseHex(number,start);}else{this._parseBase(number,base,start);}if(number[0]==='-'){this.negative=1;}this.strip();if(endian!=='le')return;this._initArray(this.toArray(),base,endian);};BN.prototype._initNumber=function _initNumber(number,base,endian){if(number<0){this.negative=1;number=-number;}if(number<0x4000000){this.words=[number&0x3ffffff];this.length=1;}else if(number<0x10000000000000){this.words=[number&0x3ffffff,number/0x4000000&0x3ffffff];this.length=2;}else{assert(number<0x20000000000000);// 2 ^ 53 (unsafe)\nthis.words=[number&0x3ffffff,number/0x4000000&0x3ffffff,1];this.length=3;}if(endian!=='le')return;// Reverse the bytes\nthis._initArray(this.toArray(),base,endian);};BN.prototype._initArray=function _initArray(number,base,endian){// Perhaps a Uint8Array\nassert(typeof number.length==='number');if(number.length<=0){this.words=[0];this.length=1;return this;}this.length=Math.ceil(number.length/3);this.words=new Array(this.length);for(var i=0;i<this.length;i++){this.words[i]=0;}var j,w;var off=0;if(endian==='be'){for(i=number.length-1,j=0;i>=0;i-=3){w=number[i]|number[i-1]<<8|number[i-2]<<16;this.words[j]|=w<<off&0x3ffffff;this.words[j+1]=w>>>26-off&0x3ffffff;off+=24;if(off>=26){off-=26;j++;}}}else if(endian==='le'){for(i=0,j=0;i<number.length;i+=3){w=number[i]|number[i+1]<<8|number[i+2]<<16;this.words[j]|=w<<off&0x3ffffff;this.words[j+1]=w>>>26-off&0x3ffffff;off+=24;if(off>=26){off-=26;j++;}}}return this.strip();};function parseHex(str,start,end){var r=0;var len=Math.min(str.length,end);for(var i=start;i<len;i++){var c=str.charCodeAt(i)-48;r<<=4;// 'a' - 'f'\nif(c>=49&&c<=54){r|=c-49+0xa;// 'A' - 'F'\n}else if(c>=17&&c<=22){r|=c-17+0xa;// '0' - '9'\n}else{r|=c&0xf;}}return r;}BN.prototype._parseHex=function _parseHex(number,start){// Create possibly bigger array to ensure that it fits the number\nthis.length=Math.ceil((number.length-start)/6);this.words=new Array(this.length);for(var i=0;i<this.length;i++){this.words[i]=0;}var j,w;// Scan 24-bit chunks and add them to the number\nvar off=0;for(i=number.length-6,j=0;i>=start;i-=6){w=parseHex(number,i,i+6);this.words[j]|=w<<off&0x3ffffff;// NOTE: `0x3fffff` is intentional here, 26bits max shift + 24bit hex limb\nthis.words[j+1]|=w>>>26-off&0x3fffff;off+=24;if(off>=26){off-=26;j++;}}if(i+6!==start){w=parseHex(number,start,i+6);this.words[j]|=w<<off&0x3ffffff;this.words[j+1]|=w>>>26-off&0x3fffff;}this.strip();};function parseBase(str,start,end,mul){var r=0;var len=Math.min(str.length,end);for(var i=start;i<len;i++){var c=str.charCodeAt(i)-48;r*=mul;// 'a'\nif(c>=49){r+=c-49+0xa;// 'A'\n}else if(c>=17){r+=c-17+0xa;// '0' - '9'\n}else{r+=c;}}return r;}BN.prototype._parseBase=function _parseBase(number,base,start){// Initialize as zero\nthis.words=[0];this.length=1;// Find length of limb in base\nfor(var limbLen=0,limbPow=1;limbPow<=0x3ffffff;limbPow*=base){limbLen++;}limbLen--;limbPow=limbPow/base|0;var total=number.length-start;var mod=total%limbLen;var end=Math.min(total,total-mod)+start;var word=0;for(var i=start;i<end;i+=limbLen){word=parseBase(number,i,i+limbLen,base);this.imuln(limbPow);if(this.words[0]+word<0x4000000){this.words[0]+=word;}else{this._iaddn(word);}}if(mod!==0){var pow=1;word=parseBase(number,i,number.length,base);for(i=0;i<mod;i++){pow*=base;}this.imuln(pow);if(this.words[0]+word<0x4000000){this.words[0]+=word;}else{this._iaddn(word);}}};BN.prototype.copy=function copy(dest){dest.words=new Array(this.length);for(var i=0;i<this.length;i++){dest.words[i]=this.words[i];}dest.length=this.length;dest.negative=this.negative;dest.red=this.red;};BN.prototype.clone=function clone(){var r=new BN(null);this.copy(r);return r;};BN.prototype._expand=function _expand(size){while(this.length<size){this.words[this.length++]=0;}return this;};// Remove leading `0` from `this`\nBN.prototype.strip=function strip(){while(this.length>1&&this.words[this.length-1]===0){this.length--;}return this._normSign();};BN.prototype._normSign=function _normSign(){// -0 = 0\nif(this.length===1&&this.words[0]===0){this.negative=0;}return this;};BN.prototype.inspect=function inspect(){return(this.red?'<BN-R: ':'<BN: ')+this.toString(16)+'>';};/*\n\n\t  var zeros = [];\n\t  var groupSizes = [];\n\t  var groupBases = [];\n\n\t  var s = '';\n\t  var i = -1;\n\t  while (++i < BN.wordSize) {\n\t    zeros[i] = s;\n\t    s += '0';\n\t  }\n\t  groupSizes[0] = 0;\n\t  groupSizes[1] = 0;\n\t  groupBases[0] = 0;\n\t  groupBases[1] = 0;\n\t  var base = 2 - 1;\n\t  while (++base < 36 + 1) {\n\t    var groupSize = 0;\n\t    var groupBase = 1;\n\t    while (groupBase < (1 << BN.wordSize) / base) {\n\t      groupBase *= base;\n\t      groupSize += 1;\n\t    }\n\t    groupSizes[base] = groupSize;\n\t    groupBases[base] = groupBase;\n\t  }\n\n\t  */var zeros=['','0','00','000','0000','00000','000000','0000000','00000000','000000000','0000000000','00000000000','000000000000','0000000000000','00000000000000','000000000000000','0000000000000000','00000000000000000','000000000000000000','0000000000000000000','00000000000000000000','000000000000000000000','0000000000000000000000','00000000000000000000000','000000000000000000000000','0000000000000000000000000'];var groupSizes=[0,0,25,16,12,11,10,9,8,8,7,7,7,7,6,6,6,6,6,6,6,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5];var groupBases=[0,0,33554432,43046721,16777216,48828125,60466176,40353607,16777216,43046721,10000000,19487171,35831808,62748517,7529536,11390625,16777216,24137569,34012224,47045881,64000000,4084101,5153632,6436343,7962624,9765625,11881376,14348907,17210368,20511149,24300000,28629151,33554432,39135393,45435424,52521875,60466176];BN.prototype.toString=function toString(base,padding){base=base||10;padding=padding|0||1;var out;if(base===16||base==='hex'){out='';var off=0;var carry=0;for(var i=0;i<this.length;i++){var w=this.words[i];var word=((w<<off|carry)&0xffffff).toString(16);carry=w>>>24-off&0xffffff;if(carry!==0||i!==this.length-1){out=zeros[6-word.length]+word+out;}else{out=word+out;}off+=2;if(off>=26){off-=26;i--;}}if(carry!==0){out=carry.toString(16)+out;}while(out.length%padding!==0){out='0'+out;}if(this.negative!==0){out='-'+out;}return out;}if(base===(base|0)&&base>=2&&base<=36){// var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));\nvar groupSize=groupSizes[base];// var groupBase = Math.pow(base, groupSize);\nvar groupBase=groupBases[base];out='';var c=this.clone();c.negative=0;while(!c.isZero()){var r=c.modn(groupBase).toString(base);c=c.idivn(groupBase);if(!c.isZero()){out=zeros[groupSize-r.length]+r+out;}else{out=r+out;}}if(this.isZero()){out='0'+out;}while(out.length%padding!==0){out='0'+out;}if(this.negative!==0){out='-'+out;}return out;}assert(false,'Base should be between 2 and 36');};BN.prototype.toNumber=function toNumber(){var ret=this.words[0];if(this.length===2){ret+=this.words[1]*0x4000000;}else if(this.length===3&&this.words[2]===0x01){// NOTE: at this stage it is known that the top bit is set\nret+=0x10000000000000+this.words[1]*0x4000000;}else if(this.length>2){assert(false,'Number can only safely store up to 53 bits');}return this.negative!==0?-ret:ret;};BN.prototype.toJSON=function toJSON(){return this.toString(16);};BN.prototype.toBuffer=function toBuffer(endian,length){assert(typeof Buffer!=='undefined');return this.toArrayLike(Buffer,endian,length);};BN.prototype.toArray=function toArray(endian,length){return this.toArrayLike(Array,endian,length);};BN.prototype.toArrayLike=function toArrayLike(ArrayType,endian,length){var byteLength=this.byteLength();var reqLength=length||Math.max(1,byteLength);assert(byteLength<=reqLength,'byte array longer than desired length');assert(reqLength>0,'Requested array length <= 0');this.strip();var littleEndian=endian==='le';var res=new ArrayType(reqLength);var b,i;var q=this.clone();if(!littleEndian){// Assume big-endian\nfor(i=0;i<reqLength-byteLength;i++){res[i]=0;}for(i=0;!q.isZero();i++){b=q.andln(0xff);q.iushrn(8);res[reqLength-i-1]=b;}}else{for(i=0;!q.isZero();i++){b=q.andln(0xff);q.iushrn(8);res[i]=b;}for(;i<reqLength;i++){res[i]=0;}}return res;};if(Math.clz32){BN.prototype._countBits=function _countBits(w){return 32-Math.clz32(w);};}else{BN.prototype._countBits=function _countBits(w){var t=w;var r=0;if(t>=0x1000){r+=13;t>>>=13;}if(t>=0x40){r+=7;t>>>=7;}if(t>=0x8){r+=4;t>>>=4;}if(t>=0x02){r+=2;t>>>=2;}return r+t;};}BN.prototype._zeroBits=function _zeroBits(w){// Short-cut\nif(w===0)return 26;var t=w;var r=0;if((t&0x1fff)===0){r+=13;t>>>=13;}if((t&0x7f)===0){r+=7;t>>>=7;}if((t&0xf)===0){r+=4;t>>>=4;}if((t&0x3)===0){r+=2;t>>>=2;}if((t&0x1)===0){r++;}return r;};// Return number of used bits in a BN\nBN.prototype.bitLength=function bitLength(){var w=this.words[this.length-1];var hi=this._countBits(w);return(this.length-1)*26+hi;};function toBitArray(num){var w=new Array(num.bitLength());for(var bit=0;bit<w.length;bit++){var off=bit/26|0;var wbit=bit%26;w[bit]=(num.words[off]&1<<wbit)>>>wbit;}return w;}// Number of trailing zero bits\nBN.prototype.zeroBits=function zeroBits(){if(this.isZero())return 0;var r=0;for(var i=0;i<this.length;i++){var b=this._zeroBits(this.words[i]);r+=b;if(b!==26)break;}return r;};BN.prototype.byteLength=function byteLength(){return Math.ceil(this.bitLength()/8);};BN.prototype.toTwos=function toTwos(width){if(this.negative!==0){return this.abs().inotn(width).iaddn(1);}return this.clone();};BN.prototype.fromTwos=function fromTwos(width){if(this.testn(width-1)){return this.notn(width).iaddn(1).ineg();}return this.clone();};BN.prototype.isNeg=function isNeg(){return this.negative!==0;};// Return negative clone of `this`\nBN.prototype.neg=function neg(){return this.clone().ineg();};BN.prototype.ineg=function ineg(){if(!this.isZero()){this.negative^=1;}return this;};// Or `num` with `this` in-place\nBN.prototype.iuor=function iuor(num){while(this.length<num.length){this.words[this.length++]=0;}for(var i=0;i<num.length;i++){this.words[i]=this.words[i]|num.words[i];}return this.strip();};BN.prototype.ior=function ior(num){assert((this.negative|num.negative)===0);return this.iuor(num);};// Or `num` with `this`\nBN.prototype.or=function or(num){if(this.length>num.length)return this.clone().ior(num);return num.clone().ior(this);};BN.prototype.uor=function uor(num){if(this.length>num.length)return this.clone().iuor(num);return num.clone().iuor(this);};// And `num` with `this` in-place\nBN.prototype.iuand=function iuand(num){// b = min-length(num, this)\nvar b;if(this.length>num.length){b=num;}else{b=this;}for(var i=0;i<b.length;i++){this.words[i]=this.words[i]&num.words[i];}this.length=b.length;return this.strip();};BN.prototype.iand=function iand(num){assert((this.negative|num.negative)===0);return this.iuand(num);};// And `num` with `this`\nBN.prototype.and=function and(num){if(this.length>num.length)return this.clone().iand(num);return num.clone().iand(this);};BN.prototype.uand=function uand(num){if(this.length>num.length)return this.clone().iuand(num);return num.clone().iuand(this);};// Xor `num` with `this` in-place\nBN.prototype.iuxor=function iuxor(num){// a.length > b.length\nvar a;var b;if(this.length>num.length){a=this;b=num;}else{a=num;b=this;}for(var i=0;i<b.length;i++){this.words[i]=a.words[i]^b.words[i];}if(this!==a){for(;i<a.length;i++){this.words[i]=a.words[i];}}this.length=a.length;return this.strip();};BN.prototype.ixor=function ixor(num){assert((this.negative|num.negative)===0);return this.iuxor(num);};// Xor `num` with `this`\nBN.prototype.xor=function xor(num){if(this.length>num.length)return this.clone().ixor(num);return num.clone().ixor(this);};BN.prototype.uxor=function uxor(num){if(this.length>num.length)return this.clone().iuxor(num);return num.clone().iuxor(this);};// Not ``this`` with ``width`` bitwidth\nBN.prototype.inotn=function inotn(width){assert(typeof width==='number'&&width>=0);var bytesNeeded=Math.ceil(width/26)|0;var bitsLeft=width%26;// Extend the buffer with leading zeroes\nthis._expand(bytesNeeded);if(bitsLeft>0){bytesNeeded--;}// Handle complete words\nfor(var i=0;i<bytesNeeded;i++){this.words[i]=~this.words[i]&0x3ffffff;}// Handle the residue\nif(bitsLeft>0){this.words[i]=~this.words[i]&0x3ffffff>>26-bitsLeft;}// And remove leading zeroes\nreturn this.strip();};BN.prototype.notn=function notn(width){return this.clone().inotn(width);};// Set `bit` of `this`\nBN.prototype.setn=function setn(bit,val){assert(typeof bit==='number'&&bit>=0);var off=bit/26|0;var wbit=bit%26;this._expand(off+1);if(val){this.words[off]=this.words[off]|1<<wbit;}else{this.words[off]=this.words[off]&~(1<<wbit);}return this.strip();};// Add `num` to `this` in-place\nBN.prototype.iadd=function iadd(num){var r;// negative + positive\nif(this.negative!==0&&num.negative===0){this.negative=0;r=this.isub(num);this.negative^=1;return this._normSign();// positive + negative\n}else if(this.negative===0&&num.negative!==0){num.negative=0;r=this.isub(num);num.negative=1;return r._normSign();}// a.length > b.length\nvar a,b;if(this.length>num.length){a=this;b=num;}else{a=num;b=this;}var carry=0;for(var i=0;i<b.length;i++){r=(a.words[i]|0)+(b.words[i]|0)+carry;this.words[i]=r&0x3ffffff;carry=r>>>26;}for(;carry!==0&&i<a.length;i++){r=(a.words[i]|0)+carry;this.words[i]=r&0x3ffffff;carry=r>>>26;}this.length=a.length;if(carry!==0){this.words[this.length]=carry;this.length++;// Copy the rest of the words\n}else if(a!==this){for(;i<a.length;i++){this.words[i]=a.words[i];}}return this;};// Add `num` to `this`\nBN.prototype.add=function add(num){var res;if(num.negative!==0&&this.negative===0){num.negative=0;res=this.sub(num);num.negative^=1;return res;}else if(num.negative===0&&this.negative!==0){this.negative=0;res=num.sub(this);this.negative=1;return res;}if(this.length>num.length)return this.clone().iadd(num);return num.clone().iadd(this);};// Subtract `num` from `this` in-place\nBN.prototype.isub=function isub(num){// this - (-num) = this + num\nif(num.negative!==0){num.negative=0;var r=this.iadd(num);num.negative=1;return r._normSign();// -this - num = -(this + num)\n}else if(this.negative!==0){this.negative=0;this.iadd(num);this.negative=1;return this._normSign();}// At this point both numbers are positive\nvar cmp=this.cmp(num);// Optimization - zeroify\nif(cmp===0){this.negative=0;this.length=1;this.words[0]=0;return this;}// a > b\nvar a,b;if(cmp>0){a=this;b=num;}else{a=num;b=this;}var carry=0;for(var i=0;i<b.length;i++){r=(a.words[i]|0)-(b.words[i]|0)+carry;carry=r>>26;this.words[i]=r&0x3ffffff;}for(;carry!==0&&i<a.length;i++){r=(a.words[i]|0)+carry;carry=r>>26;this.words[i]=r&0x3ffffff;}// Copy rest of the words\nif(carry===0&&i<a.length&&a!==this){for(;i<a.length;i++){this.words[i]=a.words[i];}}this.length=Math.max(this.length,i);if(a!==this){this.negative=1;}return this.strip();};// Subtract `num` from `this`\nBN.prototype.sub=function sub(num){return this.clone().isub(num);};function smallMulTo(self,num,out){out.negative=num.negative^self.negative;var len=self.length+num.length|0;out.length=len;len=len-1|0;// Peel one iteration (compiler can't do it, because of code complexity)\nvar a=self.words[0]|0;var b=num.words[0]|0;var r=a*b;var lo=r&0x3ffffff;var carry=r/0x4000000|0;out.words[0]=lo;for(var k=1;k<len;k++){// Sum all words with the same `i + j = k` and accumulate `ncarry`,\n// note that ncarry could be >= 0x3ffffff\nvar ncarry=carry>>>26;var rword=carry&0x3ffffff;var maxJ=Math.min(k,num.length-1);for(var j=Math.max(0,k-self.length+1);j<=maxJ;j++){var i=k-j|0;a=self.words[i]|0;b=num.words[j]|0;r=a*b+rword;ncarry+=r/0x4000000|0;rword=r&0x3ffffff;}out.words[k]=rword|0;carry=ncarry|0;}if(carry!==0){out.words[k]=carry|0;}else{out.length--;}return out.strip();}// TODO(indutny): it may be reasonable to omit it for users who don't need\n// to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit\n// multiplication (like elliptic secp256k1).\nvar comb10MulTo=function comb10MulTo(self,num,out){var a=self.words;var b=num.words;var o=out.words;var c=0;var lo;var mid;var hi;var a0=a[0]|0;var al0=a0&0x1fff;var ah0=a0>>>13;var a1=a[1]|0;var al1=a1&0x1fff;var ah1=a1>>>13;var a2=a[2]|0;var al2=a2&0x1fff;var ah2=a2>>>13;var a3=a[3]|0;var al3=a3&0x1fff;var ah3=a3>>>13;var a4=a[4]|0;var al4=a4&0x1fff;var ah4=a4>>>13;var a5=a[5]|0;var al5=a5&0x1fff;var ah5=a5>>>13;var a6=a[6]|0;var al6=a6&0x1fff;var ah6=a6>>>13;var a7=a[7]|0;var al7=a7&0x1fff;var ah7=a7>>>13;var a8=a[8]|0;var al8=a8&0x1fff;var ah8=a8>>>13;var a9=a[9]|0;var al9=a9&0x1fff;var ah9=a9>>>13;var b0=b[0]|0;var bl0=b0&0x1fff;var bh0=b0>>>13;var b1=b[1]|0;var bl1=b1&0x1fff;var bh1=b1>>>13;var b2=b[2]|0;var bl2=b2&0x1fff;var bh2=b2>>>13;var b3=b[3]|0;var bl3=b3&0x1fff;var bh3=b3>>>13;var b4=b[4]|0;var bl4=b4&0x1fff;var bh4=b4>>>13;var b5=b[5]|0;var bl5=b5&0x1fff;var bh5=b5>>>13;var b6=b[6]|0;var bl6=b6&0x1fff;var bh6=b6>>>13;var b7=b[7]|0;var bl7=b7&0x1fff;var bh7=b7>>>13;var b8=b[8]|0;var bl8=b8&0x1fff;var bh8=b8>>>13;var b9=b[9]|0;var bl9=b9&0x1fff;var bh9=b9>>>13;out.negative=self.negative^num.negative;out.length=19;/* k = 0 */lo=Math.imul(al0,bl0);mid=Math.imul(al0,bh0);mid=mid+Math.imul(ah0,bl0)|0;hi=Math.imul(ah0,bh0);var w0=(c+lo|0)+((mid&0x1fff)<<13)|0;c=(hi+(mid>>>13)|0)+(w0>>>26)|0;w0&=0x3ffffff;/* k = 1 */lo=Math.imul(al1,bl0);mid=Math.imul(al1,bh0);mid=mid+Math.imul(ah1,bl0)|0;hi=Math.imul(ah1,bh0);lo=lo+Math.imul(al0,bl1)|0;mid=mid+Math.imul(al0,bh1)|0;mid=mid+Math.imul(ah0,bl1)|0;hi=hi+Math.imul(ah0,bh1)|0;var w1=(c+lo|0)+((mid&0x1fff)<<13)|0;c=(hi+(mid>>>13)|0)+(w1>>>26)|0;w1&=0x3ffffff;/* k = 2 */lo=Math.imul(al2,bl0);mid=Math.imul(al2,bh0);mid=mid+Math.imul(ah2,bl0)|0;hi=Math.imul(ah2,bh0);lo=lo+Math.imul(al1,bl1)|0;mid=mid+Math.imul(al1,bh1)|0;mid=mid+Math.imul(ah1,bl1)|0;hi=hi+Math.imul(ah1,bh1)|0;lo=lo+Math.imul(al0,bl2)|0;mid=mid+Math.imul(al0,bh2)|0;mid=mid+Math.imul(ah0,bl2)|0;hi=hi+Math.imul(ah0,bh2)|0;var w2=(c+lo|0)+((mid&0x1fff)<<13)|0;c=(hi+(mid>>>13)|0)+(w2>>>26)|0;w2&=0x3ffffff;/* k = 3 */lo=Math.imul(al3,bl0);mid=Math.imul(al3,bh0);mid=mid+Math.imul(ah3,bl0)|0;hi=Math.imul(ah3,bh0);lo=lo+Math.imul(al2,bl1)|0;mid=mid+Math.imul(al2,bh1)|0;mid=mid+Math.imul(ah2,bl1)|0;hi=hi+Math.imul(ah2,bh1)|0;lo=lo+Math.imul(al1,bl2)|0;mid=mid+Math.imul(al1,bh2)|0;mid=mid+Math.imul(ah1,bl2)|0;hi=hi+Math.imul(ah1,bh2)|0;lo=lo+Math.imul(al0,bl3)|0;mid=mid+Math.imul(al0,bh3)|0;mid=mid+Math.imul(ah0,bl3)|0;hi=hi+Math.imul(ah0,bh3)|0;var w3=(c+lo|0)+((mid&0x1fff)<<13)|0;c=(hi+(mid>>>13)|0)+(w3>>>26)|0;w3&=0x3ffffff;/* k = 4 */lo=Math.imul(al4,bl0);mid=Math.imul(al4,bh0);mid=mid+Math.imul(ah4,bl0)|0;hi=Math.imul(ah4,bh0);lo=lo+Math.imul(al3,bl1)|0;mid=mid+Math.imul(al3,bh1)|0;mid=mid+Math.imul(ah3,bl1)|0;hi=hi+Math.imul(ah3,bh1)|0;lo=lo+Math.imul(al2,bl2)|0;mid=mid+Math.imul(al2,bh2)|0;mid=mid+Math.imul(ah2,bl2)|0;hi=hi+Math.imul(ah2,bh2)|0;lo=lo+Math.imul(al1,bl3)|0;mid=mid+Math.imul(al1,bh3)|0;mid=mid+Math.imul(ah1,bl3)|0;hi=hi+Math.imul(ah1,bh3)|0;lo=lo+Math.imul(al0,bl4)|0;mid=mid+Math.imul(al0,bh4)|0;mid=mid+Math.imul(ah0,bl4)|0;hi=hi+Math.imul(ah0,bh4)|0;var w4=(c+lo|0)+((mid&0x1fff)<<13)|0;c=(hi+(mid>>>13)|0)+(w4>>>26)|0;w4&=0x3ffffff;/* k = 5 */lo=Math.imul(al5,bl0);mid=Math.imul(al5,bh0);mid=mid+Math.imul(ah5,bl0)|0;hi=Math.imul(ah5,bh0);lo=lo+Math.imul(al4,bl1)|0;mid=mid+Math.imul(al4,bh1)|0;mid=mid+Math.imul(ah4,bl1)|0;hi=hi+Math.imul(ah4,bh1)|0;lo=lo+Math.imul(al3,bl2)|0;mid=mid+Math.imul(al3,bh2)|0;mid=mid+Math.imul(ah3,bl2)|0;hi=hi+Math.imul(ah3,bh2)|0;lo=lo+Math.imul(al2,bl3)|0;mid=mid+Math.imul(al2,bh3)|0;mid=mid+Math.imul(ah2,bl3)|0;hi=hi+Math.imul(ah2,bh3)|0;lo=lo+Math.imul(al1,bl4)|0;mid=mid+Math.imul(al1,bh4)|0;mid=mid+Math.imul(ah1,bl4)|0;hi=hi+Math.imul(ah1,bh4)|0;lo=lo+Math.imul(al0,bl5)|0;mid=mid+Math.imul(al0,bh5)|0;mid=mid+Math.imul(ah0,bl5)|0;hi=hi+Math.imul(ah0,bh5)|0;var w5=(c+lo|0)+((mid&0x1fff)<<13)|0;c=(hi+(mid>>>13)|0)+(w5>>>26)|0;w5&=0x3ffffff;/* k = 6 */lo=Math.imul(al6,bl0);mid=Math.imul(al6,bh0);mid=mid+Math.imul(ah6,bl0)|0;hi=Math.imul(ah6,bh0);lo=lo+Math.imul(al5,bl1)|0;mid=mid+Math.imul(al5,bh1)|0;mid=mid+Math.imul(ah5,bl1)|0;hi=hi+Math.imul(ah5,bh1)|0;lo=lo+Math.imul(al4,bl2)|0;mid=mid+Math.imul(al4,bh2)|0;mid=mid+Math.imul(ah4,bl2)|0;hi=hi+Math.imul(ah4,bh2)|0;lo=lo+Math.imul(al3,bl3)|0;mid=mid+Math.imul(al3,bh3)|0;mid=mid+Math.imul(ah3,bl3)|0;hi=hi+Math.imul(ah3,bh3)|0;lo=lo+Math.imul(al2,bl4)|0;mid=mid+Math.imul(al2,bh4)|0;mid=mid+Math.imul(ah2,bl4)|0;hi=hi+Math.imul(ah2,bh4)|0;lo=lo+Math.imul(al1,bl5)|0;mid=mid+Math.imul(al1,bh5)|0;mid=mid+Math.imul(ah1,bl5)|0;hi=hi+Math.imul(ah1,bh5)|0;lo=lo+Math.imul(al0,bl6)|0;mid=mid+Math.imul(al0,bh6)|0;mid=mid+Math.imul(ah0,bl6)|0;hi=hi+Math.imul(ah0,bh6)|0;var w6=(c+lo|0)+((mid&0x1fff)<<13)|0;c=(hi+(mid>>>13)|0)+(w6>>>26)|0;w6&=0x3ffffff;/* k = 7 */lo=Math.imul(al7,bl0);mid=Math.imul(al7,bh0);mid=mid+Math.imul(ah7,bl0)|0;hi=Math.imul(ah7,bh0);lo=lo+Math.imul(al6,bl1)|0;mid=mid+Math.imul(al6,bh1)|0;mid=mid+Math.imul(ah6,bl1)|0;hi=hi+Math.imul(ah6,bh1)|0;lo=lo+Math.imul(al5,bl2)|0;mid=mid+Math.imul(al5,bh2)|0;mid=mid+Math.imul(ah5,bl2)|0;hi=hi+Math.imul(ah5,bh2)|0;lo=lo+Math.imul(al4,bl3)|0;mid=mid+Math.imul(al4,bh3)|0;mid=mid+Math.imul(ah4,bl3)|0;hi=hi+Math.imul(ah4,bh3)|0;lo=lo+Math.imul(al3,bl4)|0;mid=mid+Math.imul(al3,bh4)|0;mid=mid+Math.imul(ah3,bl4)|0;hi=hi+Math.imul(ah3,bh4)|0;lo=lo+Math.imul(al2,bl5)|0;mid=mid+Math.imul(al2,bh5)|0;mid=mid+Math.imul(ah2,bl5)|0;hi=hi+Math.imul(ah2,bh5)|0;lo=lo+Math.imul(al1,bl6)|0;mid=mid+Math.imul(al1,bh6)|0;mid=mid+Math.imul(ah1,bl6)|0;hi=hi+Math.imul(ah1,bh6)|0;lo=lo+Math.imul(al0,bl7)|0;mid=mid+Math.imul(al0,bh7)|0;mid=mid+Math.imul(ah0,bl7)|0;hi=hi+Math.imul(ah0,bh7)|0;var w7=(c+lo|0)+((mid&0x1fff)<<13)|0;c=(hi+(mid>>>13)|0)+(w7>>>26)|0;w7&=0x3ffffff;/* k = 8 */lo=Math.imul(al8,bl0);mid=Math.imul(al8,bh0);mid=mid+Math.imul(ah8,bl0)|0;hi=Math.imul(ah8,bh0);lo=lo+Math.imul(al7,bl1)|0;mid=mid+Math.imul(al7,bh1)|0;mid=mid+Math.imul(ah7,bl1)|0;hi=hi+Math.imul(ah7,bh1)|0;lo=lo+Math.imul(al6,bl2)|0;mid=mid+Math.imul(al6,bh2)|0;mid=mid+Math.imul(ah6,bl2)|0;hi=hi+Math.imul(ah6,bh2)|0;lo=lo+Math.imul(al5,bl3)|0;mid=mid+Math.imul(al5,bh3)|0;mid=mid+Math.imul(ah5,bl3)|0;hi=hi+Math.imul(ah5,bh3)|0;lo=lo+Math.imul(al4,bl4)|0;mid=mid+Math.imul(al4,bh4)|0;mid=mid+Math.imul(ah4,bl4)|0;hi=hi+Math.imul(ah4,bh4)|0;lo=lo+Math.imul(al3,bl5)|0;mid=mid+Math.imul(al3,bh5)|0;mid=mid+Math.imul(ah3,bl5)|0;hi=hi+Math.imul(ah3,bh5)|0;lo=lo+Math.imul(al2,bl6)|0;mid=mid+Math.imul(al2,bh6)|0;mid=mid+Math.imul(ah2,bl6)|0;hi=hi+Math.imul(ah2,bh6)|0;lo=lo+Math.imul(al1,bl7)|0;mid=mid+Math.imul(al1,bh7)|0;mid=mid+Math.imul(ah1,bl7)|0;hi=hi+Math.imul(ah1,bh7)|0;lo=lo+Math.imul(al0,bl8)|0;mid=mid+Math.imul(al0,bh8)|0;mid=mid+Math.imul(ah0,bl8)|0;hi=hi+Math.imul(ah0,bh8)|0;var w8=(c+lo|0)+((mid&0x1fff)<<13)|0;c=(hi+(mid>>>13)|0)+(w8>>>26)|0;w8&=0x3ffffff;/* k = 9 */lo=Math.imul(al9,bl0);mid=Math.imul(al9,bh0);mid=mid+Math.imul(ah9,bl0)|0;hi=Math.imul(ah9,bh0);lo=lo+Math.imul(al8,bl1)|0;mid=mid+Math.imul(al8,bh1)|0;mid=mid+Math.imul(ah8,bl1)|0;hi=hi+Math.imul(ah8,bh1)|0;lo=lo+Math.imul(al7,bl2)|0;mid=mid+Math.imul(al7,bh2)|0;mid=mid+Math.imul(ah7,bl2)|0;hi=hi+Math.imul(ah7,bh2)|0;lo=lo+Math.imul(al6,bl3)|0;mid=mid+Math.imul(al6,bh3)|0;mid=mid+Math.imul(ah6,bl3)|0;hi=hi+Math.imul(ah6,bh3)|0;lo=lo+Math.imul(al5,bl4)|0;mid=mid+Math.imul(al5,bh4)|0;mid=mid+Math.imul(ah5,bl4)|0;hi=hi+Math.imul(ah5,bh4)|0;lo=lo+Math.imul(al4,bl5)|0;mid=mid+Math.imul(al4,bh5)|0;mid=mid+Math.imul(ah4,bl5)|0;hi=hi+Math.imul(ah4,bh5)|0;lo=lo+Math.imul(al3,bl6)|0;mid=mid+Math.imul(al3,bh6)|0;mid=mid+Math.imul(ah3,bl6)|0;hi=hi+Math.imul(ah3,bh6)|0;lo=lo+Math.imul(al2,bl7)|0;mid=mid+Math.imul(al2,bh7)|0;mid=mid+Math.imul(ah2,bl7)|0;hi=hi+Math.imul(ah2,bh7)|0;lo=lo+Math.imul(al1,bl8)|0;mid=mid+Math.imul(al1,bh8)|0;mid=mid+Math.imul(ah1,bl8)|0;hi=hi+Math.imul(ah1,bh8)|0;lo=lo+Math.imul(al0,bl9)|0;mid=mid+Math.imul(al0,bh9)|0;mid=mid+Math.imul(ah0,bl9)|0;hi=hi+Math.imul(ah0,bh9)|0;var w9=(c+lo|0)+((mid&0x1fff)<<13)|0;c=(hi+(mid>>>13)|0)+(w9>>>26)|0;w9&=0x3ffffff;/* k = 10 */lo=Math.imul(al9,bl1);mid=Math.imul(al9,bh1);mid=mid+Math.imul(ah9,bl1)|0;hi=Math.imul(ah9,bh1);lo=lo+Math.imul(al8,bl2)|0;mid=mid+Math.imul(al8,bh2)|0;mid=mid+Math.imul(ah8,bl2)|0;hi=hi+Math.imul(ah8,bh2)|0;lo=lo+Math.imul(al7,bl3)|0;mid=mid+Math.imul(al7,bh3)|0;mid=mid+Math.imul(ah7,bl3)|0;hi=hi+Math.imul(ah7,bh3)|0;lo=lo+Math.imul(al6,bl4)|0;mid=mid+Math.imul(al6,bh4)|0;mid=mid+Math.imul(ah6,bl4)|0;hi=hi+Math.imul(ah6,bh4)|0;lo=lo+Math.imul(al5,bl5)|0;mid=mid+Math.imul(al5,bh5)|0;mid=mid+Math.imul(ah5,bl5)|0;hi=hi+Math.imul(ah5,bh5)|0;lo=lo+Math.imul(al4,bl6)|0;mid=mid+Math.imul(al4,bh6)|0;mid=mid+Math.imul(ah4,bl6)|0;hi=hi+Math.imul(ah4,bh6)|0;lo=lo+Math.imul(al3,bl7)|0;mid=mid+Math.imul(al3,bh7)|0;mid=mid+Math.imul(ah3,bl7)|0;hi=hi+Math.imul(ah3,bh7)|0;lo=lo+Math.imul(al2,bl8)|0;mid=mid+Math.imul(al2,bh8)|0;mid=mid+Math.imul(ah2,bl8)|0;hi=hi+Math.imul(ah2,bh8)|0;lo=lo+Math.imul(al1,bl9)|0;mid=mid+Math.imul(al1,bh9)|0;mid=mid+Math.imul(ah1,bl9)|0;hi=hi+Math.imul(ah1,bh9)|0;var w10=(c+lo|0)+((mid&0x1fff)<<13)|0;c=(hi+(mid>>>13)|0)+(w10>>>26)|0;w10&=0x3ffffff;/* k = 11 */lo=Math.imul(al9,bl2);mid=Math.imul(al9,bh2);mid=mid+Math.imul(ah9,bl2)|0;hi=Math.imul(ah9,bh2);lo=lo+Math.imul(al8,bl3)|0;mid=mid+Math.imul(al8,bh3)|0;mid=mid+Math.imul(ah8,bl3)|0;hi=hi+Math.imul(ah8,bh3)|0;lo=lo+Math.imul(al7,bl4)|0;mid=mid+Math.imul(al7,bh4)|0;mid=mid+Math.imul(ah7,bl4)|0;hi=hi+Math.imul(ah7,bh4)|0;lo=lo+Math.imul(al6,bl5)|0;mid=mid+Math.imul(al6,bh5)|0;mid=mid+Math.imul(ah6,bl5)|0;hi=hi+Math.imul(ah6,bh5)|0;lo=lo+Math.imul(al5,bl6)|0;mid=mid+Math.imul(al5,bh6)|0;mid=mid+Math.imul(ah5,bl6)|0;hi=hi+Math.imul(ah5,bh6)|0;lo=lo+Math.imul(al4,bl7)|0;mid=mid+Math.imul(al4,bh7)|0;mid=mid+Math.imul(ah4,bl7)|0;hi=hi+Math.imul(ah4,bh7)|0;lo=lo+Math.imul(al3,bl8)|0;mid=mid+Math.imul(al3,bh8)|0;mid=mid+Math.imul(ah3,bl8)|0;hi=hi+Math.imul(ah3,bh8)|0;lo=lo+Math.imul(al2,bl9)|0;mid=mid+Math.imul(al2,bh9)|0;mid=mid+Math.imul(ah2,bl9)|0;hi=hi+Math.imul(ah2,bh9)|0;var w11=(c+lo|0)+((mid&0x1fff)<<13)|0;c=(hi+(mid>>>13)|0)+(w11>>>26)|0;w11&=0x3ffffff;/* k = 12 */lo=Math.imul(al9,bl3);mid=Math.imul(al9,bh3);mid=mid+Math.imul(ah9,bl3)|0;hi=Math.imul(ah9,bh3);lo=lo+Math.imul(al8,bl4)|0;mid=mid+Math.imul(al8,bh4)|0;mid=mid+Math.imul(ah8,bl4)|0;hi=hi+Math.imul(ah8,bh4)|0;lo=lo+Math.imul(al7,bl5)|0;mid=mid+Math.imul(al7,bh5)|0;mid=mid+Math.imul(ah7,bl5)|0;hi=hi+Math.imul(ah7,bh5)|0;lo=lo+Math.imul(al6,bl6)|0;mid=mid+Math.imul(al6,bh6)|0;mid=mid+Math.imul(ah6,bl6)|0;hi=hi+Math.imul(ah6,bh6)|0;lo=lo+Math.imul(al5,bl7)|0;mid=mid+Math.imul(al5,bh7)|0;mid=mid+Math.imul(ah5,bl7)|0;hi=hi+Math.imul(ah5,bh7)|0;lo=lo+Math.imul(al4,bl8)|0;mid=mid+Math.imul(al4,bh8)|0;mid=mid+Math.imul(ah4,bl8)|0;hi=hi+Math.imul(ah4,bh8)|0;lo=lo+Math.imul(al3,bl9)|0;mid=mid+Math.imul(al3,bh9)|0;mid=mid+Math.imul(ah3,bl9)|0;hi=hi+Math.imul(ah3,bh9)|0;var w12=(c+lo|0)+((mid&0x1fff)<<13)|0;c=(hi+(mid>>>13)|0)+(w12>>>26)|0;w12&=0x3ffffff;/* k = 13 */lo=Math.imul(al9,bl4);mid=Math.imul(al9,bh4);mid=mid+Math.imul(ah9,bl4)|0;hi=Math.imul(ah9,bh4);lo=lo+Math.imul(al8,bl5)|0;mid=mid+Math.imul(al8,bh5)|0;mid=mid+Math.imul(ah8,bl5)|0;hi=hi+Math.imul(ah8,bh5)|0;lo=lo+Math.imul(al7,bl6)|0;mid=mid+Math.imul(al7,bh6)|0;mid=mid+Math.imul(ah7,bl6)|0;hi=hi+Math.imul(ah7,bh6)|0;lo=lo+Math.imul(al6,bl7)|0;mid=mid+Math.imul(al6,bh7)|0;mid=mid+Math.imul(ah6,bl7)|0;hi=hi+Math.imul(ah6,bh7)|0;lo=lo+Math.imul(al5,bl8)|0;mid=mid+Math.imul(al5,bh8)|0;mid=mid+Math.imul(ah5,bl8)|0;hi=hi+Math.imul(ah5,bh8)|0;lo=lo+Math.imul(al4,bl9)|0;mid=mid+Math.imul(al4,bh9)|0;mid=mid+Math.imul(ah4,bl9)|0;hi=hi+Math.imul(ah4,bh9)|0;var w13=(c+lo|0)+((mid&0x1fff)<<13)|0;c=(hi+(mid>>>13)|0)+(w13>>>26)|0;w13&=0x3ffffff;/* k = 14 */lo=Math.imul(al9,bl5);mid=Math.imul(al9,bh5);mid=mid+Math.imul(ah9,bl5)|0;hi=Math.imul(ah9,bh5);lo=lo+Math.imul(al8,bl6)|0;mid=mid+Math.imul(al8,bh6)|0;mid=mid+Math.imul(ah8,bl6)|0;hi=hi+Math.imul(ah8,bh6)|0;lo=lo+Math.imul(al7,bl7)|0;mid=mid+Math.imul(al7,bh7)|0;mid=mid+Math.imul(ah7,bl7)|0;hi=hi+Math.imul(ah7,bh7)|0;lo=lo+Math.imul(al6,bl8)|0;mid=mid+Math.imul(al6,bh8)|0;mid=mid+Math.imul(ah6,bl8)|0;hi=hi+Math.imul(ah6,bh8)|0;lo=lo+Math.imul(al5,bl9)|0;mid=mid+Math.imul(al5,bh9)|0;mid=mid+Math.imul(ah5,bl9)|0;hi=hi+Math.imul(ah5,bh9)|0;var w14=(c+lo|0)+((mid&0x1fff)<<13)|0;c=(hi+(mid>>>13)|0)+(w14>>>26)|0;w14&=0x3ffffff;/* k = 15 */lo=Math.imul(al9,bl6);mid=Math.imul(al9,bh6);mid=mid+Math.imul(ah9,bl6)|0;hi=Math.imul(ah9,bh6);lo=lo+Math.imul(al8,bl7)|0;mid=mid+Math.imul(al8,bh7)|0;mid=mid+Math.imul(ah8,bl7)|0;hi=hi+Math.imul(ah8,bh7)|0;lo=lo+Math.imul(al7,bl8)|0;mid=mid+Math.imul(al7,bh8)|0;mid=mid+Math.imul(ah7,bl8)|0;hi=hi+Math.imul(ah7,bh8)|0;lo=lo+Math.imul(al6,bl9)|0;mid=mid+Math.imul(al6,bh9)|0;mid=mid+Math.imul(ah6,bl9)|0;hi=hi+Math.imul(ah6,bh9)|0;var w15=(c+lo|0)+((mid&0x1fff)<<13)|0;c=(hi+(mid>>>13)|0)+(w15>>>26)|0;w15&=0x3ffffff;/* k = 16 */lo=Math.imul(al9,bl7);mid=Math.imul(al9,bh7);mid=mid+Math.imul(ah9,bl7)|0;hi=Math.imul(ah9,bh7);lo=lo+Math.imul(al8,bl8)|0;mid=mid+Math.imul(al8,bh8)|0;mid=mid+Math.imul(ah8,bl8)|0;hi=hi+Math.imul(ah8,bh8)|0;lo=lo+Math.imul(al7,bl9)|0;mid=mid+Math.imul(al7,bh9)|0;mid=mid+Math.imul(ah7,bl9)|0;hi=hi+Math.imul(ah7,bh9)|0;var w16=(c+lo|0)+((mid&0x1fff)<<13)|0;c=(hi+(mid>>>13)|0)+(w16>>>26)|0;w16&=0x3ffffff;/* k = 17 */lo=Math.imul(al9,bl8);mid=Math.imul(al9,bh8);mid=mid+Math.imul(ah9,bl8)|0;hi=Math.imul(ah9,bh8);lo=lo+Math.imul(al8,bl9)|0;mid=mid+Math.imul(al8,bh9)|0;mid=mid+Math.imul(ah8,bl9)|0;hi=hi+Math.imul(ah8,bh9)|0;var w17=(c+lo|0)+((mid&0x1fff)<<13)|0;c=(hi+(mid>>>13)|0)+(w17>>>26)|0;w17&=0x3ffffff;/* k = 18 */lo=Math.imul(al9,bl9);mid=Math.imul(al9,bh9);mid=mid+Math.imul(ah9,bl9)|0;hi=Math.imul(ah9,bh9);var w18=(c+lo|0)+((mid&0x1fff)<<13)|0;c=(hi+(mid>>>13)|0)+(w18>>>26)|0;w18&=0x3ffffff;o[0]=w0;o[1]=w1;o[2]=w2;o[3]=w3;o[4]=w4;o[5]=w5;o[6]=w6;o[7]=w7;o[8]=w8;o[9]=w9;o[10]=w10;o[11]=w11;o[12]=w12;o[13]=w13;o[14]=w14;o[15]=w15;o[16]=w16;o[17]=w17;o[18]=w18;if(c!==0){o[19]=c;out.length++;}return out;};// Polyfill comb\nif(!Math.imul){comb10MulTo=smallMulTo;}function bigMulTo(self,num,out){out.negative=num.negative^self.negative;out.length=self.length+num.length;var carry=0;var hncarry=0;for(var k=0;k<out.length-1;k++){// Sum all words with the same `i + j = k` and accumulate `ncarry`,\n// note that ncarry could be >= 0x3ffffff\nvar ncarry=hncarry;hncarry=0;var rword=carry&0x3ffffff;var maxJ=Math.min(k,num.length-1);for(var j=Math.max(0,k-self.length+1);j<=maxJ;j++){var i=k-j;var a=self.words[i]|0;var b=num.words[j]|0;var r=a*b;var lo=r&0x3ffffff;ncarry=ncarry+(r/0x4000000|0)|0;lo=lo+rword|0;rword=lo&0x3ffffff;ncarry=ncarry+(lo>>>26)|0;hncarry+=ncarry>>>26;ncarry&=0x3ffffff;}out.words[k]=rword;carry=ncarry;ncarry=hncarry;}if(carry!==0){out.words[k]=carry;}else{out.length--;}return out.strip();}function jumboMulTo(self,num,out){var fftm=new FFTM();return fftm.mulp(self,num,out);}BN.prototype.mulTo=function mulTo(num,out){var res;var len=this.length+num.length;if(this.length===10&&num.length===10){res=comb10MulTo(this,num,out);}else if(len<63){res=smallMulTo(this,num,out);}else if(len<1024){res=bigMulTo(this,num,out);}else{res=jumboMulTo(this,num,out);}return res;};// Cooley-Tukey algorithm for FFT\n// slightly revisited to rely on looping instead of recursion\nfunction FFTM(x,y){this.x=x;this.y=y;}FFTM.prototype.makeRBT=function makeRBT(N){var t=new Array(N);var l=BN.prototype._countBits(N)-1;for(var i=0;i<N;i++){t[i]=this.revBin(i,l,N);}return t;};// Returns binary-reversed representation of `x`\nFFTM.prototype.revBin=function revBin(x,l,N){if(x===0||x===N-1)return x;var rb=0;for(var i=0;i<l;i++){rb|=(x&1)<<l-i-1;x>>=1;}return rb;};// Performs \"tweedling\" phase, therefore 'emulating'\n// behaviour of the recursive algorithm\nFFTM.prototype.permute=function permute(rbt,rws,iws,rtws,itws,N){for(var i=0;i<N;i++){rtws[i]=rws[rbt[i]];itws[i]=iws[rbt[i]];}};FFTM.prototype.transform=function transform(rws,iws,rtws,itws,N,rbt){this.permute(rbt,rws,iws,rtws,itws,N);for(var s=1;s<N;s<<=1){var l=s<<1;var rtwdf=Math.cos(2*Math.PI/l);var itwdf=Math.sin(2*Math.PI/l);for(var p=0;p<N;p+=l){var rtwdf_=rtwdf;var itwdf_=itwdf;for(var j=0;j<s;j++){var re=rtws[p+j];var ie=itws[p+j];var ro=rtws[p+j+s];var io=itws[p+j+s];var rx=rtwdf_*ro-itwdf_*io;io=rtwdf_*io+itwdf_*ro;ro=rx;rtws[p+j]=re+ro;itws[p+j]=ie+io;rtws[p+j+s]=re-ro;itws[p+j+s]=ie-io;/* jshint maxdepth : false */if(j!==l){rx=rtwdf*rtwdf_-itwdf*itwdf_;itwdf_=rtwdf*itwdf_+itwdf*rtwdf_;rtwdf_=rx;}}}}};FFTM.prototype.guessLen13b=function guessLen13b(n,m){var N=Math.max(m,n)|1;var odd=N&1;var i=0;for(N=N/2|0;N;N=N>>>1){i++;}return 1<<i+1+odd;};FFTM.prototype.conjugate=function conjugate(rws,iws,N){if(N<=1)return;for(var i=0;i<N/2;i++){var t=rws[i];rws[i]=rws[N-i-1];rws[N-i-1]=t;t=iws[i];iws[i]=-iws[N-i-1];iws[N-i-1]=-t;}};FFTM.prototype.normalize13b=function normalize13b(ws,N){var carry=0;for(var i=0;i<N/2;i++){var w=Math.round(ws[2*i+1]/N)*0x2000+Math.round(ws[2*i]/N)+carry;ws[i]=w&0x3ffffff;if(w<0x4000000){carry=0;}else{carry=w/0x4000000|0;}}return ws;};FFTM.prototype.convert13b=function convert13b(ws,len,rws,N){var carry=0;for(var i=0;i<len;i++){carry=carry+(ws[i]|0);rws[2*i]=carry&0x1fff;carry=carry>>>13;rws[2*i+1]=carry&0x1fff;carry=carry>>>13;}// Pad with zeroes\nfor(i=2*len;i<N;++i){rws[i]=0;}assert(carry===0);assert((carry&~0x1fff)===0);};FFTM.prototype.stub=function stub(N){var ph=new Array(N);for(var i=0;i<N;i++){ph[i]=0;}return ph;};FFTM.prototype.mulp=function mulp(x,y,out){var N=2*this.guessLen13b(x.length,y.length);var rbt=this.makeRBT(N);var _=this.stub(N);var rws=new Array(N);var rwst=new Array(N);var iwst=new Array(N);var nrws=new Array(N);var nrwst=new Array(N);var niwst=new Array(N);var rmws=out.words;rmws.length=N;this.convert13b(x.words,x.length,rws,N);this.convert13b(y.words,y.length,nrws,N);this.transform(rws,_,rwst,iwst,N,rbt);this.transform(nrws,_,nrwst,niwst,N,rbt);for(var i=0;i<N;i++){var rx=rwst[i]*nrwst[i]-iwst[i]*niwst[i];iwst[i]=rwst[i]*niwst[i]+iwst[i]*nrwst[i];rwst[i]=rx;}this.conjugate(rwst,iwst,N);this.transform(rwst,iwst,rmws,_,N,rbt);this.conjugate(rmws,_,N);this.normalize13b(rmws,N);out.negative=x.negative^y.negative;out.length=x.length+y.length;return out.strip();};// Multiply `this` by `num`\nBN.prototype.mul=function mul(num){var out=new BN(null);out.words=new Array(this.length+num.length);return this.mulTo(num,out);};// Multiply employing FFT\nBN.prototype.mulf=function mulf(num){var out=new BN(null);out.words=new Array(this.length+num.length);return jumboMulTo(this,num,out);};// In-place Multiplication\nBN.prototype.imul=function imul(num){return this.clone().mulTo(num,this);};BN.prototype.imuln=function imuln(num){assert(typeof num==='number');assert(num<0x4000000);// Carry\nvar carry=0;for(var i=0;i<this.length;i++){var w=(this.words[i]|0)*num;var lo=(w&0x3ffffff)+(carry&0x3ffffff);carry>>=26;carry+=w/0x4000000|0;// NOTE: lo is 27bit maximum\ncarry+=lo>>>26;this.words[i]=lo&0x3ffffff;}if(carry!==0){this.words[i]=carry;this.length++;}return this;};BN.prototype.muln=function muln(num){return this.clone().imuln(num);};// `this` * `this`\nBN.prototype.sqr=function sqr(){return this.mul(this);};// `this` * `this` in-place\nBN.prototype.isqr=function isqr(){return this.imul(this.clone());};// Math.pow(`this`, `num`)\nBN.prototype.pow=function pow(num){var w=toBitArray(num);if(w.length===0)return new BN(1);// Skip leading zeroes\nvar res=this;for(var i=0;i<w.length;i++,res=res.sqr()){if(w[i]!==0)break;}if(++i<w.length){for(var q=res.sqr();i<w.length;i++,q=q.sqr()){if(w[i]===0)continue;res=res.mul(q);}}return res;};// Shift-left in-place\nBN.prototype.iushln=function iushln(bits){assert(typeof bits==='number'&&bits>=0);var r=bits%26;var s=(bits-r)/26;var carryMask=0x3ffffff>>>26-r<<26-r;var i;if(r!==0){var carry=0;for(i=0;i<this.length;i++){var newCarry=this.words[i]&carryMask;var c=(this.words[i]|0)-newCarry<<r;this.words[i]=c|carry;carry=newCarry>>>26-r;}if(carry){this.words[i]=carry;this.length++;}}if(s!==0){for(i=this.length-1;i>=0;i--){this.words[i+s]=this.words[i];}for(i=0;i<s;i++){this.words[i]=0;}this.length+=s;}return this.strip();};BN.prototype.ishln=function ishln(bits){// TODO(indutny): implement me\nassert(this.negative===0);return this.iushln(bits);};// Shift-right in-place\n// NOTE: `hint` is a lowest bit before trailing zeroes\n// NOTE: if `extended` is present - it will be filled with destroyed bits\nBN.prototype.iushrn=function iushrn(bits,hint,extended){assert(typeof bits==='number'&&bits>=0);var h;if(hint){h=(hint-hint%26)/26;}else{h=0;}var r=bits%26;var s=Math.min((bits-r)/26,this.length);var mask=0x3ffffff^0x3ffffff>>>r<<r;var maskedWords=extended;h-=s;h=Math.max(0,h);// Extended mode, copy masked part\nif(maskedWords){for(var i=0;i<s;i++){maskedWords.words[i]=this.words[i];}maskedWords.length=s;}if(s===0){// No-op, we should not move anything at all\n}else if(this.length>s){this.length-=s;for(i=0;i<this.length;i++){this.words[i]=this.words[i+s];}}else{this.words[0]=0;this.length=1;}var carry=0;for(i=this.length-1;i>=0&&(carry!==0||i>=h);i--){var word=this.words[i]|0;this.words[i]=carry<<26-r|word>>>r;carry=word&mask;}// Push carried bits as a mask\nif(maskedWords&&carry!==0){maskedWords.words[maskedWords.length++]=carry;}if(this.length===0){this.words[0]=0;this.length=1;}return this.strip();};BN.prototype.ishrn=function ishrn(bits,hint,extended){// TODO(indutny): implement me\nassert(this.negative===0);return this.iushrn(bits,hint,extended);};// Shift-left\nBN.prototype.shln=function shln(bits){return this.clone().ishln(bits);};BN.prototype.ushln=function ushln(bits){return this.clone().iushln(bits);};// Shift-right\nBN.prototype.shrn=function shrn(bits){return this.clone().ishrn(bits);};BN.prototype.ushrn=function ushrn(bits){return this.clone().iushrn(bits);};// Test if n bit is set\nBN.prototype.testn=function testn(bit){assert(typeof bit==='number'&&bit>=0);var r=bit%26;var s=(bit-r)/26;var q=1<<r;// Fast case: bit is much higher than all existing words\nif(this.length<=s)return false;// Check bit and return\nvar w=this.words[s];return!!(w&q);};// Return only lowers bits of number (in-place)\nBN.prototype.imaskn=function imaskn(bits){assert(typeof bits==='number'&&bits>=0);var r=bits%26;var s=(bits-r)/26;assert(this.negative===0,'imaskn works only with positive numbers');if(this.length<=s){return this;}if(r!==0){s++;}this.length=Math.min(s,this.length);if(r!==0){var mask=0x3ffffff^0x3ffffff>>>r<<r;this.words[this.length-1]&=mask;}return this.strip();};// Return only lowers bits of number\nBN.prototype.maskn=function maskn(bits){return this.clone().imaskn(bits);};// Add plain number `num` to `this`\nBN.prototype.iaddn=function iaddn(num){assert(typeof num==='number');assert(num<0x4000000);if(num<0)return this.isubn(-num);// Possible sign change\nif(this.negative!==0){if(this.length===1&&(this.words[0]|0)<num){this.words[0]=num-(this.words[0]|0);this.negative=0;return this;}this.negative=0;this.isubn(num);this.negative=1;return this;}// Add without checks\nreturn this._iaddn(num);};BN.prototype._iaddn=function _iaddn(num){this.words[0]+=num;// Carry\nfor(var i=0;i<this.length&&this.words[i]>=0x4000000;i++){this.words[i]-=0x4000000;if(i===this.length-1){this.words[i+1]=1;}else{this.words[i+1]++;}}this.length=Math.max(this.length,i+1);return this;};// Subtract plain number `num` from `this`\nBN.prototype.isubn=function isubn(num){assert(typeof num==='number');assert(num<0x4000000);if(num<0)return this.iaddn(-num);if(this.negative!==0){this.negative=0;this.iaddn(num);this.negative=1;return this;}this.words[0]-=num;if(this.length===1&&this.words[0]<0){this.words[0]=-this.words[0];this.negative=1;}else{// Carry\nfor(var i=0;i<this.length&&this.words[i]<0;i++){this.words[i]+=0x4000000;this.words[i+1]-=1;}}return this.strip();};BN.prototype.addn=function addn(num){return this.clone().iaddn(num);};BN.prototype.subn=function subn(num){return this.clone().isubn(num);};BN.prototype.iabs=function iabs(){this.negative=0;return this;};BN.prototype.abs=function abs(){return this.clone().iabs();};BN.prototype._ishlnsubmul=function _ishlnsubmul(num,mul,shift){var len=num.length+shift;var i;this._expand(len);var w;var carry=0;for(i=0;i<num.length;i++){w=(this.words[i+shift]|0)+carry;var right=(num.words[i]|0)*mul;w-=right&0x3ffffff;carry=(w>>26)-(right/0x4000000|0);this.words[i+shift]=w&0x3ffffff;}for(;i<this.length-shift;i++){w=(this.words[i+shift]|0)+carry;carry=w>>26;this.words[i+shift]=w&0x3ffffff;}if(carry===0)return this.strip();// Subtraction overflow\nassert(carry===-1);carry=0;for(i=0;i<this.length;i++){w=-(this.words[i]|0)+carry;carry=w>>26;this.words[i]=w&0x3ffffff;}this.negative=1;return this.strip();};BN.prototype._wordDiv=function _wordDiv(num,mode){var shift=this.length-num.length;var a=this.clone();var b=num;// Normalize\nvar bhi=b.words[b.length-1]|0;var bhiBits=this._countBits(bhi);shift=26-bhiBits;if(shift!==0){b=b.ushln(shift);a.iushln(shift);bhi=b.words[b.length-1]|0;}// Initialize quotient\nvar m=a.length-b.length;var q;if(mode!=='mod'){q=new BN(null);q.length=m+1;q.words=new Array(q.length);for(var i=0;i<q.length;i++){q.words[i]=0;}}var diff=a.clone()._ishlnsubmul(b,1,m);if(diff.negative===0){a=diff;if(q){q.words[m]=1;}}for(var j=m-1;j>=0;j--){var qj=(a.words[b.length+j]|0)*0x4000000+(a.words[b.length+j-1]|0);// NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max\n// (0x7ffffff)\nqj=Math.min(qj/bhi|0,0x3ffffff);a._ishlnsubmul(b,qj,j);while(a.negative!==0){qj--;a.negative=0;a._ishlnsubmul(b,1,j);if(!a.isZero()){a.negative^=1;}}if(q){q.words[j]=qj;}}if(q){q.strip();}a.strip();// Denormalize\nif(mode!=='div'&&shift!==0){a.iushrn(shift);}return{div:q||null,mod:a};};// NOTE: 1) `mode` can be set to `mod` to request mod only,\n//       to `div` to request div only, or be absent to\n//       request both div & mod\n//       2) `positive` is true if unsigned mod is requested\nBN.prototype.divmod=function divmod(num,mode,positive){assert(!num.isZero());if(this.isZero()){return{div:new BN(0),mod:new BN(0)};}var div,mod,res;if(this.negative!==0&&num.negative===0){res=this.neg().divmod(num,mode);if(mode!=='mod'){div=res.div.neg();}if(mode!=='div'){mod=res.mod.neg();if(positive&&mod.negative!==0){mod.iadd(num);}}return{div:div,mod:mod};}if(this.negative===0&&num.negative!==0){res=this.divmod(num.neg(),mode);if(mode!=='mod'){div=res.div.neg();}return{div:div,mod:res.mod};}if((this.negative&num.negative)!==0){res=this.neg().divmod(num.neg(),mode);if(mode!=='div'){mod=res.mod.neg();if(positive&&mod.negative!==0){mod.isub(num);}}return{div:res.div,mod:mod};}// Both numbers are positive at this point\n// Strip both numbers to approximate shift value\nif(num.length>this.length||this.cmp(num)<0){return{div:new BN(0),mod:this};}// Very short reduction\nif(num.length===1){if(mode==='div'){return{div:this.divn(num.words[0]),mod:null};}if(mode==='mod'){return{div:null,mod:new BN(this.modn(num.words[0]))};}return{div:this.divn(num.words[0]),mod:new BN(this.modn(num.words[0]))};}return this._wordDiv(num,mode);};// Find `this` / `num`\nBN.prototype.div=function div(num){return this.divmod(num,'div',false).div;};// Find `this` % `num`\nBN.prototype.mod=function mod(num){return this.divmod(num,'mod',false).mod;};BN.prototype.umod=function umod(num){return this.divmod(num,'mod',true).mod;};// Find Round(`this` / `num`)\nBN.prototype.divRound=function divRound(num){var dm=this.divmod(num);// Fast case - exact division\nif(dm.mod.isZero())return dm.div;var mod=dm.div.negative!==0?dm.mod.isub(num):dm.mod;var half=num.ushrn(1);var r2=num.andln(1);var cmp=mod.cmp(half);// Round down\nif(cmp<0||r2===1&&cmp===0)return dm.div;// Round up\nreturn dm.div.negative!==0?dm.div.isubn(1):dm.div.iaddn(1);};BN.prototype.modn=function modn(num){assert(num<=0x3ffffff);var p=(1<<26)%num;var acc=0;for(var i=this.length-1;i>=0;i--){acc=(p*acc+(this.words[i]|0))%num;}return acc;};// In-place division by number\nBN.prototype.idivn=function idivn(num){assert(num<=0x3ffffff);var carry=0;for(var i=this.length-1;i>=0;i--){var w=(this.words[i]|0)+carry*0x4000000;this.words[i]=w/num|0;carry=w%num;}return this.strip();};BN.prototype.divn=function divn(num){return this.clone().idivn(num);};BN.prototype.egcd=function egcd(p){assert(p.negative===0);assert(!p.isZero());var x=this;var y=p.clone();if(x.negative!==0){x=x.umod(p);}else{x=x.clone();}// A * x + B * y = x\nvar A=new BN(1);var B=new BN(0);// C * x + D * y = y\nvar C=new BN(0);var D=new BN(1);var g=0;while(x.isEven()&&y.isEven()){x.iushrn(1);y.iushrn(1);++g;}var yp=y.clone();var xp=x.clone();while(!x.isZero()){for(var i=0,im=1;(x.words[0]&im)===0&&i<26;++i,im<<=1){;}if(i>0){x.iushrn(i);while(i-->0){if(A.isOdd()||B.isOdd()){A.iadd(yp);B.isub(xp);}A.iushrn(1);B.iushrn(1);}}for(var j=0,jm=1;(y.words[0]&jm)===0&&j<26;++j,jm<<=1){;}if(j>0){y.iushrn(j);while(j-->0){if(C.isOdd()||D.isOdd()){C.iadd(yp);D.isub(xp);}C.iushrn(1);D.iushrn(1);}}if(x.cmp(y)>=0){x.isub(y);A.isub(C);B.isub(D);}else{y.isub(x);C.isub(A);D.isub(B);}}return{a:C,b:D,gcd:y.iushln(g)};};// This is reduced incarnation of the binary EEA\n// above, designated to invert members of the\n// _prime_ fields F(p) at a maximal speed\nBN.prototype._invmp=function _invmp(p){assert(p.negative===0);assert(!p.isZero());var a=this;var b=p.clone();if(a.negative!==0){a=a.umod(p);}else{a=a.clone();}var x1=new BN(1);var x2=new BN(0);var delta=b.clone();while(a.cmpn(1)>0&&b.cmpn(1)>0){for(var i=0,im=1;(a.words[0]&im)===0&&i<26;++i,im<<=1){;}if(i>0){a.iushrn(i);while(i-->0){if(x1.isOdd()){x1.iadd(delta);}x1.iushrn(1);}}for(var j=0,jm=1;(b.words[0]&jm)===0&&j<26;++j,jm<<=1){;}if(j>0){b.iushrn(j);while(j-->0){if(x2.isOdd()){x2.iadd(delta);}x2.iushrn(1);}}if(a.cmp(b)>=0){a.isub(b);x1.isub(x2);}else{b.isub(a);x2.isub(x1);}}var res;if(a.cmpn(1)===0){res=x1;}else{res=x2;}if(res.cmpn(0)<0){res.iadd(p);}return res;};BN.prototype.gcd=function gcd(num){if(this.isZero())return num.abs();if(num.isZero())return this.abs();var a=this.clone();var b=num.clone();a.negative=0;b.negative=0;// Remove common factor of two\nfor(var shift=0;a.isEven()&&b.isEven();shift++){a.iushrn(1);b.iushrn(1);}do{while(a.isEven()){a.iushrn(1);}while(b.isEven()){b.iushrn(1);}var r=a.cmp(b);if(r<0){// Swap `a` and `b` to make `a` always bigger than `b`\nvar t=a;a=b;b=t;}else if(r===0||b.cmpn(1)===0){break;}a.isub(b);}while(true);return b.iushln(shift);};// Invert number in the field F(num)\nBN.prototype.invm=function invm(num){return this.egcd(num).a.umod(num);};BN.prototype.isEven=function isEven(){return(this.words[0]&1)===0;};BN.prototype.isOdd=function isOdd(){return(this.words[0]&1)===1;};// And first word and num\nBN.prototype.andln=function andln(num){return this.words[0]&num;};// Increment at the bit position in-line\nBN.prototype.bincn=function bincn(bit){assert(typeof bit==='number');var r=bit%26;var s=(bit-r)/26;var q=1<<r;// Fast case: bit is much higher than all existing words\nif(this.length<=s){this._expand(s+1);this.words[s]|=q;return this;}// Add bit and propagate, if needed\nvar carry=q;for(var i=s;carry!==0&&i<this.length;i++){var w=this.words[i]|0;w+=carry;carry=w>>>26;w&=0x3ffffff;this.words[i]=w;}if(carry!==0){this.words[i]=carry;this.length++;}return this;};BN.prototype.isZero=function isZero(){return this.length===1&&this.words[0]===0;};BN.prototype.cmpn=function cmpn(num){var negative=num<0;if(this.negative!==0&&!negative)return-1;if(this.negative===0&&negative)return 1;this.strip();var res;if(this.length>1){res=1;}else{if(negative){num=-num;}assert(num<=0x3ffffff,'Number is too big');var w=this.words[0]|0;res=w===num?0:w<num?-1:1;}if(this.negative!==0)return-res|0;return res;};// Compare two numbers and return:\n// 1 - if `this` > `num`\n// 0 - if `this` == `num`\n// -1 - if `this` < `num`\nBN.prototype.cmp=function cmp(num){if(this.negative!==0&&num.negative===0)return-1;if(this.negative===0&&num.negative!==0)return 1;var res=this.ucmp(num);if(this.negative!==0)return-res|0;return res;};// Unsigned comparison\nBN.prototype.ucmp=function ucmp(num){// At this point both numbers have the same sign\nif(this.length>num.length)return 1;if(this.length<num.length)return-1;var res=0;for(var i=this.length-1;i>=0;i--){var a=this.words[i]|0;var b=num.words[i]|0;if(a===b)continue;if(a<b){res=-1;}else if(a>b){res=1;}break;}return res;};BN.prototype.gtn=function gtn(num){return this.cmpn(num)===1;};BN.prototype.gt=function gt(num){return this.cmp(num)===1;};BN.prototype.gten=function gten(num){return this.cmpn(num)>=0;};BN.prototype.gte=function gte(num){return this.cmp(num)>=0;};BN.prototype.ltn=function ltn(num){return this.cmpn(num)===-1;};BN.prototype.lt=function lt(num){return this.cmp(num)===-1;};BN.prototype.lten=function lten(num){return this.cmpn(num)<=0;};BN.prototype.lte=function lte(num){return this.cmp(num)<=0;};BN.prototype.eqn=function eqn(num){return this.cmpn(num)===0;};BN.prototype.eq=function eq(num){return this.cmp(num)===0;};//\n// A reduce context, could be using montgomery or something better, depending\n// on the `m` itself.\n//\nBN.red=function red(num){return new Red(num);};BN.prototype.toRed=function toRed(ctx){assert(!this.red,'Already a number in reduction context');assert(this.negative===0,'red works only with positives');return ctx.convertTo(this)._forceRed(ctx);};BN.prototype.fromRed=function fromRed(){assert(this.red,'fromRed works only with numbers in reduction context');return this.red.convertFrom(this);};BN.prototype._forceRed=function _forceRed(ctx){this.red=ctx;return this;};BN.prototype.forceRed=function forceRed(ctx){assert(!this.red,'Already a number in reduction context');return this._forceRed(ctx);};BN.prototype.redAdd=function redAdd(num){assert(this.red,'redAdd works only with red numbers');return this.red.add(this,num);};BN.prototype.redIAdd=function redIAdd(num){assert(this.red,'redIAdd works only with red numbers');return this.red.iadd(this,num);};BN.prototype.redSub=function redSub(num){assert(this.red,'redSub works only with red numbers');return this.red.sub(this,num);};BN.prototype.redISub=function redISub(num){assert(this.red,'redISub works only with red numbers');return this.red.isub(this,num);};BN.prototype.redShl=function redShl(num){assert(this.red,'redShl works only with red numbers');return this.red.shl(this,num);};BN.prototype.redMul=function redMul(num){assert(this.red,'redMul works only with red numbers');this.red._verify2(this,num);return this.red.mul(this,num);};BN.prototype.redIMul=function redIMul(num){assert(this.red,'redMul works only with red numbers');this.red._verify2(this,num);return this.red.imul(this,num);};BN.prototype.redSqr=function redSqr(){assert(this.red,'redSqr works only with red numbers');this.red._verify1(this);return this.red.sqr(this);};BN.prototype.redISqr=function redISqr(){assert(this.red,'redISqr works only with red numbers');this.red._verify1(this);return this.red.isqr(this);};// Square root over p\nBN.prototype.redSqrt=function redSqrt(){assert(this.red,'redSqrt works only with red numbers');this.red._verify1(this);return this.red.sqrt(this);};BN.prototype.redInvm=function redInvm(){assert(this.red,'redInvm works only with red numbers');this.red._verify1(this);return this.red.invm(this);};// Return negative clone of `this` % `red modulo`\nBN.prototype.redNeg=function redNeg(){assert(this.red,'redNeg works only with red numbers');this.red._verify1(this);return this.red.neg(this);};BN.prototype.redPow=function redPow(num){assert(this.red&&!num.red,'redPow(normalNum)');this.red._verify1(this);return this.red.pow(this,num);};// Prime numbers with efficient reduction\nvar primes={k256:null,p224:null,p192:null,p25519:null};// Pseudo-Mersenne prime\nfunction MPrime(name,p){// P = 2 ^ N - K\nthis.name=name;this.p=new BN(p,16);this.n=this.p.bitLength();this.k=new BN(1).iushln(this.n).isub(this.p);this.tmp=this._tmp();}MPrime.prototype._tmp=function _tmp(){var tmp=new BN(null);tmp.words=new Array(Math.ceil(this.n/13));return tmp;};MPrime.prototype.ireduce=function ireduce(num){// Assumes that `num` is less than `P^2`\n// num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)\nvar r=num;var rlen;do{this.split(r,this.tmp);r=this.imulK(r);r=r.iadd(this.tmp);rlen=r.bitLength();}while(rlen>this.n);var cmp=rlen<this.n?-1:r.ucmp(this.p);if(cmp===0){r.words[0]=0;r.length=1;}else if(cmp>0){r.isub(this.p);}else{if(r.strip!==undefined){// r is BN v4 instance\nr.strip();}else{// r is BN v5 instance\nr._strip();}}return r;};MPrime.prototype.split=function split(input,out){input.iushrn(this.n,0,out);};MPrime.prototype.imulK=function imulK(num){return num.imul(this.k);};function K256(){MPrime.call(this,'k256','ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');}inherits(K256,MPrime);K256.prototype.split=function split(input,output){// 256 = 9 * 26 + 22\nvar mask=0x3fffff;var outLen=Math.min(input.length,9);for(var i=0;i<outLen;i++){output.words[i]=input.words[i];}output.length=outLen;if(input.length<=9){input.words[0]=0;input.length=1;return;}// Shift by 9 limbs\nvar prev=input.words[9];output.words[output.length++]=prev&mask;for(i=10;i<input.length;i++){var next=input.words[i]|0;input.words[i-10]=(next&mask)<<4|prev>>>22;prev=next;}prev>>>=22;input.words[i-10]=prev;if(prev===0&&input.length>10){input.length-=10;}else{input.length-=9;}};K256.prototype.imulK=function imulK(num){// K = 0x1000003d1 = [ 0x40, 0x3d1 ]\nnum.words[num.length]=0;num.words[num.length+1]=0;num.length+=2;// bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390\nvar lo=0;for(var i=0;i<num.length;i++){var w=num.words[i]|0;lo+=w*0x3d1;num.words[i]=lo&0x3ffffff;lo=w*0x40+(lo/0x4000000|0);}// Fast length reduction\nif(num.words[num.length-1]===0){num.length--;if(num.words[num.length-1]===0){num.length--;}}return num;};function P224(){MPrime.call(this,'p224','ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');}inherits(P224,MPrime);function P192(){MPrime.call(this,'p192','ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');}inherits(P192,MPrime);function P25519(){// 2 ^ 255 - 19\nMPrime.call(this,'25519','7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');}inherits(P25519,MPrime);P25519.prototype.imulK=function imulK(num){// K = 0x13\nvar carry=0;for(var i=0;i<num.length;i++){var hi=(num.words[i]|0)*0x13+carry;var lo=hi&0x3ffffff;hi>>>=26;num.words[i]=lo;carry=hi;}if(carry!==0){num.words[num.length++]=carry;}return num;};// Exported mostly for testing purposes, use plain name instead\nBN._prime=function prime(name){// Cached version of prime\nif(primes[name])return primes[name];var prime;if(name==='k256'){prime=new K256();}else if(name==='p224'){prime=new P224();}else if(name==='p192'){prime=new P192();}else if(name==='p25519'){prime=new P25519();}else{throw new Error('Unknown prime '+name);}primes[name]=prime;return prime;};//\n// Base reduction engine\n//\nfunction Red(m){if(typeof m==='string'){var prime=BN._prime(m);this.m=prime.p;this.prime=prime;}else{assert(m.gtn(1),'modulus must be greater than 1');this.m=m;this.prime=null;}}Red.prototype._verify1=function _verify1(a){assert(a.negative===0,'red works only with positives');assert(a.red,'red works only with red numbers');};Red.prototype._verify2=function _verify2(a,b){assert((a.negative|b.negative)===0,'red works only with positives');assert(a.red&&a.red===b.red,'red works only with red numbers');};Red.prototype.imod=function imod(a){if(this.prime)return this.prime.ireduce(a)._forceRed(this);return a.umod(this.m)._forceRed(this);};Red.prototype.neg=function neg(a){if(a.isZero()){return a.clone();}return this.m.sub(a)._forceRed(this);};Red.prototype.add=function add(a,b){this._verify2(a,b);var res=a.add(b);if(res.cmp(this.m)>=0){res.isub(this.m);}return res._forceRed(this);};Red.prototype.iadd=function iadd(a,b){this._verify2(a,b);var res=a.iadd(b);if(res.cmp(this.m)>=0){res.isub(this.m);}return res;};Red.prototype.sub=function sub(a,b){this._verify2(a,b);var res=a.sub(b);if(res.cmpn(0)<0){res.iadd(this.m);}return res._forceRed(this);};Red.prototype.isub=function isub(a,b){this._verify2(a,b);var res=a.isub(b);if(res.cmpn(0)<0){res.iadd(this.m);}return res;};Red.prototype.shl=function shl(a,num){this._verify1(a);return this.imod(a.ushln(num));};Red.prototype.imul=function imul(a,b){this._verify2(a,b);return this.imod(a.imul(b));};Red.prototype.mul=function mul(a,b){this._verify2(a,b);return this.imod(a.mul(b));};Red.prototype.isqr=function isqr(a){return this.imul(a,a.clone());};Red.prototype.sqr=function sqr(a){return this.mul(a,a);};Red.prototype.sqrt=function sqrt(a){if(a.isZero())return a.clone();var mod3=this.m.andln(3);assert(mod3%2===1);// Fast case\nif(mod3===3){var pow=this.m.add(new BN(1)).iushrn(2);return this.pow(a,pow);}// Tonelli-Shanks algorithm (Totally unoptimized and slow)\n//\n// Find Q and S, that Q * 2 ^ S = (P - 1)\nvar q=this.m.subn(1);var s=0;while(!q.isZero()&&q.andln(1)===0){s++;q.iushrn(1);}assert(!q.isZero());var one=new BN(1).toRed(this);var nOne=one.redNeg();// Find quadratic non-residue\n// NOTE: Max is such because of generalized Riemann hypothesis.\nvar lpow=this.m.subn(1).iushrn(1);var z=this.m.bitLength();z=new BN(2*z*z).toRed(this);while(this.pow(z,lpow).cmp(nOne)!==0){z.redIAdd(nOne);}var c=this.pow(z,q);var r=this.pow(a,q.addn(1).iushrn(1));var t=this.pow(a,q);var m=s;while(t.cmp(one)!==0){var tmp=t;for(var i=0;tmp.cmp(one)!==0;i++){tmp=tmp.redSqr();}assert(i<m);var b=this.pow(c,new BN(1).iushln(m-i-1));r=r.redMul(b);c=b.redSqr();t=t.redMul(c);m=i;}return r;};Red.prototype.invm=function invm(a){var inv=a._invmp(this.m);if(inv.negative!==0){inv.negative=0;return this.imod(inv).redNeg();}else{return this.imod(inv);}};Red.prototype.pow=function pow(a,num){if(num.isZero())return new BN(1).toRed(this);if(num.cmpn(1)===0)return a.clone();var windowSize=4;var wnd=new Array(1<<windowSize);wnd[0]=new BN(1).toRed(this);wnd[1]=a;for(var i=2;i<wnd.length;i++){wnd[i]=this.mul(wnd[i-1],a);}var res=wnd[0];var current=0;var currentLen=0;var start=num.bitLength()%26;if(start===0){start=26;}for(i=num.length-1;i>=0;i--){var word=num.words[i];for(var j=start-1;j>=0;j--){var bit=word>>j&1;if(res!==wnd[0]){res=this.sqr(res);}if(bit===0&&current===0){currentLen=0;continue;}current<<=1;current|=bit;currentLen++;if(currentLen!==windowSize&&(i!==0||j!==0))continue;res=this.mul(res,wnd[current]);currentLen=0;current=0;}start=26;}return res;};Red.prototype.convertTo=function convertTo(num){var r=num.umod(this.m);return r===num?r.clone():r;};Red.prototype.convertFrom=function convertFrom(num){var res=num.clone();res.red=null;return res;};//\n// Montgomery method engine\n//\nBN.mont=function mont(num){return new Mont(num);};function Mont(m){Red.call(this,m);this.shift=this.m.bitLength();if(this.shift%26!==0){this.shift+=26-this.shift%26;}this.r=new BN(1).iushln(this.shift);this.r2=this.imod(this.r.sqr());this.rinv=this.r._invmp(this.m);this.minv=this.rinv.mul(this.r).isubn(1).div(this.m);this.minv=this.minv.umod(this.r);this.minv=this.r.sub(this.minv);}inherits(Mont,Red);Mont.prototype.convertTo=function convertTo(num){return this.imod(num.ushln(this.shift));};Mont.prototype.convertFrom=function convertFrom(num){var r=this.imod(num.mul(this.rinv));r.red=null;return r;};Mont.prototype.imul=function imul(a,b){if(a.isZero()||b.isZero()){a.words[0]=0;a.length=1;return a;}var t=a.imul(b);var c=t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);var u=t.isub(c).iushrn(this.shift);var res=u;if(u.cmp(this.m)>=0){res=u.isub(this.m);}else if(u.cmpn(0)<0){res=u.iadd(this.m);}return res._forceRed(this);};Mont.prototype.mul=function mul(a,b){if(a.isZero()||b.isZero())return new BN(0)._forceRed(this);var t=a.mul(b);var c=t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);var u=t.isub(c).iushrn(this.shift);var res=u;if(u.cmp(this.m)>=0){res=u.isub(this.m);}else if(u.cmpn(0)<0){res=u.iadd(this.m);}return res._forceRed(this);};Mont.prototype.invm=function invm(a){// (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R\nvar res=this.imod(a._invmp(this.m).mul(this.r2));return res._forceRed(this);};})( false||module,commonjsGlobal);});var utils_1=createCommonjsModule(function(module,exports){'use strict';var utils=exports;function toArray(msg,enc){if(Array.isArray(msg))return msg.slice();if(!msg)return[];var res=[];if(typeof msg!=='string'){for(var i=0;i<msg.length;i++){res[i]=msg[i]|0;}return res;}if(enc==='hex'){msg=msg.replace(/[^a-z0-9]+/ig,'');if(msg.length%2!==0)msg='0'+msg;for(var i=0;i<msg.length;i+=2){res.push(parseInt(msg[i]+msg[i+1],16));}}else{for(var i=0;i<msg.length;i++){var c=msg.charCodeAt(i);var hi=c>>8;var lo=c&0xff;if(hi)res.push(hi,lo);else res.push(lo);}}return res;}utils.toArray=toArray;function zero2(word){if(word.length===1)return'0'+word;else return word;}utils.zero2=zero2;function toHex(msg){var res='';for(var i=0;i<msg.length;i++){res+=zero2(msg[i].toString(16));}return res;}utils.toHex=toHex;utils.encode=function encode(arr,enc){if(enc==='hex')return toHex(arr);else return arr;};});var utils_1$1=createCommonjsModule(function(module,exports){'use strict';var utils=exports;utils.assert=minimalisticAssert;utils.toArray=utils_1.toArray;utils.zero2=utils_1.zero2;utils.toHex=utils_1.toHex;utils.encode=utils_1.encode;// Represent num in a w-NAF form\nfunction getNAF(num,w,bits){var naf=new Array(Math.max(num.bitLength(),bits)+1);naf.fill(0);var ws=1<<w+1;var k=num.clone();for(var i=0;i<naf.length;i++){var z;var mod=k.andln(ws-1);if(k.isOdd()){if(mod>(ws>>1)-1)z=(ws>>1)-mod;else z=mod;k.isubn(z);}else{z=0;}naf[i]=z;k.iushrn(1);}return naf;}utils.getNAF=getNAF;// Represent k1, k2 in a Joint Sparse Form\nfunction getJSF(k1,k2){var jsf=[[],[]];k1=k1.clone();k2=k2.clone();var d1=0;var d2=0;while(k1.cmpn(-d1)>0||k2.cmpn(-d2)>0){// First phase\nvar m14=k1.andln(3)+d1&3;var m24=k2.andln(3)+d2&3;if(m14===3)m14=-1;if(m24===3)m24=-1;var u1;if((m14&1)===0){u1=0;}else{var m8=k1.andln(7)+d1&7;if((m8===3||m8===5)&&m24===2)u1=-m14;else u1=m14;}jsf[0].push(u1);var u2;if((m24&1)===0){u2=0;}else{var m8=k2.andln(7)+d2&7;if((m8===3||m8===5)&&m14===2)u2=-m24;else u2=m24;}jsf[1].push(u2);// Second phase\nif(2*d1===u1+1)d1=1-d1;if(2*d2===u2+1)d2=1-d2;k1.iushrn(1);k2.iushrn(1);}return jsf;}utils.getJSF=getJSF;function cachedProperty(obj,name,computer){var key='_'+name;obj.prototype[name]=function cachedProperty(){return this[key]!==undefined?this[key]:this[key]=computer.call(this);};}utils.cachedProperty=cachedProperty;function parseBytes(bytes){return typeof bytes==='string'?utils.toArray(bytes,'hex'):bytes;}utils.parseBytes=parseBytes;function intFromLE(bytes){return new bn$1(bytes,'hex','le');}utils.intFromLE=intFromLE;});var brorand=function brorand(length){var result=new Uint8Array(length);(commonjsGlobal.crypto||commonjsGlobal.msCrypto).getRandomValues(result);return result;};'use strict';var getNAF=utils_1$1.getNAF;var getJSF=utils_1$1.getJSF;var assert$1=utils_1$1.assert;function BaseCurve(type,conf){this.type=type;this.p=new bn$1(conf.p,16);// Use Montgomery, when there is no fast reduction for the prime\nthis.red=conf.prime?bn$1.red(conf.prime):bn$1.mont(this.p);// Useful for many curves\nthis.zero=new bn$1(0).toRed(this.red);this.one=new bn$1(1).toRed(this.red);this.two=new bn$1(2).toRed(this.red);// Curve configuration, optional\nthis.n=conf.n&&new bn$1(conf.n,16);this.g=conf.g&&this.pointFromJSON(conf.g,conf.gRed);// Temporary arrays\nthis._wnafT1=new Array(4);this._wnafT2=new Array(4);this._wnafT3=new Array(4);this._wnafT4=new Array(4);this._bitLength=this.n?this.n.bitLength():0;// Generalized Greg Maxwell's trick\nvar adjustCount=this.n&&this.p.div(this.n);if(!adjustCount||adjustCount.cmpn(100)>0){this.redN=null;}else{this._maxwellTrick=true;this.redN=this.n.toRed(this.red);}}var base=BaseCurve;BaseCurve.prototype.point=function point(){throw new Error('Not implemented');};BaseCurve.prototype.validate=function validate(){throw new Error('Not implemented');};BaseCurve.prototype._fixedNafMul=function _fixedNafMul(p,k){assert$1(p.precomputed);var doubles=p._getDoubles();var naf=getNAF(k,1,this._bitLength);var I=(1<<doubles.step+1)-(doubles.step%2===0?2:1);I/=3;// Translate into more windowed form\nvar repr=[];for(var j=0;j<naf.length;j+=doubles.step){var nafW=0;for(var k=j+doubles.step-1;k>=j;k--){nafW=(nafW<<1)+naf[k];}repr.push(nafW);}var a=this.jpoint(null,null,null);var b=this.jpoint(null,null,null);for(var i=I;i>0;i--){for(var j=0;j<repr.length;j++){var nafW=repr[j];if(nafW===i)b=b.mixedAdd(doubles.points[j]);else if(nafW===-i)b=b.mixedAdd(doubles.points[j].neg());}a=a.add(b);}return a.toP();};BaseCurve.prototype._wnafMul=function _wnafMul(p,k){var w=4;// Precompute window\nvar nafPoints=p._getNAFPoints(w);w=nafPoints.wnd;var wnd=nafPoints.points;// Get NAF form\nvar naf=getNAF(k,w,this._bitLength);// Add `this`*(N+1) for every w-NAF index\nvar acc=this.jpoint(null,null,null);for(var i=naf.length-1;i>=0;i--){// Count zeroes\nfor(var k=0;i>=0&&naf[i]===0;i--){k++;}if(i>=0)k++;acc=acc.dblp(k);if(i<0)break;var z=naf[i];assert$1(z!==0);if(p.type==='affine'){// J +- P\nif(z>0)acc=acc.mixedAdd(wnd[z-1>>1]);else acc=acc.mixedAdd(wnd[-z-1>>1].neg());}else{// J +- J\nif(z>0)acc=acc.add(wnd[z-1>>1]);else acc=acc.add(wnd[-z-1>>1].neg());}}return p.type==='affine'?acc.toP():acc;};BaseCurve.prototype._wnafMulAdd=function _wnafMulAdd(defW,points,coeffs,len,jacobianResult){var wndWidth=this._wnafT1;var wnd=this._wnafT2;var naf=this._wnafT3;// Fill all arrays\nvar max=0;for(var i=0;i<len;i++){var p=points[i];var nafPoints=p._getNAFPoints(defW);wndWidth[i]=nafPoints.wnd;wnd[i]=nafPoints.points;}// Comb small window NAFs\nfor(var i=len-1;i>=1;i-=2){var a=i-1;var b=i;if(wndWidth[a]!==1||wndWidth[b]!==1){naf[a]=getNAF(coeffs[a],wndWidth[a],this._bitLength);naf[b]=getNAF(coeffs[b],wndWidth[b],this._bitLength);max=Math.max(naf[a].length,max);max=Math.max(naf[b].length,max);continue;}var comb=[points[a],/* 1 */null,/* 3 */null,/* 5 */points[b]/* 7 */];// Try to avoid Projective points, if possible\nif(points[a].y.cmp(points[b].y)===0){comb[1]=points[a].add(points[b]);comb[2]=points[a].toJ().mixedAdd(points[b].neg());}else if(points[a].y.cmp(points[b].y.redNeg())===0){comb[1]=points[a].toJ().mixedAdd(points[b]);comb[2]=points[a].add(points[b].neg());}else{comb[1]=points[a].toJ().mixedAdd(points[b]);comb[2]=points[a].toJ().mixedAdd(points[b].neg());}var index=[-3,/* -1 -1 */-1,/* -1 0 */-5,/* -1 1 */-7,/* 0 -1 */0,/* 0 0 */7,/* 0 1 */5,/* 1 -1 */1,/* 1 0 */3/* 1 1 */];var jsf=getJSF(coeffs[a],coeffs[b]);max=Math.max(jsf[0].length,max);naf[a]=new Array(max);naf[b]=new Array(max);for(var j=0;j<max;j++){var ja=jsf[0][j]|0;var jb=jsf[1][j]|0;naf[a][j]=index[(ja+1)*3+(jb+1)];naf[b][j]=0;wnd[a]=comb;}}var acc=this.jpoint(null,null,null);var tmp=this._wnafT4;for(var i=max;i>=0;i--){var k=0;while(i>=0){var zero=true;for(var j=0;j<len;j++){tmp[j]=naf[j][i]|0;if(tmp[j]!==0)zero=false;}if(!zero)break;k++;i--;}if(i>=0)k++;acc=acc.dblp(k);if(i<0)break;for(var j=0;j<len;j++){var z=tmp[j];var p;if(z===0)continue;else if(z>0)p=wnd[j][z-1>>1];else if(z<0)p=wnd[j][-z-1>>1].neg();if(p.type==='affine')acc=acc.mixedAdd(p);else acc=acc.add(p);}}// Zeroify references\nfor(var i=0;i<len;i++){wnd[i]=null;}if(jacobianResult)return acc;else return acc.toP();};function BasePoint(curve,type){this.curve=curve;this.type=type;this.precomputed=null;}BaseCurve.BasePoint=BasePoint;BasePoint.prototype.eq=function eq()/*other*/{throw new Error('Not implemented');};BasePoint.prototype.validate=function validate(){return this.curve.validate(this);};BaseCurve.prototype.decodePoint=function decodePoint(bytes,enc){bytes=utils_1$1.toArray(bytes,enc);var len=this.p.byteLength();// uncompressed, hybrid-odd, hybrid-even\nif((bytes[0]===0x04||bytes[0]===0x06||bytes[0]===0x07)&&bytes.length-1===2*len){if(bytes[0]===0x06)assert$1(bytes[bytes.length-1]%2===0);else if(bytes[0]===0x07)assert$1(bytes[bytes.length-1]%2===1);var res=this.point(bytes.slice(1,1+len),bytes.slice(1+len,1+2*len));return res;}else if((bytes[0]===0x02||bytes[0]===0x03)&&bytes.length-1===len){return this.pointFromX(bytes.slice(1,1+len),bytes[0]===0x03);}throw new Error('Unknown point format');};BasePoint.prototype.encodeCompressed=function encodeCompressed(enc){return this.encode(enc,true);};BasePoint.prototype._encode=function _encode(compact){var len=this.curve.p.byteLength();var x=this.getX().toArray('be',len);if(compact)return[this.getY().isEven()?0x02:0x03].concat(x);return[0x04].concat(x,this.getY().toArray('be',len));};BasePoint.prototype.encode=function encode(enc,compact){return utils_1$1.encode(this._encode(compact),enc);};BasePoint.prototype.precompute=function precompute(power){if(this.precomputed)return this;var precomputed={doubles:null,naf:null,beta:null};precomputed.naf=this._getNAFPoints(8);precomputed.doubles=this._getDoubles(4,power);precomputed.beta=this._getBeta();this.precomputed=precomputed;return this;};BasePoint.prototype._hasDoubles=function _hasDoubles(k){if(!this.precomputed)return false;var doubles=this.precomputed.doubles;if(!doubles)return false;return doubles.points.length>=Math.ceil((k.bitLength()+1)/doubles.step);};BasePoint.prototype._getDoubles=function _getDoubles(step,power){if(this.precomputed&&this.precomputed.doubles)return this.precomputed.doubles;var doubles=[this];var acc=this;for(var i=0;i<power;i+=step){for(var j=0;j<step;j++){acc=acc.dbl();}doubles.push(acc);}return{step:step,points:doubles};};BasePoint.prototype._getNAFPoints=function _getNAFPoints(wnd){if(this.precomputed&&this.precomputed.naf)return this.precomputed.naf;var res=[this];var max=(1<<wnd)-1;var dbl=max===1?null:this.dbl();for(var i=1;i<max;i++){res[i]=res[i-1].add(dbl);}return{wnd:wnd,points:res};};BasePoint.prototype._getBeta=function _getBeta(){return null;};BasePoint.prototype.dblp=function dblp(k){var r=this;for(var i=0;i<k;i++){r=r.dbl();}return r;};'use strict';var assert$2=utils_1$1.assert;function ShortCurve(conf){base.call(this,'short',conf);this.a=new bn$1(conf.a,16).toRed(this.red);this.b=new bn$1(conf.b,16).toRed(this.red);this.tinv=this.two.redInvm();this.zeroA=this.a.fromRed().cmpn(0)===0;this.threeA=this.a.fromRed().sub(this.p).cmpn(-3)===0;// If the curve is endomorphic, precalculate beta and lambda\nthis.endo=this._getEndomorphism(conf);this._endoWnafT1=new Array(4);this._endoWnafT2=new Array(4);}inherits_browser(ShortCurve,base);var short_1=ShortCurve;ShortCurve.prototype._getEndomorphism=function _getEndomorphism(conf){// No efficient endomorphism\nif(!this.zeroA||!this.g||!this.n||this.p.modn(3)!==1)return;// Compute beta and lambda, that lambda * P = (beta * Px; Py)\nvar beta;var lambda;if(conf.beta){beta=new bn$1(conf.beta,16).toRed(this.red);}else{var betas=this._getEndoRoots(this.p);// Choose the smallest beta\nbeta=betas[0].cmp(betas[1])<0?betas[0]:betas[1];beta=beta.toRed(this.red);}if(conf.lambda){lambda=new bn$1(conf.lambda,16);}else{// Choose the lambda that is matching selected beta\nvar lambdas=this._getEndoRoots(this.n);if(this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta))===0){lambda=lambdas[0];}else{lambda=lambdas[1];assert$2(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta))===0);}}// Get basis vectors, used for balanced length-two representation\nvar basis;if(conf.basis){basis=conf.basis.map(function(vec){return{a:new bn$1(vec.a,16),b:new bn$1(vec.b,16)};});}else{basis=this._getEndoBasis(lambda);}return{beta:beta,lambda:lambda,basis:basis};};ShortCurve.prototype._getEndoRoots=function _getEndoRoots(num){// Find roots of for x^2 + x + 1 in F\n// Root = (-1 +- Sqrt(-3)) / 2\n//\nvar red=num===this.p?this.red:bn$1.mont(num);var tinv=new bn$1(2).toRed(red).redInvm();var ntinv=tinv.redNeg();var s=new bn$1(3).toRed(red).redNeg().redSqrt().redMul(tinv);var l1=ntinv.redAdd(s).fromRed();var l2=ntinv.redSub(s).fromRed();return[l1,l2];};ShortCurve.prototype._getEndoBasis=function _getEndoBasis(lambda){// aprxSqrt >= sqrt(this.n)\nvar aprxSqrt=this.n.ushrn(Math.floor(this.n.bitLength()/2));// 3.74\n// Run EGCD, until r(L + 1) < aprxSqrt\nvar u=lambda;var v=this.n.clone();var x1=new bn$1(1);var y1=new bn$1(0);var x2=new bn$1(0);var y2=new bn$1(1);// NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)\nvar a0;var b0;// First vector\nvar a1;var b1;// Second vector\nvar a2;var b2;var prevR;var i=0;var r;var x;while(u.cmpn(0)!==0){var q=v.div(u);r=v.sub(q.mul(u));x=x2.sub(q.mul(x1));var y=y2.sub(q.mul(y1));if(!a1&&r.cmp(aprxSqrt)<0){a0=prevR.neg();b0=x1;a1=r.neg();b1=x;}else if(a1&&++i===2){break;}prevR=r;v=u;u=r;x2=x1;x1=x;y2=y1;y1=y;}a2=r.neg();b2=x;var len1=a1.sqr().add(b1.sqr());var len2=a2.sqr().add(b2.sqr());if(len2.cmp(len1)>=0){a2=a0;b2=b0;}// Normalize signs\nif(a1.negative){a1=a1.neg();b1=b1.neg();}if(a2.negative){a2=a2.neg();b2=b2.neg();}return[{a:a1,b:b1},{a:a2,b:b2}];};ShortCurve.prototype._endoSplit=function _endoSplit(k){var basis=this.endo.basis;var v1=basis[0];var v2=basis[1];var c1=v2.b.mul(k).divRound(this.n);var c2=v1.b.neg().mul(k).divRound(this.n);var p1=c1.mul(v1.a);var p2=c2.mul(v2.a);var q1=c1.mul(v1.b);var q2=c2.mul(v2.b);// Calculate answer\nvar k1=k.sub(p1).sub(p2);var k2=q1.add(q2).neg();return{k1:k1,k2:k2};};ShortCurve.prototype.pointFromX=function pointFromX(x,odd){x=new bn$1(x,16);if(!x.red)x=x.toRed(this.red);var y2=x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);var y=y2.redSqrt();if(y.redSqr().redSub(y2).cmp(this.zero)!==0)throw new Error('invalid point');// XXX Is there any way to tell if the number is odd without converting it\n// to non-red form?\nvar isOdd=y.fromRed().isOdd();if(odd&&!isOdd||!odd&&isOdd)y=y.redNeg();return this.point(x,y);};ShortCurve.prototype.validate=function validate(point){if(point.inf)return true;var x=point.x;var y=point.y;var ax=this.a.redMul(x);var rhs=x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);return y.redSqr().redISub(rhs).cmpn(0)===0;};ShortCurve.prototype._endoWnafMulAdd=function _endoWnafMulAdd(points,coeffs,jacobianResult){var npoints=this._endoWnafT1;var ncoeffs=this._endoWnafT2;for(var i=0;i<points.length;i++){var split=this._endoSplit(coeffs[i]);var p=points[i];var beta=p._getBeta();if(split.k1.negative){split.k1.ineg();p=p.neg(true);}if(split.k2.negative){split.k2.ineg();beta=beta.neg(true);}npoints[i*2]=p;npoints[i*2+1]=beta;ncoeffs[i*2]=split.k1;ncoeffs[i*2+1]=split.k2;}var res=this._wnafMulAdd(1,npoints,ncoeffs,i*2,jacobianResult);// Clean-up references to points and coefficients\nfor(var j=0;j<i*2;j++){npoints[j]=null;ncoeffs[j]=null;}return res;};function Point(curve,x,y,isRed){base.BasePoint.call(this,curve,'affine');if(x===null&&y===null){this.x=null;this.y=null;this.inf=true;}else{this.x=new bn$1(x,16);this.y=new bn$1(y,16);// Force redgomery representation when loading from JSON\nif(isRed){this.x.forceRed(this.curve.red);this.y.forceRed(this.curve.red);}if(!this.x.red)this.x=this.x.toRed(this.curve.red);if(!this.y.red)this.y=this.y.toRed(this.curve.red);this.inf=false;}}inherits_browser(Point,base.BasePoint);ShortCurve.prototype.point=function point(x,y,isRed){return new Point(this,x,y,isRed);};ShortCurve.prototype.pointFromJSON=function pointFromJSON(obj,red){return Point.fromJSON(this,obj,red);};Point.prototype._getBeta=function _getBeta(){if(!this.curve.endo)return;var pre=this.precomputed;if(pre&&pre.beta)return pre.beta;var beta=this.curve.point(this.x.redMul(this.curve.endo.beta),this.y);if(pre){var curve=this.curve;var endoMul=function endoMul(p){return curve.point(p.x.redMul(curve.endo.beta),p.y);};pre.beta=beta;beta.precomputed={beta:null,naf:pre.naf&&{wnd:pre.naf.wnd,points:pre.naf.points.map(endoMul)},doubles:pre.doubles&&{step:pre.doubles.step,points:pre.doubles.points.map(endoMul)}};}return beta;};Point.prototype.toJSON=function toJSON(){if(!this.precomputed)return[this.x,this.y];return[this.x,this.y,this.precomputed&&{doubles:this.precomputed.doubles&&{step:this.precomputed.doubles.step,points:this.precomputed.doubles.points.slice(1)},naf:this.precomputed.naf&&{wnd:this.precomputed.naf.wnd,points:this.precomputed.naf.points.slice(1)}}];};Point.fromJSON=function fromJSON(curve,obj,red){if(typeof obj==='string')obj=JSON.parse(obj);var res=curve.point(obj[0],obj[1],red);if(!obj[2])return res;function obj2point(obj){return curve.point(obj[0],obj[1],red);}var pre=obj[2];res.precomputed={beta:null,doubles:pre.doubles&&{step:pre.doubles.step,points:[res].concat(pre.doubles.points.map(obj2point))},naf:pre.naf&&{wnd:pre.naf.wnd,points:[res].concat(pre.naf.points.map(obj2point))}};return res;};Point.prototype.inspect=function inspect(){if(this.isInfinity())return'<EC Point Infinity>';return'<EC Point x: '+this.x.fromRed().toString(16,2)+' y: '+this.y.fromRed().toString(16,2)+'>';};Point.prototype.isInfinity=function isInfinity(){return this.inf;};Point.prototype.add=function add(p){// O + P = P\nif(this.inf)return p;// P + O = P\nif(p.inf)return this;// P + P = 2P\nif(this.eq(p))return this.dbl();// P + (-P) = O\nif(this.neg().eq(p))return this.curve.point(null,null);// P + Q = O\nif(this.x.cmp(p.x)===0)return this.curve.point(null,null);var c=this.y.redSub(p.y);if(c.cmpn(0)!==0)c=c.redMul(this.x.redSub(p.x).redInvm());var nx=c.redSqr().redISub(this.x).redISub(p.x);var ny=c.redMul(this.x.redSub(nx)).redISub(this.y);return this.curve.point(nx,ny);};Point.prototype.dbl=function dbl(){if(this.inf)return this;// 2P = O\nvar ys1=this.y.redAdd(this.y);if(ys1.cmpn(0)===0)return this.curve.point(null,null);var a=this.curve.a;var x2=this.x.redSqr();var dyinv=ys1.redInvm();var c=x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);var nx=c.redSqr().redISub(this.x.redAdd(this.x));var ny=c.redMul(this.x.redSub(nx)).redISub(this.y);return this.curve.point(nx,ny);};Point.prototype.getX=function getX(){return this.x.fromRed();};Point.prototype.getY=function getY(){return this.y.fromRed();};Point.prototype.mul=function mul(k){k=new bn$1(k,16);if(this.isInfinity())return this;else if(this._hasDoubles(k))return this.curve._fixedNafMul(this,k);else if(this.curve.endo)return this.curve._endoWnafMulAdd([this],[k]);else return this.curve._wnafMul(this,k);};Point.prototype.mulAdd=function mulAdd(k1,p2,k2){var points=[this,p2];var coeffs=[k1,k2];if(this.curve.endo)return this.curve._endoWnafMulAdd(points,coeffs);else return this.curve._wnafMulAdd(1,points,coeffs,2);};Point.prototype.jmulAdd=function jmulAdd(k1,p2,k2){var points=[this,p2];var coeffs=[k1,k2];if(this.curve.endo)return this.curve._endoWnafMulAdd(points,coeffs,true);else return this.curve._wnafMulAdd(1,points,coeffs,2,true);};Point.prototype.eq=function eq(p){return this===p||this.inf===p.inf&&(this.inf||this.x.cmp(p.x)===0&&this.y.cmp(p.y)===0);};Point.prototype.neg=function neg(_precompute){if(this.inf)return this;var res=this.curve.point(this.x,this.y.redNeg());if(_precompute&&this.precomputed){var pre=this.precomputed;var negate=function negate(p){return p.neg();};res.precomputed={naf:pre.naf&&{wnd:pre.naf.wnd,points:pre.naf.points.map(negate)},doubles:pre.doubles&&{step:pre.doubles.step,points:pre.doubles.points.map(negate)}};}return res;};Point.prototype.toJ=function toJ(){if(this.inf)return this.curve.jpoint(null,null,null);var res=this.curve.jpoint(this.x,this.y,this.curve.one);return res;};function JPoint(curve,x,y,z){base.BasePoint.call(this,curve,'jacobian');if(x===null&&y===null&&z===null){this.x=this.curve.one;this.y=this.curve.one;this.z=new bn$1(0);}else{this.x=new bn$1(x,16);this.y=new bn$1(y,16);this.z=new bn$1(z,16);}if(!this.x.red)this.x=this.x.toRed(this.curve.red);if(!this.y.red)this.y=this.y.toRed(this.curve.red);if(!this.z.red)this.z=this.z.toRed(this.curve.red);this.zOne=this.z===this.curve.one;}inherits_browser(JPoint,base.BasePoint);ShortCurve.prototype.jpoint=function jpoint(x,y,z){return new JPoint(this,x,y,z);};JPoint.prototype.toP=function toP(){if(this.isInfinity())return this.curve.point(null,null);var zinv=this.z.redInvm();var zinv2=zinv.redSqr();var ax=this.x.redMul(zinv2);var ay=this.y.redMul(zinv2).redMul(zinv);return this.curve.point(ax,ay);};JPoint.prototype.neg=function neg(){return this.curve.jpoint(this.x,this.y.redNeg(),this.z);};JPoint.prototype.add=function add(p){// O + P = P\nif(this.isInfinity())return p;// P + O = P\nif(p.isInfinity())return this;// 12M + 4S + 7A\nvar pz2=p.z.redSqr();var z2=this.z.redSqr();var u1=this.x.redMul(pz2);var u2=p.x.redMul(z2);var s1=this.y.redMul(pz2.redMul(p.z));var s2=p.y.redMul(z2.redMul(this.z));var h=u1.redSub(u2);var r=s1.redSub(s2);if(h.cmpn(0)===0){if(r.cmpn(0)!==0)return this.curve.jpoint(null,null,null);else return this.dbl();}var h2=h.redSqr();var h3=h2.redMul(h);var v=u1.redMul(h2);var nx=r.redSqr().redIAdd(h3).redISub(v).redISub(v);var ny=r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));var nz=this.z.redMul(p.z).redMul(h);return this.curve.jpoint(nx,ny,nz);};JPoint.prototype.mixedAdd=function mixedAdd(p){// O + P = P\nif(this.isInfinity())return p.toJ();// P + O = P\nif(p.isInfinity())return this;// 8M + 3S + 7A\nvar z2=this.z.redSqr();var u1=this.x;var u2=p.x.redMul(z2);var s1=this.y;var s2=p.y.redMul(z2).redMul(this.z);var h=u1.redSub(u2);var r=s1.redSub(s2);if(h.cmpn(0)===0){if(r.cmpn(0)!==0)return this.curve.jpoint(null,null,null);else return this.dbl();}var h2=h.redSqr();var h3=h2.redMul(h);var v=u1.redMul(h2);var nx=r.redSqr().redIAdd(h3).redISub(v).redISub(v);var ny=r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));var nz=this.z.redMul(h);return this.curve.jpoint(nx,ny,nz);};JPoint.prototype.dblp=function dblp(pow){if(pow===0)return this;if(this.isInfinity())return this;if(!pow)return this.dbl();if(this.curve.zeroA||this.curve.threeA){var r=this;for(var i=0;i<pow;i++){r=r.dbl();}return r;}// 1M + 2S + 1A + N * (4S + 5M + 8A)\n// N = 1 => 6M + 6S + 9A\nvar a=this.curve.a;var tinv=this.curve.tinv;var jx=this.x;var jy=this.y;var jz=this.z;var jz4=jz.redSqr().redSqr();// Reuse results\nvar jyd=jy.redAdd(jy);for(var i=0;i<pow;i++){var jx2=jx.redSqr();var jyd2=jyd.redSqr();var jyd4=jyd2.redSqr();var c=jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));var t1=jx.redMul(jyd2);var nx=c.redSqr().redISub(t1.redAdd(t1));var t2=t1.redISub(nx);var dny=c.redMul(t2);dny=dny.redIAdd(dny).redISub(jyd4);var nz=jyd.redMul(jz);if(i+1<pow)jz4=jz4.redMul(jyd4);jx=nx;jz=nz;jyd=dny;}return this.curve.jpoint(jx,jyd.redMul(tinv),jz);};JPoint.prototype.dbl=function dbl(){if(this.isInfinity())return this;if(this.curve.zeroA)return this._zeroDbl();else if(this.curve.threeA)return this._threeDbl();else return this._dbl();};JPoint.prototype._zeroDbl=function _zeroDbl(){var nx;var ny;var nz;// Z = 1\nif(this.zOne){// hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\n//     #doubling-mdbl-2007-bl\n// 1M + 5S + 14A\n// XX = X1^2\nvar xx=this.x.redSqr();// YY = Y1^2\nvar yy=this.y.redSqr();// YYYY = YY^2\nvar yyyy=yy.redSqr();// S = 2 * ((X1 + YY)^2 - XX - YYYY)\nvar s=this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);s=s.redIAdd(s);// M = 3 * XX + a; a = 0\nvar m=xx.redAdd(xx).redIAdd(xx);// T = M ^ 2 - 2*S\nvar t=m.redSqr().redISub(s).redISub(s);// 8 * YYYY\nvar yyyy8=yyyy.redIAdd(yyyy);yyyy8=yyyy8.redIAdd(yyyy8);yyyy8=yyyy8.redIAdd(yyyy8);// X3 = T\nnx=t;// Y3 = M * (S - T) - 8 * YYYY\nny=m.redMul(s.redISub(t)).redISub(yyyy8);// Z3 = 2*Y1\nnz=this.y.redAdd(this.y);}else{// hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\n//     #doubling-dbl-2009-l\n// 2M + 5S + 13A\n// A = X1^2\nvar a=this.x.redSqr();// B = Y1^2\nvar b=this.y.redSqr();// C = B^2\nvar c=b.redSqr();// D = 2 * ((X1 + B)^2 - A - C)\nvar d=this.x.redAdd(b).redSqr().redISub(a).redISub(c);d=d.redIAdd(d);// E = 3 * A\nvar e=a.redAdd(a).redIAdd(a);// F = E^2\nvar f=e.redSqr();// 8 * C\nvar c8=c.redIAdd(c);c8=c8.redIAdd(c8);c8=c8.redIAdd(c8);// X3 = F - 2 * D\nnx=f.redISub(d).redISub(d);// Y3 = E * (D - X3) - 8 * C\nny=e.redMul(d.redISub(nx)).redISub(c8);// Z3 = 2 * Y1 * Z1\nnz=this.y.redMul(this.z);nz=nz.redIAdd(nz);}return this.curve.jpoint(nx,ny,nz);};JPoint.prototype._threeDbl=function _threeDbl(){var nx;var ny;var nz;// Z = 1\nif(this.zOne){// hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html\n//     #doubling-mdbl-2007-bl\n// 1M + 5S + 15A\n// XX = X1^2\nvar xx=this.x.redSqr();// YY = Y1^2\nvar yy=this.y.redSqr();// YYYY = YY^2\nvar yyyy=yy.redSqr();// S = 2 * ((X1 + YY)^2 - XX - YYYY)\nvar s=this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);s=s.redIAdd(s);// M = 3 * XX + a\nvar m=xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);// T = M^2 - 2 * S\nvar t=m.redSqr().redISub(s).redISub(s);// X3 = T\nnx=t;// Y3 = M * (S - T) - 8 * YYYY\nvar yyyy8=yyyy.redIAdd(yyyy);yyyy8=yyyy8.redIAdd(yyyy8);yyyy8=yyyy8.redIAdd(yyyy8);ny=m.redMul(s.redISub(t)).redISub(yyyy8);// Z3 = 2 * Y1\nnz=this.y.redAdd(this.y);}else{// hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b\n// 3M + 5S\n// delta = Z1^2\nvar delta=this.z.redSqr();// gamma = Y1^2\nvar gamma=this.y.redSqr();// beta = X1 * gamma\nvar beta=this.x.redMul(gamma);// alpha = 3 * (X1 - delta) * (X1 + delta)\nvar alpha=this.x.redSub(delta).redMul(this.x.redAdd(delta));alpha=alpha.redAdd(alpha).redIAdd(alpha);// X3 = alpha^2 - 8 * beta\nvar beta4=beta.redIAdd(beta);beta4=beta4.redIAdd(beta4);var beta8=beta4.redAdd(beta4);nx=alpha.redSqr().redISub(beta8);// Z3 = (Y1 + Z1)^2 - gamma - delta\nnz=this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);// Y3 = alpha * (4 * beta - X3) - 8 * gamma^2\nvar ggamma8=gamma.redSqr();ggamma8=ggamma8.redIAdd(ggamma8);ggamma8=ggamma8.redIAdd(ggamma8);ggamma8=ggamma8.redIAdd(ggamma8);ny=alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);}return this.curve.jpoint(nx,ny,nz);};JPoint.prototype._dbl=function _dbl(){var a=this.curve.a;// 4M + 6S + 10A\nvar jx=this.x;var jy=this.y;var jz=this.z;var jz4=jz.redSqr().redSqr();var jx2=jx.redSqr();var jy2=jy.redSqr();var c=jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));var jxd4=jx.redAdd(jx);jxd4=jxd4.redIAdd(jxd4);var t1=jxd4.redMul(jy2);var nx=c.redSqr().redISub(t1.redAdd(t1));var t2=t1.redISub(nx);var jyd8=jy2.redSqr();jyd8=jyd8.redIAdd(jyd8);jyd8=jyd8.redIAdd(jyd8);jyd8=jyd8.redIAdd(jyd8);var ny=c.redMul(t2).redISub(jyd8);var nz=jy.redAdd(jy).redMul(jz);return this.curve.jpoint(nx,ny,nz);};JPoint.prototype.trpl=function trpl(){if(!this.curve.zeroA)return this.dbl().add(this);// hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl\n// 5M + 10S + ...\n// XX = X1^2\nvar xx=this.x.redSqr();// YY = Y1^2\nvar yy=this.y.redSqr();// ZZ = Z1^2\nvar zz=this.z.redSqr();// YYYY = YY^2\nvar yyyy=yy.redSqr();// M = 3 * XX + a * ZZ2; a = 0\nvar m=xx.redAdd(xx).redIAdd(xx);// MM = M^2\nvar mm=m.redSqr();// E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM\nvar e=this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);e=e.redIAdd(e);e=e.redAdd(e).redIAdd(e);e=e.redISub(mm);// EE = E^2\nvar ee=e.redSqr();// T = 16*YYYY\nvar t=yyyy.redIAdd(yyyy);t=t.redIAdd(t);t=t.redIAdd(t);t=t.redIAdd(t);// U = (M + E)^2 - MM - EE - T\nvar u=m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);// X3 = 4 * (X1 * EE - 4 * YY * U)\nvar yyu4=yy.redMul(u);yyu4=yyu4.redIAdd(yyu4);yyu4=yyu4.redIAdd(yyu4);var nx=this.x.redMul(ee).redISub(yyu4);nx=nx.redIAdd(nx);nx=nx.redIAdd(nx);// Y3 = 8 * Y1 * (U * (T - U) - E * EE)\nvar ny=this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));ny=ny.redIAdd(ny);ny=ny.redIAdd(ny);ny=ny.redIAdd(ny);// Z3 = (Z1 + E)^2 - ZZ - EE\nvar nz=this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);return this.curve.jpoint(nx,ny,nz);};JPoint.prototype.mul=function mul(k,kbase){k=new bn$1(k,kbase);return this.curve._wnafMul(this,k);};JPoint.prototype.eq=function eq(p){if(p.type==='affine')return this.eq(p.toJ());if(this===p)return true;// x1 * z2^2 == x2 * z1^2\nvar z2=this.z.redSqr();var pz2=p.z.redSqr();if(this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0)!==0)return false;// y1 * z2^3 == y2 * z1^3\nvar z3=z2.redMul(this.z);var pz3=pz2.redMul(p.z);return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0)===0;};JPoint.prototype.eqXToP=function eqXToP(x){var zs=this.z.redSqr();var rx=x.toRed(this.curve.red).redMul(zs);if(this.x.cmp(rx)===0)return true;var xc=x.clone();var t=this.curve.redN.redMul(zs);for(;;){xc.iadd(this.curve.n);if(xc.cmp(this.curve.p)>=0)return false;rx.redIAdd(t);if(this.x.cmp(rx)===0)return true;}};JPoint.prototype.inspect=function inspect(){if(this.isInfinity())return'<EC JPoint Infinity>';return'<EC JPoint x: '+this.x.toString(16,2)+' y: '+this.y.toString(16,2)+' z: '+this.z.toString(16,2)+'>';};JPoint.prototype.isInfinity=function isInfinity(){// XXX This code assumes that zero is always zero in red\nreturn this.z.cmpn(0)===0;};var mont={};var edwards={};var curve_1=createCommonjsModule(function(module,exports){'use strict';var curve=exports;curve.base=base;curve.short=short_1;curve.mont=mont;curve.edwards=edwards;});var secp256k1=undefined;var curves_1=createCommonjsModule(function(module,exports){'use strict';var curves=exports;var assert=utils_1$1.assert;function PresetCurve(options){if(options.type==='short')this.curve=new curve_1.short(options);else if(options.type==='edwards')this.curve=new curve_1.edwards(options);else this.curve=new curve_1.mont(options);this.g=this.curve.g;this.n=this.curve.n;this.hash=options.hash;assert(this.g.validate(),'Invalid curve');assert(this.g.mul(this.n).isInfinity(),'Invalid curve, G*N != O');}curves.PresetCurve=PresetCurve;function defineCurve(name,options){Object.defineProperty(curves,name,{configurable:true,enumerable:true,get:function get(){var curve=new PresetCurve(options);Object.defineProperty(curves,name,{configurable:true,enumerable:true,value:curve});return curve;}});}defineCurve('p192',{type:'short',prime:'p192',p:'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',a:'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',b:'64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',n:'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',hash:hash_1.sha256,gRed:false,g:['188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012','07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811']});defineCurve('p224',{type:'short',prime:'p224',p:'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',a:'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',b:'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',n:'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',hash:hash_1.sha256,gRed:false,g:['b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21','bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34']});defineCurve('p256',{type:'short',prime:null,p:'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',a:'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',b:'5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',n:'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',hash:hash_1.sha256,gRed:false,g:['6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296','4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5']});defineCurve('p384',{type:'short',prime:null,p:'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff '+'fffffffe ffffffff 00000000 00000000 ffffffff',a:'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff '+'fffffffe ffffffff 00000000 00000000 fffffffc',b:'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f '+'5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',n:'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 '+'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',hash:hash_1.sha384,gRed:false,g:['aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 '+'5502f25d bf55296c 3a545e38 72760ab7','3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 '+'0a60b1ce 1d7e819d 7a431d7c 90ea0e5f']});defineCurve('p521',{type:'short',prime:null,p:'000001ff ffffffff ffffffff ffffffff ffffffff ffffffff '+'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff '+'ffffffff ffffffff ffffffff ffffffff ffffffff',a:'000001ff ffffffff ffffffff ffffffff ffffffff ffffffff '+'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff '+'ffffffff ffffffff ffffffff ffffffff fffffffc',b:'00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b '+'99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd '+'3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',n:'000001ff ffffffff ffffffff ffffffff ffffffff ffffffff '+'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 '+'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',hash:hash_1.sha512,gRed:false,g:['000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 '+'053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 '+'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66','00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 '+'579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 '+'3fad0761 353c7086 a272c240 88be9476 9fd16650']});defineCurve('curve25519',{type:'mont',prime:'p25519',p:'7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',a:'76d06',b:'1',n:'1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',hash:hash_1.sha256,gRed:false,g:['9']});defineCurve('ed25519',{type:'edwards',prime:'p25519',p:'7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',a:'-1',c:'1',// -121665 * (121666^(-1)) (mod P)\nd:'52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',n:'1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',hash:hash_1.sha256,gRed:false,g:['216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',// 4/5\n'6666666666666666666666666666666666666666666666666666666666666658']});var pre;try{pre=secp256k1;}catch(e){pre=undefined;}defineCurve('secp256k1',{type:'short',prime:'k256',p:'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',a:'0',b:'7',n:'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',h:'1',hash:hash_1.sha256,// Precomputed endomorphism\nbeta:'7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',lambda:'5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',basis:[{a:'3086d221a7d46bcde86c90e49284eb15',b:'-e4437ed6010e88286f547fa90abfe4c3'},{a:'114ca50f7a8e2f3f657c1108d9d44cfd8',b:'3086d221a7d46bcde86c90e49284eb15'}],gRed:false,g:['79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798','483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',pre]});});'use strict';function HmacDRBG(options){if(!(this instanceof HmacDRBG))return new HmacDRBG(options);this.hash=options.hash;this.predResist=!!options.predResist;this.outLen=this.hash.outSize;this.minEntropy=options.minEntropy||this.hash.hmacStrength;this._reseed=null;this.reseedInterval=null;this.K=null;this.V=null;var entropy=utils_1.toArray(options.entropy,options.entropyEnc||'hex');var nonce=utils_1.toArray(options.nonce,options.nonceEnc||'hex');var pers=utils_1.toArray(options.pers,options.persEnc||'hex');minimalisticAssert(entropy.length>=this.minEntropy/8,'Not enough entropy. Minimum is: '+this.minEntropy+' bits');this._init(entropy,nonce,pers);}var hmacDrbg=HmacDRBG;HmacDRBG.prototype._init=function init(entropy,nonce,pers){var seed=entropy.concat(nonce).concat(pers);this.K=new Array(this.outLen/8);this.V=new Array(this.outLen/8);for(var i=0;i<this.V.length;i++){this.K[i]=0x00;this.V[i]=0x01;}this._update(seed);this._reseed=1;this.reseedInterval=0x1000000000000;// 2^48\n};HmacDRBG.prototype._hmac=function hmac(){return new hash_1.hmac(this.hash,this.K);};HmacDRBG.prototype._update=function update(seed){var kmac=this._hmac().update(this.V).update([0x00]);if(seed)kmac=kmac.update(seed);this.K=kmac.digest();this.V=this._hmac().update(this.V).digest();if(!seed)return;this.K=this._hmac().update(this.V).update([0x01]).update(seed).digest();this.V=this._hmac().update(this.V).digest();};HmacDRBG.prototype.reseed=function reseed(entropy,entropyEnc,add,addEnc){// Optional entropy enc\nif(typeof entropyEnc!=='string'){addEnc=add;add=entropyEnc;entropyEnc=null;}entropy=utils_1.toArray(entropy,entropyEnc);add=utils_1.toArray(add,addEnc);minimalisticAssert(entropy.length>=this.minEntropy/8,'Not enough entropy. Minimum is: '+this.minEntropy+' bits');this._update(entropy.concat(add||[]));this._reseed=1;};HmacDRBG.prototype.generate=function generate(len,enc,add,addEnc){if(this._reseed>this.reseedInterval)throw new Error('Reseed is required');// Optional encoding\nif(typeof enc!=='string'){addEnc=add;add=enc;enc=null;}// Optional additional data\nif(add){add=utils_1.toArray(add,addEnc||'hex');this._update(add);}var temp=[];while(temp.length<len){this.V=this._hmac().update(this.V).digest();temp=temp.concat(this.V);}var res=temp.slice(0,len);this._update(add);this._reseed++;return utils_1.encode(res,enc);};'use strict';var assert$3=utils_1$1.assert;function KeyPair(ec,options){this.ec=ec;this.priv=null;this.pub=null;// KeyPair(ec, { priv: ..., pub: ... })\nif(options.priv)this._importPrivate(options.priv,options.privEnc);if(options.pub)this._importPublic(options.pub,options.pubEnc);}var key=KeyPair;KeyPair.fromPublic=function fromPublic(ec,pub,enc){if(pub instanceof KeyPair)return pub;return new KeyPair(ec,{pub:pub,pubEnc:enc});};KeyPair.fromPrivate=function fromPrivate(ec,priv,enc){if(priv instanceof KeyPair)return priv;return new KeyPair(ec,{priv:priv,privEnc:enc});};KeyPair.prototype.validate=function validate(){var pub=this.getPublic();if(pub.isInfinity())return{result:false,reason:'Invalid public key'};if(!pub.validate())return{result:false,reason:'Public key is not a point'};if(!pub.mul(this.ec.curve.n).isInfinity())return{result:false,reason:'Public key * N != O'};return{result:true,reason:null};};KeyPair.prototype.getPublic=function getPublic(compact,enc){// compact is optional argument\nif(typeof compact==='string'){enc=compact;compact=null;}if(!this.pub)this.pub=this.ec.g.mul(this.priv);if(!enc)return this.pub;return this.pub.encode(enc,compact);};KeyPair.prototype.getPrivate=function getPrivate(enc){if(enc==='hex')return this.priv.toString(16,2);else return this.priv;};KeyPair.prototype._importPrivate=function _importPrivate(key,enc){this.priv=new bn$1(key,enc||16);// Ensure that the priv won't be bigger than n, otherwise we may fail\n// in fixed multiplication method\nthis.priv=this.priv.umod(this.ec.curve.n);};KeyPair.prototype._importPublic=function _importPublic(key,enc){if(key.x||key.y){// Montgomery points only have an `x` coordinate.\n// Weierstrass/Edwards points on the other hand have both `x` and\n// `y` coordinates.\nif(this.ec.curve.type==='mont'){assert$3(key.x,'Need x coordinate');}else if(this.ec.curve.type==='short'||this.ec.curve.type==='edwards'){assert$3(key.x&&key.y,'Need both x and y coordinate');}this.pub=this.ec.curve.point(key.x,key.y);return;}this.pub=this.ec.curve.decodePoint(key,enc);};// ECDH\nKeyPair.prototype.derive=function derive(pub){return pub.mul(this.priv).getX();};// ECDSA\nKeyPair.prototype.sign=function sign(msg,enc,options){return this.ec.sign(msg,this,enc,options);};KeyPair.prototype.verify=function verify(msg,signature){return this.ec.verify(msg,signature,this);};KeyPair.prototype.inspect=function inspect(){return'<Key priv: '+(this.priv&&this.priv.toString(16,2))+' pub: '+(this.pub&&this.pub.inspect())+' >';};'use strict';var assert$4=utils_1$1.assert;function Signature(options,enc){if(options instanceof Signature)return options;if(this._importDER(options,enc))return;assert$4(options.r&&options.s,'Signature without r or s');this.r=new bn$1(options.r,16);this.s=new bn$1(options.s,16);if(options.recoveryParam===undefined)this.recoveryParam=null;else this.recoveryParam=options.recoveryParam;}var signature=Signature;function Position(){this.place=0;}function getLength(buf,p){var initial=buf[p.place++];if(!(initial&0x80)){return initial;}var octetLen=initial&0xf;// Indefinite length or overflow\nif(octetLen===0||octetLen>4){return false;}var val=0;for(var i=0,off=p.place;i<octetLen;i++,off++){val<<=8;val|=buf[off];val>>>=0;}// Leading zeroes\nif(val<=0x7f){return false;}p.place=off;return val;}function rmPadding(buf){var i=0;var len=buf.length-1;while(!buf[i]&&!(buf[i+1]&0x80)&&i<len){i++;}if(i===0){return buf;}return buf.slice(i);}Signature.prototype._importDER=function _importDER(data,enc){data=utils_1$1.toArray(data,enc);var p=new Position();if(data[p.place++]!==0x30){return false;}var len=getLength(data,p);if(len===false){return false;}if(len+p.place!==data.length){return false;}if(data[p.place++]!==0x02){return false;}var rlen=getLength(data,p);if(rlen===false){return false;}var r=data.slice(p.place,rlen+p.place);p.place+=rlen;if(data[p.place++]!==0x02){return false;}var slen=getLength(data,p);if(slen===false){return false;}if(data.length!==slen+p.place){return false;}var s=data.slice(p.place,slen+p.place);if(r[0]===0){if(r[1]&0x80){r=r.slice(1);}else{// Leading zeroes\nreturn false;}}if(s[0]===0){if(s[1]&0x80){s=s.slice(1);}else{// Leading zeroes\nreturn false;}}this.r=new bn$1(r);this.s=new bn$1(s);this.recoveryParam=null;return true;};function constructLength(arr,len){if(len<0x80){arr.push(len);return;}var octets=1+(Math.log(len)/Math.LN2>>>3);arr.push(octets|0x80);while(--octets){arr.push(len>>>(octets<<3)&0xff);}arr.push(len);}Signature.prototype.toDER=function toDER(enc){var r=this.r.toArray();var s=this.s.toArray();// Pad values\nif(r[0]&0x80)r=[0].concat(r);// Pad values\nif(s[0]&0x80)s=[0].concat(s);r=rmPadding(r);s=rmPadding(s);while(!s[0]&&!(s[1]&0x80)){s=s.slice(1);}var arr=[0x02];constructLength(arr,r.length);arr=arr.concat(r);arr.push(0x02);constructLength(arr,s.length);var backHalf=arr.concat(s);var res=[0x30];constructLength(res,backHalf.length);res=res.concat(backHalf);return utils_1$1.encode(res,enc);};'use strict';var assert$5=utils_1$1.assert;function EC(options){if(!(this instanceof EC))return new EC(options);// Shortcut `elliptic.ec(curve-name)`\nif(typeof options==='string'){assert$5(curves_1.hasOwnProperty(options),'Unknown curve '+options);options=curves_1[options];}// Shortcut for `elliptic.ec(elliptic.curves.curveName)`\nif(options instanceof curves_1.PresetCurve)options={curve:options};this.curve=options.curve.curve;this.n=this.curve.n;this.nh=this.n.ushrn(1);this.g=this.curve.g;// Point on curve\nthis.g=options.curve.g;this.g.precompute(options.curve.n.bitLength()+1);// Hash for function for DRBG\nthis.hash=options.hash||options.curve.hash;}var ec=EC;EC.prototype.keyPair=function keyPair(options){return new key(this,options);};EC.prototype.keyFromPrivate=function keyFromPrivate(priv,enc){return key.fromPrivate(this,priv,enc);};EC.prototype.keyFromPublic=function keyFromPublic(pub,enc){return key.fromPublic(this,pub,enc);};EC.prototype.genKeyPair=function genKeyPair(options){if(!options)options={};// Instantiate Hmac_DRBG\nvar drbg=new hmacDrbg({hash:this.hash,pers:options.pers,persEnc:options.persEnc||'utf8',entropy:options.entropy||brorand(this.hash.hmacStrength),entropyEnc:options.entropy&&options.entropyEnc||'utf8',nonce:this.n.toArray()});var bytes=this.n.byteLength();var ns2=this.n.sub(new bn$1(2));do{var priv=new bn$1(drbg.generate(bytes));if(priv.cmp(ns2)>0)continue;priv.iaddn(1);return this.keyFromPrivate(priv);}while(true);};EC.prototype._truncateToN=function truncateToN(msg,truncOnly){var delta=msg.byteLength()*8-this.n.bitLength();if(delta>0)msg=msg.ushrn(delta);if(!truncOnly&&msg.cmp(this.n)>=0)return msg.sub(this.n);else return msg;};EC.prototype.sign=function sign(msg,key,enc,options){if(_typeof(enc)==='object'){options=enc;enc=null;}if(!options)options={};key=this.keyFromPrivate(key,enc);msg=this._truncateToN(new bn$1(msg,16));// Zero-extend key to provide enough entropy\nvar bytes=this.n.byteLength();var bkey=key.getPrivate().toArray('be',bytes);// Zero-extend nonce to have the same byte size as N\nvar nonce=msg.toArray('be',bytes);// Instantiate Hmac_DRBG\nvar drbg=new hmacDrbg({hash:this.hash,entropy:bkey,nonce:nonce,pers:options.pers,persEnc:options.persEnc||'utf8'});// Number of bytes to generate\nvar ns1=this.n.sub(new bn$1(1));for(var iter=0;true;iter++){var k=options.k?options.k(iter):new bn$1(drbg.generate(this.n.byteLength()));k=this._truncateToN(k,true);if(k.cmpn(1)<=0||k.cmp(ns1)>=0)continue;var kp=this.g.mul(k);if(kp.isInfinity())continue;var kpX=kp.getX();var r=kpX.umod(this.n);if(r.cmpn(0)===0)continue;var s=k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));s=s.umod(this.n);if(s.cmpn(0)===0)continue;var recoveryParam=(kp.getY().isOdd()?1:0)|(kpX.cmp(r)!==0?2:0);// Use complement of `s`, if it is > `n / 2`\nif(options.canonical&&s.cmp(this.nh)>0){s=this.n.sub(s);recoveryParam^=1;}return new signature({r:r,s:s,recoveryParam:recoveryParam});}};EC.prototype.verify=function verify(msg,signature$1,key,enc){msg=this._truncateToN(new bn$1(msg,16));key=this.keyFromPublic(key,enc);signature$1=new signature(signature$1,'hex');// Perform primitive values validation\nvar r=signature$1.r;var s=signature$1.s;if(r.cmpn(1)<0||r.cmp(this.n)>=0)return false;if(s.cmpn(1)<0||s.cmp(this.n)>=0)return false;// Validate signature\nvar sinv=s.invm(this.n);var u1=sinv.mul(msg).umod(this.n);var u2=sinv.mul(r).umod(this.n);if(!this.curve._maxwellTrick){var p=this.g.mulAdd(u1,key.getPublic(),u2);if(p.isInfinity())return false;return p.getX().umod(this.n).cmp(r)===0;}// NOTE: Greg Maxwell's trick, inspired by:\n// https://git.io/vad3K\nvar p=this.g.jmulAdd(u1,key.getPublic(),u2);if(p.isInfinity())return false;// Compare `p.x` of Jacobian point with `r`,\n// this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the\n// inverse of `p.z^2`\nreturn p.eqXToP(r);};EC.prototype.recoverPubKey=function(msg,signature$1,j,enc){assert$5((3&j)===j,'The recovery param is more than two bits');signature$1=new signature(signature$1,enc);var n=this.n;var e=new bn$1(msg);var r=signature$1.r;var s=signature$1.s;// A set LSB signifies that the y-coordinate is odd\nvar isYOdd=j&1;var isSecondKey=j>>1;if(r.cmp(this.curve.p.umod(this.curve.n))>=0&&isSecondKey)throw new Error('Unable to find sencond key candinate');// 1.1. Let x = r + jn.\nif(isSecondKey)r=this.curve.pointFromX(r.add(this.curve.n),isYOdd);else r=this.curve.pointFromX(r,isYOdd);var rInv=signature$1.r.invm(n);var s1=n.sub(e).mul(rInv).umod(n);var s2=s.mul(rInv).umod(n);// 1.6.1 Compute Q = r^-1 (sR -  eG)\n//               Q = r^-1 (sR + -eG)\nreturn this.g.mulAdd(s1,r,s2);};EC.prototype.getKeyRecoveryParam=function(e,signature$1,Q,enc){signature$1=new signature(signature$1,enc);if(signature$1.recoveryParam!==null)return signature$1.recoveryParam;for(var i=0;i<4;i++){var Qprime;try{Qprime=this.recoverPubKey(e,signature$1,i);}catch(e){continue;}if(Qprime.eq(Q))return i;}throw new Error('Unable to find valid recovery factor');};var eddsa={};var require$$0$1=getCjsExportFromNamespace(_package$1);var elliptic_1=createCommonjsModule(function(module,exports){'use strict';var elliptic=exports;elliptic.version=require$$0$1.version;elliptic.utils=utils_1$1;elliptic.rand=brorand;elliptic.curve=curve_1;elliptic.curves=curves_1;// Protocols\nelliptic.ec=ec;elliptic.eddsa=eddsa;});var elliptic_2=elliptic_1.ec;var _version$q=createCommonjsModule(function(module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});exports.version=\"signing-key/5.0.3\";});var _version$r=unwrapExports(_version$q);var _version_1$d=_version$q.version;var lib$f=createCommonjsModule(function(module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});var logger=new lib.Logger(_version$q.version);var _curve=null;function getCurve(){if(!_curve){_curve=new elliptic_1.ec(\"secp256k1\");}return _curve;}var SigningKey=/** @class */function(){function SigningKey(privateKey){lib$3.defineReadOnly(this,\"curve\",\"secp256k1\");lib$3.defineReadOnly(this,\"privateKey\",lib$1.hexlify(privateKey));var keyPair=getCurve().keyFromPrivate(lib$1.arrayify(this.privateKey));lib$3.defineReadOnly(this,\"publicKey\",\"0x\"+keyPair.getPublic(false,\"hex\"));lib$3.defineReadOnly(this,\"compressedPublicKey\",\"0x\"+keyPair.getPublic(true,\"hex\"));lib$3.defineReadOnly(this,\"_isSigningKey\",true);}SigningKey.prototype._addPoint=function(other){var p0=getCurve().keyFromPublic(lib$1.arrayify(this.publicKey));var p1=getCurve().keyFromPublic(lib$1.arrayify(other));return\"0x\"+p0.pub.add(p1.pub).encodeCompressed(\"hex\");};SigningKey.prototype.signDigest=function(digest){var keyPair=getCurve().keyFromPrivate(lib$1.arrayify(this.privateKey));var signature=keyPair.sign(lib$1.arrayify(digest),{canonical:true});return lib$1.splitSignature({recoveryParam:signature.recoveryParam,r:lib$1.hexZeroPad(\"0x\"+signature.r.toString(16),32),s:lib$1.hexZeroPad(\"0x\"+signature.s.toString(16),32)});};SigningKey.prototype.computeSharedSecret=function(otherKey){var keyPair=getCurve().keyFromPrivate(lib$1.arrayify(this.privateKey));var otherKeyPair=getCurve().keyFromPublic(lib$1.arrayify(computePublicKey(otherKey)));return lib$1.hexZeroPad(\"0x\"+keyPair.derive(otherKeyPair.getPublic()).toString(16),32);};SigningKey.isSigningKey=function(value){return!!(value&&value._isSigningKey);};return SigningKey;}();exports.SigningKey=SigningKey;function recoverPublicKey(digest,signature){var sig=lib$1.splitSignature(signature);var rs={r:lib$1.arrayify(sig.r),s:lib$1.arrayify(sig.s)};return\"0x\"+getCurve().recoverPubKey(lib$1.arrayify(digest),rs,sig.recoveryParam).encode(\"hex\",false);}exports.recoverPublicKey=recoverPublicKey;function computePublicKey(key,compressed){var bytes=lib$1.arrayify(key);if(bytes.length===32){var signingKey=new SigningKey(bytes);if(compressed){return\"0x\"+getCurve().keyFromPrivate(bytes).getPublic(true,\"hex\");}return signingKey.publicKey;}else if(bytes.length===33){if(compressed){return lib$1.hexlify(bytes);}return\"0x\"+getCurve().keyFromPublic(bytes).getPublic(false,\"hex\");}else if(bytes.length===65){if(!compressed){return lib$1.hexlify(bytes);}return\"0x\"+getCurve().keyFromPublic(bytes).getPublic(true,\"hex\");}return logger.throwArgumentError(\"invalid public or private key\",\"key\",\"[REDACTED]\");}exports.computePublicKey=computePublicKey;});var index$f=unwrapExports(lib$f);var lib_1$f=lib$f.SigningKey;var lib_2$e=lib$f.recoverPublicKey;var lib_3$b=lib$f.computePublicKey;var _version$s=createCommonjsModule(function(module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});exports.version=\"transactions/5.0.2\";});var _version$t=unwrapExports(_version$s);var _version_1$e=_version$s.version;var lib$g=createCommonjsModule(function(module,exports){\"use strict\";var __importStar=commonjsGlobal&&commonjsGlobal.__importStar||function(mod){if(mod&&mod.__esModule)return mod;var result={};if(mod!=null)for(var k in mod){if(Object.hasOwnProperty.call(mod,k))result[k]=mod[k];}result[\"default\"]=mod;return result;};Object.defineProperty(exports,\"__esModule\",{value:true});var RLP=__importStar(lib$5);var logger=new lib.Logger(_version$s.version);///////////////////////////////\nfunction handleAddress(value){if(value===\"0x\"){return null;}return lib$6.getAddress(value);}function handleNumber(value){if(value===\"0x\"){return lib$7.Zero;}return lib$2.BigNumber.from(value);}var transactionFields=[{name:\"nonce\",maxLength:32,numeric:true},{name:\"gasPrice\",maxLength:32,numeric:true},{name:\"gasLimit\",maxLength:32,numeric:true},{name:\"to\",length:20},{name:\"value\",maxLength:32,numeric:true},{name:\"data\"}];var allowedTransactionKeys={chainId:true,data:true,gasLimit:true,gasPrice:true,nonce:true,to:true,value:true};function computeAddress(key){var publicKey=lib$f.computePublicKey(key);return lib$6.getAddress(lib$1.hexDataSlice(lib$4.keccak256(lib$1.hexDataSlice(publicKey,1)),12));}exports.computeAddress=computeAddress;function recoverAddress(digest,signature){return computeAddress(lib$f.recoverPublicKey(lib$1.arrayify(digest),signature));}exports.recoverAddress=recoverAddress;function serialize(transaction,signature){lib$3.checkProperties(transaction,allowedTransactionKeys);var raw=[];transactionFields.forEach(function(fieldInfo){var value=transaction[fieldInfo.name]||[];var options={};if(fieldInfo.numeric){options.hexPad=\"left\";}value=lib$1.arrayify(lib$1.hexlify(value,options));// Fixed-width field\nif(fieldInfo.length&&value.length!==fieldInfo.length&&value.length>0){logger.throwArgumentError(\"invalid length for \"+fieldInfo.name,\"transaction:\"+fieldInfo.name,value);}// Variable-width (with a maximum)\nif(fieldInfo.maxLength){value=lib$1.stripZeros(value);if(value.length>fieldInfo.maxLength){logger.throwArgumentError(\"invalid length for \"+fieldInfo.name,\"transaction:\"+fieldInfo.name,value);}}raw.push(lib$1.hexlify(value));});var chainId=0;if(transaction.chainId!=null){// A chainId was provided; if non-zero we'll use EIP-155\nchainId=transaction.chainId;if(typeof chainId!==\"number\"){logger.throwArgumentError(\"invalid transaction.chainId\",\"transaction\",transaction);}}else if(signature&&!lib$1.isBytesLike(signature)&&signature.v>28){// No chainId provided, but the signature is signing with EIP-155; derive chainId\nchainId=Math.floor((signature.v-35)/2);}// We have an EIP-155 transaction (chainId was specified and non-zero)\nif(chainId!==0){raw.push(lib$1.hexlify(chainId));raw.push(\"0x\");raw.push(\"0x\");}// Requesting an unsigned transation\nif(!signature){return RLP.encode(raw);}// The splitSignature will ensure the transaction has a recoveryParam in the\n// case that the signTransaction function only adds a v.\nvar sig=lib$1.splitSignature(signature);// We pushed a chainId and null r, s on for hashing only; remove those\nvar v=27+sig.recoveryParam;if(chainId!==0){raw.pop();raw.pop();raw.pop();v+=chainId*2+8;// If an EIP-155 v (directly or indirectly; maybe _vs) was provided, check it!\nif(sig.v>28&&sig.v!==v){logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\",\"signature\",signature);}}else if(sig.v!==v){logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\",\"signature\",signature);}raw.push(lib$1.hexlify(v));raw.push(lib$1.stripZeros(lib$1.arrayify(sig.r)));raw.push(lib$1.stripZeros(lib$1.arrayify(sig.s)));return RLP.encode(raw);}exports.serialize=serialize;function parse(rawTransaction){var transaction=RLP.decode(rawTransaction);if(transaction.length!==9&&transaction.length!==6){logger.throwArgumentError(\"invalid raw transaction\",\"rawTransaction\",rawTransaction);}var tx={nonce:handleNumber(transaction[0]).toNumber(),gasPrice:handleNumber(transaction[1]),gasLimit:handleNumber(transaction[2]),to:handleAddress(transaction[3]),value:handleNumber(transaction[4]),data:transaction[5],chainId:0};// Legacy unsigned transaction\nif(transaction.length===6){return tx;}try{tx.v=lib$2.BigNumber.from(transaction[6]).toNumber();}catch(error){console.log(error);return tx;}tx.r=lib$1.hexZeroPad(transaction[7],32);tx.s=lib$1.hexZeroPad(transaction[8],32);if(lib$2.BigNumber.from(tx.r).isZero()&&lib$2.BigNumber.from(tx.s).isZero()){// EIP-155 unsigned transaction\ntx.chainId=tx.v;tx.v=0;}else{// Signed Tranasaction\ntx.chainId=Math.floor((tx.v-35)/2);if(tx.chainId<0){tx.chainId=0;}var recoveryParam=tx.v-27;var raw=transaction.slice(0,6);if(tx.chainId!==0){raw.push(lib$1.hexlify(tx.chainId));raw.push(\"0x\");raw.push(\"0x\");recoveryParam-=tx.chainId*2+8;}var digest=lib$4.keccak256(RLP.encode(raw));try{tx.from=recoverAddress(digest,{r:lib$1.hexlify(tx.r),s:lib$1.hexlify(tx.s),recoveryParam:recoveryParam});}catch(error){console.log(error);}tx.hash=lib$4.keccak256(rawTransaction);}return tx;}exports.parse=parse;});var index$g=unwrapExports(lib$g);var lib_1$g=lib$g.computeAddress;var lib_2$f=lib$g.recoverAddress;var lib_3$c=lib$g.serialize;var lib_4$9=lib$g.parse;var _version$u=createCommonjsModule(function(module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});exports.version=\"wordlists/5.0.2\";});var _version$v=unwrapExports(_version$u);var _version_1$f=_version$u.version;var wordlist=createCommonjsModule(function(module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});// This gets overridden by rollup\nvar exportWordlist=false;exports.logger=new lib.Logger(_version$u.version);var Wordlist=/** @class */function(){function Wordlist(locale){var _newTarget=this.constructor;exports.logger.checkAbstract(_newTarget,Wordlist);lib$3.defineReadOnly(this,\"locale\",locale);}// Subclasses may override this\nWordlist.prototype.split=function(mnemonic){return mnemonic.toLowerCase().split(/ +/g);};// Subclasses may override this\nWordlist.prototype.join=function(words){return words.join(\" \");};Wordlist.check=function(wordlist){var words=[];for(var i=0;i<2048;i++){var word=wordlist.getWord(i);/* istanbul ignore if */if(i!==wordlist.getWordIndex(word)){return\"0x\";}words.push(word);}return lib$9.id(words.join(\"\\n\")+\"\\n\");};Wordlist.register=function(lang,name){if(!name){name=lang.locale;}/* istanbul ignore if */if(exportWordlist){try{var anyGlobal=window;if(anyGlobal._ethers&&anyGlobal._ethers.wordlists){if(!anyGlobal._ethers.wordlists[name]){lib$3.defineReadOnly(anyGlobal._ethers.wordlists,name,lang);}}}catch(error){}}};return Wordlist;}();exports.Wordlist=Wordlist;});var wordlist$1=unwrapExports(wordlist);var wordlist_1=wordlist.logger;var wordlist_2=wordlist.Wordlist;var langEn_1=createCommonjsModule(function(module,exports){\"use strict\";var __extends=commonjsGlobal&&commonjsGlobal.__extends||function(){var _extendStatics16=function extendStatics(d,b){_extendStatics16=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return _extendStatics16(d,b);};return function(d,b){_extendStatics16(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,\"__esModule\",{value:true});var words=\"AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo\";var wordlist$1=null;function loadWords(lang){if(wordlist$1!=null){return;}wordlist$1=words.replace(/([A-Z])/g,\" $1\").toLowerCase().substring(1).split(\" \");// Verify the computed list matches the official list\n/* istanbul ignore if */if(wordlist.Wordlist.check(lang)!==\"0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60\"){wordlist$1=null;throw new Error(\"BIP39 Wordlist for en (English) FAILED\");}}var LangEn=/** @class */function(_super){__extends(LangEn,_super);function LangEn(){return _super.call(this,\"en\")||this;}LangEn.prototype.getWord=function(index){loadWords(this);return wordlist$1[index];};LangEn.prototype.getWordIndex=function(word){loadWords(this);return wordlist$1.indexOf(word);};return LangEn;}(wordlist.Wordlist);var langEn=new LangEn();exports.langEn=langEn;wordlist.Wordlist.register(langEn);});var langEn=unwrapExports(langEn_1);var langEn_2=langEn_1.langEn;var browser$4=createCommonjsModule(function(module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});// Wordlists\n// See: https://github.com/bitcoin/bips/blob/master/bip-0039/bip-0039-wordlists.md\nexports.Wordlist=wordlist.Wordlist;var wordlists={en:langEn_1.langEn};exports.wordlists=wordlists;});var browser$5=unwrapExports(browser$4);var browser_1$2=browser$4.Wordlist;var browser_2$1=browser$4.wordlists;var _version$w=createCommonjsModule(function(module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});exports.version=\"hdnode/5.0.2\";});var _version$x=unwrapExports(_version$w);var _version_1$g=_version$w.version;var lib$h=createCommonjsModule(function(module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});var logger=new lib.Logger(_version$w.version);var N=lib$2.BigNumber.from(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");// \"Bitcoin seed\"\nvar MasterSecret=lib$8.toUtf8Bytes(\"Bitcoin seed\");var HardenedBit=0x80000000;// Returns a byte with the MSB bits set\nfunction getUpperMask(bits){return(1<<bits)-1<<8-bits;}// Returns a byte with the LSB bits set\nfunction getLowerMask(bits){return(1<<bits)-1;}function bytes32(value){return lib$1.hexZeroPad(lib$1.hexlify(value),32);}function base58check(data){return lib$e.Base58.encode(lib$1.concat([data,lib$1.hexDataSlice(browser.sha256(browser.sha256(data)),0,4)]));}function getWordlist(wordlist){if(wordlist==null){return browser$4.wordlists[\"en\"];}if(typeof wordlist===\"string\"){var words=browser$4.wordlists[wordlist];if(words==null){logger.throwArgumentError(\"unknown locale\",\"wordlist\",wordlist);}return words;}return wordlist;}var _constructorGuard={};exports.defaultPath=\"m/44'/60'/0'/0/0\";;var HDNode=/** @class */function(){/**\n\t     *  This constructor should not be called directly.\n\t     *\n\t     *  Please use:\n\t     *   - fromMnemonic\n\t     *   - fromSeed\n\t     */function HDNode(constructorGuard,privateKey,publicKey,parentFingerprint,chainCode,index,depth,mnemonicOrPath){var _newTarget=this.constructor;logger.checkNew(_newTarget,HDNode);/* istanbul ignore if */if(constructorGuard!==_constructorGuard){throw new Error(\"HDNode constructor cannot be called directly\");}if(privateKey){var signingKey=new lib$f.SigningKey(privateKey);lib$3.defineReadOnly(this,\"privateKey\",signingKey.privateKey);lib$3.defineReadOnly(this,\"publicKey\",signingKey.compressedPublicKey);}else{lib$3.defineReadOnly(this,\"privateKey\",null);lib$3.defineReadOnly(this,\"publicKey\",lib$1.hexlify(publicKey));}lib$3.defineReadOnly(this,\"parentFingerprint\",parentFingerprint);lib$3.defineReadOnly(this,\"fingerprint\",lib$1.hexDataSlice(browser.ripemd160(browser.sha256(this.publicKey)),0,4));lib$3.defineReadOnly(this,\"address\",lib$g.computeAddress(this.publicKey));lib$3.defineReadOnly(this,\"chainCode\",chainCode);lib$3.defineReadOnly(this,\"index\",index);lib$3.defineReadOnly(this,\"depth\",depth);if(mnemonicOrPath==null){// From a source that does not preserve the path (e.g. extended keys)\nlib$3.defineReadOnly(this,\"mnemonic\",null);lib$3.defineReadOnly(this,\"path\",null);}else if(typeof mnemonicOrPath===\"string\"){// From a source that does not preserve the mnemonic (e.g. neutered)\nlib$3.defineReadOnly(this,\"mnemonic\",null);lib$3.defineReadOnly(this,\"path\",mnemonicOrPath);}else{// From a fully qualified source\nlib$3.defineReadOnly(this,\"mnemonic\",mnemonicOrPath);lib$3.defineReadOnly(this,\"path\",mnemonicOrPath.path);}}Object.defineProperty(HDNode.prototype,\"extendedKey\",{get:function get(){// We only support the mainnet values for now, but if anyone needs\n// testnet values, let me know. I believe current senitment is that\n// we should always use mainnet, and use BIP-44 to derive the network\n//   - Mainnet: public=0x0488B21E, private=0x0488ADE4\n//   - Testnet: public=0x043587CF, private=0x04358394\nif(this.depth>=256){throw new Error(\"Depth too large!\");}return base58check(lib$1.concat([this.privateKey!=null?\"0x0488ADE4\":\"0x0488B21E\",lib$1.hexlify(this.depth),this.parentFingerprint,lib$1.hexZeroPad(lib$1.hexlify(this.index),4),this.chainCode,this.privateKey!=null?lib$1.concat([\"0x00\",this.privateKey]):this.publicKey]));},enumerable:true,configurable:true});HDNode.prototype.neuter=function(){return new HDNode(_constructorGuard,null,this.publicKey,this.parentFingerprint,this.chainCode,this.index,this.depth,this.path);};HDNode.prototype._derive=function(index){if(index>0xffffffff){throw new Error(\"invalid index - \"+String(index));}// Base path\nvar path=this.path;if(path){path+=\"/\"+(index&~HardenedBit);}var data=new Uint8Array(37);if(index&HardenedBit){if(!this.privateKey){throw new Error(\"cannot derive child of neutered node\");}// Data = 0x00 || ser_256(k_par)\ndata.set(lib$1.arrayify(this.privateKey),1);// Hardened path\nif(path){path+=\"'\";}}else{// Data = ser_p(point(k_par))\ndata.set(lib$1.arrayify(this.publicKey));}// Data += ser_32(i)\nfor(var i=24;i>=0;i-=8){data[33+(i>>3)]=index>>24-i&0xff;}var I=lib$1.arrayify(browser.computeHmac(browser.SupportedAlgorithm.sha512,this.chainCode,data));var IL=I.slice(0,32);var IR=I.slice(32);// The private key\nvar ki=null;// The public key\nvar Ki=null;if(this.privateKey){ki=bytes32(lib$2.BigNumber.from(IL).add(this.privateKey).mod(N));}else{var ek=new lib$f.SigningKey(lib$1.hexlify(IL));Ki=ek._addPoint(this.publicKey);}var mnemonicOrPath=path;var srcMnemonic=this.mnemonic;if(srcMnemonic){mnemonicOrPath=Object.freeze({phrase:srcMnemonic.phrase,path:path,locale:srcMnemonic.locale||\"en\"});}return new HDNode(_constructorGuard,ki,Ki,this.fingerprint,bytes32(IR),index,this.depth+1,mnemonicOrPath);};HDNode.prototype.derivePath=function(path){var components=path.split(\"/\");if(components.length===0||components[0]===\"m\"&&this.depth!==0){throw new Error(\"invalid path - \"+path);}if(components[0]===\"m\"){components.shift();}var result=this;for(var i=0;i<components.length;i++){var component=components[i];if(component.match(/^[0-9]+'$/)){var index=parseInt(component.substring(0,component.length-1));if(index>=HardenedBit){throw new Error(\"invalid path index - \"+component);}result=result._derive(HardenedBit+index);}else if(component.match(/^[0-9]+$/)){var index=parseInt(component);if(index>=HardenedBit){throw new Error(\"invalid path index - \"+component);}result=result._derive(index);}else{throw new Error(\"invalid path component - \"+component);}}return result;};HDNode._fromSeed=function(seed,mnemonic){var seedArray=lib$1.arrayify(seed);if(seedArray.length<16||seedArray.length>64){throw new Error(\"invalid seed\");}var I=lib$1.arrayify(browser.computeHmac(browser.SupportedAlgorithm.sha512,MasterSecret,seedArray));return new HDNode(_constructorGuard,bytes32(I.slice(0,32)),null,\"0x00000000\",bytes32(I.slice(32)),0,0,mnemonic);};HDNode.fromMnemonic=function(mnemonic,password,wordlist){// If a locale name was passed in, find the associated wordlist\nwordlist=getWordlist(wordlist);// Normalize the case and spacing in the mnemonic (throws if the mnemonic is invalid)\nmnemonic=entropyToMnemonic(mnemonicToEntropy(mnemonic,wordlist),wordlist);return HDNode._fromSeed(mnemonicToSeed(mnemonic,password),{phrase:mnemonic,path:\"m\",locale:wordlist.locale});};HDNode.fromSeed=function(seed){return HDNode._fromSeed(seed,null);};HDNode.fromExtendedKey=function(extendedKey){var bytes=lib$e.Base58.decode(extendedKey);if(bytes.length!==82||base58check(bytes.slice(0,78))!==extendedKey){logger.throwArgumentError(\"invalid extended key\",\"extendedKey\",\"[REDACTED]\");}var depth=bytes[4];var parentFingerprint=lib$1.hexlify(bytes.slice(5,9));var index=parseInt(lib$1.hexlify(bytes.slice(9,13)).substring(2),16);var chainCode=lib$1.hexlify(bytes.slice(13,45));var key=bytes.slice(45,78);switch(lib$1.hexlify(bytes.slice(0,4))){// Public Key\ncase\"0x0488b21e\":case\"0x043587cf\":return new HDNode(_constructorGuard,null,lib$1.hexlify(key),parentFingerprint,chainCode,index,depth,null);// Private Key\ncase\"0x0488ade4\":case\"0x04358394 \":if(key[0]!==0){break;}return new HDNode(_constructorGuard,lib$1.hexlify(key.slice(1)),null,parentFingerprint,chainCode,index,depth,null);}return logger.throwArgumentError(\"invalid extended key\",\"extendedKey\",\"[REDACTED]\");};return HDNode;}();exports.HDNode=HDNode;function mnemonicToSeed(mnemonic,password){if(!password){password=\"\";}var salt=lib$8.toUtf8Bytes(\"mnemonic\"+password,lib$8.UnicodeNormalizationForm.NFKD);return browser$2.pbkdf2(lib$8.toUtf8Bytes(mnemonic,lib$8.UnicodeNormalizationForm.NFKD),salt,2048,64,\"sha512\");}exports.mnemonicToSeed=mnemonicToSeed;function mnemonicToEntropy(mnemonic,wordlist){wordlist=getWordlist(wordlist);logger.checkNormalize();var words=wordlist.split(mnemonic);if(words.length%3!==0){throw new Error(\"invalid mnemonic\");}var entropy=lib$1.arrayify(new Uint8Array(Math.ceil(11*words.length/8)));var offset=0;for(var i=0;i<words.length;i++){var index=wordlist.getWordIndex(words[i].normalize(\"NFKD\"));if(index===-1){throw new Error(\"invalid mnemonic\");}for(var bit=0;bit<11;bit++){if(index&1<<10-bit){entropy[offset>>3]|=1<<7-offset%8;}offset++;}}var entropyBits=32*words.length/3;var checksumBits=words.length/3;var checksumMask=getUpperMask(checksumBits);var checksum=lib$1.arrayify(browser.sha256(entropy.slice(0,entropyBits/8)))[0]&checksumMask;if(checksum!==(entropy[entropy.length-1]&checksumMask)){throw new Error(\"invalid checksum\");}return lib$1.hexlify(entropy.slice(0,entropyBits/8));}exports.mnemonicToEntropy=mnemonicToEntropy;function entropyToMnemonic(entropy,wordlist){wordlist=getWordlist(wordlist);entropy=lib$1.arrayify(entropy);if(entropy.length%4!==0||entropy.length<16||entropy.length>32){throw new Error(\"invalid entropy\");}var indices=[0];var remainingBits=11;for(var i=0;i<entropy.length;i++){// Consume the whole byte (with still more to go)\nif(remainingBits>8){indices[indices.length-1]<<=8;indices[indices.length-1]|=entropy[i];remainingBits-=8;// This byte will complete an 11-bit index\n}else{indices[indices.length-1]<<=remainingBits;indices[indices.length-1]|=entropy[i]>>8-remainingBits;// Start the next word\nindices.push(entropy[i]&getLowerMask(8-remainingBits));remainingBits+=3;}}// Compute the checksum bits\nvar checksumBits=entropy.length/4;var checksum=lib$1.arrayify(browser.sha256(entropy))[0]&getUpperMask(checksumBits);// Shift the checksum into the word indices\nindices[indices.length-1]<<=checksumBits;indices[indices.length-1]|=checksum>>8-checksumBits;return wordlist.join(indices.map(function(index){return wordlist.getWord(index);}));}exports.entropyToMnemonic=entropyToMnemonic;function isValidMnemonic(mnemonic,wordlist){try{mnemonicToEntropy(mnemonic,wordlist);return true;}catch(error){}return false;}exports.isValidMnemonic=isValidMnemonic;});var index$h=unwrapExports(lib$h);var lib_1$h=lib$h.defaultPath;var lib_2$g=lib$h.HDNode;var lib_3$d=lib$h.mnemonicToSeed;var lib_4$a=lib$h.mnemonicToEntropy;var lib_5$9=lib$h.entropyToMnemonic;var lib_6$5=lib$h.isValidMnemonic;var _version$y=createCommonjsModule(function(module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});exports.version=\"random/5.0.2\";});var _version$z=unwrapExports(_version$y);var _version_1$h=_version$y.version;var shuffle=createCommonjsModule(function(module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});function shuffled(array){array=array.slice();for(var i=array.length-1;i>0;i--){var j=Math.floor(Math.random()*(i+1));var tmp=array[i];array[i]=array[j];array[j]=tmp;}return array;}exports.shuffled=shuffled;});var shuffle$1=unwrapExports(shuffle);var shuffle_1=shuffle.shuffled;var browser$6=createCommonjsModule(function(module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});var logger=new lib.Logger(_version$y.version);exports.shuffled=shuffle.shuffled;var anyGlobal=null;try{anyGlobal=window;if(anyGlobal==null){throw new Error(\"try next\");}}catch(error){try{anyGlobal=commonjsGlobal;if(anyGlobal==null){throw new Error(\"try next\");}}catch(error){anyGlobal={};}}var crypto=anyGlobal.crypto||anyGlobal.msCrypto;if(!crypto||!crypto.getRandomValues){logger.warn(\"WARNING: Missing strong random number source\");crypto={getRandomValues:function getRandomValues(buffer){return logger.throwError(\"no secure random source avaialble\",lib.Logger.errors.UNSUPPORTED_OPERATION,{operation:\"crypto.getRandomValues\"});}};}function randomBytes(length){if(length<=0||length>1024||length%1){logger.throwArgumentError(\"invalid length\",\"length\",length);}var result=new Uint8Array(length);crypto.getRandomValues(result);return lib$1.arrayify(result);}exports.randomBytes=randomBytes;;});var browser$7=unwrapExports(browser$6);var browser_1$3=browser$6.shuffled;var browser_2$2=browser$6.randomBytes;var aesJs=createCommonjsModule(function(module,exports){\"use strict\";(function(root){function checkInt(value){return parseInt(value)===value;}function checkInts(arrayish){if(!checkInt(arrayish.length)){return false;}for(var i=0;i<arrayish.length;i++){if(!checkInt(arrayish[i])||arrayish[i]<0||arrayish[i]>255){return false;}}return true;}function coerceArray(arg,copy){// ArrayBuffer view\nif(arg.buffer&&ArrayBuffer.isView(arg)&&arg.name==='Uint8Array'){if(copy){if(arg.slice){arg=arg.slice();}else{arg=Array.prototype.slice.call(arg);}}return arg;}// It's an array; check it is a valid representation of a byte\nif(Array.isArray(arg)){if(!checkInts(arg)){throw new Error('Array contains invalid value: '+arg);}return new Uint8Array(arg);}// Something else, but behaves like an array (maybe a Buffer? Arguments?)\nif(checkInt(arg.length)&&checkInts(arg)){return new Uint8Array(arg);}throw new Error('unsupported array-like object');}function createArray(length){return new Uint8Array(length);}function copyArray(sourceArray,targetArray,targetStart,sourceStart,sourceEnd){if(sourceStart!=null||sourceEnd!=null){if(sourceArray.slice){sourceArray=sourceArray.slice(sourceStart,sourceEnd);}else{sourceArray=Array.prototype.slice.call(sourceArray,sourceStart,sourceEnd);}}targetArray.set(sourceArray,targetStart);}var convertUtf8=function(){function toBytes(text){var result=[],i=0;text=encodeURI(text);while(i<text.length){var c=text.charCodeAt(i++);// if it is a % sign, encode the following 2 bytes as a hex value\nif(c===37){result.push(parseInt(text.substr(i,2),16));i+=2;// otherwise, just the actual byte\n}else{result.push(c);}}return coerceArray(result);}function fromBytes(bytes){var result=[],i=0;while(i<bytes.length){var c=bytes[i];if(c<128){result.push(String.fromCharCode(c));i++;}else if(c>191&&c<224){result.push(String.fromCharCode((c&0x1f)<<6|bytes[i+1]&0x3f));i+=2;}else{result.push(String.fromCharCode((c&0x0f)<<12|(bytes[i+1]&0x3f)<<6|bytes[i+2]&0x3f));i+=3;}}return result.join('');}return{toBytes:toBytes,fromBytes:fromBytes};}();var convertHex=function(){function toBytes(text){var result=[];for(var i=0;i<text.length;i+=2){result.push(parseInt(text.substr(i,2),16));}return result;}// http://ixti.net/development/javascript/2011/11/11/base64-encodedecode-of-utf8-in-browser-with-js.html\nvar Hex='0123456789abcdef';function fromBytes(bytes){var result=[];for(var i=0;i<bytes.length;i++){var v=bytes[i];result.push(Hex[(v&0xf0)>>4]+Hex[v&0x0f]);}return result.join('');}return{toBytes:toBytes,fromBytes:fromBytes};}();// Number of rounds by keysize\nvar numberOfRounds={16:10,24:12,32:14};// Round constant words\nvar rcon=[0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x1b,0x36,0x6c,0xd8,0xab,0x4d,0x9a,0x2f,0x5e,0xbc,0x63,0xc6,0x97,0x35,0x6a,0xd4,0xb3,0x7d,0xfa,0xef,0xc5,0x91];// S-box and Inverse S-box (S is for Substitution)\nvar S=[0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76,0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0,0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15,0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75,0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84,0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf,0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8,0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2,0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73,0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb,0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79,0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08,0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a,0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e,0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf,0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16];var Si=[0x52,0x09,0x6a,0xd5,0x30,0x36,0xa5,0x38,0xbf,0x40,0xa3,0x9e,0x81,0xf3,0xd7,0xfb,0x7c,0xe3,0x39,0x82,0x9b,0x2f,0xff,0x87,0x34,0x8e,0x43,0x44,0xc4,0xde,0xe9,0xcb,0x54,0x7b,0x94,0x32,0xa6,0xc2,0x23,0x3d,0xee,0x4c,0x95,0x0b,0x42,0xfa,0xc3,0x4e,0x08,0x2e,0xa1,0x66,0x28,0xd9,0x24,0xb2,0x76,0x5b,0xa2,0x49,0x6d,0x8b,0xd1,0x25,0x72,0xf8,0xf6,0x64,0x86,0x68,0x98,0x16,0xd4,0xa4,0x5c,0xcc,0x5d,0x65,0xb6,0x92,0x6c,0x70,0x48,0x50,0xfd,0xed,0xb9,0xda,0x5e,0x15,0x46,0x57,0xa7,0x8d,0x9d,0x84,0x90,0xd8,0xab,0x00,0x8c,0xbc,0xd3,0x0a,0xf7,0xe4,0x58,0x05,0xb8,0xb3,0x45,0x06,0xd0,0x2c,0x1e,0x8f,0xca,0x3f,0x0f,0x02,0xc1,0xaf,0xbd,0x03,0x01,0x13,0x8a,0x6b,0x3a,0x91,0x11,0x41,0x4f,0x67,0xdc,0xea,0x97,0xf2,0xcf,0xce,0xf0,0xb4,0xe6,0x73,0x96,0xac,0x74,0x22,0xe7,0xad,0x35,0x85,0xe2,0xf9,0x37,0xe8,0x1c,0x75,0xdf,0x6e,0x47,0xf1,0x1a,0x71,0x1d,0x29,0xc5,0x89,0x6f,0xb7,0x62,0x0e,0xaa,0x18,0xbe,0x1b,0xfc,0x56,0x3e,0x4b,0xc6,0xd2,0x79,0x20,0x9a,0xdb,0xc0,0xfe,0x78,0xcd,0x5a,0xf4,0x1f,0xdd,0xa8,0x33,0x88,0x07,0xc7,0x31,0xb1,0x12,0x10,0x59,0x27,0x80,0xec,0x5f,0x60,0x51,0x7f,0xa9,0x19,0xb5,0x4a,0x0d,0x2d,0xe5,0x7a,0x9f,0x93,0xc9,0x9c,0xef,0xa0,0xe0,0x3b,0x4d,0xae,0x2a,0xf5,0xb0,0xc8,0xeb,0xbb,0x3c,0x83,0x53,0x99,0x61,0x17,0x2b,0x04,0x7e,0xba,0x77,0xd6,0x26,0xe1,0x69,0x14,0x63,0x55,0x21,0x0c,0x7d];// Transformations for encryption\nvar T1=[0xc66363a5,0xf87c7c84,0xee777799,0xf67b7b8d,0xfff2f20d,0xd66b6bbd,0xde6f6fb1,0x91c5c554,0x60303050,0x02010103,0xce6767a9,0x562b2b7d,0xe7fefe19,0xb5d7d762,0x4dababe6,0xec76769a,0x8fcaca45,0x1f82829d,0x89c9c940,0xfa7d7d87,0xeffafa15,0xb25959eb,0x8e4747c9,0xfbf0f00b,0x41adadec,0xb3d4d467,0x5fa2a2fd,0x45afafea,0x239c9cbf,0x53a4a4f7,0xe4727296,0x9bc0c05b,0x75b7b7c2,0xe1fdfd1c,0x3d9393ae,0x4c26266a,0x6c36365a,0x7e3f3f41,0xf5f7f702,0x83cccc4f,0x6834345c,0x51a5a5f4,0xd1e5e534,0xf9f1f108,0xe2717193,0xabd8d873,0x62313153,0x2a15153f,0x0804040c,0x95c7c752,0x46232365,0x9dc3c35e,0x30181828,0x379696a1,0x0a05050f,0x2f9a9ab5,0x0e070709,0x24121236,0x1b80809b,0xdfe2e23d,0xcdebeb26,0x4e272769,0x7fb2b2cd,0xea75759f,0x1209091b,0x1d83839e,0x582c2c74,0x341a1a2e,0x361b1b2d,0xdc6e6eb2,0xb45a5aee,0x5ba0a0fb,0xa45252f6,0x763b3b4d,0xb7d6d661,0x7db3b3ce,0x5229297b,0xdde3e33e,0x5e2f2f71,0x13848497,0xa65353f5,0xb9d1d168,0x00000000,0xc1eded2c,0x40202060,0xe3fcfc1f,0x79b1b1c8,0xb65b5bed,0xd46a6abe,0x8dcbcb46,0x67bebed9,0x7239394b,0x944a4ade,0x984c4cd4,0xb05858e8,0x85cfcf4a,0xbbd0d06b,0xc5efef2a,0x4faaaae5,0xedfbfb16,0x864343c5,0x9a4d4dd7,0x66333355,0x11858594,0x8a4545cf,0xe9f9f910,0x04020206,0xfe7f7f81,0xa05050f0,0x783c3c44,0x259f9fba,0x4ba8a8e3,0xa25151f3,0x5da3a3fe,0x804040c0,0x058f8f8a,0x3f9292ad,0x219d9dbc,0x70383848,0xf1f5f504,0x63bcbcdf,0x77b6b6c1,0xafdada75,0x42212163,0x20101030,0xe5ffff1a,0xfdf3f30e,0xbfd2d26d,0x81cdcd4c,0x180c0c14,0x26131335,0xc3ecec2f,0xbe5f5fe1,0x359797a2,0x884444cc,0x2e171739,0x93c4c457,0x55a7a7f2,0xfc7e7e82,0x7a3d3d47,0xc86464ac,0xba5d5de7,0x3219192b,0xe6737395,0xc06060a0,0x19818198,0x9e4f4fd1,0xa3dcdc7f,0x44222266,0x542a2a7e,0x3b9090ab,0x0b888883,0x8c4646ca,0xc7eeee29,0x6bb8b8d3,0x2814143c,0xa7dede79,0xbc5e5ee2,0x160b0b1d,0xaddbdb76,0xdbe0e03b,0x64323256,0x743a3a4e,0x140a0a1e,0x924949db,0x0c06060a,0x4824246c,0xb85c5ce4,0x9fc2c25d,0xbdd3d36e,0x43acacef,0xc46262a6,0x399191a8,0x319595a4,0xd3e4e437,0xf279798b,0xd5e7e732,0x8bc8c843,0x6e373759,0xda6d6db7,0x018d8d8c,0xb1d5d564,0x9c4e4ed2,0x49a9a9e0,0xd86c6cb4,0xac5656fa,0xf3f4f407,0xcfeaea25,0xca6565af,0xf47a7a8e,0x47aeaee9,0x10080818,0x6fbabad5,0xf0787888,0x4a25256f,0x5c2e2e72,0x381c1c24,0x57a6a6f1,0x73b4b4c7,0x97c6c651,0xcbe8e823,0xa1dddd7c,0xe874749c,0x3e1f1f21,0x964b4bdd,0x61bdbddc,0x0d8b8b86,0x0f8a8a85,0xe0707090,0x7c3e3e42,0x71b5b5c4,0xcc6666aa,0x904848d8,0x06030305,0xf7f6f601,0x1c0e0e12,0xc26161a3,0x6a35355f,0xae5757f9,0x69b9b9d0,0x17868691,0x99c1c158,0x3a1d1d27,0x279e9eb9,0xd9e1e138,0xebf8f813,0x2b9898b3,0x22111133,0xd26969bb,0xa9d9d970,0x078e8e89,0x339494a7,0x2d9b9bb6,0x3c1e1e22,0x15878792,0xc9e9e920,0x87cece49,0xaa5555ff,0x50282878,0xa5dfdf7a,0x038c8c8f,0x59a1a1f8,0x09898980,0x1a0d0d17,0x65bfbfda,0xd7e6e631,0x844242c6,0xd06868b8,0x824141c3,0x299999b0,0x5a2d2d77,0x1e0f0f11,0x7bb0b0cb,0xa85454fc,0x6dbbbbd6,0x2c16163a];var T2=[0xa5c66363,0x84f87c7c,0x99ee7777,0x8df67b7b,0x0dfff2f2,0xbdd66b6b,0xb1de6f6f,0x5491c5c5,0x50603030,0x03020101,0xa9ce6767,0x7d562b2b,0x19e7fefe,0x62b5d7d7,0xe64dabab,0x9aec7676,0x458fcaca,0x9d1f8282,0x4089c9c9,0x87fa7d7d,0x15effafa,0xebb25959,0xc98e4747,0x0bfbf0f0,0xec41adad,0x67b3d4d4,0xfd5fa2a2,0xea45afaf,0xbf239c9c,0xf753a4a4,0x96e47272,0x5b9bc0c0,0xc275b7b7,0x1ce1fdfd,0xae3d9393,0x6a4c2626,0x5a6c3636,0x417e3f3f,0x02f5f7f7,0x4f83cccc,0x5c683434,0xf451a5a5,0x34d1e5e5,0x08f9f1f1,0x93e27171,0x73abd8d8,0x53623131,0x3f2a1515,0x0c080404,0x5295c7c7,0x65462323,0x5e9dc3c3,0x28301818,0xa1379696,0x0f0a0505,0xb52f9a9a,0x090e0707,0x36241212,0x9b1b8080,0x3ddfe2e2,0x26cdebeb,0x694e2727,0xcd7fb2b2,0x9fea7575,0x1b120909,0x9e1d8383,0x74582c2c,0x2e341a1a,0x2d361b1b,0xb2dc6e6e,0xeeb45a5a,0xfb5ba0a0,0xf6a45252,0x4d763b3b,0x61b7d6d6,0xce7db3b3,0x7b522929,0x3edde3e3,0x715e2f2f,0x97138484,0xf5a65353,0x68b9d1d1,0x00000000,0x2cc1eded,0x60402020,0x1fe3fcfc,0xc879b1b1,0xedb65b5b,0xbed46a6a,0x468dcbcb,0xd967bebe,0x4b723939,0xde944a4a,0xd4984c4c,0xe8b05858,0x4a85cfcf,0x6bbbd0d0,0x2ac5efef,0xe54faaaa,0x16edfbfb,0xc5864343,0xd79a4d4d,0x55663333,0x94118585,0xcf8a4545,0x10e9f9f9,0x06040202,0x81fe7f7f,0xf0a05050,0x44783c3c,0xba259f9f,0xe34ba8a8,0xf3a25151,0xfe5da3a3,0xc0804040,0x8a058f8f,0xad3f9292,0xbc219d9d,0x48703838,0x04f1f5f5,0xdf63bcbc,0xc177b6b6,0x75afdada,0x63422121,0x30201010,0x1ae5ffff,0x0efdf3f3,0x6dbfd2d2,0x4c81cdcd,0x14180c0c,0x35261313,0x2fc3ecec,0xe1be5f5f,0xa2359797,0xcc884444,0x392e1717,0x5793c4c4,0xf255a7a7,0x82fc7e7e,0x477a3d3d,0xacc86464,0xe7ba5d5d,0x2b321919,0x95e67373,0xa0c06060,0x98198181,0xd19e4f4f,0x7fa3dcdc,0x66442222,0x7e542a2a,0xab3b9090,0x830b8888,0xca8c4646,0x29c7eeee,0xd36bb8b8,0x3c281414,0x79a7dede,0xe2bc5e5e,0x1d160b0b,0x76addbdb,0x3bdbe0e0,0x56643232,0x4e743a3a,0x1e140a0a,0xdb924949,0x0a0c0606,0x6c482424,0xe4b85c5c,0x5d9fc2c2,0x6ebdd3d3,0xef43acac,0xa6c46262,0xa8399191,0xa4319595,0x37d3e4e4,0x8bf27979,0x32d5e7e7,0x438bc8c8,0x596e3737,0xb7da6d6d,0x8c018d8d,0x64b1d5d5,0xd29c4e4e,0xe049a9a9,0xb4d86c6c,0xfaac5656,0x07f3f4f4,0x25cfeaea,0xafca6565,0x8ef47a7a,0xe947aeae,0x18100808,0xd56fbaba,0x88f07878,0x6f4a2525,0x725c2e2e,0x24381c1c,0xf157a6a6,0xc773b4b4,0x5197c6c6,0x23cbe8e8,0x7ca1dddd,0x9ce87474,0x213e1f1f,0xdd964b4b,0xdc61bdbd,0x860d8b8b,0x850f8a8a,0x90e07070,0x427c3e3e,0xc471b5b5,0xaacc6666,0xd8904848,0x05060303,0x01f7f6f6,0x121c0e0e,0xa3c26161,0x5f6a3535,0xf9ae5757,0xd069b9b9,0x91178686,0x5899c1c1,0x273a1d1d,0xb9279e9e,0x38d9e1e1,0x13ebf8f8,0xb32b9898,0x33221111,0xbbd26969,0x70a9d9d9,0x89078e8e,0xa7339494,0xb62d9b9b,0x223c1e1e,0x92158787,0x20c9e9e9,0x4987cece,0xffaa5555,0x78502828,0x7aa5dfdf,0x8f038c8c,0xf859a1a1,0x80098989,0x171a0d0d,0xda65bfbf,0x31d7e6e6,0xc6844242,0xb8d06868,0xc3824141,0xb0299999,0x775a2d2d,0x111e0f0f,0xcb7bb0b0,0xfca85454,0xd66dbbbb,0x3a2c1616];var T3=[0x63a5c663,0x7c84f87c,0x7799ee77,0x7b8df67b,0xf20dfff2,0x6bbdd66b,0x6fb1de6f,0xc55491c5,0x30506030,0x01030201,0x67a9ce67,0x2b7d562b,0xfe19e7fe,0xd762b5d7,0xabe64dab,0x769aec76,0xca458fca,0x829d1f82,0xc94089c9,0x7d87fa7d,0xfa15effa,0x59ebb259,0x47c98e47,0xf00bfbf0,0xadec41ad,0xd467b3d4,0xa2fd5fa2,0xafea45af,0x9cbf239c,0xa4f753a4,0x7296e472,0xc05b9bc0,0xb7c275b7,0xfd1ce1fd,0x93ae3d93,0x266a4c26,0x365a6c36,0x3f417e3f,0xf702f5f7,0xcc4f83cc,0x345c6834,0xa5f451a5,0xe534d1e5,0xf108f9f1,0x7193e271,0xd873abd8,0x31536231,0x153f2a15,0x040c0804,0xc75295c7,0x23654623,0xc35e9dc3,0x18283018,0x96a13796,0x050f0a05,0x9ab52f9a,0x07090e07,0x12362412,0x809b1b80,0xe23ddfe2,0xeb26cdeb,0x27694e27,0xb2cd7fb2,0x759fea75,0x091b1209,0x839e1d83,0x2c74582c,0x1a2e341a,0x1b2d361b,0x6eb2dc6e,0x5aeeb45a,0xa0fb5ba0,0x52f6a452,0x3b4d763b,0xd661b7d6,0xb3ce7db3,0x297b5229,0xe33edde3,0x2f715e2f,0x84971384,0x53f5a653,0xd168b9d1,0x00000000,0xed2cc1ed,0x20604020,0xfc1fe3fc,0xb1c879b1,0x5bedb65b,0x6abed46a,0xcb468dcb,0xbed967be,0x394b7239,0x4ade944a,0x4cd4984c,0x58e8b058,0xcf4a85cf,0xd06bbbd0,0xef2ac5ef,0xaae54faa,0xfb16edfb,0x43c58643,0x4dd79a4d,0x33556633,0x85941185,0x45cf8a45,0xf910e9f9,0x02060402,0x7f81fe7f,0x50f0a050,0x3c44783c,0x9fba259f,0xa8e34ba8,0x51f3a251,0xa3fe5da3,0x40c08040,0x8f8a058f,0x92ad3f92,0x9dbc219d,0x38487038,0xf504f1f5,0xbcdf63bc,0xb6c177b6,0xda75afda,0x21634221,0x10302010,0xff1ae5ff,0xf30efdf3,0xd26dbfd2,0xcd4c81cd,0x0c14180c,0x13352613,0xec2fc3ec,0x5fe1be5f,0x97a23597,0x44cc8844,0x17392e17,0xc45793c4,0xa7f255a7,0x7e82fc7e,0x3d477a3d,0x64acc864,0x5de7ba5d,0x192b3219,0x7395e673,0x60a0c060,0x81981981,0x4fd19e4f,0xdc7fa3dc,0x22664422,0x2a7e542a,0x90ab3b90,0x88830b88,0x46ca8c46,0xee29c7ee,0xb8d36bb8,0x143c2814,0xde79a7de,0x5ee2bc5e,0x0b1d160b,0xdb76addb,0xe03bdbe0,0x32566432,0x3a4e743a,0x0a1e140a,0x49db9249,0x060a0c06,0x246c4824,0x5ce4b85c,0xc25d9fc2,0xd36ebdd3,0xacef43ac,0x62a6c462,0x91a83991,0x95a43195,0xe437d3e4,0x798bf279,0xe732d5e7,0xc8438bc8,0x37596e37,0x6db7da6d,0x8d8c018d,0xd564b1d5,0x4ed29c4e,0xa9e049a9,0x6cb4d86c,0x56faac56,0xf407f3f4,0xea25cfea,0x65afca65,0x7a8ef47a,0xaee947ae,0x08181008,0xbad56fba,0x7888f078,0x256f4a25,0x2e725c2e,0x1c24381c,0xa6f157a6,0xb4c773b4,0xc65197c6,0xe823cbe8,0xdd7ca1dd,0x749ce874,0x1f213e1f,0x4bdd964b,0xbddc61bd,0x8b860d8b,0x8a850f8a,0x7090e070,0x3e427c3e,0xb5c471b5,0x66aacc66,0x48d89048,0x03050603,0xf601f7f6,0x0e121c0e,0x61a3c261,0x355f6a35,0x57f9ae57,0xb9d069b9,0x86911786,0xc15899c1,0x1d273a1d,0x9eb9279e,0xe138d9e1,0xf813ebf8,0x98b32b98,0x11332211,0x69bbd269,0xd970a9d9,0x8e89078e,0x94a73394,0x9bb62d9b,0x1e223c1e,0x87921587,0xe920c9e9,0xce4987ce,0x55ffaa55,0x28785028,0xdf7aa5df,0x8c8f038c,0xa1f859a1,0x89800989,0x0d171a0d,0xbfda65bf,0xe631d7e6,0x42c68442,0x68b8d068,0x41c38241,0x99b02999,0x2d775a2d,0x0f111e0f,0xb0cb7bb0,0x54fca854,0xbbd66dbb,0x163a2c16];var T4=[0x6363a5c6,0x7c7c84f8,0x777799ee,0x7b7b8df6,0xf2f20dff,0x6b6bbdd6,0x6f6fb1de,0xc5c55491,0x30305060,0x01010302,0x6767a9ce,0x2b2b7d56,0xfefe19e7,0xd7d762b5,0xababe64d,0x76769aec,0xcaca458f,0x82829d1f,0xc9c94089,0x7d7d87fa,0xfafa15ef,0x5959ebb2,0x4747c98e,0xf0f00bfb,0xadadec41,0xd4d467b3,0xa2a2fd5f,0xafafea45,0x9c9cbf23,0xa4a4f753,0x727296e4,0xc0c05b9b,0xb7b7c275,0xfdfd1ce1,0x9393ae3d,0x26266a4c,0x36365a6c,0x3f3f417e,0xf7f702f5,0xcccc4f83,0x34345c68,0xa5a5f451,0xe5e534d1,0xf1f108f9,0x717193e2,0xd8d873ab,0x31315362,0x15153f2a,0x04040c08,0xc7c75295,0x23236546,0xc3c35e9d,0x18182830,0x9696a137,0x05050f0a,0x9a9ab52f,0x0707090e,0x12123624,0x80809b1b,0xe2e23ddf,0xebeb26cd,0x2727694e,0xb2b2cd7f,0x75759fea,0x09091b12,0x83839e1d,0x2c2c7458,0x1a1a2e34,0x1b1b2d36,0x6e6eb2dc,0x5a5aeeb4,0xa0a0fb5b,0x5252f6a4,0x3b3b4d76,0xd6d661b7,0xb3b3ce7d,0x29297b52,0xe3e33edd,0x2f2f715e,0x84849713,0x5353f5a6,0xd1d168b9,0x00000000,0xeded2cc1,0x20206040,0xfcfc1fe3,0xb1b1c879,0x5b5bedb6,0x6a6abed4,0xcbcb468d,0xbebed967,0x39394b72,0x4a4ade94,0x4c4cd498,0x5858e8b0,0xcfcf4a85,0xd0d06bbb,0xefef2ac5,0xaaaae54f,0xfbfb16ed,0x4343c586,0x4d4dd79a,0x33335566,0x85859411,0x4545cf8a,0xf9f910e9,0x02020604,0x7f7f81fe,0x5050f0a0,0x3c3c4478,0x9f9fba25,0xa8a8e34b,0x5151f3a2,0xa3a3fe5d,0x4040c080,0x8f8f8a05,0x9292ad3f,0x9d9dbc21,0x38384870,0xf5f504f1,0xbcbcdf63,0xb6b6c177,0xdada75af,0x21216342,0x10103020,0xffff1ae5,0xf3f30efd,0xd2d26dbf,0xcdcd4c81,0x0c0c1418,0x13133526,0xecec2fc3,0x5f5fe1be,0x9797a235,0x4444cc88,0x1717392e,0xc4c45793,0xa7a7f255,0x7e7e82fc,0x3d3d477a,0x6464acc8,0x5d5de7ba,0x19192b32,0x737395e6,0x6060a0c0,0x81819819,0x4f4fd19e,0xdcdc7fa3,0x22226644,0x2a2a7e54,0x9090ab3b,0x8888830b,0x4646ca8c,0xeeee29c7,0xb8b8d36b,0x14143c28,0xdede79a7,0x5e5ee2bc,0x0b0b1d16,0xdbdb76ad,0xe0e03bdb,0x32325664,0x3a3a4e74,0x0a0a1e14,0x4949db92,0x06060a0c,0x24246c48,0x5c5ce4b8,0xc2c25d9f,0xd3d36ebd,0xacacef43,0x6262a6c4,0x9191a839,0x9595a431,0xe4e437d3,0x79798bf2,0xe7e732d5,0xc8c8438b,0x3737596e,0x6d6db7da,0x8d8d8c01,0xd5d564b1,0x4e4ed29c,0xa9a9e049,0x6c6cb4d8,0x5656faac,0xf4f407f3,0xeaea25cf,0x6565afca,0x7a7a8ef4,0xaeaee947,0x08081810,0xbabad56f,0x787888f0,0x25256f4a,0x2e2e725c,0x1c1c2438,0xa6a6f157,0xb4b4c773,0xc6c65197,0xe8e823cb,0xdddd7ca1,0x74749ce8,0x1f1f213e,0x4b4bdd96,0xbdbddc61,0x8b8b860d,0x8a8a850f,0x707090e0,0x3e3e427c,0xb5b5c471,0x6666aacc,0x4848d890,0x03030506,0xf6f601f7,0x0e0e121c,0x6161a3c2,0x35355f6a,0x5757f9ae,0xb9b9d069,0x86869117,0xc1c15899,0x1d1d273a,0x9e9eb927,0xe1e138d9,0xf8f813eb,0x9898b32b,0x11113322,0x6969bbd2,0xd9d970a9,0x8e8e8907,0x9494a733,0x9b9bb62d,0x1e1e223c,0x87879215,0xe9e920c9,0xcece4987,0x5555ffaa,0x28287850,0xdfdf7aa5,0x8c8c8f03,0xa1a1f859,0x89898009,0x0d0d171a,0xbfbfda65,0xe6e631d7,0x4242c684,0x6868b8d0,0x4141c382,0x9999b029,0x2d2d775a,0x0f0f111e,0xb0b0cb7b,0x5454fca8,0xbbbbd66d,0x16163a2c];// Transformations for decryption\nvar T5=[0x51f4a750,0x7e416553,0x1a17a4c3,0x3a275e96,0x3bab6bcb,0x1f9d45f1,0xacfa58ab,0x4be30393,0x2030fa55,0xad766df6,0x88cc7691,0xf5024c25,0x4fe5d7fc,0xc52acbd7,0x26354480,0xb562a38f,0xdeb15a49,0x25ba1b67,0x45ea0e98,0x5dfec0e1,0xc32f7502,0x814cf012,0x8d4697a3,0x6bd3f9c6,0x038f5fe7,0x15929c95,0xbf6d7aeb,0x955259da,0xd4be832d,0x587421d3,0x49e06929,0x8ec9c844,0x75c2896a,0xf48e7978,0x99583e6b,0x27b971dd,0xbee14fb6,0xf088ad17,0xc920ac66,0x7dce3ab4,0x63df4a18,0xe51a3182,0x97513360,0x62537f45,0xb16477e0,0xbb6bae84,0xfe81a01c,0xf9082b94,0x70486858,0x8f45fd19,0x94de6c87,0x527bf8b7,0xab73d323,0x724b02e2,0xe31f8f57,0x6655ab2a,0xb2eb2807,0x2fb5c203,0x86c57b9a,0xd33708a5,0x302887f2,0x23bfa5b2,0x02036aba,0xed16825c,0x8acf1c2b,0xa779b492,0xf307f2f0,0x4e69e2a1,0x65daf4cd,0x0605bed5,0xd134621f,0xc4a6fe8a,0x342e539d,0xa2f355a0,0x058ae132,0xa4f6eb75,0x0b83ec39,0x4060efaa,0x5e719f06,0xbd6e1051,0x3e218af9,0x96dd063d,0xdd3e05ae,0x4de6bd46,0x91548db5,0x71c45d05,0x0406d46f,0x605015ff,0x1998fb24,0xd6bde997,0x894043cc,0x67d99e77,0xb0e842bd,0x07898b88,0xe7195b38,0x79c8eedb,0xa17c0a47,0x7c420fe9,0xf8841ec9,0x00000000,0x09808683,0x322bed48,0x1e1170ac,0x6c5a724e,0xfd0efffb,0x0f853856,0x3daed51e,0x362d3927,0x0a0fd964,0x685ca621,0x9b5b54d1,0x24362e3a,0x0c0a67b1,0x9357e70f,0xb4ee96d2,0x1b9b919e,0x80c0c54f,0x61dc20a2,0x5a774b69,0x1c121a16,0xe293ba0a,0xc0a02ae5,0x3c22e043,0x121b171d,0x0e090d0b,0xf28bc7ad,0x2db6a8b9,0x141ea9c8,0x57f11985,0xaf75074c,0xee99ddbb,0xa37f60fd,0xf701269f,0x5c72f5bc,0x44663bc5,0x5bfb7e34,0x8b432976,0xcb23c6dc,0xb6edfc68,0xb8e4f163,0xd731dcca,0x42638510,0x13972240,0x84c61120,0x854a247d,0xd2bb3df8,0xaef93211,0xc729a16d,0x1d9e2f4b,0xdcb230f3,0x0d8652ec,0x77c1e3d0,0x2bb3166c,0xa970b999,0x119448fa,0x47e96422,0xa8fc8cc4,0xa0f03f1a,0x567d2cd8,0x223390ef,0x87494ec7,0xd938d1c1,0x8ccaa2fe,0x98d40b36,0xa6f581cf,0xa57ade28,0xdab78e26,0x3fadbfa4,0x2c3a9de4,0x5078920d,0x6a5fcc9b,0x547e4662,0xf68d13c2,0x90d8b8e8,0x2e39f75e,0x82c3aff5,0x9f5d80be,0x69d0937c,0x6fd52da9,0xcf2512b3,0xc8ac993b,0x10187da7,0xe89c636e,0xdb3bbb7b,0xcd267809,0x6e5918f4,0xec9ab701,0x834f9aa8,0xe6956e65,0xaaffe67e,0x21bccf08,0xef15e8e6,0xbae79bd9,0x4a6f36ce,0xea9f09d4,0x29b07cd6,0x31a4b2af,0x2a3f2331,0xc6a59430,0x35a266c0,0x744ebc37,0xfc82caa6,0xe090d0b0,0x33a7d815,0xf104984a,0x41ecdaf7,0x7fcd500e,0x1791f62f,0x764dd68d,0x43efb04d,0xccaa4d54,0xe49604df,0x9ed1b5e3,0x4c6a881b,0xc12c1fb8,0x4665517f,0x9d5eea04,0x018c355d,0xfa877473,0xfb0b412e,0xb3671d5a,0x92dbd252,0xe9105633,0x6dd64713,0x9ad7618c,0x37a10c7a,0x59f8148e,0xeb133c89,0xcea927ee,0xb761c935,0xe11ce5ed,0x7a47b13c,0x9cd2df59,0x55f2733f,0x1814ce79,0x73c737bf,0x53f7cdea,0x5ffdaa5b,0xdf3d6f14,0x7844db86,0xcaaff381,0xb968c43e,0x3824342c,0xc2a3405f,0x161dc372,0xbce2250c,0x283c498b,0xff0d9541,0x39a80171,0x080cb3de,0xd8b4e49c,0x6456c190,0x7bcb8461,0xd532b670,0x486c5c74,0xd0b85742];var T6=[0x5051f4a7,0x537e4165,0xc31a17a4,0x963a275e,0xcb3bab6b,0xf11f9d45,0xabacfa58,0x934be303,0x552030fa,0xf6ad766d,0x9188cc76,0x25f5024c,0xfc4fe5d7,0xd7c52acb,0x80263544,0x8fb562a3,0x49deb15a,0x6725ba1b,0x9845ea0e,0xe15dfec0,0x02c32f75,0x12814cf0,0xa38d4697,0xc66bd3f9,0xe7038f5f,0x9515929c,0xebbf6d7a,0xda955259,0x2dd4be83,0xd3587421,0x2949e069,0x448ec9c8,0x6a75c289,0x78f48e79,0x6b99583e,0xdd27b971,0xb6bee14f,0x17f088ad,0x66c920ac,0xb47dce3a,0x1863df4a,0x82e51a31,0x60975133,0x4562537f,0xe0b16477,0x84bb6bae,0x1cfe81a0,0x94f9082b,0x58704868,0x198f45fd,0x8794de6c,0xb7527bf8,0x23ab73d3,0xe2724b02,0x57e31f8f,0x2a6655ab,0x07b2eb28,0x032fb5c2,0x9a86c57b,0xa5d33708,0xf2302887,0xb223bfa5,0xba02036a,0x5ced1682,0x2b8acf1c,0x92a779b4,0xf0f307f2,0xa14e69e2,0xcd65daf4,0xd50605be,0x1fd13462,0x8ac4a6fe,0x9d342e53,0xa0a2f355,0x32058ae1,0x75a4f6eb,0x390b83ec,0xaa4060ef,0x065e719f,0x51bd6e10,0xf93e218a,0x3d96dd06,0xaedd3e05,0x464de6bd,0xb591548d,0x0571c45d,0x6f0406d4,0xff605015,0x241998fb,0x97d6bde9,0xcc894043,0x7767d99e,0xbdb0e842,0x8807898b,0x38e7195b,0xdb79c8ee,0x47a17c0a,0xe97c420f,0xc9f8841e,0x00000000,0x83098086,0x48322bed,0xac1e1170,0x4e6c5a72,0xfbfd0eff,0x560f8538,0x1e3daed5,0x27362d39,0x640a0fd9,0x21685ca6,0xd19b5b54,0x3a24362e,0xb10c0a67,0x0f9357e7,0xd2b4ee96,0x9e1b9b91,0x4f80c0c5,0xa261dc20,0x695a774b,0x161c121a,0x0ae293ba,0xe5c0a02a,0x433c22e0,0x1d121b17,0x0b0e090d,0xadf28bc7,0xb92db6a8,0xc8141ea9,0x8557f119,0x4caf7507,0xbbee99dd,0xfda37f60,0x9ff70126,0xbc5c72f5,0xc544663b,0x345bfb7e,0x768b4329,0xdccb23c6,0x68b6edfc,0x63b8e4f1,0xcad731dc,0x10426385,0x40139722,0x2084c611,0x7d854a24,0xf8d2bb3d,0x11aef932,0x6dc729a1,0x4b1d9e2f,0xf3dcb230,0xec0d8652,0xd077c1e3,0x6c2bb316,0x99a970b9,0xfa119448,0x2247e964,0xc4a8fc8c,0x1aa0f03f,0xd8567d2c,0xef223390,0xc787494e,0xc1d938d1,0xfe8ccaa2,0x3698d40b,0xcfa6f581,0x28a57ade,0x26dab78e,0xa43fadbf,0xe42c3a9d,0x0d507892,0x9b6a5fcc,0x62547e46,0xc2f68d13,0xe890d8b8,0x5e2e39f7,0xf582c3af,0xbe9f5d80,0x7c69d093,0xa96fd52d,0xb3cf2512,0x3bc8ac99,0xa710187d,0x6ee89c63,0x7bdb3bbb,0x09cd2678,0xf46e5918,0x01ec9ab7,0xa8834f9a,0x65e6956e,0x7eaaffe6,0x0821bccf,0xe6ef15e8,0xd9bae79b,0xce4a6f36,0xd4ea9f09,0xd629b07c,0xaf31a4b2,0x312a3f23,0x30c6a594,0xc035a266,0x37744ebc,0xa6fc82ca,0xb0e090d0,0x1533a7d8,0x4af10498,0xf741ecda,0x0e7fcd50,0x2f1791f6,0x8d764dd6,0x4d43efb0,0x54ccaa4d,0xdfe49604,0xe39ed1b5,0x1b4c6a88,0xb8c12c1f,0x7f466551,0x049d5eea,0x5d018c35,0x73fa8774,0x2efb0b41,0x5ab3671d,0x5292dbd2,0x33e91056,0x136dd647,0x8c9ad761,0x7a37a10c,0x8e59f814,0x89eb133c,0xeecea927,0x35b761c9,0xede11ce5,0x3c7a47b1,0x599cd2df,0x3f55f273,0x791814ce,0xbf73c737,0xea53f7cd,0x5b5ffdaa,0x14df3d6f,0x867844db,0x81caaff3,0x3eb968c4,0x2c382434,0x5fc2a340,0x72161dc3,0x0cbce225,0x8b283c49,0x41ff0d95,0x7139a801,0xde080cb3,0x9cd8b4e4,0x906456c1,0x617bcb84,0x70d532b6,0x74486c5c,0x42d0b857];var T7=[0xa75051f4,0x65537e41,0xa4c31a17,0x5e963a27,0x6bcb3bab,0x45f11f9d,0x58abacfa,0x03934be3,0xfa552030,0x6df6ad76,0x769188cc,0x4c25f502,0xd7fc4fe5,0xcbd7c52a,0x44802635,0xa38fb562,0x5a49deb1,0x1b6725ba,0x0e9845ea,0xc0e15dfe,0x7502c32f,0xf012814c,0x97a38d46,0xf9c66bd3,0x5fe7038f,0x9c951592,0x7aebbf6d,0x59da9552,0x832dd4be,0x21d35874,0x692949e0,0xc8448ec9,0x896a75c2,0x7978f48e,0x3e6b9958,0x71dd27b9,0x4fb6bee1,0xad17f088,0xac66c920,0x3ab47dce,0x4a1863df,0x3182e51a,0x33609751,0x7f456253,0x77e0b164,0xae84bb6b,0xa01cfe81,0x2b94f908,0x68587048,0xfd198f45,0x6c8794de,0xf8b7527b,0xd323ab73,0x02e2724b,0x8f57e31f,0xab2a6655,0x2807b2eb,0xc2032fb5,0x7b9a86c5,0x08a5d337,0x87f23028,0xa5b223bf,0x6aba0203,0x825ced16,0x1c2b8acf,0xb492a779,0xf2f0f307,0xe2a14e69,0xf4cd65da,0xbed50605,0x621fd134,0xfe8ac4a6,0x539d342e,0x55a0a2f3,0xe132058a,0xeb75a4f6,0xec390b83,0xefaa4060,0x9f065e71,0x1051bd6e,0x8af93e21,0x063d96dd,0x05aedd3e,0xbd464de6,0x8db59154,0x5d0571c4,0xd46f0406,0x15ff6050,0xfb241998,0xe997d6bd,0x43cc8940,0x9e7767d9,0x42bdb0e8,0x8b880789,0x5b38e719,0xeedb79c8,0x0a47a17c,0x0fe97c42,0x1ec9f884,0x00000000,0x86830980,0xed48322b,0x70ac1e11,0x724e6c5a,0xfffbfd0e,0x38560f85,0xd51e3dae,0x3927362d,0xd9640a0f,0xa621685c,0x54d19b5b,0x2e3a2436,0x67b10c0a,0xe70f9357,0x96d2b4ee,0x919e1b9b,0xc54f80c0,0x20a261dc,0x4b695a77,0x1a161c12,0xba0ae293,0x2ae5c0a0,0xe0433c22,0x171d121b,0x0d0b0e09,0xc7adf28b,0xa8b92db6,0xa9c8141e,0x198557f1,0x074caf75,0xddbbee99,0x60fda37f,0x269ff701,0xf5bc5c72,0x3bc54466,0x7e345bfb,0x29768b43,0xc6dccb23,0xfc68b6ed,0xf163b8e4,0xdccad731,0x85104263,0x22401397,0x112084c6,0x247d854a,0x3df8d2bb,0x3211aef9,0xa16dc729,0x2f4b1d9e,0x30f3dcb2,0x52ec0d86,0xe3d077c1,0x166c2bb3,0xb999a970,0x48fa1194,0x642247e9,0x8cc4a8fc,0x3f1aa0f0,0x2cd8567d,0x90ef2233,0x4ec78749,0xd1c1d938,0xa2fe8cca,0x0b3698d4,0x81cfa6f5,0xde28a57a,0x8e26dab7,0xbfa43fad,0x9de42c3a,0x920d5078,0xcc9b6a5f,0x4662547e,0x13c2f68d,0xb8e890d8,0xf75e2e39,0xaff582c3,0x80be9f5d,0x937c69d0,0x2da96fd5,0x12b3cf25,0x993bc8ac,0x7da71018,0x636ee89c,0xbb7bdb3b,0x7809cd26,0x18f46e59,0xb701ec9a,0x9aa8834f,0x6e65e695,0xe67eaaff,0xcf0821bc,0xe8e6ef15,0x9bd9bae7,0x36ce4a6f,0x09d4ea9f,0x7cd629b0,0xb2af31a4,0x23312a3f,0x9430c6a5,0x66c035a2,0xbc37744e,0xcaa6fc82,0xd0b0e090,0xd81533a7,0x984af104,0xdaf741ec,0x500e7fcd,0xf62f1791,0xd68d764d,0xb04d43ef,0x4d54ccaa,0x04dfe496,0xb5e39ed1,0x881b4c6a,0x1fb8c12c,0x517f4665,0xea049d5e,0x355d018c,0x7473fa87,0x412efb0b,0x1d5ab367,0xd25292db,0x5633e910,0x47136dd6,0x618c9ad7,0x0c7a37a1,0x148e59f8,0x3c89eb13,0x27eecea9,0xc935b761,0xe5ede11c,0xb13c7a47,0xdf599cd2,0x733f55f2,0xce791814,0x37bf73c7,0xcdea53f7,0xaa5b5ffd,0x6f14df3d,0xdb867844,0xf381caaf,0xc43eb968,0x342c3824,0x405fc2a3,0xc372161d,0x250cbce2,0x498b283c,0x9541ff0d,0x017139a8,0xb3de080c,0xe49cd8b4,0xc1906456,0x84617bcb,0xb670d532,0x5c74486c,0x5742d0b8];var T8=[0xf4a75051,0x4165537e,0x17a4c31a,0x275e963a,0xab6bcb3b,0x9d45f11f,0xfa58abac,0xe303934b,0x30fa5520,0x766df6ad,0xcc769188,0x024c25f5,0xe5d7fc4f,0x2acbd7c5,0x35448026,0x62a38fb5,0xb15a49de,0xba1b6725,0xea0e9845,0xfec0e15d,0x2f7502c3,0x4cf01281,0x4697a38d,0xd3f9c66b,0x8f5fe703,0x929c9515,0x6d7aebbf,0x5259da95,0xbe832dd4,0x7421d358,0xe0692949,0xc9c8448e,0xc2896a75,0x8e7978f4,0x583e6b99,0xb971dd27,0xe14fb6be,0x88ad17f0,0x20ac66c9,0xce3ab47d,0xdf4a1863,0x1a3182e5,0x51336097,0x537f4562,0x6477e0b1,0x6bae84bb,0x81a01cfe,0x082b94f9,0x48685870,0x45fd198f,0xde6c8794,0x7bf8b752,0x73d323ab,0x4b02e272,0x1f8f57e3,0x55ab2a66,0xeb2807b2,0xb5c2032f,0xc57b9a86,0x3708a5d3,0x2887f230,0xbfa5b223,0x036aba02,0x16825ced,0xcf1c2b8a,0x79b492a7,0x07f2f0f3,0x69e2a14e,0xdaf4cd65,0x05bed506,0x34621fd1,0xa6fe8ac4,0x2e539d34,0xf355a0a2,0x8ae13205,0xf6eb75a4,0x83ec390b,0x60efaa40,0x719f065e,0x6e1051bd,0x218af93e,0xdd063d96,0x3e05aedd,0xe6bd464d,0x548db591,0xc45d0571,0x06d46f04,0x5015ff60,0x98fb2419,0xbde997d6,0x4043cc89,0xd99e7767,0xe842bdb0,0x898b8807,0x195b38e7,0xc8eedb79,0x7c0a47a1,0x420fe97c,0x841ec9f8,0x00000000,0x80868309,0x2bed4832,0x1170ac1e,0x5a724e6c,0x0efffbfd,0x8538560f,0xaed51e3d,0x2d392736,0x0fd9640a,0x5ca62168,0x5b54d19b,0x362e3a24,0x0a67b10c,0x57e70f93,0xee96d2b4,0x9b919e1b,0xc0c54f80,0xdc20a261,0x774b695a,0x121a161c,0x93ba0ae2,0xa02ae5c0,0x22e0433c,0x1b171d12,0x090d0b0e,0x8bc7adf2,0xb6a8b92d,0x1ea9c814,0xf1198557,0x75074caf,0x99ddbbee,0x7f60fda3,0x01269ff7,0x72f5bc5c,0x663bc544,0xfb7e345b,0x4329768b,0x23c6dccb,0xedfc68b6,0xe4f163b8,0x31dccad7,0x63851042,0x97224013,0xc6112084,0x4a247d85,0xbb3df8d2,0xf93211ae,0x29a16dc7,0x9e2f4b1d,0xb230f3dc,0x8652ec0d,0xc1e3d077,0xb3166c2b,0x70b999a9,0x9448fa11,0xe9642247,0xfc8cc4a8,0xf03f1aa0,0x7d2cd856,0x3390ef22,0x494ec787,0x38d1c1d9,0xcaa2fe8c,0xd40b3698,0xf581cfa6,0x7ade28a5,0xb78e26da,0xadbfa43f,0x3a9de42c,0x78920d50,0x5fcc9b6a,0x7e466254,0x8d13c2f6,0xd8b8e890,0x39f75e2e,0xc3aff582,0x5d80be9f,0xd0937c69,0xd52da96f,0x2512b3cf,0xac993bc8,0x187da710,0x9c636ee8,0x3bbb7bdb,0x267809cd,0x5918f46e,0x9ab701ec,0x4f9aa883,0x956e65e6,0xffe67eaa,0xbccf0821,0x15e8e6ef,0xe79bd9ba,0x6f36ce4a,0x9f09d4ea,0xb07cd629,0xa4b2af31,0x3f23312a,0xa59430c6,0xa266c035,0x4ebc3774,0x82caa6fc,0x90d0b0e0,0xa7d81533,0x04984af1,0xecdaf741,0xcd500e7f,0x91f62f17,0x4dd68d76,0xefb04d43,0xaa4d54cc,0x9604dfe4,0xd1b5e39e,0x6a881b4c,0x2c1fb8c1,0x65517f46,0x5eea049d,0x8c355d01,0x877473fa,0x0b412efb,0x671d5ab3,0xdbd25292,0x105633e9,0xd647136d,0xd7618c9a,0xa10c7a37,0xf8148e59,0x133c89eb,0xa927eece,0x61c935b7,0x1ce5ede1,0x47b13c7a,0xd2df599c,0xf2733f55,0x14ce7918,0xc737bf73,0xf7cdea53,0xfdaa5b5f,0x3d6f14df,0x44db8678,0xaff381ca,0x68c43eb9,0x24342c38,0xa3405fc2,0x1dc37216,0xe2250cbc,0x3c498b28,0x0d9541ff,0xa8017139,0x0cb3de08,0xb4e49cd8,0x56c19064,0xcb84617b,0x32b670d5,0x6c5c7448,0xb85742d0];// Transformations for decryption key expansion\nvar U1=[0x00000000,0x0e090d0b,0x1c121a16,0x121b171d,0x3824342c,0x362d3927,0x24362e3a,0x2a3f2331,0x70486858,0x7e416553,0x6c5a724e,0x62537f45,0x486c5c74,0x4665517f,0x547e4662,0x5a774b69,0xe090d0b0,0xee99ddbb,0xfc82caa6,0xf28bc7ad,0xd8b4e49c,0xd6bde997,0xc4a6fe8a,0xcaaff381,0x90d8b8e8,0x9ed1b5e3,0x8ccaa2fe,0x82c3aff5,0xa8fc8cc4,0xa6f581cf,0xb4ee96d2,0xbae79bd9,0xdb3bbb7b,0xd532b670,0xc729a16d,0xc920ac66,0xe31f8f57,0xed16825c,0xff0d9541,0xf104984a,0xab73d323,0xa57ade28,0xb761c935,0xb968c43e,0x9357e70f,0x9d5eea04,0x8f45fd19,0x814cf012,0x3bab6bcb,0x35a266c0,0x27b971dd,0x29b07cd6,0x038f5fe7,0x0d8652ec,0x1f9d45f1,0x119448fa,0x4be30393,0x45ea0e98,0x57f11985,0x59f8148e,0x73c737bf,0x7dce3ab4,0x6fd52da9,0x61dc20a2,0xad766df6,0xa37f60fd,0xb16477e0,0xbf6d7aeb,0x955259da,0x9b5b54d1,0x894043cc,0x87494ec7,0xdd3e05ae,0xd33708a5,0xc12c1fb8,0xcf2512b3,0xe51a3182,0xeb133c89,0xf9082b94,0xf701269f,0x4de6bd46,0x43efb04d,0x51f4a750,0x5ffdaa5b,0x75c2896a,0x7bcb8461,0x69d0937c,0x67d99e77,0x3daed51e,0x33a7d815,0x21bccf08,0x2fb5c203,0x058ae132,0x0b83ec39,0x1998fb24,0x1791f62f,0x764dd68d,0x7844db86,0x6a5fcc9b,0x6456c190,0x4e69e2a1,0x4060efaa,0x527bf8b7,0x5c72f5bc,0x0605bed5,0x080cb3de,0x1a17a4c3,0x141ea9c8,0x3e218af9,0x302887f2,0x223390ef,0x2c3a9de4,0x96dd063d,0x98d40b36,0x8acf1c2b,0x84c61120,0xaef93211,0xa0f03f1a,0xb2eb2807,0xbce2250c,0xe6956e65,0xe89c636e,0xfa877473,0xf48e7978,0xdeb15a49,0xd0b85742,0xc2a3405f,0xccaa4d54,0x41ecdaf7,0x4fe5d7fc,0x5dfec0e1,0x53f7cdea,0x79c8eedb,0x77c1e3d0,0x65daf4cd,0x6bd3f9c6,0x31a4b2af,0x3fadbfa4,0x2db6a8b9,0x23bfa5b2,0x09808683,0x07898b88,0x15929c95,0x1b9b919e,0xa17c0a47,0xaf75074c,0xbd6e1051,0xb3671d5a,0x99583e6b,0x97513360,0x854a247d,0x8b432976,0xd134621f,0xdf3d6f14,0xcd267809,0xc32f7502,0xe9105633,0xe7195b38,0xf5024c25,0xfb0b412e,0x9ad7618c,0x94de6c87,0x86c57b9a,0x88cc7691,0xa2f355a0,0xacfa58ab,0xbee14fb6,0xb0e842bd,0xea9f09d4,0xe49604df,0xf68d13c2,0xf8841ec9,0xd2bb3df8,0xdcb230f3,0xcea927ee,0xc0a02ae5,0x7a47b13c,0x744ebc37,0x6655ab2a,0x685ca621,0x42638510,0x4c6a881b,0x5e719f06,0x5078920d,0x0a0fd964,0x0406d46f,0x161dc372,0x1814ce79,0x322bed48,0x3c22e043,0x2e39f75e,0x2030fa55,0xec9ab701,0xe293ba0a,0xf088ad17,0xfe81a01c,0xd4be832d,0xdab78e26,0xc8ac993b,0xc6a59430,0x9cd2df59,0x92dbd252,0x80c0c54f,0x8ec9c844,0xa4f6eb75,0xaaffe67e,0xb8e4f163,0xb6edfc68,0x0c0a67b1,0x02036aba,0x10187da7,0x1e1170ac,0x342e539d,0x3a275e96,0x283c498b,0x26354480,0x7c420fe9,0x724b02e2,0x605015ff,0x6e5918f4,0x44663bc5,0x4a6f36ce,0x587421d3,0x567d2cd8,0x37a10c7a,0x39a80171,0x2bb3166c,0x25ba1b67,0x0f853856,0x018c355d,0x13972240,0x1d9e2f4b,0x47e96422,0x49e06929,0x5bfb7e34,0x55f2733f,0x7fcd500e,0x71c45d05,0x63df4a18,0x6dd64713,0xd731dcca,0xd938d1c1,0xcb23c6dc,0xc52acbd7,0xef15e8e6,0xe11ce5ed,0xf307f2f0,0xfd0efffb,0xa779b492,0xa970b999,0xbb6bae84,0xb562a38f,0x9f5d80be,0x91548db5,0x834f9aa8,0x8d4697a3];var U2=[0x00000000,0x0b0e090d,0x161c121a,0x1d121b17,0x2c382434,0x27362d39,0x3a24362e,0x312a3f23,0x58704868,0x537e4165,0x4e6c5a72,0x4562537f,0x74486c5c,0x7f466551,0x62547e46,0x695a774b,0xb0e090d0,0xbbee99dd,0xa6fc82ca,0xadf28bc7,0x9cd8b4e4,0x97d6bde9,0x8ac4a6fe,0x81caaff3,0xe890d8b8,0xe39ed1b5,0xfe8ccaa2,0xf582c3af,0xc4a8fc8c,0xcfa6f581,0xd2b4ee96,0xd9bae79b,0x7bdb3bbb,0x70d532b6,0x6dc729a1,0x66c920ac,0x57e31f8f,0x5ced1682,0x41ff0d95,0x4af10498,0x23ab73d3,0x28a57ade,0x35b761c9,0x3eb968c4,0x0f9357e7,0x049d5eea,0x198f45fd,0x12814cf0,0xcb3bab6b,0xc035a266,0xdd27b971,0xd629b07c,0xe7038f5f,0xec0d8652,0xf11f9d45,0xfa119448,0x934be303,0x9845ea0e,0x8557f119,0x8e59f814,0xbf73c737,0xb47dce3a,0xa96fd52d,0xa261dc20,0xf6ad766d,0xfda37f60,0xe0b16477,0xebbf6d7a,0xda955259,0xd19b5b54,0xcc894043,0xc787494e,0xaedd3e05,0xa5d33708,0xb8c12c1f,0xb3cf2512,0x82e51a31,0x89eb133c,0x94f9082b,0x9ff70126,0x464de6bd,0x4d43efb0,0x5051f4a7,0x5b5ffdaa,0x6a75c289,0x617bcb84,0x7c69d093,0x7767d99e,0x1e3daed5,0x1533a7d8,0x0821bccf,0x032fb5c2,0x32058ae1,0x390b83ec,0x241998fb,0x2f1791f6,0x8d764dd6,0x867844db,0x9b6a5fcc,0x906456c1,0xa14e69e2,0xaa4060ef,0xb7527bf8,0xbc5c72f5,0xd50605be,0xde080cb3,0xc31a17a4,0xc8141ea9,0xf93e218a,0xf2302887,0xef223390,0xe42c3a9d,0x3d96dd06,0x3698d40b,0x2b8acf1c,0x2084c611,0x11aef932,0x1aa0f03f,0x07b2eb28,0x0cbce225,0x65e6956e,0x6ee89c63,0x73fa8774,0x78f48e79,0x49deb15a,0x42d0b857,0x5fc2a340,0x54ccaa4d,0xf741ecda,0xfc4fe5d7,0xe15dfec0,0xea53f7cd,0xdb79c8ee,0xd077c1e3,0xcd65daf4,0xc66bd3f9,0xaf31a4b2,0xa43fadbf,0xb92db6a8,0xb223bfa5,0x83098086,0x8807898b,0x9515929c,0x9e1b9b91,0x47a17c0a,0x4caf7507,0x51bd6e10,0x5ab3671d,0x6b99583e,0x60975133,0x7d854a24,0x768b4329,0x1fd13462,0x14df3d6f,0x09cd2678,0x02c32f75,0x33e91056,0x38e7195b,0x25f5024c,0x2efb0b41,0x8c9ad761,0x8794de6c,0x9a86c57b,0x9188cc76,0xa0a2f355,0xabacfa58,0xb6bee14f,0xbdb0e842,0xd4ea9f09,0xdfe49604,0xc2f68d13,0xc9f8841e,0xf8d2bb3d,0xf3dcb230,0xeecea927,0xe5c0a02a,0x3c7a47b1,0x37744ebc,0x2a6655ab,0x21685ca6,0x10426385,0x1b4c6a88,0x065e719f,0x0d507892,0x640a0fd9,0x6f0406d4,0x72161dc3,0x791814ce,0x48322bed,0x433c22e0,0x5e2e39f7,0x552030fa,0x01ec9ab7,0x0ae293ba,0x17f088ad,0x1cfe81a0,0x2dd4be83,0x26dab78e,0x3bc8ac99,0x30c6a594,0x599cd2df,0x5292dbd2,0x4f80c0c5,0x448ec9c8,0x75a4f6eb,0x7eaaffe6,0x63b8e4f1,0x68b6edfc,0xb10c0a67,0xba02036a,0xa710187d,0xac1e1170,0x9d342e53,0x963a275e,0x8b283c49,0x80263544,0xe97c420f,0xe2724b02,0xff605015,0xf46e5918,0xc544663b,0xce4a6f36,0xd3587421,0xd8567d2c,0x7a37a10c,0x7139a801,0x6c2bb316,0x6725ba1b,0x560f8538,0x5d018c35,0x40139722,0x4b1d9e2f,0x2247e964,0x2949e069,0x345bfb7e,0x3f55f273,0x0e7fcd50,0x0571c45d,0x1863df4a,0x136dd647,0xcad731dc,0xc1d938d1,0xdccb23c6,0xd7c52acb,0xe6ef15e8,0xede11ce5,0xf0f307f2,0xfbfd0eff,0x92a779b4,0x99a970b9,0x84bb6bae,0x8fb562a3,0xbe9f5d80,0xb591548d,0xa8834f9a,0xa38d4697];var U3=[0x00000000,0x0d0b0e09,0x1a161c12,0x171d121b,0x342c3824,0x3927362d,0x2e3a2436,0x23312a3f,0x68587048,0x65537e41,0x724e6c5a,0x7f456253,0x5c74486c,0x517f4665,0x4662547e,0x4b695a77,0xd0b0e090,0xddbbee99,0xcaa6fc82,0xc7adf28b,0xe49cd8b4,0xe997d6bd,0xfe8ac4a6,0xf381caaf,0xb8e890d8,0xb5e39ed1,0xa2fe8cca,0xaff582c3,0x8cc4a8fc,0x81cfa6f5,0x96d2b4ee,0x9bd9bae7,0xbb7bdb3b,0xb670d532,0xa16dc729,0xac66c920,0x8f57e31f,0x825ced16,0x9541ff0d,0x984af104,0xd323ab73,0xde28a57a,0xc935b761,0xc43eb968,0xe70f9357,0xea049d5e,0xfd198f45,0xf012814c,0x6bcb3bab,0x66c035a2,0x71dd27b9,0x7cd629b0,0x5fe7038f,0x52ec0d86,0x45f11f9d,0x48fa1194,0x03934be3,0x0e9845ea,0x198557f1,0x148e59f8,0x37bf73c7,0x3ab47dce,0x2da96fd5,0x20a261dc,0x6df6ad76,0x60fda37f,0x77e0b164,0x7aebbf6d,0x59da9552,0x54d19b5b,0x43cc8940,0x4ec78749,0x05aedd3e,0x08a5d337,0x1fb8c12c,0x12b3cf25,0x3182e51a,0x3c89eb13,0x2b94f908,0x269ff701,0xbd464de6,0xb04d43ef,0xa75051f4,0xaa5b5ffd,0x896a75c2,0x84617bcb,0x937c69d0,0x9e7767d9,0xd51e3dae,0xd81533a7,0xcf0821bc,0xc2032fb5,0xe132058a,0xec390b83,0xfb241998,0xf62f1791,0xd68d764d,0xdb867844,0xcc9b6a5f,0xc1906456,0xe2a14e69,0xefaa4060,0xf8b7527b,0xf5bc5c72,0xbed50605,0xb3de080c,0xa4c31a17,0xa9c8141e,0x8af93e21,0x87f23028,0x90ef2233,0x9de42c3a,0x063d96dd,0x0b3698d4,0x1c2b8acf,0x112084c6,0x3211aef9,0x3f1aa0f0,0x2807b2eb,0x250cbce2,0x6e65e695,0x636ee89c,0x7473fa87,0x7978f48e,0x5a49deb1,0x5742d0b8,0x405fc2a3,0x4d54ccaa,0xdaf741ec,0xd7fc4fe5,0xc0e15dfe,0xcdea53f7,0xeedb79c8,0xe3d077c1,0xf4cd65da,0xf9c66bd3,0xb2af31a4,0xbfa43fad,0xa8b92db6,0xa5b223bf,0x86830980,0x8b880789,0x9c951592,0x919e1b9b,0x0a47a17c,0x074caf75,0x1051bd6e,0x1d5ab367,0x3e6b9958,0x33609751,0x247d854a,0x29768b43,0x621fd134,0x6f14df3d,0x7809cd26,0x7502c32f,0x5633e910,0x5b38e719,0x4c25f502,0x412efb0b,0x618c9ad7,0x6c8794de,0x7b9a86c5,0x769188cc,0x55a0a2f3,0x58abacfa,0x4fb6bee1,0x42bdb0e8,0x09d4ea9f,0x04dfe496,0x13c2f68d,0x1ec9f884,0x3df8d2bb,0x30f3dcb2,0x27eecea9,0x2ae5c0a0,0xb13c7a47,0xbc37744e,0xab2a6655,0xa621685c,0x85104263,0x881b4c6a,0x9f065e71,0x920d5078,0xd9640a0f,0xd46f0406,0xc372161d,0xce791814,0xed48322b,0xe0433c22,0xf75e2e39,0xfa552030,0xb701ec9a,0xba0ae293,0xad17f088,0xa01cfe81,0x832dd4be,0x8e26dab7,0x993bc8ac,0x9430c6a5,0xdf599cd2,0xd25292db,0xc54f80c0,0xc8448ec9,0xeb75a4f6,0xe67eaaff,0xf163b8e4,0xfc68b6ed,0x67b10c0a,0x6aba0203,0x7da71018,0x70ac1e11,0x539d342e,0x5e963a27,0x498b283c,0x44802635,0x0fe97c42,0x02e2724b,0x15ff6050,0x18f46e59,0x3bc54466,0x36ce4a6f,0x21d35874,0x2cd8567d,0x0c7a37a1,0x017139a8,0x166c2bb3,0x1b6725ba,0x38560f85,0x355d018c,0x22401397,0x2f4b1d9e,0x642247e9,0x692949e0,0x7e345bfb,0x733f55f2,0x500e7fcd,0x5d0571c4,0x4a1863df,0x47136dd6,0xdccad731,0xd1c1d938,0xc6dccb23,0xcbd7c52a,0xe8e6ef15,0xe5ede11c,0xf2f0f307,0xfffbfd0e,0xb492a779,0xb999a970,0xae84bb6b,0xa38fb562,0x80be9f5d,0x8db59154,0x9aa8834f,0x97a38d46];var U4=[0x00000000,0x090d0b0e,0x121a161c,0x1b171d12,0x24342c38,0x2d392736,0x362e3a24,0x3f23312a,0x48685870,0x4165537e,0x5a724e6c,0x537f4562,0x6c5c7448,0x65517f46,0x7e466254,0x774b695a,0x90d0b0e0,0x99ddbbee,0x82caa6fc,0x8bc7adf2,0xb4e49cd8,0xbde997d6,0xa6fe8ac4,0xaff381ca,0xd8b8e890,0xd1b5e39e,0xcaa2fe8c,0xc3aff582,0xfc8cc4a8,0xf581cfa6,0xee96d2b4,0xe79bd9ba,0x3bbb7bdb,0x32b670d5,0x29a16dc7,0x20ac66c9,0x1f8f57e3,0x16825ced,0x0d9541ff,0x04984af1,0x73d323ab,0x7ade28a5,0x61c935b7,0x68c43eb9,0x57e70f93,0x5eea049d,0x45fd198f,0x4cf01281,0xab6bcb3b,0xa266c035,0xb971dd27,0xb07cd629,0x8f5fe703,0x8652ec0d,0x9d45f11f,0x9448fa11,0xe303934b,0xea0e9845,0xf1198557,0xf8148e59,0xc737bf73,0xce3ab47d,0xd52da96f,0xdc20a261,0x766df6ad,0x7f60fda3,0x6477e0b1,0x6d7aebbf,0x5259da95,0x5b54d19b,0x4043cc89,0x494ec787,0x3e05aedd,0x3708a5d3,0x2c1fb8c1,0x2512b3cf,0x1a3182e5,0x133c89eb,0x082b94f9,0x01269ff7,0xe6bd464d,0xefb04d43,0xf4a75051,0xfdaa5b5f,0xc2896a75,0xcb84617b,0xd0937c69,0xd99e7767,0xaed51e3d,0xa7d81533,0xbccf0821,0xb5c2032f,0x8ae13205,0x83ec390b,0x98fb2419,0x91f62f17,0x4dd68d76,0x44db8678,0x5fcc9b6a,0x56c19064,0x69e2a14e,0x60efaa40,0x7bf8b752,0x72f5bc5c,0x05bed506,0x0cb3de08,0x17a4c31a,0x1ea9c814,0x218af93e,0x2887f230,0x3390ef22,0x3a9de42c,0xdd063d96,0xd40b3698,0xcf1c2b8a,0xc6112084,0xf93211ae,0xf03f1aa0,0xeb2807b2,0xe2250cbc,0x956e65e6,0x9c636ee8,0x877473fa,0x8e7978f4,0xb15a49de,0xb85742d0,0xa3405fc2,0xaa4d54cc,0xecdaf741,0xe5d7fc4f,0xfec0e15d,0xf7cdea53,0xc8eedb79,0xc1e3d077,0xdaf4cd65,0xd3f9c66b,0xa4b2af31,0xadbfa43f,0xb6a8b92d,0xbfa5b223,0x80868309,0x898b8807,0x929c9515,0x9b919e1b,0x7c0a47a1,0x75074caf,0x6e1051bd,0x671d5ab3,0x583e6b99,0x51336097,0x4a247d85,0x4329768b,0x34621fd1,0x3d6f14df,0x267809cd,0x2f7502c3,0x105633e9,0x195b38e7,0x024c25f5,0x0b412efb,0xd7618c9a,0xde6c8794,0xc57b9a86,0xcc769188,0xf355a0a2,0xfa58abac,0xe14fb6be,0xe842bdb0,0x9f09d4ea,0x9604dfe4,0x8d13c2f6,0x841ec9f8,0xbb3df8d2,0xb230f3dc,0xa927eece,0xa02ae5c0,0x47b13c7a,0x4ebc3774,0x55ab2a66,0x5ca62168,0x63851042,0x6a881b4c,0x719f065e,0x78920d50,0x0fd9640a,0x06d46f04,0x1dc37216,0x14ce7918,0x2bed4832,0x22e0433c,0x39f75e2e,0x30fa5520,0x9ab701ec,0x93ba0ae2,0x88ad17f0,0x81a01cfe,0xbe832dd4,0xb78e26da,0xac993bc8,0xa59430c6,0xd2df599c,0xdbd25292,0xc0c54f80,0xc9c8448e,0xf6eb75a4,0xffe67eaa,0xe4f163b8,0xedfc68b6,0x0a67b10c,0x036aba02,0x187da710,0x1170ac1e,0x2e539d34,0x275e963a,0x3c498b28,0x35448026,0x420fe97c,0x4b02e272,0x5015ff60,0x5918f46e,0x663bc544,0x6f36ce4a,0x7421d358,0x7d2cd856,0xa10c7a37,0xa8017139,0xb3166c2b,0xba1b6725,0x8538560f,0x8c355d01,0x97224013,0x9e2f4b1d,0xe9642247,0xe0692949,0xfb7e345b,0xf2733f55,0xcd500e7f,0xc45d0571,0xdf4a1863,0xd647136d,0x31dccad7,0x38d1c1d9,0x23c6dccb,0x2acbd7c5,0x15e8e6ef,0x1ce5ede1,0x07f2f0f3,0x0efffbfd,0x79b492a7,0x70b999a9,0x6bae84bb,0x62a38fb5,0x5d80be9f,0x548db591,0x4f9aa883,0x4697a38d];function convertToInt32(bytes){var result=[];for(var i=0;i<bytes.length;i+=4){result.push(bytes[i]<<24|bytes[i+1]<<16|bytes[i+2]<<8|bytes[i+3]);}return result;}var AES=function AES(key){if(!(this instanceof AES)){throw Error('AES must be instanitated with `new`');}Object.defineProperty(this,'key',{value:coerceArray(key,true)});this._prepare();};AES.prototype._prepare=function(){var rounds=numberOfRounds[this.key.length];if(rounds==null){throw new Error('invalid key size (must be 16, 24 or 32 bytes)');}// encryption round keys\nthis._Ke=[];// decryption round keys\nthis._Kd=[];for(var i=0;i<=rounds;i++){this._Ke.push([0,0,0,0]);this._Kd.push([0,0,0,0]);}var roundKeyCount=(rounds+1)*4;var KC=this.key.length/4;// convert the key into ints\nvar tk=convertToInt32(this.key);// copy values into round key arrays\nvar index;for(var i=0;i<KC;i++){index=i>>2;this._Ke[index][i%4]=tk[i];this._Kd[rounds-index][i%4]=tk[i];}// key expansion (fips-197 section 5.2)\nvar rconpointer=0;var t=KC,tt;while(t<roundKeyCount){tt=tk[KC-1];tk[0]^=S[tt>>16&0xFF]<<24^S[tt>>8&0xFF]<<16^S[tt&0xFF]<<8^S[tt>>24&0xFF]^rcon[rconpointer]<<24;rconpointer+=1;// key expansion (for non-256 bit)\nif(KC!=8){for(var i=1;i<KC;i++){tk[i]^=tk[i-1];}// key expansion for 256-bit keys is \"slightly different\" (fips-197)\n}else{for(var i=1;i<KC/2;i++){tk[i]^=tk[i-1];}tt=tk[KC/2-1];tk[KC/2]^=S[tt&0xFF]^S[tt>>8&0xFF]<<8^S[tt>>16&0xFF]<<16^S[tt>>24&0xFF]<<24;for(var i=KC/2+1;i<KC;i++){tk[i]^=tk[i-1];}}// copy values into round key arrays\nvar i=0,r,c;while(i<KC&&t<roundKeyCount){r=t>>2;c=t%4;this._Ke[r][c]=tk[i];this._Kd[rounds-r][c]=tk[i++];t++;}}// inverse-cipher-ify the decryption round key (fips-197 section 5.3)\nfor(var r=1;r<rounds;r++){for(var c=0;c<4;c++){tt=this._Kd[r][c];this._Kd[r][c]=U1[tt>>24&0xFF]^U2[tt>>16&0xFF]^U3[tt>>8&0xFF]^U4[tt&0xFF];}}};AES.prototype.encrypt=function(plaintext){if(plaintext.length!=16){throw new Error('invalid plaintext size (must be 16 bytes)');}var rounds=this._Ke.length-1;var a=[0,0,0,0];// convert plaintext to (ints ^ key)\nvar t=convertToInt32(plaintext);for(var i=0;i<4;i++){t[i]^=this._Ke[0][i];}// apply round transforms\nfor(var r=1;r<rounds;r++){for(var i=0;i<4;i++){a[i]=T1[t[i]>>24&0xff]^T2[t[(i+1)%4]>>16&0xff]^T3[t[(i+2)%4]>>8&0xff]^T4[t[(i+3)%4]&0xff]^this._Ke[r][i];}t=a.slice();}// the last round is special\nvar result=createArray(16),tt;for(var i=0;i<4;i++){tt=this._Ke[rounds][i];result[4*i]=(S[t[i]>>24&0xff]^tt>>24)&0xff;result[4*i+1]=(S[t[(i+1)%4]>>16&0xff]^tt>>16)&0xff;result[4*i+2]=(S[t[(i+2)%4]>>8&0xff]^tt>>8)&0xff;result[4*i+3]=(S[t[(i+3)%4]&0xff]^tt)&0xff;}return result;};AES.prototype.decrypt=function(ciphertext){if(ciphertext.length!=16){throw new Error('invalid ciphertext size (must be 16 bytes)');}var rounds=this._Kd.length-1;var a=[0,0,0,0];// convert plaintext to (ints ^ key)\nvar t=convertToInt32(ciphertext);for(var i=0;i<4;i++){t[i]^=this._Kd[0][i];}// apply round transforms\nfor(var r=1;r<rounds;r++){for(var i=0;i<4;i++){a[i]=T5[t[i]>>24&0xff]^T6[t[(i+3)%4]>>16&0xff]^T7[t[(i+2)%4]>>8&0xff]^T8[t[(i+1)%4]&0xff]^this._Kd[r][i];}t=a.slice();}// the last round is special\nvar result=createArray(16),tt;for(var i=0;i<4;i++){tt=this._Kd[rounds][i];result[4*i]=(Si[t[i]>>24&0xff]^tt>>24)&0xff;result[4*i+1]=(Si[t[(i+3)%4]>>16&0xff]^tt>>16)&0xff;result[4*i+2]=(Si[t[(i+2)%4]>>8&0xff]^tt>>8)&0xff;result[4*i+3]=(Si[t[(i+1)%4]&0xff]^tt)&0xff;}return result;};/**\n\t     *  Mode Of Operation - Electonic Codebook (ECB)\n\t     */var ModeOfOperationECB=function ModeOfOperationECB(key){if(!(this instanceof ModeOfOperationECB)){throw Error('AES must be instanitated with `new`');}this.description=\"Electronic Code Block\";this.name=\"ecb\";this._aes=new AES(key);};ModeOfOperationECB.prototype.encrypt=function(plaintext){plaintext=coerceArray(plaintext);if(plaintext.length%16!==0){throw new Error('invalid plaintext size (must be multiple of 16 bytes)');}var ciphertext=createArray(plaintext.length);var block=createArray(16);for(var i=0;i<plaintext.length;i+=16){copyArray(plaintext,block,0,i,i+16);block=this._aes.encrypt(block);copyArray(block,ciphertext,i);}return ciphertext;};ModeOfOperationECB.prototype.decrypt=function(ciphertext){ciphertext=coerceArray(ciphertext);if(ciphertext.length%16!==0){throw new Error('invalid ciphertext size (must be multiple of 16 bytes)');}var plaintext=createArray(ciphertext.length);var block=createArray(16);for(var i=0;i<ciphertext.length;i+=16){copyArray(ciphertext,block,0,i,i+16);block=this._aes.decrypt(block);copyArray(block,plaintext,i);}return plaintext;};/**\n\t     *  Mode Of Operation - Cipher Block Chaining (CBC)\n\t     */var ModeOfOperationCBC=function ModeOfOperationCBC(key,iv){if(!(this instanceof ModeOfOperationCBC)){throw Error('AES must be instanitated with `new`');}this.description=\"Cipher Block Chaining\";this.name=\"cbc\";if(!iv){iv=createArray(16);}else if(iv.length!=16){throw new Error('invalid initialation vector size (must be 16 bytes)');}this._lastCipherblock=coerceArray(iv,true);this._aes=new AES(key);};ModeOfOperationCBC.prototype.encrypt=function(plaintext){plaintext=coerceArray(plaintext);if(plaintext.length%16!==0){throw new Error('invalid plaintext size (must be multiple of 16 bytes)');}var ciphertext=createArray(plaintext.length);var block=createArray(16);for(var i=0;i<plaintext.length;i+=16){copyArray(plaintext,block,0,i,i+16);for(var j=0;j<16;j++){block[j]^=this._lastCipherblock[j];}this._lastCipherblock=this._aes.encrypt(block);copyArray(this._lastCipherblock,ciphertext,i);}return ciphertext;};ModeOfOperationCBC.prototype.decrypt=function(ciphertext){ciphertext=coerceArray(ciphertext);if(ciphertext.length%16!==0){throw new Error('invalid ciphertext size (must be multiple of 16 bytes)');}var plaintext=createArray(ciphertext.length);var block=createArray(16);for(var i=0;i<ciphertext.length;i+=16){copyArray(ciphertext,block,0,i,i+16);block=this._aes.decrypt(block);for(var j=0;j<16;j++){plaintext[i+j]=block[j]^this._lastCipherblock[j];}copyArray(ciphertext,this._lastCipherblock,0,i,i+16);}return plaintext;};/**\n\t     *  Mode Of Operation - Cipher Feedback (CFB)\n\t     */var ModeOfOperationCFB=function ModeOfOperationCFB(key,iv,segmentSize){if(!(this instanceof ModeOfOperationCFB)){throw Error('AES must be instanitated with `new`');}this.description=\"Cipher Feedback\";this.name=\"cfb\";if(!iv){iv=createArray(16);}else if(iv.length!=16){throw new Error('invalid initialation vector size (must be 16 size)');}if(!segmentSize){segmentSize=1;}this.segmentSize=segmentSize;this._shiftRegister=coerceArray(iv,true);this._aes=new AES(key);};ModeOfOperationCFB.prototype.encrypt=function(plaintext){if(plaintext.length%this.segmentSize!=0){throw new Error('invalid plaintext size (must be segmentSize bytes)');}var encrypted=coerceArray(plaintext,true);var xorSegment;for(var i=0;i<encrypted.length;i+=this.segmentSize){xorSegment=this._aes.encrypt(this._shiftRegister);for(var j=0;j<this.segmentSize;j++){encrypted[i+j]^=xorSegment[j];}// Shift the register\ncopyArray(this._shiftRegister,this._shiftRegister,0,this.segmentSize);copyArray(encrypted,this._shiftRegister,16-this.segmentSize,i,i+this.segmentSize);}return encrypted;};ModeOfOperationCFB.prototype.decrypt=function(ciphertext){if(ciphertext.length%this.segmentSize!=0){throw new Error('invalid ciphertext size (must be segmentSize bytes)');}var plaintext=coerceArray(ciphertext,true);var xorSegment;for(var i=0;i<plaintext.length;i+=this.segmentSize){xorSegment=this._aes.encrypt(this._shiftRegister);for(var j=0;j<this.segmentSize;j++){plaintext[i+j]^=xorSegment[j];}// Shift the register\ncopyArray(this._shiftRegister,this._shiftRegister,0,this.segmentSize);copyArray(ciphertext,this._shiftRegister,16-this.segmentSize,i,i+this.segmentSize);}return plaintext;};/**\n\t     *  Mode Of Operation - Output Feedback (OFB)\n\t     */var ModeOfOperationOFB=function ModeOfOperationOFB(key,iv){if(!(this instanceof ModeOfOperationOFB)){throw Error('AES must be instanitated with `new`');}this.description=\"Output Feedback\";this.name=\"ofb\";if(!iv){iv=createArray(16);}else if(iv.length!=16){throw new Error('invalid initialation vector size (must be 16 bytes)');}this._lastPrecipher=coerceArray(iv,true);this._lastPrecipherIndex=16;this._aes=new AES(key);};ModeOfOperationOFB.prototype.encrypt=function(plaintext){var encrypted=coerceArray(plaintext,true);for(var i=0;i<encrypted.length;i++){if(this._lastPrecipherIndex===16){this._lastPrecipher=this._aes.encrypt(this._lastPrecipher);this._lastPrecipherIndex=0;}encrypted[i]^=this._lastPrecipher[this._lastPrecipherIndex++];}return encrypted;};// Decryption is symetric\nModeOfOperationOFB.prototype.decrypt=ModeOfOperationOFB.prototype.encrypt;/**\n\t     *  Counter object for CTR common mode of operation\n\t     */var Counter=function Counter(initialValue){if(!(this instanceof Counter)){throw Error('Counter must be instanitated with `new`');}// We allow 0, but anything false-ish uses the default 1\nif(initialValue!==0&&!initialValue){initialValue=1;}if(typeof initialValue==='number'){this._counter=createArray(16);this.setValue(initialValue);}else{this.setBytes(initialValue);}};Counter.prototype.setValue=function(value){if(typeof value!=='number'||parseInt(value)!=value){throw new Error('invalid counter value (must be an integer)');}for(var index=15;index>=0;--index){this._counter[index]=value%256;value=value>>8;}};Counter.prototype.setBytes=function(bytes){bytes=coerceArray(bytes,true);if(bytes.length!=16){throw new Error('invalid counter bytes size (must be 16 bytes)');}this._counter=bytes;};Counter.prototype.increment=function(){for(var i=15;i>=0;i--){if(this._counter[i]===255){this._counter[i]=0;}else{this._counter[i]++;break;}}};/**\n\t     *  Mode Of Operation - Counter (CTR)\n\t     */var ModeOfOperationCTR=function ModeOfOperationCTR(key,counter){if(!(this instanceof ModeOfOperationCTR)){throw Error('AES must be instanitated with `new`');}this.description=\"Counter\";this.name=\"ctr\";if(!(counter instanceof Counter)){counter=new Counter(counter);}this._counter=counter;this._remainingCounter=null;this._remainingCounterIndex=16;this._aes=new AES(key);};ModeOfOperationCTR.prototype.encrypt=function(plaintext){var encrypted=coerceArray(plaintext,true);for(var i=0;i<encrypted.length;i++){if(this._remainingCounterIndex===16){this._remainingCounter=this._aes.encrypt(this._counter._counter);this._remainingCounterIndex=0;this._counter.increment();}encrypted[i]^=this._remainingCounter[this._remainingCounterIndex++];}return encrypted;};// Decryption is symetric\nModeOfOperationCTR.prototype.decrypt=ModeOfOperationCTR.prototype.encrypt;///////////////////////\n// Padding\n// See:https://tools.ietf.org/html/rfc2315\nfunction pkcs7pad(data){data=coerceArray(data,true);var padder=16-data.length%16;var result=createArray(data.length+padder);copyArray(data,result);for(var i=data.length;i<result.length;i++){result[i]=padder;}return result;}function pkcs7strip(data){data=coerceArray(data,true);if(data.length<16){throw new Error('PKCS#7 invalid length');}var padder=data[data.length-1];if(padder>16){throw new Error('PKCS#7 padding byte out of range');}var length=data.length-padder;for(var i=0;i<padder;i++){if(data[length+i]!==padder){throw new Error('PKCS#7 invalid padding byte');}}var result=createArray(length);copyArray(data,result,0,0,length);return result;}///////////////////////\n// Exporting\n// The block cipher\nvar aesjs={AES:AES,Counter:Counter,ModeOfOperation:{ecb:ModeOfOperationECB,cbc:ModeOfOperationCBC,cfb:ModeOfOperationCFB,ofb:ModeOfOperationOFB,ctr:ModeOfOperationCTR},utils:{hex:convertHex,utf8:convertUtf8},padding:{pkcs7:{pad:pkcs7pad,strip:pkcs7strip}},_arrayTest:{coerceArray:coerceArray,createArray:createArray,copyArray:copyArray}};// node.js\nif(true){module.exports=aesjs;// RequireJS/AMD\n// http://www.requirejs.org/docs/api.html\n// https://github.com/amdjs/amdjs-api/wiki/AMD\n}else {}})(commonjsGlobal);});var _version$A=createCommonjsModule(function(module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});exports.version=\"json-wallets/5.0.4\";});var _version$B=unwrapExports(_version$A);var _version_1$i=_version$A.version;var utils$1=createCommonjsModule(function(module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});function looseArrayify(hexString){if(typeof hexString==='string'&&hexString.substring(0,2)!=='0x'){hexString='0x'+hexString;}return lib$1.arrayify(hexString);}exports.looseArrayify=looseArrayify;function zpad(value,length){value=String(value);while(value.length<length){value='0'+value;}return value;}exports.zpad=zpad;function getPassword(password){if(typeof password==='string'){return lib$8.toUtf8Bytes(password,lib$8.UnicodeNormalizationForm.NFKC);}return lib$1.arrayify(password);}exports.getPassword=getPassword;function searchPath(object,path){var currentChild=object;var comps=path.toLowerCase().split('/');for(var i=0;i<comps.length;i++){// Search for a child object with a case-insensitive matching key\nvar matchingChild=null;for(var key in currentChild){if(key.toLowerCase()===comps[i]){matchingChild=currentChild[key];break;}}// Didn't find one. :'(\nif(matchingChild===null){return null;}// Now check this child...\ncurrentChild=matchingChild;}return currentChild;}exports.searchPath=searchPath;// See: https://www.ietf.org/rfc/rfc4122.txt (Section 4.4)\nfunction uuidV4(randomBytes){var bytes=lib$1.arrayify(randomBytes);// Section: 4.1.3:\n// - time_hi_and_version[12:16] = 0b0100\nbytes[6]=bytes[6]&0x0f|0x40;// Section 4.4\n// - clock_seq_hi_and_reserved[6] = 0b0\n// - clock_seq_hi_and_reserved[7] = 0b1\nbytes[8]=bytes[8]&0x3f|0x80;var value=lib$1.hexlify(bytes);return[value.substring(2,10),value.substring(10,14),value.substring(14,18),value.substring(18,22),value.substring(22,34)].join(\"-\");}exports.uuidV4=uuidV4;});var utils$2=unwrapExports(utils$1);var utils_1$2=utils$1.looseArrayify;var utils_2=utils$1.zpad;var utils_3=utils$1.getPassword;var utils_4=utils$1.searchPath;var utils_5=utils$1.uuidV4;var crowdsale=createCommonjsModule(function(module,exports){\"use strict\";var __extends=commonjsGlobal&&commonjsGlobal.__extends||function(){var _extendStatics17=function extendStatics(d,b){_extendStatics17=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return _extendStatics17(d,b);};return function(d,b){_extendStatics17(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();var __importDefault=commonjsGlobal&&commonjsGlobal.__importDefault||function(mod){return mod&&mod.__esModule?mod:{\"default\":mod};};Object.defineProperty(exports,\"__esModule\",{value:true});var aes_js_1=__importDefault(aesJs);var logger=new lib.Logger(_version$A.version);var CrowdsaleAccount=/** @class */function(_super){__extends(CrowdsaleAccount,_super);function CrowdsaleAccount(){return _super!==null&&_super.apply(this,arguments)||this;}CrowdsaleAccount.prototype.isCrowdsaleAccount=function(value){return!!(value&&value._isCrowdsaleAccount);};return CrowdsaleAccount;}(lib$3.Description);exports.CrowdsaleAccount=CrowdsaleAccount;// See: https://github.com/ethereum/pyethsaletool\nfunction decrypt(json,password){var data=JSON.parse(json);password=utils$1.getPassword(password);// Ethereum Address\nvar ethaddr=lib$6.getAddress(utils$1.searchPath(data,\"ethaddr\"));// Encrypted Seed\nvar encseed=utils$1.looseArrayify(utils$1.searchPath(data,\"encseed\"));if(!encseed||encseed.length%16!==0){logger.throwArgumentError(\"invalid encseed\",\"json\",json);}var key=lib$1.arrayify(browser$2.pbkdf2(password,password,2000,32,\"sha256\")).slice(0,16);var iv=encseed.slice(0,16);var encryptedSeed=encseed.slice(16);// Decrypt the seed\nvar aesCbc=new aes_js_1.default.ModeOfOperation.cbc(key,iv);var seed=aes_js_1.default.padding.pkcs7.strip(lib$1.arrayify(aesCbc.decrypt(encryptedSeed)));// This wallet format is weird... Convert the binary encoded hex to a string.\nvar seedHex=\"\";for(var i=0;i<seed.length;i++){seedHex+=String.fromCharCode(seed[i]);}var seedHexBytes=lib$8.toUtf8Bytes(seedHex);var privateKey=lib$4.keccak256(seedHexBytes);return new CrowdsaleAccount({_isCrowdsaleAccount:true,address:ethaddr,privateKey:privateKey});}exports.decrypt=decrypt;});var crowdsale$1=unwrapExports(crowdsale);var crowdsale_1=crowdsale.CrowdsaleAccount;var crowdsale_2=crowdsale.decrypt;var inspect=createCommonjsModule(function(module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});function isCrowdsaleWallet(json){var data=null;try{data=JSON.parse(json);}catch(error){return false;}return data.encseed&&data.ethaddr;}exports.isCrowdsaleWallet=isCrowdsaleWallet;function isKeystoreWallet(json){var data=null;try{data=JSON.parse(json);}catch(error){return false;}if(!data.version||parseInt(data.version)!==data.version||parseInt(data.version)!==3){return false;}// @TODO: Put more checks to make sure it has kdf, iv and all that good stuff\nreturn true;}exports.isKeystoreWallet=isKeystoreWallet;//export function isJsonWallet(json: string): boolean {\n//    return (isSecretStorageWallet(json) || isCrowdsaleWallet(json));\n//}\nfunction getJsonWalletAddress(json){if(isCrowdsaleWallet(json)){try{return lib$6.getAddress(JSON.parse(json).ethaddr);}catch(error){return null;}}if(isKeystoreWallet(json)){try{return lib$6.getAddress(JSON.parse(json).address);}catch(error){return null;}}return null;}exports.getJsonWalletAddress=getJsonWalletAddress;});var inspect$1=unwrapExports(inspect);var inspect_1=inspect.isCrowdsaleWallet;var inspect_2=inspect.isKeystoreWallet;var inspect_3=inspect.getJsonWalletAddress;var scrypt=createCommonjsModule(function(module,exports){\"use strict\";(function(root){var MAX_VALUE=0x7fffffff;// The SHA256 and PBKDF2 implementation are from scrypt-async-js:\n// See: https://github.com/dchest/scrypt-async-js\nfunction SHA256(m){var K=new Uint32Array([0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5,0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174,0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da,0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967,0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85,0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,0xd192e819,0xd6990624,0xf40e3585,0x106aa070,0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3,0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2]);var h0=0x6a09e667,h1=0xbb67ae85,h2=0x3c6ef372,h3=0xa54ff53a;var h4=0x510e527f,h5=0x9b05688c,h6=0x1f83d9ab,h7=0x5be0cd19;var w=new Uint32Array(64);function blocks(p){var off=0,len=p.length;while(len>=64){var a=h0,b=h1,c=h2,d=h3,e=h4,_f=h5,g=h6,h=h7,u=void 0,_i2=void 0,j=void 0,t1=void 0,t2=void 0;for(_i2=0;_i2<16;_i2++){j=off+_i2*4;w[_i2]=(p[j]&0xff)<<24|(p[j+1]&0xff)<<16|(p[j+2]&0xff)<<8|p[j+3]&0xff;}for(_i2=16;_i2<64;_i2++){u=w[_i2-2];t1=(u>>>17|u<<32-17)^(u>>>19|u<<32-19)^u>>>10;u=w[_i2-15];t2=(u>>>7|u<<32-7)^(u>>>18|u<<32-18)^u>>>3;w[_i2]=(t1+w[_i2-7]|0)+(t2+w[_i2-16]|0)|0;}for(_i2=0;_i2<64;_i2++){t1=(((e>>>6|e<<32-6)^(e>>>11|e<<32-11)^(e>>>25|e<<32-25))+(e&_f^~e&g)|0)+(h+(K[_i2]+w[_i2]|0)|0)|0;t2=((a>>>2|a<<32-2)^(a>>>13|a<<32-13)^(a>>>22|a<<32-22))+(a&b^a&c^b&c)|0;h=g;g=_f;_f=e;e=d+t1|0;d=c;c=b;b=a;a=t1+t2|0;}h0=h0+a|0;h1=h1+b|0;h2=h2+c|0;h3=h3+d|0;h4=h4+e|0;h5=h5+_f|0;h6=h6+g|0;h7=h7+h|0;off+=64;len-=64;}}blocks(m);var i,bytesLeft=m.length%64,bitLenHi=m.length/0x20000000|0,bitLenLo=m.length<<3,numZeros=bytesLeft<56?56:120,p=m.slice(m.length-bytesLeft,m.length);p.push(0x80);for(i=bytesLeft+1;i<numZeros;i++){p.push(0);}p.push(bitLenHi>>>24&0xff);p.push(bitLenHi>>>16&0xff);p.push(bitLenHi>>>8&0xff);p.push(bitLenHi>>>0&0xff);p.push(bitLenLo>>>24&0xff);p.push(bitLenLo>>>16&0xff);p.push(bitLenLo>>>8&0xff);p.push(bitLenLo>>>0&0xff);blocks(p);return[h0>>>24&0xff,h0>>>16&0xff,h0>>>8&0xff,h0>>>0&0xff,h1>>>24&0xff,h1>>>16&0xff,h1>>>8&0xff,h1>>>0&0xff,h2>>>24&0xff,h2>>>16&0xff,h2>>>8&0xff,h2>>>0&0xff,h3>>>24&0xff,h3>>>16&0xff,h3>>>8&0xff,h3>>>0&0xff,h4>>>24&0xff,h4>>>16&0xff,h4>>>8&0xff,h4>>>0&0xff,h5>>>24&0xff,h5>>>16&0xff,h5>>>8&0xff,h5>>>0&0xff,h6>>>24&0xff,h6>>>16&0xff,h6>>>8&0xff,h6>>>0&0xff,h7>>>24&0xff,h7>>>16&0xff,h7>>>8&0xff,h7>>>0&0xff];}function PBKDF2_HMAC_SHA256_OneIter(password,salt,dkLen){// compress password if it's longer than hash block length\npassword=password.length<=64?password:SHA256(password);var innerLen=64+salt.length+4;var inner=new Array(innerLen);var outerKey=new Array(64);var i;var dk=[];// inner = (password ^ ipad) || salt || counter\nfor(i=0;i<64;i++){inner[i]=0x36;}for(i=0;i<password.length;i++){inner[i]^=password[i];}for(i=0;i<salt.length;i++){inner[64+i]=salt[i];}for(i=innerLen-4;i<innerLen;i++){inner[i]=0;}// outerKey = password ^ opad\nfor(i=0;i<64;i++){outerKey[i]=0x5c;}for(i=0;i<password.length;i++){outerKey[i]^=password[i];}// increments counter inside inner\nfunction incrementCounter(){for(var _i3=innerLen-1;_i3>=innerLen-4;_i3--){inner[_i3]++;if(inner[_i3]<=0xff)return;inner[_i3]=0;}}// output blocks = SHA256(outerKey || SHA256(inner)) ...\nwhile(dkLen>=32){incrementCounter();dk=dk.concat(SHA256(outerKey.concat(SHA256(inner))));dkLen-=32;}if(dkLen>0){incrementCounter();dk=dk.concat(SHA256(outerKey.concat(SHA256(inner))).slice(0,dkLen));}return dk;}// The following is an adaptation of scryptsy\n// See: https://www.npmjs.com/package/scryptsy\nfunction blockmix_salsa8(BY,Yi,r,x,_X){var i;arraycopy(BY,(2*r-1)*16,_X,0,16);for(i=0;i<2*r;i++){blockxor(BY,i*16,_X,16);salsa20_8(_X,x);arraycopy(_X,0,BY,Yi+i*16,16);}for(i=0;i<r;i++){arraycopy(BY,Yi+i*2*16,BY,i*16,16);}for(i=0;i<r;i++){arraycopy(BY,Yi+(i*2+1)*16,BY,(i+r)*16,16);}}function R(a,b){return a<<b|a>>>32-b;}function salsa20_8(B,x){arraycopy(B,0,x,0,16);for(var i=8;i>0;i-=2){x[4]^=R(x[0]+x[12],7);x[8]^=R(x[4]+x[0],9);x[12]^=R(x[8]+x[4],13);x[0]^=R(x[12]+x[8],18);x[9]^=R(x[5]+x[1],7);x[13]^=R(x[9]+x[5],9);x[1]^=R(x[13]+x[9],13);x[5]^=R(x[1]+x[13],18);x[14]^=R(x[10]+x[6],7);x[2]^=R(x[14]+x[10],9);x[6]^=R(x[2]+x[14],13);x[10]^=R(x[6]+x[2],18);x[3]^=R(x[15]+x[11],7);x[7]^=R(x[3]+x[15],9);x[11]^=R(x[7]+x[3],13);x[15]^=R(x[11]+x[7],18);x[1]^=R(x[0]+x[3],7);x[2]^=R(x[1]+x[0],9);x[3]^=R(x[2]+x[1],13);x[0]^=R(x[3]+x[2],18);x[6]^=R(x[5]+x[4],7);x[7]^=R(x[6]+x[5],9);x[4]^=R(x[7]+x[6],13);x[5]^=R(x[4]+x[7],18);x[11]^=R(x[10]+x[9],7);x[8]^=R(x[11]+x[10],9);x[9]^=R(x[8]+x[11],13);x[10]^=R(x[9]+x[8],18);x[12]^=R(x[15]+x[14],7);x[13]^=R(x[12]+x[15],9);x[14]^=R(x[13]+x[12],13);x[15]^=R(x[14]+x[13],18);}for(var _i4=0;_i4<16;++_i4){B[_i4]+=x[_i4];}}// naive approach... going back to loop unrolling may yield additional performance\nfunction blockxor(S,Si,D,len){for(var i=0;i<len;i++){D[i]^=S[Si+i];}}function arraycopy(src,srcPos,dest,destPos,length){while(length--){dest[destPos++]=src[srcPos++];}}function checkBufferish(o){if(!o||typeof o.length!=='number'){return false;}for(var i=0;i<o.length;i++){var v=o[i];if(typeof v!=='number'||v%1||v<0||v>=256){return false;}}return true;}function ensureInteger(value,name){if(typeof value!==\"number\"||value%1){throw new Error('invalid '+name);}return value;}// N = Cpu cost, r = Memory cost, p = parallelization cost\n// callback(error, progress, key)\nfunction _scrypt(password,salt,N,r,p,dkLen,callback){N=ensureInteger(N,'N');r=ensureInteger(r,'r');p=ensureInteger(p,'p');dkLen=ensureInteger(dkLen,'dkLen');if(N===0||(N&N-1)!==0){throw new Error('N must be power of 2');}if(N>MAX_VALUE/128/r){throw new Error('N too large');}if(r>MAX_VALUE/128/p){throw new Error('r too large');}if(!checkBufferish(password)){throw new Error('password must be an array or buffer');}password=Array.prototype.slice.call(password);if(!checkBufferish(salt)){throw new Error('salt must be an array or buffer');}salt=Array.prototype.slice.call(salt);var b=PBKDF2_HMAC_SHA256_OneIter(password,salt,p*128*r);var B=new Uint32Array(p*32*r);for(var i=0;i<B.length;i++){var j=i*4;B[i]=(b[j+3]&0xff)<<24|(b[j+2]&0xff)<<16|(b[j+1]&0xff)<<8|(b[j+0]&0xff)<<0;}var XY=new Uint32Array(64*r);var V=new Uint32Array(32*r*N);var Yi=32*r;// scratch space\nvar x=new Uint32Array(16);// salsa20_8\nvar _X=new Uint32Array(16);// blockmix_salsa8\nvar totalOps=p*N*2;var currentOp=0;var lastPercent10=null;// Set this to true to abandon the scrypt on the next step\nvar stop=false;// State information\nvar state=0;var i0=0,i1;var Bi;// How many blockmix_salsa8 can we do per step?\nvar limit=callback?parseInt(1000/r):0xffffffff;// Trick from scrypt-async; if there is a setImmediate shim in place, use it\nvar nextTick=typeof setImmediate!=='undefined'?setImmediate:setTimeout;// This is really all I changed; making scryptsy a state machine so we occasionally\n// stop and give other evnts on the evnt loop a chance to run. ~RicMoo\nvar incrementalSMix=function incrementalSMix(){if(stop){return callback(new Error('cancelled'),currentOp/totalOps);}var steps;switch(state){case 0:// for (var i = 0; i < p; i++)...\nBi=i0*32*r;arraycopy(B,Bi,XY,0,Yi);// ROMix - 1\nstate=1;// Move to ROMix 2\ni1=0;// Fall through\ncase 1:// Run up to 1000 steps of the first inner smix loop\nsteps=N-i1;if(steps>limit){steps=limit;}for(var _i5=0;_i5<steps;_i5++){// ROMix - 2\narraycopy(XY,0,V,(i1+_i5)*Yi,Yi);// ROMix - 3\nblockmix_salsa8(XY,Yi,r,x,_X);// ROMix - 4\n}// for (var i = 0; i < N; i++)\ni1+=steps;currentOp+=steps;if(callback){// Call the callback with the progress (optionally stopping us)\nvar percent10=parseInt(1000*currentOp/totalOps);if(percent10!==lastPercent10){stop=callback(null,currentOp/totalOps);if(stop){break;}lastPercent10=percent10;}}if(i1<N){break;}i1=0;// Move to ROMix 6\nstate=2;// Fall through\ncase 2:// Run up to 1000 steps of the second inner smix loop\nsteps=N-i1;if(steps>limit){steps=limit;}for(var _i6=0;_i6<steps;_i6++){// ROMix - 6\nvar offset=(2*r-1)*16;// ROMix - 7\nvar _j=XY[offset]&N-1;blockxor(V,_j*Yi,XY,Yi);// ROMix - 8 (inner)\nblockmix_salsa8(XY,Yi,r,x,_X);// ROMix - 9 (outer)\n}// for (var i = 0; i < N; i++)...\ni1+=steps;currentOp+=steps;// Call the callback with the progress (optionally stopping us)\nif(callback){var _percent=parseInt(1000*currentOp/totalOps);if(_percent!==lastPercent10){stop=callback(null,currentOp/totalOps);if(stop){break;}lastPercent10=_percent;}}if(i1<N){break;}arraycopy(XY,0,B,Bi,Yi);// ROMix - 10\n// for (var i = 0; i < p; i++)...\ni0++;if(i0<p){state=0;break;}b=[];for(var _i7=0;_i7<B.length;_i7++){b.push(B[_i7]>>0&0xff);b.push(B[_i7]>>8&0xff);b.push(B[_i7]>>16&0xff);b.push(B[_i7]>>24&0xff);}var derivedKey=PBKDF2_HMAC_SHA256_OneIter(password,b,dkLen);// Send the result to the callback\nif(callback){callback(null,1.0,derivedKey);}// Done; don't break (which would reschedule)\nreturn derivedKey;}// Schedule the next steps\nif(callback){nextTick(incrementalSMix);}};// Run the smix state machine until completion\nif(!callback){while(true){var derivedKey=incrementalSMix();if(derivedKey!=undefined){return derivedKey;}}}// Bootstrap the async incremental smix\nincrementalSMix();}var lib={scrypt:function scrypt(password,salt,N,r,p,dkLen,progressCallback){return new Promise(function(resolve,reject){var lastProgress=0;if(progressCallback){progressCallback(0);}_scrypt(password,salt,N,r,p,dkLen,function(error,progress,key){if(error){reject(error);}else if(key){if(progressCallback&&lastProgress!==1){progressCallback(1);}resolve(new Uint8Array(key));}else if(progressCallback&&progress!==lastProgress){lastProgress=progress;return progressCallback(progress);}});});},syncScrypt:function syncScrypt(password,salt,N,r,p,dkLen){return new Uint8Array(_scrypt(password,salt,N,r,p,dkLen));}};// node.js\nif(true){module.exports=lib;// RequireJS/AMD\n// http://www.requirejs.org/docs/api.html\n// https://github.com/amdjs/amdjs-api/wiki/AMD\n}else {}})(commonjsGlobal);});var scrypt_1=scrypt.scrypt;var scrypt_2=scrypt.syncScrypt;var keystore=createCommonjsModule(function(module,exports){\"use strict\";var __extends=commonjsGlobal&&commonjsGlobal.__extends||function(){var _extendStatics18=function extendStatics(d,b){_extendStatics18=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return _extendStatics18(d,b);};return function(d,b){_extendStatics18(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();var __awaiter=commonjsGlobal&&commonjsGlobal.__awaiter||function(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P(function(resolve){resolve(value);});}return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value));}catch(e){reject(e);}}function rejected(value){try{step(generator[\"throw\"](value));}catch(e){reject(e);}}function step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected);}step((generator=generator.apply(thisArg,_arguments||[])).next());});};var __generator=commonjsGlobal&&commonjsGlobal.__generator||function(thisArg,body){var _={label:0,sent:function sent(){if(t[0]&1)throw t[1];return t[1];},trys:[],ops:[]},f,y,t,g;return g={next:verb(0),\"throw\":verb(1),\"return\":verb(2)},typeof Symbol===\"function\"&&(g[Symbol.iterator]=function(){return this;}),g;function verb(n){return function(v){return step([n,v]);};}function step(op){if(f)throw new TypeError(\"Generator is already executing.\");while(_){try{if(f=1,y&&(t=op[0]&2?y[\"return\"]:op[0]?y[\"throw\"]||((t=y[\"return\"])&&t.call(y),0):y.next)&&!(t=t.call(y,op[1])).done)return t;if(y=0,t)op=[op[0]&2,t.value];switch(op[0]){case 0:case 1:t=op;break;case 4:_.label++;return{value:op[1],done:false};case 5:_.label++;y=op[1];op=[0];continue;case 7:op=_.ops.pop();_.trys.pop();continue;default:if(!(t=_.trys,t=t.length>0&&t[t.length-1])&&(op[0]===6||op[0]===2)){_=0;continue;}if(op[0]===3&&(!t||op[1]>t[0]&&op[1]<t[3])){_.label=op[1];break;}if(op[0]===6&&_.label<t[1]){_.label=t[1];t=op;break;}if(t&&_.label<t[2]){_.label=t[2];_.ops.push(op);break;}if(t[2])_.ops.pop();_.trys.pop();continue;}op=body.call(thisArg,_);}catch(e){op=[6,e];y=0;}finally{f=t=0;}}if(op[0]&5)throw op[1];return{value:op[0]?op[1]:void 0,done:true};}};var __importDefault=commonjsGlobal&&commonjsGlobal.__importDefault||function(mod){return mod&&mod.__esModule?mod:{\"default\":mod};};var __importStar=commonjsGlobal&&commonjsGlobal.__importStar||function(mod){if(mod&&mod.__esModule)return mod;var result={};if(mod!=null)for(var k in mod){if(Object.hasOwnProperty.call(mod,k))result[k]=mod[k];}result[\"default\"]=mod;return result;};Object.defineProperty(exports,\"__esModule\",{value:true});var aes_js_1=__importDefault(aesJs);var scrypt$1=__importStar(scrypt);var logger=new lib.Logger(_version$A.version);// Exported Types\nfunction hasMnemonic(value){return value!=null&&value.mnemonic&&value.mnemonic.phrase;}var KeystoreAccount=/** @class */function(_super){__extends(KeystoreAccount,_super);function KeystoreAccount(){return _super!==null&&_super.apply(this,arguments)||this;}KeystoreAccount.prototype.isKeystoreAccount=function(value){return!!(value&&value._isKeystoreAccount);};return KeystoreAccount;}(lib$3.Description);exports.KeystoreAccount=KeystoreAccount;function _decrypt(data,key,ciphertext){var cipher=utils$1.searchPath(data,\"crypto/cipher\");if(cipher===\"aes-128-ctr\"){var iv=utils$1.looseArrayify(utils$1.searchPath(data,\"crypto/cipherparams/iv\"));var counter=new aes_js_1.default.Counter(iv);var aesCtr=new aes_js_1.default.ModeOfOperation.ctr(key,counter);return lib$1.arrayify(aesCtr.decrypt(ciphertext));}return null;}function _getAccount(data,key){var ciphertext=utils$1.looseArrayify(utils$1.searchPath(data,\"crypto/ciphertext\"));var computedMAC=lib$1.hexlify(lib$4.keccak256(lib$1.concat([key.slice(16,32),ciphertext]))).substring(2);if(computedMAC!==utils$1.searchPath(data,\"crypto/mac\").toLowerCase()){throw new Error(\"invalid password\");}var privateKey=_decrypt(data,key.slice(0,16),ciphertext);if(!privateKey){logger.throwError(\"unsupported cipher\",lib.Logger.errors.UNSUPPORTED_OPERATION,{operation:\"decrypt\"});}var mnemonicKey=key.slice(32,64);var address=lib$g.computeAddress(privateKey);if(data.address){var check=data.address.toLowerCase();if(check.substring(0,2)!==\"0x\"){check=\"0x\"+check;}if(lib$6.getAddress(check)!==address){throw new Error(\"address mismatch\");}}var account={_isKeystoreAccount:true,address:address,privateKey:lib$1.hexlify(privateKey)};// Version 0.1 x-ethers metadata must contain an encrypted mnemonic phrase\nif(utils$1.searchPath(data,\"x-ethers/version\")===\"0.1\"){var mnemonicCiphertext=utils$1.looseArrayify(utils$1.searchPath(data,\"x-ethers/mnemonicCiphertext\"));var mnemonicIv=utils$1.looseArrayify(utils$1.searchPath(data,\"x-ethers/mnemonicCounter\"));var mnemonicCounter=new aes_js_1.default.Counter(mnemonicIv);var mnemonicAesCtr=new aes_js_1.default.ModeOfOperation.ctr(mnemonicKey,mnemonicCounter);var path=utils$1.searchPath(data,\"x-ethers/path\")||lib$h.defaultPath;var locale=utils$1.searchPath(data,\"x-ethers/locale\")||\"en\";var entropy=lib$1.arrayify(mnemonicAesCtr.decrypt(mnemonicCiphertext));try{var mnemonic=lib$h.entropyToMnemonic(entropy,locale);var node=lib$h.HDNode.fromMnemonic(mnemonic,null,locale).derivePath(path);if(node.privateKey!=account.privateKey){throw new Error(\"mnemonic mismatch\");}account.mnemonic=node.mnemonic;}catch(error){// If we don't have the locale wordlist installed to\n// read this mnemonic, just bail and don't set the\n// mnemonic\nif(error.code!==lib.Logger.errors.INVALID_ARGUMENT||error.argument!==\"wordlist\"){throw error;}}}return new KeystoreAccount(account);}function pbkdf2Sync(passwordBytes,salt,count,dkLen,prfFunc){return lib$1.arrayify(browser$2.pbkdf2(passwordBytes,salt,count,dkLen,prfFunc));}function pbkdf2(passwordBytes,salt,count,dkLen,prfFunc){return Promise.resolve(pbkdf2Sync(passwordBytes,salt,count,dkLen,prfFunc));}function _computeKdfKey(data,password,pbkdf2Func,scryptFunc,progressCallback){var passwordBytes=utils$1.getPassword(password);var kdf=utils$1.searchPath(data,\"crypto/kdf\");if(kdf&&typeof kdf===\"string\"){var throwError=function throwError(name,value){return logger.throwArgumentError(\"invalid key-derivation function parameters\",name,value);};if(kdf.toLowerCase()===\"scrypt\"){var salt=utils$1.looseArrayify(utils$1.searchPath(data,\"crypto/kdfparams/salt\"));var N=parseInt(utils$1.searchPath(data,\"crypto/kdfparams/n\"));var r=parseInt(utils$1.searchPath(data,\"crypto/kdfparams/r\"));var p=parseInt(utils$1.searchPath(data,\"crypto/kdfparams/p\"));// Check for all required parameters\nif(!N||!r||!p){throwError(\"kdf\",kdf);}// Make sure N is a power of 2\nif((N&N-1)!==0){throwError(\"N\",N);}var dkLen=parseInt(utils$1.searchPath(data,\"crypto/kdfparams/dklen\"));if(dkLen!==32){throwError(\"dklen\",dkLen);}return scryptFunc(passwordBytes,salt,N,r,p,64,progressCallback);}else if(kdf.toLowerCase()===\"pbkdf2\"){var salt=utils$1.looseArrayify(utils$1.searchPath(data,\"crypto/kdfparams/salt\"));var prfFunc=null;var prf=utils$1.searchPath(data,\"crypto/kdfparams/prf\");if(prf===\"hmac-sha256\"){prfFunc=\"sha256\";}else if(prf===\"hmac-sha512\"){prfFunc=\"sha512\";}else{throwError(\"prf\",prf);}var count=parseInt(utils$1.searchPath(data,\"crypto/kdfparams/c\"));var dkLen=parseInt(utils$1.searchPath(data,\"crypto/kdfparams/dklen\"));if(dkLen!==32){throwError(\"dklen\",dkLen);}return pbkdf2Func(passwordBytes,salt,count,dkLen,prfFunc);}}return logger.throwArgumentError(\"unsupported key-derivation function\",\"kdf\",kdf);}function decryptSync(json,password){var data=JSON.parse(json);var key=_computeKdfKey(data,password,pbkdf2Sync,scrypt$1.syncScrypt);return _getAccount(data,key);}exports.decryptSync=decryptSync;function decrypt(json,password,progressCallback){return __awaiter(this,void 0,void 0,function(){var data,key;return __generator(this,function(_a){switch(_a.label){case 0:data=JSON.parse(json);return[4/*yield*/,_computeKdfKey(data,password,pbkdf2,scrypt$1.scrypt,progressCallback)];case 1:key=_a.sent();return[2/*return*/,_getAccount(data,key)];}});});}exports.decrypt=decrypt;function encrypt(account,password,options,progressCallback){try{// Check the address matches the private key\nif(lib$6.getAddress(account.address)!==lib$g.computeAddress(account.privateKey)){throw new Error(\"address/privateKey mismatch\");}// Check the mnemonic (if any) matches the private key\nif(hasMnemonic(account)){var mnemonic=account.mnemonic;var node=lib$h.HDNode.fromMnemonic(mnemonic.phrase,null,mnemonic.locale).derivePath(mnemonic.path||lib$h.defaultPath);if(node.privateKey!=account.privateKey){throw new Error(\"mnemonic mismatch\");}}}catch(e){return Promise.reject(e);}// The options are optional, so adjust the call as needed\nif(typeof options===\"function\"&&!progressCallback){progressCallback=options;options={};}if(!options){options={};}var privateKey=lib$1.arrayify(account.privateKey);var passwordBytes=utils$1.getPassword(password);var entropy=null;var path=null;var locale=null;if(hasMnemonic(account)){var srcMnemonic=account.mnemonic;entropy=lib$1.arrayify(lib$h.mnemonicToEntropy(srcMnemonic.phrase,srcMnemonic.locale||\"en\"));path=srcMnemonic.path||lib$h.defaultPath;locale=srcMnemonic.locale||\"en\";}var client=options.client;if(!client){client=\"ethers.js\";}// Check/generate the salt\nvar salt=null;if(options.salt){salt=lib$1.arrayify(options.salt);}else{salt=browser$6.randomBytes(32);;}// Override initialization vector\nvar iv=null;if(options.iv){iv=lib$1.arrayify(options.iv);if(iv.length!==16){throw new Error(\"invalid iv\");}}else{iv=browser$6.randomBytes(16);}// Override the uuid\nvar uuidRandom=null;if(options.uuid){uuidRandom=lib$1.arrayify(options.uuid);if(uuidRandom.length!==16){throw new Error(\"invalid uuid\");}}else{uuidRandom=browser$6.randomBytes(16);}// Override the scrypt password-based key derivation function parameters\nvar N=1<<17,r=8,p=1;if(options.scrypt){if(options.scrypt.N){N=options.scrypt.N;}if(options.scrypt.r){r=options.scrypt.r;}if(options.scrypt.p){p=options.scrypt.p;}}// We take 64 bytes:\n//   - 32 bytes   As normal for the Web3 secret storage (derivedKey, macPrefix)\n//   - 32 bytes   AES key to encrypt mnemonic with (required here to be Ethers Wallet)\nreturn scrypt$1.scrypt(passwordBytes,salt,N,r,p,64,progressCallback).then(function(key){key=lib$1.arrayify(key);// This will be used to encrypt the wallet (as per Web3 secret storage)\nvar derivedKey=key.slice(0,16);var macPrefix=key.slice(16,32);// This will be used to encrypt the mnemonic phrase (if any)\nvar mnemonicKey=key.slice(32,64);// Encrypt the private key\nvar counter=new aes_js_1.default.Counter(iv);var aesCtr=new aes_js_1.default.ModeOfOperation.ctr(derivedKey,counter);var ciphertext=lib$1.arrayify(aesCtr.encrypt(privateKey));// Compute the message authentication code, used to check the password\nvar mac=lib$4.keccak256(lib$1.concat([macPrefix,ciphertext]));// See: https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition\nvar data={address:account.address.substring(2).toLowerCase(),id:utils$1.uuidV4(uuidRandom),version:3,Crypto:{cipher:\"aes-128-ctr\",cipherparams:{iv:lib$1.hexlify(iv).substring(2)},ciphertext:lib$1.hexlify(ciphertext).substring(2),kdf:\"scrypt\",kdfparams:{salt:lib$1.hexlify(salt).substring(2),n:N,dklen:32,p:p,r:r},mac:mac.substring(2)}};// If we have a mnemonic, encrypt it into the JSON wallet\nif(entropy){var mnemonicIv=browser$6.randomBytes(16);var mnemonicCounter=new aes_js_1.default.Counter(mnemonicIv);var mnemonicAesCtr=new aes_js_1.default.ModeOfOperation.ctr(mnemonicKey,mnemonicCounter);var mnemonicCiphertext=lib$1.arrayify(mnemonicAesCtr.encrypt(entropy));var now=new Date();var timestamp=now.getUTCFullYear()+\"-\"+utils$1.zpad(now.getUTCMonth()+1,2)+\"-\"+utils$1.zpad(now.getUTCDate(),2)+\"T\"+utils$1.zpad(now.getUTCHours(),2)+\"-\"+utils$1.zpad(now.getUTCMinutes(),2)+\"-\"+utils$1.zpad(now.getUTCSeconds(),2)+\".0Z\";data[\"x-ethers\"]={client:client,gethFilename:\"UTC--\"+timestamp+\"--\"+data.address,mnemonicCounter:lib$1.hexlify(mnemonicIv).substring(2),mnemonicCiphertext:lib$1.hexlify(mnemonicCiphertext).substring(2),path:path,locale:locale,version:\"0.1\"};}return JSON.stringify(data);});}exports.encrypt=encrypt;});var keystore$1=unwrapExports(keystore);var keystore_1=keystore.KeystoreAccount;var keystore_2=keystore.decryptSync;var keystore_3=keystore.decrypt;var keystore_4=keystore.encrypt;var lib$i=createCommonjsModule(function(module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});exports.decryptCrowdsale=crowdsale.decrypt;exports.getJsonWalletAddress=inspect.getJsonWalletAddress;exports.isCrowdsaleWallet=inspect.isCrowdsaleWallet;exports.isKeystoreWallet=inspect.isKeystoreWallet;exports.decryptKeystore=keystore.decrypt;exports.decryptKeystoreSync=keystore.decryptSync;exports.encryptKeystore=keystore.encrypt;function decryptJsonWallet(json,password,progressCallback){if(inspect.isCrowdsaleWallet(json)){if(progressCallback){progressCallback(0);}var account=crowdsale.decrypt(json,password);if(progressCallback){progressCallback(1);}return Promise.resolve(account);}if(inspect.isKeystoreWallet(json)){return keystore.decrypt(json,password,progressCallback);}return Promise.reject(new Error(\"invalid JSON wallet\"));}exports.decryptJsonWallet=decryptJsonWallet;function decryptJsonWalletSync(json,password){if(inspect.isCrowdsaleWallet(json)){return crowdsale.decrypt(json,password);}if(inspect.isKeystoreWallet(json)){return keystore.decryptSync(json,password);}throw new Error(\"invalid JSON wallet\");}exports.decryptJsonWalletSync=decryptJsonWalletSync;});var index$i=unwrapExports(lib$i);var lib_1$i=lib$i.decryptCrowdsale;var lib_2$h=lib$i.getJsonWalletAddress;var lib_3$e=lib$i.isCrowdsaleWallet;var lib_4$b=lib$i.isKeystoreWallet;var lib_5$a=lib$i.decryptKeystore;var lib_6$6=lib$i.decryptKeystoreSync;var lib_7$5=lib$i.encryptKeystore;var lib_8$4=lib$i.decryptJsonWallet;var lib_9$4=lib$i.decryptJsonWalletSync;var _version$C=createCommonjsModule(function(module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});exports.version=\"wallet/5.0.2\";});var _version$D=unwrapExports(_version$C);var _version_1$j=_version$C.version;var lib$j=createCommonjsModule(function(module,exports){\"use strict\";var __extends=commonjsGlobal&&commonjsGlobal.__extends||function(){var _extendStatics19=function extendStatics(d,b){_extendStatics19=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return _extendStatics19(d,b);};return function(d,b){_extendStatics19(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,\"__esModule\",{value:true});var logger=new lib.Logger(_version$C.version);function isAccount(value){return value!=null&&lib$1.isHexString(value.privateKey,32)&&value.address!=null;}function hasMnemonic(value){var mnemonic=value.mnemonic;return mnemonic&&mnemonic.phrase;}var Wallet=/** @class */function(_super){__extends(Wallet,_super);function Wallet(privateKey,provider){var _newTarget=this.constructor;var _this=this;logger.checkNew(_newTarget,Wallet);_this=_super.call(this)||this;if(isAccount(privateKey)){var signingKey_1=new lib$f.SigningKey(privateKey.privateKey);lib$3.defineReadOnly(_this,\"_signingKey\",function(){return signingKey_1;});lib$3.defineReadOnly(_this,\"address\",lib$g.computeAddress(_this.publicKey));if(_this.address!==lib$6.getAddress(privateKey.address)){logger.throwArgumentError(\"privateKey/address mismatch\",\"privateKey\",\"[REDACTED]\");}if(hasMnemonic(privateKey)){var srcMnemonic_1=privateKey.mnemonic;lib$3.defineReadOnly(_this,\"_mnemonic\",function(){return{phrase:srcMnemonic_1.phrase,path:srcMnemonic_1.path||lib$h.defaultPath,locale:srcMnemonic_1.locale||\"en\"};});var mnemonic=_this.mnemonic;var node=lib$h.HDNode.fromMnemonic(mnemonic.phrase,null,mnemonic.locale).derivePath(mnemonic.path);if(lib$g.computeAddress(node.privateKey)!==_this.address){logger.throwArgumentError(\"mnemonic/address mismatch\",\"privateKey\",\"[REDACTED]\");}}else{lib$3.defineReadOnly(_this,\"_mnemonic\",function(){return null;});}}else{if(lib$f.SigningKey.isSigningKey(privateKey)){/* istanbul ignore if */if(privateKey.curve!==\"secp256k1\"){logger.throwArgumentError(\"unsupported curve; must be secp256k1\",\"privateKey\",\"[REDACTED]\");}lib$3.defineReadOnly(_this,\"_signingKey\",function(){return privateKey;});}else{var signingKey_2=new lib$f.SigningKey(privateKey);lib$3.defineReadOnly(_this,\"_signingKey\",function(){return signingKey_2;});}lib$3.defineReadOnly(_this,\"_mnemonic\",function(){return null;});lib$3.defineReadOnly(_this,\"address\",lib$g.computeAddress(_this.publicKey));}/* istanbul ignore if */if(provider&&!lib$b.Provider.isProvider(provider)){logger.throwArgumentError(\"invalid provider\",\"provider\",provider);}lib$3.defineReadOnly(_this,\"provider\",provider||null);return _this;}Object.defineProperty(Wallet.prototype,\"mnemonic\",{get:function get(){return this._mnemonic();},enumerable:true,configurable:true});Object.defineProperty(Wallet.prototype,\"privateKey\",{get:function get(){return this._signingKey().privateKey;},enumerable:true,configurable:true});Object.defineProperty(Wallet.prototype,\"publicKey\",{get:function get(){return this._signingKey().publicKey;},enumerable:true,configurable:true});Wallet.prototype.getAddress=function(){return Promise.resolve(this.address);};Wallet.prototype.connect=function(provider){return new Wallet(this,provider);};Wallet.prototype.signTransaction=function(transaction){var _this=this;return lib$3.resolveProperties(transaction).then(function(tx){if(tx.from!=null){if(lib$6.getAddress(tx.from)!==_this.address){logger.throwArgumentError(\"transaction from address mismatch\",\"transaction.from\",transaction.from);}delete tx.from;}var signature=_this._signingKey().signDigest(lib$4.keccak256(lib$g.serialize(tx)));return lib$g.serialize(tx,signature);});};Wallet.prototype.signMessage=function(message){return Promise.resolve(lib$1.joinSignature(this._signingKey().signDigest(lib$9.hashMessage(message))));};Wallet.prototype.encrypt=function(password,options,progressCallback){if(typeof options===\"function\"&&!progressCallback){progressCallback=options;options={};}if(progressCallback&&typeof progressCallback!==\"function\"){throw new Error(\"invalid callback\");}if(!options){options={};}return lib$i.encryptKeystore(this,password,options,progressCallback);};/**\n\t     *  Static methods to create Wallet instances.\n\t     */Wallet.createRandom=function(options){var entropy=browser$6.randomBytes(16);if(!options){options={};}if(options.extraEntropy){entropy=lib$1.arrayify(lib$1.hexDataSlice(lib$4.keccak256(lib$1.concat([entropy,options.extraEntropy])),0,16));}var mnemonic=lib$h.entropyToMnemonic(entropy,options.locale);return Wallet.fromMnemonic(mnemonic,options.path,options.locale);};Wallet.fromEncryptedJson=function(json,password,progressCallback){return lib$i.decryptJsonWallet(json,password,progressCallback).then(function(account){return new Wallet(account);});};Wallet.fromEncryptedJsonSync=function(json,password){return new Wallet(lib$i.decryptJsonWalletSync(json,password));};Wallet.fromMnemonic=function(mnemonic,path,wordlist){if(!path){path=lib$h.defaultPath;}return new Wallet(lib$h.HDNode.fromMnemonic(mnemonic,null,wordlist).derivePath(path));};return Wallet;}(lib$c.Signer);exports.Wallet=Wallet;function verifyMessage(message,signature){return lib$g.recoverAddress(lib$9.hashMessage(message),signature);}exports.verifyMessage=verifyMessage;});var index$j=unwrapExports(lib$j);var lib_1$j=lib$j.Wallet;var lib_2$i=lib$j.verifyMessage;var _version$E=createCommonjsModule(function(module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});exports.version=\"networks/5.0.2\";});var _version$F=unwrapExports(_version$E);var _version_1$k=_version$E.version;var lib$k=createCommonjsModule(function(module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});var logger=new lib.Logger(_version$E.version);;function isRenetworkable(value){return value&&typeof value.renetwork===\"function\";}function ethDefaultProvider(network){var func=function func(providers,options){if(options==null){options={};}var providerList=[];if(providers.InfuraProvider){try{providerList.push(new providers.InfuraProvider(network,options.infura));}catch(error){}}if(providers.EtherscanProvider){try{providerList.push(new providers.EtherscanProvider(network,options.etherscan));}catch(error){}}if(providers.AlchemyProvider){try{providerList.push(new providers.AlchemyProvider(network,options.alchemy));}catch(error){}}if(providers.CloudflareProvider){try{providerList.push(new providers.CloudflareProvider(network));}catch(error){}}if(providerList.length===0){return null;}if(providers.FallbackProvider){var quorum=1;if(options.quorum!=null){quorum=options.quorum;}else if(network===\"homestead\"){quorum=2;}return new providers.FallbackProvider(providerList,quorum);}return providerList[0];};func.renetwork=function(network){return ethDefaultProvider(network);};return func;}function etcDefaultProvider(url,network){var func=function func(providers,options){if(providers.JsonRpcProvider){return new providers.JsonRpcProvider(url,network);}return null;};func.renetwork=function(network){return etcDefaultProvider(url,network);};return func;}var homestead={chainId:1,ensAddress:\"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",name:\"homestead\",_defaultProvider:ethDefaultProvider(\"homestead\")};var ropsten={chainId:3,ensAddress:\"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",name:\"ropsten\",_defaultProvider:ethDefaultProvider(\"ropsten\")};var classicMordor={chainId:63,name:\"classicMordor\",_defaultProvider:etcDefaultProvider(\"https://www.ethercluster.com/mordor\",\"classicMordor\")};var networks={unspecified:{chainId:0,name:\"unspecified\"},homestead:homestead,mainnet:homestead,morden:{chainId:2,name:\"morden\"},ropsten:ropsten,testnet:ropsten,rinkeby:{chainId:4,ensAddress:\"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",name:\"rinkeby\",_defaultProvider:ethDefaultProvider(\"rinkeby\")},kovan:{chainId:42,name:\"kovan\",_defaultProvider:ethDefaultProvider(\"kovan\")},goerli:{chainId:5,ensAddress:\"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",name:\"goerli\",_defaultProvider:ethDefaultProvider(\"goerli\")},// ETC (See: #351)\nclassic:{chainId:61,name:\"classic\",_defaultProvider:etcDefaultProvider(\"https://www.ethercluster.com/etc\",\"classic\")},classicMorden:{chainId:62,name:\"classicMorden\"},classicMordor:classicMordor,classicTestnet:classicMordor,classicKotti:{chainId:6,name:\"classicKotti\",_defaultProvider:etcDefaultProvider(\"https://www.ethercluster.com/kotti\",\"classicKotti\")}};/**\n\t *  getNetwork\n\t *\n\t *  Converts a named common networks or chain ID (network ID) to a Network\n\t *  and verifies a network is a valid Network..\n\t */function getNetwork(network){// No network (null)\nif(network==null){return null;}if(typeof network===\"number\"){for(var name_1 in networks){var standard_1=networks[name_1];if(standard_1.chainId===network){return{name:standard_1.name,chainId:standard_1.chainId,ensAddress:standard_1.ensAddress||null,_defaultProvider:standard_1._defaultProvider||null};}}return{chainId:network,name:\"unknown\"};}if(typeof network===\"string\"){var standard_2=networks[network];if(standard_2==null){return null;}return{name:standard_2.name,chainId:standard_2.chainId,ensAddress:standard_2.ensAddress,_defaultProvider:standard_2._defaultProvider||null};}var standard=networks[network.name];// Not a standard network; check that it is a valid network in general\nif(!standard){if(typeof network.chainId!==\"number\"){logger.throwArgumentError(\"invalid network chainId\",\"network\",network);}return network;}// Make sure the chainId matches the expected network chainId (or is 0; disable EIP-155)\nif(network.chainId!==0&&network.chainId!==standard.chainId){logger.throwArgumentError(\"network chainId mismatch\",\"network\",network);}// @TODO: In the next major version add an attach function to a defaultProvider\n// class and move the _defaultProvider internal to this file (extend Network)\nvar defaultProvider=network._defaultProvider||null;if(defaultProvider==null&&standard._defaultProvider){if(isRenetworkable(standard._defaultProvider)){defaultProvider=standard._defaultProvider.renetwork(network);}else{defaultProvider=standard._defaultProvider;}}// Standard Network (allow overriding the ENS address)\nreturn{name:network.name,chainId:standard.chainId,ensAddress:network.ensAddress||standard.ensAddress||null,_defaultProvider:defaultProvider};}exports.getNetwork=getNetwork;});var index$k=unwrapExports(lib$k);var lib_1$k=lib$k.getNetwork;var browser$8=createCommonjsModule(function(module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});function decode(textData){textData=atob(textData);var data=[];for(var i=0;i<textData.length;i++){data.push(textData.charCodeAt(i));}return lib$1.arrayify(data);}exports.decode=decode;function encode(data){data=lib$1.arrayify(data);var textData=\"\";for(var i=0;i<data.length;i++){textData+=String.fromCharCode(data[i]);}return btoa(textData);}exports.encode=encode;});var browser$9=unwrapExports(browser$8);var browser_1$4=browser$8.decode;var browser_2$3=browser$8.encode;var _version$G=createCommonjsModule(function(module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});exports.version=\"web/5.0.3\";});var _version$H=unwrapExports(_version$G);var _version_1$l=_version$G.version;var browserGeturl=createCommonjsModule(function(module,exports){\"use strict\";var __awaiter=commonjsGlobal&&commonjsGlobal.__awaiter||function(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P(function(resolve){resolve(value);});}return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value));}catch(e){reject(e);}}function rejected(value){try{step(generator[\"throw\"](value));}catch(e){reject(e);}}function step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected);}step((generator=generator.apply(thisArg,_arguments||[])).next());});};var __generator=commonjsGlobal&&commonjsGlobal.__generator||function(thisArg,body){var _={label:0,sent:function sent(){if(t[0]&1)throw t[1];return t[1];},trys:[],ops:[]},f,y,t,g;return g={next:verb(0),\"throw\":verb(1),\"return\":verb(2)},typeof Symbol===\"function\"&&(g[Symbol.iterator]=function(){return this;}),g;function verb(n){return function(v){return step([n,v]);};}function step(op){if(f)throw new TypeError(\"Generator is already executing.\");while(_){try{if(f=1,y&&(t=op[0]&2?y[\"return\"]:op[0]?y[\"throw\"]||((t=y[\"return\"])&&t.call(y),0):y.next)&&!(t=t.call(y,op[1])).done)return t;if(y=0,t)op=[op[0]&2,t.value];switch(op[0]){case 0:case 1:t=op;break;case 4:_.label++;return{value:op[1],done:false};case 5:_.label++;y=op[1];op=[0];continue;case 7:op=_.ops.pop();_.trys.pop();continue;default:if(!(t=_.trys,t=t.length>0&&t[t.length-1])&&(op[0]===6||op[0]===2)){_=0;continue;}if(op[0]===3&&(!t||op[1]>t[0]&&op[1]<t[3])){_.label=op[1];break;}if(op[0]===6&&_.label<t[1]){_.label=t[1];t=op;break;}if(t&&_.label<t[2]){_.label=t[2];_.ops.push(op);break;}if(t[2])_.ops.pop();_.trys.pop();continue;}op=body.call(thisArg,_);}catch(e){op=[6,e];y=0;}finally{f=t=0;}}if(op[0]&5)throw op[1];return{value:op[0]?op[1]:void 0,done:true};}};Object.defineProperty(exports,\"__esModule\",{value:true});function getUrl(href,options){return __awaiter(this,void 0,void 0,function(){var request,response,body,headers;return __generator(this,function(_a){switch(_a.label){case 0:if(options==null){options={};}request={method:options.method||\"GET\",headers:options.headers||{},body:options.body||undefined,mode:\"cors\",cache:\"no-cache\",credentials:\"same-origin\",redirect:\"follow\",referrer:\"client\"};return[4/*yield*/,fetch(href,request)];case 1:response=_a.sent();return[4/*yield*/,response.arrayBuffer()];case 2:body=_a.sent();headers={};if(response.headers.forEach){response.headers.forEach(function(value,key){headers[key.toLowerCase()]=value;});}else{response.headers.keys().forEach(function(key){headers[key.toLowerCase()]=response.headers.get(key);});}return[2/*return*/,{headers:headers,statusCode:response.status,statusMessage:response.statusText,body:lib$1.arrayify(new Uint8Array(body))}];}});});}exports.getUrl=getUrl;});var browserGeturl$1=unwrapExports(browserGeturl);var browserGeturl_1=browserGeturl.getUrl;var lib$l=createCommonjsModule(function(module,exports){\"use strict\";var __awaiter=commonjsGlobal&&commonjsGlobal.__awaiter||function(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P(function(resolve){resolve(value);});}return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value));}catch(e){reject(e);}}function rejected(value){try{step(generator[\"throw\"](value));}catch(e){reject(e);}}function step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected);}step((generator=generator.apply(thisArg,_arguments||[])).next());});};var __generator=commonjsGlobal&&commonjsGlobal.__generator||function(thisArg,body){var _={label:0,sent:function sent(){if(t[0]&1)throw t[1];return t[1];},trys:[],ops:[]},f,y,t,g;return g={next:verb(0),\"throw\":verb(1),\"return\":verb(2)},typeof Symbol===\"function\"&&(g[Symbol.iterator]=function(){return this;}),g;function verb(n){return function(v){return step([n,v]);};}function step(op){if(f)throw new TypeError(\"Generator is already executing.\");while(_){try{if(f=1,y&&(t=op[0]&2?y[\"return\"]:op[0]?y[\"throw\"]||((t=y[\"return\"])&&t.call(y),0):y.next)&&!(t=t.call(y,op[1])).done)return t;if(y=0,t)op=[op[0]&2,t.value];switch(op[0]){case 0:case 1:t=op;break;case 4:_.label++;return{value:op[1],done:false};case 5:_.label++;y=op[1];op=[0];continue;case 7:op=_.ops.pop();_.trys.pop();continue;default:if(!(t=_.trys,t=t.length>0&&t[t.length-1])&&(op[0]===6||op[0]===2)){_=0;continue;}if(op[0]===3&&(!t||op[1]>t[0]&&op[1]<t[3])){_.label=op[1];break;}if(op[0]===6&&_.label<t[1]){_.label=t[1];t=op;break;}if(t&&_.label<t[2]){_.label=t[2];_.ops.push(op);break;}if(t[2])_.ops.pop();_.trys.pop();continue;}op=body.call(thisArg,_);}catch(e){op=[6,e];y=0;}finally{f=t=0;}}if(op[0]&5)throw op[1];return{value:op[0]?op[1]:void 0,done:true};}};Object.defineProperty(exports,\"__esModule\",{value:true});var logger=new lib.Logger(_version$G.version);function staller(duration){return new Promise(function(resolve){setTimeout(resolve,duration);});}// This API is still a work in progress; the future changes will likely be:\n// - ConnectionInfo => FetchDataRequest<T = any>\n// - FetchDataRequest.body? = string | Uint8Array | { contentType: string, data: string | Uint8Array }\n//   - If string => text/plain, Uint8Array => application/octet-stream (if content-type unspecified)\n// - FetchDataRequest.processFunc = (body: Uint8Array, response: FetchDataResponse) => T\n// For this reason, it should be considered internal until the API is finalized\nfunction _fetchData(connection,body,processFunc){// How many times to retry in the event of a throttle\nvar attemptLimit=_typeof(connection)===\"object\"&&connection.throttleLimit!=null?connection.throttleLimit:12;logger.assertArgument(attemptLimit>0&&attemptLimit%1===0,\"invalid connection throttle limit\",\"connection.throttleLimit\",attemptLimit);var throttleCallback=_typeof(connection)===\"object\"?connection.throttleCallback:null;var throttleSlotInterval=_typeof(connection)===\"object\"&&typeof connection.throttleSlotInterval===\"number\"?connection.throttleSlotInterval:100;logger.assertArgument(throttleSlotInterval>0&&throttleSlotInterval%1===0,\"invalid connection throttle slot interval\",\"connection.throttleSlotInterval\",throttleSlotInterval);var headers={};var url=null;// @TODO: Allow ConnectionInfo to override some of these values\nvar options={method:\"GET\"};var allow304=false;var timeout=2*60*1000;if(typeof connection===\"string\"){url=connection;}else if(_typeof(connection)===\"object\"){if(connection==null||connection.url==null){logger.throwArgumentError(\"missing URL\",\"connection.url\",connection);}url=connection.url;if(typeof connection.timeout===\"number\"&&connection.timeout>0){timeout=connection.timeout;}if(connection.headers){for(var key in connection.headers){headers[key.toLowerCase()]={key:key,value:String(connection.headers[key])};if([\"if-none-match\",\"if-modified-since\"].indexOf(key.toLowerCase())>=0){allow304=true;}}}if(connection.user!=null&&connection.password!=null){if(url.substring(0,6)!==\"https:\"&&connection.allowInsecureAuthentication!==true){logger.throwError(\"basic authentication requires a secure https url\",lib.Logger.errors.INVALID_ARGUMENT,{argument:\"url\",url:url,user:connection.user,password:\"[REDACTED]\"});}var authorization=connection.user+\":\"+connection.password;headers[\"authorization\"]={key:\"Authorization\",value:\"Basic \"+browser$8.encode(lib$8.toUtf8Bytes(authorization))};}}if(body){options.method=\"POST\";options.body=body;if(headers[\"content-type\"]==null){headers[\"content-type\"]={key:\"Content-Type\",value:\"application/octet-stream\"};}}var flatHeaders={};Object.keys(headers).forEach(function(key){var header=headers[key];flatHeaders[header.key]=header.value;});options.headers=flatHeaders;var runningTimeout=function(){var timer=null;var promise=new Promise(function(resolve,reject){if(timeout){timer=setTimeout(function(){if(timer==null){return;}timer=null;reject(logger.makeError(\"timeout\",lib.Logger.errors.TIMEOUT,{requestBody:options.body||null,requestMethod:options.method,timeout:timeout,url:url}));},timeout);}});var cancel=function cancel(){if(timer==null){return;}clearTimeout(timer);timer=null;};return{promise:promise,cancel:cancel};}();var runningFetch=function(){return __awaiter(this,void 0,void 0,function(){var attempt,response,tryAgain,stall,retryAfter,error_1,body_1,result,error_2,tryAgain,timeout_1;return __generator(this,function(_a){switch(_a.label){case 0:attempt=0;_a.label=1;case 1:if(!(attempt<attemptLimit))return[3/*break*/,19];response=null;_a.label=2;case 2:_a.trys.push([2,8,,9]);return[4/*yield*/,browserGeturl.getUrl(url,options)];case 3:response=_a.sent();if(!(response.statusCode===429&&attempt<attemptLimit))return[3/*break*/,7];tryAgain=true;if(!throttleCallback)return[3/*break*/,5];return[4/*yield*/,throttleCallback(attempt,url)];case 4:tryAgain=_a.sent();_a.label=5;case 5:if(!tryAgain)return[3/*break*/,7];stall=0;retryAfter=response.headers[\"retry-after\"];if(typeof retryAfter===\"string\"&&retryAfter.match(/^[1-9][0-9]*$/)){stall=parseInt(retryAfter)*1000;}else{stall=throttleSlotInterval*parseInt(String(Math.random()*Math.pow(2,attempt)));}//console.log(\"Stalling 429\");\nreturn[4/*yield*/,staller(stall)];case 6://console.log(\"Stalling 429\");\n_a.sent();return[3/*break*/,18];case 7:return[3/*break*/,9];case 8:error_1=_a.sent();response=error_1.response;if(response==null){runningTimeout.cancel();logger.throwError(\"missing response\",lib.Logger.errors.SERVER_ERROR,{requestBody:options.body||null,requestMethod:options.method,serverError:error_1,url:url});}return[3/*break*/,9];case 9:body_1=response.body;if(allow304&&response.statusCode===304){body_1=null;}else if(response.statusCode<200||response.statusCode>=300){runningTimeout.cancel();logger.throwError(\"bad response\",lib.Logger.errors.SERVER_ERROR,{status:response.statusCode,headers:response.headers,body:body_1,requestBody:options.body||null,requestMethod:options.method,url:url});}if(!processFunc)return[3/*break*/,17];_a.label=10;case 10:_a.trys.push([10,12,,17]);return[4/*yield*/,processFunc(body_1,response)];case 11:result=_a.sent();runningTimeout.cancel();return[2/*return*/,result];case 12:error_2=_a.sent();if(!(error_2.throttleRetry&&attempt<attemptLimit))return[3/*break*/,16];tryAgain=true;if(!throttleCallback)return[3/*break*/,14];return[4/*yield*/,throttleCallback(attempt,url)];case 13:tryAgain=_a.sent();_a.label=14;case 14:if(!tryAgain)return[3/*break*/,16];timeout_1=throttleSlotInterval*parseInt(String(Math.random()*Math.pow(2,attempt)));//console.log(\"Stalling callback\");\nreturn[4/*yield*/,staller(timeout_1)];case 15://console.log(\"Stalling callback\");\n_a.sent();return[3/*break*/,18];case 16:runningTimeout.cancel();logger.throwError(\"processing response error\",lib.Logger.errors.SERVER_ERROR,{body:body_1,error:error_2,requestBody:options.body||null,requestMethod:options.method,url:url});return[3/*break*/,17];case 17:runningTimeout.cancel();// If we had a processFunc, it eitehr returned a T or threw above.\n// The \"body\" is now a Uint8Array.\nreturn[2/*return*/,body_1];case 18:attempt++;return[3/*break*/,1];case 19:return[2/*return*/,logger.throwError(\"failed response\",lib.Logger.errors.SERVER_ERROR,{requestBody:options.body||null,requestMethod:options.method,url:url})];}});});}();return Promise.race([runningTimeout.promise,runningFetch]);}exports._fetchData=_fetchData;function fetchJson(connection,json,processFunc){var processJsonFunc=function processJsonFunc(value,response){var result=null;if(value!=null){try{result=JSON.parse(lib$8.toUtf8String(value));}catch(error){logger.throwError(\"invalid JSON\",lib.Logger.errors.SERVER_ERROR,{body:value,error:error});}}if(processFunc){result=processFunc(result,response);}return result;};// If we have json to send, we must\n// - add content-type of application/json (unless already overridden)\n// - convert the json to bytes\nvar body=null;if(json!=null){body=lib$8.toUtf8Bytes(json);// Create a connection with the content-type set for JSON\nvar updated=typeof connection===\"string\"?{url:connection}:lib$3.shallowCopy(connection);if(updated.headers){var hasContentType=Object.keys(updated.headers).filter(function(k){return k.toLowerCase()===\"content-type\";}).length!==0;if(!hasContentType){updated.headers=lib$3.shallowCopy(updated.headers);updated.headers[\"content-type\"]=\"application/json\";}}else{updated.headers={\"content-type\":\"application/json\"};}connection=updated;}return _fetchData(connection,body,processJsonFunc);}exports.fetchJson=fetchJson;function poll(func,options){if(!options){options={};}options=lib$3.shallowCopy(options);if(options.floor==null){options.floor=0;}if(options.ceiling==null){options.ceiling=10000;}if(options.interval==null){options.interval=250;}return new Promise(function(resolve,reject){var timer=null;var done=false;// Returns true if cancel was successful. Unsuccessful cancel means we're already done.\nvar cancel=function cancel(){if(done){return false;}done=true;if(timer){clearTimeout(timer);}return true;};if(options.timeout){timer=setTimeout(function(){if(cancel()){reject(new Error(\"timeout\"));}},options.timeout);}var retryLimit=options.retryLimit;var attempt=0;function check(){return func().then(function(result){// If we have a result, or are allowed null then we're done\nif(result!==undefined){if(cancel()){resolve(result);}}else if(options.oncePoll){options.oncePoll.once(\"poll\",check);}else if(options.onceBlock){options.onceBlock.once(\"block\",check);// Otherwise, exponential back-off (up to 10s) our next request\n}else if(!done){attempt++;if(attempt>retryLimit){if(cancel()){reject(new Error(\"retry limit reached\"));}return;}var timeout=options.interval*parseInt(String(Math.random()*Math.pow(2,attempt)));if(timeout<options.floor){timeout=options.floor;}if(timeout>options.ceiling){timeout=options.ceiling;}setTimeout(check,timeout);}return null;},function(error){if(cancel()){reject(error);}});}check();});}exports.poll=poll;});var index$l=unwrapExports(lib$l);var lib_1$l=lib$l._fetchData;var lib_2$j=lib$l.fetchJson;var lib_3$f=lib$l.poll;var _version$I=createCommonjsModule(function(module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});exports.version=\"providers/5.0.5\";});var _version$J=unwrapExports(_version$I);var _version_1$m=_version$I.version;var formatter=createCommonjsModule(function(module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});var logger=new lib.Logger(_version$I.version);var Formatter=/** @class */function(){function Formatter(){var _newTarget=this.constructor;logger.checkNew(_newTarget,Formatter);this.formats=this.getDefaultFormats();}Formatter.prototype.getDefaultFormats=function(){var _this=this;var formats={};var address=this.address.bind(this);var bigNumber=this.bigNumber.bind(this);var blockTag=this.blockTag.bind(this);var data=this.data.bind(this);var hash=this.hash.bind(this);var hex=this.hex.bind(this);var number=this.number.bind(this);var strictData=function strictData(v){return _this.data(v,true);};formats.transaction={hash:hash,blockHash:Formatter.allowNull(hash,null),blockNumber:Formatter.allowNull(number,null),transactionIndex:Formatter.allowNull(number,null),confirmations:Formatter.allowNull(number,null),from:address,gasPrice:bigNumber,gasLimit:bigNumber,to:Formatter.allowNull(address,null),value:bigNumber,nonce:number,data:data,r:Formatter.allowNull(this.uint256),s:Formatter.allowNull(this.uint256),v:Formatter.allowNull(number),creates:Formatter.allowNull(address,null),raw:Formatter.allowNull(data)};formats.transactionRequest={from:Formatter.allowNull(address),nonce:Formatter.allowNull(number),gasLimit:Formatter.allowNull(bigNumber),gasPrice:Formatter.allowNull(bigNumber),to:Formatter.allowNull(address),value:Formatter.allowNull(bigNumber),data:Formatter.allowNull(strictData)};formats.receiptLog={transactionIndex:number,blockNumber:number,transactionHash:hash,address:address,topics:Formatter.arrayOf(hash),data:data,logIndex:number,blockHash:hash};formats.receipt={to:Formatter.allowNull(this.address,null),from:Formatter.allowNull(this.address,null),contractAddress:Formatter.allowNull(address,null),transactionIndex:number,root:Formatter.allowNull(hash),gasUsed:bigNumber,logsBloom:Formatter.allowNull(data),blockHash:hash,transactionHash:hash,logs:Formatter.arrayOf(this.receiptLog.bind(this)),blockNumber:number,confirmations:Formatter.allowNull(number,null),cumulativeGasUsed:bigNumber,status:Formatter.allowNull(number)};formats.block={hash:hash,parentHash:hash,number:number,timestamp:number,nonce:Formatter.allowNull(hex),difficulty:this.difficulty.bind(this),gasLimit:bigNumber,gasUsed:bigNumber,miner:address,extraData:data,transactions:Formatter.allowNull(Formatter.arrayOf(hash))};formats.blockWithTransactions=lib$3.shallowCopy(formats.block);formats.blockWithTransactions.transactions=Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)));formats.filter={fromBlock:Formatter.allowNull(blockTag,undefined),toBlock:Formatter.allowNull(blockTag,undefined),blockHash:Formatter.allowNull(hash,undefined),address:Formatter.allowNull(address,undefined),topics:Formatter.allowNull(this.topics.bind(this),undefined)};formats.filterLog={blockNumber:Formatter.allowNull(number),blockHash:Formatter.allowNull(hash),transactionIndex:number,removed:Formatter.allowNull(this.boolean.bind(this)),address:address,data:Formatter.allowFalsish(data,\"0x\"),topics:Formatter.arrayOf(hash),transactionHash:hash,logIndex:number};return formats;};// Requires a BigNumberish that is within the IEEE754 safe integer range; returns a number\n// Strict! Used on input.\nFormatter.prototype.number=function(number){return lib$2.BigNumber.from(number).toNumber();};// Strict! Used on input.\nFormatter.prototype.bigNumber=function(value){return lib$2.BigNumber.from(value);};// Requires a boolean, \"true\" or  \"false\"; returns a boolean\nFormatter.prototype.boolean=function(value){if(typeof value===\"boolean\"){return value;}if(typeof value===\"string\"){value=value.toLowerCase();if(value===\"true\"){return true;}if(value===\"false\"){return false;}}throw new Error(\"invalid boolean - \"+value);};Formatter.prototype.hex=function(value,strict){if(typeof value===\"string\"){if(!strict&&value.substring(0,2)!==\"0x\"){value=\"0x\"+value;}if(lib$1.isHexString(value)){return value.toLowerCase();}}return logger.throwArgumentError(\"invalid hash\",\"value\",value);};Formatter.prototype.data=function(value,strict){var result=this.hex(value,strict);if(result.length%2!==0){throw new Error(\"invalid data; odd-length - \"+value);}return result;};// Requires an address\n// Strict! Used on input.\nFormatter.prototype.address=function(value){return lib$6.getAddress(value);};Formatter.prototype.callAddress=function(value){if(!lib$1.isHexString(value,32)){return null;}var address=lib$6.getAddress(lib$1.hexDataSlice(value,12));return address===lib$7.AddressZero?null:address;};Formatter.prototype.contractAddress=function(value){return lib$6.getContractAddress(value);};// Strict! Used on input.\nFormatter.prototype.blockTag=function(blockTag){if(blockTag==null){return\"latest\";}if(blockTag===\"earliest\"){return\"0x0\";}if(blockTag===\"latest\"||blockTag===\"pending\"){return blockTag;}if(typeof blockTag===\"number\"||lib$1.isHexString(blockTag)){return lib$1.hexValue(blockTag);}throw new Error(\"invalid blockTag\");};// Requires a hash, optionally requires 0x prefix; returns prefixed lowercase hash.\nFormatter.prototype.hash=function(value,strict){var result=this.hex(value,strict);if(lib$1.hexDataLength(result)!==32){return logger.throwArgumentError(\"invalid hash\",\"value\",value);}return result;};// Returns the difficulty as a number, or if too large (i.e. PoA network) null\nFormatter.prototype.difficulty=function(value){if(value==null){return null;}var v=lib$2.BigNumber.from(value);try{return v.toNumber();}catch(error){}return null;};Formatter.prototype.uint256=function(value){if(!lib$1.isHexString(value)){throw new Error(\"invalid uint256\");}return lib$1.hexZeroPad(value,32);};Formatter.prototype._block=function(value,format){if(value.author!=null&&value.miner==null){value.miner=value.author;}return Formatter.check(format,value);};Formatter.prototype.block=function(value){return this._block(value,this.formats.block);};Formatter.prototype.blockWithTransactions=function(value){return this._block(value,this.formats.blockWithTransactions);};// Strict! Used on input.\nFormatter.prototype.transactionRequest=function(value){return Formatter.check(this.formats.transactionRequest,value);};Formatter.prototype.transactionResponse=function(transaction){// Rename gas to gasLimit\nif(transaction.gas!=null&&transaction.gasLimit==null){transaction.gasLimit=transaction.gas;}// Some clients (TestRPC) do strange things like return 0x0 for the\n// 0 address; correct this to be a real address\nif(transaction.to&&lib$2.BigNumber.from(transaction.to).isZero()){transaction.to=\"0x0000000000000000000000000000000000000000\";}// Rename input to data\nif(transaction.input!=null&&transaction.data==null){transaction.data=transaction.input;}// If to and creates are empty, populate the creates from the transaction\nif(transaction.to==null&&transaction.creates==null){transaction.creates=this.contractAddress(transaction);}// @TODO: use transaction.serialize? Have to add support for including v, r, and s...\n/*\n\t        if (!transaction.raw) {\n\t \n\t             // Very loose providers (e.g. TestRPC) do not provide a signature or raw\n\t             if (transaction.v && transaction.r && transaction.s) {\n\t                 let raw = [\n\t                     stripZeros(hexlify(transaction.nonce)),\n\t                     stripZeros(hexlify(transaction.gasPrice)),\n\t                     stripZeros(hexlify(transaction.gasLimit)),\n\t                     (transaction.to || \"0x\"),\n\t                     stripZeros(hexlify(transaction.value || \"0x\")),\n\t                     hexlify(transaction.data || \"0x\"),\n\t                     stripZeros(hexlify(transaction.v || \"0x\")),\n\t                     stripZeros(hexlify(transaction.r)),\n\t                     stripZeros(hexlify(transaction.s)),\n\t                 ];\n\t \n\t                 transaction.raw = rlpEncode(raw);\n\t             }\n\t         }\n\t         */var result=Formatter.check(this.formats.transaction,transaction);if(transaction.chainId!=null){var chainId=transaction.chainId;if(lib$1.isHexString(chainId)){chainId=lib$2.BigNumber.from(chainId).toNumber();}result.chainId=chainId;}else{var chainId=transaction.networkId;// geth-etc returns chainId\nif(chainId==null&&result.v==null){chainId=transaction.chainId;}if(lib$1.isHexString(chainId)){chainId=lib$2.BigNumber.from(chainId).toNumber();}if(typeof chainId!==\"number\"&&result.v!=null){chainId=(result.v-35)/2;if(chainId<0){chainId=0;}chainId=parseInt(chainId);}if(typeof chainId!==\"number\"){chainId=0;}result.chainId=chainId;}// 0x0000... should actually be null\nif(result.blockHash&&result.blockHash.replace(/0/g,\"\")===\"x\"){result.blockHash=null;}return result;};Formatter.prototype.transaction=function(value){return lib$g.parse(value);};Formatter.prototype.receiptLog=function(value){return Formatter.check(this.formats.receiptLog,value);};Formatter.prototype.receipt=function(value){var result=Formatter.check(this.formats.receipt,value);if(value.status!=null){result.byzantium=true;}return result;};Formatter.prototype.topics=function(value){var _this=this;if(Array.isArray(value)){return value.map(function(v){return _this.topics(v);});}else if(value!=null){return this.hash(value,true);}return null;};Formatter.prototype.filter=function(value){return Formatter.check(this.formats.filter,value);};Formatter.prototype.filterLog=function(value){return Formatter.check(this.formats.filterLog,value);};Formatter.check=function(format,object){var result={};for(var key in format){try{var value=format[key](object[key]);if(value!==undefined){result[key]=value;}}catch(error){error.checkKey=key;error.checkValue=object[key];throw error;}}return result;};// if value is null-ish, nullValue is returned\nFormatter.allowNull=function(format,nullValue){return function(value){if(value==null){return nullValue;}return format(value);};};// If value is false-ish, replaceValue is returned\nFormatter.allowFalsish=function(format,replaceValue){return function(value){if(!value){return replaceValue;}return format(value);};};// Requires an Array satisfying check\nFormatter.arrayOf=function(format){return function(array){if(!Array.isArray(array)){throw new Error(\"not an array\");}var result=[];array.forEach(function(value){result.push(format(value));});return result;};};return Formatter;}();exports.Formatter=Formatter;// Show the throttle message only once\nvar throttleMessage=false;function showThrottleMessage(){if(throttleMessage){return;}throttleMessage=true;console.log(\"========= NOTICE =========\");console.log(\"Request-Rate Exceeded  (this message will not be repeated)\");console.log(\"\");console.log(\"The default API keys for each service are provided as a highly-throttled,\");console.log(\"community resource for low-traffic projects and early prototyping.\");console.log(\"\");console.log(\"While your application will continue to function, we highly recommended\");console.log(\"signing up for your own API keys to improve performance, increase your\");console.log(\"request rate/limit and enable other perks, such as metrics and advanced APIs.\");console.log(\"\");console.log(\"For more details: https:/\\/docs.ethers.io/api-keys/\");console.log(\"==========================\");}exports.showThrottleMessage=showThrottleMessage;});var formatter$1=unwrapExports(formatter);var formatter_1=formatter.Formatter;var formatter_2=formatter.showThrottleMessage;var baseProvider=createCommonjsModule(function(module,exports){\"use strict\";var __extends=commonjsGlobal&&commonjsGlobal.__extends||function(){var _extendStatics20=function extendStatics(d,b){_extendStatics20=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return _extendStatics20(d,b);};return function(d,b){_extendStatics20(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();var __awaiter=commonjsGlobal&&commonjsGlobal.__awaiter||function(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P(function(resolve){resolve(value);});}return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value));}catch(e){reject(e);}}function rejected(value){try{step(generator[\"throw\"](value));}catch(e){reject(e);}}function step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected);}step((generator=generator.apply(thisArg,_arguments||[])).next());});};var __generator=commonjsGlobal&&commonjsGlobal.__generator||function(thisArg,body){var _={label:0,sent:function sent(){if(t[0]&1)throw t[1];return t[1];},trys:[],ops:[]},f,y,t,g;return g={next:verb(0),\"throw\":verb(1),\"return\":verb(2)},typeof Symbol===\"function\"&&(g[Symbol.iterator]=function(){return this;}),g;function verb(n){return function(v){return step([n,v]);};}function step(op){if(f)throw new TypeError(\"Generator is already executing.\");while(_){try{if(f=1,y&&(t=op[0]&2?y[\"return\"]:op[0]?y[\"throw\"]||((t=y[\"return\"])&&t.call(y),0):y.next)&&!(t=t.call(y,op[1])).done)return t;if(y=0,t)op=[op[0]&2,t.value];switch(op[0]){case 0:case 1:t=op;break;case 4:_.label++;return{value:op[1],done:false};case 5:_.label++;y=op[1];op=[0];continue;case 7:op=_.ops.pop();_.trys.pop();continue;default:if(!(t=_.trys,t=t.length>0&&t[t.length-1])&&(op[0]===6||op[0]===2)){_=0;continue;}if(op[0]===3&&(!t||op[1]>t[0]&&op[1]<t[3])){_.label=op[1];break;}if(op[0]===6&&_.label<t[1]){_.label=t[1];t=op;break;}if(t&&_.label<t[2]){_.label=t[2];_.ops.push(op);break;}if(t[2])_.ops.pop();_.trys.pop();continue;}op=body.call(thisArg,_);}catch(e){op=[6,e];y=0;}finally{f=t=0;}}if(op[0]&5)throw op[1];return{value:op[0]?op[1]:void 0,done:true};}};Object.defineProperty(exports,\"__esModule\",{value:true});var logger=new lib.Logger(_version$I.version);//////////////////////////////\n// Event Serializeing\nfunction checkTopic(topic){if(topic==null){return\"null\";}if(lib$1.hexDataLength(topic)!==32){logger.throwArgumentError(\"invalid topic\",\"topic\",topic);}return topic.toLowerCase();}function serializeTopics(topics){// Remove trailing null AND-topics; they are redundant\ntopics=topics.slice();while(topics.length>0&&topics[topics.length-1]==null){topics.pop();}return topics.map(function(topic){if(Array.isArray(topic)){// Only track unique OR-topics\nvar unique_1={};topic.forEach(function(topic){unique_1[checkTopic(topic)]=true;});// The order of OR-topics does not matter\nvar sorted=Object.keys(unique_1);sorted.sort();return sorted.join(\"|\");}else{return checkTopic(topic);}}).join(\"&\");}function deserializeTopics(data){if(data===\"\"){return[];}return data.split(/&/g).map(function(topic){if(topic===\"\"){return[];}var comps=topic.split(\"|\").map(function(topic){return topic===\"null\"?null:topic;});return comps.length===1?comps[0]:comps;});}function getEventTag(eventName){if(typeof eventName===\"string\"){eventName=eventName.toLowerCase();if(lib$1.hexDataLength(eventName)===32){return\"tx:\"+eventName;}if(eventName.indexOf(\":\")===-1){return eventName;}}else if(Array.isArray(eventName)){return\"filter:*:\"+serializeTopics(eventName);}else if(lib$b.ForkEvent.isForkEvent(eventName)){logger.warn(\"not implemented\");throw new Error(\"not implemented\");}else if(eventName&&_typeof(eventName)===\"object\"){return\"filter:\"+(eventName.address||\"*\")+\":\"+serializeTopics(eventName.topics||[]);}throw new Error(\"invalid event - \"+eventName);}//////////////////////////////\n// Helper Object\nfunction getTime(){return new Date().getTime();}function stall(duration){return new Promise(function(resolve){setTimeout(resolve,duration);});}//////////////////////////////\n// Provider Object\n/**\n\t *  EventType\n\t *   - \"block\"\n\t *   - \"poll\"\n\t *   - \"didPoll\"\n\t *   - \"pending\"\n\t *   - \"error\"\n\t *   - \"network\"\n\t *   - filter\n\t *   - topics array\n\t *   - transaction hash\n\t */var PollableEvents=[\"block\",\"network\",\"pending\",\"poll\"];var Event=/** @class */function(){function Event(tag,listener,once){lib$3.defineReadOnly(this,\"tag\",tag);lib$3.defineReadOnly(this,\"listener\",listener);lib$3.defineReadOnly(this,\"once\",once);}Object.defineProperty(Event.prototype,\"event\",{get:function get(){switch(this.type){case\"tx\":return this.hash;case\"filter\":return this.filter;}return this.tag;},enumerable:true,configurable:true});Object.defineProperty(Event.prototype,\"type\",{get:function get(){return this.tag.split(\":\")[0];},enumerable:true,configurable:true});Object.defineProperty(Event.prototype,\"hash\",{get:function get(){var comps=this.tag.split(\":\");if(comps[0]!==\"tx\"){return null;}return comps[1];},enumerable:true,configurable:true});Object.defineProperty(Event.prototype,\"filter\",{get:function get(){var comps=this.tag.split(\":\");if(comps[0]!==\"filter\"){return null;}var address=comps[1];var topics=deserializeTopics(comps[2]);var filter={};if(topics.length>0){filter.topics=topics;}if(address&&address!==\"*\"){filter.address=address;}return filter;},enumerable:true,configurable:true});Event.prototype.pollable=function(){return this.tag.indexOf(\":\")>=0||PollableEvents.indexOf(this.tag)>=0;};return Event;}();exports.Event=Event;var defaultFormatter=null;var nextPollId=1;var BaseProvider=/** @class */function(_super){__extends(BaseProvider,_super);/**\n\t     *  ready\n\t     *\n\t     *  A Promise<Network> that resolves only once the provider is ready.\n\t     *\n\t     *  Sub-classes that call the super with a network without a chainId\n\t     *  MUST set this. Standard named networks have a known chainId.\n\t     *\n\t     */function BaseProvider(network){var _newTarget=this.constructor;var _this=this;logger.checkNew(_newTarget,lib$b.Provider);_this=_super.call(this)||this;// Events being listened to\n_this._events=[];_this._emitted={block:-2};_this.formatter=_newTarget.getFormatter();// If network is any, this Provider allows the underlying\n// network to change dynamically, and we auto-detect the\n// current network\nlib$3.defineReadOnly(_this,\"anyNetwork\",network===\"any\");if(_this.anyNetwork){network=_this.detectNetwork();}if(network instanceof Promise){_this._networkPromise=network;// Squash any \"unhandled promise\" errors; that do not need to be handled\nnetwork.catch(function(error){});// Trigger initial network setting (async)\n_this._ready().catch(function(error){});}else{var knownNetwork=lib$3.getStatic(_newTarget,\"getNetwork\")(network);if(knownNetwork){lib$3.defineReadOnly(_this,\"_network\",knownNetwork);_this.emit(\"network\",knownNetwork,null);}else{logger.throwArgumentError(\"invalid network\",\"network\",network);}}_this._maxInternalBlockNumber=-1024;_this._lastBlockNumber=-2;_this._pollingInterval=4000;_this._fastQueryDate=0;return _this;}BaseProvider.prototype._ready=function(){return __awaiter(this,void 0,void 0,function(){var network,error_1;return __generator(this,function(_a){switch(_a.label){case 0:if(!(this._network==null))return[3/*break*/,7];network=null;if(!this._networkPromise)return[3/*break*/,4];_a.label=1;case 1:_a.trys.push([1,3,,4]);return[4/*yield*/,this._networkPromise];case 2:network=_a.sent();return[3/*break*/,4];case 3:error_1=_a.sent();return[3/*break*/,4];case 4:if(!(network==null))return[3/*break*/,6];return[4/*yield*/,this.detectNetwork()];case 5:network=_a.sent();_a.label=6;case 6:// This should never happen; every Provider sub-class should have\n// suggested a network by here (or have thrown).\nif(!network){logger.throwError(\"no network detected\",lib.Logger.errors.UNKNOWN_ERROR,{});}// Possible this call stacked so do not call defineReadOnly again\nif(this._network==null){if(this.anyNetwork){this._network=network;}else{lib$3.defineReadOnly(this,\"_network\",network);}this.emit(\"network\",network,null);}_a.label=7;case 7:return[2/*return*/,this._network];}});});};Object.defineProperty(BaseProvider.prototype,\"ready\",{// This will always return the most recently established network.\n// For \"any\", this can change (a \"network\" event is emitted before\n// any change is refelcted); otherwise this cannot change\nget:function get(){var _this=this;return lib$l.poll(function(){return _this._ready().then(function(network){return network;},function(error){// If the network isn't running yet, we will wait\nif(error.code===lib.Logger.errors.NETWORK_ERROR&&error.event===\"noNetwork\"){return undefined;}throw error;});});},enumerable:true,configurable:true});// @TODO: Remove this and just create a singleton formatter\nBaseProvider.getFormatter=function(){if(defaultFormatter==null){defaultFormatter=new formatter.Formatter();}return defaultFormatter;};// @TODO: Remove this and just use getNetwork\nBaseProvider.getNetwork=function(network){return lib$k.getNetwork(network==null?\"homestead\":network);};// Fetches the blockNumber, but will reuse any result that is less\n// than maxAge old or has been requested since the last request\nBaseProvider.prototype._getInternalBlockNumber=function(maxAge){return __awaiter(this,void 0,void 0,function(){var internalBlockNumber,result,reqTime,checkInternalBlockNumber;var _this=this;return __generator(this,function(_a){switch(_a.label){case 0:return[4/*yield*/,this._ready()];case 1:_a.sent();internalBlockNumber=this._internalBlockNumber;if(!(maxAge>0&&this._internalBlockNumber))return[3/*break*/,3];return[4/*yield*/,internalBlockNumber];case 2:result=_a.sent();if(getTime()-result.respTime<=maxAge){return[2/*return*/,result.blockNumber];}_a.label=3;case 3:reqTime=getTime();checkInternalBlockNumber=lib$3.resolveProperties({blockNumber:this.perform(\"getBlockNumber\",{}),networkError:this.getNetwork().then(function(network){return null;},function(error){return error;})}).then(function(_a){var blockNumber=_a.blockNumber,networkError=_a.networkError;if(networkError){// Unremember this bad internal block number\nif(_this._internalBlockNumber===checkInternalBlockNumber){_this._internalBlockNumber=null;}throw networkError;}var respTime=getTime();blockNumber=lib$2.BigNumber.from(blockNumber).toNumber();if(blockNumber<_this._maxInternalBlockNumber){blockNumber=_this._maxInternalBlockNumber;}_this._maxInternalBlockNumber=blockNumber;_this._setFastBlockNumber(blockNumber);// @TODO: Still need this?\nreturn{blockNumber:blockNumber,reqTime:reqTime,respTime:respTime};});this._internalBlockNumber=checkInternalBlockNumber;return[4/*yield*/,checkInternalBlockNumber];case 4:return[2/*return*/,_a.sent().blockNumber];}});});};BaseProvider.prototype.poll=function(){return __awaiter(this,void 0,void 0,function(){var pollId,runners,blockNumber,i;var _this=this;return __generator(this,function(_a){switch(_a.label){case 0:pollId=nextPollId++;runners=[];return[4/*yield*/,this._getInternalBlockNumber(100+this.pollingInterval/2)];case 1:blockNumber=_a.sent();this._setFastBlockNumber(blockNumber);// Emit a poll event after we have the latest (fast) block number\nthis.emit(\"poll\",pollId,blockNumber);// If the block has not changed, meh.\nif(blockNumber===this._lastBlockNumber){this.emit(\"didPoll\",pollId);return[2/*return*/];}// First polling cycle, trigger a \"block\" events\nif(this._emitted.block===-2){this._emitted.block=blockNumber-1;}if(Math.abs(this._emitted.block-blockNumber)>1000){logger.warn(\"network block skew detected; skipping block events\");this.emit(\"error\",logger.makeError(\"network block skew detected\",lib.Logger.errors.NETWORK_ERROR,{blockNumber:blockNumber,event:\"blockSkew\",previousBlockNumber:this._emitted.block}));this.emit(\"block\",blockNumber);}else{// Notify all listener for each block that has passed\nfor(i=this._emitted.block+1;i<=blockNumber;i++){this.emit(\"block\",i);}}// The emitted block was updated, check for obsolete events\nif(this._emitted.block!==blockNumber){this._emitted.block=blockNumber;Object.keys(this._emitted).forEach(function(key){// The block event does not expire\nif(key===\"block\"){return;}// The block we were at when we emitted this event\nvar eventBlockNumber=_this._emitted[key];// We cannot garbage collect pending transactions or blocks here\n// They should be garbage collected by the Provider when setting\n// \"pending\" events\nif(eventBlockNumber===\"pending\"){return;}// Evict any transaction hashes or block hashes over 12 blocks\n// old, since they should not return null anyways\nif(blockNumber-eventBlockNumber>12){delete _this._emitted[key];}});}// First polling cycle\nif(this._lastBlockNumber===-2){this._lastBlockNumber=blockNumber-1;}// Find all transaction hashes we are waiting on\nthis._events.forEach(function(event){switch(event.type){case\"tx\":{var hash_2=event.hash;var runner=_this.getTransactionReceipt(hash_2).then(function(receipt){if(!receipt||receipt.blockNumber==null){return null;}_this._emitted[\"t:\"+hash_2]=receipt.blockNumber;_this.emit(hash_2,receipt);return null;}).catch(function(error){_this.emit(\"error\",error);});runners.push(runner);break;}case\"filter\":{var filter_1=event.filter;filter_1.fromBlock=_this._lastBlockNumber+1;filter_1.toBlock=blockNumber;var runner=_this.getLogs(filter_1).then(function(logs){if(logs.length===0){return;}logs.forEach(function(log){_this._emitted[\"b:\"+log.blockHash]=log.blockNumber;_this._emitted[\"t:\"+log.transactionHash]=log.blockNumber;_this.emit(filter_1,log);});}).catch(function(error){_this.emit(\"error\",error);});runners.push(runner);break;}}});this._lastBlockNumber=blockNumber;// Once all events for this loop have been processed, emit \"didPoll\"\nPromise.all(runners).then(function(){_this.emit(\"didPoll\",pollId);});return[2/*return*/,null];}});});};// Deprecated; do not use this\nBaseProvider.prototype.resetEventsBlock=function(blockNumber){this._lastBlockNumber=blockNumber-1;if(this.polling){this.poll();}};Object.defineProperty(BaseProvider.prototype,\"network\",{get:function get(){return this._network;},enumerable:true,configurable:true});// This method should query the network if the underlying network\n// can change, such as when connected to a JSON-RPC backend\nBaseProvider.prototype.detectNetwork=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(_a){return[2/*return*/,logger.throwError(\"provider does not support network detection\",lib.Logger.errors.UNSUPPORTED_OPERATION,{operation:\"provider.detectNetwork\"})];});});};BaseProvider.prototype.getNetwork=function(){return __awaiter(this,void 0,void 0,function(){var network,currentNetwork,error;return __generator(this,function(_a){switch(_a.label){case 0:return[4/*yield*/,this._ready()];case 1:network=_a.sent();return[4/*yield*/,this.detectNetwork()];case 2:currentNetwork=_a.sent();if(!(network.chainId!==currentNetwork.chainId))return[3/*break*/,5];if(!this.anyNetwork)return[3/*break*/,4];this._network=currentNetwork;// Reset all internal block number guards and caches\nthis._lastBlockNumber=-2;this._fastBlockNumber=null;this._fastBlockNumberPromise=null;this._fastQueryDate=0;this._emitted.block=-2;this._maxInternalBlockNumber=-1024;this._internalBlockNumber=null;// The \"network\" event MUST happen before this method resolves\n// so any events have a chance to unregister, so we stall an\n// additional event loop before returning from /this/ call\nthis.emit(\"network\",currentNetwork,network);return[4/*yield*/,stall(0)];case 3:_a.sent();return[2/*return*/,this._network];case 4:error=logger.makeError(\"underlying network changed\",lib.Logger.errors.NETWORK_ERROR,{event:\"changed\",network:network,detectedNetwork:currentNetwork});this.emit(\"error\",error);throw error;case 5:return[2/*return*/,network];}});});};Object.defineProperty(BaseProvider.prototype,\"blockNumber\",{get:function get(){var _this=this;this._getInternalBlockNumber(100+this.pollingInterval/2).then(function(blockNumber){_this._setFastBlockNumber(blockNumber);});return this._fastBlockNumber!=null?this._fastBlockNumber:-1;},enumerable:true,configurable:true});Object.defineProperty(BaseProvider.prototype,\"polling\",{get:function get(){return this._poller!=null;},set:function set(value){var _this=this;if(value&&!this._poller){this._poller=setInterval(this.poll.bind(this),this.pollingInterval);if(!this._bootstrapPoll){this._bootstrapPoll=setTimeout(function(){_this.poll();// We block additional polls until the polling interval\n// is done, to prevent overwhelming the poll function\n_this._bootstrapPoll=setTimeout(function(){// If polling was disabled, something may require a poke\n// since starting the bootstrap poll and it was disabled\nif(!_this._poller){_this.poll();}// Clear out the bootstrap so we can do another\n_this._bootstrapPoll=null;},_this.pollingInterval);},0);}}else if(!value&&this._poller){clearInterval(this._poller);this._poller=null;}},enumerable:true,configurable:true});Object.defineProperty(BaseProvider.prototype,\"pollingInterval\",{get:function get(){return this._pollingInterval;},set:function set(value){var _this=this;if(typeof value!==\"number\"||value<=0||parseInt(String(value))!=value){throw new Error(\"invalid polling interval\");}this._pollingInterval=value;if(this._poller){clearInterval(this._poller);this._poller=setInterval(function(){_this.poll();},this._pollingInterval);}},enumerable:true,configurable:true});BaseProvider.prototype._getFastBlockNumber=function(){var _this=this;var now=getTime();// Stale block number, request a newer value\nif(now-this._fastQueryDate>2*this._pollingInterval){this._fastQueryDate=now;this._fastBlockNumberPromise=this.getBlockNumber().then(function(blockNumber){if(_this._fastBlockNumber==null||blockNumber>_this._fastBlockNumber){_this._fastBlockNumber=blockNumber;}return _this._fastBlockNumber;});}return this._fastBlockNumberPromise;};BaseProvider.prototype._setFastBlockNumber=function(blockNumber){// Older block, maybe a stale request\nif(this._fastBlockNumber!=null&&blockNumber<this._fastBlockNumber){return;}// Update the time we updated the blocknumber\nthis._fastQueryDate=getTime();// Newer block number, use  it\nif(this._fastBlockNumber==null||blockNumber>this._fastBlockNumber){this._fastBlockNumber=blockNumber;this._fastBlockNumberPromise=Promise.resolve(blockNumber);}};BaseProvider.prototype.waitForTransaction=function(transactionHash,confirmations,timeout){return __awaiter(this,void 0,void 0,function(){var receipt;var _this=this;return __generator(this,function(_a){switch(_a.label){case 0:if(confirmations==null){confirmations=1;}return[4/*yield*/,this.getTransactionReceipt(transactionHash)];case 1:receipt=_a.sent();// Receipt is already good\nif((receipt?receipt.confirmations:0)>=confirmations){return[2/*return*/,receipt];}// Poll until the receipt is good...\nreturn[2/*return*/,new Promise(function(resolve,reject){var timer=null;var done=false;var handler=function handler(receipt){if(receipt.confirmations<confirmations){return;}if(timer){clearTimeout(timer);}if(done){return;}done=true;_this.removeListener(transactionHash,handler);resolve(receipt);};_this.on(transactionHash,handler);if(typeof timeout===\"number\"&&timeout>0){timer=setTimeout(function(){if(done){return;}timer=null;done=true;_this.removeListener(transactionHash,handler);reject(logger.makeError(\"timeout exceeded\",lib.Logger.errors.TIMEOUT,{timeout:timeout}));},timeout);if(timer.unref){timer.unref();}}})];}});});};BaseProvider.prototype.getBlockNumber=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(_a){return[2/*return*/,this._getInternalBlockNumber(0)];});});};BaseProvider.prototype.getGasPrice=function(){return __awaiter(this,void 0,void 0,function(){var _a,_b;return __generator(this,function(_c){switch(_c.label){case 0:return[4/*yield*/,this.getNetwork()];case 1:_c.sent();_b=(_a=lib$2.BigNumber).from;return[4/*yield*/,this.perform(\"getGasPrice\",{})];case 2:return[2/*return*/,_b.apply(_a,[_c.sent()])];}});});};BaseProvider.prototype.getBalance=function(addressOrName,blockTag){return __awaiter(this,void 0,void 0,function(){var params,_a,_b;return __generator(this,function(_c){switch(_c.label){case 0:return[4/*yield*/,this.getNetwork()];case 1:_c.sent();return[4/*yield*/,lib$3.resolveProperties({address:this._getAddress(addressOrName),blockTag:this._getBlockTag(blockTag)})];case 2:params=_c.sent();_b=(_a=lib$2.BigNumber).from;return[4/*yield*/,this.perform(\"getBalance\",params)];case 3:return[2/*return*/,_b.apply(_a,[_c.sent()])];}});});};BaseProvider.prototype.getTransactionCount=function(addressOrName,blockTag){return __awaiter(this,void 0,void 0,function(){var params,_a,_b;return __generator(this,function(_c){switch(_c.label){case 0:return[4/*yield*/,this.getNetwork()];case 1:_c.sent();return[4/*yield*/,lib$3.resolveProperties({address:this._getAddress(addressOrName),blockTag:this._getBlockTag(blockTag)})];case 2:params=_c.sent();_b=(_a=lib$2.BigNumber).from;return[4/*yield*/,this.perform(\"getTransactionCount\",params)];case 3:return[2/*return*/,_b.apply(_a,[_c.sent()]).toNumber()];}});});};BaseProvider.prototype.getCode=function(addressOrName,blockTag){return __awaiter(this,void 0,void 0,function(){var params,_a;return __generator(this,function(_b){switch(_b.label){case 0:return[4/*yield*/,this.getNetwork()];case 1:_b.sent();return[4/*yield*/,lib$3.resolveProperties({address:this._getAddress(addressOrName),blockTag:this._getBlockTag(blockTag)})];case 2:params=_b.sent();_a=lib$1.hexlify;return[4/*yield*/,this.perform(\"getCode\",params)];case 3:return[2/*return*/,_a.apply(void 0,[_b.sent()])];}});});};BaseProvider.prototype.getStorageAt=function(addressOrName,position,blockTag){return __awaiter(this,void 0,void 0,function(){var params,_a;return __generator(this,function(_b){switch(_b.label){case 0:return[4/*yield*/,this.getNetwork()];case 1:_b.sent();return[4/*yield*/,lib$3.resolveProperties({address:this._getAddress(addressOrName),blockTag:this._getBlockTag(blockTag),position:Promise.resolve(position).then(function(p){return lib$1.hexValue(p);})})];case 2:params=_b.sent();_a=lib$1.hexlify;return[4/*yield*/,this.perform(\"getStorageAt\",params)];case 3:return[2/*return*/,_a.apply(void 0,[_b.sent()])];}});});};// This should be called by any subclass wrapping a TransactionResponse\nBaseProvider.prototype._wrapTransaction=function(tx,hash){var _this=this;if(hash!=null&&lib$1.hexDataLength(hash)!==32){throw new Error(\"invalid response - sendTransaction\");}var result=tx;// Check the hash we expect is the same as the hash the server reported\nif(hash!=null&&tx.hash!==hash){logger.throwError(\"Transaction hash mismatch from Provider.sendTransaction.\",lib.Logger.errors.UNKNOWN_ERROR,{expectedHash:tx.hash,returnedHash:hash});}// @TODO: (confirmations? number, timeout? number)\nresult.wait=function(confirmations){return __awaiter(_this,void 0,void 0,function(){var receipt;return __generator(this,function(_a){switch(_a.label){case 0:// We know this transaction *must* exist (whether it gets mined is\n// another story), so setting an emitted value forces us to\n// wait even if the node returns null for the receipt\nif(confirmations!==0){this._emitted[\"t:\"+tx.hash]=\"pending\";}return[4/*yield*/,this.waitForTransaction(tx.hash,confirmations)];case 1:receipt=_a.sent();if(receipt==null&&confirmations===0){return[2/*return*/,null];}// No longer pending, allow the polling loop to garbage collect this\nthis._emitted[\"t:\"+tx.hash]=receipt.blockNumber;if(receipt.status===0){logger.throwError(\"transaction failed\",lib.Logger.errors.CALL_EXCEPTION,{transactionHash:tx.hash,transaction:tx,receipt:receipt});}return[2/*return*/,receipt];}});});};return result;};BaseProvider.prototype.sendTransaction=function(signedTransaction){return __awaiter(this,void 0,void 0,function(){var hexTx,tx,hash,error_2;return __generator(this,function(_a){switch(_a.label){case 0:return[4/*yield*/,this.getNetwork()];case 1:_a.sent();return[4/*yield*/,Promise.resolve(signedTransaction).then(function(t){return lib$1.hexlify(t);})];case 2:hexTx=_a.sent();tx=this.formatter.transaction(signedTransaction);_a.label=3;case 3:_a.trys.push([3,5,,6]);return[4/*yield*/,this.perform(\"sendTransaction\",{signedTransaction:hexTx})];case 4:hash=_a.sent();return[2/*return*/,this._wrapTransaction(tx,hash)];case 5:error_2=_a.sent();error_2.transaction=tx;error_2.transactionHash=tx.hash;throw error_2;case 6:return[2/*return*/];}});});};BaseProvider.prototype._getTransactionRequest=function(transaction){return __awaiter(this,void 0,void 0,function(){var values,tx,_a,_b;var _this=this;return __generator(this,function(_c){switch(_c.label){case 0:return[4/*yield*/,transaction];case 1:values=_c.sent();tx={};[\"from\",\"to\"].forEach(function(key){if(values[key]==null){return;}tx[key]=Promise.resolve(values[key]).then(function(v){return v?_this._getAddress(v):null;});});[\"gasLimit\",\"gasPrice\",\"value\"].forEach(function(key){if(values[key]==null){return;}tx[key]=Promise.resolve(values[key]).then(function(v){return v?lib$2.BigNumber.from(v):null;});});[\"data\"].forEach(function(key){if(values[key]==null){return;}tx[key]=Promise.resolve(values[key]).then(function(v){return v?lib$1.hexlify(v):null;});});_b=(_a=this.formatter).transactionRequest;return[4/*yield*/,lib$3.resolveProperties(tx)];case 2:return[2/*return*/,_b.apply(_a,[_c.sent()])];}});});};BaseProvider.prototype._getFilter=function(filter){return __awaiter(this,void 0,void 0,function(){var result,_a,_b;var _this=this;return __generator(this,function(_c){switch(_c.label){case 0:return[4/*yield*/,filter];case 1:filter=_c.sent();result={};if(filter.address!=null){result.address=this._getAddress(filter.address);}[\"blockHash\",\"topics\"].forEach(function(key){if(filter[key]==null){return;}result[key]=filter[key];});[\"fromBlock\",\"toBlock\"].forEach(function(key){if(filter[key]==null){return;}result[key]=_this._getBlockTag(filter[key]);});_b=(_a=this.formatter).filter;return[4/*yield*/,lib$3.resolveProperties(result)];case 2:return[2/*return*/,_b.apply(_a,[_c.sent()])];}});});};BaseProvider.prototype.call=function(transaction,blockTag){return __awaiter(this,void 0,void 0,function(){var params,_a;return __generator(this,function(_b){switch(_b.label){case 0:return[4/*yield*/,this.getNetwork()];case 1:_b.sent();return[4/*yield*/,lib$3.resolveProperties({transaction:this._getTransactionRequest(transaction),blockTag:this._getBlockTag(blockTag)})];case 2:params=_b.sent();_a=lib$1.hexlify;return[4/*yield*/,this.perform(\"call\",params)];case 3:return[2/*return*/,_a.apply(void 0,[_b.sent()])];}});});};BaseProvider.prototype.estimateGas=function(transaction){return __awaiter(this,void 0,void 0,function(){var params,_a,_b;return __generator(this,function(_c){switch(_c.label){case 0:return[4/*yield*/,this.getNetwork()];case 1:_c.sent();return[4/*yield*/,lib$3.resolveProperties({transaction:this._getTransactionRequest(transaction)})];case 2:params=_c.sent();_b=(_a=lib$2.BigNumber).from;return[4/*yield*/,this.perform(\"estimateGas\",params)];case 3:return[2/*return*/,_b.apply(_a,[_c.sent()])];}});});};BaseProvider.prototype._getAddress=function(addressOrName){return __awaiter(this,void 0,void 0,function(){var address;return __generator(this,function(_a){switch(_a.label){case 0:return[4/*yield*/,this.resolveName(addressOrName)];case 1:address=_a.sent();if(address==null){logger.throwError(\"ENS name not configured\",lib.Logger.errors.UNSUPPORTED_OPERATION,{operation:\"resolveName(\"+JSON.stringify(addressOrName)+\")\"});}return[2/*return*/,address];}});});};BaseProvider.prototype._getBlock=function(blockHashOrBlockTag,includeTransactions){return __awaiter(this,void 0,void 0,function(){var blockNumber,params,_a,_b,_c,error_3;var _this=this;return __generator(this,function(_d){switch(_d.label){case 0:return[4/*yield*/,this.getNetwork()];case 1:_d.sent();return[4/*yield*/,blockHashOrBlockTag];case 2:blockHashOrBlockTag=_d.sent();blockNumber=-128;params={includeTransactions:!!includeTransactions};if(!lib$1.isHexString(blockHashOrBlockTag,32))return[3/*break*/,3];params.blockHash=blockHashOrBlockTag;return[3/*break*/,6];case 3:_d.trys.push([3,5,,6]);_a=params;_c=(_b=this.formatter).blockTag;return[4/*yield*/,this._getBlockTag(blockHashOrBlockTag)];case 4:_a.blockTag=_c.apply(_b,[_d.sent()]);if(lib$1.isHexString(params.blockTag)){blockNumber=parseInt(params.blockTag.substring(2),16);}return[3/*break*/,6];case 5:error_3=_d.sent();logger.throwArgumentError(\"invalid block hash or block tag\",\"blockHashOrBlockTag\",blockHashOrBlockTag);return[3/*break*/,6];case 6:return[2/*return*/,lib$l.poll(function(){return __awaiter(_this,void 0,void 0,function(){var block,blockNumber_1,i,tx,confirmations;return __generator(this,function(_a){switch(_a.label){case 0:return[4/*yield*/,this.perform(\"getBlock\",params)];case 1:block=_a.sent();// Block was not found\nif(block==null){// For blockhashes, if we didn't say it existed, that blockhash may\n// not exist. If we did see it though, perhaps from a log, we know\n// it exists, and this node is just not caught up yet.\nif(params.blockHash!=null){if(this._emitted[\"b:\"+params.blockHash]==null){return[2/*return*/,null];}}// For block tags, if we are asking for a future block, we return null\nif(params.blockTag!=null){if(blockNumber>this._emitted.block){return[2/*return*/,null];}}// Retry on the next block\nreturn[2/*return*/,undefined];}if(!includeTransactions)return[3/*break*/,8];blockNumber_1=null;i=0;_a.label=2;case 2:if(!(i<block.transactions.length))return[3/*break*/,7];tx=block.transactions[i];if(!(tx.blockNumber==null))return[3/*break*/,3];tx.confirmations=0;return[3/*break*/,6];case 3:if(!(tx.confirmations==null))return[3/*break*/,6];if(!(blockNumber_1==null))return[3/*break*/,5];return[4/*yield*/,this._getInternalBlockNumber(100+2*this.pollingInterval)];case 4:blockNumber_1=_a.sent();_a.label=5;case 5:confirmations=blockNumber_1-tx.blockNumber+1;if(confirmations<=0){confirmations=1;}tx.confirmations=confirmations;_a.label=6;case 6:i++;return[3/*break*/,2];case 7:return[2/*return*/,this.formatter.blockWithTransactions(block)];case 8:return[2/*return*/,this.formatter.block(block)];}});});},{oncePoll:this})];}});});};BaseProvider.prototype.getBlock=function(blockHashOrBlockTag){return this._getBlock(blockHashOrBlockTag,false);};BaseProvider.prototype.getBlockWithTransactions=function(blockHashOrBlockTag){return this._getBlock(blockHashOrBlockTag,true);};BaseProvider.prototype.getTransaction=function(transactionHash){return __awaiter(this,void 0,void 0,function(){var params;var _this=this;return __generator(this,function(_a){switch(_a.label){case 0:return[4/*yield*/,this.getNetwork()];case 1:_a.sent();return[4/*yield*/,transactionHash];case 2:transactionHash=_a.sent();params={transactionHash:this.formatter.hash(transactionHash,true)};return[2/*return*/,lib$l.poll(function(){return __awaiter(_this,void 0,void 0,function(){var result,tx,blockNumber,confirmations;return __generator(this,function(_a){switch(_a.label){case 0:return[4/*yield*/,this.perform(\"getTransaction\",params)];case 1:result=_a.sent();if(result==null){if(this._emitted[\"t:\"+transactionHash]==null){return[2/*return*/,null];}return[2/*return*/,undefined];}tx=this.formatter.transactionResponse(result);if(!(tx.blockNumber==null))return[3/*break*/,2];tx.confirmations=0;return[3/*break*/,4];case 2:if(!(tx.confirmations==null))return[3/*break*/,4];return[4/*yield*/,this._getInternalBlockNumber(100+2*this.pollingInterval)];case 3:blockNumber=_a.sent();confirmations=blockNumber-tx.blockNumber+1;if(confirmations<=0){confirmations=1;}tx.confirmations=confirmations;_a.label=4;case 4:return[2/*return*/,this._wrapTransaction(tx)];}});});},{oncePoll:this})];}});});};BaseProvider.prototype.getTransactionReceipt=function(transactionHash){return __awaiter(this,void 0,void 0,function(){var params;var _this=this;return __generator(this,function(_a){switch(_a.label){case 0:return[4/*yield*/,this.getNetwork()];case 1:_a.sent();return[4/*yield*/,transactionHash];case 2:transactionHash=_a.sent();params={transactionHash:this.formatter.hash(transactionHash,true)};return[2/*return*/,lib$l.poll(function(){return __awaiter(_this,void 0,void 0,function(){var result,receipt,blockNumber,confirmations;return __generator(this,function(_a){switch(_a.label){case 0:return[4/*yield*/,this.perform(\"getTransactionReceipt\",params)];case 1:result=_a.sent();if(result==null){if(this._emitted[\"t:\"+transactionHash]==null){return[2/*return*/,null];}return[2/*return*/,undefined];}// \"geth-etc\" returns receipts before they are ready\nif(result.blockHash==null){return[2/*return*/,undefined];}receipt=this.formatter.receipt(result);if(!(receipt.blockNumber==null))return[3/*break*/,2];receipt.confirmations=0;return[3/*break*/,4];case 2:if(!(receipt.confirmations==null))return[3/*break*/,4];return[4/*yield*/,this._getInternalBlockNumber(100+2*this.pollingInterval)];case 3:blockNumber=_a.sent();confirmations=blockNumber-receipt.blockNumber+1;if(confirmations<=0){confirmations=1;}receipt.confirmations=confirmations;_a.label=4;case 4:return[2/*return*/,receipt];}});});},{oncePoll:this})];}});});};BaseProvider.prototype.getLogs=function(filter){return __awaiter(this,void 0,void 0,function(){var params,logs;return __generator(this,function(_a){switch(_a.label){case 0:return[4/*yield*/,this.getNetwork()];case 1:_a.sent();return[4/*yield*/,lib$3.resolveProperties({filter:this._getFilter(filter)})];case 2:params=_a.sent();return[4/*yield*/,this.perform(\"getLogs\",params)];case 3:logs=_a.sent();logs.forEach(function(log){if(log.removed==null){log.removed=false;}});return[2/*return*/,formatter.Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs)];}});});};BaseProvider.prototype.getEtherPrice=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(_a){switch(_a.label){case 0:return[4/*yield*/,this.getNetwork()];case 1:_a.sent();return[2/*return*/,this.perform(\"getEtherPrice\",{})];}});});};BaseProvider.prototype._getBlockTag=function(blockTag){return __awaiter(this,void 0,void 0,function(){var blockNumber;return __generator(this,function(_a){switch(_a.label){case 0:return[4/*yield*/,blockTag];case 1:blockTag=_a.sent();if(!(typeof blockTag===\"number\"&&blockTag<0))return[3/*break*/,3];if(blockTag%1){logger.throwArgumentError(\"invalid BlockTag\",\"blockTag\",blockTag);}return[4/*yield*/,this._getInternalBlockNumber(100+2*this.pollingInterval)];case 2:blockNumber=_a.sent();blockNumber+=blockTag;if(blockNumber<0){blockNumber=0;}return[2/*return*/,this.formatter.blockTag(blockNumber)];case 3:return[2/*return*/,this.formatter.blockTag(blockTag)];}});});};BaseProvider.prototype._getResolver=function(name){return __awaiter(this,void 0,void 0,function(){var network,transaction,_a,_b;return __generator(this,function(_c){switch(_c.label){case 0:return[4/*yield*/,this.getNetwork()];case 1:network=_c.sent();// No ENS...\nif(!network.ensAddress){logger.throwError(\"network does not support ENS\",lib.Logger.errors.UNSUPPORTED_OPERATION,{operation:\"ENS\",network:network.name});}transaction={to:network.ensAddress,data:\"0x0178b8bf\"+lib$9.namehash(name).substring(2)};_b=(_a=this.formatter).callAddress;return[4/*yield*/,this.call(transaction)];case 2:return[2/*return*/,_b.apply(_a,[_c.sent()])];}});});};BaseProvider.prototype.resolveName=function(name){return __awaiter(this,void 0,void 0,function(){var resolverAddress,transaction,_a,_b;return __generator(this,function(_c){switch(_c.label){case 0:return[4/*yield*/,name];case 1:name=_c.sent();// If it is already an address, nothing to resolve\ntry{return[2/*return*/,Promise.resolve(this.formatter.address(name))];}catch(error){// If is is a hexstring, the address is bad (See #694)\nif(lib$1.isHexString(name)){throw error;}}if(typeof name!==\"string\"){logger.throwArgumentError(\"invalid ENS name\",\"name\",name);}return[4/*yield*/,this._getResolver(name)];case 2:resolverAddress=_c.sent();if(!resolverAddress){return[2/*return*/,null];}transaction={to:resolverAddress,data:\"0x3b3b57de\"+lib$9.namehash(name).substring(2)};_b=(_a=this.formatter).callAddress;return[4/*yield*/,this.call(transaction)];case 3:return[2/*return*/,_b.apply(_a,[_c.sent()])];}});});};BaseProvider.prototype.lookupAddress=function(address){return __awaiter(this,void 0,void 0,function(){var reverseName,resolverAddress,bytes,_a,length,name,addr;return __generator(this,function(_b){switch(_b.label){case 0:return[4/*yield*/,address];case 1:address=_b.sent();address=this.formatter.address(address);reverseName=address.substring(2).toLowerCase()+\".addr.reverse\";return[4/*yield*/,this._getResolver(reverseName)];case 2:resolverAddress=_b.sent();if(!resolverAddress){return[2/*return*/,null];}_a=lib$1.arrayify;return[4/*yield*/,this.call({to:resolverAddress,data:\"0x691f3431\"+lib$9.namehash(reverseName).substring(2)})];case 3:bytes=_a.apply(void 0,[_b.sent()]);// Strip off the dynamic string pointer (0x20)\nif(bytes.length<32||!lib$2.BigNumber.from(bytes.slice(0,32)).eq(32)){return[2/*return*/,null];}bytes=bytes.slice(32);// Not a length-prefixed string\nif(bytes.length<32){return[2/*return*/,null];}length=lib$2.BigNumber.from(bytes.slice(0,32)).toNumber();bytes=bytes.slice(32);// Length longer than available data\nif(length>bytes.length){return[2/*return*/,null];}name=lib$8.toUtf8String(bytes.slice(0,length));return[4/*yield*/,this.resolveName(name)];case 4:addr=_b.sent();if(addr!=address){return[2/*return*/,null];}return[2/*return*/,name];}});});};BaseProvider.prototype.perform=function(method,params){return logger.throwError(method+\" not implemented\",lib.Logger.errors.NOT_IMPLEMENTED,{operation:method});};BaseProvider.prototype._startEvent=function(event){this.polling=this._events.filter(function(e){return e.pollable();}).length>0;};BaseProvider.prototype._stopEvent=function(event){this.polling=this._events.filter(function(e){return e.pollable();}).length>0;};BaseProvider.prototype._addEventListener=function(eventName,listener,once){var event=new Event(getEventTag(eventName),listener,once);this._events.push(event);this._startEvent(event);return this;};BaseProvider.prototype.on=function(eventName,listener){return this._addEventListener(eventName,listener,false);};BaseProvider.prototype.once=function(eventName,listener){return this._addEventListener(eventName,listener,true);};BaseProvider.prototype.emit=function(eventName){var _this=this;var args=[];for(var _i=1;_i<arguments.length;_i++){args[_i-1]=arguments[_i];}var result=false;var stopped=[];var eventTag=getEventTag(eventName);this._events=this._events.filter(function(event){if(event.tag!==eventTag){return true;}setTimeout(function(){event.listener.apply(_this,args);},0);result=true;if(event.once){stopped.push(event);return false;}return true;});stopped.forEach(function(event){_this._stopEvent(event);});return result;};BaseProvider.prototype.listenerCount=function(eventName){if(!eventName){return this._events.length;}var eventTag=getEventTag(eventName);return this._events.filter(function(event){return event.tag===eventTag;}).length;};BaseProvider.prototype.listeners=function(eventName){if(eventName==null){return this._events.map(function(event){return event.listener;});}var eventTag=getEventTag(eventName);return this._events.filter(function(event){return event.tag===eventTag;}).map(function(event){return event.listener;});};BaseProvider.prototype.off=function(eventName,listener){var _this=this;if(listener==null){return this.removeAllListeners(eventName);}var stopped=[];var found=false;var eventTag=getEventTag(eventName);this._events=this._events.filter(function(event){if(event.tag!==eventTag||event.listener!=listener){return true;}if(found){return true;}found=true;stopped.push(event);return false;});stopped.forEach(function(event){_this._stopEvent(event);});return this;};BaseProvider.prototype.removeAllListeners=function(eventName){var _this=this;var stopped=[];if(eventName==null){stopped=this._events;this._events=[];}else{var eventTag_1=getEventTag(eventName);this._events=this._events.filter(function(event){if(event.tag!==eventTag_1){return true;}stopped.push(event);return false;});}stopped.forEach(function(event){_this._stopEvent(event);});return this;};return BaseProvider;}(lib$b.Provider);exports.BaseProvider=BaseProvider;});var baseProvider$1=unwrapExports(baseProvider);var baseProvider_1=baseProvider.Event;var baseProvider_2=baseProvider.BaseProvider;var browserWs=createCommonjsModule(function(module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});var WS=null;try{WS=WebSocket;if(WS==null){throw new Error(\"inject please\");}}catch(error){var logger_2=new lib.Logger(_version$I.version);WS=function WS(){logger_2.throwError(\"WebSockets not supported in this environment\",lib.Logger.errors.UNSUPPORTED_OPERATION,{operation:\"new WebSocket()\"});};}module.exports=WS;});var browserWs$1=unwrapExports(browserWs);var jsonRpcProvider=createCommonjsModule(function(module,exports){\"use strict\";var __extends=commonjsGlobal&&commonjsGlobal.__extends||function(){var _extendStatics21=function extendStatics(d,b){_extendStatics21=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return _extendStatics21(d,b);};return function(d,b){_extendStatics21(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();var __awaiter=commonjsGlobal&&commonjsGlobal.__awaiter||function(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P(function(resolve){resolve(value);});}return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value));}catch(e){reject(e);}}function rejected(value){try{step(generator[\"throw\"](value));}catch(e){reject(e);}}function step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected);}step((generator=generator.apply(thisArg,_arguments||[])).next());});};var __generator=commonjsGlobal&&commonjsGlobal.__generator||function(thisArg,body){var _={label:0,sent:function sent(){if(t[0]&1)throw t[1];return t[1];},trys:[],ops:[]},f,y,t,g;return g={next:verb(0),\"throw\":verb(1),\"return\":verb(2)},typeof Symbol===\"function\"&&(g[Symbol.iterator]=function(){return this;}),g;function verb(n){return function(v){return step([n,v]);};}function step(op){if(f)throw new TypeError(\"Generator is already executing.\");while(_){try{if(f=1,y&&(t=op[0]&2?y[\"return\"]:op[0]?y[\"throw\"]||((t=y[\"return\"])&&t.call(y),0):y.next)&&!(t=t.call(y,op[1])).done)return t;if(y=0,t)op=[op[0]&2,t.value];switch(op[0]){case 0:case 1:t=op;break;case 4:_.label++;return{value:op[1],done:false};case 5:_.label++;y=op[1];op=[0];continue;case 7:op=_.ops.pop();_.trys.pop();continue;default:if(!(t=_.trys,t=t.length>0&&t[t.length-1])&&(op[0]===6||op[0]===2)){_=0;continue;}if(op[0]===3&&(!t||op[1]>t[0]&&op[1]<t[3])){_.label=op[1];break;}if(op[0]===6&&_.label<t[1]){_.label=t[1];t=op;break;}if(t&&_.label<t[2]){_.label=t[2];_.ops.push(op);break;}if(t[2])_.ops.pop();_.trys.pop();continue;}op=body.call(thisArg,_);}catch(e){op=[6,e];y=0;}finally{f=t=0;}}if(op[0]&5)throw op[1];return{value:op[0]?op[1]:void 0,done:true};}};Object.defineProperty(exports,\"__esModule\",{value:true});var logger=new lib.Logger(_version$I.version);function timer(timeout){return new Promise(function(resolve){setTimeout(resolve,timeout);});}function getResult(payload){if(payload.error){// @TODO: not any\nvar error=new Error(payload.error.message);error.code=payload.error.code;error.data=payload.error.data;throw error;}return payload.result;}function getLowerCase(value){if(value){return value.toLowerCase();}return value;}var _constructorGuard={};var JsonRpcSigner=/** @class */function(_super){__extends(JsonRpcSigner,_super);function JsonRpcSigner(constructorGuard,provider,addressOrIndex){var _newTarget=this.constructor;var _this=this;logger.checkNew(_newTarget,JsonRpcSigner);_this=_super.call(this)||this;if(constructorGuard!==_constructorGuard){throw new Error(\"do not call the JsonRpcSigner constructor directly; use provider.getSigner\");}lib$3.defineReadOnly(_this,\"provider\",provider);if(addressOrIndex==null){addressOrIndex=0;}if(typeof addressOrIndex===\"string\"){lib$3.defineReadOnly(_this,\"_address\",_this.provider.formatter.address(addressOrIndex));lib$3.defineReadOnly(_this,\"_index\",null);}else if(typeof addressOrIndex===\"number\"){lib$3.defineReadOnly(_this,\"_index\",addressOrIndex);lib$3.defineReadOnly(_this,\"_address\",null);}else{logger.throwArgumentError(\"invalid address or index\",\"addressOrIndex\",addressOrIndex);}return _this;}JsonRpcSigner.prototype.connect=function(provider){return logger.throwError(\"cannot alter JSON-RPC Signer connection\",lib.Logger.errors.UNSUPPORTED_OPERATION,{operation:\"connect\"});};JsonRpcSigner.prototype.connectUnchecked=function(){return new UncheckedJsonRpcSigner(_constructorGuard,this.provider,this._address||this._index);};JsonRpcSigner.prototype.getAddress=function(){var _this=this;if(this._address){return Promise.resolve(this._address);}return this.provider.send(\"eth_accounts\",[]).then(function(accounts){if(accounts.length<=_this._index){logger.throwError(\"unknown account #\"+_this._index,lib.Logger.errors.UNSUPPORTED_OPERATION,{operation:\"getAddress\"});}return _this.provider.formatter.address(accounts[_this._index]);});};JsonRpcSigner.prototype.sendUncheckedTransaction=function(transaction){var _this=this;transaction=lib$3.shallowCopy(transaction);var fromAddress=this.getAddress().then(function(address){if(address){address=address.toLowerCase();}return address;});// The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user\n// wishes to use this, it is easy to specify explicitly, otherwise\n// we look it up for them.\nif(transaction.gasLimit==null){var estimate=lib$3.shallowCopy(transaction);estimate.from=fromAddress;transaction.gasLimit=this.provider.estimateGas(estimate);}return lib$3.resolveProperties({tx:lib$3.resolveProperties(transaction),sender:fromAddress}).then(function(_a){var tx=_a.tx,sender=_a.sender;if(tx.from!=null){if(tx.from.toLowerCase()!==sender){logger.throwArgumentError(\"from address mismatch\",\"transaction\",transaction);}}else{tx.from=sender;}var hexTx=_this.provider.constructor.hexlifyTransaction(tx,{from:true});return _this.provider.send(\"eth_sendTransaction\",[hexTx]).then(function(hash){return hash;},function(error){if(error.responseText){// See: JsonRpcProvider.sendTransaction (@TODO: Expose a ._throwError??)\nif(error.responseText.indexOf(\"insufficient funds\")>=0){logger.throwError(\"insufficient funds\",lib.Logger.errors.INSUFFICIENT_FUNDS,{transaction:tx});}if(error.responseText.indexOf(\"nonce too low\")>=0){logger.throwError(\"nonce has already been used\",lib.Logger.errors.NONCE_EXPIRED,{transaction:tx});}if(error.responseText.indexOf(\"replacement transaction underpriced\")>=0){logger.throwError(\"replacement fee too low\",lib.Logger.errors.REPLACEMENT_UNDERPRICED,{transaction:tx});}}throw error;});});};JsonRpcSigner.prototype.signTransaction=function(transaction){return logger.throwError(\"signing transactions is unsupported\",lib.Logger.errors.UNSUPPORTED_OPERATION,{operation:\"signTransaction\"});};JsonRpcSigner.prototype.sendTransaction=function(transaction){var _this=this;return this.sendUncheckedTransaction(transaction).then(function(hash){return lib$l.poll(function(){return _this.provider.getTransaction(hash).then(function(tx){if(tx===null){return undefined;}return _this.provider._wrapTransaction(tx,hash);});},{onceBlock:_this.provider}).catch(function(error){error.transactionHash=hash;throw error;});});};JsonRpcSigner.prototype.signMessage=function(message){var _this=this;var data=typeof message===\"string\"?lib$8.toUtf8Bytes(message):message;return this.getAddress().then(function(address){// https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign\nreturn _this.provider.send(\"eth_sign\",[address.toLowerCase(),lib$1.hexlify(data)]);});};JsonRpcSigner.prototype.unlock=function(password){var provider=this.provider;return this.getAddress().then(function(address){return provider.send(\"personal_unlockAccount\",[address.toLowerCase(),password,null]);});};return JsonRpcSigner;}(lib$c.Signer);exports.JsonRpcSigner=JsonRpcSigner;var UncheckedJsonRpcSigner=/** @class */function(_super){__extends(UncheckedJsonRpcSigner,_super);function UncheckedJsonRpcSigner(){return _super!==null&&_super.apply(this,arguments)||this;}UncheckedJsonRpcSigner.prototype.sendTransaction=function(transaction){var _this=this;return this.sendUncheckedTransaction(transaction).then(function(hash){return{hash:hash,nonce:null,gasLimit:null,gasPrice:null,data:null,value:null,chainId:null,confirmations:0,from:null,wait:function wait(confirmations){return _this.provider.waitForTransaction(hash,confirmations);}};});};return UncheckedJsonRpcSigner;}(JsonRpcSigner);var allowedTransactionKeys={chainId:true,data:true,gasLimit:true,gasPrice:true,nonce:true,to:true,value:true};var JsonRpcProvider=/** @class */function(_super){__extends(JsonRpcProvider,_super);function JsonRpcProvider(url,network){var _newTarget=this.constructor;var _this=this;logger.checkNew(_newTarget,JsonRpcProvider);var networkOrReady=network;// The network is unknown, query the JSON-RPC for it\nif(networkOrReady==null){networkOrReady=new Promise(function(resolve,reject){setTimeout(function(){_this.detectNetwork().then(function(network){resolve(network);},function(error){reject(error);});},0);});}_this=_super.call(this,networkOrReady)||this;// Default URL\nif(!url){url=lib$3.getStatic(_this.constructor,\"defaultUrl\")();}if(typeof url===\"string\"){lib$3.defineReadOnly(_this,\"connection\",Object.freeze({url:url}));}else{lib$3.defineReadOnly(_this,\"connection\",Object.freeze(lib$3.shallowCopy(url)));}_this._nextId=42;return _this;}JsonRpcProvider.defaultUrl=function(){return\"http:/\\/localhost:8545\";};JsonRpcProvider.prototype.detectNetwork=function(){return __awaiter(this,void 0,void 0,function(){var chainId,error_1,error_2,getNetwork;return __generator(this,function(_a){switch(_a.label){case 0:return[4/*yield*/,timer(0)];case 1:_a.sent();chainId=null;_a.label=2;case 2:_a.trys.push([2,4,,9]);return[4/*yield*/,this.send(\"eth_chainId\",[])];case 3:chainId=_a.sent();return[3/*break*/,9];case 4:error_1=_a.sent();_a.label=5;case 5:_a.trys.push([5,7,,8]);return[4/*yield*/,this.send(\"net_version\",[])];case 6:chainId=_a.sent();return[3/*break*/,8];case 7:error_2=_a.sent();return[3/*break*/,8];case 8:return[3/*break*/,9];case 9:if(chainId!=null){getNetwork=lib$3.getStatic(this.constructor,\"getNetwork\");try{return[2/*return*/,getNetwork(lib$2.BigNumber.from(chainId).toNumber())];}catch(error){return[2/*return*/,logger.throwError(\"could not detect network\",lib.Logger.errors.NETWORK_ERROR,{chainId:chainId,event:\"invalidNetwork\",serverError:error})];}}return[2/*return*/,logger.throwError(\"could not detect network\",lib.Logger.errors.NETWORK_ERROR,{event:\"noNetwork\"})];}});});};JsonRpcProvider.prototype.getSigner=function(addressOrIndex){return new JsonRpcSigner(_constructorGuard,this,addressOrIndex);};JsonRpcProvider.prototype.getUncheckedSigner=function(addressOrIndex){return this.getSigner(addressOrIndex).connectUnchecked();};JsonRpcProvider.prototype.listAccounts=function(){var _this=this;return this.send(\"eth_accounts\",[]).then(function(accounts){return accounts.map(function(a){return _this.formatter.address(a);});});};JsonRpcProvider.prototype.send=function(method,params){var _this=this;var request={method:method,params:params,id:this._nextId++,jsonrpc:\"2.0\"};this.emit(\"debug\",{action:\"request\",request:lib$3.deepCopy(request),provider:this});return lib$l.fetchJson(this.connection,JSON.stringify(request),getResult).then(function(result){_this.emit(\"debug\",{action:\"response\",request:request,response:result,provider:_this});return result;},function(error){_this.emit(\"debug\",{action:\"response\",error:error,request:request,provider:_this});throw error;});};JsonRpcProvider.prototype.prepareRequest=function(method,params){switch(method){case\"getBlockNumber\":return[\"eth_blockNumber\",[]];case\"getGasPrice\":return[\"eth_gasPrice\",[]];case\"getBalance\":return[\"eth_getBalance\",[getLowerCase(params.address),params.blockTag]];case\"getTransactionCount\":return[\"eth_getTransactionCount\",[getLowerCase(params.address),params.blockTag]];case\"getCode\":return[\"eth_getCode\",[getLowerCase(params.address),params.blockTag]];case\"getStorageAt\":return[\"eth_getStorageAt\",[getLowerCase(params.address),params.position,params.blockTag]];case\"sendTransaction\":return[\"eth_sendRawTransaction\",[params.signedTransaction]];case\"getBlock\":if(params.blockTag){return[\"eth_getBlockByNumber\",[params.blockTag,!!params.includeTransactions]];}else if(params.blockHash){return[\"eth_getBlockByHash\",[params.blockHash,!!params.includeTransactions]];}return null;case\"getTransaction\":return[\"eth_getTransactionByHash\",[params.transactionHash]];case\"getTransactionReceipt\":return[\"eth_getTransactionReceipt\",[params.transactionHash]];case\"call\":{var hexlifyTransaction=lib$3.getStatic(this.constructor,\"hexlifyTransaction\");return[\"eth_call\",[hexlifyTransaction(params.transaction,{from:true}),params.blockTag]];}case\"estimateGas\":{var hexlifyTransaction=lib$3.getStatic(this.constructor,\"hexlifyTransaction\");return[\"eth_estimateGas\",[hexlifyTransaction(params.transaction,{from:true})]];}case\"getLogs\":if(params.filter&&params.filter.address!=null){params.filter.address=getLowerCase(params.filter.address);}return[\"eth_getLogs\",[params.filter]];default:break;}return null;};JsonRpcProvider.prototype.perform=function(method,params){var args=this.prepareRequest(method,params);if(args==null){logger.throwError(method+\" not implemented\",lib.Logger.errors.NOT_IMPLEMENTED,{operation:method});}// We need a little extra logic to process errors from sendTransaction\nif(method===\"sendTransaction\"){return this.send(args[0],args[1]).catch(function(error){if(error.responseText){// \"insufficient funds for gas * price + value\"\nif(error.responseText.indexOf(\"insufficient funds\")>0){logger.throwError(\"insufficient funds\",lib.Logger.errors.INSUFFICIENT_FUNDS,{});}// \"nonce too low\"\nif(error.responseText.indexOf(\"nonce too low\")>0){logger.throwError(\"nonce has already been used\",lib.Logger.errors.NONCE_EXPIRED,{});}// \"replacement transaction underpriced\"\nif(error.responseText.indexOf(\"replacement transaction underpriced\")>0){logger.throwError(\"replacement fee too low\",lib.Logger.errors.REPLACEMENT_UNDERPRICED,{});}}throw error;});}return this.send(args[0],args[1]);};JsonRpcProvider.prototype._startEvent=function(event){if(event.tag===\"pending\"){this._startPending();}_super.prototype._startEvent.call(this,event);};JsonRpcProvider.prototype._startPending=function(){if(this._pendingFilter!=null){return;}var self=this;var pendingFilter=this.send(\"eth_newPendingTransactionFilter\",[]);this._pendingFilter=pendingFilter;pendingFilter.then(function(filterId){function poll(){self.send(\"eth_getFilterChanges\",[filterId]).then(function(hashes){if(self._pendingFilter!=pendingFilter){return null;}var seq=Promise.resolve();hashes.forEach(function(hash){// @TODO: This should be garbage collected at some point... How? When?\nself._emitted[\"t:\"+hash.toLowerCase()]=\"pending\";seq=seq.then(function(){return self.getTransaction(hash).then(function(tx){self.emit(\"pending\",tx);return null;});});});return seq.then(function(){return timer(1000);});}).then(function(){if(self._pendingFilter!=pendingFilter){self.send(\"eth_uninstallFilter\",[filterId]);return;}setTimeout(function(){poll();},0);return null;}).catch(function(error){});}poll();return filterId;}).catch(function(error){});};JsonRpcProvider.prototype._stopEvent=function(event){if(event.tag===\"pending\"&&this.listenerCount(\"pending\")===0){this._pendingFilter=null;}_super.prototype._stopEvent.call(this,event);};// Convert an ethers.js transaction into a JSON-RPC transaction\n//  - gasLimit => gas\n//  - All values hexlified\n//  - All numeric values zero-striped\n//  - All addresses are lowercased\n// NOTE: This allows a TransactionRequest, but all values should be resolved\n//       before this is called\n// @TODO: This will likely be removed in future versions and prepareRequest\n//        will be the preferred method for this.\nJsonRpcProvider.hexlifyTransaction=function(transaction,allowExtra){// Check only allowed properties are given\nvar allowed=lib$3.shallowCopy(allowedTransactionKeys);if(allowExtra){for(var key in allowExtra){if(allowExtra[key]){allowed[key]=true;}}}lib$3.checkProperties(transaction,allowed);var result={};// Some nodes (INFURA ropsten; INFURA mainnet is fine) do not like leading zeros.\n[\"gasLimit\",\"gasPrice\",\"nonce\",\"value\"].forEach(function(key){if(transaction[key]==null){return;}var value=lib$1.hexValue(transaction[key]);if(key===\"gasLimit\"){key=\"gas\";}result[key]=value;});[\"from\",\"to\",\"data\"].forEach(function(key){if(transaction[key]==null){return;}result[key]=lib$1.hexlify(transaction[key]);});return result;};return JsonRpcProvider;}(baseProvider.BaseProvider);exports.JsonRpcProvider=JsonRpcProvider;});var jsonRpcProvider$1=unwrapExports(jsonRpcProvider);var jsonRpcProvider_1=jsonRpcProvider.JsonRpcSigner;var jsonRpcProvider_2=jsonRpcProvider.JsonRpcProvider;var websocketProvider=createCommonjsModule(function(module,exports){\"use strict\";var __extends=commonjsGlobal&&commonjsGlobal.__extends||function(){var _extendStatics22=function extendStatics(d,b){_extendStatics22=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return _extendStatics22(d,b);};return function(d,b){_extendStatics22(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();var __awaiter=commonjsGlobal&&commonjsGlobal.__awaiter||function(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P(function(resolve){resolve(value);});}return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value));}catch(e){reject(e);}}function rejected(value){try{step(generator[\"throw\"](value));}catch(e){reject(e);}}function step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected);}step((generator=generator.apply(thisArg,_arguments||[])).next());});};var __generator=commonjsGlobal&&commonjsGlobal.__generator||function(thisArg,body){var _={label:0,sent:function sent(){if(t[0]&1)throw t[1];return t[1];},trys:[],ops:[]},f,y,t,g;return g={next:verb(0),\"throw\":verb(1),\"return\":verb(2)},typeof Symbol===\"function\"&&(g[Symbol.iterator]=function(){return this;}),g;function verb(n){return function(v){return step([n,v]);};}function step(op){if(f)throw new TypeError(\"Generator is already executing.\");while(_){try{if(f=1,y&&(t=op[0]&2?y[\"return\"]:op[0]?y[\"throw\"]||((t=y[\"return\"])&&t.call(y),0):y.next)&&!(t=t.call(y,op[1])).done)return t;if(y=0,t)op=[op[0]&2,t.value];switch(op[0]){case 0:case 1:t=op;break;case 4:_.label++;return{value:op[1],done:false};case 5:_.label++;y=op[1];op=[0];continue;case 7:op=_.ops.pop();_.trys.pop();continue;default:if(!(t=_.trys,t=t.length>0&&t[t.length-1])&&(op[0]===6||op[0]===2)){_=0;continue;}if(op[0]===3&&(!t||op[1]>t[0]&&op[1]<t[3])){_.label=op[1];break;}if(op[0]===6&&_.label<t[1]){_.label=t[1];t=op;break;}if(t&&_.label<t[2]){_.label=t[2];_.ops.push(op);break;}if(t[2])_.ops.pop();_.trys.pop();continue;}op=body.call(thisArg,_);}catch(e){op=[6,e];y=0;}finally{f=t=0;}}if(op[0]&5)throw op[1];return{value:op[0]?op[1]:void 0,done:true};}};var __importDefault=commonjsGlobal&&commonjsGlobal.__importDefault||function(mod){return mod&&mod.__esModule?mod:{\"default\":mod};};Object.defineProperty(exports,\"__esModule\",{value:true});var ws_1=__importDefault(browserWs);var logger=new lib.Logger(_version$I.version);/**\n\t *  Notes:\n\t *\n\t *  This provider differs a bit from the polling providers. One main\n\t *  difference is how it handles consistency. The polling providers\n\t *  will stall responses to ensure a consistent state, while this\n\t *  WebSocket provider assumes the connected backend will manage this.\n\t *\n\t *  For example, if a polling provider emits an event which indicats\n\t *  the event occurred in blockhash XXX, a call to fetch that block by\n\t *  its hash XXX, if not present will retry until it is present. This\n\t *  can occur when querying a pool of nodes that are mildly out of sync\n\t *  with each other.\n\t */var NextId=1;// For more info about the Real-time Event API see:\n//   https://geth.ethereum.org/docs/rpc/pubsub\nvar WebSocketProvider=/** @class */function(_super){__extends(WebSocketProvider,_super);function WebSocketProvider(url,network){var _this=this;// This will be added in the future; please open an issue to expedite\nif(network===\"any\"){logger.throwError(\"WebSocketProvider does not support 'any' network yet\",lib.Logger.errors.UNSUPPORTED_OPERATION,{operation:\"network:any\"});}_this=_super.call(this,url,network)||this;_this._pollingInterval=-1;lib$3.defineReadOnly(_this,\"_websocket\",new ws_1.default(_this.connection.url));lib$3.defineReadOnly(_this,\"_requests\",{});lib$3.defineReadOnly(_this,\"_subs\",{});lib$3.defineReadOnly(_this,\"_subIds\",{});// Stall sending requests until the socket is open...\n_this._wsReady=false;_this._websocket.onopen=function(){_this._wsReady=true;Object.keys(_this._requests).forEach(function(id){_this._websocket.send(_this._requests[id].payload);});};_this._websocket.onmessage=function(messageEvent){var data=messageEvent.data;var result=JSON.parse(data);if(result.id!=null){var id=String(result.id);var request=_this._requests[id];delete _this._requests[id];if(result.result!==undefined){request.callback(null,result.result);}else{if(result.error){var error=new Error(result.error.message||\"unknown error\");lib$3.defineReadOnly(error,\"code\",result.error.code||null);lib$3.defineReadOnly(error,\"response\",data);request.callback(error,undefined);}else{request.callback(new Error(\"unknown error\"),undefined);}}}else if(result.method===\"eth_subscription\"){// Subscription...\nvar sub=_this._subs[result.params.subscription];if(sub){//this.emit.apply(this,                  );\nsub.processFunc(result.params.result);}}else{console.warn(\"this should not happen\");}};// This Provider does not actually poll, but we want to trigger\n// poll events for things that depend on them (like stalling for\n// block and transaction lookups)\nvar fauxPoll=setInterval(function(){_this.emit(\"poll\");},1000);if(fauxPoll.unref){fauxPoll.unref();}return _this;}Object.defineProperty(WebSocketProvider.prototype,\"pollingInterval\",{get:function get(){return 0;},set:function set(value){logger.throwError(\"cannot set polling interval on WebSocketProvider\",lib.Logger.errors.UNSUPPORTED_OPERATION,{operation:\"setPollingInterval\"});},enumerable:true,configurable:true});WebSocketProvider.prototype.resetEventsBlock=function(blockNumber){logger.throwError(\"cannot reset events block on WebSocketProvider\",lib.Logger.errors.UNSUPPORTED_OPERATION,{operation:\"resetEventBlock\"});};WebSocketProvider.prototype.poll=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(_a){return[2/*return*/,null];});});};Object.defineProperty(WebSocketProvider.prototype,\"polling\",{set:function set(value){if(!value){return;}logger.throwError(\"cannot set polling on WebSocketProvider\",lib.Logger.errors.UNSUPPORTED_OPERATION,{operation:\"setPolling\"});},enumerable:true,configurable:true});WebSocketProvider.prototype.send=function(method,params){var _this=this;var rid=NextId++;return new Promise(function(resolve,reject){function callback(error,result){if(error){return reject(error);}return resolve(result);}var payload=JSON.stringify({method:method,params:params,id:rid,jsonrpc:\"2.0\"});_this._requests[String(rid)]={callback:callback,payload:payload};if(_this._wsReady){_this._websocket.send(payload);}});};WebSocketProvider.defaultUrl=function(){return\"ws:/\\/localhost:8546\";};WebSocketProvider.prototype._subscribe=function(tag,param,processFunc){return __awaiter(this,void 0,void 0,function(){var subIdPromise,subId;var _this=this;return __generator(this,function(_a){switch(_a.label){case 0:subIdPromise=this._subIds[tag];if(subIdPromise==null){subIdPromise=Promise.all(param).then(function(param){return _this.send(\"eth_subscribe\",param);});this._subIds[tag]=subIdPromise;}return[4/*yield*/,subIdPromise];case 1:subId=_a.sent();this._subs[subId]={tag:tag,processFunc:processFunc};return[2/*return*/];}});});};WebSocketProvider.prototype._startEvent=function(event){var _this=this;switch(event.type){case\"block\":this._subscribe(\"block\",[\"newHeads\"],function(result){var blockNumber=lib$2.BigNumber.from(result.number).toNumber();_this._emitted.block=blockNumber;_this.emit(\"block\",blockNumber);});break;case\"pending\":this._subscribe(\"pending\",[\"newPendingTransactions\"],function(result){_this.emit(\"pending\",result);});break;case\"filter\":this._subscribe(event.tag,[\"logs\",this._getFilter(event.filter)],function(result){if(result.removed==null){result.removed=false;}_this.emit(event.filter,_this.formatter.filterLog(result));});break;case\"tx\":{var emitReceipt_1=function emitReceipt_1(event){var hash=event.hash;_this.getTransactionReceipt(hash).then(function(receipt){if(!receipt){return;}_this.emit(hash,receipt);});};// In case it is already mined\nemitReceipt_1(event);// To keep things simple, we start up a single newHeads subscription\n// to keep an eye out for transactions we are watching for.\n// Starting a subscription for an event (i.e. \"tx\") that is already\n// running is (basically) a nop.\nthis._subscribe(\"tx\",[\"newHeads\"],function(result){_this._events.filter(function(e){return e.type===\"tx\";}).forEach(emitReceipt_1);});break;}// Nothing is needed\ncase\"debug\":case\"poll\":case\"willPoll\":case\"didPoll\":case\"error\":break;default:console.log(\"unhandled:\",event);break;}};WebSocketProvider.prototype._stopEvent=function(event){var _this=this;var tag=event.tag;if(event.type===\"tx\"){// There are remaining transaction event listeners\nif(this._events.filter(function(e){return e.type===\"tx\";}).length){return;}tag=\"tx\";}else if(this.listenerCount(event.event)){// There are remaining event listeners\nreturn;}var subId=this._subIds[tag];if(!subId){return;}delete this._subIds[tag];subId.then(function(subId){if(!_this._subs[subId]){return;}delete _this._subs[subId];_this.send(\"eth_unsubscribe\",[subId]);});};WebSocketProvider.prototype.destroy=function(){return __awaiter(this,void 0,void 0,function(){var _this=this;return __generator(this,function(_a){switch(_a.label){case 0:if(!(this._websocket.readyState===ws_1.default.CONNECTING))return[3/*break*/,2];return[4/*yield*/,new Promise(function(resolve){_this._websocket.onopen=function(){resolve(true);};_this._websocket.onerror=function(){resolve(false);};})];case 1:_a.sent();_a.label=2;case 2:// Hangup\n// See: https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes\nthis._websocket.close(1000);return[2/*return*/];}});});};return WebSocketProvider;}(jsonRpcProvider.JsonRpcProvider);exports.WebSocketProvider=WebSocketProvider;});var websocketProvider$1=unwrapExports(websocketProvider);var websocketProvider_1=websocketProvider.WebSocketProvider;var urlJsonRpcProvider=createCommonjsModule(function(module,exports){\"use strict\";var __extends=commonjsGlobal&&commonjsGlobal.__extends||function(){var _extendStatics23=function extendStatics(d,b){_extendStatics23=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return _extendStatics23(d,b);};return function(d,b){_extendStatics23(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();var __awaiter=commonjsGlobal&&commonjsGlobal.__awaiter||function(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P(function(resolve){resolve(value);});}return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value));}catch(e){reject(e);}}function rejected(value){try{step(generator[\"throw\"](value));}catch(e){reject(e);}}function step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected);}step((generator=generator.apply(thisArg,_arguments||[])).next());});};var __generator=commonjsGlobal&&commonjsGlobal.__generator||function(thisArg,body){var _={label:0,sent:function sent(){if(t[0]&1)throw t[1];return t[1];},trys:[],ops:[]},f,y,t,g;return g={next:verb(0),\"throw\":verb(1),\"return\":verb(2)},typeof Symbol===\"function\"&&(g[Symbol.iterator]=function(){return this;}),g;function verb(n){return function(v){return step([n,v]);};}function step(op){if(f)throw new TypeError(\"Generator is already executing.\");while(_){try{if(f=1,y&&(t=op[0]&2?y[\"return\"]:op[0]?y[\"throw\"]||((t=y[\"return\"])&&t.call(y),0):y.next)&&!(t=t.call(y,op[1])).done)return t;if(y=0,t)op=[op[0]&2,t.value];switch(op[0]){case 0:case 1:t=op;break;case 4:_.label++;return{value:op[1],done:false};case 5:_.label++;y=op[1];op=[0];continue;case 7:op=_.ops.pop();_.trys.pop();continue;default:if(!(t=_.trys,t=t.length>0&&t[t.length-1])&&(op[0]===6||op[0]===2)){_=0;continue;}if(op[0]===3&&(!t||op[1]>t[0]&&op[1]<t[3])){_.label=op[1];break;}if(op[0]===6&&_.label<t[1]){_.label=t[1];t=op;break;}if(t&&_.label<t[2]){_.label=t[2];_.ops.push(op);break;}if(t[2])_.ops.pop();_.trys.pop();continue;}op=body.call(thisArg,_);}catch(e){op=[6,e];y=0;}finally{f=t=0;}}if(op[0]&5)throw op[1];return{value:op[0]?op[1]:void 0,done:true};}};Object.defineProperty(exports,\"__esModule\",{value:true});var logger=new lib.Logger(_version$I.version);// A StaticJsonRpcProvider is useful when you *know* for certain that\n// the backend will never change, as it never calls eth_chainId to\n// verify its backend. However, if the backend does change, the effects\n// are undefined and may include:\n// - inconsistent results\n// - locking up the UI\n// - block skew warnings\n// - wrong results\n// If the network is not explicit (i.e. auto-detection is expected), the\n// node MUST be running and available to respond to requests BEFORE this\n// is instantiated.\nvar StaticJsonRpcProvider=/** @class */function(_super){__extends(StaticJsonRpcProvider,_super);function StaticJsonRpcProvider(){return _super!==null&&_super.apply(this,arguments)||this;}StaticJsonRpcProvider.prototype.detectNetwork=function(){return __awaiter(this,void 0,void 0,function(){var network;return __generator(this,function(_a){switch(_a.label){case 0:network=this.network;if(!(network==null))return[3/*break*/,2];return[4/*yield*/,_super.prototype.detectNetwork.call(this)];case 1:network=_a.sent();if(!network){logger.throwError(\"no network detected\",lib.Logger.errors.UNKNOWN_ERROR,{});}// If still not set, set it\nif(this._network==null){// A static network does not support \"any\"\nlib$3.defineReadOnly(this,\"_network\",network);this.emit(\"network\",network,null);}_a.label=2;case 2:return[2/*return*/,network];}});});};return StaticJsonRpcProvider;}(jsonRpcProvider.JsonRpcProvider);exports.StaticJsonRpcProvider=StaticJsonRpcProvider;var UrlJsonRpcProvider=/** @class */function(_super){__extends(UrlJsonRpcProvider,_super);function UrlJsonRpcProvider(network,apiKey){var _newTarget=this.constructor;var _this=this;logger.checkAbstract(_newTarget,UrlJsonRpcProvider);// Normalize the Network and API Key\nnetwork=lib$3.getStatic(_newTarget,\"getNetwork\")(network);apiKey=lib$3.getStatic(_newTarget,\"getApiKey\")(apiKey);var connection=lib$3.getStatic(_newTarget,\"getUrl\")(network,apiKey);_this=_super.call(this,connection,network)||this;if(typeof apiKey===\"string\"){lib$3.defineReadOnly(_this,\"apiKey\",apiKey);}else if(apiKey!=null){Object.keys(apiKey).forEach(function(key){lib$3.defineReadOnly(_this,key,apiKey[key]);});}return _this;}UrlJsonRpcProvider.prototype._startPending=function(){logger.warn(\"WARNING: API provider does not support pending filters\");};UrlJsonRpcProvider.prototype.getSigner=function(address){return logger.throwError(\"API provider does not support signing\",lib.Logger.errors.UNSUPPORTED_OPERATION,{operation:\"getSigner\"});};UrlJsonRpcProvider.prototype.listAccounts=function(){return Promise.resolve([]);};// Return a defaultApiKey if null, otherwise validate the API key\nUrlJsonRpcProvider.getApiKey=function(apiKey){return apiKey;};// Returns the url or connection for the given network and API key. The\n// API key will have been sanitized by the getApiKey first, so any validation\n// or transformations can be done there.\nUrlJsonRpcProvider.getUrl=function(network,apiKey){return logger.throwError(\"not implemented; sub-classes must override getUrl\",lib.Logger.errors.NOT_IMPLEMENTED,{operation:\"getUrl\"});};return UrlJsonRpcProvider;}(StaticJsonRpcProvider);exports.UrlJsonRpcProvider=UrlJsonRpcProvider;});var urlJsonRpcProvider$1=unwrapExports(urlJsonRpcProvider);var urlJsonRpcProvider_1=urlJsonRpcProvider.StaticJsonRpcProvider;var urlJsonRpcProvider_2=urlJsonRpcProvider.UrlJsonRpcProvider;var alchemyProvider=createCommonjsModule(function(module,exports){\"use strict\";var __extends=commonjsGlobal&&commonjsGlobal.__extends||function(){var _extendStatics24=function extendStatics(d,b){_extendStatics24=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return _extendStatics24(d,b);};return function(d,b){_extendStatics24(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,\"__esModule\",{value:true});var logger=new lib.Logger(_version$I.version);// This key was provided to ethers.js by Alchemy to be used by the\n// default provider, but it is recommended that for your own\n// production environments, that you acquire your own API key at:\n//   https://dashboard.alchemyapi.io\nvar defaultApiKey=\"_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC\";var AlchemyProvider=/** @class */function(_super){__extends(AlchemyProvider,_super);function AlchemyProvider(){return _super!==null&&_super.apply(this,arguments)||this;}AlchemyProvider.getWebSocketProvider=function(network,apiKey){var provider=new AlchemyProvider(network,apiKey);var url=provider.connection.url.replace(/^http/i,\"ws\").replace(\".alchemyapi.\",\".ws.alchemyapi.\");return new websocketProvider.WebSocketProvider(url,provider.network);};AlchemyProvider.getApiKey=function(apiKey){if(apiKey==null){return defaultApiKey;}if(apiKey&&typeof apiKey!==\"string\"){logger.throwArgumentError(\"invalid apiKey\",\"apiKey\",apiKey);}return apiKey;};AlchemyProvider.getUrl=function(network,apiKey){var host=null;switch(network.name){case\"homestead\":host=\"eth-mainnet.alchemyapi.io/v2/\";break;case\"ropsten\":host=\"eth-ropsten.alchemyapi.io/v2/\";break;case\"rinkeby\":host=\"eth-rinkeby.alchemyapi.io/v2/\";break;case\"goerli\":host=\"eth-goerli.alchemyapi.io/v2/\";break;case\"kovan\":host=\"eth-kovan.alchemyapi.io/v2/\";break;default:logger.throwArgumentError(\"unsupported network\",\"network\",arguments[0]);}return{url:\"https:/\"+\"/\"+host+apiKey,throttleCallback:function throttleCallback(attempt,url){if(apiKey===defaultApiKey){formatter.showThrottleMessage();}return Promise.resolve(true);}};};return AlchemyProvider;}(urlJsonRpcProvider.UrlJsonRpcProvider);exports.AlchemyProvider=AlchemyProvider;});var alchemyProvider$1=unwrapExports(alchemyProvider);var alchemyProvider_1=alchemyProvider.AlchemyProvider;var cloudflareProvider=createCommonjsModule(function(module,exports){\"use strict\";var __extends=commonjsGlobal&&commonjsGlobal.__extends||function(){var _extendStatics25=function extendStatics(d,b){_extendStatics25=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return _extendStatics25(d,b);};return function(d,b){_extendStatics25(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();var __awaiter=commonjsGlobal&&commonjsGlobal.__awaiter||function(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P(function(resolve){resolve(value);});}return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value));}catch(e){reject(e);}}function rejected(value){try{step(generator[\"throw\"](value));}catch(e){reject(e);}}function step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected);}step((generator=generator.apply(thisArg,_arguments||[])).next());});};var __generator=commonjsGlobal&&commonjsGlobal.__generator||function(thisArg,body){var _={label:0,sent:function sent(){if(t[0]&1)throw t[1];return t[1];},trys:[],ops:[]},f,y,t,g;return g={next:verb(0),\"throw\":verb(1),\"return\":verb(2)},typeof Symbol===\"function\"&&(g[Symbol.iterator]=function(){return this;}),g;function verb(n){return function(v){return step([n,v]);};}function step(op){if(f)throw new TypeError(\"Generator is already executing.\");while(_){try{if(f=1,y&&(t=op[0]&2?y[\"return\"]:op[0]?y[\"throw\"]||((t=y[\"return\"])&&t.call(y),0):y.next)&&!(t=t.call(y,op[1])).done)return t;if(y=0,t)op=[op[0]&2,t.value];switch(op[0]){case 0:case 1:t=op;break;case 4:_.label++;return{value:op[1],done:false};case 5:_.label++;y=op[1];op=[0];continue;case 7:op=_.ops.pop();_.trys.pop();continue;default:if(!(t=_.trys,t=t.length>0&&t[t.length-1])&&(op[0]===6||op[0]===2)){_=0;continue;}if(op[0]===3&&(!t||op[1]>t[0]&&op[1]<t[3])){_.label=op[1];break;}if(op[0]===6&&_.label<t[1]){_.label=t[1];t=op;break;}if(t&&_.label<t[2]){_.label=t[2];_.ops.push(op);break;}if(t[2])_.ops.pop();_.trys.pop();continue;}op=body.call(thisArg,_);}catch(e){op=[6,e];y=0;}finally{f=t=0;}}if(op[0]&5)throw op[1];return{value:op[0]?op[1]:void 0,done:true};}};Object.defineProperty(exports,\"__esModule\",{value:true});var logger=new lib.Logger(_version$I.version);var CloudflareProvider=/** @class */function(_super){__extends(CloudflareProvider,_super);function CloudflareProvider(){return _super!==null&&_super.apply(this,arguments)||this;}CloudflareProvider.getApiKey=function(apiKey){if(apiKey!=null){logger.throwArgumentError(\"apiKey not supported for cloudflare\",\"apiKey\",apiKey);}return null;};CloudflareProvider.getUrl=function(network,apiKey){var host=null;switch(network.name){case\"homestead\":host=\"https://cloudflare-eth.com/\";break;default:logger.throwArgumentError(\"unsupported network\",\"network\",arguments[0]);}return host;};CloudflareProvider.prototype.perform=function(method,params){return __awaiter(this,void 0,void 0,function(){var block;return __generator(this,function(_a){switch(_a.label){case 0:if(!(method===\"getBlockNumber\"))return[3/*break*/,2];return[4/*yield*/,_super.prototype.perform.call(this,\"getBlock\",{blockTag:\"latest\"})];case 1:block=_a.sent();return[2/*return*/,block.number];case 2:return[2/*return*/,_super.prototype.perform.call(this,method,params)];}});});};return CloudflareProvider;}(urlJsonRpcProvider.UrlJsonRpcProvider);exports.CloudflareProvider=CloudflareProvider;});var cloudflareProvider$1=unwrapExports(cloudflareProvider);var cloudflareProvider_1=cloudflareProvider.CloudflareProvider;var etherscanProvider=createCommonjsModule(function(module,exports){\"use strict\";var __extends=commonjsGlobal&&commonjsGlobal.__extends||function(){var _extendStatics26=function extendStatics(d,b){_extendStatics26=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return _extendStatics26(d,b);};return function(d,b){_extendStatics26(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();var __awaiter=commonjsGlobal&&commonjsGlobal.__awaiter||function(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P(function(resolve){resolve(value);});}return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value));}catch(e){reject(e);}}function rejected(value){try{step(generator[\"throw\"](value));}catch(e){reject(e);}}function step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected);}step((generator=generator.apply(thisArg,_arguments||[])).next());});};var __generator=commonjsGlobal&&commonjsGlobal.__generator||function(thisArg,body){var _={label:0,sent:function sent(){if(t[0]&1)throw t[1];return t[1];},trys:[],ops:[]},f,y,t,g;return g={next:verb(0),\"throw\":verb(1),\"return\":verb(2)},typeof Symbol===\"function\"&&(g[Symbol.iterator]=function(){return this;}),g;function verb(n){return function(v){return step([n,v]);};}function step(op){if(f)throw new TypeError(\"Generator is already executing.\");while(_){try{if(f=1,y&&(t=op[0]&2?y[\"return\"]:op[0]?y[\"throw\"]||((t=y[\"return\"])&&t.call(y),0):y.next)&&!(t=t.call(y,op[1])).done)return t;if(y=0,t)op=[op[0]&2,t.value];switch(op[0]){case 0:case 1:t=op;break;case 4:_.label++;return{value:op[1],done:false};case 5:_.label++;y=op[1];op=[0];continue;case 7:op=_.ops.pop();_.trys.pop();continue;default:if(!(t=_.trys,t=t.length>0&&t[t.length-1])&&(op[0]===6||op[0]===2)){_=0;continue;}if(op[0]===3&&(!t||op[1]>t[0]&&op[1]<t[3])){_.label=op[1];break;}if(op[0]===6&&_.label<t[1]){_.label=t[1];t=op;break;}if(t&&_.label<t[2]){_.label=t[2];_.ops.push(op);break;}if(t[2])_.ops.pop();_.trys.pop();continue;}op=body.call(thisArg,_);}catch(e){op=[6,e];y=0;}finally{f=t=0;}}if(op[0]&5)throw op[1];return{value:op[0]?op[1]:void 0,done:true};}};Object.defineProperty(exports,\"__esModule\",{value:true});var logger=new lib.Logger(_version$I.version);// The transaction has already been sanitized by the calls in Provider\nfunction getTransactionString(transaction){var result=[];for(var key in transaction){if(transaction[key]==null){continue;}var value=lib$1.hexlify(transaction[key]);if({gasLimit:true,gasPrice:true,nonce:true,value:true}[key]){value=lib$1.hexValue(value);}result.push(key+\"=\"+value);}return result.join(\"&\");}function getResult(result){// getLogs, getHistory have weird success responses\nif(result.status==0&&(result.message===\"No records found\"||result.message===\"No transactions found\")){return result.result;}if(result.status!=1||result.message!=\"OK\"){var error=new Error(\"invalid response\");error.result=JSON.stringify(result);if((result.result||\"\").toLowerCase().indexOf(\"rate limit\")>=0){error.throttleRetry=true;}throw error;}return result.result;}function getJsonResult(result){// This response indicates we are being throttled\nif(result&&result.status==0&&result.message==\"NOTOK\"&&(result.result||\"\").toLowerCase().indexOf(\"rate limit\")>=0){var error=new Error(\"throttled response\");error.result=JSON.stringify(result);error.throttleRetry=true;throw error;}if(result.jsonrpc!=\"2.0\"){// @TODO: not any\nvar error=new Error(\"invalid response\");error.result=JSON.stringify(result);throw error;}if(result.error){// @TODO: not any\nvar error=new Error(result.error.message||\"unknown error\");if(result.error.code){error.code=result.error.code;}if(result.error.data){error.data=result.error.data;}throw error;}return result.result;}// The blockTag was normalized as a string by the Provider pre-perform operations\nfunction checkLogTag(blockTag){if(blockTag===\"pending\"){throw new Error(\"pending not supported\");}if(blockTag===\"latest\"){return blockTag;}return parseInt(blockTag.substring(2),16);}var defaultApiKey=\"9D13ZE7XSBTJ94N9BNJ2MA33VMAY2YPIRB\";var EtherscanProvider=/** @class */function(_super){__extends(EtherscanProvider,_super);function EtherscanProvider(network,apiKey){var _newTarget=this.constructor;var _this=this;logger.checkNew(_newTarget,EtherscanProvider);_this=_super.call(this,network)||this;var name=\"invalid\";if(_this.network){name=_this.network.name;}var baseUrl=null;switch(name){case\"homestead\":baseUrl=\"https://api.etherscan.io\";break;case\"ropsten\":baseUrl=\"https://api-ropsten.etherscan.io\";break;case\"rinkeby\":baseUrl=\"https://api-rinkeby.etherscan.io\";break;case\"kovan\":baseUrl=\"https://api-kovan.etherscan.io\";break;case\"goerli\":baseUrl=\"https://api-goerli.etherscan.io\";break;default:throw new Error(\"unsupported network\");}lib$3.defineReadOnly(_this,\"baseUrl\",baseUrl);lib$3.defineReadOnly(_this,\"apiKey\",apiKey||defaultApiKey);return _this;}EtherscanProvider.prototype.detectNetwork=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(_a){return[2/*return*/,this.network];});});};EtherscanProvider.prototype.perform=function(method,params){return __awaiter(this,void 0,void 0,function(){var url,apiKey,get,_a,transaction,transaction,topic0,logs,txs,i,log,tx,_b;var _this=this;return __generator(this,function(_c){switch(_c.label){case 0:url=this.baseUrl;apiKey=\"\";if(this.apiKey){apiKey+=\"&apikey=\"+this.apiKey;}get=function get(url,procFunc){return __awaiter(_this,void 0,void 0,function(){var connection,result;var _this=this;return __generator(this,function(_a){switch(_a.label){case 0:this.emit(\"debug\",{action:\"request\",request:url,provider:this});connection={url:url,throttleSlotInterval:1000,throttleCallback:function throttleCallback(attempt,url){if(_this.apiKey===defaultApiKey){formatter.showThrottleMessage();}return Promise.resolve(true);}};return[4/*yield*/,lib$l.fetchJson(connection,null,procFunc||getJsonResult)];case 1:result=_a.sent();this.emit(\"debug\",{action:\"response\",request:url,response:lib$3.deepCopy(result),provider:this});return[2/*return*/,result];}});});};_a=method;switch(_a){case\"getBlockNumber\":return[3/*break*/,1];case\"getGasPrice\":return[3/*break*/,2];case\"getBalance\":return[3/*break*/,3];case\"getTransactionCount\":return[3/*break*/,4];case\"getCode\":return[3/*break*/,5];case\"getStorageAt\":return[3/*break*/,6];case\"sendTransaction\":return[3/*break*/,7];case\"getBlock\":return[3/*break*/,8];case\"getTransaction\":return[3/*break*/,9];case\"getTransactionReceipt\":return[3/*break*/,10];case\"call\":return[3/*break*/,11];case\"estimateGas\":return[3/*break*/,12];case\"getLogs\":return[3/*break*/,13];case\"getEtherPrice\":return[3/*break*/,20];}return[3/*break*/,22];case 1:url+=\"/api?module=proxy&action=eth_blockNumber\"+apiKey;return[2/*return*/,get(url)];case 2:url+=\"/api?module=proxy&action=eth_gasPrice\"+apiKey;return[2/*return*/,get(url)];case 3:// Returns base-10 result\nurl+=\"/api?module=account&action=balance&address=\"+params.address;url+=\"&tag=\"+params.blockTag+apiKey;return[2/*return*/,get(url,getResult)];case 4:url+=\"/api?module=proxy&action=eth_getTransactionCount&address=\"+params.address;url+=\"&tag=\"+params.blockTag+apiKey;return[2/*return*/,get(url)];case 5:url+=\"/api?module=proxy&action=eth_getCode&address=\"+params.address;url+=\"&tag=\"+params.blockTag+apiKey;return[2/*return*/,get(url)];case 6:url+=\"/api?module=proxy&action=eth_getStorageAt&address=\"+params.address;url+=\"&position=\"+params.position;url+=\"&tag=\"+params.blockTag+apiKey;return[2/*return*/,get(url)];case 7:url+=\"/api?module=proxy&action=eth_sendRawTransaction&hex=\"+params.signedTransaction;url+=apiKey;return[2/*return*/,get(url).catch(function(error){if(error.responseText){// \"Insufficient funds. The account you tried to send transaction from does not have enough funds. Required 21464000000000 and got: 0\"\nif(error.responseText.toLowerCase().indexOf(\"insufficient funds\")>=0){logger.throwError(\"insufficient funds\",lib.Logger.errors.INSUFFICIENT_FUNDS,{});}// \"Transaction with the same hash was already imported.\"\nif(error.responseText.indexOf(\"same hash was already imported\")>=0){logger.throwError(\"nonce has already been used\",lib.Logger.errors.NONCE_EXPIRED,{});}// \"Transaction gas price is too low. There is another transaction with same nonce in the queue. Try increasing the gas price or incrementing the nonce.\"\nif(error.responseText.indexOf(\"another transaction with same nonce\")>=0){logger.throwError(\"replacement fee too low\",lib.Logger.errors.REPLACEMENT_UNDERPRICED,{});}}throw error;})];case 8:if(params.blockTag){url+=\"/api?module=proxy&action=eth_getBlockByNumber&tag=\"+params.blockTag;if(params.includeTransactions){url+=\"&boolean=true\";}else{url+=\"&boolean=false\";}url+=apiKey;return[2/*return*/,get(url)];}throw new Error(\"getBlock by blockHash not implemented\");case 9:url+=\"/api?module=proxy&action=eth_getTransactionByHash&txhash=\"+params.transactionHash;url+=apiKey;return[2/*return*/,get(url)];case 10:url+=\"/api?module=proxy&action=eth_getTransactionReceipt&txhash=\"+params.transactionHash;url+=apiKey;return[2/*return*/,get(url)];case 11:{transaction=getTransactionString(params.transaction);if(transaction){transaction=\"&\"+transaction;}url+=\"/api?module=proxy&action=eth_call\"+transaction;//url += \"&tag=\" + params.blockTag + apiKey;\nif(params.blockTag!==\"latest\"){throw new Error(\"EtherscanProvider does not support blockTag for call\");}url+=apiKey;return[2/*return*/,get(url)];}_c.label=12;case 12:{transaction=getTransactionString(params.transaction);if(transaction){transaction=\"&\"+transaction;}url+=\"/api?module=proxy&action=eth_estimateGas&\"+transaction;url+=apiKey;return[2/*return*/,get(url)];}_c.label=13;case 13:url+=\"/api?module=logs&action=getLogs\";if(params.filter.fromBlock){url+=\"&fromBlock=\"+checkLogTag(params.filter.fromBlock);}if(params.filter.toBlock){url+=\"&toBlock=\"+checkLogTag(params.filter.toBlock);}if(params.filter.address){url+=\"&address=\"+params.filter.address;}// @TODO: We can handle slightly more complicated logs using the logs API\nif(params.filter.topics&&params.filter.topics.length>0){if(params.filter.topics.length>1){logger.throwError(\"unsupported topic count\",lib.Logger.errors.UNSUPPORTED_OPERATION,{topics:params.filter.topics});}if(params.filter.topics.length===1){topic0=params.filter.topics[0];if(typeof topic0!==\"string\"||topic0.length!==66){logger.throwError(\"unsupported topic format\",lib.Logger.errors.UNSUPPORTED_OPERATION,{topic0:topic0});}url+=\"&topic0=\"+topic0;}}url+=apiKey;return[4/*yield*/,get(url,getResult)];case 14:logs=_c.sent();txs={};i=0;_c.label=15;case 15:if(!(i<logs.length))return[3/*break*/,19];log=logs[i];if(log.blockHash!=null){return[3/*break*/,18];}if(!(txs[log.transactionHash]==null))return[3/*break*/,17];return[4/*yield*/,this.getTransaction(log.transactionHash)];case 16:tx=_c.sent();if(tx){txs[log.transactionHash]=tx.blockHash;}_c.label=17;case 17:log.blockHash=txs[log.transactionHash];_c.label=18;case 18:i++;return[3/*break*/,15];case 19:return[2/*return*/,logs];case 20:if(this.network.name!==\"homestead\"){return[2/*return*/,0.0];}url+=\"/api?module=stats&action=ethprice\";url+=apiKey;_b=parseFloat;return[4/*yield*/,get(url,getResult)];case 21:return[2/*return*/,_b.apply(void 0,[_c.sent().ethusd])];case 22:return[3/*break*/,23];case 23:return[2/*return*/,_super.prototype.perform.call(this,method,params)];}});});};// @TODO: Allow startBlock and endBlock to be Promises\nEtherscanProvider.prototype.getHistory=function(addressOrName,startBlock,endBlock){var _this=this;var url=this.baseUrl;var apiKey=\"\";if(this.apiKey){apiKey+=\"&apikey=\"+this.apiKey;}if(startBlock==null){startBlock=0;}if(endBlock==null){endBlock=99999999;}return this.resolveName(addressOrName).then(function(address){url+=\"/api?module=account&action=txlist&address=\"+address;url+=\"&startblock=\"+startBlock;url+=\"&endblock=\"+endBlock;url+=\"&sort=asc\"+apiKey;_this.emit(\"debug\",{action:\"request\",request:url,provider:_this});var connection={url:url,throttleSlotInterval:1000,throttleCallback:function throttleCallback(attempt,url){if(_this.apiKey===defaultApiKey){formatter.showThrottleMessage();}return Promise.resolve(true);}};return lib$l.fetchJson(connection,null,getResult).then(function(result){_this.emit(\"debug\",{action:\"response\",request:url,response:lib$3.deepCopy(result),provider:_this});var output=[];result.forEach(function(tx){[\"contractAddress\",\"to\"].forEach(function(key){if(tx[key]==\"\"){delete tx[key];}});if(tx.creates==null&&tx.contractAddress!=null){tx.creates=tx.contractAddress;}var item=_this.formatter.transactionResponse(tx);if(tx.timeStamp){item.timestamp=parseInt(tx.timeStamp);}output.push(item);});return output;});});};return EtherscanProvider;}(baseProvider.BaseProvider);exports.EtherscanProvider=EtherscanProvider;});var etherscanProvider$1=unwrapExports(etherscanProvider);var etherscanProvider_1=etherscanProvider.EtherscanProvider;var fallbackProvider=createCommonjsModule(function(module,exports){\"use strict\";var __extends=commonjsGlobal&&commonjsGlobal.__extends||function(){var _extendStatics27=function extendStatics(d,b){_extendStatics27=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return _extendStatics27(d,b);};return function(d,b){_extendStatics27(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();var __awaiter=commonjsGlobal&&commonjsGlobal.__awaiter||function(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P(function(resolve){resolve(value);});}return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value));}catch(e){reject(e);}}function rejected(value){try{step(generator[\"throw\"](value));}catch(e){reject(e);}}function step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected);}step((generator=generator.apply(thisArg,_arguments||[])).next());});};var __generator=commonjsGlobal&&commonjsGlobal.__generator||function(thisArg,body){var _={label:0,sent:function sent(){if(t[0]&1)throw t[1];return t[1];},trys:[],ops:[]},f,y,t,g;return g={next:verb(0),\"throw\":verb(1),\"return\":verb(2)},typeof Symbol===\"function\"&&(g[Symbol.iterator]=function(){return this;}),g;function verb(n){return function(v){return step([n,v]);};}function step(op){if(f)throw new TypeError(\"Generator is already executing.\");while(_){try{if(f=1,y&&(t=op[0]&2?y[\"return\"]:op[0]?y[\"throw\"]||((t=y[\"return\"])&&t.call(y),0):y.next)&&!(t=t.call(y,op[1])).done)return t;if(y=0,t)op=[op[0]&2,t.value];switch(op[0]){case 0:case 1:t=op;break;case 4:_.label++;return{value:op[1],done:false};case 5:_.label++;y=op[1];op=[0];continue;case 7:op=_.ops.pop();_.trys.pop();continue;default:if(!(t=_.trys,t=t.length>0&&t[t.length-1])&&(op[0]===6||op[0]===2)){_=0;continue;}if(op[0]===3&&(!t||op[1]>t[0]&&op[1]<t[3])){_.label=op[1];break;}if(op[0]===6&&_.label<t[1]){_.label=t[1];t=op;break;}if(t&&_.label<t[2]){_.label=t[2];_.ops.push(op);break;}if(t[2])_.ops.pop();_.trys.pop();continue;}op=body.call(thisArg,_);}catch(e){op=[6,e];y=0;}finally{f=t=0;}}if(op[0]&5)throw op[1];return{value:op[0]?op[1]:void 0,done:true};}};Object.defineProperty(exports,\"__esModule\",{value:true});var logger=new lib.Logger(_version$I.version);function now(){return new Date().getTime();}// Returns to network as long as all agree, or null if any is null.\n// Throws an error if any two networks do not match.\nfunction checkNetworks(networks){var result=null;for(var i=0;i<networks.length;i++){var network=networks[i];// Null! We do not know our network; bail.\nif(network==null){return null;}if(result){// Make sure the network matches the previous networks\nif(!(result.name===network.name&&result.chainId===network.chainId&&(result.ensAddress===network.ensAddress||result.ensAddress==null&&network.ensAddress==null))){logger.throwArgumentError(\"provider mismatch\",\"networks\",networks);}}else{result=network;}}return result;}function median(values,maxDelta){values=values.slice().sort();var middle=Math.floor(values.length/2);// Odd length; take the middle\nif(values.length%2){return values[middle];}// Even length; take the average of the two middle\nvar a=values[middle-1],b=values[middle];if(maxDelta!=null&&Math.abs(a-b)>maxDelta){return null;}return(a+b)/2;}function serialize(value){if(value===null){return\"null\";}else if(typeof value===\"number\"||typeof value===\"boolean\"){return JSON.stringify(value);}else if(typeof value===\"string\"){return value;}else if(lib$2.BigNumber.isBigNumber(value)){return value.toString();}else if(Array.isArray(value)){return JSON.stringify(value.map(function(i){return serialize(i);}));}else if(_typeof(value)===\"object\"){var keys=Object.keys(value);keys.sort();return\"{\"+keys.map(function(key){var v=value[key];if(typeof v===\"function\"){v=\"[function]\";}else{v=serialize(v);}return JSON.stringify(key)+\":\"+v;}).join(\",\")+\"}\";}throw new Error(\"unknown value type: \"+_typeof(value));}// Next request ID to use for emitting debug info\nvar nextRid=1;;function stall(duration){var cancel=null;var timer=null;var promise=new Promise(function(resolve){cancel=function cancel(){if(timer){clearTimeout(timer);timer=null;}resolve();};timer=setTimeout(cancel,duration);});var wait=function wait(func){promise=promise.then(func);return promise;};function getPromise(){return promise;}return{cancel:cancel,getPromise:getPromise,wait:wait};};function exposeDebugConfig(config,now){var result={provider:config.provider,weight:config.weight};if(config.start){result.start=config.start;}if(now){result.duration=now-config.start;}if(config.done){if(config.error){result.error=config.error;}else{result.result=config.result||null;}}return result;}function normalizedTally(normalize,quorum){return function(configs){// Count the votes for each result\nvar tally={};configs.forEach(function(c){var value=normalize(c.result);if(!tally[value]){tally[value]={count:0,result:c.result};}tally[value].count++;});// Check for a quorum on any given result\nvar keys=Object.keys(tally);for(var i=0;i<keys.length;i++){var check=tally[keys[i]];if(check.count>=quorum){return check.result;}}// No quroum\nreturn undefined;};}function getProcessFunc(provider,method,params){var normalize=serialize;switch(method){case\"getBlockNumber\":// Return the median value, unless there is (median + 1) is also\n// present, in which case that is probably true and the median\n// is going to be stale soon. In the event of a malicious node,\n// the lie will be true soon enough.\nreturn function(configs){var values=configs.map(function(c){return c.result;});// Get the median block number\nvar blockNumber=median(configs.map(function(c){return c.result;}),2);if(blockNumber==null){return undefined;}blockNumber=Math.ceil(blockNumber);// If the next block height is present, its prolly safe to use\nif(values.indexOf(blockNumber+1)>=0){blockNumber++;}// Don't ever roll back the blockNumber\nif(blockNumber>=provider._highestBlockNumber){provider._highestBlockNumber=blockNumber;}return provider._highestBlockNumber;};case\"getGasPrice\":// Return the middle (round index up) value, similar to median\n// but do not average even entries and choose the higher.\n// Malicious actors must compromise 50% of the nodes to lie.\nreturn function(configs){var values=configs.map(function(c){return c.result;});values.sort();return values[Math.floor(values.length/2)];};case\"getEtherPrice\":// Returns the median price. Malicious actors must compromise at\n// least 50% of the nodes to lie (in a meaningful way).\nreturn function(configs){return median(configs.map(function(c){return c.result;}));};// No additional normalizing required; serialize is enough\ncase\"getBalance\":case\"getTransactionCount\":case\"getCode\":case\"getStorageAt\":case\"call\":case\"estimateGas\":case\"getLogs\":break;// We drop the confirmations from transactions as it is approximate\ncase\"getTransaction\":case\"getTransactionReceipt\":normalize=function normalize(tx){if(tx==null){return null;}tx=lib$3.shallowCopy(tx);tx.confirmations=-1;return serialize(tx);};break;// We drop the confirmations from transactions as it is approximate\ncase\"getBlock\":// We drop the confirmations from transactions as it is approximate\nif(params.includeTransactions){normalize=function normalize(block){if(block==null){return null;}block=lib$3.shallowCopy(block);block.transactions=block.transactions.map(function(tx){tx=lib$3.shallowCopy(tx);tx.confirmations=-1;return tx;});return serialize(block);};}else{normalize=function normalize(block){if(block==null){return null;}return serialize(block);};}break;default:throw new Error(\"unknown method: \"+method);}// Return the result if and only if the expected quorum is\n// satisfied and agreed upon for the final result.\nreturn normalizedTally(normalize,provider.quorum);}// If we are doing a blockTag query, we need to make sure the backend is\n// caught up to the FallbackProvider, before sending a request to it.\nfunction waitForSync(config,blockNumber){return __awaiter(this,void 0,void 0,function(){var provider;return __generator(this,function(_a){provider=config.provider;if(provider.blockNumber!=null&&provider.blockNumber>=blockNumber||blockNumber===-1){return[2/*return*/,provider];}return[2/*return*/,lib$l.poll(function(){return new Promise(function(resolve,reject){setTimeout(function(){// We are synced\nif(provider.blockNumber>=blockNumber){return resolve(provider);}// We're done; just quit\nif(config.cancelled){return resolve(null);}// Try again, next block\nreturn resolve(undefined);},0);});},{oncePoll:provider})];});});}function getRunner(config,currentBlockNumber,method,params){return __awaiter(this,void 0,void 0,function(){var provider,_a,filter;return __generator(this,function(_b){switch(_b.label){case 0:provider=config.provider;_a=method;switch(_a){case\"getBlockNumber\":return[3/*break*/,1];case\"getGasPrice\":return[3/*break*/,1];case\"getEtherPrice\":return[3/*break*/,2];case\"getBalance\":return[3/*break*/,3];case\"getTransactionCount\":return[3/*break*/,3];case\"getCode\":return[3/*break*/,3];case\"getStorageAt\":return[3/*break*/,6];case\"getBlock\":return[3/*break*/,9];case\"call\":return[3/*break*/,12];case\"estimateGas\":return[3/*break*/,12];case\"getTransaction\":return[3/*break*/,15];case\"getTransactionReceipt\":return[3/*break*/,15];case\"getLogs\":return[3/*break*/,16];}return[3/*break*/,19];case 1:return[2/*return*/,provider[method]()];case 2:if(provider.getEtherPrice){return[2/*return*/,provider.getEtherPrice()];}return[3/*break*/,19];case 3:if(!(params.blockTag&&lib$1.isHexString(params.blockTag)))return[3/*break*/,5];return[4/*yield*/,waitForSync(config,currentBlockNumber)];case 4:provider=_b.sent();_b.label=5;case 5:return[2/*return*/,provider[method](params.address,params.blockTag||\"latest\")];case 6:if(!(params.blockTag&&lib$1.isHexString(params.blockTag)))return[3/*break*/,8];return[4/*yield*/,waitForSync(config,currentBlockNumber)];case 7:provider=_b.sent();_b.label=8;case 8:return[2/*return*/,provider.getStorageAt(params.address,params.position,params.blockTag||\"latest\")];case 9:if(!(params.blockTag&&lib$1.isHexString(params.blockTag)))return[3/*break*/,11];return[4/*yield*/,waitForSync(config,currentBlockNumber)];case 10:provider=_b.sent();_b.label=11;case 11:return[2/*return*/,provider[params.includeTransactions?\"getBlockWithTransactions\":\"getBlock\"](params.blockTag||params.blockHash)];case 12:if(!(params.blockTag&&lib$1.isHexString(params.blockTag)))return[3/*break*/,14];return[4/*yield*/,waitForSync(config,currentBlockNumber)];case 13:provider=_b.sent();_b.label=14;case 14:return[2/*return*/,provider[method](params.transaction)];case 15:return[2/*return*/,provider[method](params.transactionHash)];case 16:filter=params.filter;if(!(filter.fromBlock&&lib$1.isHexString(filter.fromBlock)||filter.toBlock&&lib$1.isHexString(filter.toBlock)))return[3/*break*/,18];return[4/*yield*/,waitForSync(config,currentBlockNumber)];case 17:provider=_b.sent();_b.label=18;case 18:return[2/*return*/,provider.getLogs(filter)];case 19:return[2/*return*/,logger.throwError(\"unknown method error\",lib.Logger.errors.UNKNOWN_ERROR,{method:method,params:params})];}});});}var FallbackProvider=/** @class */function(_super){__extends(FallbackProvider,_super);function FallbackProvider(providers,quorum){var _newTarget=this.constructor;var _this=this;logger.checkNew(_newTarget,FallbackProvider);if(providers.length===0){logger.throwArgumentError(\"missing providers\",\"providers\",providers);}var providerConfigs=providers.map(function(configOrProvider,index){if(lib$b.Provider.isProvider(configOrProvider)){return Object.freeze({provider:configOrProvider,weight:1,stallTimeout:750,priority:1});}var config=lib$3.shallowCopy(configOrProvider);if(config.priority==null){config.priority=1;}if(config.stallTimeout==null){config.stallTimeout=750;}if(config.weight==null){config.weight=1;}var weight=config.weight;if(weight%1||weight>512||weight<1){logger.throwArgumentError(\"invalid weight; must be integer in [1, 512]\",\"providers[\"+index+\"].weight\",weight);}return Object.freeze(config);});var total=providerConfigs.reduce(function(accum,c){return accum+c.weight;},0);if(quorum==null){quorum=total/2;}else if(quorum>total){logger.throwArgumentError(\"quorum will always fail; larger than total weight\",\"quorum\",quorum);}// Are all providers' networks are known\nvar networkOrReady=checkNetworks(providerConfigs.map(function(c){return c.provider.network;}));// Not all networks are known; we must stall\nif(networkOrReady==null){networkOrReady=new Promise(function(resolve,reject){setTimeout(function(){_this.detectNetwork().then(resolve,reject);},0);});}_this=_super.call(this,networkOrReady)||this;// Preserve a copy, so we do not get mutated\nlib$3.defineReadOnly(_this,\"providerConfigs\",Object.freeze(providerConfigs));lib$3.defineReadOnly(_this,\"quorum\",quorum);_this._highestBlockNumber=-1;return _this;}FallbackProvider.prototype.detectNetwork=function(){return __awaiter(this,void 0,void 0,function(){var networks;return __generator(this,function(_a){switch(_a.label){case 0:return[4/*yield*/,Promise.all(this.providerConfigs.map(function(c){return c.provider.getNetwork();}))];case 1:networks=_a.sent();return[2/*return*/,checkNetworks(networks)];}});});};FallbackProvider.prototype.perform=function(method,params){return __awaiter(this,void 0,void 0,function(){var results,i_1,result,processFunc,configs,currentBlockNumber,i,first,_loop_1,this_1,state_1;var _this=this;return __generator(this,function(_a){switch(_a.label){case 0:if(!(method===\"sendTransaction\"))return[3/*break*/,2];return[4/*yield*/,Promise.all(this.providerConfigs.map(function(c){return c.provider.sendTransaction(params.signedTransaction).then(function(result){return result.hash;},function(error){return error;});}))];case 1:results=_a.sent();// Any success is good enough (other errors are likely \"already seen\" errors\nfor(i_1=0;i_1<results.length;i_1++){result=results[i_1];if(typeof result===\"string\"){return[2/*return*/,result];}}// They were all an error; pick the first error\nthrow results[0];case 2:if(!(this._highestBlockNumber===-1&&method!==\"getBlockNumber\"))return[3/*break*/,4];return[4/*yield*/,this.getBlockNumber()];case 3:_a.sent();_a.label=4;case 4:processFunc=getProcessFunc(this,method,params);configs=browser$6.shuffled(this.providerConfigs.map(lib$3.shallowCopy));configs.sort(function(a,b){return a.priority-b.priority;});currentBlockNumber=this._highestBlockNumber;i=0;first=true;_loop_1=function _loop_1(){var t0,inflightWeight,_loop_2,waiting,results,result;return __generator(this,function(_a){switch(_a.label){case 0:t0=now();inflightWeight=configs.filter(function(c){return c.runner&&t0-c.start<c.stallTimeout;}).reduce(function(accum,c){return accum+c.weight;},0);_loop_2=function _loop_2(){var config=configs[i++];var rid=nextRid++;config.start=now();config.staller=stall(config.stallTimeout);config.staller.wait(function(){config.staller=null;});config.runner=getRunner(config,currentBlockNumber,method,params).then(function(result){config.done=true;config.result=result;if(_this.listenerCount(\"debug\")){_this.emit(\"debug\",{action:\"request\",rid:rid,backend:exposeDebugConfig(config,now()),request:{method:method,params:lib$3.deepCopy(params)},provider:_this});}},function(error){config.done=true;config.error=error;if(_this.listenerCount(\"debug\")){_this.emit(\"debug\",{action:\"request\",rid:rid,backend:exposeDebugConfig(config,now()),request:{method:method,params:lib$3.deepCopy(params)},provider:_this});}});if(this_1.listenerCount(\"debug\")){this_1.emit(\"debug\",{action:\"request\",rid:rid,backend:exposeDebugConfig(config,null),request:{method:method,params:lib$3.deepCopy(params)},provider:this_1});}inflightWeight+=config.weight;};// Start running enough to meet quorum\nwhile(inflightWeight<this_1.quorum&&i<configs.length){_loop_2();}waiting=[];configs.forEach(function(c){if(c.done||!c.runner){return;}waiting.push(c.runner);if(c.staller){waiting.push(c.staller.getPromise());}});if(!waiting.length)return[3/*break*/,2];return[4/*yield*/,Promise.race(waiting)];case 1:_a.sent();_a.label=2;case 2:results=configs.filter(function(c){return c.done&&c.error==null;});if(!(results.length>=this_1.quorum))return[3/*break*/,5];result=processFunc(results);if(result!==undefined){// Shut down any stallers\nconfigs.forEach(function(c){if(c.staller){c.staller.cancel();}c.cancelled=true;});return[2/*return*/,{value:result}];}if(!!first)return[3/*break*/,4];return[4/*yield*/,stall(100).getPromise()];case 3:_a.sent();_a.label=4;case 4:first=false;_a.label=5;case 5:// All configs have run to completion; we will never get more data\nif(configs.filter(function(c){return!c.done;}).length===0){return[2/*return*/,\"break\"];}return[2/*return*/];}});};this_1=this;_a.label=5;case 5:if(false){}return[5/*yield**/,_loop_1()];case 6:state_1=_a.sent();if(_typeof(state_1)===\"object\")return[2/*return*/,state_1.value];if(state_1===\"break\")return[3/*break*/,7];return[3/*break*/,5];case 7:// Shut down any stallers; shouldn't be any\nconfigs.forEach(function(c){if(c.staller){c.staller.cancel();}c.cancelled=true;});return[2/*return*/,logger.throwError(\"failed to meet quorum\",lib.Logger.errors.SERVER_ERROR,{method:method,params:params,//results: configs.map((c) => c.result),\n//errors: configs.map((c) => c.error),\nresults:configs.map(function(c){return exposeDebugConfig(c);}),provider:this})];}});});};return FallbackProvider;}(baseProvider.BaseProvider);exports.FallbackProvider=FallbackProvider;});var fallbackProvider$1=unwrapExports(fallbackProvider);var fallbackProvider_1=fallbackProvider.FallbackProvider;\"use strict\";var IpcProvider=null;var browserIpcProvider={IpcProvider:IpcProvider};var infuraProvider=createCommonjsModule(function(module,exports){\"use strict\";var __extends=commonjsGlobal&&commonjsGlobal.__extends||function(){var _extendStatics28=function extendStatics(d,b){_extendStatics28=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return _extendStatics28(d,b);};return function(d,b){_extendStatics28(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,\"__esModule\",{value:true});var logger=new lib.Logger(_version$I.version);var defaultProjectId=\"84842078b09946638c03157f83405213\";var InfuraProvider=/** @class */function(_super){__extends(InfuraProvider,_super);function InfuraProvider(){return _super!==null&&_super.apply(this,arguments)||this;}InfuraProvider.getWebSocketProvider=function(network,apiKey){var provider=new InfuraProvider(network,apiKey);var connection=provider.connection;if(connection.password){logger.throwError(\"INFURA WebSocket project secrets unsupported\",lib.Logger.errors.UNSUPPORTED_OPERATION,{operation:\"InfuraProvider.getWebSocketProvider()\"});}var url=connection.url.replace(/^http/i,\"ws\").replace(\"/v3/\",\"/ws/v3/\");return new websocketProvider.WebSocketProvider(url,network);};InfuraProvider.getApiKey=function(apiKey){var apiKeyObj={apiKey:defaultProjectId,projectId:defaultProjectId,projectSecret:null};if(apiKey==null){return apiKeyObj;}if(typeof apiKey===\"string\"){apiKeyObj.projectId=apiKey;}else if(apiKey.projectSecret!=null){logger.assertArgument(typeof apiKey.projectId===\"string\",\"projectSecret requires a projectId\",\"projectId\",apiKey.projectId);logger.assertArgument(typeof apiKey.projectSecret===\"string\",\"invalid projectSecret\",\"projectSecret\",\"[REDACTED]\");apiKeyObj.projectId=apiKey.projectId;apiKeyObj.projectSecret=apiKey.projectSecret;}else if(apiKey.projectId){apiKeyObj.projectId=apiKey.projectId;}apiKeyObj.apiKey=apiKeyObj.projectId;return apiKeyObj;};InfuraProvider.getUrl=function(network,apiKey){var host=null;switch(network?network.name:\"unknown\"){case\"homestead\":host=\"mainnet.infura.io\";break;case\"ropsten\":host=\"ropsten.infura.io\";break;case\"rinkeby\":host=\"rinkeby.infura.io\";break;case\"kovan\":host=\"kovan.infura.io\";break;case\"goerli\":host=\"goerli.infura.io\";break;default:logger.throwError(\"unsupported network\",lib.Logger.errors.INVALID_ARGUMENT,{argument:\"network\",value:network});}var connection={url:\"https:/\"+\"/\"+host+\"/v3/\"+apiKey.projectId,throttleCallback:function throttleCallback(attempt,url){if(apiKey.projectId===defaultProjectId){formatter.showThrottleMessage();}return Promise.resolve(true);}};if(apiKey.projectSecret!=null){connection.user=\"\";connection.password=apiKey.projectSecret;}return connection;};return InfuraProvider;}(urlJsonRpcProvider.UrlJsonRpcProvider);exports.InfuraProvider=InfuraProvider;});var infuraProvider$1=unwrapExports(infuraProvider);var infuraProvider_1=infuraProvider.InfuraProvider;var nodesmithProvider=createCommonjsModule(function(module,exports){/* istanbul ignore file */\"use strict\";var __extends=commonjsGlobal&&commonjsGlobal.__extends||function(){var _extendStatics29=function extendStatics(d,b){_extendStatics29=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return _extendStatics29(d,b);};return function(d,b){_extendStatics29(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,\"__esModule\",{value:true});var logger=new lib.Logger(_version$I.version);// Special API key provided by Nodesmith for ethers.js\nvar defaultApiKey=\"ETHERS_JS_SHARED\";var NodesmithProvider=/** @class */function(_super){__extends(NodesmithProvider,_super);function NodesmithProvider(){return _super!==null&&_super.apply(this,arguments)||this;}NodesmithProvider.getApiKey=function(apiKey){if(apiKey&&typeof apiKey!==\"string\"){logger.throwArgumentError(\"invalid apiKey\",\"apiKey\",apiKey);}return apiKey||defaultApiKey;};NodesmithProvider.getUrl=function(network,apiKey){logger.warn(\"NodeSmith will be discontinued on 2019-12-20; please migrate to another platform.\");var host=null;switch(network.name){case\"homestead\":host=\"https://ethereum.api.nodesmith.io/v1/mainnet/jsonrpc\";break;case\"ropsten\":host=\"https://ethereum.api.nodesmith.io/v1/ropsten/jsonrpc\";break;case\"rinkeby\":host=\"https://ethereum.api.nodesmith.io/v1/rinkeby/jsonrpc\";break;case\"goerli\":host=\"https://ethereum.api.nodesmith.io/v1/goerli/jsonrpc\";break;case\"kovan\":host=\"https://ethereum.api.nodesmith.io/v1/kovan/jsonrpc\";break;default:logger.throwArgumentError(\"unsupported network\",\"network\",arguments[0]);}return host+\"?apiKey=\"+apiKey;};return NodesmithProvider;}(urlJsonRpcProvider.UrlJsonRpcProvider);exports.NodesmithProvider=NodesmithProvider;});var nodesmithProvider$1=unwrapExports(nodesmithProvider);var nodesmithProvider_1=nodesmithProvider.NodesmithProvider;var web3Provider=createCommonjsModule(function(module,exports){\"use strict\";var __extends=commonjsGlobal&&commonjsGlobal.__extends||function(){var _extendStatics30=function extendStatics(d,b){_extendStatics30=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p))d[p]=b[p];}};return _extendStatics30(d,b);};return function(d,b){_extendStatics30(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,\"__esModule\",{value:true});var logger=new lib.Logger(_version$I.version);var _nextId=1;function buildWeb3LegacyFetcher(provider,sendFunc){return function(method,params){// Metamask complains about eth_sign (and on some versions hangs)\nif(method==\"eth_sign\"&&provider.isMetaMask){// https://github.com/ethereum/go-ethereum/wiki/Management-APIs#personal_sign\nmethod=\"personal_sign\";params=[params[1],params[0]];}var request={method:method,params:params,id:_nextId++,jsonrpc:\"2.0\"};return new Promise(function(resolve,reject){sendFunc(request,function(error,result){if(error){return reject(error);}if(result.error){var error_1=new Error(result.error.message);error_1.code=result.error.code;error_1.data=result.error.data;return reject(error_1);}resolve(result.result);});});};}function buildEip1193Fetcher(provider){return function(method,params){if(params==null){params=[];}// Metamask complains about eth_sign (and on some versions hangs)\nif(method==\"eth_sign\"&&provider.isMetaMask){// https://github.com/ethereum/go-ethereum/wiki/Management-APIs#personal_sign\nmethod=\"personal_sign\";params=[params[1],params[0]];}return provider.request({method:method,params:params});};}var Web3Provider=/** @class */function(_super){__extends(Web3Provider,_super);function Web3Provider(provider,network){var _newTarget=this.constructor;var _this=this;logger.checkNew(_newTarget,Web3Provider);if(provider==null){logger.throwArgumentError(\"missing provider\",\"provider\",provider);}var path=null;var jsonRpcFetchFunc=null;var subprovider=null;if(typeof provider===\"function\"){path=\"unknown:\";jsonRpcFetchFunc=provider;}else{path=provider.host||provider.path||\"\";if(!path&&provider.isMetaMask){path=\"metamask\";}subprovider=provider;if(provider.request){if(path===\"\"){path=\"eip-1193:\";}jsonRpcFetchFunc=buildEip1193Fetcher(provider);}else if(provider.sendAsync){jsonRpcFetchFunc=buildWeb3LegacyFetcher(provider,provider.sendAsync.bind(provider));}else if(provider.send){jsonRpcFetchFunc=buildWeb3LegacyFetcher(provider,provider.send.bind(provider));}else{logger.throwArgumentError(\"unsupported provider\",\"provider\",provider);}if(!path){path=\"unknown:\";}}_this=_super.call(this,path,network)||this;lib$3.defineReadOnly(_this,\"jsonRpcFetchFunc\",jsonRpcFetchFunc);lib$3.defineReadOnly(_this,\"provider\",subprovider);return _this;}Web3Provider.prototype.send=function(method,params){return this.jsonRpcFetchFunc(method,params);};return Web3Provider;}(jsonRpcProvider.JsonRpcProvider);exports.Web3Provider=Web3Provider;});var web3Provider$1=unwrapExports(web3Provider);var web3Provider_1=web3Provider.Web3Provider;var lib$m=createCommonjsModule(function(module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});exports.Provider=lib$b.Provider;exports.getNetwork=lib$k.getNetwork;exports.BaseProvider=baseProvider.BaseProvider;exports.AlchemyProvider=alchemyProvider.AlchemyProvider;exports.CloudflareProvider=cloudflareProvider.CloudflareProvider;exports.EtherscanProvider=etherscanProvider.EtherscanProvider;exports.FallbackProvider=fallbackProvider.FallbackProvider;exports.IpcProvider=browserIpcProvider.IpcProvider;exports.InfuraProvider=infuraProvider.InfuraProvider;exports.JsonRpcProvider=jsonRpcProvider.JsonRpcProvider;exports.JsonRpcSigner=jsonRpcProvider.JsonRpcSigner;exports.NodesmithProvider=nodesmithProvider.NodesmithProvider;exports.StaticJsonRpcProvider=urlJsonRpcProvider.StaticJsonRpcProvider;exports.UrlJsonRpcProvider=urlJsonRpcProvider.UrlJsonRpcProvider;exports.Web3Provider=web3Provider.Web3Provider;exports.WebSocketProvider=websocketProvider.WebSocketProvider;exports.Formatter=formatter.Formatter;var logger=new lib.Logger(_version$I.version);////////////////////////\n// Helper Functions\nfunction getDefaultProvider(network,options){if(network==null){network=\"homestead\";}// If passed a URL, figure out the right type of provider based on the scheme\nif(typeof network===\"string\"){// @TODO: Add support for IpcProvider; maybe if it ends in \".ipc\"?\n// Handle http and ws (and their secure variants)\nvar match=network.match(/^(ws|http)s?:/i);if(match){switch(match[1]){case\"http\":return new jsonRpcProvider.JsonRpcProvider(network);case\"ws\":return new websocketProvider.WebSocketProvider(network);default:logger.throwArgumentError(\"unsupported URL scheme\",\"network\",network);}}}var n=lib$k.getNetwork(network);if(!n||!n._defaultProvider){logger.throwError(\"unsupported getDefaultProvider network\",lib.Logger.errors.NETWORK_ERROR,{operation:\"getDefaultProvider\",network:network});}return n._defaultProvider({FallbackProvider:fallbackProvider.FallbackProvider,AlchemyProvider:alchemyProvider.AlchemyProvider,CloudflareProvider:cloudflareProvider.CloudflareProvider,EtherscanProvider:etherscanProvider.EtherscanProvider,InfuraProvider:infuraProvider.InfuraProvider,JsonRpcProvider:jsonRpcProvider.JsonRpcProvider,NodesmithProvider:nodesmithProvider.NodesmithProvider,Web3Provider:web3Provider.Web3Provider,IpcProvider:browserIpcProvider.IpcProvider},options);}exports.getDefaultProvider=getDefaultProvider;});var index$m=unwrapExports(lib$m);var lib_1$m=lib$m.Provider;var lib_2$k=lib$m.getNetwork;var lib_3$g=lib$m.BaseProvider;var lib_4$c=lib$m.AlchemyProvider;var lib_5$b=lib$m.CloudflareProvider;var lib_6$7=lib$m.EtherscanProvider;var lib_7$6=lib$m.FallbackProvider;var lib_8$5=lib$m.IpcProvider;var lib_9$5=lib$m.InfuraProvider;var lib_10$3=lib$m.JsonRpcProvider;var lib_11$2=lib$m.JsonRpcSigner;var lib_12$2=lib$m.NodesmithProvider;var lib_13$2=lib$m.StaticJsonRpcProvider;var lib_14$1=lib$m.UrlJsonRpcProvider;var lib_15$1=lib$m.Web3Provider;var lib_16$1=lib$m.WebSocketProvider;var lib_17=lib$m.Formatter;var lib_18=lib$m.getDefaultProvider;var lib$n=createCommonjsModule(function(module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});var regexBytes=new RegExp(\"^bytes([0-9]+)$\");var regexNumber=new RegExp(\"^(u?int)([0-9]*)$\");var regexArray=new RegExp(\"^(.*)\\\\[([0-9]*)\\\\]$\");var Zeros=\"0000000000000000000000000000000000000000000000000000000000000000\";function _pack(type,value,isArray){switch(type){case\"address\":if(isArray){return lib$1.zeroPad(value,32);}return lib$1.arrayify(value);case\"string\":return lib$8.toUtf8Bytes(value);case\"bytes\":return lib$1.arrayify(value);case\"bool\":value=value?\"0x01\":\"0x00\";if(isArray){return lib$1.zeroPad(value,32);}return lib$1.arrayify(value);}var match=type.match(regexNumber);if(match){//let signed = (match[1] === \"int\")\nvar size=parseInt(match[2]||\"256\");if(match[2]&&String(size)!==match[2]||size%8!==0||size===0||size>256){throw new Error(\"invalid number type - \"+type);}if(isArray){size=256;}value=lib$2.BigNumber.from(value).toTwos(size);return lib$1.zeroPad(value,size/8);}match=type.match(regexBytes);if(match){var size=parseInt(match[1]);if(String(size)!==match[1]||size===0||size>32){throw new Error(\"invalid bytes type - \"+type);}if(lib$1.arrayify(value).byteLength!==size){throw new Error(\"invalid value for \"+type);}if(isArray){return lib$1.arrayify((value+Zeros).substring(0,66));}return value;}match=type.match(regexArray);if(match&&Array.isArray(value)){var baseType_1=match[1];var count=parseInt(match[2]||String(value.length));if(count!=value.length){throw new Error(\"invalid value for \"+type);}var result_1=[];value.forEach(function(value){result_1.push(_pack(baseType_1,value,true));});return lib$1.concat(result_1);}throw new Error(\"invalid type - \"+type);}// @TODO: Array Enum\nfunction pack(types,values){if(types.length!=values.length){throw new Error(\"type/value count mismatch\");}var tight=[];types.forEach(function(type,index){tight.push(_pack(type,values[index]));});return lib$1.hexlify(lib$1.concat(tight));}exports.pack=pack;function keccak256(types,values){return lib$4.keccak256(pack(types,values));}exports.keccak256=keccak256;function sha256(types,values){return browser.sha256(pack(types,values));}exports.sha256=sha256;});var index$n=unwrapExports(lib$n);var lib_1$n=lib$n.pack;var lib_2$l=lib$n.keccak256;var lib_3$h=lib$n.sha256;var _version$K=createCommonjsModule(function(module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});exports.version=\"units/5.0.2\";});var _version$L=unwrapExports(_version$K);var _version_1$n=_version$K.version;var lib$o=createCommonjsModule(function(module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});var logger=new lib.Logger(_version$K.version);var names=[\"wei\",\"kwei\",\"mwei\",\"gwei\",\"szabo\",\"finney\",\"ether\"];// Some environments have issues with RegEx that contain back-tracking, so we cannot\n// use them.\nfunction commify(value){var comps=String(value).split(\".\");if(comps.length>2||!comps[0].match(/^-?[0-9]*$/)||comps[1]&&!comps[1].match(/^[0-9]*$/)||value===\".\"||value===\"-.\"){logger.throwArgumentError(\"invalid value\",\"value\",value);}// Make sure we have at least one whole digit (0 if none)\nvar whole=comps[0];var negative=\"\";if(whole.substring(0,1)===\"-\"){negative=\"-\";whole=whole.substring(1);}// Make sure we have at least 1 whole digit with no leading zeros\nwhile(whole.substring(0,1)===\"0\"){whole=whole.substring(1);}if(whole===\"\"){whole=\"0\";}var suffix=\"\";if(comps.length===2){suffix=\".\"+(comps[1]||\"0\");}while(suffix.length>2&&suffix[suffix.length-1]===\"0\"){suffix=suffix.substring(0,suffix.length-1);}var formatted=[];while(whole.length){if(whole.length<=3){formatted.unshift(whole);break;}else{var index=whole.length-3;formatted.unshift(whole.substring(index));whole=whole.substring(0,index);}}return negative+formatted.join(\",\")+suffix;}exports.commify=commify;function formatUnits(value,unitName){if(typeof unitName===\"string\"){var index=names.indexOf(unitName);if(index!==-1){unitName=3*index;}}return lib$2.formatFixed(value,unitName!=null?unitName:18);}exports.formatUnits=formatUnits;function parseUnits(value,unitName){if(typeof unitName===\"string\"){var index=names.indexOf(unitName);if(index!==-1){unitName=3*index;}}return lib$2.parseFixed(value,unitName!=null?unitName:18);}exports.parseUnits=parseUnits;function formatEther(wei){return formatUnits(wei,18);}exports.formatEther=formatEther;function parseEther(ether){return parseUnits(ether,18);}exports.parseEther=parseEther;});var index$o=unwrapExports(lib$o);var lib_1$o=lib$o.commify;var lib_2$m=lib$o.formatUnits;var lib_3$i=lib$o.parseUnits;var lib_4$d=lib$o.formatEther;var lib_5$c=lib$o.parseEther;var utils$3=createCommonjsModule(function(module,exports){\"use strict\";var __importStar=commonjsGlobal&&commonjsGlobal.__importStar||function(mod){if(mod&&mod.__esModule)return mod;var result={};if(mod!=null)for(var k in mod){if(Object.hasOwnProperty.call(mod,k))result[k]=mod[k];}result[\"default\"]=mod;return result;};Object.defineProperty(exports,\"__esModule\",{value:true});exports.AbiCoder=lib$a.AbiCoder;exports.checkResultErrors=lib$a.checkResultErrors;exports.defaultAbiCoder=lib$a.defaultAbiCoder;exports.EventFragment=lib$a.EventFragment;exports.FormatTypes=lib$a.FormatTypes;exports.Fragment=lib$a.Fragment;exports.FunctionFragment=lib$a.FunctionFragment;exports.Indexed=lib$a.Indexed;exports.Interface=lib$a.Interface;exports.LogDescription=lib$a.LogDescription;exports.ParamType=lib$a.ParamType;exports.TransactionDescription=lib$a.TransactionDescription;exports.getAddress=lib$6.getAddress;exports.getCreate2Address=lib$6.getCreate2Address;exports.getContractAddress=lib$6.getContractAddress;exports.getIcapAddress=lib$6.getIcapAddress;exports.isAddress=lib$6.isAddress;var base64=__importStar(browser$8);exports.base64=base64;exports.base58=lib$e.Base58;exports.arrayify=lib$1.arrayify;exports.concat=lib$1.concat;exports.hexDataSlice=lib$1.hexDataSlice;exports.hexDataLength=lib$1.hexDataLength;exports.hexlify=lib$1.hexlify;exports.hexStripZeros=lib$1.hexStripZeros;exports.hexValue=lib$1.hexValue;exports.hexZeroPad=lib$1.hexZeroPad;exports.isBytes=lib$1.isBytes;exports.isBytesLike=lib$1.isBytesLike;exports.isHexString=lib$1.isHexString;exports.joinSignature=lib$1.joinSignature;exports.zeroPad=lib$1.zeroPad;exports.splitSignature=lib$1.splitSignature;exports.stripZeros=lib$1.stripZeros;exports.hashMessage=lib$9.hashMessage;exports.id=lib$9.id;exports.isValidName=lib$9.isValidName;exports.namehash=lib$9.namehash;exports.defaultPath=lib$h.defaultPath;exports.entropyToMnemonic=lib$h.entropyToMnemonic;exports.HDNode=lib$h.HDNode;exports.isValidMnemonic=lib$h.isValidMnemonic;exports.mnemonicToEntropy=lib$h.mnemonicToEntropy;exports.mnemonicToSeed=lib$h.mnemonicToSeed;exports.getJsonWalletAddress=lib$i.getJsonWalletAddress;exports.keccak256=lib$4.keccak256;exports.Logger=lib.Logger;exports.computeHmac=browser.computeHmac;exports.ripemd160=browser.ripemd160;exports.sha256=browser.sha256;exports.sha512=browser.sha512;exports.solidityKeccak256=lib$n.keccak256;exports.solidityPack=lib$n.pack;exports.soliditySha256=lib$n.sha256;exports.randomBytes=browser$6.randomBytes;exports.shuffled=browser$6.shuffled;exports.checkProperties=lib$3.checkProperties;exports.deepCopy=lib$3.deepCopy;exports.defineReadOnly=lib$3.defineReadOnly;exports.getStatic=lib$3.getStatic;exports.resolveProperties=lib$3.resolveProperties;exports.shallowCopy=lib$3.shallowCopy;var RLP=__importStar(lib$5);exports.RLP=RLP;exports.computePublicKey=lib$f.computePublicKey;exports.recoverPublicKey=lib$f.recoverPublicKey;exports.SigningKey=lib$f.SigningKey;exports.formatBytes32String=lib$8.formatBytes32String;exports.nameprep=lib$8.nameprep;exports.parseBytes32String=lib$8.parseBytes32String;exports._toEscapedUtf8String=lib$8._toEscapedUtf8String;exports.toUtf8Bytes=lib$8.toUtf8Bytes;exports.toUtf8CodePoints=lib$8.toUtf8CodePoints;exports.toUtf8String=lib$8.toUtf8String;exports.Utf8ErrorFuncs=lib$8.Utf8ErrorFuncs;exports.computeAddress=lib$g.computeAddress;exports.parseTransaction=lib$g.parse;exports.recoverAddress=lib$g.recoverAddress;exports.serializeTransaction=lib$g.serialize;exports.commify=lib$o.commify;exports.formatEther=lib$o.formatEther;exports.parseEther=lib$o.parseEther;exports.formatUnits=lib$o.formatUnits;exports.parseUnits=lib$o.parseUnits;exports.verifyMessage=lib$j.verifyMessage;exports._fetchData=lib$l._fetchData;exports.fetchJson=lib$l.fetchJson;exports.poll=lib$l.poll;////////////////////////\n// Enums\nvar sha2_2=browser;exports.SupportedAlgorithm=sha2_2.SupportedAlgorithm;var strings_2=lib$8;exports.UnicodeNormalizationForm=strings_2.UnicodeNormalizationForm;exports.Utf8ErrorReason=strings_2.Utf8ErrorReason;});var utils$4=unwrapExports(utils$3);var utils_1$3=utils$3.AbiCoder;var utils_2$1=utils$3.checkResultErrors;var utils_3$1=utils$3.defaultAbiCoder;var utils_4$1=utils$3.EventFragment;var utils_5$1=utils$3.FormatTypes;var utils_6=utils$3.Fragment;var utils_7=utils$3.FunctionFragment;var utils_8=utils$3.Indexed;var utils_9=utils$3.Interface;var utils_10=utils$3.LogDescription;var utils_11=utils$3.ParamType;var utils_12=utils$3.TransactionDescription;var utils_13=utils$3.getAddress;var utils_14=utils$3.getCreate2Address;var utils_15=utils$3.getContractAddress;var utils_16=utils$3.getIcapAddress;var utils_17=utils$3.isAddress;var utils_18=utils$3.base64;var utils_19=utils$3.base58;var utils_20=utils$3.arrayify;var utils_21=utils$3.concat;var utils_22=utils$3.hexDataSlice;var utils_23=utils$3.hexDataLength;var utils_24=utils$3.hexlify;var utils_25=utils$3.hexStripZeros;var utils_26=utils$3.hexValue;var utils_27=utils$3.hexZeroPad;var utils_28=utils$3.isBytes;var utils_29=utils$3.isBytesLike;var utils_30=utils$3.isHexString;var utils_31=utils$3.joinSignature;var utils_32=utils$3.zeroPad;var utils_33=utils$3.splitSignature;var utils_34=utils$3.stripZeros;var utils_35=utils$3.hashMessage;var utils_36=utils$3.id;var utils_37=utils$3.isValidName;var utils_38=utils$3.namehash;var utils_39=utils$3.defaultPath;var utils_40=utils$3.entropyToMnemonic;var utils_41=utils$3.HDNode;var utils_42=utils$3.isValidMnemonic;var utils_43=utils$3.mnemonicToEntropy;var utils_44=utils$3.mnemonicToSeed;var utils_45=utils$3.getJsonWalletAddress;var utils_46=utils$3.keccak256;var utils_47=utils$3.Logger;var utils_48=utils$3.computeHmac;var utils_49=utils$3.ripemd160;var utils_50=utils$3.sha256;var utils_51=utils$3.sha512;var utils_52=utils$3.solidityKeccak256;var utils_53=utils$3.solidityPack;var utils_54=utils$3.soliditySha256;var utils_55=utils$3.randomBytes;var utils_56=utils$3.shuffled;var utils_57=utils$3.checkProperties;var utils_58=utils$3.deepCopy;var utils_59=utils$3.defineReadOnly;var utils_60=utils$3.getStatic;var utils_61=utils$3.resolveProperties;var utils_62=utils$3.shallowCopy;var utils_63=utils$3.RLP;var utils_64=utils$3.computePublicKey;var utils_65=utils$3.recoverPublicKey;var utils_66=utils$3.SigningKey;var utils_67=utils$3.formatBytes32String;var utils_68=utils$3.nameprep;var utils_69=utils$3.parseBytes32String;var utils_70=utils$3._toEscapedUtf8String;var utils_71=utils$3.toUtf8Bytes;var utils_72=utils$3.toUtf8CodePoints;var utils_73=utils$3.toUtf8String;var utils_74=utils$3.Utf8ErrorFuncs;var utils_75=utils$3.computeAddress;var utils_76=utils$3.parseTransaction;var utils_77=utils$3.recoverAddress;var utils_78=utils$3.serializeTransaction;var utils_79=utils$3.commify;var utils_80=utils$3.formatEther;var utils_81=utils$3.parseEther;var utils_82=utils$3.formatUnits;var utils_83=utils$3.parseUnits;var utils_84=utils$3.verifyMessage;var utils_85=utils$3._fetchData;var utils_86=utils$3.fetchJson;var utils_87=utils$3.poll;var utils_88=utils$3.SupportedAlgorithm;var utils_89=utils$3.UnicodeNormalizationForm;var utils_90=utils$3.Utf8ErrorReason;var _version$M=createCommonjsModule(function(module,exports){\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});exports.version=\"ethers/5.0.8\";});var _version$N=unwrapExports(_version$M);var _version_1$o=_version$M.version;var ethers=createCommonjsModule(function(module,exports){\"use strict\";var __importStar=commonjsGlobal&&commonjsGlobal.__importStar||function(mod){if(mod&&mod.__esModule)return mod;var result={};if(mod!=null)for(var k in mod){if(Object.hasOwnProperty.call(mod,k))result[k]=mod[k];}result[\"default\"]=mod;return result;};Object.defineProperty(exports,\"__esModule\",{value:true});exports.Contract=lib$d.Contract;exports.ContractFactory=lib$d.ContractFactory;exports.BigNumber=lib$2.BigNumber;exports.FixedNumber=lib$2.FixedNumber;exports.Signer=lib$c.Signer;exports.VoidSigner=lib$c.VoidSigner;exports.Wallet=lib$j.Wallet;var constants=__importStar(lib$7);exports.constants=constants;var providers=__importStar(lib$m);exports.providers=providers;var providers_1=lib$m;exports.getDefaultProvider=providers_1.getDefaultProvider;exports.Wordlist=browser$4.Wordlist;exports.wordlists=browser$4.wordlists;var utils=__importStar(utils$3);exports.utils=utils;exports.errors=lib.ErrorCode;////////////////////////\n// Compile-Time Constants\n// This is generated by \"npm run dist\"\nexports.version=_version$M.version;var logger=new lib.Logger(_version$M.version);exports.logger=logger;});var ethers$1=unwrapExports(ethers);var ethers_1=ethers.Contract;var ethers_2=ethers.ContractFactory;var ethers_3=ethers.BigNumber;var ethers_4=ethers.FixedNumber;var ethers_5=ethers.Signer;var ethers_6=ethers.VoidSigner;var ethers_7=ethers.Wallet;var ethers_8=ethers.constants;var ethers_9=ethers.providers;var ethers_10=ethers.getDefaultProvider;var ethers_11=ethers.Wordlist;var ethers_12=ethers.wordlists;var ethers_13=ethers.utils;var ethers_14=ethers.errors;var ethers_15=ethers.version;var ethers_16=ethers.logger;var lib$p=createCommonjsModule(function(module,exports){\"use strict\";var __importStar=commonjsGlobal&&commonjsGlobal.__importStar||function(mod){if(mod&&mod.__esModule)return mod;var result={};if(mod!=null)for(var k in mod){if(Object.hasOwnProperty.call(mod,k))result[k]=mod[k];}result[\"default\"]=mod;return result;};Object.defineProperty(exports,\"__esModule\",{value:true});// To modify this file, you must update ./admin/cmds/update-exports.js\nvar ethers$1=__importStar(ethers);exports.ethers=ethers$1;try{var anyGlobal=window;if(anyGlobal._ethers==null){anyGlobal._ethers=ethers$1;}}catch(error){}var ethers_1=ethers;exports.Signer=ethers_1.Signer;exports.Wallet=ethers_1.Wallet;exports.VoidSigner=ethers_1.VoidSigner;exports.getDefaultProvider=ethers_1.getDefaultProvider;exports.providers=ethers_1.providers;exports.Contract=ethers_1.Contract;exports.ContractFactory=ethers_1.ContractFactory;exports.BigNumber=ethers_1.BigNumber;exports.FixedNumber=ethers_1.FixedNumber;exports.constants=ethers_1.constants;exports.errors=ethers_1.errors;exports.logger=ethers_1.logger;exports.utils=ethers_1.utils;exports.wordlists=ethers_1.wordlists;////////////////////////\n// Compile-Time Constants\nexports.version=ethers_1.version;exports.Wordlist=ethers_1.Wordlist;});var index$p=unwrapExports(lib$p);var lib_1$p=lib$p.ethers;var lib_2$n=lib$p.Signer;var lib_3$j=lib$p.Wallet;var lib_4$e=lib$p.VoidSigner;var lib_5$d=lib$p.getDefaultProvider;var lib_6$8=lib$p.providers;var lib_7$7=lib$p.Contract;var lib_8$6=lib$p.ContractFactory;var lib_9$6=lib$p.BigNumber;var lib_10$4=lib$p.FixedNumber;var lib_11$3=lib$p.constants;var lib_12$3=lib$p.errors;var lib_13$3=lib$p.logger;var lib_14$2=lib$p.utils;var lib_15$2=lib$p.wordlists;var lib_16$2=lib$p.version;var lib_17$1=lib$p.Wordlist;exports.BigNumber=lib_9$6;exports.Contract=lib_7$7;exports.ContractFactory=lib_8$6;exports.FixedNumber=lib_10$4;exports.Signer=lib_2$n;exports.VoidSigner=lib_4$e;exports.Wallet=lib_3$j;exports.Wordlist=lib_17$1;exports.constants=lib_11$3;exports.default=index$p;exports.errors=lib_12$3;exports.ethers=lib_1$p;exports.getDefaultProvider=lib_5$d;exports.logger=lib_13$3;exports.providers=lib_6$8;exports.utils=lib_14$2;exports.version=lib_16$2;exports.wordlists=lib_15$2;Object.defineProperty(exports,'__esModule',{value:true});});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../process/browser.js */ \"./node_modules/process/browser.js\"), __webpack_require__(/*! ./../../timers-browserify/main.js */ \"./node_modules/timers-browserify/main.js\").setImmediate))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXRoZXJzL2Rpc3QvZXRoZXJzLnVtZC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ldGhlcnMvZGlzdC9ldGhlcnMudW1kLmpzP2IwNDciXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuXHQoZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLmV0aGVycyA9IHt9KSk7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuXHR2YXIgY29tbW9uanNHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fTtcblxuXHRmdW5jdGlvbiBjb21tb25qc1JlcXVpcmUgKCkge1xuXHRcdHRocm93IG5ldyBFcnJvcignRHluYW1pYyByZXF1aXJlcyBhcmUgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQgYnkgcm9sbHVwLXBsdWdpbi1jb21tb25qcycpO1xuXHR9XG5cblx0ZnVuY3Rpb24gdW53cmFwRXhwb3J0cyAoeCkge1xuXHRcdHJldHVybiB4ICYmIHguX19lc01vZHVsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ2RlZmF1bHQnKSA/IHhbJ2RlZmF1bHQnXSA6IHg7XG5cdH1cblxuXHRmdW5jdGlvbiBjcmVhdGVDb21tb25qc01vZHVsZShmbiwgbW9kdWxlKSB7XG5cdFx0cmV0dXJuIG1vZHVsZSA9IHsgZXhwb3J0czoge30gfSwgZm4obW9kdWxlLCBtb2R1bGUuZXhwb3J0cyksIG1vZHVsZS5leHBvcnRzO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0Q2pzRXhwb3J0RnJvbU5hbWVzcGFjZSAobikge1xuXHRcdHJldHVybiBuICYmIG5bJ2RlZmF1bHQnXSB8fCBuO1xuXHR9XG5cblx0dmFyIF9ub2RlUmVzb2x2ZV9lbXB0eSA9IHt9O1xuXG5cdHZhciBfbm9kZVJlc29sdmVfZW1wdHkkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0XHQnZGVmYXVsdCc6IF9ub2RlUmVzb2x2ZV9lbXB0eVxuXHR9KTtcblxuXHR2YXIgcmVxdWlyZSQkMCA9IGdldENqc0V4cG9ydEZyb21OYW1lc3BhY2UoX25vZGVSZXNvbHZlX2VtcHR5JDEpO1xuXG5cdHZhciBibiA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcblx0KGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0ICAndXNlIHN0cmljdCc7XG5cblx0ICAvLyBVdGlsc1xuXHQgIGZ1bmN0aW9uIGFzc2VydCAodmFsLCBtc2cpIHtcblx0ICAgIGlmICghdmFsKSB0aHJvdyBuZXcgRXJyb3IobXNnIHx8ICdBc3NlcnRpb24gZmFpbGVkJyk7XG5cdCAgfVxuXG5cdCAgLy8gQ291bGQgdXNlIGBpbmhlcml0c2AgbW9kdWxlLCBidXQgZG9uJ3Qgd2FudCB0byBtb3ZlIGZyb20gc2luZ2xlIGZpbGVcblx0ICAvLyBhcmNoaXRlY3R1cmUgeWV0LlxuXHQgIGZ1bmN0aW9uIGluaGVyaXRzIChjdG9yLCBzdXBlckN0b3IpIHtcblx0ICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yO1xuXHQgICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge307XG5cdCAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlO1xuXHQgICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKTtcblx0ICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3Rvcjtcblx0ICB9XG5cblx0ICAvLyBCTlxuXG5cdCAgZnVuY3Rpb24gQk4gKG51bWJlciwgYmFzZSwgZW5kaWFuKSB7XG5cdCAgICBpZiAoQk4uaXNCTihudW1iZXIpKSB7XG5cdCAgICAgIHJldHVybiBudW1iZXI7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuXHQgICAgdGhpcy53b3JkcyA9IG51bGw7XG5cdCAgICB0aGlzLmxlbmd0aCA9IDA7XG5cblx0ICAgIC8vIFJlZHVjdGlvbiBjb250ZXh0XG5cdCAgICB0aGlzLnJlZCA9IG51bGw7XG5cblx0ICAgIGlmIChudW1iZXIgIT09IG51bGwpIHtcblx0ICAgICAgaWYgKGJhc2UgPT09ICdsZScgfHwgYmFzZSA9PT0gJ2JlJykge1xuXHQgICAgICAgIGVuZGlhbiA9IGJhc2U7XG5cdCAgICAgICAgYmFzZSA9IDEwO1xuXHQgICAgICB9XG5cblx0ICAgICAgdGhpcy5faW5pdChudW1iZXIgfHwgMCwgYmFzZSB8fCAxMCwgZW5kaWFuIHx8ICdiZScpO1xuXHQgICAgfVxuXHQgIH1cblx0ICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpIHtcblx0ICAgIG1vZHVsZS5leHBvcnRzID0gQk47XG5cdCAgfSBlbHNlIHtcblx0ICAgIGV4cG9ydHMuQk4gPSBCTjtcblx0ICB9XG5cblx0ICBCTi5CTiA9IEJOO1xuXHQgIEJOLndvcmRTaXplID0gMjY7XG5cblx0ICB2YXIgQnVmZmVyO1xuXHQgIHRyeSB7XG5cdCAgICBCdWZmZXIgPSByZXF1aXJlJCQwLkJ1ZmZlcjtcblx0ICB9IGNhdGNoIChlKSB7XG5cdCAgfVxuXG5cdCAgQk4uaXNCTiA9IGZ1bmN0aW9uIGlzQk4gKG51bSkge1xuXHQgICAgaWYgKG51bSBpbnN0YW5jZW9mIEJOKSB7XG5cdCAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gbnVtICE9PSBudWxsICYmIHR5cGVvZiBudW0gPT09ICdvYmplY3QnICYmXG5cdCAgICAgIG51bS5jb25zdHJ1Y3Rvci53b3JkU2l6ZSA9PT0gQk4ud29yZFNpemUgJiYgQXJyYXkuaXNBcnJheShudW0ud29yZHMpO1xuXHQgIH07XG5cblx0ICBCTi5tYXggPSBmdW5jdGlvbiBtYXggKGxlZnQsIHJpZ2h0KSB7XG5cdCAgICBpZiAobGVmdC5jbXAocmlnaHQpID4gMCkgcmV0dXJuIGxlZnQ7XG5cdCAgICByZXR1cm4gcmlnaHQ7XG5cdCAgfTtcblxuXHQgIEJOLm1pbiA9IGZ1bmN0aW9uIG1pbiAobGVmdCwgcmlnaHQpIHtcblx0ICAgIGlmIChsZWZ0LmNtcChyaWdodCkgPCAwKSByZXR1cm4gbGVmdDtcblx0ICAgIHJldHVybiByaWdodDtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gaW5pdCAobnVtYmVyLCBiYXNlLCBlbmRpYW4pIHtcblx0ICAgIGlmICh0eXBlb2YgbnVtYmVyID09PSAnbnVtYmVyJykge1xuXHQgICAgICByZXR1cm4gdGhpcy5faW5pdE51bWJlcihudW1iZXIsIGJhc2UsIGVuZGlhbik7XG5cdCAgICB9XG5cblx0ICAgIGlmICh0eXBlb2YgbnVtYmVyID09PSAnb2JqZWN0Jykge1xuXHQgICAgICByZXR1cm4gdGhpcy5faW5pdEFycmF5KG51bWJlciwgYmFzZSwgZW5kaWFuKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKGJhc2UgPT09ICdoZXgnKSB7XG5cdCAgICAgIGJhc2UgPSAxNjtcblx0ICAgIH1cblx0ICAgIGFzc2VydChiYXNlID09PSAoYmFzZSB8IDApICYmIGJhc2UgPj0gMiAmJiBiYXNlIDw9IDM2KTtcblxuXHQgICAgbnVtYmVyID0gbnVtYmVyLnRvU3RyaW5nKCkucmVwbGFjZSgvXFxzKy9nLCAnJyk7XG5cdCAgICB2YXIgc3RhcnQgPSAwO1xuXHQgICAgaWYgKG51bWJlclswXSA9PT0gJy0nKSB7XG5cdCAgICAgIHN0YXJ0Kys7XG5cdCAgICB9XG5cblx0ICAgIGlmIChiYXNlID09PSAxNikge1xuXHQgICAgICB0aGlzLl9wYXJzZUhleChudW1iZXIsIHN0YXJ0KTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHRoaXMuX3BhcnNlQmFzZShudW1iZXIsIGJhc2UsIHN0YXJ0KTtcblx0ICAgIH1cblxuXHQgICAgaWYgKG51bWJlclswXSA9PT0gJy0nKSB7XG5cdCAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLnN0cmlwKCk7XG5cblx0ICAgIGlmIChlbmRpYW4gIT09ICdsZScpIHJldHVybjtcblxuXHQgICAgdGhpcy5faW5pdEFycmF5KHRoaXMudG9BcnJheSgpLCBiYXNlLCBlbmRpYW4pO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuX2luaXROdW1iZXIgPSBmdW5jdGlvbiBfaW5pdE51bWJlciAobnVtYmVyLCBiYXNlLCBlbmRpYW4pIHtcblx0ICAgIGlmIChudW1iZXIgPCAwKSB7XG5cdCAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuXHQgICAgICBudW1iZXIgPSAtbnVtYmVyO1xuXHQgICAgfVxuXHQgICAgaWYgKG51bWJlciA8IDB4NDAwMDAwMCkge1xuXHQgICAgICB0aGlzLndvcmRzID0gWyBudW1iZXIgJiAweDNmZmZmZmYgXTtcblx0ICAgICAgdGhpcy5sZW5ndGggPSAxO1xuXHQgICAgfSBlbHNlIGlmIChudW1iZXIgPCAweDEwMDAwMDAwMDAwMDAwKSB7XG5cdCAgICAgIHRoaXMud29yZHMgPSBbXG5cdCAgICAgICAgbnVtYmVyICYgMHgzZmZmZmZmLFxuXHQgICAgICAgIChudW1iZXIgLyAweDQwMDAwMDApICYgMHgzZmZmZmZmXG5cdCAgICAgIF07XG5cdCAgICAgIHRoaXMubGVuZ3RoID0gMjtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGFzc2VydChudW1iZXIgPCAweDIwMDAwMDAwMDAwMDAwKTsgLy8gMiBeIDUzICh1bnNhZmUpXG5cdCAgICAgIHRoaXMud29yZHMgPSBbXG5cdCAgICAgICAgbnVtYmVyICYgMHgzZmZmZmZmLFxuXHQgICAgICAgIChudW1iZXIgLyAweDQwMDAwMDApICYgMHgzZmZmZmZmLFxuXHQgICAgICAgIDFcblx0ICAgICAgXTtcblx0ICAgICAgdGhpcy5sZW5ndGggPSAzO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoZW5kaWFuICE9PSAnbGUnKSByZXR1cm47XG5cblx0ICAgIC8vIFJldmVyc2UgdGhlIGJ5dGVzXG5cdCAgICB0aGlzLl9pbml0QXJyYXkodGhpcy50b0FycmF5KCksIGJhc2UsIGVuZGlhbik7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5faW5pdEFycmF5ID0gZnVuY3Rpb24gX2luaXRBcnJheSAobnVtYmVyLCBiYXNlLCBlbmRpYW4pIHtcblx0ICAgIC8vIFBlcmhhcHMgYSBVaW50OEFycmF5XG5cdCAgICBhc3NlcnQodHlwZW9mIG51bWJlci5sZW5ndGggPT09ICdudW1iZXInKTtcblx0ICAgIGlmIChudW1iZXIubGVuZ3RoIDw9IDApIHtcblx0ICAgICAgdGhpcy53b3JkcyA9IFsgMCBdO1xuXHQgICAgICB0aGlzLmxlbmd0aCA9IDE7XG5cdCAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLmxlbmd0aCA9IE1hdGguY2VpbChudW1iZXIubGVuZ3RoIC8gMyk7XG5cdCAgICB0aGlzLndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICB0aGlzLndvcmRzW2ldID0gMDtcblx0ICAgIH1cblxuXHQgICAgdmFyIGosIHc7XG5cdCAgICB2YXIgb2ZmID0gMDtcblx0ICAgIGlmIChlbmRpYW4gPT09ICdiZScpIHtcblx0ICAgICAgZm9yIChpID0gbnVtYmVyLmxlbmd0aCAtIDEsIGogPSAwOyBpID49IDA7IGkgLT0gMykge1xuXHQgICAgICAgIHcgPSBudW1iZXJbaV0gfCAobnVtYmVyW2kgLSAxXSA8PCA4KSB8IChudW1iZXJbaSAtIDJdIDw8IDE2KTtcblx0ICAgICAgICB0aGlzLndvcmRzW2pdIHw9ICh3IDw8IG9mZikgJiAweDNmZmZmZmY7XG5cdCAgICAgICAgdGhpcy53b3Jkc1tqICsgMV0gPSAodyA+Pj4gKDI2IC0gb2ZmKSkgJiAweDNmZmZmZmY7XG5cdCAgICAgICAgb2ZmICs9IDI0O1xuXHQgICAgICAgIGlmIChvZmYgPj0gMjYpIHtcblx0ICAgICAgICAgIG9mZiAtPSAyNjtcblx0ICAgICAgICAgIGorKztcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSBpZiAoZW5kaWFuID09PSAnbGUnKSB7XG5cdCAgICAgIGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbnVtYmVyLmxlbmd0aDsgaSArPSAzKSB7XG5cdCAgICAgICAgdyA9IG51bWJlcltpXSB8IChudW1iZXJbaSArIDFdIDw8IDgpIHwgKG51bWJlcltpICsgMl0gPDwgMTYpO1xuXHQgICAgICAgIHRoaXMud29yZHNbal0gfD0gKHcgPDwgb2ZmKSAmIDB4M2ZmZmZmZjtcblx0ICAgICAgICB0aGlzLndvcmRzW2ogKyAxXSA9ICh3ID4+PiAoMjYgLSBvZmYpKSAmIDB4M2ZmZmZmZjtcblx0ICAgICAgICBvZmYgKz0gMjQ7XG5cdCAgICAgICAgaWYgKG9mZiA+PSAyNikge1xuXHQgICAgICAgICAgb2ZmIC09IDI2O1xuXHQgICAgICAgICAgaisrO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcblx0ICB9O1xuXG5cdCAgZnVuY3Rpb24gcGFyc2VIZXggKHN0ciwgc3RhcnQsIGVuZCkge1xuXHQgICAgdmFyIHIgPSAwO1xuXHQgICAgdmFyIGxlbiA9IE1hdGgubWluKHN0ci5sZW5ndGgsIGVuZCk7XG5cdCAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBsZW47IGkrKykge1xuXHQgICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpIC0gNDg7XG5cblx0ICAgICAgciA8PD0gNDtcblxuXHQgICAgICAvLyAnYScgLSAnZidcblx0ICAgICAgaWYgKGMgPj0gNDkgJiYgYyA8PSA1NCkge1xuXHQgICAgICAgIHIgfD0gYyAtIDQ5ICsgMHhhO1xuXG5cdCAgICAgIC8vICdBJyAtICdGJ1xuXHQgICAgICB9IGVsc2UgaWYgKGMgPj0gMTcgJiYgYyA8PSAyMikge1xuXHQgICAgICAgIHIgfD0gYyAtIDE3ICsgMHhhO1xuXG5cdCAgICAgIC8vICcwJyAtICc5J1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHIgfD0gYyAmIDB4Zjtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIHI7XG5cdCAgfVxuXG5cdCAgQk4ucHJvdG90eXBlLl9wYXJzZUhleCA9IGZ1bmN0aW9uIF9wYXJzZUhleCAobnVtYmVyLCBzdGFydCkge1xuXHQgICAgLy8gQ3JlYXRlIHBvc3NpYmx5IGJpZ2dlciBhcnJheSB0byBlbnN1cmUgdGhhdCBpdCBmaXRzIHRoZSBudW1iZXJcblx0ICAgIHRoaXMubGVuZ3RoID0gTWF0aC5jZWlsKChudW1iZXIubGVuZ3RoIC0gc3RhcnQpIC8gNik7XG5cdCAgICB0aGlzLndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICB0aGlzLndvcmRzW2ldID0gMDtcblx0ICAgIH1cblxuXHQgICAgdmFyIGosIHc7XG5cdCAgICAvLyBTY2FuIDI0LWJpdCBjaHVua3MgYW5kIGFkZCB0aGVtIHRvIHRoZSBudW1iZXJcblx0ICAgIHZhciBvZmYgPSAwO1xuXHQgICAgZm9yIChpID0gbnVtYmVyLmxlbmd0aCAtIDYsIGogPSAwOyBpID49IHN0YXJ0OyBpIC09IDYpIHtcblx0ICAgICAgdyA9IHBhcnNlSGV4KG51bWJlciwgaSwgaSArIDYpO1xuXHQgICAgICB0aGlzLndvcmRzW2pdIHw9ICh3IDw8IG9mZikgJiAweDNmZmZmZmY7XG5cdCAgICAgIC8vIE5PVEU6IGAweDNmZmZmZmAgaXMgaW50ZW50aW9uYWwgaGVyZSwgMjZiaXRzIG1heCBzaGlmdCArIDI0Yml0IGhleCBsaW1iXG5cdCAgICAgIHRoaXMud29yZHNbaiArIDFdIHw9IHcgPj4+ICgyNiAtIG9mZikgJiAweDNmZmZmZjtcblx0ICAgICAgb2ZmICs9IDI0O1xuXHQgICAgICBpZiAob2ZmID49IDI2KSB7XG5cdCAgICAgICAgb2ZmIC09IDI2O1xuXHQgICAgICAgIGorKztcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgaWYgKGkgKyA2ICE9PSBzdGFydCkge1xuXHQgICAgICB3ID0gcGFyc2VIZXgobnVtYmVyLCBzdGFydCwgaSArIDYpO1xuXHQgICAgICB0aGlzLndvcmRzW2pdIHw9ICh3IDw8IG9mZikgJiAweDNmZmZmZmY7XG5cdCAgICAgIHRoaXMud29yZHNbaiArIDFdIHw9IHcgPj4+ICgyNiAtIG9mZikgJiAweDNmZmZmZjtcblx0ICAgIH1cblx0ICAgIHRoaXMuc3RyaXAoKTtcblx0ICB9O1xuXG5cdCAgZnVuY3Rpb24gcGFyc2VCYXNlIChzdHIsIHN0YXJ0LCBlbmQsIG11bCkge1xuXHQgICAgdmFyIHIgPSAwO1xuXHQgICAgdmFyIGxlbiA9IE1hdGgubWluKHN0ci5sZW5ndGgsIGVuZCk7XG5cdCAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBsZW47IGkrKykge1xuXHQgICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpIC0gNDg7XG5cblx0ICAgICAgciAqPSBtdWw7XG5cblx0ICAgICAgLy8gJ2EnXG5cdCAgICAgIGlmIChjID49IDQ5KSB7XG5cdCAgICAgICAgciArPSBjIC0gNDkgKyAweGE7XG5cblx0ICAgICAgLy8gJ0EnXG5cdCAgICAgIH0gZWxzZSBpZiAoYyA+PSAxNykge1xuXHQgICAgICAgIHIgKz0gYyAtIDE3ICsgMHhhO1xuXG5cdCAgICAgIC8vICcwJyAtICc5J1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHIgKz0gYztcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIHI7XG5cdCAgfVxuXG5cdCAgQk4ucHJvdG90eXBlLl9wYXJzZUJhc2UgPSBmdW5jdGlvbiBfcGFyc2VCYXNlIChudW1iZXIsIGJhc2UsIHN0YXJ0KSB7XG5cdCAgICAvLyBJbml0aWFsaXplIGFzIHplcm9cblx0ICAgIHRoaXMud29yZHMgPSBbIDAgXTtcblx0ICAgIHRoaXMubGVuZ3RoID0gMTtcblxuXHQgICAgLy8gRmluZCBsZW5ndGggb2YgbGltYiBpbiBiYXNlXG5cdCAgICBmb3IgKHZhciBsaW1iTGVuID0gMCwgbGltYlBvdyA9IDE7IGxpbWJQb3cgPD0gMHgzZmZmZmZmOyBsaW1iUG93ICo9IGJhc2UpIHtcblx0ICAgICAgbGltYkxlbisrO1xuXHQgICAgfVxuXHQgICAgbGltYkxlbi0tO1xuXHQgICAgbGltYlBvdyA9IChsaW1iUG93IC8gYmFzZSkgfCAwO1xuXG5cdCAgICB2YXIgdG90YWwgPSBudW1iZXIubGVuZ3RoIC0gc3RhcnQ7XG5cdCAgICB2YXIgbW9kID0gdG90YWwgJSBsaW1iTGVuO1xuXHQgICAgdmFyIGVuZCA9IE1hdGgubWluKHRvdGFsLCB0b3RhbCAtIG1vZCkgKyBzdGFydDtcblxuXHQgICAgdmFyIHdvcmQgPSAwO1xuXHQgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IGxpbWJMZW4pIHtcblx0ICAgICAgd29yZCA9IHBhcnNlQmFzZShudW1iZXIsIGksIGkgKyBsaW1iTGVuLCBiYXNlKTtcblxuXHQgICAgICB0aGlzLmltdWxuKGxpbWJQb3cpO1xuXHQgICAgICBpZiAodGhpcy53b3Jkc1swXSArIHdvcmQgPCAweDQwMDAwMDApIHtcblx0ICAgICAgICB0aGlzLndvcmRzWzBdICs9IHdvcmQ7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdGhpcy5faWFkZG4od29yZCk7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgaWYgKG1vZCAhPT0gMCkge1xuXHQgICAgICB2YXIgcG93ID0gMTtcblx0ICAgICAgd29yZCA9IHBhcnNlQmFzZShudW1iZXIsIGksIG51bWJlci5sZW5ndGgsIGJhc2UpO1xuXG5cdCAgICAgIGZvciAoaSA9IDA7IGkgPCBtb2Q7IGkrKykge1xuXHQgICAgICAgIHBvdyAqPSBiYXNlO1xuXHQgICAgICB9XG5cblx0ICAgICAgdGhpcy5pbXVsbihwb3cpO1xuXHQgICAgICBpZiAodGhpcy53b3Jkc1swXSArIHdvcmQgPCAweDQwMDAwMDApIHtcblx0ICAgICAgICB0aGlzLndvcmRzWzBdICs9IHdvcmQ7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdGhpcy5faWFkZG4od29yZCk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5IChkZXN0KSB7XG5cdCAgICBkZXN0LndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICBkZXN0LndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXTtcblx0ICAgIH1cblx0ICAgIGRlc3QubGVuZ3RoID0gdGhpcy5sZW5ndGg7XG5cdCAgICBkZXN0Lm5lZ2F0aXZlID0gdGhpcy5uZWdhdGl2ZTtcblx0ICAgIGRlc3QucmVkID0gdGhpcy5yZWQ7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lICgpIHtcblx0ICAgIHZhciByID0gbmV3IEJOKG51bGwpO1xuXHQgICAgdGhpcy5jb3B5KHIpO1xuXHQgICAgcmV0dXJuIHI7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5fZXhwYW5kID0gZnVuY3Rpb24gX2V4cGFuZCAoc2l6ZSkge1xuXHQgICAgd2hpbGUgKHRoaXMubGVuZ3RoIDwgc2l6ZSkge1xuXHQgICAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoKytdID0gMDtcblx0ICAgIH1cblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cblx0ICAvLyBSZW1vdmUgbGVhZGluZyBgMGAgZnJvbSBgdGhpc2Bcblx0ICBCTi5wcm90b3R5cGUuc3RyaXAgPSBmdW5jdGlvbiBzdHJpcCAoKSB7XG5cdCAgICB3aGlsZSAodGhpcy5sZW5ndGggPiAxICYmIHRoaXMud29yZHNbdGhpcy5sZW5ndGggLSAxXSA9PT0gMCkge1xuXHQgICAgICB0aGlzLmxlbmd0aC0tO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHRoaXMuX25vcm1TaWduKCk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5fbm9ybVNpZ24gPSBmdW5jdGlvbiBfbm9ybVNpZ24gKCkge1xuXHQgICAgLy8gLTAgPSAwXG5cdCAgICBpZiAodGhpcy5sZW5ndGggPT09IDEgJiYgdGhpcy53b3Jkc1swXSA9PT0gMCkge1xuXHQgICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcblx0ICAgIH1cblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuXHQgICAgcmV0dXJuICh0aGlzLnJlZCA/ICc8Qk4tUjogJyA6ICc8Qk46ICcpICsgdGhpcy50b1N0cmluZygxNikgKyAnPic7XG5cdCAgfTtcblxuXHQgIC8qXG5cblx0ICB2YXIgemVyb3MgPSBbXTtcblx0ICB2YXIgZ3JvdXBTaXplcyA9IFtdO1xuXHQgIHZhciBncm91cEJhc2VzID0gW107XG5cblx0ICB2YXIgcyA9ICcnO1xuXHQgIHZhciBpID0gLTE7XG5cdCAgd2hpbGUgKCsraSA8IEJOLndvcmRTaXplKSB7XG5cdCAgICB6ZXJvc1tpXSA9IHM7XG5cdCAgICBzICs9ICcwJztcblx0ICB9XG5cdCAgZ3JvdXBTaXplc1swXSA9IDA7XG5cdCAgZ3JvdXBTaXplc1sxXSA9IDA7XG5cdCAgZ3JvdXBCYXNlc1swXSA9IDA7XG5cdCAgZ3JvdXBCYXNlc1sxXSA9IDA7XG5cdCAgdmFyIGJhc2UgPSAyIC0gMTtcblx0ICB3aGlsZSAoKytiYXNlIDwgMzYgKyAxKSB7XG5cdCAgICB2YXIgZ3JvdXBTaXplID0gMDtcblx0ICAgIHZhciBncm91cEJhc2UgPSAxO1xuXHQgICAgd2hpbGUgKGdyb3VwQmFzZSA8ICgxIDw8IEJOLndvcmRTaXplKSAvIGJhc2UpIHtcblx0ICAgICAgZ3JvdXBCYXNlICo9IGJhc2U7XG5cdCAgICAgIGdyb3VwU2l6ZSArPSAxO1xuXHQgICAgfVxuXHQgICAgZ3JvdXBTaXplc1tiYXNlXSA9IGdyb3VwU2l6ZTtcblx0ICAgIGdyb3VwQmFzZXNbYmFzZV0gPSBncm91cEJhc2U7XG5cdCAgfVxuXG5cdCAgKi9cblxuXHQgIHZhciB6ZXJvcyA9IFtcblx0ICAgICcnLFxuXHQgICAgJzAnLFxuXHQgICAgJzAwJyxcblx0ICAgICcwMDAnLFxuXHQgICAgJzAwMDAnLFxuXHQgICAgJzAwMDAwJyxcblx0ICAgICcwMDAwMDAnLFxuXHQgICAgJzAwMDAwMDAnLFxuXHQgICAgJzAwMDAwMDAwJyxcblx0ICAgICcwMDAwMDAwMDAnLFxuXHQgICAgJzAwMDAwMDAwMDAnLFxuXHQgICAgJzAwMDAwMDAwMDAwJyxcblx0ICAgICcwMDAwMDAwMDAwMDAnLFxuXHQgICAgJzAwMDAwMDAwMDAwMDAnLFxuXHQgICAgJzAwMDAwMDAwMDAwMDAwJyxcblx0ICAgICcwMDAwMDAwMDAwMDAwMDAnLFxuXHQgICAgJzAwMDAwMDAwMDAwMDAwMDAnLFxuXHQgICAgJzAwMDAwMDAwMDAwMDAwMDAwJyxcblx0ICAgICcwMDAwMDAwMDAwMDAwMDAwMDAnLFxuXHQgICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuXHQgICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcblx0ICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuXHQgICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuXHQgICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcblx0ICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuXHQgICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnXG5cdCAgXTtcblxuXHQgIHZhciBncm91cFNpemVzID0gW1xuXHQgICAgMCwgMCxcblx0ICAgIDI1LCAxNiwgMTIsIDExLCAxMCwgOSwgOCxcblx0ICAgIDgsIDcsIDcsIDcsIDcsIDYsIDYsXG5cdCAgICA2LCA2LCA2LCA2LCA2LCA1LCA1LFxuXHQgICAgNSwgNSwgNSwgNSwgNSwgNSwgNSxcblx0ICAgIDUsIDUsIDUsIDUsIDUsIDUsIDVcblx0ICBdO1xuXG5cdCAgdmFyIGdyb3VwQmFzZXMgPSBbXG5cdCAgICAwLCAwLFxuXHQgICAgMzM1NTQ0MzIsIDQzMDQ2NzIxLCAxNjc3NzIxNiwgNDg4MjgxMjUsIDYwNDY2MTc2LCA0MDM1MzYwNywgMTY3NzcyMTYsXG5cdCAgICA0MzA0NjcyMSwgMTAwMDAwMDAsIDE5NDg3MTcxLCAzNTgzMTgwOCwgNjI3NDg1MTcsIDc1Mjk1MzYsIDExMzkwNjI1LFxuXHQgICAgMTY3NzcyMTYsIDI0MTM3NTY5LCAzNDAxMjIyNCwgNDcwNDU4ODEsIDY0MDAwMDAwLCA0MDg0MTAxLCA1MTUzNjMyLFxuXHQgICAgNjQzNjM0MywgNzk2MjYyNCwgOTc2NTYyNSwgMTE4ODEzNzYsIDE0MzQ4OTA3LCAxNzIxMDM2OCwgMjA1MTExNDksXG5cdCAgICAyNDMwMDAwMCwgMjg2MjkxNTEsIDMzNTU0NDMyLCAzOTEzNTM5MywgNDU0MzU0MjQsIDUyNTIxODc1LCA2MDQ2NjE3NlxuXHQgIF07XG5cblx0ICBCTi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoYmFzZSwgcGFkZGluZykge1xuXHQgICAgYmFzZSA9IGJhc2UgfHwgMTA7XG5cdCAgICBwYWRkaW5nID0gcGFkZGluZyB8IDAgfHwgMTtcblxuXHQgICAgdmFyIG91dDtcblx0ICAgIGlmIChiYXNlID09PSAxNiB8fCBiYXNlID09PSAnaGV4Jykge1xuXHQgICAgICBvdXQgPSAnJztcblx0ICAgICAgdmFyIG9mZiA9IDA7XG5cdCAgICAgIHZhciBjYXJyeSA9IDA7XG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHZhciB3ID0gdGhpcy53b3Jkc1tpXTtcblx0ICAgICAgICB2YXIgd29yZCA9ICgoKHcgPDwgb2ZmKSB8IGNhcnJ5KSAmIDB4ZmZmZmZmKS50b1N0cmluZygxNik7XG5cdCAgICAgICAgY2FycnkgPSAodyA+Pj4gKDI0IC0gb2ZmKSkgJiAweGZmZmZmZjtcblx0ICAgICAgICBpZiAoY2FycnkgIT09IDAgfHwgaSAhPT0gdGhpcy5sZW5ndGggLSAxKSB7XG5cdCAgICAgICAgICBvdXQgPSB6ZXJvc1s2IC0gd29yZC5sZW5ndGhdICsgd29yZCArIG91dDtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgb3V0ID0gd29yZCArIG91dDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgb2ZmICs9IDI7XG5cdCAgICAgICAgaWYgKG9mZiA+PSAyNikge1xuXHQgICAgICAgICAgb2ZmIC09IDI2O1xuXHQgICAgICAgICAgaS0tO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICBpZiAoY2FycnkgIT09IDApIHtcblx0ICAgICAgICBvdXQgPSBjYXJyeS50b1N0cmluZygxNikgKyBvdXQ7XG5cdCAgICAgIH1cblx0ICAgICAgd2hpbGUgKG91dC5sZW5ndGggJSBwYWRkaW5nICE9PSAwKSB7XG5cdCAgICAgICAgb3V0ID0gJzAnICsgb3V0O1xuXHQgICAgICB9XG5cdCAgICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG5cdCAgICAgICAgb3V0ID0gJy0nICsgb3V0O1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBvdXQ7XG5cdCAgICB9XG5cblx0ICAgIGlmIChiYXNlID09PSAoYmFzZSB8IDApICYmIGJhc2UgPj0gMiAmJiBiYXNlIDw9IDM2KSB7XG5cdCAgICAgIC8vIHZhciBncm91cFNpemUgPSBNYXRoLmZsb29yKEJOLndvcmRTaXplICogTWF0aC5MTjIgLyBNYXRoLmxvZyhiYXNlKSk7XG5cdCAgICAgIHZhciBncm91cFNpemUgPSBncm91cFNpemVzW2Jhc2VdO1xuXHQgICAgICAvLyB2YXIgZ3JvdXBCYXNlID0gTWF0aC5wb3coYmFzZSwgZ3JvdXBTaXplKTtcblx0ICAgICAgdmFyIGdyb3VwQmFzZSA9IGdyb3VwQmFzZXNbYmFzZV07XG5cdCAgICAgIG91dCA9ICcnO1xuXHQgICAgICB2YXIgYyA9IHRoaXMuY2xvbmUoKTtcblx0ICAgICAgYy5uZWdhdGl2ZSA9IDA7XG5cdCAgICAgIHdoaWxlICghYy5pc1plcm8oKSkge1xuXHQgICAgICAgIHZhciByID0gYy5tb2RuKGdyb3VwQmFzZSkudG9TdHJpbmcoYmFzZSk7XG5cdCAgICAgICAgYyA9IGMuaWRpdm4oZ3JvdXBCYXNlKTtcblxuXHQgICAgICAgIGlmICghYy5pc1plcm8oKSkge1xuXHQgICAgICAgICAgb3V0ID0gemVyb3NbZ3JvdXBTaXplIC0gci5sZW5ndGhdICsgciArIG91dDtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgb3V0ID0gciArIG91dDtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKHRoaXMuaXNaZXJvKCkpIHtcblx0ICAgICAgICBvdXQgPSAnMCcgKyBvdXQ7XG5cdCAgICAgIH1cblx0ICAgICAgd2hpbGUgKG91dC5sZW5ndGggJSBwYWRkaW5nICE9PSAwKSB7XG5cdCAgICAgICAgb3V0ID0gJzAnICsgb3V0O1xuXHQgICAgICB9XG5cdCAgICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG5cdCAgICAgICAgb3V0ID0gJy0nICsgb3V0O1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBvdXQ7XG5cdCAgICB9XG5cblx0ICAgIGFzc2VydChmYWxzZSwgJ0Jhc2Ugc2hvdWxkIGJlIGJldHdlZW4gMiBhbmQgMzYnKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLnRvTnVtYmVyID0gZnVuY3Rpb24gdG9OdW1iZXIgKCkge1xuXHQgICAgdmFyIHJldCA9IHRoaXMud29yZHNbMF07XG5cdCAgICBpZiAodGhpcy5sZW5ndGggPT09IDIpIHtcblx0ICAgICAgcmV0ICs9IHRoaXMud29yZHNbMV0gKiAweDQwMDAwMDA7XG5cdCAgICB9IGVsc2UgaWYgKHRoaXMubGVuZ3RoID09PSAzICYmIHRoaXMud29yZHNbMl0gPT09IDB4MDEpIHtcblx0ICAgICAgLy8gTk9URTogYXQgdGhpcyBzdGFnZSBpdCBpcyBrbm93biB0aGF0IHRoZSB0b3AgYml0IGlzIHNldFxuXHQgICAgICByZXQgKz0gMHgxMDAwMDAwMDAwMDAwMCArICh0aGlzLndvcmRzWzFdICogMHg0MDAwMDAwKTtcblx0ICAgIH0gZWxzZSBpZiAodGhpcy5sZW5ndGggPiAyKSB7XG5cdCAgICAgIGFzc2VydChmYWxzZSwgJ051bWJlciBjYW4gb25seSBzYWZlbHkgc3RvcmUgdXAgdG8gNTMgYml0cycpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuICh0aGlzLm5lZ2F0aXZlICE9PSAwKSA/IC1yZXQgOiByZXQ7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuXHQgICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoMTYpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUudG9CdWZmZXIgPSBmdW5jdGlvbiB0b0J1ZmZlciAoZW5kaWFuLCBsZW5ndGgpIHtcblx0ICAgIGFzc2VydCh0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJyk7XG5cdCAgICByZXR1cm4gdGhpcy50b0FycmF5TGlrZShCdWZmZXIsIGVuZGlhbiwgbGVuZ3RoKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiB0b0FycmF5IChlbmRpYW4sIGxlbmd0aCkge1xuXHQgICAgcmV0dXJuIHRoaXMudG9BcnJheUxpa2UoQXJyYXksIGVuZGlhbiwgbGVuZ3RoKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLnRvQXJyYXlMaWtlID0gZnVuY3Rpb24gdG9BcnJheUxpa2UgKEFycmF5VHlwZSwgZW5kaWFuLCBsZW5ndGgpIHtcblx0ICAgIHZhciBieXRlTGVuZ3RoID0gdGhpcy5ieXRlTGVuZ3RoKCk7XG5cdCAgICB2YXIgcmVxTGVuZ3RoID0gbGVuZ3RoIHx8IE1hdGgubWF4KDEsIGJ5dGVMZW5ndGgpO1xuXHQgICAgYXNzZXJ0KGJ5dGVMZW5ndGggPD0gcmVxTGVuZ3RoLCAnYnl0ZSBhcnJheSBsb25nZXIgdGhhbiBkZXNpcmVkIGxlbmd0aCcpO1xuXHQgICAgYXNzZXJ0KHJlcUxlbmd0aCA+IDAsICdSZXF1ZXN0ZWQgYXJyYXkgbGVuZ3RoIDw9IDAnKTtcblxuXHQgICAgdGhpcy5zdHJpcCgpO1xuXHQgICAgdmFyIGxpdHRsZUVuZGlhbiA9IGVuZGlhbiA9PT0gJ2xlJztcblx0ICAgIHZhciByZXMgPSBuZXcgQXJyYXlUeXBlKHJlcUxlbmd0aCk7XG5cblx0ICAgIHZhciBiLCBpO1xuXHQgICAgdmFyIHEgPSB0aGlzLmNsb25lKCk7XG5cdCAgICBpZiAoIWxpdHRsZUVuZGlhbikge1xuXHQgICAgICAvLyBBc3N1bWUgYmlnLWVuZGlhblxuXHQgICAgICBmb3IgKGkgPSAwOyBpIDwgcmVxTGVuZ3RoIC0gYnl0ZUxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgcmVzW2ldID0gMDtcblx0ICAgICAgfVxuXG5cdCAgICAgIGZvciAoaSA9IDA7ICFxLmlzWmVybygpOyBpKyspIHtcblx0ICAgICAgICBiID0gcS5hbmRsbigweGZmKTtcblx0ICAgICAgICBxLml1c2hybig4KTtcblxuXHQgICAgICAgIHJlc1tyZXFMZW5ndGggLSBpIC0gMV0gPSBiO1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBmb3IgKGkgPSAwOyAhcS5pc1plcm8oKTsgaSsrKSB7XG5cdCAgICAgICAgYiA9IHEuYW5kbG4oMHhmZik7XG5cdCAgICAgICAgcS5pdXNocm4oOCk7XG5cblx0ICAgICAgICByZXNbaV0gPSBiO1xuXHQgICAgICB9XG5cblx0ICAgICAgZm9yICg7IGkgPCByZXFMZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHJlc1tpXSA9IDA7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHJlcztcblx0ICB9O1xuXG5cdCAgaWYgKE1hdGguY2x6MzIpIHtcblx0ICAgIEJOLnByb3RvdHlwZS5fY291bnRCaXRzID0gZnVuY3Rpb24gX2NvdW50Qml0cyAodykge1xuXHQgICAgICByZXR1cm4gMzIgLSBNYXRoLmNsejMyKHcpO1xuXHQgICAgfTtcblx0ICB9IGVsc2Uge1xuXHQgICAgQk4ucHJvdG90eXBlLl9jb3VudEJpdHMgPSBmdW5jdGlvbiBfY291bnRCaXRzICh3KSB7XG5cdCAgICAgIHZhciB0ID0gdztcblx0ICAgICAgdmFyIHIgPSAwO1xuXHQgICAgICBpZiAodCA+PSAweDEwMDApIHtcblx0ICAgICAgICByICs9IDEzO1xuXHQgICAgICAgIHQgPj4+PSAxMztcblx0ICAgICAgfVxuXHQgICAgICBpZiAodCA+PSAweDQwKSB7XG5cdCAgICAgICAgciArPSA3O1xuXHQgICAgICAgIHQgPj4+PSA3O1xuXHQgICAgICB9XG5cdCAgICAgIGlmICh0ID49IDB4OCkge1xuXHQgICAgICAgIHIgKz0gNDtcblx0ICAgICAgICB0ID4+Pj0gNDtcblx0ICAgICAgfVxuXHQgICAgICBpZiAodCA+PSAweDAyKSB7XG5cdCAgICAgICAgciArPSAyO1xuXHQgICAgICAgIHQgPj4+PSAyO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiByICsgdDtcblx0ICAgIH07XG5cdCAgfVxuXG5cdCAgQk4ucHJvdG90eXBlLl96ZXJvQml0cyA9IGZ1bmN0aW9uIF96ZXJvQml0cyAodykge1xuXHQgICAgLy8gU2hvcnQtY3V0XG5cdCAgICBpZiAodyA9PT0gMCkgcmV0dXJuIDI2O1xuXG5cdCAgICB2YXIgdCA9IHc7XG5cdCAgICB2YXIgciA9IDA7XG5cdCAgICBpZiAoKHQgJiAweDFmZmYpID09PSAwKSB7XG5cdCAgICAgIHIgKz0gMTM7XG5cdCAgICAgIHQgPj4+PSAxMztcblx0ICAgIH1cblx0ICAgIGlmICgodCAmIDB4N2YpID09PSAwKSB7XG5cdCAgICAgIHIgKz0gNztcblx0ICAgICAgdCA+Pj49IDc7XG5cdCAgICB9XG5cdCAgICBpZiAoKHQgJiAweGYpID09PSAwKSB7XG5cdCAgICAgIHIgKz0gNDtcblx0ICAgICAgdCA+Pj49IDQ7XG5cdCAgICB9XG5cdCAgICBpZiAoKHQgJiAweDMpID09PSAwKSB7XG5cdCAgICAgIHIgKz0gMjtcblx0ICAgICAgdCA+Pj49IDI7XG5cdCAgICB9XG5cdCAgICBpZiAoKHQgJiAweDEpID09PSAwKSB7XG5cdCAgICAgIHIrKztcblx0ICAgIH1cblx0ICAgIHJldHVybiByO1xuXHQgIH07XG5cblx0ICAvLyBSZXR1cm4gbnVtYmVyIG9mIHVzZWQgYml0cyBpbiBhIEJOXG5cdCAgQk4ucHJvdG90eXBlLmJpdExlbmd0aCA9IGZ1bmN0aW9uIGJpdExlbmd0aCAoKSB7XG5cdCAgICB2YXIgdyA9IHRoaXMud29yZHNbdGhpcy5sZW5ndGggLSAxXTtcblx0ICAgIHZhciBoaSA9IHRoaXMuX2NvdW50Qml0cyh3KTtcblx0ICAgIHJldHVybiAodGhpcy5sZW5ndGggLSAxKSAqIDI2ICsgaGk7XG5cdCAgfTtcblxuXHQgIGZ1bmN0aW9uIHRvQml0QXJyYXkgKG51bSkge1xuXHQgICAgdmFyIHcgPSBuZXcgQXJyYXkobnVtLmJpdExlbmd0aCgpKTtcblxuXHQgICAgZm9yICh2YXIgYml0ID0gMDsgYml0IDwgdy5sZW5ndGg7IGJpdCsrKSB7XG5cdCAgICAgIHZhciBvZmYgPSAoYml0IC8gMjYpIHwgMDtcblx0ICAgICAgdmFyIHdiaXQgPSBiaXQgJSAyNjtcblxuXHQgICAgICB3W2JpdF0gPSAobnVtLndvcmRzW29mZl0gJiAoMSA8PCB3Yml0KSkgPj4+IHdiaXQ7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB3O1xuXHQgIH1cblxuXHQgIC8vIE51bWJlciBvZiB0cmFpbGluZyB6ZXJvIGJpdHNcblx0ICBCTi5wcm90b3R5cGUuemVyb0JpdHMgPSBmdW5jdGlvbiB6ZXJvQml0cyAoKSB7XG5cdCAgICBpZiAodGhpcy5pc1plcm8oKSkgcmV0dXJuIDA7XG5cblx0ICAgIHZhciByID0gMDtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICB2YXIgYiA9IHRoaXMuX3plcm9CaXRzKHRoaXMud29yZHNbaV0pO1xuXHQgICAgICByICs9IGI7XG5cdCAgICAgIGlmIChiICE9PSAyNikgYnJlYWs7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcjtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmJ5dGVMZW5ndGggPSBmdW5jdGlvbiBieXRlTGVuZ3RoICgpIHtcblx0ICAgIHJldHVybiBNYXRoLmNlaWwodGhpcy5iaXRMZW5ndGgoKSAvIDgpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUudG9Ud29zID0gZnVuY3Rpb24gdG9Ud29zICh3aWR0aCkge1xuXHQgICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuYWJzKCkuaW5vdG4od2lkdGgpLmlhZGRuKDEpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHRoaXMuY2xvbmUoKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmZyb21Ud29zID0gZnVuY3Rpb24gZnJvbVR3b3MgKHdpZHRoKSB7XG5cdCAgICBpZiAodGhpcy50ZXN0bih3aWR0aCAtIDEpKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLm5vdG4od2lkdGgpLmlhZGRuKDEpLmluZWcoKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB0aGlzLmNsb25lKCk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5pc05lZyA9IGZ1bmN0aW9uIGlzTmVnICgpIHtcblx0ICAgIHJldHVybiB0aGlzLm5lZ2F0aXZlICE9PSAwO1xuXHQgIH07XG5cblx0ICAvLyBSZXR1cm4gbmVnYXRpdmUgY2xvbmUgb2YgYHRoaXNgXG5cdCAgQk4ucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uIG5lZyAoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmluZWcoKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmluZWcgPSBmdW5jdGlvbiBpbmVnICgpIHtcblx0ICAgIGlmICghdGhpcy5pc1plcm8oKSkge1xuXHQgICAgICB0aGlzLm5lZ2F0aXZlIF49IDE7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cblx0ICAvLyBPciBgbnVtYCB3aXRoIGB0aGlzYCBpbi1wbGFjZVxuXHQgIEJOLnByb3RvdHlwZS5pdW9yID0gZnVuY3Rpb24gaXVvciAobnVtKSB7XG5cdCAgICB3aGlsZSAodGhpcy5sZW5ndGggPCBudW0ubGVuZ3RoKSB7XG5cdCAgICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGgrK10gPSAwO1xuXHQgICAgfVxuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xuXHQgICAgICB0aGlzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXSB8IG51bS53b3Jkc1tpXTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmlvciA9IGZ1bmN0aW9uIGlvciAobnVtKSB7XG5cdCAgICBhc3NlcnQoKHRoaXMubmVnYXRpdmUgfCBudW0ubmVnYXRpdmUpID09PSAwKTtcblx0ICAgIHJldHVybiB0aGlzLml1b3IobnVtKTtcblx0ICB9O1xuXG5cdCAgLy8gT3IgYG51bWAgd2l0aCBgdGhpc2Bcblx0ICBCTi5wcm90b3R5cGUub3IgPSBmdW5jdGlvbiBvciAobnVtKSB7XG5cdCAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLmlvcihudW0pO1xuXHQgICAgcmV0dXJuIG51bS5jbG9uZSgpLmlvcih0aGlzKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLnVvciA9IGZ1bmN0aW9uIHVvciAobnVtKSB7XG5cdCAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLml1b3IobnVtKTtcblx0ICAgIHJldHVybiBudW0uY2xvbmUoKS5pdW9yKHRoaXMpO1xuXHQgIH07XG5cblx0ICAvLyBBbmQgYG51bWAgd2l0aCBgdGhpc2AgaW4tcGxhY2Vcblx0ICBCTi5wcm90b3R5cGUuaXVhbmQgPSBmdW5jdGlvbiBpdWFuZCAobnVtKSB7XG5cdCAgICAvLyBiID0gbWluLWxlbmd0aChudW0sIHRoaXMpXG5cdCAgICB2YXIgYjtcblx0ICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHtcblx0ICAgICAgYiA9IG51bTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGIgPSB0aGlzO1xuXHQgICAgfVxuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdGhpcy53b3Jkc1tpXSA9IHRoaXMud29yZHNbaV0gJiBudW0ud29yZHNbaV07XG5cdCAgICB9XG5cblx0ICAgIHRoaXMubGVuZ3RoID0gYi5sZW5ndGg7XG5cblx0ICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5pYW5kID0gZnVuY3Rpb24gaWFuZCAobnVtKSB7XG5cdCAgICBhc3NlcnQoKHRoaXMubmVnYXRpdmUgfCBudW0ubmVnYXRpdmUpID09PSAwKTtcblx0ICAgIHJldHVybiB0aGlzLml1YW5kKG51bSk7XG5cdCAgfTtcblxuXHQgIC8vIEFuZCBgbnVtYCB3aXRoIGB0aGlzYFxuXHQgIEJOLnByb3RvdHlwZS5hbmQgPSBmdW5jdGlvbiBhbmQgKG51bSkge1xuXHQgICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYW5kKG51bSk7XG5cdCAgICByZXR1cm4gbnVtLmNsb25lKCkuaWFuZCh0aGlzKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLnVhbmQgPSBmdW5jdGlvbiB1YW5kIChudW0pIHtcblx0ICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaXVhbmQobnVtKTtcblx0ICAgIHJldHVybiBudW0uY2xvbmUoKS5pdWFuZCh0aGlzKTtcblx0ICB9O1xuXG5cdCAgLy8gWG9yIGBudW1gIHdpdGggYHRoaXNgIGluLXBsYWNlXG5cdCAgQk4ucHJvdG90eXBlLml1eG9yID0gZnVuY3Rpb24gaXV4b3IgKG51bSkge1xuXHQgICAgLy8gYS5sZW5ndGggPiBiLmxlbmd0aFxuXHQgICAgdmFyIGE7XG5cdCAgICB2YXIgYjtcblx0ICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHtcblx0ICAgICAgYSA9IHRoaXM7XG5cdCAgICAgIGIgPSBudW07XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBhID0gbnVtO1xuXHQgICAgICBiID0gdGhpcztcblx0ICAgIH1cblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHRoaXMud29yZHNbaV0gPSBhLndvcmRzW2ldIF4gYi53b3Jkc1tpXTtcblx0ICAgIH1cblxuXHQgICAgaWYgKHRoaXMgIT09IGEpIHtcblx0ICAgICAgZm9yICg7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV07XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgdGhpcy5sZW5ndGggPSBhLmxlbmd0aDtcblxuXHQgICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLml4b3IgPSBmdW5jdGlvbiBpeG9yIChudW0pIHtcblx0ICAgIGFzc2VydCgodGhpcy5uZWdhdGl2ZSB8IG51bS5uZWdhdGl2ZSkgPT09IDApO1xuXHQgICAgcmV0dXJuIHRoaXMuaXV4b3IobnVtKTtcblx0ICB9O1xuXG5cdCAgLy8gWG9yIGBudW1gIHdpdGggYHRoaXNgXG5cdCAgQk4ucHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uIHhvciAobnVtKSB7XG5cdCAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLml4b3IobnVtKTtcblx0ICAgIHJldHVybiBudW0uY2xvbmUoKS5peG9yKHRoaXMpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUudXhvciA9IGZ1bmN0aW9uIHV4b3IgKG51bSkge1xuXHQgICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdXhvcihudW0pO1xuXHQgICAgcmV0dXJuIG51bS5jbG9uZSgpLml1eG9yKHRoaXMpO1xuXHQgIH07XG5cblx0ICAvLyBOb3QgYGB0aGlzYGAgd2l0aCBgYHdpZHRoYGAgYml0d2lkdGhcblx0ICBCTi5wcm90b3R5cGUuaW5vdG4gPSBmdW5jdGlvbiBpbm90biAod2lkdGgpIHtcblx0ICAgIGFzc2VydCh0eXBlb2Ygd2lkdGggPT09ICdudW1iZXInICYmIHdpZHRoID49IDApO1xuXG5cdCAgICB2YXIgYnl0ZXNOZWVkZWQgPSBNYXRoLmNlaWwod2lkdGggLyAyNikgfCAwO1xuXHQgICAgdmFyIGJpdHNMZWZ0ID0gd2lkdGggJSAyNjtcblxuXHQgICAgLy8gRXh0ZW5kIHRoZSBidWZmZXIgd2l0aCBsZWFkaW5nIHplcm9lc1xuXHQgICAgdGhpcy5fZXhwYW5kKGJ5dGVzTmVlZGVkKTtcblxuXHQgICAgaWYgKGJpdHNMZWZ0ID4gMCkge1xuXHQgICAgICBieXRlc05lZWRlZC0tO1xuXHQgICAgfVxuXG5cdCAgICAvLyBIYW5kbGUgY29tcGxldGUgd29yZHNcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXNOZWVkZWQ7IGkrKykge1xuXHQgICAgICB0aGlzLndvcmRzW2ldID0gfnRoaXMud29yZHNbaV0gJiAweDNmZmZmZmY7XG5cdCAgICB9XG5cblx0ICAgIC8vIEhhbmRsZSB0aGUgcmVzaWR1ZVxuXHQgICAgaWYgKGJpdHNMZWZ0ID4gMCkge1xuXHQgICAgICB0aGlzLndvcmRzW2ldID0gfnRoaXMud29yZHNbaV0gJiAoMHgzZmZmZmZmID4+ICgyNiAtIGJpdHNMZWZ0KSk7XG5cdCAgICB9XG5cblx0ICAgIC8vIEFuZCByZW1vdmUgbGVhZGluZyB6ZXJvZXNcblx0ICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5ub3RuID0gZnVuY3Rpb24gbm90biAod2lkdGgpIHtcblx0ICAgIHJldHVybiB0aGlzLmNsb25lKCkuaW5vdG4od2lkdGgpO1xuXHQgIH07XG5cblx0ICAvLyBTZXQgYGJpdGAgb2YgYHRoaXNgXG5cdCAgQk4ucHJvdG90eXBlLnNldG4gPSBmdW5jdGlvbiBzZXRuIChiaXQsIHZhbCkge1xuXHQgICAgYXNzZXJ0KHR5cGVvZiBiaXQgPT09ICdudW1iZXInICYmIGJpdCA+PSAwKTtcblxuXHQgICAgdmFyIG9mZiA9IChiaXQgLyAyNikgfCAwO1xuXHQgICAgdmFyIHdiaXQgPSBiaXQgJSAyNjtcblxuXHQgICAgdGhpcy5fZXhwYW5kKG9mZiArIDEpO1xuXG5cdCAgICBpZiAodmFsKSB7XG5cdCAgICAgIHRoaXMud29yZHNbb2ZmXSA9IHRoaXMud29yZHNbb2ZmXSB8ICgxIDw8IHdiaXQpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdGhpcy53b3Jkc1tvZmZdID0gdGhpcy53b3Jkc1tvZmZdICYgfigxIDw8IHdiaXQpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuXHQgIH07XG5cblx0ICAvLyBBZGQgYG51bWAgdG8gYHRoaXNgIGluLXBsYWNlXG5cdCAgQk4ucHJvdG90eXBlLmlhZGQgPSBmdW5jdGlvbiBpYWRkIChudW0pIHtcblx0ICAgIHZhciByO1xuXG5cdCAgICAvLyBuZWdhdGl2ZSArIHBvc2l0aXZlXG5cdCAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiBudW0ubmVnYXRpdmUgPT09IDApIHtcblx0ICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG5cdCAgICAgIHIgPSB0aGlzLmlzdWIobnVtKTtcblx0ICAgICAgdGhpcy5uZWdhdGl2ZSBePSAxO1xuXHQgICAgICByZXR1cm4gdGhpcy5fbm9ybVNpZ24oKTtcblxuXHQgICAgLy8gcG9zaXRpdmUgKyBuZWdhdGl2ZVxuXHQgICAgfSBlbHNlIGlmICh0aGlzLm5lZ2F0aXZlID09PSAwICYmIG51bS5uZWdhdGl2ZSAhPT0gMCkge1xuXHQgICAgICBudW0ubmVnYXRpdmUgPSAwO1xuXHQgICAgICByID0gdGhpcy5pc3ViKG51bSk7XG5cdCAgICAgIG51bS5uZWdhdGl2ZSA9IDE7XG5cdCAgICAgIHJldHVybiByLl9ub3JtU2lnbigpO1xuXHQgICAgfVxuXG5cdCAgICAvLyBhLmxlbmd0aCA+IGIubGVuZ3RoXG5cdCAgICB2YXIgYSwgYjtcblx0ICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHtcblx0ICAgICAgYSA9IHRoaXM7XG5cdCAgICAgIGIgPSBudW07XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBhID0gbnVtO1xuXHQgICAgICBiID0gdGhpcztcblx0ICAgIH1cblxuXHQgICAgdmFyIGNhcnJ5ID0gMDtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuXHQgICAgICByID0gKGEud29yZHNbaV0gfCAwKSArIChiLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcblx0ICAgICAgdGhpcy53b3Jkc1tpXSA9IHIgJiAweDNmZmZmZmY7XG5cdCAgICAgIGNhcnJ5ID0gciA+Pj4gMjY7XG5cdCAgICB9XG5cdCAgICBmb3IgKDsgY2FycnkgIT09IDAgJiYgaSA8IGEubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgciA9IChhLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcblx0ICAgICAgdGhpcy53b3Jkc1tpXSA9IHIgJiAweDNmZmZmZmY7XG5cdCAgICAgIGNhcnJ5ID0gciA+Pj4gMjY7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMubGVuZ3RoID0gYS5sZW5ndGg7XG5cdCAgICBpZiAoY2FycnkgIT09IDApIHtcblx0ICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aF0gPSBjYXJyeTtcblx0ICAgICAgdGhpcy5sZW5ndGgrKztcblx0ICAgIC8vIENvcHkgdGhlIHJlc3Qgb2YgdGhlIHdvcmRzXG5cdCAgICB9IGVsc2UgaWYgKGEgIT09IHRoaXMpIHtcblx0ICAgICAgZm9yICg7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV07XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblxuXHQgIC8vIEFkZCBgbnVtYCB0byBgdGhpc2Bcblx0ICBCTi5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChudW0pIHtcblx0ICAgIHZhciByZXM7XG5cdCAgICBpZiAobnVtLm5lZ2F0aXZlICE9PSAwICYmIHRoaXMubmVnYXRpdmUgPT09IDApIHtcblx0ICAgICAgbnVtLm5lZ2F0aXZlID0gMDtcblx0ICAgICAgcmVzID0gdGhpcy5zdWIobnVtKTtcblx0ICAgICAgbnVtLm5lZ2F0aXZlIF49IDE7XG5cdCAgICAgIHJldHVybiByZXM7XG5cdCAgICB9IGVsc2UgaWYgKG51bS5uZWdhdGl2ZSA9PT0gMCAmJiB0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG5cdCAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuXHQgICAgICByZXMgPSBudW0uc3ViKHRoaXMpO1xuXHQgICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcblx0ICAgICAgcmV0dXJuIHJlcztcblx0ICAgIH1cblxuXHQgICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYWRkKG51bSk7XG5cblx0ICAgIHJldHVybiBudW0uY2xvbmUoKS5pYWRkKHRoaXMpO1xuXHQgIH07XG5cblx0ICAvLyBTdWJ0cmFjdCBgbnVtYCBmcm9tIGB0aGlzYCBpbi1wbGFjZVxuXHQgIEJOLnByb3RvdHlwZS5pc3ViID0gZnVuY3Rpb24gaXN1YiAobnVtKSB7XG5cdCAgICAvLyB0aGlzIC0gKC1udW0pID0gdGhpcyArIG51bVxuXHQgICAgaWYgKG51bS5uZWdhdGl2ZSAhPT0gMCkge1xuXHQgICAgICBudW0ubmVnYXRpdmUgPSAwO1xuXHQgICAgICB2YXIgciA9IHRoaXMuaWFkZChudW0pO1xuXHQgICAgICBudW0ubmVnYXRpdmUgPSAxO1xuXHQgICAgICByZXR1cm4gci5fbm9ybVNpZ24oKTtcblxuXHQgICAgLy8gLXRoaXMgLSBudW0gPSAtKHRoaXMgKyBudW0pXG5cdCAgICB9IGVsc2UgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcblx0ICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG5cdCAgICAgIHRoaXMuaWFkZChudW0pO1xuXHQgICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcblx0ICAgICAgcmV0dXJuIHRoaXMuX25vcm1TaWduKCk7XG5cdCAgICB9XG5cblx0ICAgIC8vIEF0IHRoaXMgcG9pbnQgYm90aCBudW1iZXJzIGFyZSBwb3NpdGl2ZVxuXHQgICAgdmFyIGNtcCA9IHRoaXMuY21wKG51bSk7XG5cblx0ICAgIC8vIE9wdGltaXphdGlvbiAtIHplcm9pZnlcblx0ICAgIGlmIChjbXAgPT09IDApIHtcblx0ICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG5cdCAgICAgIHRoaXMubGVuZ3RoID0gMTtcblx0ICAgICAgdGhpcy53b3Jkc1swXSA9IDA7XG5cdCAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfVxuXG5cdCAgICAvLyBhID4gYlxuXHQgICAgdmFyIGEsIGI7XG5cdCAgICBpZiAoY21wID4gMCkge1xuXHQgICAgICBhID0gdGhpcztcblx0ICAgICAgYiA9IG51bTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGEgPSBudW07XG5cdCAgICAgIGIgPSB0aGlzO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgY2FycnkgPSAwO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHIgPSAoYS53b3Jkc1tpXSB8IDApIC0gKGIud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuXHQgICAgICBjYXJyeSA9IHIgPj4gMjY7XG5cdCAgICAgIHRoaXMud29yZHNbaV0gPSByICYgMHgzZmZmZmZmO1xuXHQgICAgfVxuXHQgICAgZm9yICg7IGNhcnJ5ICE9PSAwICYmIGkgPCBhLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHIgPSAoYS53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG5cdCAgICAgIGNhcnJ5ID0gciA+PiAyNjtcblx0ICAgICAgdGhpcy53b3Jkc1tpXSA9IHIgJiAweDNmZmZmZmY7XG5cdCAgICB9XG5cblx0ICAgIC8vIENvcHkgcmVzdCBvZiB0aGUgd29yZHNcblx0ICAgIGlmIChjYXJyeSA9PT0gMCAmJiBpIDwgYS5sZW5ndGggJiYgYSAhPT0gdGhpcykge1xuXHQgICAgICBmb3IgKDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICB0aGlzLmxlbmd0aCA9IE1hdGgubWF4KHRoaXMubGVuZ3RoLCBpKTtcblxuXHQgICAgaWYgKGEgIT09IHRoaXMpIHtcblx0ICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG5cdCAgfTtcblxuXHQgIC8vIFN1YnRyYWN0IGBudW1gIGZyb20gYHRoaXNgXG5cdCAgQk4ucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uIHN1YiAobnVtKSB7XG5cdCAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzdWIobnVtKTtcblx0ICB9O1xuXG5cdCAgZnVuY3Rpb24gc21hbGxNdWxUbyAoc2VsZiwgbnVtLCBvdXQpIHtcblx0ICAgIG91dC5uZWdhdGl2ZSA9IG51bS5uZWdhdGl2ZSBeIHNlbGYubmVnYXRpdmU7XG5cdCAgICB2YXIgbGVuID0gKHNlbGYubGVuZ3RoICsgbnVtLmxlbmd0aCkgfCAwO1xuXHQgICAgb3V0Lmxlbmd0aCA9IGxlbjtcblx0ICAgIGxlbiA9IChsZW4gLSAxKSB8IDA7XG5cblx0ICAgIC8vIFBlZWwgb25lIGl0ZXJhdGlvbiAoY29tcGlsZXIgY2FuJ3QgZG8gaXQsIGJlY2F1c2Ugb2YgY29kZSBjb21wbGV4aXR5KVxuXHQgICAgdmFyIGEgPSBzZWxmLndvcmRzWzBdIHwgMDtcblx0ICAgIHZhciBiID0gbnVtLndvcmRzWzBdIHwgMDtcblx0ICAgIHZhciByID0gYSAqIGI7XG5cblx0ICAgIHZhciBsbyA9IHIgJiAweDNmZmZmZmY7XG5cdCAgICB2YXIgY2FycnkgPSAociAvIDB4NDAwMDAwMCkgfCAwO1xuXHQgICAgb3V0LndvcmRzWzBdID0gbG87XG5cblx0ICAgIGZvciAodmFyIGsgPSAxOyBrIDwgbGVuOyBrKyspIHtcblx0ICAgICAgLy8gU3VtIGFsbCB3b3JkcyB3aXRoIHRoZSBzYW1lIGBpICsgaiA9IGtgIGFuZCBhY2N1bXVsYXRlIGBuY2FycnlgLFxuXHQgICAgICAvLyBub3RlIHRoYXQgbmNhcnJ5IGNvdWxkIGJlID49IDB4M2ZmZmZmZlxuXHQgICAgICB2YXIgbmNhcnJ5ID0gY2FycnkgPj4+IDI2O1xuXHQgICAgICB2YXIgcndvcmQgPSBjYXJyeSAmIDB4M2ZmZmZmZjtcblx0ICAgICAgdmFyIG1heEogPSBNYXRoLm1pbihrLCBudW0ubGVuZ3RoIC0gMSk7XG5cdCAgICAgIGZvciAodmFyIGogPSBNYXRoLm1heCgwLCBrIC0gc2VsZi5sZW5ndGggKyAxKTsgaiA8PSBtYXhKOyBqKyspIHtcblx0ICAgICAgICB2YXIgaSA9IChrIC0gaikgfCAwO1xuXHQgICAgICAgIGEgPSBzZWxmLndvcmRzW2ldIHwgMDtcblx0ICAgICAgICBiID0gbnVtLndvcmRzW2pdIHwgMDtcblx0ICAgICAgICByID0gYSAqIGIgKyByd29yZDtcblx0ICAgICAgICBuY2FycnkgKz0gKHIgLyAweDQwMDAwMDApIHwgMDtcblx0ICAgICAgICByd29yZCA9IHIgJiAweDNmZmZmZmY7XG5cdCAgICAgIH1cblx0ICAgICAgb3V0LndvcmRzW2tdID0gcndvcmQgfCAwO1xuXHQgICAgICBjYXJyeSA9IG5jYXJyeSB8IDA7XG5cdCAgICB9XG5cdCAgICBpZiAoY2FycnkgIT09IDApIHtcblx0ICAgICAgb3V0LndvcmRzW2tdID0gY2FycnkgfCAwO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgb3V0Lmxlbmd0aC0tO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gb3V0LnN0cmlwKCk7XG5cdCAgfVxuXG5cdCAgLy8gVE9ETyhpbmR1dG55KTogaXQgbWF5IGJlIHJlYXNvbmFibGUgdG8gb21pdCBpdCBmb3IgdXNlcnMgd2hvIGRvbid0IG5lZWRcblx0ICAvLyB0byB3b3JrIHdpdGggMjU2LWJpdCBudW1iZXJzLCBvdGhlcndpc2UgaXQgZ2l2ZXMgMjAlIGltcHJvdmVtZW50IGZvciAyNTYtYml0XG5cdCAgLy8gbXVsdGlwbGljYXRpb24gKGxpa2UgZWxsaXB0aWMgc2VjcDI1NmsxKS5cblx0ICB2YXIgY29tYjEwTXVsVG8gPSBmdW5jdGlvbiBjb21iMTBNdWxUbyAoc2VsZiwgbnVtLCBvdXQpIHtcblx0ICAgIHZhciBhID0gc2VsZi53b3Jkcztcblx0ICAgIHZhciBiID0gbnVtLndvcmRzO1xuXHQgICAgdmFyIG8gPSBvdXQud29yZHM7XG5cdCAgICB2YXIgYyA9IDA7XG5cdCAgICB2YXIgbG87XG5cdCAgICB2YXIgbWlkO1xuXHQgICAgdmFyIGhpO1xuXHQgICAgdmFyIGEwID0gYVswXSB8IDA7XG5cdCAgICB2YXIgYWwwID0gYTAgJiAweDFmZmY7XG5cdCAgICB2YXIgYWgwID0gYTAgPj4+IDEzO1xuXHQgICAgdmFyIGExID0gYVsxXSB8IDA7XG5cdCAgICB2YXIgYWwxID0gYTEgJiAweDFmZmY7XG5cdCAgICB2YXIgYWgxID0gYTEgPj4+IDEzO1xuXHQgICAgdmFyIGEyID0gYVsyXSB8IDA7XG5cdCAgICB2YXIgYWwyID0gYTIgJiAweDFmZmY7XG5cdCAgICB2YXIgYWgyID0gYTIgPj4+IDEzO1xuXHQgICAgdmFyIGEzID0gYVszXSB8IDA7XG5cdCAgICB2YXIgYWwzID0gYTMgJiAweDFmZmY7XG5cdCAgICB2YXIgYWgzID0gYTMgPj4+IDEzO1xuXHQgICAgdmFyIGE0ID0gYVs0XSB8IDA7XG5cdCAgICB2YXIgYWw0ID0gYTQgJiAweDFmZmY7XG5cdCAgICB2YXIgYWg0ID0gYTQgPj4+IDEzO1xuXHQgICAgdmFyIGE1ID0gYVs1XSB8IDA7XG5cdCAgICB2YXIgYWw1ID0gYTUgJiAweDFmZmY7XG5cdCAgICB2YXIgYWg1ID0gYTUgPj4+IDEzO1xuXHQgICAgdmFyIGE2ID0gYVs2XSB8IDA7XG5cdCAgICB2YXIgYWw2ID0gYTYgJiAweDFmZmY7XG5cdCAgICB2YXIgYWg2ID0gYTYgPj4+IDEzO1xuXHQgICAgdmFyIGE3ID0gYVs3XSB8IDA7XG5cdCAgICB2YXIgYWw3ID0gYTcgJiAweDFmZmY7XG5cdCAgICB2YXIgYWg3ID0gYTcgPj4+IDEzO1xuXHQgICAgdmFyIGE4ID0gYVs4XSB8IDA7XG5cdCAgICB2YXIgYWw4ID0gYTggJiAweDFmZmY7XG5cdCAgICB2YXIgYWg4ID0gYTggPj4+IDEzO1xuXHQgICAgdmFyIGE5ID0gYVs5XSB8IDA7XG5cdCAgICB2YXIgYWw5ID0gYTkgJiAweDFmZmY7XG5cdCAgICB2YXIgYWg5ID0gYTkgPj4+IDEzO1xuXHQgICAgdmFyIGIwID0gYlswXSB8IDA7XG5cdCAgICB2YXIgYmwwID0gYjAgJiAweDFmZmY7XG5cdCAgICB2YXIgYmgwID0gYjAgPj4+IDEzO1xuXHQgICAgdmFyIGIxID0gYlsxXSB8IDA7XG5cdCAgICB2YXIgYmwxID0gYjEgJiAweDFmZmY7XG5cdCAgICB2YXIgYmgxID0gYjEgPj4+IDEzO1xuXHQgICAgdmFyIGIyID0gYlsyXSB8IDA7XG5cdCAgICB2YXIgYmwyID0gYjIgJiAweDFmZmY7XG5cdCAgICB2YXIgYmgyID0gYjIgPj4+IDEzO1xuXHQgICAgdmFyIGIzID0gYlszXSB8IDA7XG5cdCAgICB2YXIgYmwzID0gYjMgJiAweDFmZmY7XG5cdCAgICB2YXIgYmgzID0gYjMgPj4+IDEzO1xuXHQgICAgdmFyIGI0ID0gYls0XSB8IDA7XG5cdCAgICB2YXIgYmw0ID0gYjQgJiAweDFmZmY7XG5cdCAgICB2YXIgYmg0ID0gYjQgPj4+IDEzO1xuXHQgICAgdmFyIGI1ID0gYls1XSB8IDA7XG5cdCAgICB2YXIgYmw1ID0gYjUgJiAweDFmZmY7XG5cdCAgICB2YXIgYmg1ID0gYjUgPj4+IDEzO1xuXHQgICAgdmFyIGI2ID0gYls2XSB8IDA7XG5cdCAgICB2YXIgYmw2ID0gYjYgJiAweDFmZmY7XG5cdCAgICB2YXIgYmg2ID0gYjYgPj4+IDEzO1xuXHQgICAgdmFyIGI3ID0gYls3XSB8IDA7XG5cdCAgICB2YXIgYmw3ID0gYjcgJiAweDFmZmY7XG5cdCAgICB2YXIgYmg3ID0gYjcgPj4+IDEzO1xuXHQgICAgdmFyIGI4ID0gYls4XSB8IDA7XG5cdCAgICB2YXIgYmw4ID0gYjggJiAweDFmZmY7XG5cdCAgICB2YXIgYmg4ID0gYjggPj4+IDEzO1xuXHQgICAgdmFyIGI5ID0gYls5XSB8IDA7XG5cdCAgICB2YXIgYmw5ID0gYjkgJiAweDFmZmY7XG5cdCAgICB2YXIgYmg5ID0gYjkgPj4+IDEzO1xuXG5cdCAgICBvdXQubmVnYXRpdmUgPSBzZWxmLm5lZ2F0aXZlIF4gbnVtLm5lZ2F0aXZlO1xuXHQgICAgb3V0Lmxlbmd0aCA9IDE5O1xuXHQgICAgLyogayA9IDAgKi9cblx0ICAgIGxvID0gTWF0aC5pbXVsKGFsMCwgYmwwKTtcblx0ICAgIG1pZCA9IE1hdGguaW11bChhbDAsIGJoMCk7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmwwKSkgfCAwO1xuXHQgICAgaGkgPSBNYXRoLmltdWwoYWgwLCBiaDApO1xuXHQgICAgdmFyIHcwID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuXHQgICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcwID4+PiAyNikpIHwgMDtcblx0ICAgIHcwICY9IDB4M2ZmZmZmZjtcblx0ICAgIC8qIGsgPSAxICovXG5cdCAgICBsbyA9IE1hdGguaW11bChhbDEsIGJsMCk7XG5cdCAgICBtaWQgPSBNYXRoLmltdWwoYWwxLCBiaDApO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsMCkpIHwgMDtcblx0ICAgIGhpID0gTWF0aC5pbXVsKGFoMSwgYmgwKTtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmwxKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoMSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDEpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoMSkpIHwgMDtcblx0ICAgIHZhciB3MSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcblx0ICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MSA+Pj4gMjYpKSB8IDA7XG5cdCAgICB3MSAmPSAweDNmZmZmZmY7XG5cdCAgICAvKiBrID0gMiAqL1xuXHQgICAgbG8gPSBNYXRoLmltdWwoYWwyLCBibDApO1xuXHQgICAgbWlkID0gTWF0aC5pbXVsKGFsMiwgYmgwKTtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDApKSB8IDA7XG5cdCAgICBoaSA9IE1hdGguaW11bChhaDIsIGJoMCk7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsMSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDEpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmwxKSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDEpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsMikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDIpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmwyKSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDIpKSB8IDA7XG5cdCAgICB2YXIgdzIgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG5cdCAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzIgPj4+IDI2KSkgfCAwO1xuXHQgICAgdzIgJj0gMHgzZmZmZmZmO1xuXHQgICAgLyogayA9IDMgKi9cblx0ICAgIGxvID0gTWF0aC5pbXVsKGFsMywgYmwwKTtcblx0ICAgIG1pZCA9IE1hdGguaW11bChhbDMsIGJoMCk7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmwwKSkgfCAwO1xuXHQgICAgaGkgPSBNYXRoLmltdWwoYWgzLCBiaDApO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDEpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmgxKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsMSkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmgxKSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDIpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmgyKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsMikpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmgyKSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDMpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmgzKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsMykpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmgzKSkgfCAwO1xuXHQgICAgdmFyIHczID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuXHQgICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHczID4+PiAyNikpIHwgMDtcblx0ICAgIHczICY9IDB4M2ZmZmZmZjtcblx0ICAgIC8qIGsgPSA0ICovXG5cdCAgICBsbyA9IE1hdGguaW11bChhbDQsIGJsMCk7XG5cdCAgICBtaWQgPSBNYXRoLmltdWwoYWw0LCBiaDApO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsMCkpIHwgMDtcblx0ICAgIGhpID0gTWF0aC5pbXVsKGFoNCwgYmgwKTtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmwxKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoMSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDEpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoMSkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmwyKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoMikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDIpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoMikpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmwzKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoMykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDMpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoMykpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw0KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoNCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDQpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoNCkpIHwgMDtcblx0ICAgIHZhciB3NCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcblx0ICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3NCA+Pj4gMjYpKSB8IDA7XG5cdCAgICB3NCAmPSAweDNmZmZmZmY7XG5cdCAgICAvKiBrID0gNSAqL1xuXHQgICAgbG8gPSBNYXRoLmltdWwoYWw1LCBibDApO1xuXHQgICAgbWlkID0gTWF0aC5pbXVsKGFsNSwgYmgwKTtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDApKSB8IDA7XG5cdCAgICBoaSA9IE1hdGguaW11bChhaDUsIGJoMCk7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsMSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDEpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmwxKSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDEpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsMikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDIpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmwyKSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDIpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsMykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDMpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmwzKSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDMpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsNCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDQpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw0KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDQpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsNSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDUpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw1KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDUpKSB8IDA7XG5cdCAgICB2YXIgdzUgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG5cdCAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzUgPj4+IDI2KSkgfCAwO1xuXHQgICAgdzUgJj0gMHgzZmZmZmZmO1xuXHQgICAgLyogayA9IDYgKi9cblx0ICAgIGxvID0gTWF0aC5pbXVsKGFsNiwgYmwwKTtcblx0ICAgIG1pZCA9IE1hdGguaW11bChhbDYsIGJoMCk7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmwwKSkgfCAwO1xuXHQgICAgaGkgPSBNYXRoLmltdWwoYWg2LCBiaDApO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDEpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmgxKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsMSkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmgxKSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDIpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmgyKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsMikpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmgyKSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDMpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmgzKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsMykpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmgzKSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDQpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg0KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsNCkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg0KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDUpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg1KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsNSkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg1KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDYpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg2KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsNikpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg2KSkgfCAwO1xuXHQgICAgdmFyIHc2ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuXHQgICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc2ID4+PiAyNikpIHwgMDtcblx0ICAgIHc2ICY9IDB4M2ZmZmZmZjtcblx0ICAgIC8qIGsgPSA3ICovXG5cdCAgICBsbyA9IE1hdGguaW11bChhbDcsIGJsMCk7XG5cdCAgICBtaWQgPSBNYXRoLmltdWwoYWw3LCBiaDApO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsMCkpIHwgMDtcblx0ICAgIGhpID0gTWF0aC5pbXVsKGFoNywgYmgwKTtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmwxKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoMSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDEpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoMSkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmwyKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoMikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDIpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoMikpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmwzKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoMykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDMpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoMykpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw0KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoNCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDQpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoNCkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw1KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoNSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDUpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoNSkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw2KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoNikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDYpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoNikpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw3KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoNykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDcpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoNykpIHwgMDtcblx0ICAgIHZhciB3NyA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcblx0ICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3NyA+Pj4gMjYpKSB8IDA7XG5cdCAgICB3NyAmPSAweDNmZmZmZmY7XG5cdCAgICAvKiBrID0gOCAqL1xuXHQgICAgbG8gPSBNYXRoLmltdWwoYWw4LCBibDApO1xuXHQgICAgbWlkID0gTWF0aC5pbXVsKGFsOCwgYmgwKTtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDApKSB8IDA7XG5cdCAgICBoaSA9IE1hdGguaW11bChhaDgsIGJoMCk7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsMSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDEpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmwxKSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDEpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsMikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDIpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmwyKSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDIpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsMykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDMpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmwzKSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDMpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsNCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDQpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw0KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDQpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsNSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDUpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw1KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDUpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsNikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDYpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw2KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDYpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsNykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDcpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw3KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDcpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsOCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDgpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw4KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDgpKSB8IDA7XG5cdCAgICB2YXIgdzggPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG5cdCAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzggPj4+IDI2KSkgfCAwO1xuXHQgICAgdzggJj0gMHgzZmZmZmZmO1xuXHQgICAgLyogayA9IDkgKi9cblx0ICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwwKTtcblx0ICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoMCk7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmwwKSkgfCAwO1xuXHQgICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDApO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDEpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmgxKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsMSkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmgxKSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDIpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmgyKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsMikpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmgyKSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDMpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmgzKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsMykpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmgzKSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDQpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg0KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsNCkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg0KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDUpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg1KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsNSkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg1KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDYpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg2KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsNikpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg2KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDcpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg3KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsNykpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg3KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDgpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg4KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsOCkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg4KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDkpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg5KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsOSkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg5KSkgfCAwO1xuXHQgICAgdmFyIHc5ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuXHQgICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc5ID4+PiAyNikpIHwgMDtcblx0ICAgIHc5ICY9IDB4M2ZmZmZmZjtcblx0ICAgIC8qIGsgPSAxMCAqL1xuXHQgICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDEpO1xuXHQgICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmgxKTtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDEpKSB8IDA7XG5cdCAgICBoaSA9IE1hdGguaW11bChhaDksIGJoMSk7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsMikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDIpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmwyKSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDIpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsMykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDMpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmwzKSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDMpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsNCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDQpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw0KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDQpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsNSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDUpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw1KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDUpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsNikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDYpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw2KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDYpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsNykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDcpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw3KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDcpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsOCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDgpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw4KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDgpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsOSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDkpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw5KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDkpKSB8IDA7XG5cdCAgICB2YXIgdzEwID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuXHQgICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxMCA+Pj4gMjYpKSB8IDA7XG5cdCAgICB3MTAgJj0gMHgzZmZmZmZmO1xuXHQgICAgLyogayA9IDExICovXG5cdCAgICBsbyA9IE1hdGguaW11bChhbDksIGJsMik7XG5cdCAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDIpO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsMikpIHwgMDtcblx0ICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmgyKTtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmwzKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoMykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDMpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoMykpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw0KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoNCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDQpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoNCkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw1KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoNSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDUpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoNSkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw2KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoNikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDYpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoNikpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw3KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoNykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDcpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoNykpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw4KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoOCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDgpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoOCkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw5KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoOSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDkpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoOSkpIHwgMDtcblx0ICAgIHZhciB3MTEgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG5cdCAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzExID4+PiAyNikpIHwgMDtcblx0ICAgIHcxMSAmPSAweDNmZmZmZmY7XG5cdCAgICAvKiBrID0gMTIgKi9cblx0ICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwzKTtcblx0ICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoMyk7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmwzKSkgfCAwO1xuXHQgICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDMpO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDQpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg0KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsNCkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg0KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDUpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg1KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsNSkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg1KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDYpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg2KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsNikpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg2KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDcpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg3KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsNykpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg3KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDgpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg4KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsOCkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg4KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDkpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg5KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsOSkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg5KSkgfCAwO1xuXHQgICAgdmFyIHcxMiA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcblx0ICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTIgPj4+IDI2KSkgfCAwO1xuXHQgICAgdzEyICY9IDB4M2ZmZmZmZjtcblx0ICAgIC8qIGsgPSAxMyAqL1xuXHQgICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDQpO1xuXHQgICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg0KTtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDQpKSB8IDA7XG5cdCAgICBoaSA9IE1hdGguaW11bChhaDksIGJoNCk7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsNSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDUpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw1KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDUpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsNikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDYpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw2KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDYpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsNykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDcpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw3KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDcpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsOCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDgpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw4KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDgpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsOSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDkpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw5KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDkpKSB8IDA7XG5cdCAgICB2YXIgdzEzID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuXHQgICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxMyA+Pj4gMjYpKSB8IDA7XG5cdCAgICB3MTMgJj0gMHgzZmZmZmZmO1xuXHQgICAgLyogayA9IDE0ICovXG5cdCAgICBsbyA9IE1hdGguaW11bChhbDksIGJsNSk7XG5cdCAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDUpO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsNSkpIHwgMDtcblx0ICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg1KTtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw2KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoNikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDYpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoNikpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw3KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoNykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDcpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoNykpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw4KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoOCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDgpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoOCkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw5KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoOSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDkpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoOSkpIHwgMDtcblx0ICAgIHZhciB3MTQgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG5cdCAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE0ID4+PiAyNikpIHwgMDtcblx0ICAgIHcxNCAmPSAweDNmZmZmZmY7XG5cdCAgICAvKiBrID0gMTUgKi9cblx0ICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw2KTtcblx0ICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoNik7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw2KSkgfCAwO1xuXHQgICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDYpO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDcpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg3KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsNykpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg3KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDgpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg4KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsOCkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg4KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDkpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg5KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsOSkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg5KSkgfCAwO1xuXHQgICAgdmFyIHcxNSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcblx0ICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTUgPj4+IDI2KSkgfCAwO1xuXHQgICAgdzE1ICY9IDB4M2ZmZmZmZjtcblx0ICAgIC8qIGsgPSAxNiAqL1xuXHQgICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDcpO1xuXHQgICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg3KTtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDcpKSB8IDA7XG5cdCAgICBoaSA9IE1hdGguaW11bChhaDksIGJoNyk7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsOCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDgpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw4KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDgpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsOSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDkpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw5KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDkpKSB8IDA7XG5cdCAgICB2YXIgdzE2ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuXHQgICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxNiA+Pj4gMjYpKSB8IDA7XG5cdCAgICB3MTYgJj0gMHgzZmZmZmZmO1xuXHQgICAgLyogayA9IDE3ICovXG5cdCAgICBsbyA9IE1hdGguaW11bChhbDksIGJsOCk7XG5cdCAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDgpO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsOCkpIHwgMDtcblx0ICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg4KTtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw5KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoOSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDkpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoOSkpIHwgMDtcblx0ICAgIHZhciB3MTcgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG5cdCAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE3ID4+PiAyNikpIHwgMDtcblx0ICAgIHcxNyAmPSAweDNmZmZmZmY7XG5cdCAgICAvKiBrID0gMTggKi9cblx0ICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw5KTtcblx0ICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoOSk7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw5KSkgfCAwO1xuXHQgICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDkpO1xuXHQgICAgdmFyIHcxOCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcblx0ICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTggPj4+IDI2KSkgfCAwO1xuXHQgICAgdzE4ICY9IDB4M2ZmZmZmZjtcblx0ICAgIG9bMF0gPSB3MDtcblx0ICAgIG9bMV0gPSB3MTtcblx0ICAgIG9bMl0gPSB3Mjtcblx0ICAgIG9bM10gPSB3Mztcblx0ICAgIG9bNF0gPSB3NDtcblx0ICAgIG9bNV0gPSB3NTtcblx0ICAgIG9bNl0gPSB3Njtcblx0ICAgIG9bN10gPSB3Nztcblx0ICAgIG9bOF0gPSB3ODtcblx0ICAgIG9bOV0gPSB3OTtcblx0ICAgIG9bMTBdID0gdzEwO1xuXHQgICAgb1sxMV0gPSB3MTE7XG5cdCAgICBvWzEyXSA9IHcxMjtcblx0ICAgIG9bMTNdID0gdzEzO1xuXHQgICAgb1sxNF0gPSB3MTQ7XG5cdCAgICBvWzE1XSA9IHcxNTtcblx0ICAgIG9bMTZdID0gdzE2O1xuXHQgICAgb1sxN10gPSB3MTc7XG5cdCAgICBvWzE4XSA9IHcxODtcblx0ICAgIGlmIChjICE9PSAwKSB7XG5cdCAgICAgIG9bMTldID0gYztcblx0ICAgICAgb3V0Lmxlbmd0aCsrO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIG91dDtcblx0ICB9O1xuXG5cdCAgLy8gUG9seWZpbGwgY29tYlxuXHQgIGlmICghTWF0aC5pbXVsKSB7XG5cdCAgICBjb21iMTBNdWxUbyA9IHNtYWxsTXVsVG87XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gYmlnTXVsVG8gKHNlbGYsIG51bSwgb3V0KSB7XG5cdCAgICBvdXQubmVnYXRpdmUgPSBudW0ubmVnYXRpdmUgXiBzZWxmLm5lZ2F0aXZlO1xuXHQgICAgb3V0Lmxlbmd0aCA9IHNlbGYubGVuZ3RoICsgbnVtLmxlbmd0aDtcblxuXHQgICAgdmFyIGNhcnJ5ID0gMDtcblx0ICAgIHZhciBobmNhcnJ5ID0gMDtcblx0ICAgIGZvciAodmFyIGsgPSAwOyBrIDwgb3V0Lmxlbmd0aCAtIDE7IGsrKykge1xuXHQgICAgICAvLyBTdW0gYWxsIHdvcmRzIHdpdGggdGhlIHNhbWUgYGkgKyBqID0ga2AgYW5kIGFjY3VtdWxhdGUgYG5jYXJyeWAsXG5cdCAgICAgIC8vIG5vdGUgdGhhdCBuY2FycnkgY291bGQgYmUgPj0gMHgzZmZmZmZmXG5cdCAgICAgIHZhciBuY2FycnkgPSBobmNhcnJ5O1xuXHQgICAgICBobmNhcnJ5ID0gMDtcblx0ICAgICAgdmFyIHJ3b3JkID0gY2FycnkgJiAweDNmZmZmZmY7XG5cdCAgICAgIHZhciBtYXhKID0gTWF0aC5taW4oaywgbnVtLmxlbmd0aCAtIDEpO1xuXHQgICAgICBmb3IgKHZhciBqID0gTWF0aC5tYXgoMCwgayAtIHNlbGYubGVuZ3RoICsgMSk7IGogPD0gbWF4SjsgaisrKSB7XG5cdCAgICAgICAgdmFyIGkgPSBrIC0gajtcblx0ICAgICAgICB2YXIgYSA9IHNlbGYud29yZHNbaV0gfCAwO1xuXHQgICAgICAgIHZhciBiID0gbnVtLndvcmRzW2pdIHwgMDtcblx0ICAgICAgICB2YXIgciA9IGEgKiBiO1xuXG5cdCAgICAgICAgdmFyIGxvID0gciAmIDB4M2ZmZmZmZjtcblx0ICAgICAgICBuY2FycnkgPSAobmNhcnJ5ICsgKChyIC8gMHg0MDAwMDAwKSB8IDApKSB8IDA7XG5cdCAgICAgICAgbG8gPSAobG8gKyByd29yZCkgfCAwO1xuXHQgICAgICAgIHJ3b3JkID0gbG8gJiAweDNmZmZmZmY7XG5cdCAgICAgICAgbmNhcnJ5ID0gKG5jYXJyeSArIChsbyA+Pj4gMjYpKSB8IDA7XG5cblx0ICAgICAgICBobmNhcnJ5ICs9IG5jYXJyeSA+Pj4gMjY7XG5cdCAgICAgICAgbmNhcnJ5ICY9IDB4M2ZmZmZmZjtcblx0ICAgICAgfVxuXHQgICAgICBvdXQud29yZHNba10gPSByd29yZDtcblx0ICAgICAgY2FycnkgPSBuY2Fycnk7XG5cdCAgICAgIG5jYXJyeSA9IGhuY2Fycnk7XG5cdCAgICB9XG5cdCAgICBpZiAoY2FycnkgIT09IDApIHtcblx0ICAgICAgb3V0LndvcmRzW2tdID0gY2Fycnk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBvdXQubGVuZ3RoLS07XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBvdXQuc3RyaXAoKTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBqdW1ib011bFRvIChzZWxmLCBudW0sIG91dCkge1xuXHQgICAgdmFyIGZmdG0gPSBuZXcgRkZUTSgpO1xuXHQgICAgcmV0dXJuIGZmdG0ubXVscChzZWxmLCBudW0sIG91dCk7XG5cdCAgfVxuXG5cdCAgQk4ucHJvdG90eXBlLm11bFRvID0gZnVuY3Rpb24gbXVsVG8gKG51bSwgb3V0KSB7XG5cdCAgICB2YXIgcmVzO1xuXHQgICAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoICsgbnVtLmxlbmd0aDtcblx0ICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMTAgJiYgbnVtLmxlbmd0aCA9PT0gMTApIHtcblx0ICAgICAgcmVzID0gY29tYjEwTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuXHQgICAgfSBlbHNlIGlmIChsZW4gPCA2Mykge1xuXHQgICAgICByZXMgPSBzbWFsbE11bFRvKHRoaXMsIG51bSwgb3V0KTtcblx0ICAgIH0gZWxzZSBpZiAobGVuIDwgMTAyNCkge1xuXHQgICAgICByZXMgPSBiaWdNdWxUbyh0aGlzLCBudW0sIG91dCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXMgPSBqdW1ib011bFRvKHRoaXMsIG51bSwgb3V0KTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHJlcztcblx0ICB9O1xuXG5cdCAgLy8gQ29vbGV5LVR1a2V5IGFsZ29yaXRobSBmb3IgRkZUXG5cdCAgLy8gc2xpZ2h0bHkgcmV2aXNpdGVkIHRvIHJlbHkgb24gbG9vcGluZyBpbnN0ZWFkIG9mIHJlY3Vyc2lvblxuXG5cdCAgZnVuY3Rpb24gRkZUTSAoeCwgeSkge1xuXHQgICAgdGhpcy54ID0geDtcblx0ICAgIHRoaXMueSA9IHk7XG5cdCAgfVxuXG5cdCAgRkZUTS5wcm90b3R5cGUubWFrZVJCVCA9IGZ1bmN0aW9uIG1ha2VSQlQgKE4pIHtcblx0ICAgIHZhciB0ID0gbmV3IEFycmF5KE4pO1xuXHQgICAgdmFyIGwgPSBCTi5wcm90b3R5cGUuX2NvdW50Qml0cyhOKSAtIDE7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IE47IGkrKykge1xuXHQgICAgICB0W2ldID0gdGhpcy5yZXZCaW4oaSwgbCwgTik7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB0O1xuXHQgIH07XG5cblx0ICAvLyBSZXR1cm5zIGJpbmFyeS1yZXZlcnNlZCByZXByZXNlbnRhdGlvbiBvZiBgeGBcblx0ICBGRlRNLnByb3RvdHlwZS5yZXZCaW4gPSBmdW5jdGlvbiByZXZCaW4gKHgsIGwsIE4pIHtcblx0ICAgIGlmICh4ID09PSAwIHx8IHggPT09IE4gLSAxKSByZXR1cm4geDtcblxuXHQgICAgdmFyIHJiID0gMDtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cdCAgICAgIHJiIHw9ICh4ICYgMSkgPDwgKGwgLSBpIC0gMSk7XG5cdCAgICAgIHggPj49IDE7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiByYjtcblx0ICB9O1xuXG5cdCAgLy8gUGVyZm9ybXMgXCJ0d2VlZGxpbmdcIiBwaGFzZSwgdGhlcmVmb3JlICdlbXVsYXRpbmcnXG5cdCAgLy8gYmVoYXZpb3VyIG9mIHRoZSByZWN1cnNpdmUgYWxnb3JpdGhtXG5cdCAgRkZUTS5wcm90b3R5cGUucGVybXV0ZSA9IGZ1bmN0aW9uIHBlcm11dGUgKHJidCwgcndzLCBpd3MsIHJ0d3MsIGl0d3MsIE4pIHtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG5cdCAgICAgIHJ0d3NbaV0gPSByd3NbcmJ0W2ldXTtcblx0ICAgICAgaXR3c1tpXSA9IGl3c1tyYnRbaV1dO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICBGRlRNLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiB0cmFuc2Zvcm0gKHJ3cywgaXdzLCBydHdzLCBpdHdzLCBOLCByYnQpIHtcblx0ICAgIHRoaXMucGVybXV0ZShyYnQsIHJ3cywgaXdzLCBydHdzLCBpdHdzLCBOKTtcblxuXHQgICAgZm9yICh2YXIgcyA9IDE7IHMgPCBOOyBzIDw8PSAxKSB7XG5cdCAgICAgIHZhciBsID0gcyA8PCAxO1xuXG5cdCAgICAgIHZhciBydHdkZiA9IE1hdGguY29zKDIgKiBNYXRoLlBJIC8gbCk7XG5cdCAgICAgIHZhciBpdHdkZiA9IE1hdGguc2luKDIgKiBNYXRoLlBJIC8gbCk7XG5cblx0ICAgICAgZm9yICh2YXIgcCA9IDA7IHAgPCBOOyBwICs9IGwpIHtcblx0ICAgICAgICB2YXIgcnR3ZGZfID0gcnR3ZGY7XG5cdCAgICAgICAgdmFyIGl0d2RmXyA9IGl0d2RmO1xuXG5cdCAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzOyBqKyspIHtcblx0ICAgICAgICAgIHZhciByZSA9IHJ0d3NbcCArIGpdO1xuXHQgICAgICAgICAgdmFyIGllID0gaXR3c1twICsgal07XG5cblx0ICAgICAgICAgIHZhciBybyA9IHJ0d3NbcCArIGogKyBzXTtcblx0ICAgICAgICAgIHZhciBpbyA9IGl0d3NbcCArIGogKyBzXTtcblxuXHQgICAgICAgICAgdmFyIHJ4ID0gcnR3ZGZfICogcm8gLSBpdHdkZl8gKiBpbztcblxuXHQgICAgICAgICAgaW8gPSBydHdkZl8gKiBpbyArIGl0d2RmXyAqIHJvO1xuXHQgICAgICAgICAgcm8gPSByeDtcblxuXHQgICAgICAgICAgcnR3c1twICsgal0gPSByZSArIHJvO1xuXHQgICAgICAgICAgaXR3c1twICsgal0gPSBpZSArIGlvO1xuXG5cdCAgICAgICAgICBydHdzW3AgKyBqICsgc10gPSByZSAtIHJvO1xuXHQgICAgICAgICAgaXR3c1twICsgaiArIHNdID0gaWUgLSBpbztcblxuXHQgICAgICAgICAgLyoganNoaW50IG1heGRlcHRoIDogZmFsc2UgKi9cblx0ICAgICAgICAgIGlmIChqICE9PSBsKSB7XG5cdCAgICAgICAgICAgIHJ4ID0gcnR3ZGYgKiBydHdkZl8gLSBpdHdkZiAqIGl0d2RmXztcblxuXHQgICAgICAgICAgICBpdHdkZl8gPSBydHdkZiAqIGl0d2RmXyArIGl0d2RmICogcnR3ZGZfO1xuXHQgICAgICAgICAgICBydHdkZl8gPSByeDtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgRkZUTS5wcm90b3R5cGUuZ3Vlc3NMZW4xM2IgPSBmdW5jdGlvbiBndWVzc0xlbjEzYiAobiwgbSkge1xuXHQgICAgdmFyIE4gPSBNYXRoLm1heChtLCBuKSB8IDE7XG5cdCAgICB2YXIgb2RkID0gTiAmIDE7XG5cdCAgICB2YXIgaSA9IDA7XG5cdCAgICBmb3IgKE4gPSBOIC8gMiB8IDA7IE47IE4gPSBOID4+PiAxKSB7XG5cdCAgICAgIGkrKztcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIDEgPDwgaSArIDEgKyBvZGQ7XG5cdCAgfTtcblxuXHQgIEZGVE0ucHJvdG90eXBlLmNvbmp1Z2F0ZSA9IGZ1bmN0aW9uIGNvbmp1Z2F0ZSAocndzLCBpd3MsIE4pIHtcblx0ICAgIGlmIChOIDw9IDEpIHJldHVybjtcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOIC8gMjsgaSsrKSB7XG5cdCAgICAgIHZhciB0ID0gcndzW2ldO1xuXG5cdCAgICAgIHJ3c1tpXSA9IHJ3c1tOIC0gaSAtIDFdO1xuXHQgICAgICByd3NbTiAtIGkgLSAxXSA9IHQ7XG5cblx0ICAgICAgdCA9IGl3c1tpXTtcblxuXHQgICAgICBpd3NbaV0gPSAtaXdzW04gLSBpIC0gMV07XG5cdCAgICAgIGl3c1tOIC0gaSAtIDFdID0gLXQ7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIEZGVE0ucHJvdG90eXBlLm5vcm1hbGl6ZTEzYiA9IGZ1bmN0aW9uIG5vcm1hbGl6ZTEzYiAod3MsIE4pIHtcblx0ICAgIHZhciBjYXJyeSA9IDA7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IE4gLyAyOyBpKyspIHtcblx0ICAgICAgdmFyIHcgPSBNYXRoLnJvdW5kKHdzWzIgKiBpICsgMV0gLyBOKSAqIDB4MjAwMCArXG5cdCAgICAgICAgTWF0aC5yb3VuZCh3c1syICogaV0gLyBOKSArXG5cdCAgICAgICAgY2Fycnk7XG5cblx0ICAgICAgd3NbaV0gPSB3ICYgMHgzZmZmZmZmO1xuXG5cdCAgICAgIGlmICh3IDwgMHg0MDAwMDAwKSB7XG5cdCAgICAgICAgY2FycnkgPSAwO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGNhcnJ5ID0gdyAvIDB4NDAwMDAwMCB8IDA7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHdzO1xuXHQgIH07XG5cblx0ICBGRlRNLnByb3RvdHlwZS5jb252ZXJ0MTNiID0gZnVuY3Rpb24gY29udmVydDEzYiAod3MsIGxlbiwgcndzLCBOKSB7XG5cdCAgICB2YXIgY2FycnkgPSAwO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHQgICAgICBjYXJyeSA9IGNhcnJ5ICsgKHdzW2ldIHwgMCk7XG5cblx0ICAgICAgcndzWzIgKiBpXSA9IGNhcnJ5ICYgMHgxZmZmOyBjYXJyeSA9IGNhcnJ5ID4+PiAxMztcblx0ICAgICAgcndzWzIgKiBpICsgMV0gPSBjYXJyeSAmIDB4MWZmZjsgY2FycnkgPSBjYXJyeSA+Pj4gMTM7XG5cdCAgICB9XG5cblx0ICAgIC8vIFBhZCB3aXRoIHplcm9lc1xuXHQgICAgZm9yIChpID0gMiAqIGxlbjsgaSA8IE47ICsraSkge1xuXHQgICAgICByd3NbaV0gPSAwO1xuXHQgICAgfVxuXG5cdCAgICBhc3NlcnQoY2FycnkgPT09IDApO1xuXHQgICAgYXNzZXJ0KChjYXJyeSAmIH4weDFmZmYpID09PSAwKTtcblx0ICB9O1xuXG5cdCAgRkZUTS5wcm90b3R5cGUuc3R1YiA9IGZ1bmN0aW9uIHN0dWIgKE4pIHtcblx0ICAgIHZhciBwaCA9IG5ldyBBcnJheShOKTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG5cdCAgICAgIHBoW2ldID0gMDtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHBoO1xuXHQgIH07XG5cblx0ICBGRlRNLnByb3RvdHlwZS5tdWxwID0gZnVuY3Rpb24gbXVscCAoeCwgeSwgb3V0KSB7XG5cdCAgICB2YXIgTiA9IDIgKiB0aGlzLmd1ZXNzTGVuMTNiKHgubGVuZ3RoLCB5Lmxlbmd0aCk7XG5cblx0ICAgIHZhciByYnQgPSB0aGlzLm1ha2VSQlQoTik7XG5cblx0ICAgIHZhciBfID0gdGhpcy5zdHViKE4pO1xuXG5cdCAgICB2YXIgcndzID0gbmV3IEFycmF5KE4pO1xuXHQgICAgdmFyIHJ3c3QgPSBuZXcgQXJyYXkoTik7XG5cdCAgICB2YXIgaXdzdCA9IG5ldyBBcnJheShOKTtcblxuXHQgICAgdmFyIG5yd3MgPSBuZXcgQXJyYXkoTik7XG5cdCAgICB2YXIgbnJ3c3QgPSBuZXcgQXJyYXkoTik7XG5cdCAgICB2YXIgbml3c3QgPSBuZXcgQXJyYXkoTik7XG5cblx0ICAgIHZhciBybXdzID0gb3V0LndvcmRzO1xuXHQgICAgcm13cy5sZW5ndGggPSBOO1xuXG5cdCAgICB0aGlzLmNvbnZlcnQxM2IoeC53b3JkcywgeC5sZW5ndGgsIHJ3cywgTik7XG5cdCAgICB0aGlzLmNvbnZlcnQxM2IoeS53b3JkcywgeS5sZW5ndGgsIG5yd3MsIE4pO1xuXG5cdCAgICB0aGlzLnRyYW5zZm9ybShyd3MsIF8sIHJ3c3QsIGl3c3QsIE4sIHJidCk7XG5cdCAgICB0aGlzLnRyYW5zZm9ybShucndzLCBfLCBucndzdCwgbml3c3QsIE4sIHJidCk7XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG5cdCAgICAgIHZhciByeCA9IHJ3c3RbaV0gKiBucndzdFtpXSAtIGl3c3RbaV0gKiBuaXdzdFtpXTtcblx0ICAgICAgaXdzdFtpXSA9IHJ3c3RbaV0gKiBuaXdzdFtpXSArIGl3c3RbaV0gKiBucndzdFtpXTtcblx0ICAgICAgcndzdFtpXSA9IHJ4O1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLmNvbmp1Z2F0ZShyd3N0LCBpd3N0LCBOKTtcblx0ICAgIHRoaXMudHJhbnNmb3JtKHJ3c3QsIGl3c3QsIHJtd3MsIF8sIE4sIHJidCk7XG5cdCAgICB0aGlzLmNvbmp1Z2F0ZShybXdzLCBfLCBOKTtcblx0ICAgIHRoaXMubm9ybWFsaXplMTNiKHJtd3MsIE4pO1xuXG5cdCAgICBvdXQubmVnYXRpdmUgPSB4Lm5lZ2F0aXZlIF4geS5uZWdhdGl2ZTtcblx0ICAgIG91dC5sZW5ndGggPSB4Lmxlbmd0aCArIHkubGVuZ3RoO1xuXHQgICAgcmV0dXJuIG91dC5zdHJpcCgpO1xuXHQgIH07XG5cblx0ICAvLyBNdWx0aXBseSBgdGhpc2AgYnkgYG51bWBcblx0ICBCTi5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsIChudW0pIHtcblx0ICAgIHZhciBvdXQgPSBuZXcgQk4obnVsbCk7XG5cdCAgICBvdXQud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGggKyBudW0ubGVuZ3RoKTtcblx0ICAgIHJldHVybiB0aGlzLm11bFRvKG51bSwgb3V0KTtcblx0ICB9O1xuXG5cdCAgLy8gTXVsdGlwbHkgZW1wbG95aW5nIEZGVFxuXHQgIEJOLnByb3RvdHlwZS5tdWxmID0gZnVuY3Rpb24gbXVsZiAobnVtKSB7XG5cdCAgICB2YXIgb3V0ID0gbmV3IEJOKG51bGwpO1xuXHQgICAgb3V0LndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoICsgbnVtLmxlbmd0aCk7XG5cdCAgICByZXR1cm4ganVtYm9NdWxUbyh0aGlzLCBudW0sIG91dCk7XG5cdCAgfTtcblxuXHQgIC8vIEluLXBsYWNlIE11bHRpcGxpY2F0aW9uXG5cdCAgQk4ucHJvdG90eXBlLmltdWwgPSBmdW5jdGlvbiBpbXVsIChudW0pIHtcblx0ICAgIHJldHVybiB0aGlzLmNsb25lKCkubXVsVG8obnVtLCB0aGlzKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmltdWxuID0gZnVuY3Rpb24gaW11bG4gKG51bSkge1xuXHQgICAgYXNzZXJ0KHR5cGVvZiBudW0gPT09ICdudW1iZXInKTtcblx0ICAgIGFzc2VydChudW0gPCAweDQwMDAwMDApO1xuXG5cdCAgICAvLyBDYXJyeVxuXHQgICAgdmFyIGNhcnJ5ID0gMDtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICB2YXIgdyA9ICh0aGlzLndvcmRzW2ldIHwgMCkgKiBudW07XG5cdCAgICAgIHZhciBsbyA9ICh3ICYgMHgzZmZmZmZmKSArIChjYXJyeSAmIDB4M2ZmZmZmZik7XG5cdCAgICAgIGNhcnJ5ID4+PSAyNjtcblx0ICAgICAgY2FycnkgKz0gKHcgLyAweDQwMDAwMDApIHwgMDtcblx0ICAgICAgLy8gTk9URTogbG8gaXMgMjdiaXQgbWF4aW11bVxuXHQgICAgICBjYXJyeSArPSBsbyA+Pj4gMjY7XG5cdCAgICAgIHRoaXMud29yZHNbaV0gPSBsbyAmIDB4M2ZmZmZmZjtcblx0ICAgIH1cblxuXHQgICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG5cdCAgICAgIHRoaXMud29yZHNbaV0gPSBjYXJyeTtcblx0ICAgICAgdGhpcy5sZW5ndGgrKztcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5tdWxuID0gZnVuY3Rpb24gbXVsbiAobnVtKSB7XG5cdCAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmltdWxuKG51bSk7XG5cdCAgfTtcblxuXHQgIC8vIGB0aGlzYCAqIGB0aGlzYFxuXHQgIEJOLnByb3RvdHlwZS5zcXIgPSBmdW5jdGlvbiBzcXIgKCkge1xuXHQgICAgcmV0dXJuIHRoaXMubXVsKHRoaXMpO1xuXHQgIH07XG5cblx0ICAvLyBgdGhpc2AgKiBgdGhpc2AgaW4tcGxhY2Vcblx0ICBCTi5wcm90b3R5cGUuaXNxciA9IGZ1bmN0aW9uIGlzcXIgKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuaW11bCh0aGlzLmNsb25lKCkpO1xuXHQgIH07XG5cblx0ICAvLyBNYXRoLnBvdyhgdGhpc2AsIGBudW1gKVxuXHQgIEJOLnByb3RvdHlwZS5wb3cgPSBmdW5jdGlvbiBwb3cgKG51bSkge1xuXHQgICAgdmFyIHcgPSB0b0JpdEFycmF5KG51bSk7XG5cdCAgICBpZiAody5sZW5ndGggPT09IDApIHJldHVybiBuZXcgQk4oMSk7XG5cblx0ICAgIC8vIFNraXAgbGVhZGluZyB6ZXJvZXNcblx0ICAgIHZhciByZXMgPSB0aGlzO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3Lmxlbmd0aDsgaSsrLCByZXMgPSByZXMuc3FyKCkpIHtcblx0ICAgICAgaWYgKHdbaV0gIT09IDApIGJyZWFrO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoKytpIDwgdy5sZW5ndGgpIHtcblx0ICAgICAgZm9yICh2YXIgcSA9IHJlcy5zcXIoKTsgaSA8IHcubGVuZ3RoOyBpKyssIHEgPSBxLnNxcigpKSB7XG5cdCAgICAgICAgaWYgKHdbaV0gPT09IDApIGNvbnRpbnVlO1xuXG5cdCAgICAgICAgcmVzID0gcmVzLm11bChxKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gcmVzO1xuXHQgIH07XG5cblx0ICAvLyBTaGlmdC1sZWZ0IGluLXBsYWNlXG5cdCAgQk4ucHJvdG90eXBlLml1c2hsbiA9IGZ1bmN0aW9uIGl1c2hsbiAoYml0cykge1xuXHQgICAgYXNzZXJ0KHR5cGVvZiBiaXRzID09PSAnbnVtYmVyJyAmJiBiaXRzID49IDApO1xuXHQgICAgdmFyIHIgPSBiaXRzICUgMjY7XG5cdCAgICB2YXIgcyA9IChiaXRzIC0gcikgLyAyNjtcblx0ICAgIHZhciBjYXJyeU1hc2sgPSAoMHgzZmZmZmZmID4+PiAoMjYgLSByKSkgPDwgKDI2IC0gcik7XG5cdCAgICB2YXIgaTtcblxuXHQgICAgaWYgKHIgIT09IDApIHtcblx0ICAgICAgdmFyIGNhcnJ5ID0gMDtcblxuXHQgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHZhciBuZXdDYXJyeSA9IHRoaXMud29yZHNbaV0gJiBjYXJyeU1hc2s7XG5cdCAgICAgICAgdmFyIGMgPSAoKHRoaXMud29yZHNbaV0gfCAwKSAtIG5ld0NhcnJ5KSA8PCByO1xuXHQgICAgICAgIHRoaXMud29yZHNbaV0gPSBjIHwgY2Fycnk7XG5cdCAgICAgICAgY2FycnkgPSBuZXdDYXJyeSA+Pj4gKDI2IC0gcik7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoY2FycnkpIHtcblx0ICAgICAgICB0aGlzLndvcmRzW2ldID0gY2Fycnk7XG5cdCAgICAgICAgdGhpcy5sZW5ndGgrKztcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAocyAhPT0gMCkge1xuXHQgICAgICBmb3IgKGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdCAgICAgICAgdGhpcy53b3Jkc1tpICsgc10gPSB0aGlzLndvcmRzW2ldO1xuXHQgICAgICB9XG5cblx0ICAgICAgZm9yIChpID0gMDsgaSA8IHM7IGkrKykge1xuXHQgICAgICAgIHRoaXMud29yZHNbaV0gPSAwO1xuXHQgICAgICB9XG5cblx0ICAgICAgdGhpcy5sZW5ndGggKz0gcztcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmlzaGxuID0gZnVuY3Rpb24gaXNobG4gKGJpdHMpIHtcblx0ICAgIC8vIFRPRE8oaW5kdXRueSk6IGltcGxlbWVudCBtZVxuXHQgICAgYXNzZXJ0KHRoaXMubmVnYXRpdmUgPT09IDApO1xuXHQgICAgcmV0dXJuIHRoaXMuaXVzaGxuKGJpdHMpO1xuXHQgIH07XG5cblx0ICAvLyBTaGlmdC1yaWdodCBpbi1wbGFjZVxuXHQgIC8vIE5PVEU6IGBoaW50YCBpcyBhIGxvd2VzdCBiaXQgYmVmb3JlIHRyYWlsaW5nIHplcm9lc1xuXHQgIC8vIE5PVEU6IGlmIGBleHRlbmRlZGAgaXMgcHJlc2VudCAtIGl0IHdpbGwgYmUgZmlsbGVkIHdpdGggZGVzdHJveWVkIGJpdHNcblx0ICBCTi5wcm90b3R5cGUuaXVzaHJuID0gZnVuY3Rpb24gaXVzaHJuIChiaXRzLCBoaW50LCBleHRlbmRlZCkge1xuXHQgICAgYXNzZXJ0KHR5cGVvZiBiaXRzID09PSAnbnVtYmVyJyAmJiBiaXRzID49IDApO1xuXHQgICAgdmFyIGg7XG5cdCAgICBpZiAoaGludCkge1xuXHQgICAgICBoID0gKGhpbnQgLSAoaGludCAlIDI2KSkgLyAyNjtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGggPSAwO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgciA9IGJpdHMgJSAyNjtcblx0ICAgIHZhciBzID0gTWF0aC5taW4oKGJpdHMgLSByKSAvIDI2LCB0aGlzLmxlbmd0aCk7XG5cdCAgICB2YXIgbWFzayA9IDB4M2ZmZmZmZiBeICgoMHgzZmZmZmZmID4+PiByKSA8PCByKTtcblx0ICAgIHZhciBtYXNrZWRXb3JkcyA9IGV4dGVuZGVkO1xuXG5cdCAgICBoIC09IHM7XG5cdCAgICBoID0gTWF0aC5tYXgoMCwgaCk7XG5cblx0ICAgIC8vIEV4dGVuZGVkIG1vZGUsIGNvcHkgbWFza2VkIHBhcnRcblx0ICAgIGlmIChtYXNrZWRXb3Jkcykge1xuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKykge1xuXHQgICAgICAgIG1hc2tlZFdvcmRzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXTtcblx0ICAgICAgfVxuXHQgICAgICBtYXNrZWRXb3Jkcy5sZW5ndGggPSBzO1xuXHQgICAgfVxuXG5cdCAgICBpZiAocyA9PT0gMCkge1xuXHQgICAgICAvLyBOby1vcCwgd2Ugc2hvdWxkIG5vdCBtb3ZlIGFueXRoaW5nIGF0IGFsbFxuXHQgICAgfSBlbHNlIGlmICh0aGlzLmxlbmd0aCA+IHMpIHtcblx0ICAgICAgdGhpcy5sZW5ndGggLT0gcztcblx0ICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICB0aGlzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpICsgc107XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHRoaXMud29yZHNbMF0gPSAwO1xuXHQgICAgICB0aGlzLmxlbmd0aCA9IDE7XG5cdCAgICB9XG5cblx0ICAgIHZhciBjYXJyeSA9IDA7XG5cdCAgICBmb3IgKGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMCAmJiAoY2FycnkgIT09IDAgfHwgaSA+PSBoKTsgaS0tKSB7XG5cdCAgICAgIHZhciB3b3JkID0gdGhpcy53b3Jkc1tpXSB8IDA7XG5cdCAgICAgIHRoaXMud29yZHNbaV0gPSAoY2FycnkgPDwgKDI2IC0gcikpIHwgKHdvcmQgPj4+IHIpO1xuXHQgICAgICBjYXJyeSA9IHdvcmQgJiBtYXNrO1xuXHQgICAgfVxuXG5cdCAgICAvLyBQdXNoIGNhcnJpZWQgYml0cyBhcyBhIG1hc2tcblx0ICAgIGlmIChtYXNrZWRXb3JkcyAmJiBjYXJyeSAhPT0gMCkge1xuXHQgICAgICBtYXNrZWRXb3Jkcy53b3Jkc1ttYXNrZWRXb3Jkcy5sZW5ndGgrK10gPSBjYXJyeTtcblx0ICAgIH1cblxuXHQgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB7XG5cdCAgICAgIHRoaXMud29yZHNbMF0gPSAwO1xuXHQgICAgICB0aGlzLmxlbmd0aCA9IDE7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5pc2hybiA9IGZ1bmN0aW9uIGlzaHJuIChiaXRzLCBoaW50LCBleHRlbmRlZCkge1xuXHQgICAgLy8gVE9ETyhpbmR1dG55KTogaW1wbGVtZW50IG1lXG5cdCAgICBhc3NlcnQodGhpcy5uZWdhdGl2ZSA9PT0gMCk7XG5cdCAgICByZXR1cm4gdGhpcy5pdXNocm4oYml0cywgaGludCwgZXh0ZW5kZWQpO1xuXHQgIH07XG5cblx0ICAvLyBTaGlmdC1sZWZ0XG5cdCAgQk4ucHJvdG90eXBlLnNobG4gPSBmdW5jdGlvbiBzaGxuIChiaXRzKSB7XG5cdCAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzaGxuKGJpdHMpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUudXNobG4gPSBmdW5jdGlvbiB1c2hsbiAoYml0cykge1xuXHQgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdXNobG4oYml0cyk7XG5cdCAgfTtcblxuXHQgIC8vIFNoaWZ0LXJpZ2h0XG5cdCAgQk4ucHJvdG90eXBlLnNocm4gPSBmdW5jdGlvbiBzaHJuIChiaXRzKSB7XG5cdCAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzaHJuKGJpdHMpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUudXNocm4gPSBmdW5jdGlvbiB1c2hybiAoYml0cykge1xuXHQgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdXNocm4oYml0cyk7XG5cdCAgfTtcblxuXHQgIC8vIFRlc3QgaWYgbiBiaXQgaXMgc2V0XG5cdCAgQk4ucHJvdG90eXBlLnRlc3RuID0gZnVuY3Rpb24gdGVzdG4gKGJpdCkge1xuXHQgICAgYXNzZXJ0KHR5cGVvZiBiaXQgPT09ICdudW1iZXInICYmIGJpdCA+PSAwKTtcblx0ICAgIHZhciByID0gYml0ICUgMjY7XG5cdCAgICB2YXIgcyA9IChiaXQgLSByKSAvIDI2O1xuXHQgICAgdmFyIHEgPSAxIDw8IHI7XG5cblx0ICAgIC8vIEZhc3QgY2FzZTogYml0IGlzIG11Y2ggaGlnaGVyIHRoYW4gYWxsIGV4aXN0aW5nIHdvcmRzXG5cdCAgICBpZiAodGhpcy5sZW5ndGggPD0gcykgcmV0dXJuIGZhbHNlO1xuXG5cdCAgICAvLyBDaGVjayBiaXQgYW5kIHJldHVyblxuXHQgICAgdmFyIHcgPSB0aGlzLndvcmRzW3NdO1xuXG5cdCAgICByZXR1cm4gISEodyAmIHEpO1xuXHQgIH07XG5cblx0ICAvLyBSZXR1cm4gb25seSBsb3dlcnMgYml0cyBvZiBudW1iZXIgKGluLXBsYWNlKVxuXHQgIEJOLnByb3RvdHlwZS5pbWFza24gPSBmdW5jdGlvbiBpbWFza24gKGJpdHMpIHtcblx0ICAgIGFzc2VydCh0eXBlb2YgYml0cyA9PT0gJ251bWJlcicgJiYgYml0cyA+PSAwKTtcblx0ICAgIHZhciByID0gYml0cyAlIDI2O1xuXHQgICAgdmFyIHMgPSAoYml0cyAtIHIpIC8gMjY7XG5cblx0ICAgIGFzc2VydCh0aGlzLm5lZ2F0aXZlID09PSAwLCAnaW1hc2tuIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZSBudW1iZXJzJyk7XG5cblx0ICAgIGlmICh0aGlzLmxlbmd0aCA8PSBzKSB7XG5cdCAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfVxuXG5cdCAgICBpZiAociAhPT0gMCkge1xuXHQgICAgICBzKys7XG5cdCAgICB9XG5cdCAgICB0aGlzLmxlbmd0aCA9IE1hdGgubWluKHMsIHRoaXMubGVuZ3RoKTtcblxuXHQgICAgaWYgKHIgIT09IDApIHtcblx0ICAgICAgdmFyIG1hc2sgPSAweDNmZmZmZmYgXiAoKDB4M2ZmZmZmZiA+Pj4gcikgPDwgcik7XG5cdCAgICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGggLSAxXSAmPSBtYXNrO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuXHQgIH07XG5cblx0ICAvLyBSZXR1cm4gb25seSBsb3dlcnMgYml0cyBvZiBudW1iZXJcblx0ICBCTi5wcm90b3R5cGUubWFza24gPSBmdW5jdGlvbiBtYXNrbiAoYml0cykge1xuXHQgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbWFza24oYml0cyk7XG5cdCAgfTtcblxuXHQgIC8vIEFkZCBwbGFpbiBudW1iZXIgYG51bWAgdG8gYHRoaXNgXG5cdCAgQk4ucHJvdG90eXBlLmlhZGRuID0gZnVuY3Rpb24gaWFkZG4gKG51bSkge1xuXHQgICAgYXNzZXJ0KHR5cGVvZiBudW0gPT09ICdudW1iZXInKTtcblx0ICAgIGFzc2VydChudW0gPCAweDQwMDAwMDApO1xuXHQgICAgaWYgKG51bSA8IDApIHJldHVybiB0aGlzLmlzdWJuKC1udW0pO1xuXG5cdCAgICAvLyBQb3NzaWJsZSBzaWduIGNoYW5nZVxuXHQgICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcblx0ICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAxICYmICh0aGlzLndvcmRzWzBdIHwgMCkgPCBudW0pIHtcblx0ICAgICAgICB0aGlzLndvcmRzWzBdID0gbnVtIC0gKHRoaXMud29yZHNbMF0gfCAwKTtcblx0ICAgICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgfVxuXG5cdCAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuXHQgICAgICB0aGlzLmlzdWJuKG51bSk7XG5cdCAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuXHQgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH1cblxuXHQgICAgLy8gQWRkIHdpdGhvdXQgY2hlY2tzXG5cdCAgICByZXR1cm4gdGhpcy5faWFkZG4obnVtKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLl9pYWRkbiA9IGZ1bmN0aW9uIF9pYWRkbiAobnVtKSB7XG5cdCAgICB0aGlzLndvcmRzWzBdICs9IG51bTtcblxuXHQgICAgLy8gQ2Fycnlcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGggJiYgdGhpcy53b3Jkc1tpXSA+PSAweDQwMDAwMDA7IGkrKykge1xuXHQgICAgICB0aGlzLndvcmRzW2ldIC09IDB4NDAwMDAwMDtcblx0ICAgICAgaWYgKGkgPT09IHRoaXMubGVuZ3RoIC0gMSkge1xuXHQgICAgICAgIHRoaXMud29yZHNbaSArIDFdID0gMTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICB0aGlzLndvcmRzW2kgKyAxXSsrO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICB0aGlzLmxlbmd0aCA9IE1hdGgubWF4KHRoaXMubGVuZ3RoLCBpICsgMSk7XG5cblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cblx0ICAvLyBTdWJ0cmFjdCBwbGFpbiBudW1iZXIgYG51bWAgZnJvbSBgdGhpc2Bcblx0ICBCTi5wcm90b3R5cGUuaXN1Ym4gPSBmdW5jdGlvbiBpc3VibiAobnVtKSB7XG5cdCAgICBhc3NlcnQodHlwZW9mIG51bSA9PT0gJ251bWJlcicpO1xuXHQgICAgYXNzZXJ0KG51bSA8IDB4NDAwMDAwMCk7XG5cdCAgICBpZiAobnVtIDwgMCkgcmV0dXJuIHRoaXMuaWFkZG4oLW51bSk7XG5cblx0ICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG5cdCAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuXHQgICAgICB0aGlzLmlhZGRuKG51bSk7XG5cdCAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuXHQgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH1cblxuXHQgICAgdGhpcy53b3Jkc1swXSAtPSBudW07XG5cblx0ICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLndvcmRzWzBdIDwgMCkge1xuXHQgICAgICB0aGlzLndvcmRzWzBdID0gLXRoaXMud29yZHNbMF07XG5cdCAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgLy8gQ2Fycnlcblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aCAmJiB0aGlzLndvcmRzW2ldIDwgMDsgaSsrKSB7XG5cdCAgICAgICAgdGhpcy53b3Jkc1tpXSArPSAweDQwMDAwMDA7XG5cdCAgICAgICAgdGhpcy53b3Jkc1tpICsgMV0gLT0gMTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuYWRkbiA9IGZ1bmN0aW9uIGFkZG4gKG51bSkge1xuXHQgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYWRkbihudW0pO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuc3VibiA9IGZ1bmN0aW9uIHN1Ym4gKG51bSkge1xuXHQgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc3VibihudW0pO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuaWFicyA9IGZ1bmN0aW9uIGlhYnMgKCkge1xuXHQgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG5cblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuYWJzID0gZnVuY3Rpb24gYWJzICgpIHtcblx0ICAgIHJldHVybiB0aGlzLmNsb25lKCkuaWFicygpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuX2lzaGxuc3VibXVsID0gZnVuY3Rpb24gX2lzaGxuc3VibXVsIChudW0sIG11bCwgc2hpZnQpIHtcblx0ICAgIHZhciBsZW4gPSBudW0ubGVuZ3RoICsgc2hpZnQ7XG5cdCAgICB2YXIgaTtcblxuXHQgICAgdGhpcy5fZXhwYW5kKGxlbik7XG5cblx0ICAgIHZhciB3O1xuXHQgICAgdmFyIGNhcnJ5ID0gMDtcblx0ICAgIGZvciAoaSA9IDA7IGkgPCBudW0ubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdyA9ICh0aGlzLndvcmRzW2kgKyBzaGlmdF0gfCAwKSArIGNhcnJ5O1xuXHQgICAgICB2YXIgcmlnaHQgPSAobnVtLndvcmRzW2ldIHwgMCkgKiBtdWw7XG5cdCAgICAgIHcgLT0gcmlnaHQgJiAweDNmZmZmZmY7XG5cdCAgICAgIGNhcnJ5ID0gKHcgPj4gMjYpIC0gKChyaWdodCAvIDB4NDAwMDAwMCkgfCAwKTtcblx0ICAgICAgdGhpcy53b3Jkc1tpICsgc2hpZnRdID0gdyAmIDB4M2ZmZmZmZjtcblx0ICAgIH1cblx0ICAgIGZvciAoOyBpIDwgdGhpcy5sZW5ndGggLSBzaGlmdDsgaSsrKSB7XG5cdCAgICAgIHcgPSAodGhpcy53b3Jkc1tpICsgc2hpZnRdIHwgMCkgKyBjYXJyeTtcblx0ICAgICAgY2FycnkgPSB3ID4+IDI2O1xuXHQgICAgICB0aGlzLndvcmRzW2kgKyBzaGlmdF0gPSB3ICYgMHgzZmZmZmZmO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoY2FycnkgPT09IDApIHJldHVybiB0aGlzLnN0cmlwKCk7XG5cblx0ICAgIC8vIFN1YnRyYWN0aW9uIG92ZXJmbG93XG5cdCAgICBhc3NlcnQoY2FycnkgPT09IC0xKTtcblx0ICAgIGNhcnJ5ID0gMDtcblx0ICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHcgPSAtKHRoaXMud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuXHQgICAgICBjYXJyeSA9IHcgPj4gMjY7XG5cdCAgICAgIHRoaXMud29yZHNbaV0gPSB3ICYgMHgzZmZmZmZmO1xuXHQgICAgfVxuXHQgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG5cblx0ICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5fd29yZERpdiA9IGZ1bmN0aW9uIF93b3JkRGl2IChudW0sIG1vZGUpIHtcblx0ICAgIHZhciBzaGlmdCA9IHRoaXMubGVuZ3RoIC0gbnVtLmxlbmd0aDtcblxuXHQgICAgdmFyIGEgPSB0aGlzLmNsb25lKCk7XG5cdCAgICB2YXIgYiA9IG51bTtcblxuXHQgICAgLy8gTm9ybWFsaXplXG5cdCAgICB2YXIgYmhpID0gYi53b3Jkc1tiLmxlbmd0aCAtIDFdIHwgMDtcblx0ICAgIHZhciBiaGlCaXRzID0gdGhpcy5fY291bnRCaXRzKGJoaSk7XG5cdCAgICBzaGlmdCA9IDI2IC0gYmhpQml0cztcblx0ICAgIGlmIChzaGlmdCAhPT0gMCkge1xuXHQgICAgICBiID0gYi51c2hsbihzaGlmdCk7XG5cdCAgICAgIGEuaXVzaGxuKHNoaWZ0KTtcblx0ICAgICAgYmhpID0gYi53b3Jkc1tiLmxlbmd0aCAtIDFdIHwgMDtcblx0ICAgIH1cblxuXHQgICAgLy8gSW5pdGlhbGl6ZSBxdW90aWVudFxuXHQgICAgdmFyIG0gPSBhLmxlbmd0aCAtIGIubGVuZ3RoO1xuXHQgICAgdmFyIHE7XG5cblx0ICAgIGlmIChtb2RlICE9PSAnbW9kJykge1xuXHQgICAgICBxID0gbmV3IEJOKG51bGwpO1xuXHQgICAgICBxLmxlbmd0aCA9IG0gKyAxO1xuXHQgICAgICBxLndvcmRzID0gbmV3IEFycmF5KHEubGVuZ3RoKTtcblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgcS53b3Jkc1tpXSA9IDA7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgdmFyIGRpZmYgPSBhLmNsb25lKCkuX2lzaGxuc3VibXVsKGIsIDEsIG0pO1xuXHQgICAgaWYgKGRpZmYubmVnYXRpdmUgPT09IDApIHtcblx0ICAgICAgYSA9IGRpZmY7XG5cdCAgICAgIGlmIChxKSB7XG5cdCAgICAgICAgcS53b3Jkc1ttXSA9IDE7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgZm9yICh2YXIgaiA9IG0gLSAxOyBqID49IDA7IGotLSkge1xuXHQgICAgICB2YXIgcWogPSAoYS53b3Jkc1tiLmxlbmd0aCArIGpdIHwgMCkgKiAweDQwMDAwMDAgK1xuXHQgICAgICAgIChhLndvcmRzW2IubGVuZ3RoICsgaiAtIDFdIHwgMCk7XG5cblx0ICAgICAgLy8gTk9URTogKHFqIC8gYmhpKSBpcyAoMHgzZmZmZmZmICogMHg0MDAwMDAwICsgMHgzZmZmZmZmKSAvIDB4MjAwMDAwMCBtYXhcblx0ICAgICAgLy8gKDB4N2ZmZmZmZilcblx0ICAgICAgcWogPSBNYXRoLm1pbigocWogLyBiaGkpIHwgMCwgMHgzZmZmZmZmKTtcblxuXHQgICAgICBhLl9pc2hsbnN1Ym11bChiLCBxaiwgaik7XG5cdCAgICAgIHdoaWxlIChhLm5lZ2F0aXZlICE9PSAwKSB7XG5cdCAgICAgICAgcWotLTtcblx0ICAgICAgICBhLm5lZ2F0aXZlID0gMDtcblx0ICAgICAgICBhLl9pc2hsbnN1Ym11bChiLCAxLCBqKTtcblx0ICAgICAgICBpZiAoIWEuaXNaZXJvKCkpIHtcblx0ICAgICAgICAgIGEubmVnYXRpdmUgXj0gMTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKHEpIHtcblx0ICAgICAgICBxLndvcmRzW2pdID0gcWo7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIGlmIChxKSB7XG5cdCAgICAgIHEuc3RyaXAoKTtcblx0ICAgIH1cblx0ICAgIGEuc3RyaXAoKTtcblxuXHQgICAgLy8gRGVub3JtYWxpemVcblx0ICAgIGlmIChtb2RlICE9PSAnZGl2JyAmJiBzaGlmdCAhPT0gMCkge1xuXHQgICAgICBhLml1c2hybihzaGlmdCk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB7XG5cdCAgICAgIGRpdjogcSB8fCBudWxsLFxuXHQgICAgICBtb2Q6IGFcblx0ICAgIH07XG5cdCAgfTtcblxuXHQgIC8vIE5PVEU6IDEpIGBtb2RlYCBjYW4gYmUgc2V0IHRvIGBtb2RgIHRvIHJlcXVlc3QgbW9kIG9ubHksXG5cdCAgLy8gICAgICAgdG8gYGRpdmAgdG8gcmVxdWVzdCBkaXYgb25seSwgb3IgYmUgYWJzZW50IHRvXG5cdCAgLy8gICAgICAgcmVxdWVzdCBib3RoIGRpdiAmIG1vZFxuXHQgIC8vICAgICAgIDIpIGBwb3NpdGl2ZWAgaXMgdHJ1ZSBpZiB1bnNpZ25lZCBtb2QgaXMgcmVxdWVzdGVkXG5cdCAgQk4ucHJvdG90eXBlLmRpdm1vZCA9IGZ1bmN0aW9uIGRpdm1vZCAobnVtLCBtb2RlLCBwb3NpdGl2ZSkge1xuXHQgICAgYXNzZXJ0KCFudW0uaXNaZXJvKCkpO1xuXG5cdCAgICBpZiAodGhpcy5pc1plcm8oKSkge1xuXHQgICAgICByZXR1cm4ge1xuXHQgICAgICAgIGRpdjogbmV3IEJOKDApLFxuXHQgICAgICAgIG1vZDogbmV3IEJOKDApXG5cdCAgICAgIH07XG5cdCAgICB9XG5cblx0ICAgIHZhciBkaXYsIG1vZCwgcmVzO1xuXHQgICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDAgJiYgbnVtLm5lZ2F0aXZlID09PSAwKSB7XG5cdCAgICAgIHJlcyA9IHRoaXMubmVnKCkuZGl2bW9kKG51bSwgbW9kZSk7XG5cblx0ICAgICAgaWYgKG1vZGUgIT09ICdtb2QnKSB7XG5cdCAgICAgICAgZGl2ID0gcmVzLmRpdi5uZWcoKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChtb2RlICE9PSAnZGl2Jykge1xuXHQgICAgICAgIG1vZCA9IHJlcy5tb2QubmVnKCk7XG5cdCAgICAgICAgaWYgKHBvc2l0aXZlICYmIG1vZC5uZWdhdGl2ZSAhPT0gMCkge1xuXHQgICAgICAgICAgbW9kLmlhZGQobnVtKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICByZXR1cm4ge1xuXHQgICAgICAgIGRpdjogZGl2LFxuXHQgICAgICAgIG1vZDogbW9kXG5cdCAgICAgIH07XG5cdCAgICB9XG5cblx0ICAgIGlmICh0aGlzLm5lZ2F0aXZlID09PSAwICYmIG51bS5uZWdhdGl2ZSAhPT0gMCkge1xuXHQgICAgICByZXMgPSB0aGlzLmRpdm1vZChudW0ubmVnKCksIG1vZGUpO1xuXG5cdCAgICAgIGlmIChtb2RlICE9PSAnbW9kJykge1xuXHQgICAgICAgIGRpdiA9IHJlcy5kaXYubmVnKCk7XG5cdCAgICAgIH1cblxuXHQgICAgICByZXR1cm4ge1xuXHQgICAgICAgIGRpdjogZGl2LFxuXHQgICAgICAgIG1vZDogcmVzLm1vZFxuXHQgICAgICB9O1xuXHQgICAgfVxuXG5cdCAgICBpZiAoKHRoaXMubmVnYXRpdmUgJiBudW0ubmVnYXRpdmUpICE9PSAwKSB7XG5cdCAgICAgIHJlcyA9IHRoaXMubmVnKCkuZGl2bW9kKG51bS5uZWcoKSwgbW9kZSk7XG5cblx0ICAgICAgaWYgKG1vZGUgIT09ICdkaXYnKSB7XG5cdCAgICAgICAgbW9kID0gcmVzLm1vZC5uZWcoKTtcblx0ICAgICAgICBpZiAocG9zaXRpdmUgJiYgbW9kLm5lZ2F0aXZlICE9PSAwKSB7XG5cdCAgICAgICAgICBtb2QuaXN1YihudW0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIHJldHVybiB7XG5cdCAgICAgICAgZGl2OiByZXMuZGl2LFxuXHQgICAgICAgIG1vZDogbW9kXG5cdCAgICAgIH07XG5cdCAgICB9XG5cblx0ICAgIC8vIEJvdGggbnVtYmVycyBhcmUgcG9zaXRpdmUgYXQgdGhpcyBwb2ludFxuXG5cdCAgICAvLyBTdHJpcCBib3RoIG51bWJlcnMgdG8gYXBwcm94aW1hdGUgc2hpZnQgdmFsdWVcblx0ICAgIGlmIChudW0ubGVuZ3RoID4gdGhpcy5sZW5ndGggfHwgdGhpcy5jbXAobnVtKSA8IDApIHtcblx0ICAgICAgcmV0dXJuIHtcblx0ICAgICAgICBkaXY6IG5ldyBCTigwKSxcblx0ICAgICAgICBtb2Q6IHRoaXNcblx0ICAgICAgfTtcblx0ICAgIH1cblxuXHQgICAgLy8gVmVyeSBzaG9ydCByZWR1Y3Rpb25cblx0ICAgIGlmIChudW0ubGVuZ3RoID09PSAxKSB7XG5cdCAgICAgIGlmIChtb2RlID09PSAnZGl2Jykge1xuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICBkaXY6IHRoaXMuZGl2bihudW0ud29yZHNbMF0pLFxuXHQgICAgICAgICAgbW9kOiBudWxsXG5cdCAgICAgICAgfTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChtb2RlID09PSAnbW9kJykge1xuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICBkaXY6IG51bGwsXG5cdCAgICAgICAgICBtb2Q6IG5ldyBCTih0aGlzLm1vZG4obnVtLndvcmRzWzBdKSlcblx0ICAgICAgICB9O1xuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuIHtcblx0ICAgICAgICBkaXY6IHRoaXMuZGl2bihudW0ud29yZHNbMF0pLFxuXHQgICAgICAgIG1vZDogbmV3IEJOKHRoaXMubW9kbihudW0ud29yZHNbMF0pKVxuXHQgICAgICB9O1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdGhpcy5fd29yZERpdihudW0sIG1vZGUpO1xuXHQgIH07XG5cblx0ICAvLyBGaW5kIGB0aGlzYCAvIGBudW1gXG5cdCAgQk4ucHJvdG90eXBlLmRpdiA9IGZ1bmN0aW9uIGRpdiAobnVtKSB7XG5cdCAgICByZXR1cm4gdGhpcy5kaXZtb2QobnVtLCAnZGl2JywgZmFsc2UpLmRpdjtcblx0ICB9O1xuXG5cdCAgLy8gRmluZCBgdGhpc2AgJSBgbnVtYFxuXHQgIEJOLnByb3RvdHlwZS5tb2QgPSBmdW5jdGlvbiBtb2QgKG51bSkge1xuXHQgICAgcmV0dXJuIHRoaXMuZGl2bW9kKG51bSwgJ21vZCcsIGZhbHNlKS5tb2Q7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS51bW9kID0gZnVuY3Rpb24gdW1vZCAobnVtKSB7XG5cdCAgICByZXR1cm4gdGhpcy5kaXZtb2QobnVtLCAnbW9kJywgdHJ1ZSkubW9kO1xuXHQgIH07XG5cblx0ICAvLyBGaW5kIFJvdW5kKGB0aGlzYCAvIGBudW1gKVxuXHQgIEJOLnByb3RvdHlwZS5kaXZSb3VuZCA9IGZ1bmN0aW9uIGRpdlJvdW5kIChudW0pIHtcblx0ICAgIHZhciBkbSA9IHRoaXMuZGl2bW9kKG51bSk7XG5cblx0ICAgIC8vIEZhc3QgY2FzZSAtIGV4YWN0IGRpdmlzaW9uXG5cdCAgICBpZiAoZG0ubW9kLmlzWmVybygpKSByZXR1cm4gZG0uZGl2O1xuXG5cdCAgICB2YXIgbW9kID0gZG0uZGl2Lm5lZ2F0aXZlICE9PSAwID8gZG0ubW9kLmlzdWIobnVtKSA6IGRtLm1vZDtcblxuXHQgICAgdmFyIGhhbGYgPSBudW0udXNocm4oMSk7XG5cdCAgICB2YXIgcjIgPSBudW0uYW5kbG4oMSk7XG5cdCAgICB2YXIgY21wID0gbW9kLmNtcChoYWxmKTtcblxuXHQgICAgLy8gUm91bmQgZG93blxuXHQgICAgaWYgKGNtcCA8IDAgfHwgcjIgPT09IDEgJiYgY21wID09PSAwKSByZXR1cm4gZG0uZGl2O1xuXG5cdCAgICAvLyBSb3VuZCB1cFxuXHQgICAgcmV0dXJuIGRtLmRpdi5uZWdhdGl2ZSAhPT0gMCA/IGRtLmRpdi5pc3VibigxKSA6IGRtLmRpdi5pYWRkbigxKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLm1vZG4gPSBmdW5jdGlvbiBtb2RuIChudW0pIHtcblx0ICAgIGFzc2VydChudW0gPD0gMHgzZmZmZmZmKTtcblx0ICAgIHZhciBwID0gKDEgPDwgMjYpICUgbnVtO1xuXG5cdCAgICB2YXIgYWNjID0gMDtcblx0ICAgIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdCAgICAgIGFjYyA9IChwICogYWNjICsgKHRoaXMud29yZHNbaV0gfCAwKSkgJSBudW07XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBhY2M7XG5cdCAgfTtcblxuXHQgIC8vIEluLXBsYWNlIGRpdmlzaW9uIGJ5IG51bWJlclxuXHQgIEJOLnByb3RvdHlwZS5pZGl2biA9IGZ1bmN0aW9uIGlkaXZuIChudW0pIHtcblx0ICAgIGFzc2VydChudW0gPD0gMHgzZmZmZmZmKTtcblxuXHQgICAgdmFyIGNhcnJ5ID0gMDtcblx0ICAgIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdCAgICAgIHZhciB3ID0gKHRoaXMud29yZHNbaV0gfCAwKSArIGNhcnJ5ICogMHg0MDAwMDAwO1xuXHQgICAgICB0aGlzLndvcmRzW2ldID0gKHcgLyBudW0pIHwgMDtcblx0ICAgICAgY2FycnkgPSB3ICUgbnVtO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuZGl2biA9IGZ1bmN0aW9uIGRpdm4gKG51bSkge1xuXHQgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pZGl2bihudW0pO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuZWdjZCA9IGZ1bmN0aW9uIGVnY2QgKHApIHtcblx0ICAgIGFzc2VydChwLm5lZ2F0aXZlID09PSAwKTtcblx0ICAgIGFzc2VydCghcC5pc1plcm8oKSk7XG5cblx0ICAgIHZhciB4ID0gdGhpcztcblx0ICAgIHZhciB5ID0gcC5jbG9uZSgpO1xuXG5cdCAgICBpZiAoeC5uZWdhdGl2ZSAhPT0gMCkge1xuXHQgICAgICB4ID0geC51bW9kKHApO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgeCA9IHguY2xvbmUoKTtcblx0ICAgIH1cblxuXHQgICAgLy8gQSAqIHggKyBCICogeSA9IHhcblx0ICAgIHZhciBBID0gbmV3IEJOKDEpO1xuXHQgICAgdmFyIEIgPSBuZXcgQk4oMCk7XG5cblx0ICAgIC8vIEMgKiB4ICsgRCAqIHkgPSB5XG5cdCAgICB2YXIgQyA9IG5ldyBCTigwKTtcblx0ICAgIHZhciBEID0gbmV3IEJOKDEpO1xuXG5cdCAgICB2YXIgZyA9IDA7XG5cblx0ICAgIHdoaWxlICh4LmlzRXZlbigpICYmIHkuaXNFdmVuKCkpIHtcblx0ICAgICAgeC5pdXNocm4oMSk7XG5cdCAgICAgIHkuaXVzaHJuKDEpO1xuXHQgICAgICArK2c7XG5cdCAgICB9XG5cblx0ICAgIHZhciB5cCA9IHkuY2xvbmUoKTtcblx0ICAgIHZhciB4cCA9IHguY2xvbmUoKTtcblxuXHQgICAgd2hpbGUgKCF4LmlzWmVybygpKSB7XG5cdCAgICAgIGZvciAodmFyIGkgPSAwLCBpbSA9IDE7ICh4LndvcmRzWzBdICYgaW0pID09PSAwICYmIGkgPCAyNjsgKytpLCBpbSA8PD0gMSk7XG5cdCAgICAgIGlmIChpID4gMCkge1xuXHQgICAgICAgIHguaXVzaHJuKGkpO1xuXHQgICAgICAgIHdoaWxlIChpLS0gPiAwKSB7XG5cdCAgICAgICAgICBpZiAoQS5pc09kZCgpIHx8IEIuaXNPZGQoKSkge1xuXHQgICAgICAgICAgICBBLmlhZGQoeXApO1xuXHQgICAgICAgICAgICBCLmlzdWIoeHApO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICBBLml1c2hybigxKTtcblx0ICAgICAgICAgIEIuaXVzaHJuKDEpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIGZvciAodmFyIGogPSAwLCBqbSA9IDE7ICh5LndvcmRzWzBdICYgam0pID09PSAwICYmIGogPCAyNjsgKytqLCBqbSA8PD0gMSk7XG5cdCAgICAgIGlmIChqID4gMCkge1xuXHQgICAgICAgIHkuaXVzaHJuKGopO1xuXHQgICAgICAgIHdoaWxlIChqLS0gPiAwKSB7XG5cdCAgICAgICAgICBpZiAoQy5pc09kZCgpIHx8IEQuaXNPZGQoKSkge1xuXHQgICAgICAgICAgICBDLmlhZGQoeXApO1xuXHQgICAgICAgICAgICBELmlzdWIoeHApO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICBDLml1c2hybigxKTtcblx0ICAgICAgICAgIEQuaXVzaHJuKDEpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIGlmICh4LmNtcCh5KSA+PSAwKSB7XG5cdCAgICAgICAgeC5pc3ViKHkpO1xuXHQgICAgICAgIEEuaXN1YihDKTtcblx0ICAgICAgICBCLmlzdWIoRCk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgeS5pc3ViKHgpO1xuXHQgICAgICAgIEMuaXN1YihBKTtcblx0ICAgICAgICBELmlzdWIoQik7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHtcblx0ICAgICAgYTogQyxcblx0ICAgICAgYjogRCxcblx0ICAgICAgZ2NkOiB5Lml1c2hsbihnKVxuXHQgICAgfTtcblx0ICB9O1xuXG5cdCAgLy8gVGhpcyBpcyByZWR1Y2VkIGluY2FybmF0aW9uIG9mIHRoZSBiaW5hcnkgRUVBXG5cdCAgLy8gYWJvdmUsIGRlc2lnbmF0ZWQgdG8gaW52ZXJ0IG1lbWJlcnMgb2YgdGhlXG5cdCAgLy8gX3ByaW1lXyBmaWVsZHMgRihwKSBhdCBhIG1heGltYWwgc3BlZWRcblx0ICBCTi5wcm90b3R5cGUuX2ludm1wID0gZnVuY3Rpb24gX2ludm1wIChwKSB7XG5cdCAgICBhc3NlcnQocC5uZWdhdGl2ZSA9PT0gMCk7XG5cdCAgICBhc3NlcnQoIXAuaXNaZXJvKCkpO1xuXG5cdCAgICB2YXIgYSA9IHRoaXM7XG5cdCAgICB2YXIgYiA9IHAuY2xvbmUoKTtcblxuXHQgICAgaWYgKGEubmVnYXRpdmUgIT09IDApIHtcblx0ICAgICAgYSA9IGEudW1vZChwKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGEgPSBhLmNsb25lKCk7XG5cdCAgICB9XG5cblx0ICAgIHZhciB4MSA9IG5ldyBCTigxKTtcblx0ICAgIHZhciB4MiA9IG5ldyBCTigwKTtcblxuXHQgICAgdmFyIGRlbHRhID0gYi5jbG9uZSgpO1xuXG5cdCAgICB3aGlsZSAoYS5jbXBuKDEpID4gMCAmJiBiLmNtcG4oMSkgPiAwKSB7XG5cdCAgICAgIGZvciAodmFyIGkgPSAwLCBpbSA9IDE7IChhLndvcmRzWzBdICYgaW0pID09PSAwICYmIGkgPCAyNjsgKytpLCBpbSA8PD0gMSk7XG5cdCAgICAgIGlmIChpID4gMCkge1xuXHQgICAgICAgIGEuaXVzaHJuKGkpO1xuXHQgICAgICAgIHdoaWxlIChpLS0gPiAwKSB7XG5cdCAgICAgICAgICBpZiAoeDEuaXNPZGQoKSkge1xuXHQgICAgICAgICAgICB4MS5pYWRkKGRlbHRhKTtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgeDEuaXVzaHJuKDEpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIGZvciAodmFyIGogPSAwLCBqbSA9IDE7IChiLndvcmRzWzBdICYgam0pID09PSAwICYmIGogPCAyNjsgKytqLCBqbSA8PD0gMSk7XG5cdCAgICAgIGlmIChqID4gMCkge1xuXHQgICAgICAgIGIuaXVzaHJuKGopO1xuXHQgICAgICAgIHdoaWxlIChqLS0gPiAwKSB7XG5cdCAgICAgICAgICBpZiAoeDIuaXNPZGQoKSkge1xuXHQgICAgICAgICAgICB4Mi5pYWRkKGRlbHRhKTtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgeDIuaXVzaHJuKDEpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChhLmNtcChiKSA+PSAwKSB7XG5cdCAgICAgICAgYS5pc3ViKGIpO1xuXHQgICAgICAgIHgxLmlzdWIoeDIpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGIuaXN1YihhKTtcblx0ICAgICAgICB4Mi5pc3ViKHgxKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICB2YXIgcmVzO1xuXHQgICAgaWYgKGEuY21wbigxKSA9PT0gMCkge1xuXHQgICAgICByZXMgPSB4MTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHJlcyA9IHgyO1xuXHQgICAgfVxuXG5cdCAgICBpZiAocmVzLmNtcG4oMCkgPCAwKSB7XG5cdCAgICAgIHJlcy5pYWRkKHApO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gcmVzO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuZ2NkID0gZnVuY3Rpb24gZ2NkIChudW0pIHtcblx0ICAgIGlmICh0aGlzLmlzWmVybygpKSByZXR1cm4gbnVtLmFicygpO1xuXHQgICAgaWYgKG51bS5pc1plcm8oKSkgcmV0dXJuIHRoaXMuYWJzKCk7XG5cblx0ICAgIHZhciBhID0gdGhpcy5jbG9uZSgpO1xuXHQgICAgdmFyIGIgPSBudW0uY2xvbmUoKTtcblx0ICAgIGEubmVnYXRpdmUgPSAwO1xuXHQgICAgYi5uZWdhdGl2ZSA9IDA7XG5cblx0ICAgIC8vIFJlbW92ZSBjb21tb24gZmFjdG9yIG9mIHR3b1xuXHQgICAgZm9yICh2YXIgc2hpZnQgPSAwOyBhLmlzRXZlbigpICYmIGIuaXNFdmVuKCk7IHNoaWZ0KyspIHtcblx0ICAgICAgYS5pdXNocm4oMSk7XG5cdCAgICAgIGIuaXVzaHJuKDEpO1xuXHQgICAgfVxuXG5cdCAgICBkbyB7XG5cdCAgICAgIHdoaWxlIChhLmlzRXZlbigpKSB7XG5cdCAgICAgICAgYS5pdXNocm4oMSk7XG5cdCAgICAgIH1cblx0ICAgICAgd2hpbGUgKGIuaXNFdmVuKCkpIHtcblx0ICAgICAgICBiLml1c2hybigxKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHZhciByID0gYS5jbXAoYik7XG5cdCAgICAgIGlmIChyIDwgMCkge1xuXHQgICAgICAgIC8vIFN3YXAgYGFgIGFuZCBgYmAgdG8gbWFrZSBgYWAgYWx3YXlzIGJpZ2dlciB0aGFuIGBiYFxuXHQgICAgICAgIHZhciB0ID0gYTtcblx0ICAgICAgICBhID0gYjtcblx0ICAgICAgICBiID0gdDtcblx0ICAgICAgfSBlbHNlIGlmIChyID09PSAwIHx8IGIuY21wbigxKSA9PT0gMCkge1xuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgICB9XG5cblx0ICAgICAgYS5pc3ViKGIpO1xuXHQgICAgfSB3aGlsZSAodHJ1ZSk7XG5cblx0ICAgIHJldHVybiBiLml1c2hsbihzaGlmdCk7XG5cdCAgfTtcblxuXHQgIC8vIEludmVydCBudW1iZXIgaW4gdGhlIGZpZWxkIEYobnVtKVxuXHQgIEJOLnByb3RvdHlwZS5pbnZtID0gZnVuY3Rpb24gaW52bSAobnVtKSB7XG5cdCAgICByZXR1cm4gdGhpcy5lZ2NkKG51bSkuYS51bW9kKG51bSk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5pc0V2ZW4gPSBmdW5jdGlvbiBpc0V2ZW4gKCkge1xuXHQgICAgcmV0dXJuICh0aGlzLndvcmRzWzBdICYgMSkgPT09IDA7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5pc09kZCA9IGZ1bmN0aW9uIGlzT2RkICgpIHtcblx0ICAgIHJldHVybiAodGhpcy53b3Jkc1swXSAmIDEpID09PSAxO1xuXHQgIH07XG5cblx0ICAvLyBBbmQgZmlyc3Qgd29yZCBhbmQgbnVtXG5cdCAgQk4ucHJvdG90eXBlLmFuZGxuID0gZnVuY3Rpb24gYW5kbG4gKG51bSkge1xuXHQgICAgcmV0dXJuIHRoaXMud29yZHNbMF0gJiBudW07XG5cdCAgfTtcblxuXHQgIC8vIEluY3JlbWVudCBhdCB0aGUgYml0IHBvc2l0aW9uIGluLWxpbmVcblx0ICBCTi5wcm90b3R5cGUuYmluY24gPSBmdW5jdGlvbiBiaW5jbiAoYml0KSB7XG5cdCAgICBhc3NlcnQodHlwZW9mIGJpdCA9PT0gJ251bWJlcicpO1xuXHQgICAgdmFyIHIgPSBiaXQgJSAyNjtcblx0ICAgIHZhciBzID0gKGJpdCAtIHIpIC8gMjY7XG5cdCAgICB2YXIgcSA9IDEgPDwgcjtcblxuXHQgICAgLy8gRmFzdCBjYXNlOiBiaXQgaXMgbXVjaCBoaWdoZXIgdGhhbiBhbGwgZXhpc3Rpbmcgd29yZHNcblx0ICAgIGlmICh0aGlzLmxlbmd0aCA8PSBzKSB7XG5cdCAgICAgIHRoaXMuX2V4cGFuZChzICsgMSk7XG5cdCAgICAgIHRoaXMud29yZHNbc10gfD0gcTtcblx0ICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9XG5cblx0ICAgIC8vIEFkZCBiaXQgYW5kIHByb3BhZ2F0ZSwgaWYgbmVlZGVkXG5cdCAgICB2YXIgY2FycnkgPSBxO1xuXHQgICAgZm9yICh2YXIgaSA9IHM7IGNhcnJ5ICE9PSAwICYmIGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciB3ID0gdGhpcy53b3Jkc1tpXSB8IDA7XG5cdCAgICAgIHcgKz0gY2Fycnk7XG5cdCAgICAgIGNhcnJ5ID0gdyA+Pj4gMjY7XG5cdCAgICAgIHcgJj0gMHgzZmZmZmZmO1xuXHQgICAgICB0aGlzLndvcmRzW2ldID0gdztcblx0ICAgIH1cblx0ICAgIGlmIChjYXJyeSAhPT0gMCkge1xuXHQgICAgICB0aGlzLndvcmRzW2ldID0gY2Fycnk7XG5cdCAgICAgIHRoaXMubGVuZ3RoKys7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmlzWmVybyA9IGZ1bmN0aW9uIGlzWmVybyAoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5sZW5ndGggPT09IDEgJiYgdGhpcy53b3Jkc1swXSA9PT0gMDtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmNtcG4gPSBmdW5jdGlvbiBjbXBuIChudW0pIHtcblx0ICAgIHZhciBuZWdhdGl2ZSA9IG51bSA8IDA7XG5cblx0ICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwICYmICFuZWdhdGl2ZSkgcmV0dXJuIC0xO1xuXHQgICAgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgbmVnYXRpdmUpIHJldHVybiAxO1xuXG5cdCAgICB0aGlzLnN0cmlwKCk7XG5cblx0ICAgIHZhciByZXM7XG5cdCAgICBpZiAodGhpcy5sZW5ndGggPiAxKSB7XG5cdCAgICAgIHJlcyA9IDE7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBpZiAobmVnYXRpdmUpIHtcblx0ICAgICAgICBudW0gPSAtbnVtO1xuXHQgICAgICB9XG5cblx0ICAgICAgYXNzZXJ0KG51bSA8PSAweDNmZmZmZmYsICdOdW1iZXIgaXMgdG9vIGJpZycpO1xuXG5cdCAgICAgIHZhciB3ID0gdGhpcy53b3Jkc1swXSB8IDA7XG5cdCAgICAgIHJlcyA9IHcgPT09IG51bSA/IDAgOiB3IDwgbnVtID8gLTEgOiAxO1xuXHQgICAgfVxuXHQgICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHJldHVybiAtcmVzIHwgMDtcblx0ICAgIHJldHVybiByZXM7XG5cdCAgfTtcblxuXHQgIC8vIENvbXBhcmUgdHdvIG51bWJlcnMgYW5kIHJldHVybjpcblx0ICAvLyAxIC0gaWYgYHRoaXNgID4gYG51bWBcblx0ICAvLyAwIC0gaWYgYHRoaXNgID09IGBudW1gXG5cdCAgLy8gLTEgLSBpZiBgdGhpc2AgPCBgbnVtYFxuXHQgIEJOLnByb3RvdHlwZS5jbXAgPSBmdW5jdGlvbiBjbXAgKG51bSkge1xuXHQgICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDAgJiYgbnVtLm5lZ2F0aXZlID09PSAwKSByZXR1cm4gLTE7XG5cdCAgICBpZiAodGhpcy5uZWdhdGl2ZSA9PT0gMCAmJiBudW0ubmVnYXRpdmUgIT09IDApIHJldHVybiAxO1xuXG5cdCAgICB2YXIgcmVzID0gdGhpcy51Y21wKG51bSk7XG5cdCAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkgcmV0dXJuIC1yZXMgfCAwO1xuXHQgICAgcmV0dXJuIHJlcztcblx0ICB9O1xuXG5cdCAgLy8gVW5zaWduZWQgY29tcGFyaXNvblxuXHQgIEJOLnByb3RvdHlwZS51Y21wID0gZnVuY3Rpb24gdWNtcCAobnVtKSB7XG5cdCAgICAvLyBBdCB0aGlzIHBvaW50IGJvdGggbnVtYmVycyBoYXZlIHRoZSBzYW1lIHNpZ25cblx0ICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiAxO1xuXHQgICAgaWYgKHRoaXMubGVuZ3RoIDwgbnVtLmxlbmd0aCkgcmV0dXJuIC0xO1xuXG5cdCAgICB2YXIgcmVzID0gMDtcblx0ICAgIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdCAgICAgIHZhciBhID0gdGhpcy53b3Jkc1tpXSB8IDA7XG5cdCAgICAgIHZhciBiID0gbnVtLndvcmRzW2ldIHwgMDtcblxuXHQgICAgICBpZiAoYSA9PT0gYikgY29udGludWU7XG5cdCAgICAgIGlmIChhIDwgYikge1xuXHQgICAgICAgIHJlcyA9IC0xO1xuXHQgICAgICB9IGVsc2UgaWYgKGEgPiBiKSB7XG5cdCAgICAgICAgcmVzID0gMTtcblx0ICAgICAgfVxuXHQgICAgICBicmVhaztcblx0ICAgIH1cblx0ICAgIHJldHVybiByZXM7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5ndG4gPSBmdW5jdGlvbiBndG4gKG51bSkge1xuXHQgICAgcmV0dXJuIHRoaXMuY21wbihudW0pID09PSAxO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuZ3QgPSBmdW5jdGlvbiBndCAobnVtKSB7XG5cdCAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA9PT0gMTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmd0ZW4gPSBmdW5jdGlvbiBndGVuIChudW0pIHtcblx0ICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA+PSAwO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuZ3RlID0gZnVuY3Rpb24gZ3RlIChudW0pIHtcblx0ICAgIHJldHVybiB0aGlzLmNtcChudW0pID49IDA7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5sdG4gPSBmdW5jdGlvbiBsdG4gKG51bSkge1xuXHQgICAgcmV0dXJuIHRoaXMuY21wbihudW0pID09PSAtMTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmx0ID0gZnVuY3Rpb24gbHQgKG51bSkge1xuXHQgICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPT09IC0xO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUubHRlbiA9IGZ1bmN0aW9uIGx0ZW4gKG51bSkge1xuXHQgICAgcmV0dXJuIHRoaXMuY21wbihudW0pIDw9IDA7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5sdGUgPSBmdW5jdGlvbiBsdGUgKG51bSkge1xuXHQgICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPD0gMDtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmVxbiA9IGZ1bmN0aW9uIGVxbiAobnVtKSB7XG5cdCAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPT09IDA7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIGVxIChudW0pIHtcblx0ICAgIHJldHVybiB0aGlzLmNtcChudW0pID09PSAwO1xuXHQgIH07XG5cblx0ICAvL1xuXHQgIC8vIEEgcmVkdWNlIGNvbnRleHQsIGNvdWxkIGJlIHVzaW5nIG1vbnRnb21lcnkgb3Igc29tZXRoaW5nIGJldHRlciwgZGVwZW5kaW5nXG5cdCAgLy8gb24gdGhlIGBtYCBpdHNlbGYuXG5cdCAgLy9cblx0ICBCTi5yZWQgPSBmdW5jdGlvbiByZWQgKG51bSkge1xuXHQgICAgcmV0dXJuIG5ldyBSZWQobnVtKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLnRvUmVkID0gZnVuY3Rpb24gdG9SZWQgKGN0eCkge1xuXHQgICAgYXNzZXJ0KCF0aGlzLnJlZCwgJ0FscmVhZHkgYSBudW1iZXIgaW4gcmVkdWN0aW9uIGNvbnRleHQnKTtcblx0ICAgIGFzc2VydCh0aGlzLm5lZ2F0aXZlID09PSAwLCAncmVkIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZXMnKTtcblx0ICAgIHJldHVybiBjdHguY29udmVydFRvKHRoaXMpLl9mb3JjZVJlZChjdHgpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuZnJvbVJlZCA9IGZ1bmN0aW9uIGZyb21SZWQgKCkge1xuXHQgICAgYXNzZXJ0KHRoaXMucmVkLCAnZnJvbVJlZCB3b3JrcyBvbmx5IHdpdGggbnVtYmVycyBpbiByZWR1Y3Rpb24gY29udGV4dCcpO1xuXHQgICAgcmV0dXJuIHRoaXMucmVkLmNvbnZlcnRGcm9tKHRoaXMpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuX2ZvcmNlUmVkID0gZnVuY3Rpb24gX2ZvcmNlUmVkIChjdHgpIHtcblx0ICAgIHRoaXMucmVkID0gY3R4O1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5mb3JjZVJlZCA9IGZ1bmN0aW9uIGZvcmNlUmVkIChjdHgpIHtcblx0ICAgIGFzc2VydCghdGhpcy5yZWQsICdBbHJlYWR5IGEgbnVtYmVyIGluIHJlZHVjdGlvbiBjb250ZXh0Jyk7XG5cdCAgICByZXR1cm4gdGhpcy5fZm9yY2VSZWQoY3R4KTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLnJlZEFkZCA9IGZ1bmN0aW9uIHJlZEFkZCAobnVtKSB7XG5cdCAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRBZGQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG5cdCAgICByZXR1cm4gdGhpcy5yZWQuYWRkKHRoaXMsIG51bSk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5yZWRJQWRkID0gZnVuY3Rpb24gcmVkSUFkZCAobnVtKSB7XG5cdCAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRJQWRkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuXHQgICAgcmV0dXJuIHRoaXMucmVkLmlhZGQodGhpcywgbnVtKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLnJlZFN1YiA9IGZ1bmN0aW9uIHJlZFN1YiAobnVtKSB7XG5cdCAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRTdWIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG5cdCAgICByZXR1cm4gdGhpcy5yZWQuc3ViKHRoaXMsIG51bSk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5yZWRJU3ViID0gZnVuY3Rpb24gcmVkSVN1YiAobnVtKSB7XG5cdCAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRJU3ViIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuXHQgICAgcmV0dXJuIHRoaXMucmVkLmlzdWIodGhpcywgbnVtKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLnJlZFNobCA9IGZ1bmN0aW9uIHJlZFNobCAobnVtKSB7XG5cdCAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRTaGwgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG5cdCAgICByZXR1cm4gdGhpcy5yZWQuc2hsKHRoaXMsIG51bSk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5yZWRNdWwgPSBmdW5jdGlvbiByZWRNdWwgKG51bSkge1xuXHQgICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkTXVsIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuXHQgICAgdGhpcy5yZWQuX3ZlcmlmeTIodGhpcywgbnVtKTtcblx0ICAgIHJldHVybiB0aGlzLnJlZC5tdWwodGhpcywgbnVtKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLnJlZElNdWwgPSBmdW5jdGlvbiByZWRJTXVsIChudW0pIHtcblx0ICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZE11bCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcblx0ICAgIHRoaXMucmVkLl92ZXJpZnkyKHRoaXMsIG51bSk7XG5cdCAgICByZXR1cm4gdGhpcy5yZWQuaW11bCh0aGlzLCBudW0pO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUucmVkU3FyID0gZnVuY3Rpb24gcmVkU3FyICgpIHtcblx0ICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZFNxciB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcblx0ICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuXHQgICAgcmV0dXJuIHRoaXMucmVkLnNxcih0aGlzKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLnJlZElTcXIgPSBmdW5jdGlvbiByZWRJU3FyICgpIHtcblx0ICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZElTcXIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG5cdCAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcblx0ICAgIHJldHVybiB0aGlzLnJlZC5pc3FyKHRoaXMpO1xuXHQgIH07XG5cblx0ICAvLyBTcXVhcmUgcm9vdCBvdmVyIHBcblx0ICBCTi5wcm90b3R5cGUucmVkU3FydCA9IGZ1bmN0aW9uIHJlZFNxcnQgKCkge1xuXHQgICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkU3FydCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcblx0ICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuXHQgICAgcmV0dXJuIHRoaXMucmVkLnNxcnQodGhpcyk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5yZWRJbnZtID0gZnVuY3Rpb24gcmVkSW52bSAoKSB7XG5cdCAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRJbnZtIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuXHQgICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG5cdCAgICByZXR1cm4gdGhpcy5yZWQuaW52bSh0aGlzKTtcblx0ICB9O1xuXG5cdCAgLy8gUmV0dXJuIG5lZ2F0aXZlIGNsb25lIG9mIGB0aGlzYCAlIGByZWQgbW9kdWxvYFxuXHQgIEJOLnByb3RvdHlwZS5yZWROZWcgPSBmdW5jdGlvbiByZWROZWcgKCkge1xuXHQgICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkTmVnIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuXHQgICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG5cdCAgICByZXR1cm4gdGhpcy5yZWQubmVnKHRoaXMpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUucmVkUG93ID0gZnVuY3Rpb24gcmVkUG93IChudW0pIHtcblx0ICAgIGFzc2VydCh0aGlzLnJlZCAmJiAhbnVtLnJlZCwgJ3JlZFBvdyhub3JtYWxOdW0pJyk7XG5cdCAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcblx0ICAgIHJldHVybiB0aGlzLnJlZC5wb3codGhpcywgbnVtKTtcblx0ICB9O1xuXG5cdCAgLy8gUHJpbWUgbnVtYmVycyB3aXRoIGVmZmljaWVudCByZWR1Y3Rpb25cblx0ICB2YXIgcHJpbWVzID0ge1xuXHQgICAgazI1NjogbnVsbCxcblx0ICAgIHAyMjQ6IG51bGwsXG5cdCAgICBwMTkyOiBudWxsLFxuXHQgICAgcDI1NTE5OiBudWxsXG5cdCAgfTtcblxuXHQgIC8vIFBzZXVkby1NZXJzZW5uZSBwcmltZVxuXHQgIGZ1bmN0aW9uIE1QcmltZSAobmFtZSwgcCkge1xuXHQgICAgLy8gUCA9IDIgXiBOIC0gS1xuXHQgICAgdGhpcy5uYW1lID0gbmFtZTtcblx0ICAgIHRoaXMucCA9IG5ldyBCTihwLCAxNik7XG5cdCAgICB0aGlzLm4gPSB0aGlzLnAuYml0TGVuZ3RoKCk7XG5cdCAgICB0aGlzLmsgPSBuZXcgQk4oMSkuaXVzaGxuKHRoaXMubikuaXN1Yih0aGlzLnApO1xuXG5cdCAgICB0aGlzLnRtcCA9IHRoaXMuX3RtcCgpO1xuXHQgIH1cblxuXHQgIE1QcmltZS5wcm90b3R5cGUuX3RtcCA9IGZ1bmN0aW9uIF90bXAgKCkge1xuXHQgICAgdmFyIHRtcCA9IG5ldyBCTihudWxsKTtcblx0ICAgIHRtcC53b3JkcyA9IG5ldyBBcnJheShNYXRoLmNlaWwodGhpcy5uIC8gMTMpKTtcblx0ICAgIHJldHVybiB0bXA7XG5cdCAgfTtcblxuXHQgIE1QcmltZS5wcm90b3R5cGUuaXJlZHVjZSA9IGZ1bmN0aW9uIGlyZWR1Y2UgKG51bSkge1xuXHQgICAgLy8gQXNzdW1lcyB0aGF0IGBudW1gIGlzIGxlc3MgdGhhbiBgUF4yYFxuXHQgICAgLy8gbnVtID0gSEkgKiAoMiBeIE4gLSBLKSArIEhJICogSyArIExPID0gSEkgKiBLICsgTE8gKG1vZCBQKVxuXHQgICAgdmFyIHIgPSBudW07XG5cdCAgICB2YXIgcmxlbjtcblxuXHQgICAgZG8ge1xuXHQgICAgICB0aGlzLnNwbGl0KHIsIHRoaXMudG1wKTtcblx0ICAgICAgciA9IHRoaXMuaW11bEsocik7XG5cdCAgICAgIHIgPSByLmlhZGQodGhpcy50bXApO1xuXHQgICAgICBybGVuID0gci5iaXRMZW5ndGgoKTtcblx0ICAgIH0gd2hpbGUgKHJsZW4gPiB0aGlzLm4pO1xuXG5cdCAgICB2YXIgY21wID0gcmxlbiA8IHRoaXMubiA/IC0xIDogci51Y21wKHRoaXMucCk7XG5cdCAgICBpZiAoY21wID09PSAwKSB7XG5cdCAgICAgIHIud29yZHNbMF0gPSAwO1xuXHQgICAgICByLmxlbmd0aCA9IDE7XG5cdCAgICB9IGVsc2UgaWYgKGNtcCA+IDApIHtcblx0ICAgICAgci5pc3ViKHRoaXMucCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBpZiAoci5zdHJpcCAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgLy8gciBpcyBCTiB2NCBpbnN0YW5jZVxuXHQgICAgICAgIHIuc3RyaXAoKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAvLyByIGlzIEJOIHY1IGluc3RhbmNlXG5cdCAgICAgICAgci5fc3RyaXAoKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gcjtcblx0ICB9O1xuXG5cdCAgTVByaW1lLnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIHNwbGl0IChpbnB1dCwgb3V0KSB7XG5cdCAgICBpbnB1dC5pdXNocm4odGhpcy5uLCAwLCBvdXQpO1xuXHQgIH07XG5cblx0ICBNUHJpbWUucHJvdG90eXBlLmltdWxLID0gZnVuY3Rpb24gaW11bEsgKG51bSkge1xuXHQgICAgcmV0dXJuIG51bS5pbXVsKHRoaXMuayk7XG5cdCAgfTtcblxuXHQgIGZ1bmN0aW9uIEsyNTYgKCkge1xuXHQgICAgTVByaW1lLmNhbGwoXG5cdCAgICAgIHRoaXMsXG5cdCAgICAgICdrMjU2Jyxcblx0ICAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmYzJmJyk7XG5cdCAgfVxuXHQgIGluaGVyaXRzKEsyNTYsIE1QcmltZSk7XG5cblx0ICBLMjU2LnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIHNwbGl0IChpbnB1dCwgb3V0cHV0KSB7XG5cdCAgICAvLyAyNTYgPSA5ICogMjYgKyAyMlxuXHQgICAgdmFyIG1hc2sgPSAweDNmZmZmZjtcblxuXHQgICAgdmFyIG91dExlbiA9IE1hdGgubWluKGlucHV0Lmxlbmd0aCwgOSk7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IG91dExlbjsgaSsrKSB7XG5cdCAgICAgIG91dHB1dC53b3Jkc1tpXSA9IGlucHV0LndvcmRzW2ldO1xuXHQgICAgfVxuXHQgICAgb3V0cHV0Lmxlbmd0aCA9IG91dExlbjtcblxuXHQgICAgaWYgKGlucHV0Lmxlbmd0aCA8PSA5KSB7XG5cdCAgICAgIGlucHV0LndvcmRzWzBdID0gMDtcblx0ICAgICAgaW5wdXQubGVuZ3RoID0gMTtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXG5cdCAgICAvLyBTaGlmdCBieSA5IGxpbWJzXG5cdCAgICB2YXIgcHJldiA9IGlucHV0LndvcmRzWzldO1xuXHQgICAgb3V0cHV0LndvcmRzW291dHB1dC5sZW5ndGgrK10gPSBwcmV2ICYgbWFzaztcblxuXHQgICAgZm9yIChpID0gMTA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuXHQgICAgICB2YXIgbmV4dCA9IGlucHV0LndvcmRzW2ldIHwgMDtcblx0ICAgICAgaW5wdXQud29yZHNbaSAtIDEwXSA9ICgobmV4dCAmIG1hc2spIDw8IDQpIHwgKHByZXYgPj4+IDIyKTtcblx0ICAgICAgcHJldiA9IG5leHQ7XG5cdCAgICB9XG5cdCAgICBwcmV2ID4+Pj0gMjI7XG5cdCAgICBpbnB1dC53b3Jkc1tpIC0gMTBdID0gcHJldjtcblx0ICAgIGlmIChwcmV2ID09PSAwICYmIGlucHV0Lmxlbmd0aCA+IDEwKSB7XG5cdCAgICAgIGlucHV0Lmxlbmd0aCAtPSAxMDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGlucHV0Lmxlbmd0aCAtPSA5O1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICBLMjU2LnByb3RvdHlwZS5pbXVsSyA9IGZ1bmN0aW9uIGltdWxLIChudW0pIHtcblx0ICAgIC8vIEsgPSAweDEwMDAwMDNkMSA9IFsgMHg0MCwgMHgzZDEgXVxuXHQgICAgbnVtLndvcmRzW251bS5sZW5ndGhdID0gMDtcblx0ICAgIG51bS53b3Jkc1tudW0ubGVuZ3RoICsgMV0gPSAwO1xuXHQgICAgbnVtLmxlbmd0aCArPSAyO1xuXG5cdCAgICAvLyBib3VuZGVkIGF0OiAweDQwICogMHgzZmZmZmZmICsgMHgzZDAgPSAweDEwMDAwMDM5MFxuXHQgICAgdmFyIGxvID0gMDtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciB3ID0gbnVtLndvcmRzW2ldIHwgMDtcblx0ICAgICAgbG8gKz0gdyAqIDB4M2QxO1xuXHQgICAgICBudW0ud29yZHNbaV0gPSBsbyAmIDB4M2ZmZmZmZjtcblx0ICAgICAgbG8gPSB3ICogMHg0MCArICgobG8gLyAweDQwMDAwMDApIHwgMCk7XG5cdCAgICB9XG5cblx0ICAgIC8vIEZhc3QgbGVuZ3RoIHJlZHVjdGlvblxuXHQgICAgaWYgKG51bS53b3Jkc1tudW0ubGVuZ3RoIC0gMV0gPT09IDApIHtcblx0ICAgICAgbnVtLmxlbmd0aC0tO1xuXHQgICAgICBpZiAobnVtLndvcmRzW251bS5sZW5ndGggLSAxXSA9PT0gMCkge1xuXHQgICAgICAgIG51bS5sZW5ndGgtLTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIG51bTtcblx0ICB9O1xuXG5cdCAgZnVuY3Rpb24gUDIyNCAoKSB7XG5cdCAgICBNUHJpbWUuY2FsbChcblx0ICAgICAgdGhpcyxcblx0ICAgICAgJ3AyMjQnLFxuXHQgICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgMDAwMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDEnKTtcblx0ICB9XG5cdCAgaW5oZXJpdHMoUDIyNCwgTVByaW1lKTtcblxuXHQgIGZ1bmN0aW9uIFAxOTIgKCkge1xuXHQgICAgTVByaW1lLmNhbGwoXG5cdCAgICAgIHRoaXMsXG5cdCAgICAgICdwMTkyJyxcblx0ICAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmZmZmIGZmZmZmZmZmJyk7XG5cdCAgfVxuXHQgIGluaGVyaXRzKFAxOTIsIE1QcmltZSk7XG5cblx0ICBmdW5jdGlvbiBQMjU1MTkgKCkge1xuXHQgICAgLy8gMiBeIDI1NSAtIDE5XG5cdCAgICBNUHJpbWUuY2FsbChcblx0ICAgICAgdGhpcyxcblx0ICAgICAgJzI1NTE5Jyxcblx0ICAgICAgJzdmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZWQnKTtcblx0ICB9XG5cdCAgaW5oZXJpdHMoUDI1NTE5LCBNUHJpbWUpO1xuXG5cdCAgUDI1NTE5LnByb3RvdHlwZS5pbXVsSyA9IGZ1bmN0aW9uIGltdWxLIChudW0pIHtcblx0ICAgIC8vIEsgPSAweDEzXG5cdCAgICB2YXIgY2FycnkgPSAwO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW0ubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIGhpID0gKG51bS53b3Jkc1tpXSB8IDApICogMHgxMyArIGNhcnJ5O1xuXHQgICAgICB2YXIgbG8gPSBoaSAmIDB4M2ZmZmZmZjtcblx0ICAgICAgaGkgPj4+PSAyNjtcblxuXHQgICAgICBudW0ud29yZHNbaV0gPSBsbztcblx0ICAgICAgY2FycnkgPSBoaTtcblx0ICAgIH1cblx0ICAgIGlmIChjYXJyeSAhPT0gMCkge1xuXHQgICAgICBudW0ud29yZHNbbnVtLmxlbmd0aCsrXSA9IGNhcnJ5O1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIG51bTtcblx0ICB9O1xuXG5cdCAgLy8gRXhwb3J0ZWQgbW9zdGx5IGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB1c2UgcGxhaW4gbmFtZSBpbnN0ZWFkXG5cdCAgQk4uX3ByaW1lID0gZnVuY3Rpb24gcHJpbWUgKG5hbWUpIHtcblx0ICAgIC8vIENhY2hlZCB2ZXJzaW9uIG9mIHByaW1lXG5cdCAgICBpZiAocHJpbWVzW25hbWVdKSByZXR1cm4gcHJpbWVzW25hbWVdO1xuXG5cdCAgICB2YXIgcHJpbWU7XG5cdCAgICBpZiAobmFtZSA9PT0gJ2syNTYnKSB7XG5cdCAgICAgIHByaW1lID0gbmV3IEsyNTYoKTtcblx0ICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3AyMjQnKSB7XG5cdCAgICAgIHByaW1lID0gbmV3IFAyMjQoKTtcblx0ICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3AxOTInKSB7XG5cdCAgICAgIHByaW1lID0gbmV3IFAxOTIoKTtcblx0ICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3AyNTUxOScpIHtcblx0ICAgICAgcHJpbWUgPSBuZXcgUDI1NTE5KCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gcHJpbWUgJyArIG5hbWUpO1xuXHQgICAgfVxuXHQgICAgcHJpbWVzW25hbWVdID0gcHJpbWU7XG5cblx0ICAgIHJldHVybiBwcmltZTtcblx0ICB9O1xuXG5cdCAgLy9cblx0ICAvLyBCYXNlIHJlZHVjdGlvbiBlbmdpbmVcblx0ICAvL1xuXHQgIGZ1bmN0aW9uIFJlZCAobSkge1xuXHQgICAgaWYgKHR5cGVvZiBtID09PSAnc3RyaW5nJykge1xuXHQgICAgICB2YXIgcHJpbWUgPSBCTi5fcHJpbWUobSk7XG5cdCAgICAgIHRoaXMubSA9IHByaW1lLnA7XG5cdCAgICAgIHRoaXMucHJpbWUgPSBwcmltZTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGFzc2VydChtLmd0bigxKSwgJ21vZHVsdXMgbXVzdCBiZSBncmVhdGVyIHRoYW4gMScpO1xuXHQgICAgICB0aGlzLm0gPSBtO1xuXHQgICAgICB0aGlzLnByaW1lID0gbnVsbDtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBSZWQucHJvdG90eXBlLl92ZXJpZnkxID0gZnVuY3Rpb24gX3ZlcmlmeTEgKGEpIHtcblx0ICAgIGFzc2VydChhLm5lZ2F0aXZlID09PSAwLCAncmVkIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZXMnKTtcblx0ICAgIGFzc2VydChhLnJlZCwgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcblx0ICB9O1xuXG5cdCAgUmVkLnByb3RvdHlwZS5fdmVyaWZ5MiA9IGZ1bmN0aW9uIF92ZXJpZnkyIChhLCBiKSB7XG5cdCAgICBhc3NlcnQoKGEubmVnYXRpdmUgfCBiLm5lZ2F0aXZlKSA9PT0gMCwgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmVzJyk7XG5cdCAgICBhc3NlcnQoYS5yZWQgJiYgYS5yZWQgPT09IGIucmVkLFxuXHQgICAgICAncmVkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuXHQgIH07XG5cblx0ICBSZWQucHJvdG90eXBlLmltb2QgPSBmdW5jdGlvbiBpbW9kIChhKSB7XG5cdCAgICBpZiAodGhpcy5wcmltZSkgcmV0dXJuIHRoaXMucHJpbWUuaXJlZHVjZShhKS5fZm9yY2VSZWQodGhpcyk7XG5cdCAgICByZXR1cm4gYS51bW9kKHRoaXMubSkuX2ZvcmNlUmVkKHRoaXMpO1xuXHQgIH07XG5cblx0ICBSZWQucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uIG5lZyAoYSkge1xuXHQgICAgaWYgKGEuaXNaZXJvKCkpIHtcblx0ICAgICAgcmV0dXJuIGEuY2xvbmUoKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHRoaXMubS5zdWIoYSkuX2ZvcmNlUmVkKHRoaXMpO1xuXHQgIH07XG5cblx0ICBSZWQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoYSwgYikge1xuXHQgICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuXHQgICAgdmFyIHJlcyA9IGEuYWRkKGIpO1xuXHQgICAgaWYgKHJlcy5jbXAodGhpcy5tKSA+PSAwKSB7XG5cdCAgICAgIHJlcy5pc3ViKHRoaXMubSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcblx0ICB9O1xuXG5cdCAgUmVkLnByb3RvdHlwZS5pYWRkID0gZnVuY3Rpb24gaWFkZCAoYSwgYikge1xuXHQgICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuXHQgICAgdmFyIHJlcyA9IGEuaWFkZChiKTtcblx0ICAgIGlmIChyZXMuY21wKHRoaXMubSkgPj0gMCkge1xuXHQgICAgICByZXMuaXN1Yih0aGlzLm0pO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlcztcblx0ICB9O1xuXG5cdCAgUmVkLnByb3RvdHlwZS5zdWIgPSBmdW5jdGlvbiBzdWIgKGEsIGIpIHtcblx0ICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cblx0ICAgIHZhciByZXMgPSBhLnN1YihiKTtcblx0ICAgIGlmIChyZXMuY21wbigwKSA8IDApIHtcblx0ICAgICAgcmVzLmlhZGQodGhpcy5tKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuXHQgIH07XG5cblx0ICBSZWQucHJvdG90eXBlLmlzdWIgPSBmdW5jdGlvbiBpc3ViIChhLCBiKSB7XG5cdCAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuXG5cdCAgICB2YXIgcmVzID0gYS5pc3ViKGIpO1xuXHQgICAgaWYgKHJlcy5jbXBuKDApIDwgMCkge1xuXHQgICAgICByZXMuaWFkZCh0aGlzLm0pO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlcztcblx0ICB9O1xuXG5cdCAgUmVkLnByb3RvdHlwZS5zaGwgPSBmdW5jdGlvbiBzaGwgKGEsIG51bSkge1xuXHQgICAgdGhpcy5fdmVyaWZ5MShhKTtcblx0ICAgIHJldHVybiB0aGlzLmltb2QoYS51c2hsbihudW0pKTtcblx0ICB9O1xuXG5cdCAgUmVkLnByb3RvdHlwZS5pbXVsID0gZnVuY3Rpb24gaW11bCAoYSwgYikge1xuXHQgICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblx0ICAgIHJldHVybiB0aGlzLmltb2QoYS5pbXVsKGIpKTtcblx0ICB9O1xuXG5cdCAgUmVkLnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwgKGEsIGIpIHtcblx0ICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cdCAgICByZXR1cm4gdGhpcy5pbW9kKGEubXVsKGIpKTtcblx0ICB9O1xuXG5cdCAgUmVkLnByb3RvdHlwZS5pc3FyID0gZnVuY3Rpb24gaXNxciAoYSkge1xuXHQgICAgcmV0dXJuIHRoaXMuaW11bChhLCBhLmNsb25lKCkpO1xuXHQgIH07XG5cblx0ICBSZWQucHJvdG90eXBlLnNxciA9IGZ1bmN0aW9uIHNxciAoYSkge1xuXHQgICAgcmV0dXJuIHRoaXMubXVsKGEsIGEpO1xuXHQgIH07XG5cblx0ICBSZWQucHJvdG90eXBlLnNxcnQgPSBmdW5jdGlvbiBzcXJ0IChhKSB7XG5cdCAgICBpZiAoYS5pc1plcm8oKSkgcmV0dXJuIGEuY2xvbmUoKTtcblxuXHQgICAgdmFyIG1vZDMgPSB0aGlzLm0uYW5kbG4oMyk7XG5cdCAgICBhc3NlcnQobW9kMyAlIDIgPT09IDEpO1xuXG5cdCAgICAvLyBGYXN0IGNhc2Vcblx0ICAgIGlmIChtb2QzID09PSAzKSB7XG5cdCAgICAgIHZhciBwb3cgPSB0aGlzLm0uYWRkKG5ldyBCTigxKSkuaXVzaHJuKDIpO1xuXHQgICAgICByZXR1cm4gdGhpcy5wb3coYSwgcG93KTtcblx0ICAgIH1cblxuXHQgICAgLy8gVG9uZWxsaS1TaGFua3MgYWxnb3JpdGhtIChUb3RhbGx5IHVub3B0aW1pemVkIGFuZCBzbG93KVxuXHQgICAgLy9cblx0ICAgIC8vIEZpbmQgUSBhbmQgUywgdGhhdCBRICogMiBeIFMgPSAoUCAtIDEpXG5cdCAgICB2YXIgcSA9IHRoaXMubS5zdWJuKDEpO1xuXHQgICAgdmFyIHMgPSAwO1xuXHQgICAgd2hpbGUgKCFxLmlzWmVybygpICYmIHEuYW5kbG4oMSkgPT09IDApIHtcblx0ICAgICAgcysrO1xuXHQgICAgICBxLml1c2hybigxKTtcblx0ICAgIH1cblx0ICAgIGFzc2VydCghcS5pc1plcm8oKSk7XG5cblx0ICAgIHZhciBvbmUgPSBuZXcgQk4oMSkudG9SZWQodGhpcyk7XG5cdCAgICB2YXIgbk9uZSA9IG9uZS5yZWROZWcoKTtcblxuXHQgICAgLy8gRmluZCBxdWFkcmF0aWMgbm9uLXJlc2lkdWVcblx0ICAgIC8vIE5PVEU6IE1heCBpcyBzdWNoIGJlY2F1c2Ugb2YgZ2VuZXJhbGl6ZWQgUmllbWFubiBoeXBvdGhlc2lzLlxuXHQgICAgdmFyIGxwb3cgPSB0aGlzLm0uc3VibigxKS5pdXNocm4oMSk7XG5cdCAgICB2YXIgeiA9IHRoaXMubS5iaXRMZW5ndGgoKTtcblx0ICAgIHogPSBuZXcgQk4oMiAqIHogKiB6KS50b1JlZCh0aGlzKTtcblxuXHQgICAgd2hpbGUgKHRoaXMucG93KHosIGxwb3cpLmNtcChuT25lKSAhPT0gMCkge1xuXHQgICAgICB6LnJlZElBZGQobk9uZSk7XG5cdCAgICB9XG5cblx0ICAgIHZhciBjID0gdGhpcy5wb3coeiwgcSk7XG5cdCAgICB2YXIgciA9IHRoaXMucG93KGEsIHEuYWRkbigxKS5pdXNocm4oMSkpO1xuXHQgICAgdmFyIHQgPSB0aGlzLnBvdyhhLCBxKTtcblx0ICAgIHZhciBtID0gcztcblx0ICAgIHdoaWxlICh0LmNtcChvbmUpICE9PSAwKSB7XG5cdCAgICAgIHZhciB0bXAgPSB0O1xuXHQgICAgICBmb3IgKHZhciBpID0gMDsgdG1wLmNtcChvbmUpICE9PSAwOyBpKyspIHtcblx0ICAgICAgICB0bXAgPSB0bXAucmVkU3FyKCk7XG5cdCAgICAgIH1cblx0ICAgICAgYXNzZXJ0KGkgPCBtKTtcblx0ICAgICAgdmFyIGIgPSB0aGlzLnBvdyhjLCBuZXcgQk4oMSkuaXVzaGxuKG0gLSBpIC0gMSkpO1xuXG5cdCAgICAgIHIgPSByLnJlZE11bChiKTtcblx0ICAgICAgYyA9IGIucmVkU3FyKCk7XG5cdCAgICAgIHQgPSB0LnJlZE11bChjKTtcblx0ICAgICAgbSA9IGk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiByO1xuXHQgIH07XG5cblx0ICBSZWQucHJvdG90eXBlLmludm0gPSBmdW5jdGlvbiBpbnZtIChhKSB7XG5cdCAgICB2YXIgaW52ID0gYS5faW52bXAodGhpcy5tKTtcblx0ICAgIGlmIChpbnYubmVnYXRpdmUgIT09IDApIHtcblx0ICAgICAgaW52Lm5lZ2F0aXZlID0gMDtcblx0ICAgICAgcmV0dXJuIHRoaXMuaW1vZChpbnYpLnJlZE5lZygpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuaW1vZChpbnYpO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICBSZWQucHJvdG90eXBlLnBvdyA9IGZ1bmN0aW9uIHBvdyAoYSwgbnVtKSB7XG5cdCAgICBpZiAobnVtLmlzWmVybygpKSByZXR1cm4gbmV3IEJOKDEpLnRvUmVkKHRoaXMpO1xuXHQgICAgaWYgKG51bS5jbXBuKDEpID09PSAwKSByZXR1cm4gYS5jbG9uZSgpO1xuXG5cdCAgICB2YXIgd2luZG93U2l6ZSA9IDQ7XG5cdCAgICB2YXIgd25kID0gbmV3IEFycmF5KDEgPDwgd2luZG93U2l6ZSk7XG5cdCAgICB3bmRbMF0gPSBuZXcgQk4oMSkudG9SZWQodGhpcyk7XG5cdCAgICB3bmRbMV0gPSBhO1xuXHQgICAgZm9yICh2YXIgaSA9IDI7IGkgPCB3bmQubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgd25kW2ldID0gdGhpcy5tdWwod25kW2kgLSAxXSwgYSk7XG5cdCAgICB9XG5cblx0ICAgIHZhciByZXMgPSB3bmRbMF07XG5cdCAgICB2YXIgY3VycmVudCA9IDA7XG5cdCAgICB2YXIgY3VycmVudExlbiA9IDA7XG5cdCAgICB2YXIgc3RhcnQgPSBudW0uYml0TGVuZ3RoKCkgJSAyNjtcblx0ICAgIGlmIChzdGFydCA9PT0gMCkge1xuXHQgICAgICBzdGFydCA9IDI2O1xuXHQgICAgfVxuXG5cdCAgICBmb3IgKGkgPSBudW0ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0ICAgICAgdmFyIHdvcmQgPSBudW0ud29yZHNbaV07XG5cdCAgICAgIGZvciAodmFyIGogPSBzdGFydCAtIDE7IGogPj0gMDsgai0tKSB7XG5cdCAgICAgICAgdmFyIGJpdCA9ICh3b3JkID4+IGopICYgMTtcblx0ICAgICAgICBpZiAocmVzICE9PSB3bmRbMF0pIHtcblx0ICAgICAgICAgIHJlcyA9IHRoaXMuc3FyKHJlcyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKGJpdCA9PT0gMCAmJiBjdXJyZW50ID09PSAwKSB7XG5cdCAgICAgICAgICBjdXJyZW50TGVuID0gMDtcblx0ICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGN1cnJlbnQgPDw9IDE7XG5cdCAgICAgICAgY3VycmVudCB8PSBiaXQ7XG5cdCAgICAgICAgY3VycmVudExlbisrO1xuXHQgICAgICAgIGlmIChjdXJyZW50TGVuICE9PSB3aW5kb3dTaXplICYmIChpICE9PSAwIHx8IGogIT09IDApKSBjb250aW51ZTtcblxuXHQgICAgICAgIHJlcyA9IHRoaXMubXVsKHJlcywgd25kW2N1cnJlbnRdKTtcblx0ICAgICAgICBjdXJyZW50TGVuID0gMDtcblx0ICAgICAgICBjdXJyZW50ID0gMDtcblx0ICAgICAgfVxuXHQgICAgICBzdGFydCA9IDI2O1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gcmVzO1xuXHQgIH07XG5cblx0ICBSZWQucHJvdG90eXBlLmNvbnZlcnRUbyA9IGZ1bmN0aW9uIGNvbnZlcnRUbyAobnVtKSB7XG5cdCAgICB2YXIgciA9IG51bS51bW9kKHRoaXMubSk7XG5cblx0ICAgIHJldHVybiByID09PSBudW0gPyByLmNsb25lKCkgOiByO1xuXHQgIH07XG5cblx0ICBSZWQucHJvdG90eXBlLmNvbnZlcnRGcm9tID0gZnVuY3Rpb24gY29udmVydEZyb20gKG51bSkge1xuXHQgICAgdmFyIHJlcyA9IG51bS5jbG9uZSgpO1xuXHQgICAgcmVzLnJlZCA9IG51bGw7XG5cdCAgICByZXR1cm4gcmVzO1xuXHQgIH07XG5cblx0ICAvL1xuXHQgIC8vIE1vbnRnb21lcnkgbWV0aG9kIGVuZ2luZVxuXHQgIC8vXG5cblx0ICBCTi5tb250ID0gZnVuY3Rpb24gbW9udCAobnVtKSB7XG5cdCAgICByZXR1cm4gbmV3IE1vbnQobnVtKTtcblx0ICB9O1xuXG5cdCAgZnVuY3Rpb24gTW9udCAobSkge1xuXHQgICAgUmVkLmNhbGwodGhpcywgbSk7XG5cblx0ICAgIHRoaXMuc2hpZnQgPSB0aGlzLm0uYml0TGVuZ3RoKCk7XG5cdCAgICBpZiAodGhpcy5zaGlmdCAlIDI2ICE9PSAwKSB7XG5cdCAgICAgIHRoaXMuc2hpZnQgKz0gMjYgLSAodGhpcy5zaGlmdCAlIDI2KTtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5yID0gbmV3IEJOKDEpLml1c2hsbih0aGlzLnNoaWZ0KTtcblx0ICAgIHRoaXMucjIgPSB0aGlzLmltb2QodGhpcy5yLnNxcigpKTtcblx0ICAgIHRoaXMucmludiA9IHRoaXMuci5faW52bXAodGhpcy5tKTtcblxuXHQgICAgdGhpcy5taW52ID0gdGhpcy5yaW52Lm11bCh0aGlzLnIpLmlzdWJuKDEpLmRpdih0aGlzLm0pO1xuXHQgICAgdGhpcy5taW52ID0gdGhpcy5taW52LnVtb2QodGhpcy5yKTtcblx0ICAgIHRoaXMubWludiA9IHRoaXMuci5zdWIodGhpcy5taW52KTtcblx0ICB9XG5cdCAgaW5oZXJpdHMoTW9udCwgUmVkKTtcblxuXHQgIE1vbnQucHJvdG90eXBlLmNvbnZlcnRUbyA9IGZ1bmN0aW9uIGNvbnZlcnRUbyAobnVtKSB7XG5cdCAgICByZXR1cm4gdGhpcy5pbW9kKG51bS51c2hsbih0aGlzLnNoaWZ0KSk7XG5cdCAgfTtcblxuXHQgIE1vbnQucHJvdG90eXBlLmNvbnZlcnRGcm9tID0gZnVuY3Rpb24gY29udmVydEZyb20gKG51bSkge1xuXHQgICAgdmFyIHIgPSB0aGlzLmltb2QobnVtLm11bCh0aGlzLnJpbnYpKTtcblx0ICAgIHIucmVkID0gbnVsbDtcblx0ICAgIHJldHVybiByO1xuXHQgIH07XG5cblx0ICBNb250LnByb3RvdHlwZS5pbXVsID0gZnVuY3Rpb24gaW11bCAoYSwgYikge1xuXHQgICAgaWYgKGEuaXNaZXJvKCkgfHwgYi5pc1plcm8oKSkge1xuXHQgICAgICBhLndvcmRzWzBdID0gMDtcblx0ICAgICAgYS5sZW5ndGggPSAxO1xuXHQgICAgICByZXR1cm4gYTtcblx0ICAgIH1cblxuXHQgICAgdmFyIHQgPSBhLmltdWwoYik7XG5cdCAgICB2YXIgYyA9IHQubWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubWludikuaW1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm0pO1xuXHQgICAgdmFyIHUgPSB0LmlzdWIoYykuaXVzaHJuKHRoaXMuc2hpZnQpO1xuXHQgICAgdmFyIHJlcyA9IHU7XG5cblx0ICAgIGlmICh1LmNtcCh0aGlzLm0pID49IDApIHtcblx0ICAgICAgcmVzID0gdS5pc3ViKHRoaXMubSk7XG5cdCAgICB9IGVsc2UgaWYgKHUuY21wbigwKSA8IDApIHtcblx0ICAgICAgcmVzID0gdS5pYWRkKHRoaXMubSk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuXHQgIH07XG5cblx0ICBNb250LnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwgKGEsIGIpIHtcblx0ICAgIGlmIChhLmlzWmVybygpIHx8IGIuaXNaZXJvKCkpIHJldHVybiBuZXcgQk4oMCkuX2ZvcmNlUmVkKHRoaXMpO1xuXG5cdCAgICB2YXIgdCA9IGEubXVsKGIpO1xuXHQgICAgdmFyIGMgPSB0Lm1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm1pbnYpLmltYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5tKTtcblx0ICAgIHZhciB1ID0gdC5pc3ViKGMpLml1c2hybih0aGlzLnNoaWZ0KTtcblx0ICAgIHZhciByZXMgPSB1O1xuXHQgICAgaWYgKHUuY21wKHRoaXMubSkgPj0gMCkge1xuXHQgICAgICByZXMgPSB1LmlzdWIodGhpcy5tKTtcblx0ICAgIH0gZWxzZSBpZiAodS5jbXBuKDApIDwgMCkge1xuXHQgICAgICByZXMgPSB1LmlhZGQodGhpcy5tKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG5cdCAgfTtcblxuXHQgIE1vbnQucHJvdG90eXBlLmludm0gPSBmdW5jdGlvbiBpbnZtIChhKSB7XG5cdCAgICAvLyAoQVIpXi0xICogUl4yID0gKEFeLTEgKiBSXi0xKSAqIFJeMiA9IEFeLTEgKiBSXG5cdCAgICB2YXIgcmVzID0gdGhpcy5pbW9kKGEuX2ludm1wKHRoaXMubSkubXVsKHRoaXMucjIpKTtcblx0ICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuXHQgIH07XG5cdH0pKCdvYmplY3QnID09PSAndW5kZWZpbmVkJyB8fCBtb2R1bGUsIGNvbW1vbmpzR2xvYmFsKTtcblx0fSk7XG5cdHZhciBibl8xID0gYm4uQk47XG5cblx0dmFyIF92ZXJzaW9uID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLnZlcnNpb24gPSBcImxvZ2dlci81LjAuNFwiO1xuXG5cdH0pO1xuXG5cdHZhciBfdmVyc2lvbiQxID0gdW53cmFwRXhwb3J0cyhfdmVyc2lvbik7XG5cdHZhciBfdmVyc2lvbl8xID0gX3ZlcnNpb24udmVyc2lvbjtcblxuXHR2YXIgbGliID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHR2YXIgX3Blcm1hbmVudENlbnNvckVycm9ycyA9IGZhbHNlO1xuXHR2YXIgX2NlbnNvckVycm9ycyA9IGZhbHNlO1xuXHR2YXIgTG9nTGV2ZWxzID0geyBkZWJ1ZzogMSwgXCJkZWZhdWx0XCI6IDIsIGluZm86IDIsIHdhcm5pbmc6IDMsIGVycm9yOiA0LCBvZmY6IDUgfTtcblx0dmFyIF9sb2dMZXZlbCA9IExvZ0xldmVsc1tcImRlZmF1bHRcIl07XG5cblx0dmFyIF9nbG9iYWxMb2dnZXIgPSBudWxsO1xuXHRmdW5jdGlvbiBfY2hlY2tOb3JtYWxpemUoKSB7XG5cdCAgICB0cnkge1xuXHQgICAgICAgIHZhciBtaXNzaW5nXzEgPSBbXTtcblx0ICAgICAgICAvLyBNYWtlIHN1cmUgYWxsIGZvcm1zIG9mIG5vcm1hbGl6YXRpb24gYXJlIHN1cHBvcnRlZFxuXHQgICAgICAgIFtcIk5GRFwiLCBcIk5GQ1wiLCBcIk5GS0RcIiwgXCJORktDXCJdLmZvckVhY2goZnVuY3Rpb24gKGZvcm0pIHtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGlmIChcInRlc3RcIi5ub3JtYWxpemUoZm9ybSkgIT09IFwidGVzdFwiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmFkIG5vcm1hbGl6ZVwiKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgIG1pc3NpbmdfMS5wdXNoKGZvcm0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgaWYgKG1pc3NpbmdfMS5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBcIiArIG1pc3NpbmdfMS5qb2luKFwiLCBcIikpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoU3RyaW5nLmZyb21DaGFyQ29kZSgweGU5KS5ub3JtYWxpemUoXCJORkRcIikgIT09IFN0cmluZy5mcm9tQ2hhckNvZGUoMHg2NSwgMHgwMzAxKSkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJicm9rZW4gaW1wbGVtZW50YXRpb25cIik7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgY2F0Y2ggKGVycm9yKSB7XG5cdCAgICAgICAgcmV0dXJuIGVycm9yLm1lc3NhZ2U7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbnVsbDtcblx0fVxuXHR2YXIgX25vcm1hbGl6ZUVycm9yID0gX2NoZWNrTm9ybWFsaXplKCk7XG5cdHZhciBMb2dMZXZlbDtcblx0KGZ1bmN0aW9uIChMb2dMZXZlbCkge1xuXHQgICAgTG9nTGV2ZWxbXCJERUJVR1wiXSA9IFwiREVCVUdcIjtcblx0ICAgIExvZ0xldmVsW1wiSU5GT1wiXSA9IFwiSU5GT1wiO1xuXHQgICAgTG9nTGV2ZWxbXCJXQVJOSU5HXCJdID0gXCJXQVJOSU5HXCI7XG5cdCAgICBMb2dMZXZlbFtcIkVSUk9SXCJdID0gXCJFUlJPUlwiO1xuXHQgICAgTG9nTGV2ZWxbXCJPRkZcIl0gPSBcIk9GRlwiO1xuXHR9KShMb2dMZXZlbCA9IGV4cG9ydHMuTG9nTGV2ZWwgfHwgKGV4cG9ydHMuTG9nTGV2ZWwgPSB7fSkpO1xuXHR2YXIgRXJyb3JDb2RlO1xuXHQoZnVuY3Rpb24gKEVycm9yQ29kZSkge1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy8gR2VuZXJpYyBFcnJvcnNcblx0ICAgIC8vIFVua25vd24gRXJyb3Jcblx0ICAgIEVycm9yQ29kZVtcIlVOS05PV05fRVJST1JcIl0gPSBcIlVOS05PV05fRVJST1JcIjtcblx0ICAgIC8vIE5vdCBJbXBsZW1lbnRlZFxuXHQgICAgRXJyb3JDb2RlW1wiTk9UX0lNUExFTUVOVEVEXCJdID0gXCJOT1RfSU1QTEVNRU5URURcIjtcblx0ICAgIC8vIFVuc3VwcG9ydGVkIE9wZXJhdGlvblxuXHQgICAgLy8gICAtIG9wZXJhdGlvblxuXHQgICAgRXJyb3JDb2RlW1wiVU5TVVBQT1JURURfT1BFUkFUSU9OXCJdID0gXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIjtcblx0ICAgIC8vIE5ldHdvcmsgRXJyb3IgKGkuZS4gRXRoZXJldW0gTmV0d29yaywgc3VjaCBhcyBhbiBpbnZhbGlkIGNoYWluIElEKVxuXHQgICAgLy8gICAtIGV2ZW50IChcIm5vTmV0d29ya1wiIGlzIG5vdCByZS10aHJvd24gaW4gcHJvdmlkZXIucmVhZHk7IG90aGVyd2lzZSB0aHJvd24pXG5cdCAgICBFcnJvckNvZGVbXCJORVRXT1JLX0VSUk9SXCJdID0gXCJORVRXT1JLX0VSUk9SXCI7XG5cdCAgICAvLyBTb21lIHNvcnQgb2YgYmFkIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlclxuXHQgICAgRXJyb3JDb2RlW1wiU0VSVkVSX0VSUk9SXCJdID0gXCJTRVJWRVJfRVJST1JcIjtcblx0ICAgIC8vIFRpbWVvdXRcblx0ICAgIEVycm9yQ29kZVtcIlRJTUVPVVRcIl0gPSBcIlRJTUVPVVRcIjtcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vIE9wZXJhdGlvbmFsICBFcnJvcnNcblx0ICAgIC8vIEJ1ZmZlciBPdmVycnVuXG5cdCAgICBFcnJvckNvZGVbXCJCVUZGRVJfT1ZFUlJVTlwiXSA9IFwiQlVGRkVSX09WRVJSVU5cIjtcblx0ICAgIC8vIE51bWVyaWMgRmF1bHRcblx0ICAgIC8vICAgLSBvcGVyYXRpb246IHRoZSBvcGVyYXRpb24gYmVpbmcgZXhlY3V0ZWRcblx0ICAgIC8vICAgLSBmYXVsdDogdGhlIHJlYXNvbiB0aGlzIGZhdWx0ZWRcblx0ICAgIEVycm9yQ29kZVtcIk5VTUVSSUNfRkFVTFRcIl0gPSBcIk5VTUVSSUNfRkFVTFRcIjtcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vIEFyZ3VtZW50IEVycm9yc1xuXHQgICAgLy8gTWlzc2luZyBuZXcgb3BlcmF0b3IgdG8gYW4gb2JqZWN0XG5cdCAgICAvLyAgLSBuYW1lOiBUaGUgbmFtZSBvZiB0aGUgY2xhc3Ncblx0ICAgIEVycm9yQ29kZVtcIk1JU1NJTkdfTkVXXCJdID0gXCJNSVNTSU5HX05FV1wiO1xuXHQgICAgLy8gSW52YWxpZCBhcmd1bWVudCAoZS5nLiB2YWx1ZSBpcyBpbmNvbXBhdGlibGUgd2l0aCB0eXBlKSB0byBhIGZ1bmN0aW9uOlxuXHQgICAgLy8gICAtIGFyZ3VtZW50OiBUaGUgYXJndW1lbnQgbmFtZSB0aGF0IHdhcyBpbnZhbGlkXG5cdCAgICAvLyAgIC0gdmFsdWU6IFRoZSB2YWx1ZSBvZiB0aGUgYXJndW1lbnRcblx0ICAgIEVycm9yQ29kZVtcIklOVkFMSURfQVJHVU1FTlRcIl0gPSBcIklOVkFMSURfQVJHVU1FTlRcIjtcblx0ICAgIC8vIE1pc3NpbmcgYXJndW1lbnQgdG8gYSBmdW5jdGlvbjpcblx0ICAgIC8vICAgLSBjb3VudDogVGhlIG51bWJlciBvZiBhcmd1bWVudHMgcmVjZWl2ZWRcblx0ICAgIC8vICAgLSBleHBlY3RlZENvdW50OiBUaGUgbnVtYmVyIG9mIGFyZ3VtZW50cyBleHBlY3RlZFxuXHQgICAgRXJyb3JDb2RlW1wiTUlTU0lOR19BUkdVTUVOVFwiXSA9IFwiTUlTU0lOR19BUkdVTUVOVFwiO1xuXHQgICAgLy8gVG9vIG1hbnkgYXJndW1lbnRzXG5cdCAgICAvLyAgIC0gY291bnQ6IFRoZSBudW1iZXIgb2YgYXJndW1lbnRzIHJlY2VpdmVkXG5cdCAgICAvLyAgIC0gZXhwZWN0ZWRDb3VudDogVGhlIG51bWJlciBvZiBhcmd1bWVudHMgZXhwZWN0ZWRcblx0ICAgIEVycm9yQ29kZVtcIlVORVhQRUNURURfQVJHVU1FTlRcIl0gPSBcIlVORVhQRUNURURfQVJHVU1FTlRcIjtcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vIEJsb2NrY2hhaW4gRXJyb3JzXG5cdCAgICAvLyBDYWxsIGV4Y2VwdGlvblxuXHQgICAgLy8gIC0gdHJhbnNhY3Rpb246IHRoZSB0cmFuc2FjdGlvblxuXHQgICAgLy8gIC0gYWRkcmVzcz86IHRoZSBjb250cmFjdCBhZGRyZXNzXG5cdCAgICAvLyAgLSBhcmdzPzogVGhlIGFyZ3VtZW50cyBwYXNzZWQgaW50byB0aGUgZnVuY3Rpb25cblx0ICAgIC8vICAtIG1ldGhvZD86IFRoZSBTb2xpZGl0eSBtZXRob2Qgc2lnbmF0dXJlXG5cdCAgICAvLyAgLSBlcnJvclNpZ25hdHVyZT86IFRoZSBFSVA4NDggZXJyb3Igc2lnbmF0dXJlXG5cdCAgICAvLyAgLSBlcnJvckFyZ3M/OiBUaGUgRUlQODQ4IGVycm9yIHBhcmFtZXRlcnNcblx0ICAgIC8vICAtIHJlYXNvbjogVGhlIHJlYXNvbiAob25seSBmb3IgRUlQODQ4IFwiRXJyb3Ioc3RyaW5nKVwiKVxuXHQgICAgRXJyb3JDb2RlW1wiQ0FMTF9FWENFUFRJT05cIl0gPSBcIkNBTExfRVhDRVBUSU9OXCI7XG5cdCAgICAvLyBJbnN1ZmZpY2llbiBmdW5kcyAoPCB2YWx1ZSArIGdhc0xpbWl0ICogZ2FzUHJpY2UpXG5cdCAgICAvLyAgIC0gdHJhbnNhY3Rpb246IHRoZSB0cmFuc2FjdGlvbiBhdHRlbXB0ZWRcblx0ICAgIEVycm9yQ29kZVtcIklOU1VGRklDSUVOVF9GVU5EU1wiXSA9IFwiSU5TVUZGSUNJRU5UX0ZVTkRTXCI7XG5cdCAgICAvLyBOb25jZSBoYXMgYWxyZWFkeSBiZWVuIHVzZWRcblx0ICAgIC8vICAgLSB0cmFuc2FjdGlvbjogdGhlIHRyYW5zYWN0aW9uIGF0dGVtcHRlZFxuXHQgICAgRXJyb3JDb2RlW1wiTk9OQ0VfRVhQSVJFRFwiXSA9IFwiTk9OQ0VfRVhQSVJFRFwiO1xuXHQgICAgLy8gVGhlIHJlcGxhY2VtZW50IGZlZSBmb3IgdGhlIHRyYW5zYWN0aW9uIGlzIHRvbyBsb3dcblx0ICAgIC8vICAgLSB0cmFuc2FjdGlvbjogdGhlIHRyYW5zYWN0aW9uIGF0dGVtcHRlZFxuXHQgICAgRXJyb3JDb2RlW1wiUkVQTEFDRU1FTlRfVU5ERVJQUklDRURcIl0gPSBcIlJFUExBQ0VNRU5UX1VOREVSUFJJQ0VEXCI7XG5cdCAgICAvLyBUaGUgZ2FzIGxpbWl0IGNvdWxkIG5vdCBiZSBlc3RpbWF0ZWRcblx0ICAgIC8vICAgLSB0cmFuc2FjdGlvbjogdGhlIHRyYW5zYWN0aW9uIHBhc3NlZCB0byBlc3RpbWF0ZUdhc1xuXHQgICAgRXJyb3JDb2RlW1wiVU5QUkVESUNUQUJMRV9HQVNfTElNSVRcIl0gPSBcIlVOUFJFRElDVEFCTEVfR0FTX0xJTUlUXCI7XG5cdH0pKEVycm9yQ29kZSA9IGV4cG9ydHMuRXJyb3JDb2RlIHx8IChleHBvcnRzLkVycm9yQ29kZSA9IHt9KSk7XG5cdDtcblx0dmFyIExvZ2dlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIExvZ2dlcih2ZXJzaW9uKSB7XG5cdCAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidmVyc2lvblwiLCB7XG5cdCAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cdCAgICAgICAgICAgIHZhbHVlOiB2ZXJzaW9uLFxuXHQgICAgICAgICAgICB3cml0YWJsZTogZmFsc2Vcblx0ICAgICAgICB9KTtcblx0ICAgIH1cblx0ICAgIExvZ2dlci5wcm90b3R5cGUuX2xvZyA9IGZ1bmN0aW9uIChsb2dMZXZlbCwgYXJncykge1xuXHQgICAgICAgIHZhciBsZXZlbCA9IGxvZ0xldmVsLnRvTG93ZXJDYXNlKCk7XG5cdCAgICAgICAgaWYgKExvZ0xldmVsc1tsZXZlbF0gPT0gbnVsbCkge1xuXHQgICAgICAgICAgICB0aGlzLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgbG9nIGxldmVsIG5hbWVcIiwgXCJsb2dMZXZlbFwiLCBsb2dMZXZlbCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChfbG9nTGV2ZWwgPiBMb2dMZXZlbHNbbGV2ZWxdKSB7XG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJncyk7XG5cdCAgICB9O1xuXHQgICAgTG9nZ2VyLnByb3RvdHlwZS5kZWJ1ZyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgYXJncyA9IFtdO1xuXHQgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG5cdCAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5fbG9nKExvZ2dlci5sZXZlbHMuREVCVUcsIGFyZ3MpO1xuXHQgICAgfTtcblx0ICAgIExvZ2dlci5wcm90b3R5cGUuaW5mbyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgYXJncyA9IFtdO1xuXHQgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG5cdCAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5fbG9nKExvZ2dlci5sZXZlbHMuSU5GTywgYXJncyk7XG5cdCAgICB9O1xuXHQgICAgTG9nZ2VyLnByb3RvdHlwZS53YXJuID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBhcmdzID0gW107XG5cdCAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcblx0ICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9sb2coTG9nZ2VyLmxldmVscy5XQVJOSU5HLCBhcmdzKTtcblx0ICAgIH07XG5cdCAgICBMb2dnZXIucHJvdG90eXBlLm1ha2VFcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlLCBjb2RlLCBwYXJhbXMpIHtcblx0ICAgICAgICAvLyBFcnJvcnMgYXJlIGJlaW5nIGNlbnNvcmVkXG5cdCAgICAgICAgaWYgKF9jZW5zb3JFcnJvcnMpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFrZUVycm9yKFwiY2Vuc29yZWQgZXJyb3JcIiwgY29kZSwge30pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoIWNvZGUpIHtcblx0ICAgICAgICAgICAgY29kZSA9IExvZ2dlci5lcnJvcnMuVU5LTk9XTl9FUlJPUjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKCFwYXJhbXMpIHtcblx0ICAgICAgICAgICAgcGFyYW1zID0ge307XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBtZXNzYWdlRGV0YWlscyA9IFtdO1xuXHQgICAgICAgIE9iamVjdC5rZXlzKHBhcmFtcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBtZXNzYWdlRGV0YWlscy5wdXNoKGtleSArIFwiPVwiICsgSlNPTi5zdHJpbmdpZnkocGFyYW1zW2tleV0pKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgIG1lc3NhZ2VEZXRhaWxzLnB1c2goa2V5ICsgXCI9XCIgKyBKU09OLnN0cmluZ2lmeShwYXJhbXNba2V5XS50b1N0cmluZygpKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgICAgICBtZXNzYWdlRGV0YWlscy5wdXNoKFwiY29kZT1cIiArIGNvZGUpO1xuXHQgICAgICAgIG1lc3NhZ2VEZXRhaWxzLnB1c2goXCJ2ZXJzaW9uPVwiICsgdGhpcy52ZXJzaW9uKTtcblx0ICAgICAgICB2YXIgcmVhc29uID0gbWVzc2FnZTtcblx0ICAgICAgICBpZiAobWVzc2FnZURldGFpbHMubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCIgKFwiICsgbWVzc2FnZURldGFpbHMuam9pbihcIiwgXCIpICsgXCIpXCI7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIEBUT0RPOiBBbnk/P1xuXHQgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcblx0ICAgICAgICBlcnJvci5yZWFzb24gPSByZWFzb247XG5cdCAgICAgICAgZXJyb3IuY29kZSA9IGNvZGU7XG5cdCAgICAgICAgT2JqZWN0LmtleXMocGFyYW1zKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0ICAgICAgICAgICAgZXJyb3Jba2V5XSA9IHBhcmFtc1trZXldO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHJldHVybiBlcnJvcjtcblx0ICAgIH07XG5cdCAgICBMb2dnZXIucHJvdG90eXBlLnRocm93RXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZSwgY29kZSwgcGFyYW1zKSB7XG5cdCAgICAgICAgdGhyb3cgdGhpcy5tYWtlRXJyb3IobWVzc2FnZSwgY29kZSwgcGFyYW1zKTtcblx0ICAgIH07XG5cdCAgICBMb2dnZXIucHJvdG90eXBlLnRocm93QXJndW1lbnRFcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlLCBuYW1lLCB2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLnRocm93RXJyb3IobWVzc2FnZSwgTG9nZ2VyLmVycm9ycy5JTlZBTElEX0FSR1VNRU5ULCB7XG5cdCAgICAgICAgICAgIGFyZ3VtZW50OiBuYW1lLFxuXHQgICAgICAgICAgICB2YWx1ZTogdmFsdWVcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBMb2dnZXIucHJvdG90eXBlLmFzc2VydCA9IGZ1bmN0aW9uIChjb25kaXRpb24sIG1lc3NhZ2UsIGNvZGUsIHBhcmFtcykge1xuXHQgICAgICAgIGlmICghIWNvbmRpdGlvbikge1xuXHQgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlLCBjb2RlLCBwYXJhbXMpO1xuXHQgICAgfTtcblx0ICAgIExvZ2dlci5wcm90b3R5cGUuYXNzZXJ0QXJndW1lbnQgPSBmdW5jdGlvbiAoY29uZGl0aW9uLCBtZXNzYWdlLCBuYW1lLCB2YWx1ZSkge1xuXHQgICAgICAgIGlmICghIWNvbmRpdGlvbikge1xuXHQgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMudGhyb3dBcmd1bWVudEVycm9yKG1lc3NhZ2UsIG5hbWUsIHZhbHVlKTtcblx0ICAgIH07XG5cdCAgICBMb2dnZXIucHJvdG90eXBlLmNoZWNrTm9ybWFsaXplID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcblx0ICAgICAgICBpZiAobWVzc2FnZSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIG1lc3NhZ2UgPSBcInBsYXRmb3JtIG1pc3NpbmcgU3RyaW5nLnByb3RvdHlwZS5ub3JtYWxpemVcIjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKF9ub3JtYWxpemVFcnJvcikge1xuXHQgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IoXCJwbGF0Zm9ybSBtaXNzaW5nIFN0cmluZy5wcm90b3R5cGUubm9ybWFsaXplXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG5cdCAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiU3RyaW5nLnByb3RvdHlwZS5ub3JtYWxpemVcIiwgZm9ybTogX25vcm1hbGl6ZUVycm9yXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICBMb2dnZXIucHJvdG90eXBlLmNoZWNrU2FmZVVpbnQ1MyA9IGZ1bmN0aW9uICh2YWx1ZSwgbWVzc2FnZSkge1xuXHQgICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSAhPT0gXCJudW1iZXJcIikge1xuXHQgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChtZXNzYWdlID09IG51bGwpIHtcblx0ICAgICAgICAgICAgbWVzc2FnZSA9IFwidmFsdWUgbm90IHNhZmVcIjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+PSAweDFmZmZmZmZmZmZmZmZmKSB7XG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlLCBMb2dnZXIuZXJyb3JzLk5VTUVSSUNfRkFVTFQsIHtcblx0ICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJjaGVja1NhZmVJbnRlZ2VyXCIsXG5cdCAgICAgICAgICAgICAgICBmYXVsdDogXCJvdXQtb2Ytc2FmZS1yYW5nZVwiLFxuXHQgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodmFsdWUgJSAxKSB7XG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlLCBMb2dnZXIuZXJyb3JzLk5VTUVSSUNfRkFVTFQsIHtcblx0ICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJjaGVja1NhZmVJbnRlZ2VyXCIsXG5cdCAgICAgICAgICAgICAgICBmYXVsdDogXCJub24taW50ZWdlclwiLFxuXHQgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICBMb2dnZXIucHJvdG90eXBlLmNoZWNrQXJndW1lbnRDb3VudCA9IGZ1bmN0aW9uIChjb3VudCwgZXhwZWN0ZWRDb3VudCwgbWVzc2FnZSkge1xuXHQgICAgICAgIGlmIChtZXNzYWdlKSB7XG5cdCAgICAgICAgICAgIG1lc3NhZ2UgPSBcIjogXCIgKyBtZXNzYWdlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgbWVzc2FnZSA9IFwiXCI7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChjb3VudCA8IGV4cGVjdGVkQ291bnQpIHtcblx0ICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKFwibWlzc2luZyBhcmd1bWVudFwiICsgbWVzc2FnZSwgTG9nZ2VyLmVycm9ycy5NSVNTSU5HX0FSR1VNRU5ULCB7XG5cdCAgICAgICAgICAgICAgICBjb3VudDogY291bnQsXG5cdCAgICAgICAgICAgICAgICBleHBlY3RlZENvdW50OiBleHBlY3RlZENvdW50XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoY291bnQgPiBleHBlY3RlZENvdW50KSB7XG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihcInRvbyBtYW55IGFyZ3VtZW50c1wiICsgbWVzc2FnZSwgTG9nZ2VyLmVycm9ycy5VTkVYUEVDVEVEX0FSR1VNRU5ULCB7XG5cdCAgICAgICAgICAgICAgICBjb3VudDogY291bnQsXG5cdCAgICAgICAgICAgICAgICBleHBlY3RlZENvdW50OiBleHBlY3RlZENvdW50XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICBMb2dnZXIucHJvdG90eXBlLmNoZWNrTmV3ID0gZnVuY3Rpb24gKHRhcmdldCwga2luZCkge1xuXHQgICAgICAgIGlmICh0YXJnZXQgPT09IE9iamVjdCB8fCB0YXJnZXQgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IoXCJtaXNzaW5nIG5ld1wiLCBMb2dnZXIuZXJyb3JzLk1JU1NJTkdfTkVXLCB7IG5hbWU6IGtpbmQubmFtZSB9KTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgTG9nZ2VyLnByb3RvdHlwZS5jaGVja0Fic3RyYWN0ID0gZnVuY3Rpb24gKHRhcmdldCwga2luZCkge1xuXHQgICAgICAgIGlmICh0YXJnZXQgPT09IGtpbmQpIHtcblx0ICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKFwiY2Fubm90IGluc3RhbnRpYXRlIGFic3RyYWN0IGNsYXNzIFwiICsgSlNPTi5zdHJpbmdpZnkoa2luZC5uYW1lKSArIFwiIGRpcmVjdGx5OyB1c2UgYSBzdWItY2xhc3NcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHsgbmFtZTogdGFyZ2V0Lm5hbWUsIG9wZXJhdGlvbjogXCJuZXdcIiB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAodGFyZ2V0ID09PSBPYmplY3QgfHwgdGFyZ2V0ID09IG51bGwpIHtcblx0ICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKFwibWlzc2luZyBuZXdcIiwgTG9nZ2VyLmVycm9ycy5NSVNTSU5HX05FVywgeyBuYW1lOiBraW5kLm5hbWUgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIExvZ2dlci5nbG9iYWxMb2dnZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgaWYgKCFfZ2xvYmFsTG9nZ2VyKSB7XG5cdCAgICAgICAgICAgIF9nbG9iYWxMb2dnZXIgPSBuZXcgTG9nZ2VyKF92ZXJzaW9uLnZlcnNpb24pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gX2dsb2JhbExvZ2dlcjtcblx0ICAgIH07XG5cdCAgICBMb2dnZXIuc2V0Q2Vuc29yc2hpcCA9IGZ1bmN0aW9uIChjZW5zb3JzaGlwLCBwZXJtYW5lbnQpIHtcblx0ICAgICAgICBpZiAoIWNlbnNvcnNoaXAgJiYgcGVybWFuZW50KSB7XG5cdCAgICAgICAgICAgIHRoaXMuZ2xvYmFsTG9nZ2VyKCkudGhyb3dFcnJvcihcImNhbm5vdCBwZXJtYW5lbnRseSBkaXNhYmxlIGNlbnNvcnNoaXBcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcblx0ICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJzZXRDZW5zb3JzaGlwXCJcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChfcGVybWFuZW50Q2Vuc29yRXJyb3JzKSB7XG5cdCAgICAgICAgICAgIGlmICghY2Vuc29yc2hpcCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoaXMuZ2xvYmFsTG9nZ2VyKCkudGhyb3dFcnJvcihcImVycm9yIGNlbnNvcnNoaXAgcGVybWFuZW50XCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG5cdCAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwic2V0Q2Vuc29yc2hpcFwiXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBfY2Vuc29yRXJyb3JzID0gISFjZW5zb3JzaGlwO1xuXHQgICAgICAgIF9wZXJtYW5lbnRDZW5zb3JFcnJvcnMgPSAhIXBlcm1hbmVudDtcblx0ICAgIH07XG5cdCAgICBMb2dnZXIuc2V0TG9nTGV2ZWwgPSBmdW5jdGlvbiAobG9nTGV2ZWwpIHtcblx0ICAgICAgICB2YXIgbGV2ZWwgPSBMb2dMZXZlbHNbbG9nTGV2ZWwudG9Mb3dlckNhc2UoKV07XG5cdCAgICAgICAgaWYgKGxldmVsID09IG51bGwpIHtcblx0ICAgICAgICAgICAgTG9nZ2VyLmdsb2JhbExvZ2dlcigpLndhcm4oXCJpbnZhbGlkIGxvZyBsZXZlbCAtIFwiICsgbG9nTGV2ZWwpO1xuXHQgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfVxuXHQgICAgICAgIF9sb2dMZXZlbCA9IGxldmVsO1xuXHQgICAgfTtcblx0ICAgIExvZ2dlci5lcnJvcnMgPSBFcnJvckNvZGU7XG5cdCAgICBMb2dnZXIubGV2ZWxzID0gTG9nTGV2ZWw7XG5cdCAgICByZXR1cm4gTG9nZ2VyO1xuXHR9KCkpO1xuXHRleHBvcnRzLkxvZ2dlciA9IExvZ2dlcjtcblxuXHR9KTtcblxuXHR2YXIgaW5kZXggPSB1bndyYXBFeHBvcnRzKGxpYik7XG5cdHZhciBsaWJfMSA9IGxpYi5Mb2dMZXZlbDtcblx0dmFyIGxpYl8yID0gbGliLkVycm9yQ29kZTtcblx0dmFyIGxpYl8zID0gbGliLkxvZ2dlcjtcblxuXHR2YXIgX3ZlcnNpb24kMiA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy52ZXJzaW9uID0gXCJieXRlcy81LjAuM1wiO1xuXG5cdH0pO1xuXG5cdHZhciBfdmVyc2lvbiQzID0gdW53cmFwRXhwb3J0cyhfdmVyc2lvbiQyKTtcblx0dmFyIF92ZXJzaW9uXzEkMSA9IF92ZXJzaW9uJDIudmVyc2lvbjtcblxuXHR2YXIgbGliJDEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cblxuXHR2YXIgbG9nZ2VyID0gbmV3IGxpYi5Mb2dnZXIoX3ZlcnNpb24kMi52ZXJzaW9uKTtcblx0Ly8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHRmdW5jdGlvbiBpc0hleGFibGUodmFsdWUpIHtcblx0ICAgIHJldHVybiAhISh2YWx1ZS50b0hleFN0cmluZyk7XG5cdH1cblx0ZnVuY3Rpb24gYWRkU2xpY2UoYXJyYXkpIHtcblx0ICAgIGlmIChhcnJheS5zbGljZSkge1xuXHQgICAgICAgIHJldHVybiBhcnJheTtcblx0ICAgIH1cblx0ICAgIGFycmF5LnNsaWNlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblx0ICAgICAgICByZXR1cm4gYWRkU2xpY2UobmV3IFVpbnQ4QXJyYXkoQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGFycmF5LCBhcmdzKSkpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBhcnJheTtcblx0fVxuXHRmdW5jdGlvbiBpc0J5dGVzTGlrZSh2YWx1ZSkge1xuXHQgICAgcmV0dXJuICgoaXNIZXhTdHJpbmcodmFsdWUpICYmICEodmFsdWUubGVuZ3RoICUgMikpIHx8IGlzQnl0ZXModmFsdWUpKTtcblx0fVxuXHRleHBvcnRzLmlzQnl0ZXNMaWtlID0gaXNCeXRlc0xpa2U7XG5cdGZ1bmN0aW9uIGlzQnl0ZXModmFsdWUpIHtcblx0ICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG5cdCAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXHQgICAgaWYgKHZhbHVlLmNvbnN0cnVjdG9yID09PSBVaW50OEFycmF5KSB7XG5cdCAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9XG5cdCAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cdCAgICBpZiAodmFsdWUubGVuZ3RoID09IG51bGwpIHtcblx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgdmFyIHYgPSB2YWx1ZVtpXTtcblx0ICAgICAgICBpZiAodiA8IDAgfHwgdiA+PSAyNTYgfHwgKHYgJSAxKSkge1xuXHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIHRydWU7XG5cdH1cblx0ZXhwb3J0cy5pc0J5dGVzID0gaXNCeXRlcztcblx0ZnVuY3Rpb24gYXJyYXlpZnkodmFsdWUsIG9wdGlvbnMpIHtcblx0ICAgIGlmICghb3B0aW9ucykge1xuXHQgICAgICAgIG9wdGlvbnMgPSB7fTtcblx0ICAgIH1cblx0ICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJudW1iZXJcIikge1xuXHQgICAgICAgIGxvZ2dlci5jaGVja1NhZmVVaW50NTModmFsdWUsIFwiaW52YWxpZCBhcnJheWlmeSB2YWx1ZVwiKTtcblx0ICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cdCAgICAgICAgd2hpbGUgKHZhbHVlKSB7XG5cdCAgICAgICAgICAgIHJlc3VsdC51bnNoaWZ0KHZhbHVlICYgMHhmZik7XG5cdCAgICAgICAgICAgIHZhbHVlID0gcGFyc2VJbnQoU3RyaW5nKHZhbHVlIC8gMjU2KSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAwKSB7XG5cdCAgICAgICAgICAgIHJlc3VsdC5wdXNoKDApO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gYWRkU2xpY2UobmV3IFVpbnQ4QXJyYXkocmVzdWx0KSk7XG5cdCAgICB9XG5cdCAgICBpZiAob3B0aW9ucy5hbGxvd01pc3NpbmdQcmVmaXggJiYgdHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUuc3Vic3RyaW5nKDAsIDIpICE9PSBcIjB4XCIpIHtcblx0ICAgICAgICB2YWx1ZSA9IFwiMHhcIiArIHZhbHVlO1xuXHQgICAgfVxuXHQgICAgaWYgKGlzSGV4YWJsZSh2YWx1ZSkpIHtcblx0ICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvSGV4U3RyaW5nKCk7XG5cdCAgICB9XG5cdCAgICBpZiAoaXNIZXhTdHJpbmcodmFsdWUpKSB7XG5cdCAgICAgICAgdmFyIGhleCA9IHZhbHVlLnN1YnN0cmluZygyKTtcblx0ICAgICAgICBpZiAoaGV4Lmxlbmd0aCAlIDIpIHtcblx0ICAgICAgICAgICAgaWYgKG9wdGlvbnMuaGV4UGFkID09PSBcImxlZnRcIikge1xuXHQgICAgICAgICAgICAgICAgaGV4ID0gXCIweDBcIiArIGhleC5zdWJzdHJpbmcoMik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5oZXhQYWQgPT09IFwicmlnaHRcIikge1xuXHQgICAgICAgICAgICAgICAgaGV4ICs9IFwiMFwiO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImhleCBkYXRhIGlzIG9kZC1sZW5ndGhcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGV4Lmxlbmd0aDsgaSArPSAyKSB7XG5cdCAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBhcnNlSW50KGhleC5zdWJzdHJpbmcoaSwgaSArIDIpLCAxNikpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gYWRkU2xpY2UobmV3IFVpbnQ4QXJyYXkocmVzdWx0KSk7XG5cdCAgICB9XG5cdCAgICBpZiAoaXNCeXRlcyh2YWx1ZSkpIHtcblx0ICAgICAgICByZXR1cm4gYWRkU2xpY2UobmV3IFVpbnQ4QXJyYXkodmFsdWUpKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBhcnJheWlmeSB2YWx1ZVwiLCBcInZhbHVlXCIsIHZhbHVlKTtcblx0fVxuXHRleHBvcnRzLmFycmF5aWZ5ID0gYXJyYXlpZnk7XG5cdGZ1bmN0aW9uIGNvbmNhdChpdGVtcykge1xuXHQgICAgdmFyIG9iamVjdHMgPSBpdGVtcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGFycmF5aWZ5KGl0ZW0pOyB9KTtcblx0ICAgIHZhciBsZW5ndGggPSBvYmplY3RzLnJlZHVjZShmdW5jdGlvbiAoYWNjdW0sIGl0ZW0pIHsgcmV0dXJuIChhY2N1bSArIGl0ZW0ubGVuZ3RoKTsgfSwgMCk7XG5cdCAgICB2YXIgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcblx0ICAgIG9iamVjdHMucmVkdWNlKGZ1bmN0aW9uIChvZmZzZXQsIG9iamVjdCkge1xuXHQgICAgICAgIHJlc3VsdC5zZXQob2JqZWN0LCBvZmZzZXQpO1xuXHQgICAgICAgIHJldHVybiBvZmZzZXQgKyBvYmplY3QubGVuZ3RoO1xuXHQgICAgfSwgMCk7XG5cdCAgICByZXR1cm4gYWRkU2xpY2UocmVzdWx0KTtcblx0fVxuXHRleHBvcnRzLmNvbmNhdCA9IGNvbmNhdDtcblx0ZnVuY3Rpb24gc3RyaXBaZXJvcyh2YWx1ZSkge1xuXHQgICAgdmFyIHJlc3VsdCA9IGFycmF5aWZ5KHZhbHVlKTtcblx0ICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAwKSB7XG5cdCAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgIH1cblx0ICAgIC8vIEZpbmQgdGhlIGZpcnN0IG5vbi16ZXJvIGVudHJ5XG5cdCAgICB2YXIgc3RhcnQgPSAwO1xuXHQgICAgd2hpbGUgKHN0YXJ0IDwgcmVzdWx0Lmxlbmd0aCAmJiByZXN1bHRbc3RhcnRdID09PSAwKSB7XG5cdCAgICAgICAgc3RhcnQrKztcblx0ICAgIH1cblx0ICAgIC8vIElmIHdlIHN0YXJ0ZWQgd2l0aCB6ZXJvcywgc3RyaXAgdGhlbVxuXHQgICAgaWYgKHN0YXJ0KSB7XG5cdCAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKHN0YXJ0KTtcblx0ICAgIH1cblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdH1cblx0ZXhwb3J0cy5zdHJpcFplcm9zID0gc3RyaXBaZXJvcztcblx0ZnVuY3Rpb24gemVyb1BhZCh2YWx1ZSwgbGVuZ3RoKSB7XG5cdCAgICB2YWx1ZSA9IGFycmF5aWZ5KHZhbHVlKTtcblx0ICAgIGlmICh2YWx1ZS5sZW5ndGggPiBsZW5ndGgpIHtcblx0ICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidmFsdWUgb3V0IG9mIHJhbmdlXCIsIFwidmFsdWVcIiwgYXJndW1lbnRzWzBdKTtcblx0ICAgIH1cblx0ICAgIHZhciByZXN1bHQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuXHQgICAgcmVzdWx0LnNldCh2YWx1ZSwgbGVuZ3RoIC0gdmFsdWUubGVuZ3RoKTtcblx0ICAgIHJldHVybiBhZGRTbGljZShyZXN1bHQpO1xuXHR9XG5cdGV4cG9ydHMuemVyb1BhZCA9IHplcm9QYWQ7XG5cdGZ1bmN0aW9uIGlzSGV4U3RyaW5nKHZhbHVlLCBsZW5ndGgpIHtcblx0ICAgIGlmICh0eXBlb2YgKHZhbHVlKSAhPT0gXCJzdHJpbmdcIiB8fCAhdmFsdWUubWF0Y2goL14weFswLTlBLUZhLWZdKiQvKSkge1xuXHQgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIH1cblx0ICAgIGlmIChsZW5ndGggJiYgdmFsdWUubGVuZ3RoICE9PSAyICsgMiAqIGxlbmd0aCkge1xuXHQgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB0cnVlO1xuXHR9XG5cdGV4cG9ydHMuaXNIZXhTdHJpbmcgPSBpc0hleFN0cmluZztcblx0dmFyIEhleENoYXJhY3RlcnMgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcblx0ZnVuY3Rpb24gaGV4bGlmeSh2YWx1ZSwgb3B0aW9ucykge1xuXHQgICAgaWYgKCFvcHRpb25zKSB7XG5cdCAgICAgICAgb3B0aW9ucyA9IHt9O1xuXHQgICAgfVxuXHQgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm51bWJlclwiKSB7XG5cdCAgICAgICAgbG9nZ2VyLmNoZWNrU2FmZVVpbnQ1Myh2YWx1ZSwgXCJpbnZhbGlkIGhleGxpZnkgdmFsdWVcIik7XG5cdCAgICAgICAgdmFyIGhleCA9IFwiXCI7XG5cdCAgICAgICAgd2hpbGUgKHZhbHVlKSB7XG5cdCAgICAgICAgICAgIGhleCA9IEhleENoYXJhY3RlcnNbdmFsdWUgJiAweDBmXSArIGhleDtcblx0ICAgICAgICAgICAgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlIC8gMTYpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoaGV4Lmxlbmd0aCkge1xuXHQgICAgICAgICAgICBpZiAoaGV4Lmxlbmd0aCAlIDIpIHtcblx0ICAgICAgICAgICAgICAgIGhleCA9IFwiMFwiICsgaGV4O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBcIjB4XCIgKyBoZXg7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBcIjB4MDBcIjtcblx0ICAgIH1cblx0ICAgIGlmIChvcHRpb25zLmFsbG93TWlzc2luZ1ByZWZpeCAmJiB0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZS5zdWJzdHJpbmcoMCwgMikgIT09IFwiMHhcIikge1xuXHQgICAgICAgIHZhbHVlID0gXCIweFwiICsgdmFsdWU7XG5cdCAgICB9XG5cdCAgICBpZiAoaXNIZXhhYmxlKHZhbHVlKSkge1xuXHQgICAgICAgIHJldHVybiB2YWx1ZS50b0hleFN0cmluZygpO1xuXHQgICAgfVxuXHQgICAgaWYgKGlzSGV4U3RyaW5nKHZhbHVlKSkge1xuXHQgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggJSAyKSB7XG5cdCAgICAgICAgICAgIGlmIChvcHRpb25zLmhleFBhZCA9PT0gXCJsZWZ0XCIpIHtcblx0ICAgICAgICAgICAgICAgIHZhbHVlID0gXCIweDBcIiArIHZhbHVlLnN1YnN0cmluZygyKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLmhleFBhZCA9PT0gXCJyaWdodFwiKSB7XG5cdCAgICAgICAgICAgICAgICB2YWx1ZSArPSBcIjBcIjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJoZXggZGF0YSBpcyBvZGQtbGVuZ3RoXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuXHQgICAgfVxuXHQgICAgaWYgKGlzQnl0ZXModmFsdWUpKSB7XG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IFwiMHhcIjtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIHZhciB2ID0gdmFsdWVbaV07XG5cdCAgICAgICAgICAgIHJlc3VsdCArPSBIZXhDaGFyYWN0ZXJzWyh2ICYgMHhmMCkgPj4gNF0gKyBIZXhDaGFyYWN0ZXJzW3YgJiAweDBmXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgIH1cblx0ICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBoZXhsaWZ5IHZhbHVlXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuXHR9XG5cdGV4cG9ydHMuaGV4bGlmeSA9IGhleGxpZnk7XG5cdC8qXG5cdGZ1bmN0aW9uIHVub2RkaWZ5KHZhbHVlOiBCeXRlc0xpa2UgfCBIZXhhYmxlIHwgbnVtYmVyKTogQnl0ZXNMaWtlIHwgSGV4YWJsZSB8IG51bWJlciB7XG5cdCAgICBpZiAodHlwZW9mKHZhbHVlKSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZS5sZW5ndGggJSAyICYmIHZhbHVlLnN1YnN0cmluZygwLCAyKSA9PT0gXCIweFwiKSB7XG5cdCAgICAgICAgcmV0dXJuIFwiMHgwXCIgKyB2YWx1ZS5zdWJzdHJpbmcoMik7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdmFsdWU7XG5cdH1cblx0Ki9cblx0ZnVuY3Rpb24gaGV4RGF0YUxlbmd0aChkYXRhKSB7XG5cdCAgICBpZiAodHlwZW9mIChkYXRhKSAhPT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgIGRhdGEgPSBoZXhsaWZ5KGRhdGEpO1xuXHQgICAgfVxuXHQgICAgZWxzZSBpZiAoIWlzSGV4U3RyaW5nKGRhdGEpIHx8IChkYXRhLmxlbmd0aCAlIDIpKSB7XG5cdCAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gKGRhdGEubGVuZ3RoIC0gMikgLyAyO1xuXHR9XG5cdGV4cG9ydHMuaGV4RGF0YUxlbmd0aCA9IGhleERhdGFMZW5ndGg7XG5cdGZ1bmN0aW9uIGhleERhdGFTbGljZShkYXRhLCBvZmZzZXQsIGVuZE9mZnNldCkge1xuXHQgICAgaWYgKHR5cGVvZiAoZGF0YSkgIT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICBkYXRhID0gaGV4bGlmeShkYXRhKTtcblx0ICAgIH1cblx0ICAgIGVsc2UgaWYgKCFpc0hleFN0cmluZyhkYXRhKSB8fCAoZGF0YS5sZW5ndGggJSAyKSkge1xuXHQgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGhleERhdGFcIiwgXCJ2YWx1ZVwiLCBkYXRhKTtcblx0ICAgIH1cblx0ICAgIG9mZnNldCA9IDIgKyAyICogb2Zmc2V0O1xuXHQgICAgaWYgKGVuZE9mZnNldCAhPSBudWxsKSB7XG5cdCAgICAgICAgcmV0dXJuIFwiMHhcIiArIGRhdGEuc3Vic3RyaW5nKG9mZnNldCwgMiArIDIgKiBlbmRPZmZzZXQpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIFwiMHhcIiArIGRhdGEuc3Vic3RyaW5nKG9mZnNldCk7XG5cdH1cblx0ZXhwb3J0cy5oZXhEYXRhU2xpY2UgPSBoZXhEYXRhU2xpY2U7XG5cdGZ1bmN0aW9uIGhleENvbmNhdChpdGVtcykge1xuXHQgICAgdmFyIHJlc3VsdCA9IFwiMHhcIjtcblx0ICAgIGl0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcblx0ICAgICAgICByZXN1bHQgKz0gaGV4bGlmeShpdGVtKS5zdWJzdHJpbmcoMik7XG5cdCAgICB9KTtcblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdH1cblx0ZXhwb3J0cy5oZXhDb25jYXQgPSBoZXhDb25jYXQ7XG5cdGZ1bmN0aW9uIGhleFZhbHVlKHZhbHVlKSB7XG5cdCAgICB2YXIgdHJpbW1lZCA9IGhleFN0cmlwWmVyb3MoaGV4bGlmeSh2YWx1ZSwgeyBoZXhQYWQ6IFwibGVmdFwiIH0pKTtcblx0ICAgIGlmICh0cmltbWVkID09PSBcIjB4XCIpIHtcblx0ICAgICAgICByZXR1cm4gXCIweDBcIjtcblx0ICAgIH1cblx0ICAgIHJldHVybiB0cmltbWVkO1xuXHR9XG5cdGV4cG9ydHMuaGV4VmFsdWUgPSBoZXhWYWx1ZTtcblx0ZnVuY3Rpb24gaGV4U3RyaXBaZXJvcyh2YWx1ZSkge1xuXHQgICAgaWYgKHR5cGVvZiAodmFsdWUpICE9PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgdmFsdWUgPSBoZXhsaWZ5KHZhbHVlKTtcblx0ICAgIH1cblx0ICAgIGlmICghaXNIZXhTdHJpbmcodmFsdWUpKSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgaGV4IHN0cmluZ1wiLCBcInZhbHVlXCIsIHZhbHVlKTtcblx0ICAgIH1cblx0ICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDIpO1xuXHQgICAgdmFyIG9mZnNldCA9IDA7XG5cdCAgICB3aGlsZSAob2Zmc2V0IDwgdmFsdWUubGVuZ3RoICYmIHZhbHVlW29mZnNldF0gPT09IFwiMFwiKSB7XG5cdCAgICAgICAgb2Zmc2V0Kys7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gXCIweFwiICsgdmFsdWUuc3Vic3RyaW5nKG9mZnNldCk7XG5cdH1cblx0ZXhwb3J0cy5oZXhTdHJpcFplcm9zID0gaGV4U3RyaXBaZXJvcztcblx0ZnVuY3Rpb24gaGV4WmVyb1BhZCh2YWx1ZSwgbGVuZ3RoKSB7XG5cdCAgICBpZiAodHlwZW9mICh2YWx1ZSkgIT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICB2YWx1ZSA9IGhleGxpZnkodmFsdWUpO1xuXHQgICAgfVxuXHQgICAgZWxzZSBpZiAoIWlzSGV4U3RyaW5nKHZhbHVlKSkge1xuXHQgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGhleCBzdHJpbmdcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG5cdCAgICB9XG5cdCAgICBpZiAodmFsdWUubGVuZ3RoID4gMiAqIGxlbmd0aCArIDIpIHtcblx0ICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidmFsdWUgb3V0IG9mIHJhbmdlXCIsIFwidmFsdWVcIiwgYXJndW1lbnRzWzFdKTtcblx0ICAgIH1cblx0ICAgIHdoaWxlICh2YWx1ZS5sZW5ndGggPCAyICogbGVuZ3RoICsgMikge1xuXHQgICAgICAgIHZhbHVlID0gXCIweDBcIiArIHZhbHVlLnN1YnN0cmluZygyKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB2YWx1ZTtcblx0fVxuXHRleHBvcnRzLmhleFplcm9QYWQgPSBoZXhaZXJvUGFkO1xuXHRmdW5jdGlvbiBzcGxpdFNpZ25hdHVyZShzaWduYXR1cmUpIHtcblx0ICAgIHZhciByZXN1bHQgPSB7XG5cdCAgICAgICAgcjogXCIweFwiLFxuXHQgICAgICAgIHM6IFwiMHhcIixcblx0ICAgICAgICBfdnM6IFwiMHhcIixcblx0ICAgICAgICByZWNvdmVyeVBhcmFtOiAwLFxuXHQgICAgICAgIHY6IDBcblx0ICAgIH07XG5cdCAgICBpZiAoaXNCeXRlc0xpa2Uoc2lnbmF0dXJlKSkge1xuXHQgICAgICAgIHZhciBieXRlcyA9IGFycmF5aWZ5KHNpZ25hdHVyZSk7XG5cdCAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCAhPT0gNjUpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgc2lnbmF0dXJlIHN0cmluZzsgbXVzdCBiZSA2NSBieXRlc1wiLCBcInNpZ25hdHVyZVwiLCBzaWduYXR1cmUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBHZXQgdGhlIHIsIHMgYW5kIHZcblx0ICAgICAgICByZXN1bHQuciA9IGhleGxpZnkoYnl0ZXMuc2xpY2UoMCwgMzIpKTtcblx0ICAgICAgICByZXN1bHQucyA9IGhleGxpZnkoYnl0ZXMuc2xpY2UoMzIsIDY0KSk7XG5cdCAgICAgICAgcmVzdWx0LnYgPSBieXRlc1s2NF07XG5cdCAgICAgICAgLy8gQWxsb3cgYSByZWNpZCB0byBiZSB1c2VkIGFzIHRoZSB2XG5cdCAgICAgICAgaWYgKHJlc3VsdC52IDwgMjcpIHtcblx0ICAgICAgICAgICAgaWYgKHJlc3VsdC52ID09PSAwIHx8IHJlc3VsdC52ID09PSAxKSB7XG5cdCAgICAgICAgICAgICAgICByZXN1bHQudiArPSAyNztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzaWduYXR1cmUgaW52YWxpZCB2IGJ5dGVcIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBDb21wdXRlIHJlY292ZXJ5UGFyYW0gZnJvbSB2XG5cdCAgICAgICAgcmVzdWx0LnJlY292ZXJ5UGFyYW0gPSAxIC0gKHJlc3VsdC52ICUgMik7XG5cdCAgICAgICAgLy8gQ29tcHV0ZSBfdnMgZnJvbSByZWNvdmVyeVBhcmFtIGFuZCBzXG5cdCAgICAgICAgaWYgKHJlc3VsdC5yZWNvdmVyeVBhcmFtKSB7XG5cdCAgICAgICAgICAgIGJ5dGVzWzMyXSB8PSAweDgwO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXN1bHQuX3ZzID0gaGV4bGlmeShieXRlcy5zbGljZSgzMiwgNjQpKTtcblx0ICAgIH1cblx0ICAgIGVsc2Uge1xuXHQgICAgICAgIHJlc3VsdC5yID0gc2lnbmF0dXJlLnI7XG5cdCAgICAgICAgcmVzdWx0LnMgPSBzaWduYXR1cmUucztcblx0ICAgICAgICByZXN1bHQudiA9IHNpZ25hdHVyZS52O1xuXHQgICAgICAgIHJlc3VsdC5yZWNvdmVyeVBhcmFtID0gc2lnbmF0dXJlLnJlY292ZXJ5UGFyYW07XG5cdCAgICAgICAgcmVzdWx0Ll92cyA9IHNpZ25hdHVyZS5fdnM7XG5cdCAgICAgICAgLy8gSWYgdGhlIF92cyBpcyBhdmFpbGFibGUsIHVzZSBpdCB0byBwb3B1bGF0ZSBtaXNzaW5nIHMsIHYgYW5kIHJlY292ZXJ5UGFyYW1cblx0ICAgICAgICAvLyBhbmQgdmVyaWZ5IG5vbi1taXNzaW5nIHMsIHYgYW5kIHJlY292ZXJ5UGFyYW1cblx0ICAgICAgICBpZiAocmVzdWx0Ll92cyAhPSBudWxsKSB7XG5cdCAgICAgICAgICAgIHZhciB2c18xID0gemVyb1BhZChhcnJheWlmeShyZXN1bHQuX3ZzKSwgMzIpO1xuXHQgICAgICAgICAgICByZXN1bHQuX3ZzID0gaGV4bGlmeSh2c18xKTtcblx0ICAgICAgICAgICAgLy8gU2V0IG9yIGNoZWNrIHRoZSByZWNpZFxuXHQgICAgICAgICAgICB2YXIgcmVjb3ZlcnlQYXJhbSA9ICgodnNfMVswXSA+PSAxMjgpID8gMSA6IDApO1xuXHQgICAgICAgICAgICBpZiAocmVzdWx0LnJlY292ZXJ5UGFyYW0gPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgcmVzdWx0LnJlY292ZXJ5UGFyYW0gPSByZWNvdmVyeVBhcmFtO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdC5yZWNvdmVyeVBhcmFtICE9PSByZWNvdmVyeVBhcmFtKSB7XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwic2lnbmF0dXJlIHJlY292ZXJ5UGFyYW0gbWlzbWF0Y2ggX3ZzXCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgLy8gU2V0IG9yIGNoZWNrIHRoZSBzXG5cdCAgICAgICAgICAgIHZzXzFbMF0gJj0gMHg3Zjtcblx0ICAgICAgICAgICAgdmFyIHMgPSBoZXhsaWZ5KHZzXzEpO1xuXHQgICAgICAgICAgICBpZiAocmVzdWx0LnMgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgcmVzdWx0LnMgPSBzO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdC5zICE9PSBzKSB7XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwic2lnbmF0dXJlIHYgbWlzbWF0Y2ggX3ZzXCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gVXNlIHJlY2lkIGFuZCB2IHRvIHBvcHVsYXRlIGVhY2ggb3RoZXJcblx0ICAgICAgICBpZiAocmVzdWx0LnJlY292ZXJ5UGFyYW0gPT0gbnVsbCkge1xuXHQgICAgICAgICAgICBpZiAocmVzdWx0LnYgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInNpZ25hdHVyZSBtaXNzaW5nIHYgYW5kIHJlY292ZXJ5UGFyYW1cIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHJlc3VsdC5yZWNvdmVyeVBhcmFtID0gMSAtIChyZXN1bHQudiAlIDIpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICBpZiAocmVzdWx0LnYgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgcmVzdWx0LnYgPSAyNyArIHJlc3VsdC5yZWNvdmVyeVBhcmFtO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdC5yZWNvdmVyeVBhcmFtICE9PSAoMSAtIChyZXN1bHQudiAlIDIpKSkge1xuXHQgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInNpZ25hdHVyZSByZWNvdmVyeVBhcmFtIG1pc21hdGNoIHZcIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAocmVzdWx0LnIgPT0gbnVsbCB8fCAhaXNIZXhTdHJpbmcocmVzdWx0LnIpKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzaWduYXR1cmUgbWlzc2luZyBvciBpbnZhbGlkIHJcIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIHJlc3VsdC5yID0gaGV4WmVyb1BhZChyZXN1bHQuciwgMzIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAocmVzdWx0LnMgPT0gbnVsbCB8fCAhaXNIZXhTdHJpbmcocmVzdWx0LnMpKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzaWduYXR1cmUgbWlzc2luZyBvciBpbnZhbGlkIHNcIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIHJlc3VsdC5zID0gaGV4WmVyb1BhZChyZXN1bHQucywgMzIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgdnMgPSBhcnJheWlmeShyZXN1bHQucyk7XG5cdCAgICAgICAgaWYgKHZzWzBdID49IDEyOCkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwic2lnbmF0dXJlIHMgb3V0IG9mIHJhbmdlXCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChyZXN1bHQucmVjb3ZlcnlQYXJhbSkge1xuXHQgICAgICAgICAgICB2c1swXSB8PSAweDgwO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgX3ZzID0gaGV4bGlmeSh2cyk7XG5cdCAgICAgICAgaWYgKHJlc3VsdC5fdnMpIHtcblx0ICAgICAgICAgICAgaWYgKCFpc0hleFN0cmluZyhyZXN1bHQuX3ZzKSkge1xuXHQgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInNpZ25hdHVyZSBpbnZhbGlkIF92c1wiLCBcInNpZ25hdHVyZVwiLCBzaWduYXR1cmUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJlc3VsdC5fdnMgPSBoZXhaZXJvUGFkKHJlc3VsdC5fdnMsIDMyKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gU2V0IG9yIGNoZWNrIHRoZSBfdnNcblx0ICAgICAgICBpZiAocmVzdWx0Ll92cyA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHJlc3VsdC5fdnMgPSBfdnM7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2UgaWYgKHJlc3VsdC5fdnMgIT09IF92cykge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwic2lnbmF0dXJlIF92cyBtaXNtYXRjaCB2IGFuZCBzXCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0fVxuXHRleHBvcnRzLnNwbGl0U2lnbmF0dXJlID0gc3BsaXRTaWduYXR1cmU7XG5cdGZ1bmN0aW9uIGpvaW5TaWduYXR1cmUoc2lnbmF0dXJlKSB7XG5cdCAgICBzaWduYXR1cmUgPSBzcGxpdFNpZ25hdHVyZShzaWduYXR1cmUpO1xuXHQgICAgcmV0dXJuIGhleGxpZnkoY29uY2F0KFtcblx0ICAgICAgICBzaWduYXR1cmUucixcblx0ICAgICAgICBzaWduYXR1cmUucyxcblx0ICAgICAgICAoc2lnbmF0dXJlLnJlY292ZXJ5UGFyYW0gPyBcIjB4MWNcIiA6IFwiMHgxYlwiKVxuXHQgICAgXSkpO1xuXHR9XG5cdGV4cG9ydHMuam9pblNpZ25hdHVyZSA9IGpvaW5TaWduYXR1cmU7XG5cblx0fSk7XG5cblx0dmFyIGluZGV4JDEgPSB1bndyYXBFeHBvcnRzKGxpYiQxKTtcblx0dmFyIGxpYl8xJDEgPSBsaWIkMS5pc0J5dGVzTGlrZTtcblx0dmFyIGxpYl8yJDEgPSBsaWIkMS5pc0J5dGVzO1xuXHR2YXIgbGliXzMkMSA9IGxpYiQxLmFycmF5aWZ5O1xuXHR2YXIgbGliXzQgPSBsaWIkMS5jb25jYXQ7XG5cdHZhciBsaWJfNSA9IGxpYiQxLnN0cmlwWmVyb3M7XG5cdHZhciBsaWJfNiA9IGxpYiQxLnplcm9QYWQ7XG5cdHZhciBsaWJfNyA9IGxpYiQxLmlzSGV4U3RyaW5nO1xuXHR2YXIgbGliXzggPSBsaWIkMS5oZXhsaWZ5O1xuXHR2YXIgbGliXzkgPSBsaWIkMS5oZXhEYXRhTGVuZ3RoO1xuXHR2YXIgbGliXzEwID0gbGliJDEuaGV4RGF0YVNsaWNlO1xuXHR2YXIgbGliXzExID0gbGliJDEuaGV4Q29uY2F0O1xuXHR2YXIgbGliXzEyID0gbGliJDEuaGV4VmFsdWU7XG5cdHZhciBsaWJfMTMgPSBsaWIkMS5oZXhTdHJpcFplcm9zO1xuXHR2YXIgbGliXzE0ID0gbGliJDEuaGV4WmVyb1BhZDtcblx0dmFyIGxpYl8xNSA9IGxpYiQxLnNwbGl0U2lnbmF0dXJlO1xuXHR2YXIgbGliXzE2ID0gbGliJDEuam9pblNpZ25hdHVyZTtcblxuXHR2YXIgX3ZlcnNpb24kNCA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy52ZXJzaW9uID0gXCJiaWdudW1iZXIvNS4wLjVcIjtcblxuXHR9KTtcblxuXHR2YXIgX3ZlcnNpb24kNSA9IHVud3JhcEV4cG9ydHMoX3ZlcnNpb24kNCk7XG5cdHZhciBfdmVyc2lvbl8xJDIgPSBfdmVyc2lvbiQ0LnZlcnNpb247XG5cblx0dmFyIGJpZ251bWJlciA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0LyoqXG5cdCAqICBCaWdOdW1iZXJcblx0ICpcblx0ICogIEEgd3JhcHBlciBhcm91bmQgdGhlIEJOLmpzIG9iamVjdC4gV2UgdXNlIHRoZSBCTi5qcyBsaWJyYXJ5XG5cdCAqICBiZWNhdXNlIGl0IGlzIHVzZWQgYnkgZWxsaXB0aWMsIHNvIGl0IGlzIHJlcXVpcmVkIHJlZ2FyZGxlcy5cblx0ICpcblx0ICovXG5cblxuXG5cblx0dmFyIGxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJDQudmVyc2lvbik7XG5cdHZhciBfY29uc3RydWN0b3JHdWFyZCA9IHt9O1xuXHR2YXIgTUFYX1NBRkUgPSAweDFmZmZmZmZmZmZmZmZmO1xuXHRmdW5jdGlvbiBpc0JpZ051bWJlcmlzaCh2YWx1ZSkge1xuXHQgICAgcmV0dXJuICh2YWx1ZSAhPSBudWxsKSAmJiAoQmlnTnVtYmVyLmlzQmlnTnVtYmVyKHZhbHVlKSB8fFxuXHQgICAgICAgICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJudW1iZXJcIiAmJiAodmFsdWUgJSAxKSA9PT0gMCkgfHxcblx0ICAgICAgICAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIgJiYgISF2YWx1ZS5tYXRjaCgvXi0/WzAtOV0rJC8pKSB8fFxuXHQgICAgICAgIGxpYiQxLmlzSGV4U3RyaW5nKHZhbHVlKSB8fFxuXHQgICAgICAgICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJiaWdpbnRcIikgfHxcblx0ICAgICAgICBsaWIkMS5pc0J5dGVzKHZhbHVlKSk7XG5cdH1cblx0ZXhwb3J0cy5pc0JpZ051bWJlcmlzaCA9IGlzQmlnTnVtYmVyaXNoO1xuXHR2YXIgQmlnTnVtYmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gQmlnTnVtYmVyKGNvbnN0cnVjdG9yR3VhcmQsIGhleCkge1xuXHQgICAgICAgIHZhciBfbmV3VGFyZ2V0ID0gdGhpcy5jb25zdHJ1Y3Rvcjtcblx0ICAgICAgICBsb2dnZXIuY2hlY2tOZXcoX25ld1RhcmdldCwgQmlnTnVtYmVyKTtcblx0ICAgICAgICBpZiAoY29uc3RydWN0b3JHdWFyZCAhPT0gX2NvbnN0cnVjdG9yR3VhcmQpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJjYW5ub3QgY2FsbCBjb25zdHJ1Y3RvciBkaXJlY3RseTsgdXNlIEJpZ051bWJlci5mcm9tXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuXHQgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcIm5ldyAoQmlnTnVtYmVyKVwiXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9oZXggPSBoZXg7XG5cdCAgICAgICAgdGhpcy5faXNCaWdOdW1iZXIgPSB0cnVlO1xuXHQgICAgICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG5cdCAgICB9XG5cdCAgICBCaWdOdW1iZXIucHJvdG90eXBlLmZyb21Ud29zID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykuZnJvbVR3b3ModmFsdWUpKTtcblx0ICAgIH07XG5cdCAgICBCaWdOdW1iZXIucHJvdG90eXBlLnRvVHdvcyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLnRvVHdvcyh2YWx1ZSkpO1xuXHQgICAgfTtcblx0ICAgIEJpZ051bWJlci5wcm90b3R5cGUuYWJzID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGlmICh0aGlzLl9oZXhbMF0gPT09IFwiLVwiKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBCaWdOdW1iZXIuZnJvbSh0aGlzLl9oZXguc3Vic3RyaW5nKDEpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgQmlnTnVtYmVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0ICAgICAgICByZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS5hZGQodG9CTihvdGhlcikpKTtcblx0ICAgIH07XG5cdCAgICBCaWdOdW1iZXIucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHQgICAgICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLnN1Yih0b0JOKG90aGVyKSkpO1xuXHQgICAgfTtcblx0ICAgIEJpZ051bWJlci5wcm90b3R5cGUuZGl2ID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdCAgICAgICAgdmFyIG8gPSBCaWdOdW1iZXIuZnJvbShvdGhlcik7XG5cdCAgICAgICAgaWYgKG8uaXNaZXJvKCkpIHtcblx0ICAgICAgICAgICAgdGhyb3dGYXVsdChcImRpdmlzaW9uIGJ5IHplcm9cIiwgXCJkaXZcIik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLmRpdih0b0JOKG90aGVyKSkpO1xuXHQgICAgfTtcblx0ICAgIEJpZ051bWJlci5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdCAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykubXVsKHRvQk4ob3RoZXIpKSk7XG5cdCAgICB9O1xuXHQgICAgQmlnTnVtYmVyLnByb3RvdHlwZS5tb2QgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0ICAgICAgICB2YXIgdmFsdWUgPSB0b0JOKG90aGVyKTtcblx0ICAgICAgICBpZiAodmFsdWUuaXNOZWcoKSkge1xuXHQgICAgICAgICAgICB0aHJvd0ZhdWx0KFwiY2Fubm90IG1vZHVsbyBuZWdhdGl2ZSB2YWx1ZXNcIiwgXCJtb2RcIik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLnVtb2QodmFsdWUpKTtcblx0ICAgIH07XG5cdCAgICBCaWdOdW1iZXIucHJvdG90eXBlLnBvdyA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHQgICAgICAgIHZhciB2YWx1ZSA9IHRvQk4ob3RoZXIpO1xuXHQgICAgICAgIGlmICh2YWx1ZS5pc05lZygpKSB7XG5cdCAgICAgICAgICAgIHRocm93RmF1bHQoXCJjYW5ub3QgcmFpc2UgdG8gbmVnYXRpdmUgdmFsdWVzXCIsIFwicG93XCIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS5wb3codmFsdWUpKTtcblx0ICAgIH07XG5cdCAgICBCaWdOdW1iZXIucHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHQgICAgICAgIHZhciB2YWx1ZSA9IHRvQk4ob3RoZXIpO1xuXHQgICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSB8fCB2YWx1ZS5pc05lZygpKSB7XG5cdCAgICAgICAgICAgIHRocm93RmF1bHQoXCJjYW5ub3QgJ2FuZCcgbmVnYXRpdmUgdmFsdWVzXCIsIFwiYW5kXCIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS5hbmQodmFsdWUpKTtcblx0ICAgIH07XG5cdCAgICBCaWdOdW1iZXIucHJvdG90eXBlLm9yID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdCAgICAgICAgdmFyIHZhbHVlID0gdG9CTihvdGhlcik7XG5cdCAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpIHx8IHZhbHVlLmlzTmVnKCkpIHtcblx0ICAgICAgICAgICAgdGhyb3dGYXVsdChcImNhbm5vdCAnb3InIG5lZ2F0aXZlIHZhbHVlc1wiLCBcIm9yXCIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS5vcih2YWx1ZSkpO1xuXHQgICAgfTtcblx0ICAgIEJpZ051bWJlci5wcm90b3R5cGUueG9yID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdCAgICAgICAgdmFyIHZhbHVlID0gdG9CTihvdGhlcik7XG5cdCAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpIHx8IHZhbHVlLmlzTmVnKCkpIHtcblx0ICAgICAgICAgICAgdGhyb3dGYXVsdChcImNhbm5vdCAneG9yJyBuZWdhdGl2ZSB2YWx1ZXNcIiwgXCJ4b3JcIik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLnhvcih2YWx1ZSkpO1xuXHQgICAgfTtcblx0ICAgIEJpZ051bWJlci5wcm90b3R5cGUubWFzayA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSB8fCB2YWx1ZSA8IDApIHtcblx0ICAgICAgICAgICAgdGhyb3dGYXVsdChcImNhbm5vdCBtYXNrIG5lZ2F0aXZlIHZhbHVlc1wiLCBcIm1hc2tcIik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLm1hc2tuKHZhbHVlKSk7XG5cdCAgICB9O1xuXHQgICAgQmlnTnVtYmVyLnByb3RvdHlwZS5zaGwgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkgfHwgdmFsdWUgPCAwKSB7XG5cdCAgICAgICAgICAgIHRocm93RmF1bHQoXCJjYW5ub3Qgc2hpZnQgbmVnYXRpdmUgdmFsdWVzXCIsIFwic2hsXCIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS5zaGxuKHZhbHVlKSk7XG5cdCAgICB9O1xuXHQgICAgQmlnTnVtYmVyLnByb3RvdHlwZS5zaHIgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkgfHwgdmFsdWUgPCAwKSB7XG5cdCAgICAgICAgICAgIHRocm93RmF1bHQoXCJjYW5ub3Qgc2hpZnQgbmVnYXRpdmUgdmFsdWVzXCIsIFwic2hyXCIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS5zaHJuKHZhbHVlKSk7XG5cdCAgICB9O1xuXHQgICAgQmlnTnVtYmVyLnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHQgICAgICAgIHJldHVybiB0b0JOKHRoaXMpLmVxKHRvQk4ob3RoZXIpKTtcblx0ICAgIH07XG5cdCAgICBCaWdOdW1iZXIucHJvdG90eXBlLmx0ID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdCAgICAgICAgcmV0dXJuIHRvQk4odGhpcykubHQodG9CTihvdGhlcikpO1xuXHQgICAgfTtcblx0ICAgIEJpZ051bWJlci5wcm90b3R5cGUubHRlID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdCAgICAgICAgcmV0dXJuIHRvQk4odGhpcykubHRlKHRvQk4ob3RoZXIpKTtcblx0ICAgIH07XG5cdCAgICBCaWdOdW1iZXIucHJvdG90eXBlLmd0ID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdCAgICAgICAgcmV0dXJuIHRvQk4odGhpcykuZ3QodG9CTihvdGhlcikpO1xuXHQgICAgfTtcblx0ICAgIEJpZ051bWJlci5wcm90b3R5cGUuZ3RlID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdCAgICAgICAgcmV0dXJuIHRvQk4odGhpcykuZ3RlKHRvQk4ob3RoZXIpKTtcblx0ICAgIH07XG5cdCAgICBCaWdOdW1iZXIucHJvdG90eXBlLmlzTmVnYXRpdmUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuICh0aGlzLl9oZXhbMF0gPT09IFwiLVwiKTtcblx0ICAgIH07XG5cdCAgICBCaWdOdW1iZXIucHJvdG90eXBlLmlzWmVybyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gdG9CTih0aGlzKS5pc1plcm8oKTtcblx0ICAgIH07XG5cdCAgICBCaWdOdW1iZXIucHJvdG90eXBlLnRvTnVtYmVyID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0b0JOKHRoaXMpLnRvTnVtYmVyKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgICAgICB0aHJvd0ZhdWx0KFwib3ZlcmZsb3dcIiwgXCJ0b051bWJlclwiLCB0aGlzLnRvU3RyaW5nKCkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgIH07XG5cdCAgICBCaWdOdW1iZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIC8vIExvdHMgb2YgcGVvcGxlIGV4cGVjdCB0aGlzLCB3aGljaCB3ZSBkbyBub3Qgc3VwcG9ydCwgc28gY2hlY2tcblx0ICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMCkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImJpZ051bWJlci50b1N0cmluZyBkb2VzIG5vdCBhY2NlcHQgcGFyYW1ldGVyc1wiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTkVYUEVDVEVEX0FSR1VNRU5ULCB7fSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0b0JOKHRoaXMpLnRvU3RyaW5nKDEwKTtcblx0ICAgIH07XG5cdCAgICBCaWdOdW1iZXIucHJvdG90eXBlLnRvSGV4U3RyaW5nID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9oZXg7XG5cdCAgICB9O1xuXHQgICAgQmlnTnVtYmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBCaWdOdW1iZXIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgaWYgKHZhbHVlLm1hdGNoKC9eLT8weFswLTlhLWZdKyQvaSkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKF9jb25zdHJ1Y3Rvckd1YXJkLCB0b0hleCh2YWx1ZSkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmICh2YWx1ZS5tYXRjaCgvXi0/WzAtOV0rJC8pKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihfY29uc3RydWN0b3JHdWFyZCwgdG9IZXgobmV3IGJuLkJOKHZhbHVlKSkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBCaWdOdW1iZXIgc3RyaW5nXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwibnVtYmVyXCIpIHtcblx0ICAgICAgICAgICAgaWYgKHZhbHVlICUgMSkge1xuXHQgICAgICAgICAgICAgICAgdGhyb3dGYXVsdChcInVuZGVyZmxvd1wiLCBcIkJpZ051bWJlci5mcm9tXCIsIHZhbHVlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAodmFsdWUgPj0gTUFYX1NBRkUgfHwgdmFsdWUgPD0gLU1BWF9TQUZFKSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvd0ZhdWx0KFwib3ZlcmZsb3dcIiwgXCJCaWdOdW1iZXIuZnJvbVwiLCB2YWx1ZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKFN0cmluZyh2YWx1ZSkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwiYmlnaW50XCIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKHZhbHVlLnRvU3RyaW5nKCkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAobGliJDEuaXNCeXRlcyh2YWx1ZSkpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKGxpYiQxLmhleGxpZnkodmFsdWUpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHZhbHVlLl9oZXggJiYgbGliJDEuaXNIZXhTdHJpbmcodmFsdWUuX2hleCkpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKHZhbHVlLl9oZXgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodmFsdWUudG9IZXhTdHJpbmcpIHtcblx0ICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0hleFN0cmluZygpO1xuXHQgICAgICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBCaWdOdW1iZXIuZnJvbSh2YWx1ZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIEJpZ051bWJlciB2YWx1ZVwiLCBcInZhbHVlXCIsIHZhbHVlKTtcblx0ICAgIH07XG5cdCAgICBCaWdOdW1iZXIuaXNCaWdOdW1iZXIgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX2lzQmlnTnVtYmVyKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gQmlnTnVtYmVyO1xuXHR9KCkpO1xuXHRleHBvcnRzLkJpZ051bWJlciA9IEJpZ051bWJlcjtcblx0Ly8gTm9ybWFsaXplIHRoZSBoZXggc3RyaW5nXG5cdGZ1bmN0aW9uIHRvSGV4KHZhbHVlKSB7XG5cdCAgICAvLyBGb3IgQk4sIGNhbGwgb24gdGhlIGhleCBzdHJpbmdcblx0ICAgIGlmICh0eXBlb2YgKHZhbHVlKSAhPT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgIHJldHVybiB0b0hleCh2YWx1ZS50b1N0cmluZygxNikpO1xuXHQgICAgfVxuXHQgICAgLy8gSWYgbmVnYXRpdmUsIHByZXBlbmQgdGhlIG5lZ2F0aXZlIHNpZ24gdG8gdGhlIG5vcm1hbGl6ZWQgcG9zaXRpdmUgdmFsdWVcblx0ICAgIGlmICh2YWx1ZVswXSA9PT0gXCItXCIpIHtcblx0ICAgICAgICAvLyBTdHJpcCBvZmYgdGhlIG5lZ2F0aXZlIHNpZ25cblx0ICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cmluZygxKTtcblx0ICAgICAgICAvLyBDYW5ub3QgaGF2ZSBtdWxpdHBsZSBuZWdhdGl2ZSBzaWducyAoZS5nLiBcIi0tMHgwNFwiKVxuXHQgICAgICAgIGlmICh2YWx1ZVswXSA9PT0gXCItXCIpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgaGV4XCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBDYWxsIHRvSGV4IG9uIHRoZSBwb3NpdGl2ZSBjb21wb25lbnRcblx0ICAgICAgICB2YWx1ZSA9IHRvSGV4KHZhbHVlKTtcblx0ICAgICAgICAvLyBEbyBub3QgYWxsb3cgXCItMHgwMFwiXG5cdCAgICAgICAgaWYgKHZhbHVlID09PSBcIjB4MDBcIikge1xuXHQgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIE5lZ2F0ZSB0aGUgdmFsdWVcblx0ICAgICAgICByZXR1cm4gXCItXCIgKyB2YWx1ZTtcblx0ICAgIH1cblx0ICAgIC8vIEFkZCBhIFwiMHhcIiBwcmVmaXggaWYgbWlzc2luZ1xuXHQgICAgaWYgKHZhbHVlLnN1YnN0cmluZygwLCAyKSAhPT0gXCIweFwiKSB7XG5cdCAgICAgICAgdmFsdWUgPSBcIjB4XCIgKyB2YWx1ZTtcblx0ICAgIH1cblx0ICAgIC8vIE5vcm1hbGl6ZSB6ZXJvXG5cdCAgICBpZiAodmFsdWUgPT09IFwiMHhcIikge1xuXHQgICAgICAgIHJldHVybiBcIjB4MDBcIjtcblx0ICAgIH1cblx0ICAgIC8vIE1ha2UgdGhlIHN0cmluZyBldmVuIGxlbmd0aFxuXHQgICAgaWYgKHZhbHVlLmxlbmd0aCAlIDIpIHtcblx0ICAgICAgICB2YWx1ZSA9IFwiMHgwXCIgKyB2YWx1ZS5zdWJzdHJpbmcoMik7XG5cdCAgICB9XG5cdCAgICAvLyBUcmltIHRvIHNtYWxsZXN0IGV2ZW4tbGVuZ3RoIHN0cmluZ1xuXHQgICAgd2hpbGUgKHZhbHVlLmxlbmd0aCA+IDQgJiYgdmFsdWUuc3Vic3RyaW5nKDAsIDQpID09PSBcIjB4MDBcIikge1xuXHQgICAgICAgIHZhbHVlID0gXCIweFwiICsgdmFsdWUuc3Vic3RyaW5nKDQpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHZhbHVlO1xuXHR9XG5cdGZ1bmN0aW9uIHRvQmlnTnVtYmVyKHZhbHVlKSB7XG5cdCAgICByZXR1cm4gQmlnTnVtYmVyLmZyb20odG9IZXgodmFsdWUpKTtcblx0fVxuXHRmdW5jdGlvbiB0b0JOKHZhbHVlKSB7XG5cdCAgICB2YXIgaGV4ID0gQmlnTnVtYmVyLmZyb20odmFsdWUpLnRvSGV4U3RyaW5nKCk7XG5cdCAgICBpZiAoaGV4WzBdID09PSBcIi1cIikge1xuXHQgICAgICAgIHJldHVybiAobmV3IGJuLkJOKFwiLVwiICsgaGV4LnN1YnN0cmluZygzKSwgMTYpKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBuZXcgYm4uQk4oaGV4LnN1YnN0cmluZygyKSwgMTYpO1xuXHR9XG5cdGZ1bmN0aW9uIHRocm93RmF1bHQoZmF1bHQsIG9wZXJhdGlvbiwgdmFsdWUpIHtcblx0ICAgIHZhciBwYXJhbXMgPSB7IGZhdWx0OiBmYXVsdCwgb3BlcmF0aW9uOiBvcGVyYXRpb24gfTtcblx0ICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG5cdCAgICAgICAgcGFyYW1zLnZhbHVlID0gdmFsdWU7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoZmF1bHQsIGxpYi5Mb2dnZXIuZXJyb3JzLk5VTUVSSUNfRkFVTFQsIHBhcmFtcyk7XG5cdH1cblxuXHR9KTtcblxuXHR2YXIgYmlnbnVtYmVyJDEgPSB1bndyYXBFeHBvcnRzKGJpZ251bWJlcik7XG5cdHZhciBiaWdudW1iZXJfMSA9IGJpZ251bWJlci5pc0JpZ051bWJlcmlzaDtcblx0dmFyIGJpZ251bWJlcl8yID0gYmlnbnVtYmVyLkJpZ051bWJlcjtcblxuXHR2YXIgZml4ZWRudW1iZXIgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cblxuXG5cdHZhciBsb2dnZXIgPSBuZXcgbGliLkxvZ2dlcihfdmVyc2lvbiQ0LnZlcnNpb24pO1xuXG5cdHZhciBfY29uc3RydWN0b3JHdWFyZCA9IHt9O1xuXHR2YXIgWmVybyA9IGJpZ251bWJlci5CaWdOdW1iZXIuZnJvbSgwKTtcblx0dmFyIE5lZ2F0aXZlT25lID0gYmlnbnVtYmVyLkJpZ051bWJlci5mcm9tKC0xKTtcblx0ZnVuY3Rpb24gdGhyb3dGYXVsdChtZXNzYWdlLCBmYXVsdCwgb3BlcmF0aW9uLCB2YWx1ZSkge1xuXHQgICAgdmFyIHBhcmFtcyA9IHsgZmF1bHQ6IGZhdWx0LCBvcGVyYXRpb246IG9wZXJhdGlvbiB9O1xuXHQgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICBwYXJhbXMudmFsdWUgPSB2YWx1ZTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihtZXNzYWdlLCBsaWIuTG9nZ2VyLmVycm9ycy5OVU1FUklDX0ZBVUxULCBwYXJhbXMpO1xuXHR9XG5cdC8vIENvbnN0YW50IHRvIHB1bGwgemVyb3MgZnJvbSBmb3IgbXVsdGlwbGllcnNcblx0dmFyIHplcm9zID0gXCIwXCI7XG5cdHdoaWxlICh6ZXJvcy5sZW5ndGggPCAyNTYpIHtcblx0ICAgIHplcm9zICs9IHplcm9zO1xuXHR9XG5cdC8vIFJldHVybnMgYSBzdHJpbmcgXCIxXCIgZm9sbG93ZWQgYnkgZGVjaW1hbCBcIjBcInNcblx0ZnVuY3Rpb24gZ2V0TXVsdGlwbGllcihkZWNpbWFscykge1xuXHQgICAgaWYgKHR5cGVvZiAoZGVjaW1hbHMpICE9PSBcIm51bWJlclwiKSB7XG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgZGVjaW1hbHMgPSBiaWdudW1iZXIuQmlnTnVtYmVyLmZyb20oZGVjaW1hbHMpLnRvTnVtYmVyKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGNhdGNoIChlKSB7IH1cblx0ICAgIH1cblx0ICAgIGlmICh0eXBlb2YgKGRlY2ltYWxzKSA9PT0gXCJudW1iZXJcIiAmJiBkZWNpbWFscyA+PSAwICYmIGRlY2ltYWxzIDw9IDI1NiAmJiAhKGRlY2ltYWxzICUgMSkpIHtcblx0ICAgICAgICByZXR1cm4gKFwiMVwiICsgemVyb3Muc3Vic3RyaW5nKDAsIGRlY2ltYWxzKSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZGVjaW1hbCBzaXplXCIsIFwiZGVjaW1hbHNcIiwgZGVjaW1hbHMpO1xuXHR9XG5cdGZ1bmN0aW9uIGZvcm1hdEZpeGVkKHZhbHVlLCBkZWNpbWFscykge1xuXHQgICAgaWYgKGRlY2ltYWxzID09IG51bGwpIHtcblx0ICAgICAgICBkZWNpbWFscyA9IDA7XG5cdCAgICB9XG5cdCAgICB2YXIgbXVsdGlwbGllciA9IGdldE11bHRpcGxpZXIoZGVjaW1hbHMpO1xuXHQgICAgLy8gTWFrZSBzdXJlIHdlaSBpcyBhIGJpZyBudW1iZXIgKGNvbnZlcnQgYXMgbmVjZXNzYXJ5KVxuXHQgICAgdmFsdWUgPSBiaWdudW1iZXIuQmlnTnVtYmVyLmZyb20odmFsdWUpO1xuXHQgICAgdmFyIG5lZ2F0aXZlID0gdmFsdWUubHQoWmVybyk7XG5cdCAgICBpZiAobmVnYXRpdmUpIHtcblx0ICAgICAgICB2YWx1ZSA9IHZhbHVlLm11bChOZWdhdGl2ZU9uZSk7XG5cdCAgICB9XG5cdCAgICB2YXIgZnJhY3Rpb24gPSB2YWx1ZS5tb2QobXVsdGlwbGllcikudG9TdHJpbmcoKTtcblx0ICAgIHdoaWxlIChmcmFjdGlvbi5sZW5ndGggPCBtdWx0aXBsaWVyLmxlbmd0aCAtIDEpIHtcblx0ICAgICAgICBmcmFjdGlvbiA9IFwiMFwiICsgZnJhY3Rpb247XG5cdCAgICB9XG5cdCAgICAvLyBTdHJpcCB0cmFpbmluZyAwXG5cdCAgICBmcmFjdGlvbiA9IGZyYWN0aW9uLm1hdGNoKC9eKFswLTldKlsxLTldfDApKDAqKS8pWzFdO1xuXHQgICAgdmFyIHdob2xlID0gdmFsdWUuZGl2KG11bHRpcGxpZXIpLnRvU3RyaW5nKCk7XG5cdCAgICB2YWx1ZSA9IHdob2xlICsgXCIuXCIgKyBmcmFjdGlvbjtcblx0ICAgIGlmIChuZWdhdGl2ZSkge1xuXHQgICAgICAgIHZhbHVlID0gXCItXCIgKyB2YWx1ZTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB2YWx1ZTtcblx0fVxuXHRleHBvcnRzLmZvcm1hdEZpeGVkID0gZm9ybWF0Rml4ZWQ7XG5cdGZ1bmN0aW9uIHBhcnNlRml4ZWQodmFsdWUsIGRlY2ltYWxzKSB7XG5cdCAgICBpZiAoZGVjaW1hbHMgPT0gbnVsbCkge1xuXHQgICAgICAgIGRlY2ltYWxzID0gMDtcblx0ICAgIH1cblx0ICAgIHZhciBtdWx0aXBsaWVyID0gZ2V0TXVsdGlwbGllcihkZWNpbWFscyk7XG5cdCAgICBpZiAodHlwZW9mICh2YWx1ZSkgIT09IFwic3RyaW5nXCIgfHwgIXZhbHVlLm1hdGNoKC9eLT9bMC05LixdKyQvKSkge1xuXHQgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGRlY2ltYWwgdmFsdWVcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG5cdCAgICB9XG5cdCAgICBpZiAobXVsdGlwbGllci5sZW5ndGggLSAxID09PSAwKSB7XG5cdCAgICAgICAgcmV0dXJuIGJpZ251bWJlci5CaWdOdW1iZXIuZnJvbSh2YWx1ZSk7XG5cdCAgICB9XG5cdCAgICAvLyBJcyBpdCBuZWdhdGl2ZT9cblx0ICAgIHZhciBuZWdhdGl2ZSA9ICh2YWx1ZS5zdWJzdHJpbmcoMCwgMSkgPT09IFwiLVwiKTtcblx0ICAgIGlmIChuZWdhdGl2ZSkge1xuXHQgICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDEpO1xuXHQgICAgfVxuXHQgICAgaWYgKHZhbHVlID09PSBcIi5cIikge1xuXHQgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJtaXNzaW5nIHZhbHVlXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuXHQgICAgfVxuXHQgICAgLy8gU3BsaXQgaXQgaW50byBhIHdob2xlIGFuZCBmcmFjdGlvbmFsIHBhcnRcblx0ICAgIHZhciBjb21wcyA9IHZhbHVlLnNwbGl0KFwiLlwiKTtcblx0ICAgIGlmIChjb21wcy5sZW5ndGggPiAyKSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInRvbyBtYW55IGRlY2ltYWwgcG9pbnRzXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuXHQgICAgfVxuXHQgICAgdmFyIHdob2xlID0gY29tcHNbMF0sIGZyYWN0aW9uID0gY29tcHNbMV07XG5cdCAgICBpZiAoIXdob2xlKSB7XG5cdCAgICAgICAgd2hvbGUgPSBcIjBcIjtcblx0ICAgIH1cblx0ICAgIGlmICghZnJhY3Rpb24pIHtcblx0ICAgICAgICBmcmFjdGlvbiA9IFwiMFwiO1xuXHQgICAgfVxuXHQgICAgLy8gUHJldmVudCB1bmRlcmZsb3dcblx0ICAgIGlmIChmcmFjdGlvbi5sZW5ndGggPiBtdWx0aXBsaWVyLmxlbmd0aCAtIDEpIHtcblx0ICAgICAgICB0aHJvd0ZhdWx0KFwiZnJhY3Rpb25hbCBjb21wb25lbnQgZXhjZWVkcyBkZWNpbWFsc1wiLCBcInVuZGVyZmxvd1wiLCBcInBhcnNlRml4ZWRcIik7XG5cdCAgICB9XG5cdCAgICAvLyBGdWxseSBwYWQgdGhlIHN0cmluZyB3aXRoIHplcm9zIHRvIGdldCB0byB3ZWlcblx0ICAgIHdoaWxlIChmcmFjdGlvbi5sZW5ndGggPCBtdWx0aXBsaWVyLmxlbmd0aCAtIDEpIHtcblx0ICAgICAgICBmcmFjdGlvbiArPSBcIjBcIjtcblx0ICAgIH1cblx0ICAgIHZhciB3aG9sZVZhbHVlID0gYmlnbnVtYmVyLkJpZ051bWJlci5mcm9tKHdob2xlKTtcblx0ICAgIHZhciBmcmFjdGlvblZhbHVlID0gYmlnbnVtYmVyLkJpZ051bWJlci5mcm9tKGZyYWN0aW9uKTtcblx0ICAgIHZhciB3ZWkgPSAod2hvbGVWYWx1ZS5tdWwobXVsdGlwbGllcikpLmFkZChmcmFjdGlvblZhbHVlKTtcblx0ICAgIGlmIChuZWdhdGl2ZSkge1xuXHQgICAgICAgIHdlaSA9IHdlaS5tdWwoTmVnYXRpdmVPbmUpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHdlaTtcblx0fVxuXHRleHBvcnRzLnBhcnNlRml4ZWQgPSBwYXJzZUZpeGVkO1xuXHR2YXIgRml4ZWRGb3JtYXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBGaXhlZEZvcm1hdChjb25zdHJ1Y3Rvckd1YXJkLCBzaWduZWQsIHdpZHRoLCBkZWNpbWFscykge1xuXHQgICAgICAgIGlmIChjb25zdHJ1Y3Rvckd1YXJkICE9PSBfY29uc3RydWN0b3JHdWFyZCkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImNhbm5vdCB1c2UgRml4ZWRGb3JtYXQgY29uc3RydWN0b3I7IHVzZSBGaXhlZEZvcm1hdC5mcm9tXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuXHQgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcIm5ldyBGaXhlZEZvcm1hdFwiXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLnNpZ25lZCA9IHNpZ25lZDtcblx0ICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG5cdCAgICAgICAgdGhpcy5kZWNpbWFscyA9IGRlY2ltYWxzO1xuXHQgICAgICAgIHRoaXMubmFtZSA9IChzaWduZWQgPyBcIlwiIDogXCJ1XCIpICsgXCJmaXhlZFwiICsgU3RyaW5nKHdpZHRoKSArIFwieFwiICsgU3RyaW5nKGRlY2ltYWxzKTtcblx0ICAgICAgICB0aGlzLl9tdWx0aXBsaWVyID0gZ2V0TXVsdGlwbGllcihkZWNpbWFscyk7XG5cdCAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcblx0ICAgIH1cblx0ICAgIEZpeGVkRm9ybWF0LmZyb20gPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBGaXhlZEZvcm1hdCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBzaWduZWQgPSB0cnVlO1xuXHQgICAgICAgIHZhciB3aWR0aCA9IDEyODtcblx0ICAgICAgICB2YXIgZGVjaW1hbHMgPSAxODtcblx0ICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgaWYgKHZhbHVlID09PSBcImZpeGVkXCIpIHtcblx0ICAgICAgICAgICAgICAgIC8vIGRlZmF1bHRzLi4uXG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgPT09IFwidWZpeGVkXCIpIHtcblx0ICAgICAgICAgICAgICAgIHNpZ25lZCA9IGZhbHNlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IHZhbHVlLm1hdGNoKC9eKHU/KWZpeGVkKFswLTldKyl4KFswLTldKykkLyk7XG5cdCAgICAgICAgICAgICAgICBpZiAoIW1hdGNoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZml4ZWQgZm9ybWF0XCIsIFwiZm9ybWF0XCIsIHZhbHVlKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHNpZ25lZCA9IChtYXRjaFsxXSAhPT0gXCJ1XCIpO1xuXHQgICAgICAgICAgICAgICAgd2lkdGggPSBwYXJzZUludChtYXRjaFsyXSk7XG5cdCAgICAgICAgICAgICAgICBkZWNpbWFscyA9IHBhcnNlSW50KG1hdGNoWzNdKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIGlmICh2YWx1ZSkge1xuXHQgICAgICAgICAgICB2YXIgY2hlY2sgPSBmdW5jdGlvbiAoa2V5LCB0eXBlLCBkZWZhdWx0VmFsdWUpIHtcblx0ICAgICAgICAgICAgICAgIGlmICh2YWx1ZVtrZXldID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAodmFsdWVba2V5XSkgIT09IHR5cGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBmaXhlZCBmb3JtYXQgKFwiICsga2V5ICsgXCIgbm90IFwiICsgdHlwZSArIFwiKVwiLCBcImZvcm1hdC5cIiArIGtleSwgdmFsdWVba2V5XSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVba2V5XTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgc2lnbmVkID0gY2hlY2soXCJzaWduZWRcIiwgXCJib29sZWFuXCIsIHNpZ25lZCk7XG5cdCAgICAgICAgICAgIHdpZHRoID0gY2hlY2soXCJ3aWR0aFwiLCBcIm51bWJlclwiLCB3aWR0aCk7XG5cdCAgICAgICAgICAgIGRlY2ltYWxzID0gY2hlY2soXCJkZWNpbWFsc1wiLCBcIm51bWJlclwiLCBkZWNpbWFscyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICh3aWR0aCAlIDgpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZml4ZWQgZm9ybWF0IHdpZHRoIChub3QgYnl0ZSBhbGlnbmVkKVwiLCBcImZvcm1hdC53aWR0aFwiLCB3aWR0aCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChkZWNpbWFscyA+IDgwKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGZpeGVkIGZvcm1hdCAoZGVjaW1hbHMgdG9vIGxhcmdlKVwiLCBcImZvcm1hdC5kZWNpbWFsc1wiLCBkZWNpbWFscyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBuZXcgRml4ZWRGb3JtYXQoX2NvbnN0cnVjdG9yR3VhcmQsIHNpZ25lZCwgd2lkdGgsIGRlY2ltYWxzKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gRml4ZWRGb3JtYXQ7XG5cdH0oKSk7XG5cdGV4cG9ydHMuRml4ZWRGb3JtYXQgPSBGaXhlZEZvcm1hdDtcblx0dmFyIEZpeGVkTnVtYmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gRml4ZWROdW1iZXIoY29uc3RydWN0b3JHdWFyZCwgaGV4LCB2YWx1ZSwgZm9ybWF0KSB7XG5cdCAgICAgICAgdmFyIF9uZXdUYXJnZXQgPSB0aGlzLmNvbnN0cnVjdG9yO1xuXHQgICAgICAgIGxvZ2dlci5jaGVja05ldyhfbmV3VGFyZ2V0LCBGaXhlZE51bWJlcik7XG5cdCAgICAgICAgaWYgKGNvbnN0cnVjdG9yR3VhcmQgIT09IF9jb25zdHJ1Y3Rvckd1YXJkKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IHVzZSBGaXhlZE51bWJlciBjb25zdHJ1Y3RvcjsgdXNlIEZpeGVkTnVtYmVyLmZyb21cIiwgbGliLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG5cdCAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwibmV3IEZpeGVkRm9ybWF0XCJcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuZm9ybWF0ID0gZm9ybWF0O1xuXHQgICAgICAgIHRoaXMuX2hleCA9IGhleDtcblx0ICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuXHQgICAgICAgIHRoaXMuX2lzRml4ZWROdW1iZXIgPSB0cnVlO1xuXHQgICAgICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG5cdCAgICB9XG5cdCAgICBGaXhlZE51bWJlci5wcm90b3R5cGUuX2NoZWNrRm9ybWF0ID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuZm9ybWF0Lm5hbWUgIT09IG90aGVyLmZvcm1hdC5uYW1lKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbmNvbXBhdGlibGUgZm9ybWF0OyB1c2UgZml4ZWROdW1iZXIudG9Gb3JtYXRcIiwgXCJvdGhlclwiLCBvdGhlcik7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIEZpeGVkTnVtYmVyLnByb3RvdHlwZS5hZGRVbnNhZmUgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0ICAgICAgICB0aGlzLl9jaGVja0Zvcm1hdChvdGhlcik7XG5cdCAgICAgICAgdmFyIGEgPSBwYXJzZUZpeGVkKHRoaXMuX3ZhbHVlLCB0aGlzLmZvcm1hdC5kZWNpbWFscyk7XG5cdCAgICAgICAgdmFyIGIgPSBwYXJzZUZpeGVkKG90aGVyLl92YWx1ZSwgb3RoZXIuZm9ybWF0LmRlY2ltYWxzKTtcblx0ICAgICAgICByZXR1cm4gRml4ZWROdW1iZXIuZnJvbVZhbHVlKGEuYWRkKGIpLCB0aGlzLmZvcm1hdC5kZWNpbWFscywgdGhpcy5mb3JtYXQpO1xuXHQgICAgfTtcblx0ICAgIEZpeGVkTnVtYmVyLnByb3RvdHlwZS5zdWJVbnNhZmUgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0ICAgICAgICB0aGlzLl9jaGVja0Zvcm1hdChvdGhlcik7XG5cdCAgICAgICAgdmFyIGEgPSBwYXJzZUZpeGVkKHRoaXMuX3ZhbHVlLCB0aGlzLmZvcm1hdC5kZWNpbWFscyk7XG5cdCAgICAgICAgdmFyIGIgPSBwYXJzZUZpeGVkKG90aGVyLl92YWx1ZSwgb3RoZXIuZm9ybWF0LmRlY2ltYWxzKTtcblx0ICAgICAgICByZXR1cm4gRml4ZWROdW1iZXIuZnJvbVZhbHVlKGEuc3ViKGIpLCB0aGlzLmZvcm1hdC5kZWNpbWFscywgdGhpcy5mb3JtYXQpO1xuXHQgICAgfTtcblx0ICAgIEZpeGVkTnVtYmVyLnByb3RvdHlwZS5tdWxVbnNhZmUgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0ICAgICAgICB0aGlzLl9jaGVja0Zvcm1hdChvdGhlcik7XG5cdCAgICAgICAgdmFyIGEgPSBwYXJzZUZpeGVkKHRoaXMuX3ZhbHVlLCB0aGlzLmZvcm1hdC5kZWNpbWFscyk7XG5cdCAgICAgICAgdmFyIGIgPSBwYXJzZUZpeGVkKG90aGVyLl92YWx1ZSwgb3RoZXIuZm9ybWF0LmRlY2ltYWxzKTtcblx0ICAgICAgICByZXR1cm4gRml4ZWROdW1iZXIuZnJvbVZhbHVlKGEubXVsKGIpLmRpdih0aGlzLmZvcm1hdC5fbXVsdGlwbGllciksIHRoaXMuZm9ybWF0LmRlY2ltYWxzLCB0aGlzLmZvcm1hdCk7XG5cdCAgICB9O1xuXHQgICAgRml4ZWROdW1iZXIucHJvdG90eXBlLmRpdlVuc2FmZSA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHQgICAgICAgIHRoaXMuX2NoZWNrRm9ybWF0KG90aGVyKTtcblx0ICAgICAgICB2YXIgYSA9IHBhcnNlRml4ZWQodGhpcy5fdmFsdWUsIHRoaXMuZm9ybWF0LmRlY2ltYWxzKTtcblx0ICAgICAgICB2YXIgYiA9IHBhcnNlRml4ZWQob3RoZXIuX3ZhbHVlLCBvdGhlci5mb3JtYXQuZGVjaW1hbHMpO1xuXHQgICAgICAgIHJldHVybiBGaXhlZE51bWJlci5mcm9tVmFsdWUoYS5tdWwodGhpcy5mb3JtYXQuX211bHRpcGxpZXIpLmRpdihiKSwgdGhpcy5mb3JtYXQuZGVjaW1hbHMsIHRoaXMuZm9ybWF0KTtcblx0ICAgIH07XG5cdCAgICAvLyBAVE9ETzogU3VwcG9ydCBvdGhlciByb3VuZGluZyBhbGdvcml0aG1zXG5cdCAgICBGaXhlZE51bWJlci5wcm90b3R5cGUucm91bmQgPSBmdW5jdGlvbiAoZGVjaW1hbHMpIHtcblx0ICAgICAgICBpZiAoZGVjaW1hbHMgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICBkZWNpbWFscyA9IDA7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChkZWNpbWFscyA8IDAgfHwgZGVjaW1hbHMgPiA4MCB8fCAoZGVjaW1hbHMgJSAxKSkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBkZWNpbWFsIGNvdW50XCIsIFwiZGVjaW1hbHNcIiwgZGVjaW1hbHMpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBJZiB3ZSBhcmUgYWxyZWFkeSBpbiByYW5nZSwgd2UncmUgZG9uZVxuXHQgICAgICAgIHZhciBjb21wcyA9IHRoaXMudG9TdHJpbmcoKS5zcGxpdChcIi5cIik7XG5cdCAgICAgICAgaWYgKGNvbXBzWzFdLmxlbmd0aCA8PSBkZWNpbWFscykge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gQnVtcCB0aGUgdmFsdWUgdXAgYnkgdGhlIDAuMDAuLi4wMDA1XG5cdCAgICAgICAgdmFyIGJ1bXAgPSBcIjAuXCIgKyB6ZXJvcy5zdWJzdHJpbmcoMCwgZGVjaW1hbHMpICsgXCI1XCI7XG5cdCAgICAgICAgY29tcHMgPSB0aGlzLmFkZFVuc2FmZShGaXhlZE51bWJlci5mcm9tU3RyaW5nKGJ1bXAsIHRoaXMuZm9ybWF0KSkuX3ZhbHVlLnNwbGl0KFwiLlwiKTtcblx0ICAgICAgICAvLyBOb3cgaXQgaXMgc2FmZSB0byB0cnVuY2F0ZVxuXHQgICAgICAgIHJldHVybiBGaXhlZE51bWJlci5mcm9tU3RyaW5nKGNvbXBzWzBdICsgXCIuXCIgKyBjb21wc1sxXS5zdWJzdHJpbmcoMCwgZGVjaW1hbHMpKTtcblx0ICAgIH07XG5cdCAgICBGaXhlZE51bWJlci5wcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiAodGhpcy5fdmFsdWUgPT09IFwiMC4wXCIpO1xuXHQgICAgfTtcblx0ICAgIEZpeGVkTnVtYmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3ZhbHVlOyB9O1xuXHQgICAgRml4ZWROdW1iZXIucHJvdG90eXBlLnRvSGV4U3RyaW5nID0gZnVuY3Rpb24gKHdpZHRoKSB7XG5cdCAgICAgICAgaWYgKHdpZHRoID09IG51bGwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hleDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHdpZHRoICUgOCkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBieXRlIHdpZHRoXCIsIFwid2lkdGhcIiwgd2lkdGgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgaGV4ID0gYmlnbnVtYmVyLkJpZ051bWJlci5mcm9tKHRoaXMuX2hleCkuZnJvbVR3b3ModGhpcy5mb3JtYXQud2lkdGgpLnRvVHdvcyh3aWR0aCkudG9IZXhTdHJpbmcoKTtcblx0ICAgICAgICByZXR1cm4gbGliJDEuaGV4WmVyb1BhZChoZXgsIHdpZHRoIC8gOCk7XG5cdCAgICB9O1xuXHQgICAgRml4ZWROdW1iZXIucHJvdG90eXBlLnRvVW5zYWZlRmxvYXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBwYXJzZUZsb2F0KHRoaXMudG9TdHJpbmcoKSk7IH07XG5cdCAgICBGaXhlZE51bWJlci5wcm90b3R5cGUudG9Gb3JtYXQgPSBmdW5jdGlvbiAoZm9ybWF0KSB7XG5cdCAgICAgICAgcmV0dXJuIEZpeGVkTnVtYmVyLmZyb21TdHJpbmcodGhpcy5fdmFsdWUsIGZvcm1hdCk7XG5cdCAgICB9O1xuXHQgICAgRml4ZWROdW1iZXIuZnJvbVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCBkZWNpbWFscywgZm9ybWF0KSB7XG5cdCAgICAgICAgLy8gSWYgZGVjaW1hbHMgbG9va3MgbW9yZSBsaWtlIGEgZm9ybWF0LCBhbmQgdGhlcmUgaXMgbm8gZm9ybWF0LCBzaGlmdCB0aGUgcGFyYW1ldGVyc1xuXHQgICAgICAgIGlmIChmb3JtYXQgPT0gbnVsbCAmJiBkZWNpbWFscyAhPSBudWxsICYmICFiaWdudW1iZXIuaXNCaWdOdW1iZXJpc2goZGVjaW1hbHMpKSB7XG5cdCAgICAgICAgICAgIGZvcm1hdCA9IGRlY2ltYWxzO1xuXHQgICAgICAgICAgICBkZWNpbWFscyA9IG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChkZWNpbWFscyA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIGRlY2ltYWxzID0gMDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGZvcm1hdCA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIGZvcm1hdCA9IFwiZml4ZWRcIjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIEZpeGVkTnVtYmVyLmZyb21TdHJpbmcoZm9ybWF0Rml4ZWQodmFsdWUsIGRlY2ltYWxzKSwgRml4ZWRGb3JtYXQuZnJvbShmb3JtYXQpKTtcblx0ICAgIH07XG5cdCAgICBGaXhlZE51bWJlci5mcm9tU3RyaW5nID0gZnVuY3Rpb24gKHZhbHVlLCBmb3JtYXQpIHtcblx0ICAgICAgICBpZiAoZm9ybWF0ID09IG51bGwpIHtcblx0ICAgICAgICAgICAgZm9ybWF0ID0gXCJmaXhlZFwiO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgZml4ZWRGb3JtYXQgPSBGaXhlZEZvcm1hdC5mcm9tKGZvcm1hdCk7XG5cdCAgICAgICAgdmFyIG51bWVyaWMgPSBwYXJzZUZpeGVkKHZhbHVlLCBmaXhlZEZvcm1hdC5kZWNpbWFscyk7XG5cdCAgICAgICAgaWYgKCFmaXhlZEZvcm1hdC5zaWduZWQgJiYgbnVtZXJpYy5sdChaZXJvKSkge1xuXHQgICAgICAgICAgICB0aHJvd0ZhdWx0KFwidW5zaWduZWQgdmFsdWUgY2Fubm90IGJlIG5lZ2F0aXZlXCIsIFwib3ZlcmZsb3dcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBoZXggPSBudWxsO1xuXHQgICAgICAgIGlmIChmaXhlZEZvcm1hdC5zaWduZWQpIHtcblx0ICAgICAgICAgICAgaGV4ID0gbnVtZXJpYy50b1R3b3MoZml4ZWRGb3JtYXQud2lkdGgpLnRvSGV4U3RyaW5nKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICBoZXggPSBudW1lcmljLnRvSGV4U3RyaW5nKCk7XG5cdCAgICAgICAgICAgIGhleCA9IGxpYiQxLmhleFplcm9QYWQoaGV4LCBmaXhlZEZvcm1hdC53aWR0aCAvIDgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgZGVjaW1hbCA9IGZvcm1hdEZpeGVkKG51bWVyaWMsIGZpeGVkRm9ybWF0LmRlY2ltYWxzKTtcblx0ICAgICAgICByZXR1cm4gbmV3IEZpeGVkTnVtYmVyKF9jb25zdHJ1Y3Rvckd1YXJkLCBoZXgsIGRlY2ltYWwsIGZpeGVkRm9ybWF0KTtcblx0ICAgIH07XG5cdCAgICBGaXhlZE51bWJlci5mcm9tQnl0ZXMgPSBmdW5jdGlvbiAodmFsdWUsIGZvcm1hdCkge1xuXHQgICAgICAgIGlmIChmb3JtYXQgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICBmb3JtYXQgPSBcImZpeGVkXCI7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBmaXhlZEZvcm1hdCA9IEZpeGVkRm9ybWF0LmZyb20oZm9ybWF0KTtcblx0ICAgICAgICBpZiAobGliJDEuYXJyYXlpZnkodmFsdWUpLmxlbmd0aCA+IGZpeGVkRm9ybWF0LndpZHRoIC8gOCkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvdmVyZmxvd1wiKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIG51bWVyaWMgPSBiaWdudW1iZXIuQmlnTnVtYmVyLmZyb20odmFsdWUpO1xuXHQgICAgICAgIGlmIChmaXhlZEZvcm1hdC5zaWduZWQpIHtcblx0ICAgICAgICAgICAgbnVtZXJpYyA9IG51bWVyaWMuZnJvbVR3b3MoZml4ZWRGb3JtYXQud2lkdGgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgaGV4ID0gbnVtZXJpYy50b1R3b3MoKGZpeGVkRm9ybWF0LnNpZ25lZCA/IDAgOiAxKSArIGZpeGVkRm9ybWF0LndpZHRoKS50b0hleFN0cmluZygpO1xuXHQgICAgICAgIHZhciBkZWNpbWFsID0gZm9ybWF0Rml4ZWQobnVtZXJpYywgZml4ZWRGb3JtYXQuZGVjaW1hbHMpO1xuXHQgICAgICAgIHJldHVybiBuZXcgRml4ZWROdW1iZXIoX2NvbnN0cnVjdG9yR3VhcmQsIGhleCwgZGVjaW1hbCwgZml4ZWRGb3JtYXQpO1xuXHQgICAgfTtcblx0ICAgIEZpeGVkTnVtYmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGZvcm1hdCkge1xuXHQgICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgICAgICByZXR1cm4gRml4ZWROdW1iZXIuZnJvbVN0cmluZyh2YWx1ZSwgZm9ybWF0KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGxpYiQxLmlzQnl0ZXModmFsdWUpKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBGaXhlZE51bWJlci5mcm9tQnl0ZXModmFsdWUsIGZvcm1hdCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgIHJldHVybiBGaXhlZE51bWJlci5mcm9tVmFsdWUodmFsdWUsIDAsIGZvcm1hdCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgICAgICAvLyBBbGxvdyBOVU1FUklDX0ZBVUxUIHRvIGJ1YmJsZSB1cFxuXHQgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSAhPT0gbGliLkxvZ2dlci5lcnJvcnMuSU5WQUxJRF9BUkdVTUVOVCkge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIEZpeGVkTnVtYmVyIHZhbHVlXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuXHQgICAgfTtcblx0ICAgIEZpeGVkTnVtYmVyLmlzRml4ZWROdW1iZXIgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX2lzRml4ZWROdW1iZXIpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBGaXhlZE51bWJlcjtcblx0fSgpKTtcblx0ZXhwb3J0cy5GaXhlZE51bWJlciA9IEZpeGVkTnVtYmVyO1xuXG5cdH0pO1xuXG5cdHZhciBmaXhlZG51bWJlciQxID0gdW53cmFwRXhwb3J0cyhmaXhlZG51bWJlcik7XG5cdHZhciBmaXhlZG51bWJlcl8xID0gZml4ZWRudW1iZXIuZm9ybWF0Rml4ZWQ7XG5cdHZhciBmaXhlZG51bWJlcl8yID0gZml4ZWRudW1iZXIucGFyc2VGaXhlZDtcblx0dmFyIGZpeGVkbnVtYmVyXzMgPSBmaXhlZG51bWJlci5GaXhlZEZvcm1hdDtcblx0dmFyIGZpeGVkbnVtYmVyXzQgPSBmaXhlZG51bWJlci5GaXhlZE51bWJlcjtcblxuXHR2YXIgbGliJDIgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cblx0ZXhwb3J0cy5CaWdOdW1iZXIgPSBiaWdudW1iZXIuQmlnTnVtYmVyO1xuXG5cdGV4cG9ydHMuZm9ybWF0Rml4ZWQgPSBmaXhlZG51bWJlci5mb3JtYXRGaXhlZDtcblx0ZXhwb3J0cy5GaXhlZEZvcm1hdCA9IGZpeGVkbnVtYmVyLkZpeGVkRm9ybWF0O1xuXHRleHBvcnRzLkZpeGVkTnVtYmVyID0gZml4ZWRudW1iZXIuRml4ZWROdW1iZXI7XG5cdGV4cG9ydHMucGFyc2VGaXhlZCA9IGZpeGVkbnVtYmVyLnBhcnNlRml4ZWQ7XG5cblx0fSk7XG5cblx0dmFyIGluZGV4JDIgPSB1bndyYXBFeHBvcnRzKGxpYiQyKTtcblx0dmFyIGxpYl8xJDIgPSBsaWIkMi5CaWdOdW1iZXI7XG5cdHZhciBsaWJfMiQyID0gbGliJDIuZm9ybWF0Rml4ZWQ7XG5cdHZhciBsaWJfMyQyID0gbGliJDIuRml4ZWRGb3JtYXQ7XG5cdHZhciBsaWJfNCQxID0gbGliJDIuRml4ZWROdW1iZXI7XG5cdHZhciBsaWJfNSQxID0gbGliJDIucGFyc2VGaXhlZDtcblxuXHR2YXIgX3ZlcnNpb24kNiA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy52ZXJzaW9uID0gXCJwcm9wZXJ0aWVzLzUuMC4yXCI7XG5cblx0fSk7XG5cblx0dmFyIF92ZXJzaW9uJDcgPSB1bndyYXBFeHBvcnRzKF92ZXJzaW9uJDYpO1xuXHR2YXIgX3ZlcnNpb25fMSQzID0gX3ZlcnNpb24kNi52ZXJzaW9uO1xuXG5cdHZhciBsaWIkMyA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciBfX2F3YWl0ZXIgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG5cdCAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cblx0ICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cblx0ICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cblx0ICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuXHQgICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcblx0ICAgIH0pO1xuXHR9O1xuXHR2YXIgX19nZW5lcmF0b3IgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG5cdCAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuXHQgICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG5cdCAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cblx0ICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcblx0ICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG5cdCAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG5cdCAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcblx0ICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuXHQgICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcblx0ICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG5cdCAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG5cdCAgICAgICAgICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcblx0ICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuXHQgICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cblx0ICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcblx0ICAgIH1cblx0fTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5cblx0dmFyIGxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJDYudmVyc2lvbik7XG5cdGZ1bmN0aW9uIGRlZmluZVJlYWRPbmx5KG9iamVjdCwgbmFtZSwgdmFsdWUpIHtcblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIG5hbWUsIHtcblx0ICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXHQgICAgICAgIHZhbHVlOiB2YWx1ZSxcblx0ICAgICAgICB3cml0YWJsZTogZmFsc2UsXG5cdCAgICB9KTtcblx0fVxuXHRleHBvcnRzLmRlZmluZVJlYWRPbmx5ID0gZGVmaW5lUmVhZE9ubHk7XG5cdC8vIENyYXdsIHVwIHRoZSBjb25zdHJ1Y3RvciBjaGFpbiB0byBmaW5kIGEgc3RhdGljIG1ldGhvZFxuXHRmdW5jdGlvbiBnZXRTdGF0aWMoY3Rvciwga2V5KSB7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IDMyOyBpKyspIHtcblx0ICAgICAgICBpZiAoY3RvcltrZXldKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBjdG9yW2tleV07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICghY3Rvci5wcm90b3R5cGUgfHwgdHlwZW9mIChjdG9yLnByb3RvdHlwZSkgIT09IFwib2JqZWN0XCIpIHtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGN0b3IgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY3Rvci5wcm90b3R5cGUpLmNvbnN0cnVjdG9yO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIG51bGw7XG5cdH1cblx0ZXhwb3J0cy5nZXRTdGF0aWMgPSBnZXRTdGF0aWM7XG5cdGZ1bmN0aW9uIHJlc29sdmVQcm9wZXJ0aWVzKG9iamVjdCkge1xuXHQgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBwcm9taXNlcywgcmVzdWx0cztcblx0ICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMDpcblx0ICAgICAgICAgICAgICAgICAgICBwcm9taXNlcyA9IE9iamVjdC5rZXlzKG9iamVjdCkubWFwKGZ1bmN0aW9uIChrZXkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gb2JqZWN0W2tleV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24gKHYpIHsgcmV0dXJuICh7IGtleToga2V5LCB2YWx1ZTogdiB9KTsgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgUHJvbWlzZS5hbGwocHJvbWlzZXMpXTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICByZXN1bHRzID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCByZXN1bHRzLnJlZHVjZShmdW5jdGlvbiAoYWNjdW0sIHJlc3VsdCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjdW1bKHJlc3VsdC5rZXkpXSA9IHJlc3VsdC52YWx1ZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhY2N1bTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSwge30pXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgfSk7XG5cdH1cblx0ZXhwb3J0cy5yZXNvbHZlUHJvcGVydGllcyA9IHJlc29sdmVQcm9wZXJ0aWVzO1xuXHRmdW5jdGlvbiBjaGVja1Byb3BlcnRpZXMob2JqZWN0LCBwcm9wZXJ0aWVzKSB7XG5cdCAgICBpZiAoIW9iamVjdCB8fCB0eXBlb2YgKG9iamVjdCkgIT09IFwib2JqZWN0XCIpIHtcblx0ICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBvYmplY3RcIiwgXCJvYmplY3RcIiwgb2JqZWN0KTtcblx0ICAgIH1cblx0ICAgIE9iamVjdC5rZXlzKG9iamVjdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdCAgICAgICAgaWYgKCFwcm9wZXJ0aWVzW2tleV0pIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgb2JqZWN0IGtleSAtIFwiICsga2V5LCBcInRyYW5zYWN0aW9uOlwiICsga2V5LCBvYmplY3QpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHR9XG5cdGV4cG9ydHMuY2hlY2tQcm9wZXJ0aWVzID0gY2hlY2tQcm9wZXJ0aWVzO1xuXHRmdW5jdGlvbiBzaGFsbG93Q29weShvYmplY3QpIHtcblx0ICAgIHZhciByZXN1bHQgPSB7fTtcblx0ICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcblx0ICAgICAgICByZXN1bHRba2V5XSA9IG9iamVjdFtrZXldO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0fVxuXHRleHBvcnRzLnNoYWxsb3dDb3B5ID0gc2hhbGxvd0NvcHk7XG5cdHZhciBvcGFxdWUgPSB7IGJpZ2ludDogdHJ1ZSwgYm9vbGVhbjogdHJ1ZSwgXCJmdW5jdGlvblwiOiB0cnVlLCBudW1iZXI6IHRydWUsIHN0cmluZzogdHJ1ZSB9O1xuXHRmdW5jdGlvbiBfaXNGcm96ZW4ob2JqZWN0KSB7XG5cdCAgICAvLyBPcGFxdWUgb2JqZWN0cyBhcmUgbm90IG11dGFibGUsIHNvIHNhZmUgdG8gY29weSBieSBhc3NpZ25tZW50XG5cdCAgICBpZiAob2JqZWN0ID09PSB1bmRlZmluZWQgfHwgb2JqZWN0ID09PSBudWxsIHx8IG9wYXF1ZVt0eXBlb2YgKG9iamVjdCldKSB7XG5cdCAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9XG5cdCAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpIHx8IHR5cGVvZiAob2JqZWN0KSA9PT0gXCJvYmplY3RcIikge1xuXHQgICAgICAgIGlmICghT2JqZWN0LmlzRnJvemVuKG9iamVjdCkpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIGlmICghX2lzRnJvemVuKG9iamVjdFtrZXlzW2ldXSkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiQ2Fubm90IGRlZXBDb3B5IFwiICsgdHlwZW9mIChvYmplY3QpLCBcIm9iamVjdFwiLCBvYmplY3QpO1xuXHR9XG5cdC8vIFJldHVybnMgYSBuZXcgY29weSBvZiBvYmplY3QsIHN1Y2ggdGhhdCBubyBwcm9wZXJ0aWVzIG1heSBiZSByZXBsYWNlZC5cblx0Ly8gTmV3IHByb3BlcnRpZXMgbWF5IGJlIGFkZGVkIG9ubHkgdG8gb2JqZWN0cy5cblx0ZnVuY3Rpb24gX2RlZXBDb3B5KG9iamVjdCkge1xuXHQgICAgaWYgKF9pc0Zyb3plbihvYmplY3QpKSB7XG5cdCAgICAgICAgcmV0dXJuIG9iamVjdDtcblx0ICAgIH1cblx0ICAgIC8vIEFycmF5cyBhcmUgbXV0YWJsZSwgc28gd2UgbmVlZCB0byBjcmVhdGUgYSBjb3B5XG5cdCAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG5cdCAgICAgICAgcmV0dXJuIE9iamVjdC5mcmVlemUob2JqZWN0Lm1hcChmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gZGVlcENvcHkoaXRlbSk7IH0pKTtcblx0ICAgIH1cblx0ICAgIGlmICh0eXBlb2YgKG9iamVjdCkgPT09IFwib2JqZWN0XCIpIHtcblx0ICAgICAgICB2YXIgcmVzdWx0ID0ge307XG5cdCAgICAgICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuXHQgICAgICAgICAgICB2YXIgdmFsdWUgPSBvYmplY3Rba2V5XTtcblx0ICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHJlc3VsdCwga2V5LCBkZWVwQ29weSh2YWx1ZSkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJDYW5ub3QgZGVlcENvcHkgXCIgKyB0eXBlb2YgKG9iamVjdCksIFwib2JqZWN0XCIsIG9iamVjdCk7XG5cdH1cblx0ZnVuY3Rpb24gZGVlcENvcHkob2JqZWN0KSB7XG5cdCAgICByZXR1cm4gX2RlZXBDb3B5KG9iamVjdCk7XG5cdH1cblx0ZXhwb3J0cy5kZWVwQ29weSA9IGRlZXBDb3B5O1xuXHR2YXIgRGVzY3JpcHRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBEZXNjcmlwdGlvbihpbmZvKSB7XG5cdCAgICAgICAgZm9yICh2YXIga2V5IGluIGluZm8pIHtcblx0ICAgICAgICAgICAgdGhpc1trZXldID0gZGVlcENvcHkoaW5mb1trZXldKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gRGVzY3JpcHRpb247XG5cdH0oKSk7XG5cdGV4cG9ydHMuRGVzY3JpcHRpb24gPSBEZXNjcmlwdGlvbjtcblxuXHR9KTtcblxuXHR2YXIgaW5kZXgkMyA9IHVud3JhcEV4cG9ydHMobGliJDMpO1xuXHR2YXIgbGliXzEkMyA9IGxpYiQzLmRlZmluZVJlYWRPbmx5O1xuXHR2YXIgbGliXzIkMyA9IGxpYiQzLmdldFN0YXRpYztcblx0dmFyIGxpYl8zJDMgPSBsaWIkMy5yZXNvbHZlUHJvcGVydGllcztcblx0dmFyIGxpYl80JDIgPSBsaWIkMy5jaGVja1Byb3BlcnRpZXM7XG5cdHZhciBsaWJfNSQyID0gbGliJDMuc2hhbGxvd0NvcHk7XG5cdHZhciBsaWJfNiQxID0gbGliJDMuZGVlcENvcHk7XG5cdHZhciBsaWJfNyQxID0gbGliJDMuRGVzY3JpcHRpb247XG5cblx0dmFyIF92ZXJzaW9uJDggPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMudmVyc2lvbiA9IFwiYWJpLzUuMC4yXCI7XG5cblx0fSk7XG5cblx0dmFyIF92ZXJzaW9uJDkgPSB1bndyYXBFeHBvcnRzKF92ZXJzaW9uJDgpO1xuXHR2YXIgX3ZlcnNpb25fMSQ0ID0gX3ZlcnNpb24kOC52ZXJzaW9uO1xuXG5cdHZhciBmcmFnbWVudHMgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19leHRlbmRzID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG5cdCAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcblx0ICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG5cdCAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cblx0ICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG5cdCAgICB9O1xuXHR9KSgpO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cblxuXG5cblx0dmFyIGxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJDgudmVyc2lvbik7XG5cdDtcblx0dmFyIF9jb25zdHJ1Y3Rvckd1YXJkID0ge307XG5cdHZhciBNb2RpZmllcnNCeXRlcyA9IHsgY2FsbGRhdGE6IHRydWUsIG1lbW9yeTogdHJ1ZSwgc3RvcmFnZTogdHJ1ZSB9O1xuXHR2YXIgTW9kaWZpZXJzTmVzdCA9IHsgY2FsbGRhdGE6IHRydWUsIG1lbW9yeTogdHJ1ZSB9O1xuXHRmdW5jdGlvbiBjaGVja01vZGlmaWVyKHR5cGUsIG5hbWUpIHtcblx0ICAgIGlmICh0eXBlID09PSBcImJ5dGVzXCIgfHwgdHlwZSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgIGlmIChNb2RpZmllcnNCeXRlc1tuYW1lXSkge1xuXHQgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBlbHNlIGlmICh0eXBlID09PSBcImFkZHJlc3NcIikge1xuXHQgICAgICAgIGlmIChuYW1lID09PSBcInBheWFibGVcIikge1xuXHQgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBlbHNlIGlmICh0eXBlLmluZGV4T2YoXCJbXCIpID49IDAgfHwgdHlwZSA9PT0gXCJ0dXBsZVwiKSB7XG5cdCAgICAgICAgaWYgKE1vZGlmaWVyc05lc3RbbmFtZV0pIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgaWYgKE1vZGlmaWVyc0J5dGVzW25hbWVdIHx8IG5hbWUgPT09IFwicGF5YWJsZVwiKSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgbW9kaWZpZXJcIiwgXCJuYW1lXCIsIG5hbWUpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHR9XG5cdC8vIEBUT0RPOiBNYWtlIHN1cmUgdGhhdCBjaGlsZHJlbiBvZiBhbiBpbmRleGVkIHR1cGxlIGFyZSBtYXJrZWQgd2l0aCBhIG51bGwgaW5kZXhlZFxuXHRmdW5jdGlvbiBwYXJzZVBhcmFtVHlwZShwYXJhbSwgYWxsb3dJbmRleGVkKSB7XG5cdCAgICB2YXIgb3JpZ2luYWxQYXJhbSA9IHBhcmFtO1xuXHQgICAgZnVuY3Rpb24gdGhyb3dFcnJvcihpKSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IHBvc2l0aW9uIFwiICsgaSwgXCJwYXJhbVwiLCBwYXJhbSk7XG5cdCAgICB9XG5cdCAgICBwYXJhbSA9IHBhcmFtLnJlcGxhY2UoL1xccy9nLCBcIiBcIik7XG5cdCAgICBmdW5jdGlvbiBuZXdOb2RlKHBhcmVudCkge1xuXHQgICAgICAgIHZhciBub2RlID0geyB0eXBlOiBcIlwiLCBuYW1lOiBcIlwiLCBwYXJlbnQ6IHBhcmVudCwgc3RhdGU6IHsgYWxsb3dUeXBlOiB0cnVlIH0gfTtcblx0ICAgICAgICBpZiAoYWxsb3dJbmRleGVkKSB7XG5cdCAgICAgICAgICAgIG5vZGUuaW5kZXhlZCA9IGZhbHNlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gbm9kZTtcblx0ICAgIH1cblx0ICAgIHZhciBwYXJlbnQgPSB7IHR5cGU6IFwiXCIsIG5hbWU6IFwiXCIsIHN0YXRlOiB7IGFsbG93VHlwZTogdHJ1ZSB9IH07XG5cdCAgICB2YXIgbm9kZSA9IHBhcmVudDtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW0ubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICB2YXIgYyA9IHBhcmFtW2ldO1xuXHQgICAgICAgIHN3aXRjaCAoYykge1xuXHQgICAgICAgICAgICBjYXNlIFwiKFwiOlxuXHQgICAgICAgICAgICAgICAgaWYgKG5vZGUuc3RhdGUuYWxsb3dUeXBlICYmIG5vZGUudHlwZSA9PT0gXCJcIikge1xuXHQgICAgICAgICAgICAgICAgICAgIG5vZGUudHlwZSA9IFwidHVwbGVcIjtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFub2RlLnN0YXRlLmFsbG93UGFyYW1zKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihpKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIG5vZGUuc3RhdGUuYWxsb3dUeXBlID0gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICBub2RlLnR5cGUgPSB2ZXJpZnlUeXBlKG5vZGUudHlwZSk7XG5cdCAgICAgICAgICAgICAgICBub2RlLmNvbXBvbmVudHMgPSBbbmV3Tm9kZShub2RlKV07XG5cdCAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5jb21wb25lbnRzWzBdO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgXCIpXCI6XG5cdCAgICAgICAgICAgICAgICBkZWxldGUgbm9kZS5zdGF0ZTtcblx0ICAgICAgICAgICAgICAgIGlmIChub2RlLm5hbWUgPT09IFwiaW5kZXhlZFwiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFhbGxvd0luZGV4ZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihpKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgbm9kZS5pbmRleGVkID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICBub2RlLm5hbWUgPSBcIlwiO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgaWYgKGNoZWNrTW9kaWZpZXIobm9kZS50eXBlLCBub2RlLm5hbWUpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgbm9kZS5uYW1lID0gXCJcIjtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIG5vZGUudHlwZSA9IHZlcmlmeVR5cGUobm9kZS50eXBlKTtcblx0ICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IG5vZGU7XG5cdCAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG5cdCAgICAgICAgICAgICAgICBpZiAoIW5vZGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGkpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZGVsZXRlIGNoaWxkLnBhcmVudDtcblx0ICAgICAgICAgICAgICAgIG5vZGUuc3RhdGUuYWxsb3dQYXJhbXMgPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAgIG5vZGUuc3RhdGUuYWxsb3dOYW1lID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgIG5vZGUuc3RhdGUuYWxsb3dBcnJheSA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSBcIixcIjpcblx0ICAgICAgICAgICAgICAgIGRlbGV0ZSBub2RlLnN0YXRlO1xuXHQgICAgICAgICAgICAgICAgaWYgKG5vZGUubmFtZSA9PT0gXCJpbmRleGVkXCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIWFsbG93SW5kZXhlZCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGkpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBub2RlLmluZGV4ZWQgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgIG5vZGUubmFtZSA9IFwiXCI7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBpZiAoY2hlY2tNb2RpZmllcihub2RlLnR5cGUsIG5vZGUubmFtZSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICBub2RlLm5hbWUgPSBcIlwiO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgbm9kZS50eXBlID0gdmVyaWZ5VHlwZShub2RlLnR5cGUpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHNpYmxpbmcgPSBuZXdOb2RlKG5vZGUucGFyZW50KTtcblx0ICAgICAgICAgICAgICAgIC8veyB0eXBlOiBcIlwiLCBuYW1lOiBcIlwiLCBwYXJlbnQ6IG5vZGUucGFyZW50LCBzdGF0ZTogeyBhbGxvd1R5cGU6IHRydWUgfSB9O1xuXHQgICAgICAgICAgICAgICAgbm9kZS5wYXJlbnQuY29tcG9uZW50cy5wdXNoKHNpYmxpbmcpO1xuXHQgICAgICAgICAgICAgICAgZGVsZXRlIG5vZGUucGFyZW50O1xuXHQgICAgICAgICAgICAgICAgbm9kZSA9IHNpYmxpbmc7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgLy8gSGl0IGEgc3BhY2UuLi5cblx0ICAgICAgICAgICAgY2FzZSBcIiBcIjpcblx0ICAgICAgICAgICAgICAgIC8vIElmIHJlYWRpbmcgdHlwZSwgdGhlIHR5cGUgaXMgZG9uZSBhbmQgbWF5IHJlYWQgYSBwYXJhbSBvciBuYW1lXG5cdCAgICAgICAgICAgICAgICBpZiAobm9kZS5zdGF0ZS5hbGxvd1R5cGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS50eXBlICE9PSBcIlwiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUudHlwZSA9IHZlcmlmeVR5cGUobm9kZS50eXBlKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG5vZGUuc3RhdGUuYWxsb3dUeXBlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnN0YXRlLmFsbG93TmFtZSA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc3RhdGUuYWxsb3dQYXJhbXMgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIC8vIElmIHJlYWRpbmcgbmFtZSwgdGhlIG5hbWUgaXMgZG9uZVxuXHQgICAgICAgICAgICAgICAgaWYgKG5vZGUuc3RhdGUuYWxsb3dOYW1lKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubmFtZSAhPT0gXCJcIikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5uYW1lID09PSBcImluZGV4ZWRcIikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhbGxvd0luZGV4ZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuaW5kZXhlZCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoaSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmluZGV4ZWQgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5uYW1lID0gXCJcIjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGVja01vZGlmaWVyKG5vZGUudHlwZSwgbm9kZS5uYW1lKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5uYW1lID0gXCJcIjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc3RhdGUuYWxsb3dOYW1lID0gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSBcIltcIjpcblx0ICAgICAgICAgICAgICAgIGlmICghbm9kZS5zdGF0ZS5hbGxvd0FycmF5KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihpKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIG5vZGUudHlwZSArPSBjO1xuXHQgICAgICAgICAgICAgICAgbm9kZS5zdGF0ZS5hbGxvd0FycmF5ID0gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICBub2RlLnN0YXRlLmFsbG93TmFtZSA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgbm9kZS5zdGF0ZS5yZWFkQXJyYXkgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgXCJdXCI6XG5cdCAgICAgICAgICAgICAgICBpZiAoIW5vZGUuc3RhdGUucmVhZEFycmF5KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihpKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIG5vZGUudHlwZSArPSBjO1xuXHQgICAgICAgICAgICAgICAgbm9kZS5zdGF0ZS5yZWFkQXJyYXkgPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAgIG5vZGUuc3RhdGUuYWxsb3dBcnJheSA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICBub2RlLnN0YXRlLmFsbG93TmFtZSA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgIGlmIChub2RlLnN0YXRlLmFsbG93VHlwZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIG5vZGUudHlwZSArPSBjO1xuXHQgICAgICAgICAgICAgICAgICAgIG5vZGUuc3RhdGUuYWxsb3dQYXJhbXMgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgIG5vZGUuc3RhdGUuYWxsb3dBcnJheSA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmIChub2RlLnN0YXRlLmFsbG93TmFtZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIG5vZGUubmFtZSArPSBjO1xuXHQgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBub2RlLnN0YXRlLmFsbG93QXJyYXk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmIChub2RlLnN0YXRlLnJlYWRBcnJheSkge1xuXHQgICAgICAgICAgICAgICAgICAgIG5vZGUudHlwZSArPSBjO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihpKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBpZiAobm9kZS5wYXJlbnQpIHtcblx0ICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidW5leHBlY3RlZCBlb2ZcIiwgXCJwYXJhbVwiLCBwYXJhbSk7XG5cdCAgICB9XG5cdCAgICBkZWxldGUgcGFyZW50LnN0YXRlO1xuXHQgICAgaWYgKG5vZGUubmFtZSA9PT0gXCJpbmRleGVkXCIpIHtcblx0ICAgICAgICBpZiAoIWFsbG93SW5kZXhlZCkge1xuXHQgICAgICAgICAgICB0aHJvd0Vycm9yKG9yaWdpbmFsUGFyYW0ubGVuZ3RoIC0gNyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChub2RlLmluZGV4ZWQpIHtcblx0ICAgICAgICAgICAgdGhyb3dFcnJvcihvcmlnaW5hbFBhcmFtLmxlbmd0aCAtIDcpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBub2RlLmluZGV4ZWQgPSB0cnVlO1xuXHQgICAgICAgIG5vZGUubmFtZSA9IFwiXCI7XG5cdCAgICB9XG5cdCAgICBlbHNlIGlmIChjaGVja01vZGlmaWVyKG5vZGUudHlwZSwgbm9kZS5uYW1lKSkge1xuXHQgICAgICAgIG5vZGUubmFtZSA9IFwiXCI7XG5cdCAgICB9XG5cdCAgICBwYXJlbnQudHlwZSA9IHZlcmlmeVR5cGUocGFyZW50LnR5cGUpO1xuXHQgICAgcmV0dXJuIHBhcmVudDtcblx0fVxuXHRmdW5jdGlvbiBwb3B1bGF0ZShvYmplY3QsIHBhcmFtcykge1xuXHQgICAgZm9yICh2YXIga2V5IGluIHBhcmFtcykge1xuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KG9iamVjdCwga2V5LCBwYXJhbXNba2V5XSk7XG5cdCAgICB9XG5cdH1cblx0ZXhwb3J0cy5Gb3JtYXRUeXBlcyA9IE9iamVjdC5mcmVlemUoe1xuXHQgICAgLy8gQmFyZSBmb3JtYXR0aW5nLCBhcyBpcyBuZWVkZWQgZm9yIGNvbXB1dGluZyBhIHNpZ2hhc2ggb2YgYW4gZXZlbnQgb3IgZnVuY3Rpb25cblx0ICAgIHNpZ2hhc2g6IFwic2lnaGFzaFwiLFxuXHQgICAgLy8gSHVtYW4tUmVhZGFibGUgd2l0aCBNaW5pbWFsIHNwYWNpbmcgYW5kIHdpdGhvdXQgbmFtZXMgKGNvbXBhY3QgaHVtYW4tcmVhZGFibGUpXG5cdCAgICBtaW5pbWFsOiBcIm1pbmltYWxcIixcblx0ICAgIC8vIEh1bWFuLVJlYWRibGUgd2l0aCBuaWNlIHNwYWNpbmcsIGluY2x1ZGluZyBhbGwgbmFtZXNcblx0ICAgIGZ1bGw6IFwiZnVsbFwiLFxuXHQgICAgLy8gSlNPTi1mb3JtYXQgYSBsYSBTb2xpZGl0eVxuXHQgICAganNvbjogXCJqc29uXCJcblx0fSk7XG5cdHZhciBwYXJhbVR5cGVBcnJheSA9IG5ldyBSZWdFeHAoL14oLiopXFxbKFswLTldKilcXF0kLyk7XG5cdHZhciBQYXJhbVR5cGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBQYXJhbVR5cGUoY29uc3RydWN0b3JHdWFyZCwgcGFyYW1zKSB7XG5cdCAgICAgICAgaWYgKGNvbnN0cnVjdG9yR3VhcmQgIT09IF9jb25zdHJ1Y3Rvckd1YXJkKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidXNlIGZyb21TdHJpbmdcIiwgbGliLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG5cdCAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwibmV3IFBhcmFtVHlwZSgpXCJcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHBvcHVsYXRlKHRoaXMsIHBhcmFtcyk7XG5cdCAgICAgICAgdmFyIG1hdGNoID0gdGhpcy50eXBlLm1hdGNoKHBhcmFtVHlwZUFycmF5KTtcblx0ICAgICAgICBpZiAobWF0Y2gpIHtcblx0ICAgICAgICAgICAgcG9wdWxhdGUodGhpcywge1xuXHQgICAgICAgICAgICAgICAgYXJyYXlMZW5ndGg6IHBhcnNlSW50KG1hdGNoWzJdIHx8IFwiLTFcIiksXG5cdCAgICAgICAgICAgICAgICBhcnJheUNoaWxkcmVuOiBQYXJhbVR5cGUuZnJvbU9iamVjdCh7XG5cdCAgICAgICAgICAgICAgICAgICAgdHlwZTogbWF0Y2hbMV0sXG5cdCAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50czogdGhpcy5jb21wb25lbnRzXG5cdCAgICAgICAgICAgICAgICB9KSxcblx0ICAgICAgICAgICAgICAgIGJhc2VUeXBlOiBcImFycmF5XCJcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICBwb3B1bGF0ZSh0aGlzLCB7XG5cdCAgICAgICAgICAgICAgICBhcnJheUxlbmd0aDogbnVsbCxcblx0ICAgICAgICAgICAgICAgIGFycmF5Q2hpbGRyZW46IG51bGwsXG5cdCAgICAgICAgICAgICAgICBiYXNlVHlwZTogKCh0aGlzLmNvbXBvbmVudHMgIT0gbnVsbCkgPyBcInR1cGxlXCIgOiB0aGlzLnR5cGUpXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9pc1BhcmFtVHlwZSA9IHRydWU7XG5cdCAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcblx0ICAgIH1cblx0ICAgIC8vIEZvcm1hdCB0aGUgcGFyYW1ldGVyIGZyYWdtZW50XG5cdCAgICAvLyAgIC0gc2lnaGFzaDogXCIodWludDI1NixhZGRyZXNzKVwiXG5cdCAgICAvLyAgIC0gbWluaW1hbDogXCJ0dXBsZSh1aW50MjU2LGFkZHJlc3MpIGluZGV4ZWRcIlxuXHQgICAgLy8gICAtIGZ1bGw6ICAgIFwidHVwbGUodWludDI1NiBmb28sIGFkZHJlcyBiYXIpIGluZGV4ZWQgYmF6XCJcblx0ICAgIFBhcmFtVHlwZS5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuXHQgICAgICAgIGlmICghZm9ybWF0KSB7XG5cdCAgICAgICAgICAgIGZvcm1hdCA9IGV4cG9ydHMuRm9ybWF0VHlwZXMuc2lnaGFzaDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKCFleHBvcnRzLkZvcm1hdFR5cGVzW2Zvcm1hdF0pIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZm9ybWF0IHR5cGVcIiwgXCJmb3JtYXRcIiwgZm9ybWF0KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGZvcm1hdCA9PT0gZXhwb3J0cy5Gb3JtYXRUeXBlcy5qc29uKSB7XG5cdCAgICAgICAgICAgIHZhciByZXN1bHRfMSA9IHtcblx0ICAgICAgICAgICAgICAgIHR5cGU6ICgodGhpcy5iYXNlVHlwZSA9PT0gXCJ0dXBsZVwiKSA/IFwidHVwbGVcIiA6IHRoaXMudHlwZSksXG5cdCAgICAgICAgICAgICAgICBuYW1lOiAodGhpcy5uYW1lIHx8IHVuZGVmaW5lZClcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiAodGhpcy5pbmRleGVkKSA9PT0gXCJib29sZWFuXCIpIHtcblx0ICAgICAgICAgICAgICAgIHJlc3VsdF8xLmluZGV4ZWQgPSB0aGlzLmluZGV4ZWQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50cykge1xuXHQgICAgICAgICAgICAgICAgcmVzdWx0XzEuY29tcG9uZW50cyA9IHRoaXMuY29tcG9uZW50cy5tYXAoZnVuY3Rpb24gKGNvbXApIHsgcmV0dXJuIEpTT04ucGFyc2UoY29tcC5mb3JtYXQoZm9ybWF0KSk7IH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShyZXN1bHRfMSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciByZXN1bHQgPSBcIlwiO1xuXHQgICAgICAgIC8vIEFycmF5XG5cdCAgICAgICAgaWYgKHRoaXMuYmFzZVR5cGUgPT09IFwiYXJyYXlcIikge1xuXHQgICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5hcnJheUNoaWxkcmVuLmZvcm1hdChmb3JtYXQpO1xuXHQgICAgICAgICAgICByZXN1bHQgKz0gXCJbXCIgKyAodGhpcy5hcnJheUxlbmd0aCA8IDAgPyBcIlwiIDogU3RyaW5nKHRoaXMuYXJyYXlMZW5ndGgpKSArIFwiXVwiO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuYmFzZVR5cGUgPT09IFwidHVwbGVcIikge1xuXHQgICAgICAgICAgICAgICAgaWYgKGZvcm1hdCAhPT0gZXhwb3J0cy5Gb3JtYXRUeXBlcy5zaWdoYXNoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMudHlwZTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIihcIiArIHRoaXMuY29tcG9uZW50cy5tYXAoZnVuY3Rpb24gKGNvbXApIHsgcmV0dXJuIGNvbXAuZm9ybWF0KGZvcm1hdCk7IH0pLmpvaW4oKGZvcm1hdCA9PT0gZXhwb3J0cy5Gb3JtYXRUeXBlcy5mdWxsKSA/IFwiLCBcIiA6IFwiLFwiKSArIFwiKVwiO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMudHlwZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoZm9ybWF0ICE9PSBleHBvcnRzLkZvcm1hdFR5cGVzLnNpZ2hhc2gpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuaW5kZXhlZCA9PT0gdHJ1ZSkge1xuXHQgICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiIGluZGV4ZWRcIjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAoZm9ybWF0ID09PSBleHBvcnRzLkZvcm1hdFR5cGVzLmZ1bGwgJiYgdGhpcy5uYW1lKSB7XG5cdCAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCIgXCIgKyB0aGlzLm5hbWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgIH07XG5cdCAgICBQYXJhbVR5cGUuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgYWxsb3dJbmRleGVkKSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBQYXJhbVR5cGUuZnJvbVN0cmluZyh2YWx1ZSwgYWxsb3dJbmRleGVkKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIFBhcmFtVHlwZS5mcm9tT2JqZWN0KHZhbHVlKTtcblx0ICAgIH07XG5cdCAgICBQYXJhbVR5cGUuZnJvbU9iamVjdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIGlmIChQYXJhbVR5cGUuaXNQYXJhbVR5cGUodmFsdWUpKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIG5ldyBQYXJhbVR5cGUoX2NvbnN0cnVjdG9yR3VhcmQsIHtcblx0ICAgICAgICAgICAgbmFtZTogKHZhbHVlLm5hbWUgfHwgbnVsbCksXG5cdCAgICAgICAgICAgIHR5cGU6IHZlcmlmeVR5cGUodmFsdWUudHlwZSksXG5cdCAgICAgICAgICAgIGluZGV4ZWQ6ICgodmFsdWUuaW5kZXhlZCA9PSBudWxsKSA/IG51bGwgOiAhIXZhbHVlLmluZGV4ZWQpLFxuXHQgICAgICAgICAgICBjb21wb25lbnRzOiAodmFsdWUuY29tcG9uZW50cyA/IHZhbHVlLmNvbXBvbmVudHMubWFwKFBhcmFtVHlwZS5mcm9tT2JqZWN0KSA6IG51bGwpXG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgUGFyYW1UeXBlLmZyb21TdHJpbmcgPSBmdW5jdGlvbiAodmFsdWUsIGFsbG93SW5kZXhlZCkge1xuXHQgICAgICAgIGZ1bmN0aW9uIFBhcmFtVHlwaWZ5KG5vZGUpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIFBhcmFtVHlwZS5mcm9tT2JqZWN0KHtcblx0ICAgICAgICAgICAgICAgIG5hbWU6IG5vZGUubmFtZSxcblx0ICAgICAgICAgICAgICAgIHR5cGU6IG5vZGUudHlwZSxcblx0ICAgICAgICAgICAgICAgIGluZGV4ZWQ6IG5vZGUuaW5kZXhlZCxcblx0ICAgICAgICAgICAgICAgIGNvbXBvbmVudHM6IG5vZGUuY29tcG9uZW50c1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIFBhcmFtVHlwaWZ5KHBhcnNlUGFyYW1UeXBlKHZhbHVlLCAhIWFsbG93SW5kZXhlZCkpO1xuXHQgICAgfTtcblx0ICAgIFBhcmFtVHlwZS5pc1BhcmFtVHlwZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiAhISh2YWx1ZSAhPSBudWxsICYmIHZhbHVlLl9pc1BhcmFtVHlwZSk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFBhcmFtVHlwZTtcblx0fSgpKTtcblx0ZXhwb3J0cy5QYXJhbVR5cGUgPSBQYXJhbVR5cGU7XG5cdDtcblx0ZnVuY3Rpb24gcGFyc2VQYXJhbXModmFsdWUsIGFsbG93SW5kZXgpIHtcblx0ICAgIHJldHVybiBzcGxpdE5lc3RpbmcodmFsdWUpLm1hcChmdW5jdGlvbiAocGFyYW0pIHsgcmV0dXJuIFBhcmFtVHlwZS5mcm9tU3RyaW5nKHBhcmFtLCBhbGxvd0luZGV4KTsgfSk7XG5cdH1cblx0dmFyIEZyYWdtZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gRnJhZ21lbnQoY29uc3RydWN0b3JHdWFyZCwgcGFyYW1zKSB7XG5cdCAgICAgICAgaWYgKGNvbnN0cnVjdG9yR3VhcmQgIT09IF9jb25zdHJ1Y3Rvckd1YXJkKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidXNlIGEgc3RhdGljIGZyb20gbWV0aG9kXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuXHQgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcIm5ldyBGcmFnbWVudCgpXCJcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHBvcHVsYXRlKHRoaXMsIHBhcmFtcyk7XG5cdCAgICAgICAgdGhpcy5faXNGcmFnbWVudCA9IHRydWU7XG5cdCAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcblx0ICAgIH1cblx0ICAgIEZyYWdtZW50LmZyb20gPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICBpZiAoRnJhZ21lbnQuaXNGcmFnbWVudCh2YWx1ZSkpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIEZyYWdtZW50LmZyb21TdHJpbmcodmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gRnJhZ21lbnQuZnJvbU9iamVjdCh2YWx1ZSk7XG5cdCAgICB9O1xuXHQgICAgRnJhZ21lbnQuZnJvbU9iamVjdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIGlmIChGcmFnbWVudC5pc0ZyYWdtZW50KHZhbHVlKSkge1xuXHQgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHN3aXRjaCAodmFsdWUudHlwZSkge1xuXHQgICAgICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcblx0ICAgICAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbkZyYWdtZW50LmZyb21PYmplY3QodmFsdWUpO1xuXHQgICAgICAgICAgICBjYXNlIFwiZXZlbnRcIjpcblx0ICAgICAgICAgICAgICAgIHJldHVybiBFdmVudEZyYWdtZW50LmZyb21PYmplY3QodmFsdWUpO1xuXHQgICAgICAgICAgICBjYXNlIFwiY29uc3RydWN0b3JcIjpcblx0ICAgICAgICAgICAgICAgIHJldHVybiBDb25zdHJ1Y3RvckZyYWdtZW50LmZyb21PYmplY3QodmFsdWUpO1xuXHQgICAgICAgICAgICBjYXNlIFwiZmFsbGJhY2tcIjpcblx0ICAgICAgICAgICAgY2FzZSBcInJlY2VpdmVcIjpcblx0ICAgICAgICAgICAgICAgIC8vIEBUT0RPOiBTb21ldGhpbmc/IE1heWJlIHJldHVybiBhIEZ1bmN0aW9uRnJhZ21lbnQ/IEEgY3VzdG9tIERlZmF1bHRGdW5jdGlvbkZyYWdtZW50P1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBmcmFnbWVudCBvYmplY3RcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG5cdCAgICB9O1xuXHQgICAgRnJhZ21lbnQuZnJvbVN0cmluZyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgXCJyZXR1cm5zXCIgaXMgc3Vycm91bmRlZCBieSBhIHNwYWNlIGFuZCBhbGwgd2hpdGVzcGFjZSBpcyBleGFjdGx5IG9uZSBzcGFjZVxuXHQgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxzL2csIFwiIFwiKTtcblx0ICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcKC9nLCBcIiAoXCIpLnJlcGxhY2UoL1xcKS9nLCBcIikgXCIpLnJlcGxhY2UoL1xccysvZywgXCIgXCIpO1xuXHQgICAgICAgIHZhbHVlID0gdmFsdWUudHJpbSgpO1xuXHQgICAgICAgIGlmICh2YWx1ZS5zcGxpdChcIiBcIilbMF0gPT09IFwiZXZlbnRcIikge1xuXHQgICAgICAgICAgICByZXR1cm4gRXZlbnRGcmFnbWVudC5mcm9tU3RyaW5nKHZhbHVlLnN1YnN0cmluZyg1KS50cmltKCkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIGlmICh2YWx1ZS5zcGxpdChcIiBcIilbMF0gPT09IFwiZnVuY3Rpb25cIikge1xuXHQgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb25GcmFnbWVudC5mcm9tU3RyaW5nKHZhbHVlLnN1YnN0cmluZyg4KS50cmltKCkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIGlmICh2YWx1ZS5zcGxpdChcIihcIilbMF0udHJpbSgpID09PSBcImNvbnN0cnVjdG9yXCIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIENvbnN0cnVjdG9yRnJhZ21lbnQuZnJvbVN0cmluZyh2YWx1ZS50cmltKCkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInVuc3VwcG9ydGVkIGZyYWdtZW50XCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuXHQgICAgfTtcblx0ICAgIEZyYWdtZW50LmlzRnJhZ21lbnQgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX2lzRnJhZ21lbnQpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBGcmFnbWVudDtcblx0fSgpKTtcblx0ZXhwb3J0cy5GcmFnbWVudCA9IEZyYWdtZW50O1xuXHR2YXIgRXZlbnRGcmFnbWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0ICAgIF9fZXh0ZW5kcyhFdmVudEZyYWdtZW50LCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gRXZlbnRGcmFnbWVudCgpIHtcblx0ICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cdCAgICB9XG5cdCAgICBFdmVudEZyYWdtZW50LnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbiAoZm9ybWF0KSB7XG5cdCAgICAgICAgaWYgKCFmb3JtYXQpIHtcblx0ICAgICAgICAgICAgZm9ybWF0ID0gZXhwb3J0cy5Gb3JtYXRUeXBlcy5zaWdoYXNoO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoIWV4cG9ydHMuRm9ybWF0VHlwZXNbZm9ybWF0XSkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBmb3JtYXQgdHlwZVwiLCBcImZvcm1hdFwiLCBmb3JtYXQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoZm9ybWF0ID09PSBleHBvcnRzLkZvcm1hdFR5cGVzLmpzb24pIHtcblx0ICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcblx0ICAgICAgICAgICAgICAgIHR5cGU6IFwiZXZlbnRcIixcblx0ICAgICAgICAgICAgICAgIGFub255bW91czogdGhpcy5hbm9ueW1vdXMsXG5cdCAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG5cdCAgICAgICAgICAgICAgICBpbnB1dHM6IHRoaXMuaW5wdXRzLm1hcChmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIEpTT04ucGFyc2UoaW5wdXQuZm9ybWF0KGZvcm1hdCkpOyB9KVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IFwiXCI7XG5cdCAgICAgICAgaWYgKGZvcm1hdCAhPT0gZXhwb3J0cy5Gb3JtYXRUeXBlcy5zaWdoYXNoKSB7XG5cdCAgICAgICAgICAgIHJlc3VsdCArPSBcImV2ZW50IFwiO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXN1bHQgKz0gdGhpcy5uYW1lICsgXCIoXCIgKyB0aGlzLmlucHV0cy5tYXAoZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBpbnB1dC5mb3JtYXQoZm9ybWF0KTsgfSkuam9pbigoZm9ybWF0ID09PSBleHBvcnRzLkZvcm1hdFR5cGVzLmZ1bGwpID8gXCIsIFwiIDogXCIsXCIpICsgXCIpIFwiO1xuXHQgICAgICAgIGlmIChmb3JtYXQgIT09IGV4cG9ydHMuRm9ybWF0VHlwZXMuc2lnaGFzaCkge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5hbm9ueW1vdXMpIHtcblx0ICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcImFub255bW91cyBcIjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcmVzdWx0LnRyaW0oKTtcblx0ICAgIH07XG5cdCAgICBFdmVudEZyYWdtZW50LmZyb20gPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIEV2ZW50RnJhZ21lbnQuZnJvbVN0cmluZyh2YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBFdmVudEZyYWdtZW50LmZyb21PYmplY3QodmFsdWUpO1xuXHQgICAgfTtcblx0ICAgIEV2ZW50RnJhZ21lbnQuZnJvbU9iamVjdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIGlmIChFdmVudEZyYWdtZW50LmlzRXZlbnRGcmFnbWVudCh2YWx1ZSkpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodmFsdWUudHlwZSAhPT0gXCJldmVudFwiKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGV2ZW50IG9iamVjdFwiLCBcInZhbHVlXCIsIHZhbHVlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHBhcmFtcyA9IHtcblx0ICAgICAgICAgICAgbmFtZTogdmVyaWZ5SWRlbnRpZmllcih2YWx1ZS5uYW1lKSxcblx0ICAgICAgICAgICAgYW5vbnltb3VzOiB2YWx1ZS5hbm9ueW1vdXMsXG5cdCAgICAgICAgICAgIGlucHV0czogKHZhbHVlLmlucHV0cyA/IHZhbHVlLmlucHV0cy5tYXAoUGFyYW1UeXBlLmZyb21PYmplY3QpIDogW10pLFxuXHQgICAgICAgICAgICB0eXBlOiBcImV2ZW50XCJcblx0ICAgICAgICB9O1xuXHQgICAgICAgIHJldHVybiBuZXcgRXZlbnRGcmFnbWVudChfY29uc3RydWN0b3JHdWFyZCwgcGFyYW1zKTtcblx0ICAgIH07XG5cdCAgICBFdmVudEZyYWdtZW50LmZyb21TdHJpbmcgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICB2YXIgbWF0Y2ggPSB2YWx1ZS5tYXRjaChyZWdleFBhcmVuKTtcblx0ICAgICAgICBpZiAoIW1hdGNoKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGV2ZW50IHN0cmluZ1wiLCBcInZhbHVlXCIsIHZhbHVlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGFub255bW91cyA9IGZhbHNlO1xuXHQgICAgICAgIG1hdGNoWzNdLnNwbGl0KFwiIFwiKS5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuXHQgICAgICAgICAgICBzd2l0Y2ggKG1vZGlmaWVyLnRyaW0oKSkge1xuXHQgICAgICAgICAgICAgICAgY2FzZSBcImFub255bW91c1wiOlxuXHQgICAgICAgICAgICAgICAgICAgIGFub255bW91cyA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBjYXNlIFwiXCI6XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKFwidW5rbm93biBtb2RpZmllcjogXCIgKyBtb2RpZmllcik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgICAgICByZXR1cm4gRXZlbnRGcmFnbWVudC5mcm9tT2JqZWN0KHtcblx0ICAgICAgICAgICAgbmFtZTogbWF0Y2hbMV0udHJpbSgpLFxuXHQgICAgICAgICAgICBhbm9ueW1vdXM6IGFub255bW91cyxcblx0ICAgICAgICAgICAgaW5wdXRzOiBwYXJzZVBhcmFtcyhtYXRjaFsyXSwgdHJ1ZSksXG5cdCAgICAgICAgICAgIHR5cGU6IFwiZXZlbnRcIlxuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIEV2ZW50RnJhZ21lbnQuaXNFdmVudEZyYWdtZW50ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuICh2YWx1ZSAmJiB2YWx1ZS5faXNGcmFnbWVudCAmJiB2YWx1ZS50eXBlID09PSBcImV2ZW50XCIpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBFdmVudEZyYWdtZW50O1xuXHR9KEZyYWdtZW50KSk7XG5cdGV4cG9ydHMuRXZlbnRGcmFnbWVudCA9IEV2ZW50RnJhZ21lbnQ7XG5cdGZ1bmN0aW9uIHBhcnNlR2FzKHZhbHVlLCBwYXJhbXMpIHtcblx0ICAgIHBhcmFtcy5nYXMgPSBudWxsO1xuXHQgICAgdmFyIGNvbXBzID0gdmFsdWUuc3BsaXQoXCJAXCIpO1xuXHQgICAgaWYgKGNvbXBzLmxlbmd0aCAhPT0gMSkge1xuXHQgICAgICAgIGlmIChjb21wcy5sZW5ndGggPiAyKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGh1bWFuLXJlYWRhYmxlIEFCSSBzaWduYXR1cmVcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICghY29tcHNbMV0ubWF0Y2goL15bMC05XSskLykpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgaHVtYW4tcmVhZGFibGUgQUJJIHNpZ25hdHVyZSBnYXNcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHBhcmFtcy5nYXMgPSBsaWIkMi5CaWdOdW1iZXIuZnJvbShjb21wc1sxXSk7XG5cdCAgICAgICAgcmV0dXJuIGNvbXBzWzBdO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHZhbHVlO1xuXHR9XG5cdGZ1bmN0aW9uIHBhcnNlTW9kaWZpZXJzKHZhbHVlLCBwYXJhbXMpIHtcblx0ICAgIHBhcmFtcy5jb25zdGFudCA9IGZhbHNlO1xuXHQgICAgcGFyYW1zLnBheWFibGUgPSBmYWxzZTtcblx0ICAgIHBhcmFtcy5zdGF0ZU11dGFiaWxpdHkgPSBcIm5vbnBheWFibGVcIjtcblx0ICAgIHZhbHVlLnNwbGl0KFwiIFwiKS5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuXHQgICAgICAgIHN3aXRjaCAobW9kaWZpZXIudHJpbSgpKSB7XG5cdCAgICAgICAgICAgIGNhc2UgXCJjb25zdGFudFwiOlxuXHQgICAgICAgICAgICAgICAgcGFyYW1zLmNvbnN0YW50ID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlIFwicGF5YWJsZVwiOlxuXHQgICAgICAgICAgICAgICAgcGFyYW1zLnBheWFibGUgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgcGFyYW1zLnN0YXRlTXV0YWJpbGl0eSA9IFwicGF5YWJsZVwiO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgXCJub25wYXlhYmxlXCI6XG5cdCAgICAgICAgICAgICAgICBwYXJhbXMucGF5YWJsZSA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgcGFyYW1zLnN0YXRlTXV0YWJpbGl0eSA9IFwibm9ucGF5YWJsZVwiO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgXCJwdXJlXCI6XG5cdCAgICAgICAgICAgICAgICBwYXJhbXMuY29uc3RhbnQgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgcGFyYW1zLnN0YXRlTXV0YWJpbGl0eSA9IFwicHVyZVwiO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgXCJ2aWV3XCI6XG5cdCAgICAgICAgICAgICAgICBwYXJhbXMuY29uc3RhbnQgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgcGFyYW1zLnN0YXRlTXV0YWJpbGl0eSA9IFwidmlld1wiO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgXCJleHRlcm5hbFwiOlxuXHQgICAgICAgICAgICBjYXNlIFwicHVibGljXCI6XG5cdCAgICAgICAgICAgIGNhc2UgXCJcIjpcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJ1bmtub3duIG1vZGlmaWVyOiBcIiArIG1vZGlmaWVyKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0fVxuXHRmdW5jdGlvbiB2ZXJpZnlTdGF0ZSh2YWx1ZSkge1xuXHQgICAgdmFyIHJlc3VsdCA9IHtcblx0ICAgICAgICBjb25zdGFudDogZmFsc2UsXG5cdCAgICAgICAgcGF5YWJsZTogdHJ1ZSxcblx0ICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwicGF5YWJsZVwiXG5cdCAgICB9O1xuXHQgICAgaWYgKHZhbHVlLnN0YXRlTXV0YWJpbGl0eSAhPSBudWxsKSB7XG5cdCAgICAgICAgcmVzdWx0LnN0YXRlTXV0YWJpbGl0eSA9IHZhbHVlLnN0YXRlTXV0YWJpbGl0eTtcblx0ICAgICAgICAvLyBTZXQgKGFuZCBjaGVjayB0aGluZ3MgYXJlIGNvbnNpc3RlbnQpIHRoZSBjb25zdGFudCBwcm9wZXJ0eVxuXHQgICAgICAgIHJlc3VsdC5jb25zdGFudCA9IChyZXN1bHQuc3RhdGVNdXRhYmlsaXR5ID09PSBcInZpZXdcIiB8fCByZXN1bHQuc3RhdGVNdXRhYmlsaXR5ID09PSBcInB1cmVcIik7XG5cdCAgICAgICAgaWYgKHZhbHVlLmNvbnN0YW50ICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgaWYgKCghIXZhbHVlLmNvbnN0YW50KSAhPT0gcmVzdWx0LmNvbnN0YW50KSB7XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiY2Fubm90IGhhdmUgY29uc3RhbnQgZnVuY3Rpb24gd2l0aCBtdXRhYmlsaXR5IFwiICsgcmVzdWx0LnN0YXRlTXV0YWJpbGl0eSwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gU2V0IChhbmQgY2hlY2sgdGhpbmdzIGFyZSBjb25zaXN0ZW50KSB0aGUgcGF5YWJsZSBwcm9wZXJ0eVxuXHQgICAgICAgIHJlc3VsdC5wYXlhYmxlID0gKHJlc3VsdC5zdGF0ZU11dGFiaWxpdHkgPT09IFwicGF5YWJsZVwiKTtcblx0ICAgICAgICBpZiAodmFsdWUucGF5YWJsZSAhPSBudWxsKSB7XG5cdCAgICAgICAgICAgIGlmICgoISF2YWx1ZS5wYXlhYmxlKSAhPT0gcmVzdWx0LnBheWFibGUpIHtcblx0ICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJjYW5ub3QgaGF2ZSBwYXlhYmxlIGZ1bmN0aW9uIHdpdGggbXV0YWJpbGl0eSBcIiArIHJlc3VsdC5zdGF0ZU11dGFiaWxpdHksIFwidmFsdWVcIiwgdmFsdWUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgZWxzZSBpZiAodmFsdWUucGF5YWJsZSAhPSBudWxsKSB7XG5cdCAgICAgICAgcmVzdWx0LnBheWFibGUgPSAhIXZhbHVlLnBheWFibGU7XG5cdCAgICAgICAgLy8gSWYgcGF5YWJsZSB3ZSBjYW4gYXNzdW1lIG5vbi1jb25zdGFudDsgb3RoZXJ3aXNlIHdlIGNhbid0IGFzc3VtZVxuXHQgICAgICAgIGlmICh2YWx1ZS5jb25zdGFudCA9PSBudWxsICYmICFyZXN1bHQucGF5YWJsZSAmJiB2YWx1ZS50eXBlICE9PSBcImNvbnN0cnVjdG9yXCIpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInVuYWJsZSB0byBkZXRlcm1pbmUgc3RhdGVNdXRhYmlsaXR5XCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXN1bHQuY29uc3RhbnQgPSAhIXZhbHVlLmNvbnN0YW50O1xuXHQgICAgICAgIGlmIChyZXN1bHQuY29uc3RhbnQpIHtcblx0ICAgICAgICAgICAgcmVzdWx0LnN0YXRlTXV0YWJpbGl0eSA9IFwidmlld1wiO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgcmVzdWx0LnN0YXRlTXV0YWJpbGl0eSA9IChyZXN1bHQucGF5YWJsZSA/IFwicGF5YWJsZVwiIDogXCJub25wYXlhYmxlXCIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAocmVzdWx0LnBheWFibGUgJiYgcmVzdWx0LmNvbnN0YW50KSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJjYW5ub3QgaGF2ZSBjb25zdGFudCBwYXlhYmxlIGZ1bmN0aW9uXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIGVsc2UgaWYgKHZhbHVlLmNvbnN0YW50ICE9IG51bGwpIHtcblx0ICAgICAgICByZXN1bHQuY29uc3RhbnQgPSAhIXZhbHVlLmNvbnN0YW50O1xuXHQgICAgICAgIHJlc3VsdC5wYXlhYmxlID0gIXJlc3VsdC5jb25zdGFudDtcblx0ICAgICAgICByZXN1bHQuc3RhdGVNdXRhYmlsaXR5ID0gKHJlc3VsdC5jb25zdGFudCA/IFwidmlld1wiIDogXCJwYXlhYmxlXCIpO1xuXHQgICAgfVxuXHQgICAgZWxzZSBpZiAodmFsdWUudHlwZSAhPT0gXCJjb25zdHJ1Y3RvclwiKSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInVuYWJsZSB0byBkZXRlcm1pbmUgc3RhdGVNdXRhYmlsaXR5XCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0fVxuXHR2YXIgQ29uc3RydWN0b3JGcmFnbWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0ICAgIF9fZXh0ZW5kcyhDb25zdHJ1Y3RvckZyYWdtZW50LCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gQ29uc3RydWN0b3JGcmFnbWVudCgpIHtcblx0ICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cdCAgICB9XG5cdCAgICBDb25zdHJ1Y3RvckZyYWdtZW50LnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbiAoZm9ybWF0KSB7XG5cdCAgICAgICAgaWYgKCFmb3JtYXQpIHtcblx0ICAgICAgICAgICAgZm9ybWF0ID0gZXhwb3J0cy5Gb3JtYXRUeXBlcy5zaWdoYXNoO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoIWV4cG9ydHMuRm9ybWF0VHlwZXNbZm9ybWF0XSkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBmb3JtYXQgdHlwZVwiLCBcImZvcm1hdFwiLCBmb3JtYXQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoZm9ybWF0ID09PSBleHBvcnRzLkZvcm1hdFR5cGVzLmpzb24pIHtcblx0ICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcblx0ICAgICAgICAgICAgICAgIHR5cGU6IFwiY29uc3RydWN0b3JcIixcblx0ICAgICAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eTogKCh0aGlzLnN0YXRlTXV0YWJpbGl0eSAhPT0gXCJub25wYXlhYmxlXCIpID8gdGhpcy5zdGF0ZU11dGFiaWxpdHkgOiB1bmRlZmluZWQpLFxuXHQgICAgICAgICAgICAgICAgcGF5YmxlOiB0aGlzLnBheWFibGUsXG5cdCAgICAgICAgICAgICAgICBnYXM6ICh0aGlzLmdhcyA/IHRoaXMuZ2FzLnRvTnVtYmVyKCkgOiB1bmRlZmluZWQpLFxuXHQgICAgICAgICAgICAgICAgaW5wdXRzOiB0aGlzLmlucHV0cy5tYXAoZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBKU09OLnBhcnNlKGlucHV0LmZvcm1hdChmb3JtYXQpKTsgfSlcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChmb3JtYXQgPT09IGV4cG9ydHMuRm9ybWF0VHlwZXMuc2lnaGFzaCkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImNhbm5vdCBmb3JtYXQgYSBjb25zdHJ1Y3RvciBmb3Igc2lnaGFzaFwiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcblx0ICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJmb3JtYXQoc2lnaGFzaClcIlxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IFwiY29uc3RydWN0b3IoXCIgKyB0aGlzLmlucHV0cy5tYXAoZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBpbnB1dC5mb3JtYXQoZm9ybWF0KTsgfSkuam9pbigoZm9ybWF0ID09PSBleHBvcnRzLkZvcm1hdFR5cGVzLmZ1bGwpID8gXCIsIFwiIDogXCIsXCIpICsgXCIpIFwiO1xuXHQgICAgICAgIGlmICh0aGlzLnN0YXRlTXV0YWJpbGl0eSAmJiB0aGlzLnN0YXRlTXV0YWJpbGl0eSAhPT0gXCJub25wYXlhYmxlXCIpIHtcblx0ICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuc3RhdGVNdXRhYmlsaXR5ICsgXCIgXCI7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiByZXN1bHQudHJpbSgpO1xuXHQgICAgfTtcblx0ICAgIENvbnN0cnVjdG9yRnJhZ21lbnQuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgICAgICByZXR1cm4gQ29uc3RydWN0b3JGcmFnbWVudC5mcm9tU3RyaW5nKHZhbHVlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIENvbnN0cnVjdG9yRnJhZ21lbnQuZnJvbU9iamVjdCh2YWx1ZSk7XG5cdCAgICB9O1xuXHQgICAgQ29uc3RydWN0b3JGcmFnbWVudC5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgaWYgKENvbnN0cnVjdG9yRnJhZ21lbnQuaXNDb25zdHJ1Y3RvckZyYWdtZW50KHZhbHVlKSkge1xuXHQgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICh2YWx1ZS50eXBlICE9PSBcImNvbnN0cnVjdG9yXCIpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgY29uc3RydWN0b3Igb2JqZWN0XCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgc3RhdGUgPSB2ZXJpZnlTdGF0ZSh2YWx1ZSk7XG5cdCAgICAgICAgaWYgKHN0YXRlLmNvbnN0YW50KSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY29uc3RhbnRcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBwYXJhbXMgPSB7XG5cdCAgICAgICAgICAgIG5hbWU6IG51bGwsXG5cdCAgICAgICAgICAgIHR5cGU6IHZhbHVlLnR5cGUsXG5cdCAgICAgICAgICAgIGlucHV0czogKHZhbHVlLmlucHV0cyA/IHZhbHVlLmlucHV0cy5tYXAoUGFyYW1UeXBlLmZyb21PYmplY3QpIDogW10pLFxuXHQgICAgICAgICAgICBwYXlhYmxlOiBzdGF0ZS5wYXlhYmxlLFxuXHQgICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IHN0YXRlLnN0YXRlTXV0YWJpbGl0eSxcblx0ICAgICAgICAgICAgZ2FzOiAodmFsdWUuZ2FzID8gbGliJDIuQmlnTnVtYmVyLmZyb20odmFsdWUuZ2FzKSA6IG51bGwpXG5cdCAgICAgICAgfTtcblx0ICAgICAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yRnJhZ21lbnQoX2NvbnN0cnVjdG9yR3VhcmQsIHBhcmFtcyk7XG5cdCAgICB9O1xuXHQgICAgQ29uc3RydWN0b3JGcmFnbWVudC5mcm9tU3RyaW5nID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgdmFyIHBhcmFtcyA9IHsgdHlwZTogXCJjb25zdHJ1Y3RvclwiIH07XG5cdCAgICAgICAgdmFsdWUgPSBwYXJzZUdhcyh2YWx1ZSwgcGFyYW1zKTtcblx0ICAgICAgICB2YXIgcGFyZW5zID0gdmFsdWUubWF0Y2gocmVnZXhQYXJlbik7XG5cdCAgICAgICAgaWYgKCFwYXJlbnMgfHwgcGFyZW5zWzFdLnRyaW0oKSAhPT0gXCJjb25zdHJ1Y3RvclwiKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGNvbnN0cnVjdG9yIHN0cmluZ1wiLCBcInZhbHVlXCIsIHZhbHVlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcGFyYW1zLmlucHV0cyA9IHBhcnNlUGFyYW1zKHBhcmVuc1syXS50cmltKCksIGZhbHNlKTtcblx0ICAgICAgICBwYXJzZU1vZGlmaWVycyhwYXJlbnNbM10udHJpbSgpLCBwYXJhbXMpO1xuXHQgICAgICAgIHJldHVybiBDb25zdHJ1Y3RvckZyYWdtZW50LmZyb21PYmplY3QocGFyYW1zKTtcblx0ICAgIH07XG5cdCAgICBDb25zdHJ1Y3RvckZyYWdtZW50LmlzQ29uc3RydWN0b3JGcmFnbWVudCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiAodmFsdWUgJiYgdmFsdWUuX2lzRnJhZ21lbnQgJiYgdmFsdWUudHlwZSA9PT0gXCJjb25zdHJ1Y3RvclwiKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gQ29uc3RydWN0b3JGcmFnbWVudDtcblx0fShGcmFnbWVudCkpO1xuXHRleHBvcnRzLkNvbnN0cnVjdG9yRnJhZ21lbnQgPSBDb25zdHJ1Y3RvckZyYWdtZW50O1xuXHR2YXIgRnVuY3Rpb25GcmFnbWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0ICAgIF9fZXh0ZW5kcyhGdW5jdGlvbkZyYWdtZW50LCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gRnVuY3Rpb25GcmFnbWVudCgpIHtcblx0ICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cdCAgICB9XG5cdCAgICBGdW5jdGlvbkZyYWdtZW50LnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbiAoZm9ybWF0KSB7XG5cdCAgICAgICAgaWYgKCFmb3JtYXQpIHtcblx0ICAgICAgICAgICAgZm9ybWF0ID0gZXhwb3J0cy5Gb3JtYXRUeXBlcy5zaWdoYXNoO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoIWV4cG9ydHMuRm9ybWF0VHlwZXNbZm9ybWF0XSkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBmb3JtYXQgdHlwZVwiLCBcImZvcm1hdFwiLCBmb3JtYXQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoZm9ybWF0ID09PSBleHBvcnRzLkZvcm1hdFR5cGVzLmpzb24pIHtcblx0ICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcblx0ICAgICAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcblx0ICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcblx0ICAgICAgICAgICAgICAgIGNvbnN0YW50OiB0aGlzLmNvbnN0YW50LFxuXHQgICAgICAgICAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiAoKHRoaXMuc3RhdGVNdXRhYmlsaXR5ICE9PSBcIm5vbnBheWFibGVcIikgPyB0aGlzLnN0YXRlTXV0YWJpbGl0eSA6IHVuZGVmaW5lZCksXG5cdCAgICAgICAgICAgICAgICBwYXlibGU6IHRoaXMucGF5YWJsZSxcblx0ICAgICAgICAgICAgICAgIGdhczogKHRoaXMuZ2FzID8gdGhpcy5nYXMudG9OdW1iZXIoKSA6IHVuZGVmaW5lZCksXG5cdCAgICAgICAgICAgICAgICBpbnB1dHM6IHRoaXMuaW5wdXRzLm1hcChmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIEpTT04ucGFyc2UoaW5wdXQuZm9ybWF0KGZvcm1hdCkpOyB9KSxcblx0ICAgICAgICAgICAgICAgIG91cHV0czogdGhpcy5vdXRwdXRzLm1hcChmdW5jdGlvbiAob3V0cHV0KSB7IHJldHVybiBKU09OLnBhcnNlKG91dHB1dC5mb3JtYXQoZm9ybWF0KSk7IH0pLFxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IFwiXCI7XG5cdCAgICAgICAgaWYgKGZvcm1hdCAhPT0gZXhwb3J0cy5Gb3JtYXRUeXBlcy5zaWdoYXNoKSB7XG5cdCAgICAgICAgICAgIHJlc3VsdCArPSBcImZ1bmN0aW9uIFwiO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXN1bHQgKz0gdGhpcy5uYW1lICsgXCIoXCIgKyB0aGlzLmlucHV0cy5tYXAoZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBpbnB1dC5mb3JtYXQoZm9ybWF0KTsgfSkuam9pbigoZm9ybWF0ID09PSBleHBvcnRzLkZvcm1hdFR5cGVzLmZ1bGwpID8gXCIsIFwiIDogXCIsXCIpICsgXCIpIFwiO1xuXHQgICAgICAgIGlmIChmb3JtYXQgIT09IGV4cG9ydHMuRm9ybWF0VHlwZXMuc2lnaGFzaCkge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZU11dGFiaWxpdHkpIHtcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlTXV0YWJpbGl0eSAhPT0gXCJub25wYXlhYmxlXCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gKHRoaXMuc3RhdGVNdXRhYmlsaXR5ICsgXCIgXCIpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY29uc3RhbnQpIHtcblx0ICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcInZpZXcgXCI7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0cyAmJiB0aGlzLm91dHB1dHMubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCJyZXR1cm5zIChcIiArIHRoaXMub3V0cHV0cy5tYXAoZnVuY3Rpb24gKG91dHB1dCkgeyByZXR1cm4gb3V0cHV0LmZvcm1hdChmb3JtYXQpOyB9KS5qb2luKFwiLCBcIikgKyBcIikgXCI7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKHRoaXMuZ2FzICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIkBcIiArIHRoaXMuZ2FzLnRvU3RyaW5nKCkgKyBcIiBcIjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcmVzdWx0LnRyaW0oKTtcblx0ICAgIH07XG5cdCAgICBGdW5jdGlvbkZyYWdtZW50LmZyb20gPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uRnJhZ21lbnQuZnJvbVN0cmluZyh2YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBGdW5jdGlvbkZyYWdtZW50LmZyb21PYmplY3QodmFsdWUpO1xuXHQgICAgfTtcblx0ICAgIEZ1bmN0aW9uRnJhZ21lbnQuZnJvbU9iamVjdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIGlmIChGdW5jdGlvbkZyYWdtZW50LmlzRnVuY3Rpb25GcmFnbWVudCh2YWx1ZSkpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodmFsdWUudHlwZSAhPT0gXCJmdW5jdGlvblwiKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGZ1bmN0aW9uIG9iamVjdFwiLCBcInZhbHVlXCIsIHZhbHVlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHN0YXRlID0gdmVyaWZ5U3RhdGUodmFsdWUpO1xuXHQgICAgICAgIHZhciBwYXJhbXMgPSB7XG5cdCAgICAgICAgICAgIHR5cGU6IHZhbHVlLnR5cGUsXG5cdCAgICAgICAgICAgIG5hbWU6IHZlcmlmeUlkZW50aWZpZXIodmFsdWUubmFtZSksXG5cdCAgICAgICAgICAgIGNvbnN0YW50OiBzdGF0ZS5jb25zdGFudCxcblx0ICAgICAgICAgICAgaW5wdXRzOiAodmFsdWUuaW5wdXRzID8gdmFsdWUuaW5wdXRzLm1hcChQYXJhbVR5cGUuZnJvbU9iamVjdCkgOiBbXSksXG5cdCAgICAgICAgICAgIG91dHB1dHM6ICh2YWx1ZS5vdXRwdXRzID8gdmFsdWUub3V0cHV0cy5tYXAoUGFyYW1UeXBlLmZyb21PYmplY3QpIDogW10pLFxuXHQgICAgICAgICAgICBwYXlhYmxlOiBzdGF0ZS5wYXlhYmxlLFxuXHQgICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IHN0YXRlLnN0YXRlTXV0YWJpbGl0eSxcblx0ICAgICAgICAgICAgZ2FzOiAodmFsdWUuZ2FzID8gbGliJDIuQmlnTnVtYmVyLmZyb20odmFsdWUuZ2FzKSA6IG51bGwpXG5cdCAgICAgICAgfTtcblx0ICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uRnJhZ21lbnQoX2NvbnN0cnVjdG9yR3VhcmQsIHBhcmFtcyk7XG5cdCAgICB9O1xuXHQgICAgRnVuY3Rpb25GcmFnbWVudC5mcm9tU3RyaW5nID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgdmFyIHBhcmFtcyA9IHsgdHlwZTogXCJmdW5jdGlvblwiIH07XG5cdCAgICAgICAgdmFsdWUgPSBwYXJzZUdhcyh2YWx1ZSwgcGFyYW1zKTtcblx0ICAgICAgICB2YXIgY29tcHMgPSB2YWx1ZS5zcGxpdChcIiByZXR1cm5zIFwiKTtcblx0ICAgICAgICBpZiAoY29tcHMubGVuZ3RoID4gMikge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBmdW5jdGlvbiBzdHJpbmdcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBwYXJlbnMgPSBjb21wc1swXS5tYXRjaChyZWdleFBhcmVuKTtcblx0ICAgICAgICBpZiAoIXBhcmVucykge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBmdW5jdGlvbiBzaWduYXR1cmVcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHBhcmFtcy5uYW1lID0gcGFyZW5zWzFdLnRyaW0oKTtcblx0ICAgICAgICBpZiAocGFyYW1zLm5hbWUpIHtcblx0ICAgICAgICAgICAgdmVyaWZ5SWRlbnRpZmllcihwYXJhbXMubmFtZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHBhcmFtcy5pbnB1dHMgPSBwYXJzZVBhcmFtcyhwYXJlbnNbMl0sIGZhbHNlKTtcblx0ICAgICAgICBwYXJzZU1vZGlmaWVycyhwYXJlbnNbM10udHJpbSgpLCBwYXJhbXMpO1xuXHQgICAgICAgIC8vIFdlIGhhdmUgb3V0cHV0c1xuXHQgICAgICAgIGlmIChjb21wcy5sZW5ndGggPiAxKSB7XG5cdCAgICAgICAgICAgIHZhciByZXR1cm5zID0gY29tcHNbMV0ubWF0Y2gocmVnZXhQYXJlbik7XG5cdCAgICAgICAgICAgIGlmIChyZXR1cm5zWzFdLnRyaW0oKSAhPSBcIlwiIHx8IHJldHVybnNbM10udHJpbSgpICE9IFwiXCIpIHtcblx0ICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bmV4cGVjdGVkIHRva2Vuc1wiLCBcInZhbHVlXCIsIHZhbHVlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBwYXJhbXMub3V0cHV0cyA9IHBhcnNlUGFyYW1zKHJldHVybnNbMl0sIGZhbHNlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIHBhcmFtcy5vdXRwdXRzID0gW107XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBGdW5jdGlvbkZyYWdtZW50LmZyb21PYmplY3QocGFyYW1zKTtcblx0ICAgIH07XG5cdCAgICBGdW5jdGlvbkZyYWdtZW50LmlzRnVuY3Rpb25GcmFnbWVudCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiAodmFsdWUgJiYgdmFsdWUuX2lzRnJhZ21lbnQgJiYgdmFsdWUudHlwZSA9PT0gXCJmdW5jdGlvblwiKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gRnVuY3Rpb25GcmFnbWVudDtcblx0fShDb25zdHJ1Y3RvckZyYWdtZW50KSk7XG5cdGV4cG9ydHMuRnVuY3Rpb25GcmFnbWVudCA9IEZ1bmN0aW9uRnJhZ21lbnQ7XG5cdC8vZXhwb3J0IGNsYXNzIEVycm9yRnJhZ21lbnQgZXh0ZW5kcyBGcmFnbWVudCB7XG5cdC8vfVxuXHQvL2V4cG9ydCBjbGFzcyBTdHJ1Y3RGcmFnbWVudCBleHRlbmRzIEZyYWdtZW50IHtcblx0Ly99XG5cdGZ1bmN0aW9uIHZlcmlmeVR5cGUodHlwZSkge1xuXHQgICAgLy8gVGhlc2UgbmVlZCB0byBiZSB0cmFuc2Zvcm1lZCB0byB0aGVpciBmdWxsIGRlc2NyaXB0aW9uXG5cdCAgICBpZiAodHlwZS5tYXRjaCgvXnVpbnQoJHxbXjEtOV0pLykpIHtcblx0ICAgICAgICB0eXBlID0gXCJ1aW50MjU2XCIgKyB0eXBlLnN1YnN0cmluZyg0KTtcblx0ICAgIH1cblx0ICAgIGVsc2UgaWYgKHR5cGUubWF0Y2goL15pbnQoJHxbXjEtOV0pLykpIHtcblx0ICAgICAgICB0eXBlID0gXCJpbnQyNTZcIiArIHR5cGUuc3Vic3RyaW5nKDMpO1xuXHQgICAgfVxuXHQgICAgLy8gQFRPRE86IG1vcmUgdmVyaWZpY2F0aW9uXG5cdCAgICByZXR1cm4gdHlwZTtcblx0fVxuXHR2YXIgcmVnZXhJZGVudGlmaWVyID0gbmV3IFJlZ0V4cChcIl5bQS1aYS16X11bQS1aYS16MC05X10qJFwiKTtcblx0ZnVuY3Rpb24gdmVyaWZ5SWRlbnRpZmllcih2YWx1ZSkge1xuXHQgICAgaWYgKCF2YWx1ZSB8fCAhdmFsdWUubWF0Y2gocmVnZXhJZGVudGlmaWVyKSkge1xuXHQgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGlkZW50aWZpZXIgXFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdmFsdWU7XG5cdH1cblx0dmFyIHJlZ2V4UGFyZW4gPSBuZXcgUmVnRXhwKFwiXihbXikoXSopXFxcXCgoLiopXFxcXCkoW14pKF0qKSRcIik7XG5cdGZ1bmN0aW9uIHNwbGl0TmVzdGluZyh2YWx1ZSkge1xuXHQgICAgdmFsdWUgPSB2YWx1ZS50cmltKCk7XG5cdCAgICB2YXIgcmVzdWx0ID0gW107XG5cdCAgICB2YXIgYWNjdW0gPSBcIlwiO1xuXHQgICAgdmFyIGRlcHRoID0gMDtcblx0ICAgIGZvciAodmFyIG9mZnNldCA9IDA7IG9mZnNldCA8IHZhbHVlLmxlbmd0aDsgb2Zmc2V0KyspIHtcblx0ICAgICAgICB2YXIgYyA9IHZhbHVlW29mZnNldF07XG5cdCAgICAgICAgaWYgKGMgPT09IFwiLFwiICYmIGRlcHRoID09PSAwKSB7XG5cdCAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFjY3VtKTtcblx0ICAgICAgICAgICAgYWNjdW0gPSBcIlwiO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgYWNjdW0gKz0gYztcblx0ICAgICAgICAgICAgaWYgKGMgPT09IFwiKFwiKSB7XG5cdCAgICAgICAgICAgICAgICBkZXB0aCsrO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09IFwiKVwiKSB7XG5cdCAgICAgICAgICAgICAgICBkZXB0aC0tO1xuXHQgICAgICAgICAgICAgICAgaWYgKGRlcHRoID09PSAtMSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bmJhbGFuY2VkIHBhcmVudGhlc2lzXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgaWYgKGFjY3VtKSB7XG5cdCAgICAgICAgcmVzdWx0LnB1c2goYWNjdW0pO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdH0pO1xuXG5cdHZhciBmcmFnbWVudHMkMSA9IHVud3JhcEV4cG9ydHMoZnJhZ21lbnRzKTtcblx0dmFyIGZyYWdtZW50c18xID0gZnJhZ21lbnRzLkZvcm1hdFR5cGVzO1xuXHR2YXIgZnJhZ21lbnRzXzIgPSBmcmFnbWVudHMuUGFyYW1UeXBlO1xuXHR2YXIgZnJhZ21lbnRzXzMgPSBmcmFnbWVudHMuRnJhZ21lbnQ7XG5cdHZhciBmcmFnbWVudHNfNCA9IGZyYWdtZW50cy5FdmVudEZyYWdtZW50O1xuXHR2YXIgZnJhZ21lbnRzXzUgPSBmcmFnbWVudHMuQ29uc3RydWN0b3JGcmFnbWVudDtcblx0dmFyIGZyYWdtZW50c182ID0gZnJhZ21lbnRzLkZ1bmN0aW9uRnJhZ21lbnQ7XG5cblx0dmFyIGFic3RyYWN0Q29kZXIgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cblxuXG5cblxuXHR2YXIgbG9nZ2VyID0gbmV3IGxpYi5Mb2dnZXIoX3ZlcnNpb24kOC52ZXJzaW9uKTtcblx0ZnVuY3Rpb24gY2hlY2tSZXN1bHRFcnJvcnMocmVzdWx0KSB7XG5cdCAgICAvLyBGaW5kIHRoZSBmaXJzdCBlcnJvciAoaWYgYW55KVxuXHQgICAgdmFyIGVycm9ycyA9IFtdO1xuXHQgICAgdmFyIGNoZWNrRXJyb3JzID0gZnVuY3Rpb24gKHBhdGgsIG9iamVjdCkge1xuXHQgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuXHQgICAgICAgICAgICB2YXIgY2hpbGRQYXRoID0gcGF0aC5zbGljZSgpO1xuXHQgICAgICAgICAgICBjaGlsZFBhdGgucHVzaChrZXkpO1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgY2hlY2tFcnJvcnMoY2hpbGRQYXRoLCBvYmplY3Rba2V5XSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh7IHBhdGg6IGNoaWxkUGF0aCwgZXJyb3I6IGVycm9yIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIGNoZWNrRXJyb3JzKFtdLCByZXN1bHQpO1xuXHQgICAgcmV0dXJuIGVycm9ycztcblx0fVxuXHRleHBvcnRzLmNoZWNrUmVzdWx0RXJyb3JzID0gY2hlY2tSZXN1bHRFcnJvcnM7XG5cdHZhciBDb2RlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIENvZGVyKG5hbWUsIHR5cGUsIGxvY2FsTmFtZSwgZHluYW1pYykge1xuXHQgICAgICAgIC8vIEBUT0RPOiBkZWZpbmVSZWFkT25seSB0aGVzZVxuXHQgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG5cdCAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcblx0ICAgICAgICB0aGlzLmxvY2FsTmFtZSA9IGxvY2FsTmFtZTtcblx0ICAgICAgICB0aGlzLmR5bmFtaWMgPSBkeW5hbWljO1xuXHQgICAgfVxuXHQgICAgQ29kZXIucHJvdG90eXBlLl90aHJvd0Vycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHZhbHVlKSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihtZXNzYWdlLCB0aGlzLmxvY2FsTmFtZSwgdmFsdWUpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBDb2Rlcjtcblx0fSgpKTtcblx0ZXhwb3J0cy5Db2RlciA9IENvZGVyO1xuXHR2YXIgV3JpdGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gV3JpdGVyKHdvcmRTaXplKSB7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJ3b3JkU2l6ZVwiLCB3b3JkU2l6ZSB8fCAzMik7XG5cdCAgICAgICAgdGhpcy5fZGF0YSA9IGxpYiQxLmFycmF5aWZ5KFtdKTtcblx0ICAgICAgICB0aGlzLl9wYWRkaW5nID0gbmV3IFVpbnQ4QXJyYXkod29yZFNpemUpO1xuXHQgICAgfVxuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRlci5wcm90b3R5cGUsIFwiZGF0YVwiLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsaWIkMS5oZXhsaWZ5KHRoaXMuX2RhdGEpOyB9LFxuXHQgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cdCAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG5cdCAgICB9KTtcblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0ZXIucHJvdG90eXBlLCBcImxlbmd0aFwiLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kYXRhLmxlbmd0aDsgfSxcblx0ICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXHQgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHQgICAgfSk7XG5cdCAgICBXcml0ZXIucHJvdG90eXBlLl93cml0ZURhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuXHQgICAgICAgIHRoaXMuX2RhdGEgPSBsaWIkMS5jb25jYXQoW3RoaXMuX2RhdGEsIGRhdGFdKTtcblx0ICAgICAgICByZXR1cm4gZGF0YS5sZW5ndGg7XG5cdCAgICB9O1xuXHQgICAgLy8gQXJyYXlpc2ggaXRlbXM7IHBhZGRlZCBvbiB0aGUgcmlnaHQgdG8gd29yZFNpemVcblx0ICAgIFdyaXRlci5wcm90b3R5cGUud3JpdGVCeXRlcyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHZhciBieXRlcyA9IGxpYiQxLmFycmF5aWZ5KHZhbHVlKTtcblx0ICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoICUgdGhpcy53b3JkU2l6ZSkge1xuXHQgICAgICAgICAgICBieXRlcyA9IGxpYiQxLmNvbmNhdChbYnl0ZXMsIHRoaXMuX3BhZGRpbmcuc2xpY2UoYnl0ZXMubGVuZ3RoICUgdGhpcy53b3JkU2l6ZSldKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX3dyaXRlRGF0YShieXRlcyk7XG5cdCAgICB9O1xuXHQgICAgV3JpdGVyLnByb3RvdHlwZS5fZ2V0VmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICB2YXIgYnl0ZXMgPSBsaWIkMS5hcnJheWlmeShsaWIkMi5CaWdOdW1iZXIuZnJvbSh2YWx1ZSkpO1xuXHQgICAgICAgIGlmIChieXRlcy5sZW5ndGggPiB0aGlzLndvcmRTaXplKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidmFsdWUgb3V0LW9mLWJvdW5kc1wiLCBsaWIuTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTiwge1xuXHQgICAgICAgICAgICAgICAgbGVuZ3RoOiB0aGlzLndvcmRTaXplLFxuXHQgICAgICAgICAgICAgICAgb2Zmc2V0OiBieXRlcy5sZW5ndGhcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChieXRlcy5sZW5ndGggJSB0aGlzLndvcmRTaXplKSB7XG5cdCAgICAgICAgICAgIGJ5dGVzID0gbGliJDEuY29uY2F0KFt0aGlzLl9wYWRkaW5nLnNsaWNlKGJ5dGVzLmxlbmd0aCAlIHRoaXMud29yZFNpemUpLCBieXRlc10pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gYnl0ZXM7XG5cdCAgICB9O1xuXHQgICAgLy8gQmlnTnVtYmVyaXNoIGl0ZW1zOyBwYWRkZWQgb24gdGhlIGxlZnQgdG8gd29yZFNpemVcblx0ICAgIFdyaXRlci5wcm90b3R5cGUud3JpdGVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl93cml0ZURhdGEodGhpcy5fZ2V0VmFsdWUodmFsdWUpKTtcblx0ICAgIH07XG5cdCAgICBXcml0ZXIucHJvdG90eXBlLndyaXRlVXBkYXRhYmxlVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5sZW5ndGg7XG5cdCAgICAgICAgdGhpcy53cml0ZVZhbHVlKDApO1xuXHQgICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICAgICAgX3RoaXMuX2RhdGEuc2V0KF90aGlzLl9nZXRWYWx1ZSh2YWx1ZSksIG9mZnNldCk7XG5cdCAgICAgICAgfTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gV3JpdGVyO1xuXHR9KCkpO1xuXHRleHBvcnRzLldyaXRlciA9IFdyaXRlcjtcblx0dmFyIFJlYWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIFJlYWRlcihkYXRhLCB3b3JkU2l6ZSwgY29lcmNlRnVuYykge1xuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX2RhdGFcIiwgbGliJDEuYXJyYXlpZnkoZGF0YSkpO1xuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KHRoaXMsIFwid29yZFNpemVcIiwgd29yZFNpemUgfHwgMzIpO1xuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX2NvZXJjZUZ1bmNcIiwgY29lcmNlRnVuYyk7XG5cdCAgICAgICAgdGhpcy5fb2Zmc2V0ID0gMDtcblx0ICAgIH1cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkZXIucHJvdG90eXBlLCBcImRhdGFcIiwge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGliJDEuaGV4bGlmeSh0aGlzLl9kYXRhKTsgfSxcblx0ICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXHQgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHQgICAgfSk7XG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGVyLnByb3RvdHlwZSwgXCJjb25zdW1lZFwiLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9vZmZzZXQ7IH0sXG5cdCAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblx0ICAgICAgICBjb25maWd1cmFibGU6IHRydWVcblx0ICAgIH0pO1xuXHQgICAgLy8gVGhlIGRlZmF1bHQgQ29lcmNlIGZ1bmN0aW9uXG5cdCAgICBSZWFkZXIuY29lcmNlID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG5cdCAgICAgICAgdmFyIG1hdGNoID0gbmFtZS5tYXRjaChcIl51P2ludChbMC05XSspJFwiKTtcblx0ICAgICAgICBpZiAobWF0Y2ggJiYgcGFyc2VJbnQobWF0Y2hbMV0pIDw9IDQ4KSB7XG5cdCAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9OdW1iZXIoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHZhbHVlO1xuXHQgICAgfTtcblx0ICAgIFJlYWRlci5wcm90b3R5cGUuY29lcmNlID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuX2NvZXJjZUZ1bmMpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvZXJjZUZ1bmMobmFtZSwgdmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gUmVhZGVyLmNvZXJjZShuYW1lLCB2YWx1ZSk7XG5cdCAgICB9O1xuXHQgICAgUmVhZGVyLnByb3RvdHlwZS5fcGVla0J5dGVzID0gZnVuY3Rpb24gKG9mZnNldCwgbGVuZ3RoKSB7XG5cdCAgICAgICAgdmFyIGFsaWduZWRMZW5ndGggPSBNYXRoLmNlaWwobGVuZ3RoIC8gdGhpcy53b3JkU2l6ZSkgKiB0aGlzLndvcmRTaXplO1xuXHQgICAgICAgIGlmICh0aGlzLl9vZmZzZXQgKyBhbGlnbmVkTGVuZ3RoID4gdGhpcy5fZGF0YS5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJkYXRhIG91dC1vZi1ib3VuZHNcIiwgbGliLkxvZ2dlci5lcnJvcnMuQlVGRkVSX09WRVJSVU4sIHtcblx0ICAgICAgICAgICAgICAgIGxlbmd0aDogdGhpcy5fZGF0YS5sZW5ndGgsXG5cdCAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMuX29mZnNldCArIGFsaWduZWRMZW5ndGhcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLnNsaWNlKHRoaXMuX29mZnNldCwgdGhpcy5fb2Zmc2V0ICsgYWxpZ25lZExlbmd0aCk7XG5cdCAgICB9O1xuXHQgICAgUmVhZGVyLnByb3RvdHlwZS5zdWJSZWFkZXIgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBSZWFkZXIodGhpcy5fZGF0YS5zbGljZSh0aGlzLl9vZmZzZXQgKyBvZmZzZXQpLCB0aGlzLndvcmRTaXplLCB0aGlzLl9jb2VyY2VGdW5jKTtcblx0ICAgIH07XG5cdCAgICBSZWFkZXIucHJvdG90eXBlLnJlYWRCeXRlcyA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcblx0ICAgICAgICB2YXIgYnl0ZXMgPSB0aGlzLl9wZWVrQnl0ZXMoMCwgbGVuZ3RoKTtcblx0ICAgICAgICB0aGlzLl9vZmZzZXQgKz0gYnl0ZXMubGVuZ3RoO1xuXHQgICAgICAgIC8vIEBUT0RPOiBNYWtlIHN1cmUgdGhlIGxlbmd0aC4uZW5kIGJ5dGVzIGFyZSBhbGwgMD9cblx0ICAgICAgICByZXR1cm4gYnl0ZXMuc2xpY2UoMCwgbGVuZ3RoKTtcblx0ICAgIH07XG5cdCAgICBSZWFkZXIucHJvdG90eXBlLnJlYWRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gbGliJDIuQmlnTnVtYmVyLmZyb20odGhpcy5yZWFkQnl0ZXModGhpcy53b3JkU2l6ZSkpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBSZWFkZXI7XG5cdH0oKSk7XG5cdGV4cG9ydHMuUmVhZGVyID0gUmVhZGVyO1xuXG5cdH0pO1xuXG5cdHZhciBhYnN0cmFjdENvZGVyJDEgPSB1bndyYXBFeHBvcnRzKGFic3RyYWN0Q29kZXIpO1xuXHR2YXIgYWJzdHJhY3RDb2Rlcl8xID0gYWJzdHJhY3RDb2Rlci5jaGVja1Jlc3VsdEVycm9ycztcblx0dmFyIGFic3RyYWN0Q29kZXJfMiA9IGFic3RyYWN0Q29kZXIuQ29kZXI7XG5cdHZhciBhYnN0cmFjdENvZGVyXzMgPSBhYnN0cmFjdENvZGVyLldyaXRlcjtcblx0dmFyIGFic3RyYWN0Q29kZXJfNCA9IGFic3RyYWN0Q29kZXIuUmVhZGVyO1xuXG5cdHZhciBzaGEzID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuXHQvKipcclxuXHQgKiBbanMtc2hhM117QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2VtbjE3OC9qcy1zaGEzfVxyXG5cdCAqXHJcblx0ICogQHZlcnNpb24gMC41LjdcclxuXHQgKiBAYXV0aG9yIENoZW4sIFlpLUN5dWFuIFtlbW4xNzhAZ21haWwuY29tXVxyXG5cdCAqIEBjb3B5cmlnaHQgQ2hlbiwgWWktQ3l1YW4gMjAxNS0yMDE2XHJcblx0ICogQGxpY2Vuc2UgTUlUXHJcblx0ICovXHJcblx0Lypqc2xpbnQgYml0d2lzZTogdHJ1ZSAqL1xyXG5cdChmdW5jdGlvbiAoKSB7XHJcblx0ICAndXNlIHN0cmljdCc7XHJcblxyXG5cdCAgdmFyIHJvb3QgPSB0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyA/IHdpbmRvdyA6IHt9O1xyXG5cdCAgdmFyIE5PREVfSlMgPSAhcm9vdC5KU19TSEEzX05PX05PREVfSlMgJiYgdHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmIHByb2Nlc3MudmVyc2lvbnMgJiYgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlO1xyXG5cdCAgaWYgKE5PREVfSlMpIHtcclxuXHQgICAgcm9vdCA9IGNvbW1vbmpzR2xvYmFsO1xyXG5cdCAgfVxyXG5cdCAgdmFyIENPTU1PTl9KUyA9ICFyb290LkpTX1NIQTNfTk9fQ09NTU9OX0pTICYmICdvYmplY3QnID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cztcclxuXHQgIHZhciBIRVhfQ0hBUlMgPSAnMDEyMzQ1Njc4OWFiY2RlZicuc3BsaXQoJycpO1xyXG5cdCAgdmFyIFNIQUtFX1BBRERJTkcgPSBbMzEsIDc5MzYsIDIwMzE2MTYsIDUyMDA5MzY5Nl07XHJcblx0ICB2YXIgS0VDQ0FLX1BBRERJTkcgPSBbMSwgMjU2LCA2NTUzNiwgMTY3NzcyMTZdO1xyXG5cdCAgdmFyIFBBRERJTkcgPSBbNiwgMTUzNiwgMzkzMjE2LCAxMDA2NjMyOTZdO1xyXG5cdCAgdmFyIFNISUZUID0gWzAsIDgsIDE2LCAyNF07XHJcblx0ICB2YXIgUkMgPSBbMSwgMCwgMzI4OTgsIDAsIDMyOTA2LCAyMTQ3NDgzNjQ4LCAyMTQ3NTE2NDE2LCAyMTQ3NDgzNjQ4LCAzMjkwNywgMCwgMjE0NzQ4MzY0OSxcclxuXHQgICAgICAgICAgICAwLCAyMTQ3NTE2NTQ1LCAyMTQ3NDgzNjQ4LCAzMjc3NywgMjE0NzQ4MzY0OCwgMTM4LCAwLCAxMzYsIDAsIDIxNDc1MTY0MjUsIDAsXHJcblx0ICAgICAgICAgICAgMjE0NzQ4MzY1OCwgMCwgMjE0NzUxNjU1NSwgMCwgMTM5LCAyMTQ3NDgzNjQ4LCAzMjkwNSwgMjE0NzQ4MzY0OCwgMzI3NzEsXHJcblx0ICAgICAgICAgICAgMjE0NzQ4MzY0OCwgMzI3NzAsIDIxNDc0ODM2NDgsIDEyOCwgMjE0NzQ4MzY0OCwgMzI3NzgsIDAsIDIxNDc0ODM2NTgsIDIxNDc0ODM2NDgsXHJcblx0ICAgICAgICAgICAgMjE0NzUxNjU0NSwgMjE0NzQ4MzY0OCwgMzI4OTYsIDIxNDc0ODM2NDgsIDIxNDc0ODM2NDksIDAsIDIxNDc1MTY0MjQsIDIxNDc0ODM2NDhdO1xyXG5cdCAgdmFyIEJJVFMgPSBbMjI0LCAyNTYsIDM4NCwgNTEyXTtcclxuXHQgIHZhciBTSEFLRV9CSVRTID0gWzEyOCwgMjU2XTtcclxuXHQgIHZhciBPVVRQVVRfVFlQRVMgPSBbJ2hleCcsICdidWZmZXInLCAnYXJyYXlCdWZmZXInLCAnYXJyYXknXTtcclxuXHJcblx0ICB2YXIgY3JlYXRlT3V0cHV0TWV0aG9kID0gZnVuY3Rpb24gKGJpdHMsIHBhZGRpbmcsIG91dHB1dFR5cGUpIHtcclxuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIChtZXNzYWdlKSB7XHJcblx0ICAgICAgcmV0dXJuIG5ldyBLZWNjYWsoYml0cywgcGFkZGluZywgYml0cykudXBkYXRlKG1lc3NhZ2UpW291dHB1dFR5cGVdKCk7XHJcblx0ICAgIH07XHJcblx0ICB9O1xyXG5cclxuXHQgIHZhciBjcmVhdGVTaGFrZU91dHB1dE1ldGhvZCA9IGZ1bmN0aW9uIChiaXRzLCBwYWRkaW5nLCBvdXRwdXRUeXBlKSB7XHJcblx0ICAgIHJldHVybiBmdW5jdGlvbiAobWVzc2FnZSwgb3V0cHV0Qml0cykge1xyXG5cdCAgICAgIHJldHVybiBuZXcgS2VjY2FrKGJpdHMsIHBhZGRpbmcsIG91dHB1dEJpdHMpLnVwZGF0ZShtZXNzYWdlKVtvdXRwdXRUeXBlXSgpO1xyXG5cdCAgICB9O1xyXG5cdCAgfTtcclxuXHJcblx0ICB2YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKGJpdHMsIHBhZGRpbmcpIHtcclxuXHQgICAgdmFyIG1ldGhvZCA9IGNyZWF0ZU91dHB1dE1ldGhvZChiaXRzLCBwYWRkaW5nLCAnaGV4Jyk7XHJcblx0ICAgIG1ldGhvZC5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgcmV0dXJuIG5ldyBLZWNjYWsoYml0cywgcGFkZGluZywgYml0cyk7XHJcblx0ICAgIH07XHJcblx0ICAgIG1ldGhvZC51cGRhdGUgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xyXG5cdCAgICAgIHJldHVybiBtZXRob2QuY3JlYXRlKCkudXBkYXRlKG1lc3NhZ2UpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IE9VVFBVVF9UWVBFUy5sZW5ndGg7ICsraSkge1xyXG5cdCAgICAgIHZhciB0eXBlID0gT1VUUFVUX1RZUEVTW2ldO1xyXG5cdCAgICAgIG1ldGhvZFt0eXBlXSA9IGNyZWF0ZU91dHB1dE1ldGhvZChiaXRzLCBwYWRkaW5nLCB0eXBlKTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gbWV0aG9kO1xyXG5cdCAgfTtcclxuXHJcblx0ICB2YXIgY3JlYXRlU2hha2VNZXRob2QgPSBmdW5jdGlvbiAoYml0cywgcGFkZGluZykge1xyXG5cdCAgICB2YXIgbWV0aG9kID0gY3JlYXRlU2hha2VPdXRwdXRNZXRob2QoYml0cywgcGFkZGluZywgJ2hleCcpO1xyXG5cdCAgICBtZXRob2QuY3JlYXRlID0gZnVuY3Rpb24gKG91dHB1dEJpdHMpIHtcclxuXHQgICAgICByZXR1cm4gbmV3IEtlY2NhayhiaXRzLCBwYWRkaW5nLCBvdXRwdXRCaXRzKTtcclxuXHQgICAgfTtcclxuXHQgICAgbWV0aG9kLnVwZGF0ZSA9IGZ1bmN0aW9uIChtZXNzYWdlLCBvdXRwdXRCaXRzKSB7XHJcblx0ICAgICAgcmV0dXJuIG1ldGhvZC5jcmVhdGUob3V0cHV0Qml0cykudXBkYXRlKG1lc3NhZ2UpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IE9VVFBVVF9UWVBFUy5sZW5ndGg7ICsraSkge1xyXG5cdCAgICAgIHZhciB0eXBlID0gT1VUUFVUX1RZUEVTW2ldO1xyXG5cdCAgICAgIG1ldGhvZFt0eXBlXSA9IGNyZWF0ZVNoYWtlT3V0cHV0TWV0aG9kKGJpdHMsIHBhZGRpbmcsIHR5cGUpO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBtZXRob2Q7XHJcblx0ICB9O1xyXG5cclxuXHQgIHZhciBhbGdvcml0aG1zID0gW1xyXG5cdCAgICB7bmFtZTogJ2tlY2NhaycsIHBhZGRpbmc6IEtFQ0NBS19QQURESU5HLCBiaXRzOiBCSVRTLCBjcmVhdGVNZXRob2Q6IGNyZWF0ZU1ldGhvZH0sXHJcblx0ICAgIHtuYW1lOiAnc2hhMycsIHBhZGRpbmc6IFBBRERJTkcsIGJpdHM6IEJJVFMsIGNyZWF0ZU1ldGhvZDogY3JlYXRlTWV0aG9kfSxcclxuXHQgICAge25hbWU6ICdzaGFrZScsIHBhZGRpbmc6IFNIQUtFX1BBRERJTkcsIGJpdHM6IFNIQUtFX0JJVFMsIGNyZWF0ZU1ldGhvZDogY3JlYXRlU2hha2VNZXRob2R9XHJcblx0ICBdO1xyXG5cclxuXHQgIHZhciBtZXRob2RzID0ge30sIG1ldGhvZE5hbWVzID0gW107XHJcblxyXG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGdvcml0aG1zLmxlbmd0aDsgKytpKSB7XHJcblx0ICAgIHZhciBhbGdvcml0aG0gPSBhbGdvcml0aG1zW2ldO1xyXG5cdCAgICB2YXIgYml0cyAgPSBhbGdvcml0aG0uYml0cztcclxuXHQgICAgZm9yICh2YXIgaiA9IDA7IGogPCBiaXRzLmxlbmd0aDsgKytqKSB7XHJcblx0ICAgICAgdmFyIG1ldGhvZE5hbWUgPSBhbGdvcml0aG0ubmFtZSArJ18nICsgYml0c1tqXTtcclxuXHQgICAgICBtZXRob2ROYW1lcy5wdXNoKG1ldGhvZE5hbWUpO1xyXG5cdCAgICAgIG1ldGhvZHNbbWV0aG9kTmFtZV0gPSBhbGdvcml0aG0uY3JlYXRlTWV0aG9kKGJpdHNbal0sIGFsZ29yaXRobS5wYWRkaW5nKTtcclxuXHQgICAgfVxyXG5cdCAgfVxyXG5cclxuXHQgIGZ1bmN0aW9uIEtlY2NhayhiaXRzLCBwYWRkaW5nLCBvdXRwdXRCaXRzKSB7XHJcblx0ICAgIHRoaXMuYmxvY2tzID0gW107XHJcblx0ICAgIHRoaXMucyA9IFtdO1xyXG5cdCAgICB0aGlzLnBhZGRpbmcgPSBwYWRkaW5nO1xyXG5cdCAgICB0aGlzLm91dHB1dEJpdHMgPSBvdXRwdXRCaXRzO1xyXG5cdCAgICB0aGlzLnJlc2V0ID0gdHJ1ZTtcclxuXHQgICAgdGhpcy5ibG9jayA9IDA7XHJcblx0ICAgIHRoaXMuc3RhcnQgPSAwO1xyXG5cdCAgICB0aGlzLmJsb2NrQ291bnQgPSAoMTYwMCAtIChiaXRzIDw8IDEpKSA+PiA1O1xyXG5cdCAgICB0aGlzLmJ5dGVDb3VudCA9IHRoaXMuYmxvY2tDb3VudCA8PCAyO1xyXG5cdCAgICB0aGlzLm91dHB1dEJsb2NrcyA9IG91dHB1dEJpdHMgPj4gNTtcclxuXHQgICAgdGhpcy5leHRyYUJ5dGVzID0gKG91dHB1dEJpdHMgJiAzMSkgPj4gMztcclxuXHJcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNTA7ICsraSkge1xyXG5cdCAgICAgIHRoaXMuc1tpXSA9IDA7XHJcblx0ICAgIH1cclxuXHQgIH1cclxuXHJcblx0ICBLZWNjYWsucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XHJcblx0ICAgIHZhciBub3RTdHJpbmcgPSB0eXBlb2YgbWVzc2FnZSAhPT0gJ3N0cmluZyc7XHJcblx0ICAgIGlmIChub3RTdHJpbmcgJiYgbWVzc2FnZS5jb25zdHJ1Y3RvciA9PT0gQXJyYXlCdWZmZXIpIHtcclxuXHQgICAgICBtZXNzYWdlID0gbmV3IFVpbnQ4QXJyYXkobWVzc2FnZSk7XHJcblx0ICAgIH1cclxuXHQgICAgdmFyIGxlbmd0aCA9IG1lc3NhZ2UubGVuZ3RoLCBibG9ja3MgPSB0aGlzLmJsb2NrcywgYnl0ZUNvdW50ID0gdGhpcy5ieXRlQ291bnQsXHJcblx0ICAgICAgYmxvY2tDb3VudCA9IHRoaXMuYmxvY2tDb3VudCwgaW5kZXggPSAwLCBzID0gdGhpcy5zLCBpLCBjb2RlO1xyXG5cclxuXHQgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XHJcblx0ICAgICAgaWYgKHRoaXMucmVzZXQpIHtcclxuXHQgICAgICAgIHRoaXMucmVzZXQgPSBmYWxzZTtcclxuXHQgICAgICAgIGJsb2Nrc1swXSA9IHRoaXMuYmxvY2s7XHJcblx0ICAgICAgICBmb3IgKGkgPSAxOyBpIDwgYmxvY2tDb3VudCArIDE7ICsraSkge1xyXG5cdCAgICAgICAgICBibG9ja3NbaV0gPSAwO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgIH1cclxuXHQgICAgICBpZiAobm90U3RyaW5nKSB7XHJcblx0ICAgICAgICBmb3IgKGkgPSB0aGlzLnN0YXJ0OyBpbmRleCA8IGxlbmd0aCAmJiBpIDwgYnl0ZUNvdW50OyArK2luZGV4KSB7XHJcblx0ICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9IG1lc3NhZ2VbaW5kZXhdIDw8IFNISUZUW2krKyAmIDNdO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICBmb3IgKGkgPSB0aGlzLnN0YXJ0OyBpbmRleCA8IGxlbmd0aCAmJiBpIDwgYnl0ZUNvdW50OyArK2luZGV4KSB7XHJcblx0ICAgICAgICAgIGNvZGUgPSBtZXNzYWdlLmNoYXJDb2RlQXQoaW5kZXgpO1xyXG5cdCAgICAgICAgICBpZiAoY29kZSA8IDB4ODApIHtcclxuXHQgICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSBjb2RlIDw8IFNISUZUW2krKyAmIDNdO1xyXG5cdCAgICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPCAweDgwMCkge1xyXG5cdCAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweGMwIHwgKGNvZGUgPj4gNikpIDw8IFNISUZUW2krKyAmIDNdO1xyXG5cdCAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKGNvZGUgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XHJcblx0ICAgICAgICAgIH0gZWxzZSBpZiAoY29kZSA8IDB4ZDgwMCB8fCBjb2RlID49IDB4ZTAwMCkge1xyXG5cdCAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweGUwIHwgKGNvZGUgPj4gMTIpKSA8PCBTSElGVFtpKysgJiAzXTtcclxuXHQgICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8ICgoY29kZSA+PiA2KSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcclxuXHQgICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8IChjb2RlICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xyXG5cdCAgICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAgIGNvZGUgPSAweDEwMDAwICsgKCgoY29kZSAmIDB4M2ZmKSA8PCAxMCkgfCAobWVzc2FnZS5jaGFyQ29kZUF0KCsraW5kZXgpICYgMHgzZmYpKTtcclxuXHQgICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHhmMCB8IChjb2RlID4+IDE4KSkgPDwgU0hJRlRbaSsrICYgM107XHJcblx0ICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ODAgfCAoKGNvZGUgPj4gMTIpICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xyXG5cdCAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKChjb2RlID4+IDYpICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xyXG5cdCAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKGNvZGUgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XHJcblx0ICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICB9XHJcblx0ICAgICAgdGhpcy5sYXN0Qnl0ZUluZGV4ID0gaTtcclxuXHQgICAgICBpZiAoaSA+PSBieXRlQ291bnQpIHtcclxuXHQgICAgICAgIHRoaXMuc3RhcnQgPSBpIC0gYnl0ZUNvdW50O1xyXG5cdCAgICAgICAgdGhpcy5ibG9jayA9IGJsb2Nrc1tibG9ja0NvdW50XTtcclxuXHQgICAgICAgIGZvciAoaSA9IDA7IGkgPCBibG9ja0NvdW50OyArK2kpIHtcclxuXHQgICAgICAgICAgc1tpXSBePSBibG9ja3NbaV07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBmKHMpO1xyXG5cdCAgICAgICAgdGhpcy5yZXNldCA9IHRydWU7XHJcblx0ICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgIHRoaXMuc3RhcnQgPSBpO1xyXG5cdCAgICAgIH1cclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gdGhpcztcclxuXHQgIH07XHJcblxyXG5cdCAgS2VjY2FrLnByb3RvdHlwZS5maW5hbGl6ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgdmFyIGJsb2NrcyA9IHRoaXMuYmxvY2tzLCBpID0gdGhpcy5sYXN0Qnl0ZUluZGV4LCBibG9ja0NvdW50ID0gdGhpcy5ibG9ja0NvdW50LCBzID0gdGhpcy5zO1xyXG5cdCAgICBibG9ja3NbaSA+PiAyXSB8PSB0aGlzLnBhZGRpbmdbaSAmIDNdO1xyXG5cdCAgICBpZiAodGhpcy5sYXN0Qnl0ZUluZGV4ID09PSB0aGlzLmJ5dGVDb3VudCkge1xyXG5cdCAgICAgIGJsb2Nrc1swXSA9IGJsb2Nrc1tibG9ja0NvdW50XTtcclxuXHQgICAgICBmb3IgKGkgPSAxOyBpIDwgYmxvY2tDb3VudCArIDE7ICsraSkge1xyXG5cdCAgICAgICAgYmxvY2tzW2ldID0gMDtcclxuXHQgICAgICB9XHJcblx0ICAgIH1cclxuXHQgICAgYmxvY2tzW2Jsb2NrQ291bnQgLSAxXSB8PSAweDgwMDAwMDAwO1xyXG5cdCAgICBmb3IgKGkgPSAwOyBpIDwgYmxvY2tDb3VudDsgKytpKSB7XHJcblx0ICAgICAgc1tpXSBePSBibG9ja3NbaV07XHJcblx0ICAgIH1cclxuXHQgICAgZihzKTtcclxuXHQgIH07XHJcblxyXG5cdCAgS2VjY2FrLnByb3RvdHlwZS50b1N0cmluZyA9IEtlY2Nhay5wcm90b3R5cGUuaGV4ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICB0aGlzLmZpbmFsaXplKCk7XHJcblxyXG5cdCAgICB2YXIgYmxvY2tDb3VudCA9IHRoaXMuYmxvY2tDb3VudCwgcyA9IHRoaXMucywgb3V0cHV0QmxvY2tzID0gdGhpcy5vdXRwdXRCbG9ja3MsXHJcblx0ICAgICAgICBleHRyYUJ5dGVzID0gdGhpcy5leHRyYUJ5dGVzLCBpID0gMCwgaiA9IDA7XHJcblx0ICAgIHZhciBoZXggPSAnJywgYmxvY2s7XHJcblx0ICAgIHdoaWxlIChqIDwgb3V0cHV0QmxvY2tzKSB7XHJcblx0ICAgICAgZm9yIChpID0gMDsgaSA8IGJsb2NrQ291bnQgJiYgaiA8IG91dHB1dEJsb2NrczsgKytpLCArK2opIHtcclxuXHQgICAgICAgIGJsb2NrID0gc1tpXTtcclxuXHQgICAgICAgIGhleCArPSBIRVhfQ0hBUlNbKGJsb2NrID4+IDQpICYgMHgwRl0gKyBIRVhfQ0hBUlNbYmxvY2sgJiAweDBGXSArXHJcblx0ICAgICAgICAgICAgICAgSEVYX0NIQVJTWyhibG9jayA+PiAxMikgJiAweDBGXSArIEhFWF9DSEFSU1soYmxvY2sgPj4gOCkgJiAweDBGXSArXHJcblx0ICAgICAgICAgICAgICAgSEVYX0NIQVJTWyhibG9jayA+PiAyMCkgJiAweDBGXSArIEhFWF9DSEFSU1soYmxvY2sgPj4gMTYpICYgMHgwRl0gK1xyXG5cdCAgICAgICAgICAgICAgIEhFWF9DSEFSU1soYmxvY2sgPj4gMjgpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGJsb2NrID4+IDI0KSAmIDB4MEZdO1xyXG5cdCAgICAgIH1cclxuXHQgICAgICBpZiAoaiAlIGJsb2NrQ291bnQgPT09IDApIHtcclxuXHQgICAgICAgIGYocyk7XHJcblx0ICAgICAgICBpID0gMDtcclxuXHQgICAgICB9XHJcblx0ICAgIH1cclxuXHQgICAgaWYgKGV4dHJhQnl0ZXMpIHtcclxuXHQgICAgICBibG9jayA9IHNbaV07XHJcblx0ICAgICAgaWYgKGV4dHJhQnl0ZXMgPiAwKSB7XHJcblx0ICAgICAgICBoZXggKz0gSEVYX0NIQVJTWyhibG9jayA+PiA0KSAmIDB4MEZdICsgSEVYX0NIQVJTW2Jsb2NrICYgMHgwRl07XHJcblx0ICAgICAgfVxyXG5cdCAgICAgIGlmIChleHRyYUJ5dGVzID4gMSkge1xyXG5cdCAgICAgICAgaGV4ICs9IEhFWF9DSEFSU1soYmxvY2sgPj4gMTIpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGJsb2NrID4+IDgpICYgMHgwRl07XHJcblx0ICAgICAgfVxyXG5cdCAgICAgIGlmIChleHRyYUJ5dGVzID4gMikge1xyXG5cdCAgICAgICAgaGV4ICs9IEhFWF9DSEFSU1soYmxvY2sgPj4gMjApICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGJsb2NrID4+IDE2KSAmIDB4MEZdO1xyXG5cdCAgICAgIH1cclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gaGV4O1xyXG5cdCAgfTtcclxuXHJcblx0ICBLZWNjYWsucHJvdG90eXBlLmFycmF5QnVmZmVyID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICB0aGlzLmZpbmFsaXplKCk7XHJcblxyXG5cdCAgICB2YXIgYmxvY2tDb3VudCA9IHRoaXMuYmxvY2tDb3VudCwgcyA9IHRoaXMucywgb3V0cHV0QmxvY2tzID0gdGhpcy5vdXRwdXRCbG9ja3MsXHJcblx0ICAgICAgICBleHRyYUJ5dGVzID0gdGhpcy5leHRyYUJ5dGVzLCBpID0gMCwgaiA9IDA7XHJcblx0ICAgIHZhciBieXRlcyA9IHRoaXMub3V0cHV0Qml0cyA+PiAzO1xyXG5cdCAgICB2YXIgYnVmZmVyO1xyXG5cdCAgICBpZiAoZXh0cmFCeXRlcykge1xyXG5cdCAgICAgIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcigob3V0cHV0QmxvY2tzICsgMSkgPDwgMik7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgICAgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ5dGVzKTtcclxuXHQgICAgfVxyXG5cdCAgICB2YXIgYXJyYXkgPSBuZXcgVWludDMyQXJyYXkoYnVmZmVyKTtcclxuXHQgICAgd2hpbGUgKGogPCBvdXRwdXRCbG9ja3MpIHtcclxuXHQgICAgICBmb3IgKGkgPSAwOyBpIDwgYmxvY2tDb3VudCAmJiBqIDwgb3V0cHV0QmxvY2tzOyArK2ksICsraikge1xyXG5cdCAgICAgICAgYXJyYXlbal0gPSBzW2ldO1xyXG5cdCAgICAgIH1cclxuXHQgICAgICBpZiAoaiAlIGJsb2NrQ291bnQgPT09IDApIHtcclxuXHQgICAgICAgIGYocyk7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9XHJcblx0ICAgIGlmIChleHRyYUJ5dGVzKSB7XHJcblx0ICAgICAgYXJyYXlbaV0gPSBzW2ldO1xyXG5cdCAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5zbGljZSgwLCBieXRlcyk7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIGJ1ZmZlcjtcclxuXHQgIH07XHJcblxyXG5cdCAgS2VjY2FrLnByb3RvdHlwZS5idWZmZXIgPSBLZWNjYWsucHJvdG90eXBlLmFycmF5QnVmZmVyO1xyXG5cclxuXHQgIEtlY2Nhay5wcm90b3R5cGUuZGlnZXN0ID0gS2VjY2FrLnByb3RvdHlwZS5hcnJheSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgdGhpcy5maW5hbGl6ZSgpO1xyXG5cclxuXHQgICAgdmFyIGJsb2NrQ291bnQgPSB0aGlzLmJsb2NrQ291bnQsIHMgPSB0aGlzLnMsIG91dHB1dEJsb2NrcyA9IHRoaXMub3V0cHV0QmxvY2tzLFxyXG5cdCAgICAgICAgZXh0cmFCeXRlcyA9IHRoaXMuZXh0cmFCeXRlcywgaSA9IDAsIGogPSAwO1xyXG5cdCAgICB2YXIgYXJyYXkgPSBbXSwgb2Zmc2V0LCBibG9jaztcclxuXHQgICAgd2hpbGUgKGogPCBvdXRwdXRCbG9ja3MpIHtcclxuXHQgICAgICBmb3IgKGkgPSAwOyBpIDwgYmxvY2tDb3VudCAmJiBqIDwgb3V0cHV0QmxvY2tzOyArK2ksICsraikge1xyXG5cdCAgICAgICAgb2Zmc2V0ID0gaiA8PCAyO1xyXG5cdCAgICAgICAgYmxvY2sgPSBzW2ldO1xyXG5cdCAgICAgICAgYXJyYXlbb2Zmc2V0XSA9IGJsb2NrICYgMHhGRjtcclxuXHQgICAgICAgIGFycmF5W29mZnNldCArIDFdID0gKGJsb2NrID4+IDgpICYgMHhGRjtcclxuXHQgICAgICAgIGFycmF5W29mZnNldCArIDJdID0gKGJsb2NrID4+IDE2KSAmIDB4RkY7XHJcblx0ICAgICAgICBhcnJheVtvZmZzZXQgKyAzXSA9IChibG9jayA+PiAyNCkgJiAweEZGO1xyXG5cdCAgICAgIH1cclxuXHQgICAgICBpZiAoaiAlIGJsb2NrQ291bnQgPT09IDApIHtcclxuXHQgICAgICAgIGYocyk7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9XHJcblx0ICAgIGlmIChleHRyYUJ5dGVzKSB7XHJcblx0ICAgICAgb2Zmc2V0ID0gaiA8PCAyO1xyXG5cdCAgICAgIGJsb2NrID0gc1tpXTtcclxuXHQgICAgICBpZiAoZXh0cmFCeXRlcyA+IDApIHtcclxuXHQgICAgICAgIGFycmF5W29mZnNldF0gPSBibG9jayAmIDB4RkY7XHJcblx0ICAgICAgfVxyXG5cdCAgICAgIGlmIChleHRyYUJ5dGVzID4gMSkge1xyXG5cdCAgICAgICAgYXJyYXlbb2Zmc2V0ICsgMV0gPSAoYmxvY2sgPj4gOCkgJiAweEZGO1xyXG5cdCAgICAgIH1cclxuXHQgICAgICBpZiAoZXh0cmFCeXRlcyA+IDIpIHtcclxuXHQgICAgICAgIGFycmF5W29mZnNldCArIDJdID0gKGJsb2NrID4+IDE2KSAmIDB4RkY7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBhcnJheTtcclxuXHQgIH07XHJcblxyXG5cdCAgdmFyIGYgPSBmdW5jdGlvbiAocykge1xyXG5cdCAgICB2YXIgaCwgbCwgbiwgYzAsIGMxLCBjMiwgYzMsIGM0LCBjNSwgYzYsIGM3LCBjOCwgYzksXHJcblx0ICAgICAgICBiMCwgYjEsIGIyLCBiMywgYjQsIGI1LCBiNiwgYjcsIGI4LCBiOSwgYjEwLCBiMTEsIGIxMiwgYjEzLCBiMTQsIGIxNSwgYjE2LCBiMTcsXHJcblx0ICAgICAgICBiMTgsIGIxOSwgYjIwLCBiMjEsIGIyMiwgYjIzLCBiMjQsIGIyNSwgYjI2LCBiMjcsIGIyOCwgYjI5LCBiMzAsIGIzMSwgYjMyLCBiMzMsXHJcblx0ICAgICAgICBiMzQsIGIzNSwgYjM2LCBiMzcsIGIzOCwgYjM5LCBiNDAsIGI0MSwgYjQyLCBiNDMsIGI0NCwgYjQ1LCBiNDYsIGI0NywgYjQ4LCBiNDk7XHJcblx0ICAgIGZvciAobiA9IDA7IG4gPCA0ODsgbiArPSAyKSB7XHJcblx0ICAgICAgYzAgPSBzWzBdIF4gc1sxMF0gXiBzWzIwXSBeIHNbMzBdIF4gc1s0MF07XHJcblx0ICAgICAgYzEgPSBzWzFdIF4gc1sxMV0gXiBzWzIxXSBeIHNbMzFdIF4gc1s0MV07XHJcblx0ICAgICAgYzIgPSBzWzJdIF4gc1sxMl0gXiBzWzIyXSBeIHNbMzJdIF4gc1s0Ml07XHJcblx0ICAgICAgYzMgPSBzWzNdIF4gc1sxM10gXiBzWzIzXSBeIHNbMzNdIF4gc1s0M107XHJcblx0ICAgICAgYzQgPSBzWzRdIF4gc1sxNF0gXiBzWzI0XSBeIHNbMzRdIF4gc1s0NF07XHJcblx0ICAgICAgYzUgPSBzWzVdIF4gc1sxNV0gXiBzWzI1XSBeIHNbMzVdIF4gc1s0NV07XHJcblx0ICAgICAgYzYgPSBzWzZdIF4gc1sxNl0gXiBzWzI2XSBeIHNbMzZdIF4gc1s0Nl07XHJcblx0ICAgICAgYzcgPSBzWzddIF4gc1sxN10gXiBzWzI3XSBeIHNbMzddIF4gc1s0N107XHJcblx0ICAgICAgYzggPSBzWzhdIF4gc1sxOF0gXiBzWzI4XSBeIHNbMzhdIF4gc1s0OF07XHJcblx0ICAgICAgYzkgPSBzWzldIF4gc1sxOV0gXiBzWzI5XSBeIHNbMzldIF4gc1s0OV07XHJcblxyXG5cdCAgICAgIGggPSBjOCBeICgoYzIgPDwgMSkgfCAoYzMgPj4+IDMxKSk7XHJcblx0ICAgICAgbCA9IGM5IF4gKChjMyA8PCAxKSB8IChjMiA+Pj4gMzEpKTtcclxuXHQgICAgICBzWzBdIF49IGg7XHJcblx0ICAgICAgc1sxXSBePSBsO1xyXG5cdCAgICAgIHNbMTBdIF49IGg7XHJcblx0ICAgICAgc1sxMV0gXj0gbDtcclxuXHQgICAgICBzWzIwXSBePSBoO1xyXG5cdCAgICAgIHNbMjFdIF49IGw7XHJcblx0ICAgICAgc1szMF0gXj0gaDtcclxuXHQgICAgICBzWzMxXSBePSBsO1xyXG5cdCAgICAgIHNbNDBdIF49IGg7XHJcblx0ICAgICAgc1s0MV0gXj0gbDtcclxuXHQgICAgICBoID0gYzAgXiAoKGM0IDw8IDEpIHwgKGM1ID4+PiAzMSkpO1xyXG5cdCAgICAgIGwgPSBjMSBeICgoYzUgPDwgMSkgfCAoYzQgPj4+IDMxKSk7XHJcblx0ICAgICAgc1syXSBePSBoO1xyXG5cdCAgICAgIHNbM10gXj0gbDtcclxuXHQgICAgICBzWzEyXSBePSBoO1xyXG5cdCAgICAgIHNbMTNdIF49IGw7XHJcblx0ICAgICAgc1syMl0gXj0gaDtcclxuXHQgICAgICBzWzIzXSBePSBsO1xyXG5cdCAgICAgIHNbMzJdIF49IGg7XHJcblx0ICAgICAgc1szM10gXj0gbDtcclxuXHQgICAgICBzWzQyXSBePSBoO1xyXG5cdCAgICAgIHNbNDNdIF49IGw7XHJcblx0ICAgICAgaCA9IGMyIF4gKChjNiA8PCAxKSB8IChjNyA+Pj4gMzEpKTtcclxuXHQgICAgICBsID0gYzMgXiAoKGM3IDw8IDEpIHwgKGM2ID4+PiAzMSkpO1xyXG5cdCAgICAgIHNbNF0gXj0gaDtcclxuXHQgICAgICBzWzVdIF49IGw7XHJcblx0ICAgICAgc1sxNF0gXj0gaDtcclxuXHQgICAgICBzWzE1XSBePSBsO1xyXG5cdCAgICAgIHNbMjRdIF49IGg7XHJcblx0ICAgICAgc1syNV0gXj0gbDtcclxuXHQgICAgICBzWzM0XSBePSBoO1xyXG5cdCAgICAgIHNbMzVdIF49IGw7XHJcblx0ICAgICAgc1s0NF0gXj0gaDtcclxuXHQgICAgICBzWzQ1XSBePSBsO1xyXG5cdCAgICAgIGggPSBjNCBeICgoYzggPDwgMSkgfCAoYzkgPj4+IDMxKSk7XHJcblx0ICAgICAgbCA9IGM1IF4gKChjOSA8PCAxKSB8IChjOCA+Pj4gMzEpKTtcclxuXHQgICAgICBzWzZdIF49IGg7XHJcblx0ICAgICAgc1s3XSBePSBsO1xyXG5cdCAgICAgIHNbMTZdIF49IGg7XHJcblx0ICAgICAgc1sxN10gXj0gbDtcclxuXHQgICAgICBzWzI2XSBePSBoO1xyXG5cdCAgICAgIHNbMjddIF49IGw7XHJcblx0ICAgICAgc1szNl0gXj0gaDtcclxuXHQgICAgICBzWzM3XSBePSBsO1xyXG5cdCAgICAgIHNbNDZdIF49IGg7XHJcblx0ICAgICAgc1s0N10gXj0gbDtcclxuXHQgICAgICBoID0gYzYgXiAoKGMwIDw8IDEpIHwgKGMxID4+PiAzMSkpO1xyXG5cdCAgICAgIGwgPSBjNyBeICgoYzEgPDwgMSkgfCAoYzAgPj4+IDMxKSk7XHJcblx0ICAgICAgc1s4XSBePSBoO1xyXG5cdCAgICAgIHNbOV0gXj0gbDtcclxuXHQgICAgICBzWzE4XSBePSBoO1xyXG5cdCAgICAgIHNbMTldIF49IGw7XHJcblx0ICAgICAgc1syOF0gXj0gaDtcclxuXHQgICAgICBzWzI5XSBePSBsO1xyXG5cdCAgICAgIHNbMzhdIF49IGg7XHJcblx0ICAgICAgc1szOV0gXj0gbDtcclxuXHQgICAgICBzWzQ4XSBePSBoO1xyXG5cdCAgICAgIHNbNDldIF49IGw7XHJcblxyXG5cdCAgICAgIGIwID0gc1swXTtcclxuXHQgICAgICBiMSA9IHNbMV07XHJcblx0ICAgICAgYjMyID0gKHNbMTFdIDw8IDQpIHwgKHNbMTBdID4+PiAyOCk7XHJcblx0ICAgICAgYjMzID0gKHNbMTBdIDw8IDQpIHwgKHNbMTFdID4+PiAyOCk7XHJcblx0ICAgICAgYjE0ID0gKHNbMjBdIDw8IDMpIHwgKHNbMjFdID4+PiAyOSk7XHJcblx0ICAgICAgYjE1ID0gKHNbMjFdIDw8IDMpIHwgKHNbMjBdID4+PiAyOSk7XHJcblx0ICAgICAgYjQ2ID0gKHNbMzFdIDw8IDkpIHwgKHNbMzBdID4+PiAyMyk7XHJcblx0ICAgICAgYjQ3ID0gKHNbMzBdIDw8IDkpIHwgKHNbMzFdID4+PiAyMyk7XHJcblx0ICAgICAgYjI4ID0gKHNbNDBdIDw8IDE4KSB8IChzWzQxXSA+Pj4gMTQpO1xyXG5cdCAgICAgIGIyOSA9IChzWzQxXSA8PCAxOCkgfCAoc1s0MF0gPj4+IDE0KTtcclxuXHQgICAgICBiMjAgPSAoc1syXSA8PCAxKSB8IChzWzNdID4+PiAzMSk7XHJcblx0ICAgICAgYjIxID0gKHNbM10gPDwgMSkgfCAoc1syXSA+Pj4gMzEpO1xyXG5cdCAgICAgIGIyID0gKHNbMTNdIDw8IDEyKSB8IChzWzEyXSA+Pj4gMjApO1xyXG5cdCAgICAgIGIzID0gKHNbMTJdIDw8IDEyKSB8IChzWzEzXSA+Pj4gMjApO1xyXG5cdCAgICAgIGIzNCA9IChzWzIyXSA8PCAxMCkgfCAoc1syM10gPj4+IDIyKTtcclxuXHQgICAgICBiMzUgPSAoc1syM10gPDwgMTApIHwgKHNbMjJdID4+PiAyMik7XHJcblx0ICAgICAgYjE2ID0gKHNbMzNdIDw8IDEzKSB8IChzWzMyXSA+Pj4gMTkpO1xyXG5cdCAgICAgIGIxNyA9IChzWzMyXSA8PCAxMykgfCAoc1szM10gPj4+IDE5KTtcclxuXHQgICAgICBiNDggPSAoc1s0Ml0gPDwgMikgfCAoc1s0M10gPj4+IDMwKTtcclxuXHQgICAgICBiNDkgPSAoc1s0M10gPDwgMikgfCAoc1s0Ml0gPj4+IDMwKTtcclxuXHQgICAgICBiNDAgPSAoc1s1XSA8PCAzMCkgfCAoc1s0XSA+Pj4gMik7XHJcblx0ICAgICAgYjQxID0gKHNbNF0gPDwgMzApIHwgKHNbNV0gPj4+IDIpO1xyXG5cdCAgICAgIGIyMiA9IChzWzE0XSA8PCA2KSB8IChzWzE1XSA+Pj4gMjYpO1xyXG5cdCAgICAgIGIyMyA9IChzWzE1XSA8PCA2KSB8IChzWzE0XSA+Pj4gMjYpO1xyXG5cdCAgICAgIGI0ID0gKHNbMjVdIDw8IDExKSB8IChzWzI0XSA+Pj4gMjEpO1xyXG5cdCAgICAgIGI1ID0gKHNbMjRdIDw8IDExKSB8IChzWzI1XSA+Pj4gMjEpO1xyXG5cdCAgICAgIGIzNiA9IChzWzM0XSA8PCAxNSkgfCAoc1szNV0gPj4+IDE3KTtcclxuXHQgICAgICBiMzcgPSAoc1szNV0gPDwgMTUpIHwgKHNbMzRdID4+PiAxNyk7XHJcblx0ICAgICAgYjE4ID0gKHNbNDVdIDw8IDI5KSB8IChzWzQ0XSA+Pj4gMyk7XHJcblx0ICAgICAgYjE5ID0gKHNbNDRdIDw8IDI5KSB8IChzWzQ1XSA+Pj4gMyk7XHJcblx0ICAgICAgYjEwID0gKHNbNl0gPDwgMjgpIHwgKHNbN10gPj4+IDQpO1xyXG5cdCAgICAgIGIxMSA9IChzWzddIDw8IDI4KSB8IChzWzZdID4+PiA0KTtcclxuXHQgICAgICBiNDIgPSAoc1sxN10gPDwgMjMpIHwgKHNbMTZdID4+PiA5KTtcclxuXHQgICAgICBiNDMgPSAoc1sxNl0gPDwgMjMpIHwgKHNbMTddID4+PiA5KTtcclxuXHQgICAgICBiMjQgPSAoc1syNl0gPDwgMjUpIHwgKHNbMjddID4+PiA3KTtcclxuXHQgICAgICBiMjUgPSAoc1syN10gPDwgMjUpIHwgKHNbMjZdID4+PiA3KTtcclxuXHQgICAgICBiNiA9IChzWzM2XSA8PCAyMSkgfCAoc1szN10gPj4+IDExKTtcclxuXHQgICAgICBiNyA9IChzWzM3XSA8PCAyMSkgfCAoc1szNl0gPj4+IDExKTtcclxuXHQgICAgICBiMzggPSAoc1s0N10gPDwgMjQpIHwgKHNbNDZdID4+PiA4KTtcclxuXHQgICAgICBiMzkgPSAoc1s0Nl0gPDwgMjQpIHwgKHNbNDddID4+PiA4KTtcclxuXHQgICAgICBiMzAgPSAoc1s4XSA8PCAyNykgfCAoc1s5XSA+Pj4gNSk7XHJcblx0ICAgICAgYjMxID0gKHNbOV0gPDwgMjcpIHwgKHNbOF0gPj4+IDUpO1xyXG5cdCAgICAgIGIxMiA9IChzWzE4XSA8PCAyMCkgfCAoc1sxOV0gPj4+IDEyKTtcclxuXHQgICAgICBiMTMgPSAoc1sxOV0gPDwgMjApIHwgKHNbMThdID4+PiAxMik7XHJcblx0ICAgICAgYjQ0ID0gKHNbMjldIDw8IDcpIHwgKHNbMjhdID4+PiAyNSk7XHJcblx0ICAgICAgYjQ1ID0gKHNbMjhdIDw8IDcpIHwgKHNbMjldID4+PiAyNSk7XHJcblx0ICAgICAgYjI2ID0gKHNbMzhdIDw8IDgpIHwgKHNbMzldID4+PiAyNCk7XHJcblx0ICAgICAgYjI3ID0gKHNbMzldIDw8IDgpIHwgKHNbMzhdID4+PiAyNCk7XHJcblx0ICAgICAgYjggPSAoc1s0OF0gPDwgMTQpIHwgKHNbNDldID4+PiAxOCk7XHJcblx0ICAgICAgYjkgPSAoc1s0OV0gPDwgMTQpIHwgKHNbNDhdID4+PiAxOCk7XHJcblxyXG5cdCAgICAgIHNbMF0gPSBiMCBeICh+YjIgJiBiNCk7XHJcblx0ICAgICAgc1sxXSA9IGIxIF4gKH5iMyAmIGI1KTtcclxuXHQgICAgICBzWzEwXSA9IGIxMCBeICh+YjEyICYgYjE0KTtcclxuXHQgICAgICBzWzExXSA9IGIxMSBeICh+YjEzICYgYjE1KTtcclxuXHQgICAgICBzWzIwXSA9IGIyMCBeICh+YjIyICYgYjI0KTtcclxuXHQgICAgICBzWzIxXSA9IGIyMSBeICh+YjIzICYgYjI1KTtcclxuXHQgICAgICBzWzMwXSA9IGIzMCBeICh+YjMyICYgYjM0KTtcclxuXHQgICAgICBzWzMxXSA9IGIzMSBeICh+YjMzICYgYjM1KTtcclxuXHQgICAgICBzWzQwXSA9IGI0MCBeICh+YjQyICYgYjQ0KTtcclxuXHQgICAgICBzWzQxXSA9IGI0MSBeICh+YjQzICYgYjQ1KTtcclxuXHQgICAgICBzWzJdID0gYjIgXiAofmI0ICYgYjYpO1xyXG5cdCAgICAgIHNbM10gPSBiMyBeICh+YjUgJiBiNyk7XHJcblx0ICAgICAgc1sxMl0gPSBiMTIgXiAofmIxNCAmIGIxNik7XHJcblx0ICAgICAgc1sxM10gPSBiMTMgXiAofmIxNSAmIGIxNyk7XHJcblx0ICAgICAgc1syMl0gPSBiMjIgXiAofmIyNCAmIGIyNik7XHJcblx0ICAgICAgc1syM10gPSBiMjMgXiAofmIyNSAmIGIyNyk7XHJcblx0ICAgICAgc1szMl0gPSBiMzIgXiAofmIzNCAmIGIzNik7XHJcblx0ICAgICAgc1szM10gPSBiMzMgXiAofmIzNSAmIGIzNyk7XHJcblx0ICAgICAgc1s0Ml0gPSBiNDIgXiAofmI0NCAmIGI0Nik7XHJcblx0ICAgICAgc1s0M10gPSBiNDMgXiAofmI0NSAmIGI0Nyk7XHJcblx0ICAgICAgc1s0XSA9IGI0IF4gKH5iNiAmIGI4KTtcclxuXHQgICAgICBzWzVdID0gYjUgXiAofmI3ICYgYjkpO1xyXG5cdCAgICAgIHNbMTRdID0gYjE0IF4gKH5iMTYgJiBiMTgpO1xyXG5cdCAgICAgIHNbMTVdID0gYjE1IF4gKH5iMTcgJiBiMTkpO1xyXG5cdCAgICAgIHNbMjRdID0gYjI0IF4gKH5iMjYgJiBiMjgpO1xyXG5cdCAgICAgIHNbMjVdID0gYjI1IF4gKH5iMjcgJiBiMjkpO1xyXG5cdCAgICAgIHNbMzRdID0gYjM0IF4gKH5iMzYgJiBiMzgpO1xyXG5cdCAgICAgIHNbMzVdID0gYjM1IF4gKH5iMzcgJiBiMzkpO1xyXG5cdCAgICAgIHNbNDRdID0gYjQ0IF4gKH5iNDYgJiBiNDgpO1xyXG5cdCAgICAgIHNbNDVdID0gYjQ1IF4gKH5iNDcgJiBiNDkpO1xyXG5cdCAgICAgIHNbNl0gPSBiNiBeICh+YjggJiBiMCk7XHJcblx0ICAgICAgc1s3XSA9IGI3IF4gKH5iOSAmIGIxKTtcclxuXHQgICAgICBzWzE2XSA9IGIxNiBeICh+YjE4ICYgYjEwKTtcclxuXHQgICAgICBzWzE3XSA9IGIxNyBeICh+YjE5ICYgYjExKTtcclxuXHQgICAgICBzWzI2XSA9IGIyNiBeICh+YjI4ICYgYjIwKTtcclxuXHQgICAgICBzWzI3XSA9IGIyNyBeICh+YjI5ICYgYjIxKTtcclxuXHQgICAgICBzWzM2XSA9IGIzNiBeICh+YjM4ICYgYjMwKTtcclxuXHQgICAgICBzWzM3XSA9IGIzNyBeICh+YjM5ICYgYjMxKTtcclxuXHQgICAgICBzWzQ2XSA9IGI0NiBeICh+YjQ4ICYgYjQwKTtcclxuXHQgICAgICBzWzQ3XSA9IGI0NyBeICh+YjQ5ICYgYjQxKTtcclxuXHQgICAgICBzWzhdID0gYjggXiAofmIwICYgYjIpO1xyXG5cdCAgICAgIHNbOV0gPSBiOSBeICh+YjEgJiBiMyk7XHJcblx0ICAgICAgc1sxOF0gPSBiMTggXiAofmIxMCAmIGIxMik7XHJcblx0ICAgICAgc1sxOV0gPSBiMTkgXiAofmIxMSAmIGIxMyk7XHJcblx0ICAgICAgc1syOF0gPSBiMjggXiAofmIyMCAmIGIyMik7XHJcblx0ICAgICAgc1syOV0gPSBiMjkgXiAofmIyMSAmIGIyMyk7XHJcblx0ICAgICAgc1szOF0gPSBiMzggXiAofmIzMCAmIGIzMik7XHJcblx0ICAgICAgc1szOV0gPSBiMzkgXiAofmIzMSAmIGIzMyk7XHJcblx0ICAgICAgc1s0OF0gPSBiNDggXiAofmI0MCAmIGI0Mik7XHJcblx0ICAgICAgc1s0OV0gPSBiNDkgXiAofmI0MSAmIGI0Myk7XHJcblxyXG5cdCAgICAgIHNbMF0gXj0gUkNbbl07XHJcblx0ICAgICAgc1sxXSBePSBSQ1tuICsgMV07XHJcblx0ICAgIH1cclxuXHQgIH07XHJcblxyXG5cdCAgaWYgKENPTU1PTl9KUykge1xyXG5cdCAgICBtb2R1bGUuZXhwb3J0cyA9IG1ldGhvZHM7XHJcblx0ICB9IGVsc2Uge1xyXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1ldGhvZE5hbWVzLmxlbmd0aDsgKytpKSB7XHJcblx0ICAgICAgcm9vdFttZXRob2ROYW1lc1tpXV0gPSBtZXRob2RzW21ldGhvZE5hbWVzW2ldXTtcclxuXHQgICAgfVxyXG5cdCAgfVxyXG5cdH0pKCk7XG5cdH0pO1xuXG5cdHZhciBsaWIkNCA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciBfX2ltcG9ydERlZmF1bHQgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG5cdCAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcblx0fTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHR2YXIganNfc2hhM18xID0gX19pbXBvcnREZWZhdWx0KHNoYTMpO1xuXG5cdGZ1bmN0aW9uIGtlY2NhazI1NihkYXRhKSB7XG5cdCAgICByZXR1cm4gJzB4JyArIGpzX3NoYTNfMS5kZWZhdWx0LmtlY2Nha18yNTYobGliJDEuYXJyYXlpZnkoZGF0YSkpO1xuXHR9XG5cdGV4cG9ydHMua2VjY2FrMjU2ID0ga2VjY2FrMjU2O1xuXG5cdH0pO1xuXG5cdHZhciBpbmRleCQ0ID0gdW53cmFwRXhwb3J0cyhsaWIkNCk7XG5cdHZhciBsaWJfMSQ0ID0gbGliJDQua2VjY2FrMjU2O1xuXG5cdHZhciBfdmVyc2lvbiRhID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLnZlcnNpb24gPSBcInJscC81LjAuMlwiO1xuXG5cdH0pO1xuXG5cdHZhciBfdmVyc2lvbiRiID0gdW53cmFwRXhwb3J0cyhfdmVyc2lvbiRhKTtcblx0dmFyIF92ZXJzaW9uXzEkNSA9IF92ZXJzaW9uJGEudmVyc2lvbjtcblxuXHR2YXIgbGliJDUgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdC8vU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vd2lraS93aWtpL1JMUFxuXG5cblxuXHR2YXIgbG9nZ2VyID0gbmV3IGxpYi5Mb2dnZXIoX3ZlcnNpb24kYS52ZXJzaW9uKTtcblx0ZnVuY3Rpb24gYXJyYXlpZnlJbnRlZ2VyKHZhbHVlKSB7XG5cdCAgICB2YXIgcmVzdWx0ID0gW107XG5cdCAgICB3aGlsZSAodmFsdWUpIHtcblx0ICAgICAgICByZXN1bHQudW5zaGlmdCh2YWx1ZSAmIDB4ZmYpO1xuXHQgICAgICAgIHZhbHVlID4+PSA4O1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0fVxuXHRmdW5jdGlvbiB1bmFycmF5aWZ5SW50ZWdlcihkYXRhLCBvZmZzZXQsIGxlbmd0aCkge1xuXHQgICAgdmFyIHJlc3VsdCA9IDA7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgcmVzdWx0ID0gKHJlc3VsdCAqIDI1NikgKyBkYXRhW29mZnNldCArIGldO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0fVxuXHRmdW5jdGlvbiBfZW5jb2RlKG9iamVjdCkge1xuXHQgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuXHQgICAgICAgIHZhciBwYXlsb2FkXzEgPSBbXTtcblx0ICAgICAgICBvYmplY3QuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcblx0ICAgICAgICAgICAgcGF5bG9hZF8xID0gcGF5bG9hZF8xLmNvbmNhdChfZW5jb2RlKGNoaWxkKSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgaWYgKHBheWxvYWRfMS5sZW5ndGggPD0gNTUpIHtcblx0ICAgICAgICAgICAgcGF5bG9hZF8xLnVuc2hpZnQoMHhjMCArIHBheWxvYWRfMS5sZW5ndGgpO1xuXHQgICAgICAgICAgICByZXR1cm4gcGF5bG9hZF8xO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgbGVuZ3RoXzEgPSBhcnJheWlmeUludGVnZXIocGF5bG9hZF8xLmxlbmd0aCk7XG5cdCAgICAgICAgbGVuZ3RoXzEudW5zaGlmdCgweGY3ICsgbGVuZ3RoXzEubGVuZ3RoKTtcblx0ICAgICAgICByZXR1cm4gbGVuZ3RoXzEuY29uY2F0KHBheWxvYWRfMSk7XG5cdCAgICB9XG5cdCAgICBpZiAoIWxpYiQxLmlzQnl0ZXNMaWtlKG9iamVjdCkpIHtcblx0ICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiUkxQIG9iamVjdCBtdXN0IGJlIEJ5dGVzTGlrZVwiLCBcIm9iamVjdFwiLCBvYmplY3QpO1xuXHQgICAgfVxuXHQgICAgdmFyIGRhdGEgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChsaWIkMS5hcnJheWlmeShvYmplY3QpKTtcblx0ICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMSAmJiBkYXRhWzBdIDw9IDB4N2YpIHtcblx0ICAgICAgICByZXR1cm4gZGF0YTtcblx0ICAgIH1cblx0ICAgIGVsc2UgaWYgKGRhdGEubGVuZ3RoIDw9IDU1KSB7XG5cdCAgICAgICAgZGF0YS51bnNoaWZ0KDB4ODAgKyBkYXRhLmxlbmd0aCk7XG5cdCAgICAgICAgcmV0dXJuIGRhdGE7XG5cdCAgICB9XG5cdCAgICB2YXIgbGVuZ3RoID0gYXJyYXlpZnlJbnRlZ2VyKGRhdGEubGVuZ3RoKTtcblx0ICAgIGxlbmd0aC51bnNoaWZ0KDB4YjcgKyBsZW5ndGgubGVuZ3RoKTtcblx0ICAgIHJldHVybiBsZW5ndGguY29uY2F0KGRhdGEpO1xuXHR9XG5cdGZ1bmN0aW9uIGVuY29kZShvYmplY3QpIHtcblx0ICAgIHJldHVybiBsaWIkMS5oZXhsaWZ5KF9lbmNvZGUob2JqZWN0KSk7XG5cdH1cblx0ZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG5cdGZ1bmN0aW9uIF9kZWNvZGVDaGlsZHJlbihkYXRhLCBvZmZzZXQsIGNoaWxkT2Zmc2V0LCBsZW5ndGgpIHtcblx0ICAgIHZhciByZXN1bHQgPSBbXTtcblx0ICAgIHdoaWxlIChjaGlsZE9mZnNldCA8IG9mZnNldCArIDEgKyBsZW5ndGgpIHtcblx0ICAgICAgICB2YXIgZGVjb2RlZCA9IF9kZWNvZGUoZGF0YSwgY2hpbGRPZmZzZXQpO1xuXHQgICAgICAgIHJlc3VsdC5wdXNoKGRlY29kZWQucmVzdWx0KTtcblx0ICAgICAgICBjaGlsZE9mZnNldCArPSBkZWNvZGVkLmNvbnN1bWVkO1xuXHQgICAgICAgIGlmIChjaGlsZE9mZnNldCA+IG9mZnNldCArIDEgKyBsZW5ndGgpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJjaGlsZCBkYXRhIHRvbyBzaG9ydFwiLCBsaWIuTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTiwge30pO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiB7IGNvbnN1bWVkOiAoMSArIGxlbmd0aCksIHJlc3VsdDogcmVzdWx0IH07XG5cdH1cblx0Ly8gcmV0dXJucyB7IGNvbnN1bWVkOiBudW1iZXIsIHJlc3VsdDogT2JqZWN0IH1cblx0ZnVuY3Rpb24gX2RlY29kZShkYXRhLCBvZmZzZXQpIHtcblx0ICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMCkge1xuXHQgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiZGF0YSB0b28gc2hvcnRcIiwgbGliLkxvZ2dlci5lcnJvcnMuQlVGRkVSX09WRVJSVU4sIHt9KTtcblx0ICAgIH1cblx0ICAgIC8vIEFycmF5IHdpdGggZXh0cmEgbGVuZ3RoIHByZWZpeFxuXHQgICAgaWYgKGRhdGFbb2Zmc2V0XSA+PSAweGY4KSB7XG5cdCAgICAgICAgdmFyIGxlbmd0aExlbmd0aCA9IGRhdGFbb2Zmc2V0XSAtIDB4Zjc7XG5cdCAgICAgICAgaWYgKG9mZnNldCArIDEgKyBsZW5ndGhMZW5ndGggPiBkYXRhLmxlbmd0aCkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImRhdGEgc2hvcnQgc2VnbWVudCB0b28gc2hvcnRcIiwgbGliLkxvZ2dlci5lcnJvcnMuQlVGRkVSX09WRVJSVU4sIHt9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGxlbmd0aF8yID0gdW5hcnJheWlmeUludGVnZXIoZGF0YSwgb2Zmc2V0ICsgMSwgbGVuZ3RoTGVuZ3RoKTtcblx0ICAgICAgICBpZiAob2Zmc2V0ICsgMSArIGxlbmd0aExlbmd0aCArIGxlbmd0aF8yID4gZGF0YS5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJkYXRhIGxvbmcgc2VnbWVudCB0b28gc2hvcnRcIiwgbGliLkxvZ2dlci5lcnJvcnMuQlVGRkVSX09WRVJSVU4sIHt9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIF9kZWNvZGVDaGlsZHJlbihkYXRhLCBvZmZzZXQsIG9mZnNldCArIDEgKyBsZW5ndGhMZW5ndGgsIGxlbmd0aExlbmd0aCArIGxlbmd0aF8yKTtcblx0ICAgIH1cblx0ICAgIGVsc2UgaWYgKGRhdGFbb2Zmc2V0XSA+PSAweGMwKSB7XG5cdCAgICAgICAgdmFyIGxlbmd0aF8zID0gZGF0YVtvZmZzZXRdIC0gMHhjMDtcblx0ICAgICAgICBpZiAob2Zmc2V0ICsgMSArIGxlbmd0aF8zID4gZGF0YS5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJkYXRhIGFycmF5IHRvbyBzaG9ydFwiLCBsaWIuTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTiwge30pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gX2RlY29kZUNoaWxkcmVuKGRhdGEsIG9mZnNldCwgb2Zmc2V0ICsgMSwgbGVuZ3RoXzMpO1xuXHQgICAgfVxuXHQgICAgZWxzZSBpZiAoZGF0YVtvZmZzZXRdID49IDB4YjgpIHtcblx0ICAgICAgICB2YXIgbGVuZ3RoTGVuZ3RoID0gZGF0YVtvZmZzZXRdIC0gMHhiNztcblx0ICAgICAgICBpZiAob2Zmc2V0ICsgMSArIGxlbmd0aExlbmd0aCA+IGRhdGEubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiZGF0YSBhcnJheSB0b28gc2hvcnRcIiwgbGliLkxvZ2dlci5lcnJvcnMuQlVGRkVSX09WRVJSVU4sIHt9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGxlbmd0aF80ID0gdW5hcnJheWlmeUludGVnZXIoZGF0YSwgb2Zmc2V0ICsgMSwgbGVuZ3RoTGVuZ3RoKTtcblx0ICAgICAgICBpZiAob2Zmc2V0ICsgMSArIGxlbmd0aExlbmd0aCArIGxlbmd0aF80ID4gZGF0YS5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJkYXRhIGFycmF5IHRvbyBzaG9ydFwiLCBsaWIuTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTiwge30pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgcmVzdWx0ID0gbGliJDEuaGV4bGlmeShkYXRhLnNsaWNlKG9mZnNldCArIDEgKyBsZW5ndGhMZW5ndGgsIG9mZnNldCArIDEgKyBsZW5ndGhMZW5ndGggKyBsZW5ndGhfNCkpO1xuXHQgICAgICAgIHJldHVybiB7IGNvbnN1bWVkOiAoMSArIGxlbmd0aExlbmd0aCArIGxlbmd0aF80KSwgcmVzdWx0OiByZXN1bHQgfTtcblx0ICAgIH1cblx0ICAgIGVsc2UgaWYgKGRhdGFbb2Zmc2V0XSA+PSAweDgwKSB7XG5cdCAgICAgICAgdmFyIGxlbmd0aF81ID0gZGF0YVtvZmZzZXRdIC0gMHg4MDtcblx0ICAgICAgICBpZiAob2Zmc2V0ICsgMSArIGxlbmd0aF81ID4gZGF0YS5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJkYXRhIHRvbyBzaG9ydFwiLCBsaWIuTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTiwge30pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgcmVzdWx0ID0gbGliJDEuaGV4bGlmeShkYXRhLnNsaWNlKG9mZnNldCArIDEsIG9mZnNldCArIDEgKyBsZW5ndGhfNSkpO1xuXHQgICAgICAgIHJldHVybiB7IGNvbnN1bWVkOiAoMSArIGxlbmd0aF81KSwgcmVzdWx0OiByZXN1bHQgfTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB7IGNvbnN1bWVkOiAxLCByZXN1bHQ6IGxpYiQxLmhleGxpZnkoZGF0YVtvZmZzZXRdKSB9O1xuXHR9XG5cdGZ1bmN0aW9uIGRlY29kZShkYXRhKSB7XG5cdCAgICB2YXIgYnl0ZXMgPSBsaWIkMS5hcnJheWlmeShkYXRhKTtcblx0ICAgIHZhciBkZWNvZGVkID0gX2RlY29kZShieXRlcywgMCk7XG5cdCAgICBpZiAoZGVjb2RlZC5jb25zdW1lZCAhPT0gYnl0ZXMubGVuZ3RoKSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgcmxwIGRhdGFcIiwgXCJkYXRhXCIsIGRhdGEpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGRlY29kZWQucmVzdWx0O1xuXHR9XG5cdGV4cG9ydHMuZGVjb2RlID0gZGVjb2RlO1xuXG5cdH0pO1xuXG5cdHZhciBpbmRleCQ1ID0gdW53cmFwRXhwb3J0cyhsaWIkNSk7XG5cdHZhciBsaWJfMSQ1ID0gbGliJDUuZW5jb2RlO1xuXHR2YXIgbGliXzIkNCA9IGxpYiQ1LmRlY29kZTtcblxuXHR2YXIgX3ZlcnNpb24kYyA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy52ZXJzaW9uID0gXCJhZGRyZXNzLzUuMC4yXCI7XG5cblx0fSk7XG5cblx0dmFyIF92ZXJzaW9uJGQgPSB1bndyYXBFeHBvcnRzKF92ZXJzaW9uJGMpO1xuXHR2YXIgX3ZlcnNpb25fMSQ2ID0gX3ZlcnNpb24kYy52ZXJzaW9uO1xuXG5cdHZhciBsaWIkNiA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0Ly8gV2UgdXNlIHRoaXMgZm9yIGJhc2UgMzYgbWF0aHNcblxuXG5cblxuXG5cblxuXHR2YXIgbG9nZ2VyID0gbmV3IGxpYi5Mb2dnZXIoX3ZlcnNpb24kYy52ZXJzaW9uKTtcblx0ZnVuY3Rpb24gZ2V0Q2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpIHtcblx0ICAgIGlmICghbGliJDEuaXNIZXhTdHJpbmcoYWRkcmVzcywgMjApKSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYWRkcmVzc1wiLCBcImFkZHJlc3NcIiwgYWRkcmVzcyk7XG5cdCAgICB9XG5cdCAgICBhZGRyZXNzID0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpO1xuXHQgICAgdmFyIGNoYXJzID0gYWRkcmVzcy5zdWJzdHJpbmcoMikuc3BsaXQoXCJcIik7XG5cdCAgICB2YXIgZXhwYW5kZWQgPSBuZXcgVWludDhBcnJheSg0MCk7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQwOyBpKyspIHtcblx0ICAgICAgICBleHBhbmRlZFtpXSA9IGNoYXJzW2ldLmNoYXJDb2RlQXQoMCk7XG5cdCAgICB9XG5cdCAgICB2YXIgaGFzaGVkID0gbGliJDEuYXJyYXlpZnkobGliJDQua2VjY2FrMjU2KGV4cGFuZGVkKSk7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQwOyBpICs9IDIpIHtcblx0ICAgICAgICBpZiAoKGhhc2hlZFtpID4+IDFdID4+IDQpID49IDgpIHtcblx0ICAgICAgICAgICAgY2hhcnNbaV0gPSBjaGFyc1tpXS50b1VwcGVyQ2FzZSgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoKGhhc2hlZFtpID4+IDFdICYgMHgwZikgPj0gOCkge1xuXHQgICAgICAgICAgICBjaGFyc1tpICsgMV0gPSBjaGFyc1tpICsgMV0udG9VcHBlckNhc2UoKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gXCIweFwiICsgY2hhcnMuam9pbihcIlwiKTtcblx0fVxuXHQvLyBTaGltcyBmb3IgZW52aXJvbm1lbnRzIHRoYXQgYXJlIG1pc3Npbmcgc29tZSByZXF1aXJlZCBjb25zdGFudHMgYW5kIGZ1bmN0aW9uc1xuXHR2YXIgTUFYX1NBRkVfSU5URUdFUiA9IDB4MWZmZmZmZmZmZmZmZmY7XG5cdGZ1bmN0aW9uIGxvZzEwKHgpIHtcblx0ICAgIGlmIChNYXRoLmxvZzEwKSB7XG5cdCAgICAgICAgcmV0dXJuIE1hdGgubG9nMTAoeCk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gTWF0aC5sb2coeCkgLyBNYXRoLkxOMTA7XG5cdH1cblx0Ly8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JbnRlcm5hdGlvbmFsX0JhbmtfQWNjb3VudF9OdW1iZXJcblx0Ly8gQ3JlYXRlIGxvb2t1cCB0YWJsZVxuXHR2YXIgaWJhbkxvb2t1cCA9IHt9O1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0ICAgIGliYW5Mb29rdXBbU3RyaW5nKGkpXSA9IFN0cmluZyhpKTtcblx0fVxuXHRmb3IgKHZhciBpID0gMDsgaSA8IDI2OyBpKyspIHtcblx0ICAgIGliYW5Mb29rdXBbU3RyaW5nLmZyb21DaGFyQ29kZSg2NSArIGkpXSA9IFN0cmluZygxMCArIGkpO1xuXHR9XG5cdC8vIEhvdyBtYW55IGRlY2ltYWwgZGlnaXRzIGNhbiB3ZSBwcm9jZXNzPyAoZm9yIDY0LWJpdCBmbG9hdCwgdGhpcyBpcyAxNSlcblx0dmFyIHNhZmVEaWdpdHMgPSBNYXRoLmZsb29yKGxvZzEwKE1BWF9TQUZFX0lOVEVHRVIpKTtcblx0ZnVuY3Rpb24gaWJhbkNoZWNrc3VtKGFkZHJlc3MpIHtcblx0ICAgIGFkZHJlc3MgPSBhZGRyZXNzLnRvVXBwZXJDYXNlKCk7XG5cdCAgICBhZGRyZXNzID0gYWRkcmVzcy5zdWJzdHJpbmcoNCkgKyBhZGRyZXNzLnN1YnN0cmluZygwLCAyKSArIFwiMDBcIjtcblx0ICAgIHZhciBleHBhbmRlZCA9IGFkZHJlc3Muc3BsaXQoXCJcIikubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBpYmFuTG9va3VwW2NdOyB9KS5qb2luKFwiXCIpO1xuXHQgICAgLy8gSmF2YXNjcmlwdCBjYW4gaGFuZGxlIGludGVnZXJzIHNhZmVseSB1cCB0byAxNSAoZGVjaW1hbCkgZGlnaXRzXG5cdCAgICB3aGlsZSAoZXhwYW5kZWQubGVuZ3RoID49IHNhZmVEaWdpdHMpIHtcblx0ICAgICAgICB2YXIgYmxvY2sgPSBleHBhbmRlZC5zdWJzdHJpbmcoMCwgc2FmZURpZ2l0cyk7XG5cdCAgICAgICAgZXhwYW5kZWQgPSBwYXJzZUludChibG9jaywgMTApICUgOTcgKyBleHBhbmRlZC5zdWJzdHJpbmcoYmxvY2subGVuZ3RoKTtcblx0ICAgIH1cblx0ICAgIHZhciBjaGVja3N1bSA9IFN0cmluZyg5OCAtIChwYXJzZUludChleHBhbmRlZCwgMTApICUgOTcpKTtcblx0ICAgIHdoaWxlIChjaGVja3N1bS5sZW5ndGggPCAyKSB7XG5cdCAgICAgICAgY2hlY2tzdW0gPSBcIjBcIiArIGNoZWNrc3VtO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGNoZWNrc3VtO1xuXHR9XG5cdDtcblx0ZnVuY3Rpb24gZ2V0QWRkcmVzcyhhZGRyZXNzKSB7XG5cdCAgICB2YXIgcmVzdWx0ID0gbnVsbDtcblx0ICAgIGlmICh0eXBlb2YgKGFkZHJlc3MpICE9PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYWRkcmVzc1wiLCBcImFkZHJlc3NcIiwgYWRkcmVzcyk7XG5cdCAgICB9XG5cdCAgICBpZiAoYWRkcmVzcy5tYXRjaCgvXigweCk/WzAtOWEtZkEtRl17NDB9JC8pKSB7XG5cdCAgICAgICAgLy8gTWlzc2luZyB0aGUgMHggcHJlZml4XG5cdCAgICAgICAgaWYgKGFkZHJlc3Muc3Vic3RyaW5nKDAsIDIpICE9PSBcIjB4XCIpIHtcblx0ICAgICAgICAgICAgYWRkcmVzcyA9IFwiMHhcIiArIGFkZHJlc3M7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJlc3VsdCA9IGdldENoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKTtcblx0ICAgICAgICAvLyBJdCBpcyBhIGNoZWNrc3VtbWVkIGFkZHJlc3Mgd2l0aCBhIGJhZCBjaGVja3N1bVxuXHQgICAgICAgIGlmIChhZGRyZXNzLm1hdGNoKC8oW0EtRl0uKlthLWZdKXwoW2EtZl0uKltBLUZdKS8pICYmIHJlc3VsdCAhPT0gYWRkcmVzcykge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiYmFkIGFkZHJlc3MgY2hlY2tzdW1cIiwgXCJhZGRyZXNzXCIsIGFkZHJlc3MpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBNYXliZSBJQ0FQPyAod2Ugb25seSBzdXBwb3J0IGRpcmVjdCBtb2RlKVxuXHQgICAgfVxuXHQgICAgZWxzZSBpZiAoYWRkcmVzcy5tYXRjaCgvXlhFWzAtOV17Mn1bMC05QS1aYS16XXszMCwzMX0kLykpIHtcblx0ICAgICAgICAvLyBJdCBpcyBhbiBJQ0FQIGFkZHJlc3Mgd2l0aCBhIGJhZCBjaGVja3N1bVxuXHQgICAgICAgIGlmIChhZGRyZXNzLnN1YnN0cmluZygyLCA0KSAhPT0gaWJhbkNoZWNrc3VtKGFkZHJlc3MpKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJiYWQgaWNhcCBjaGVja3N1bVwiLCBcImFkZHJlc3NcIiwgYWRkcmVzcyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJlc3VsdCA9IChuZXcgYm4uQk4oYWRkcmVzcy5zdWJzdHJpbmcoNCksIDM2KSkudG9TdHJpbmcoMTYpO1xuXHQgICAgICAgIHdoaWxlIChyZXN1bHQubGVuZ3RoIDwgNDApIHtcblx0ICAgICAgICAgICAgcmVzdWx0ID0gXCIwXCIgKyByZXN1bHQ7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJlc3VsdCA9IGdldENoZWNrc3VtQWRkcmVzcyhcIjB4XCIgKyByZXN1bHQpO1xuXHQgICAgfVxuXHQgICAgZWxzZSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYWRkcmVzc1wiLCBcImFkZHJlc3NcIiwgYWRkcmVzcyk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHR9XG5cdGV4cG9ydHMuZ2V0QWRkcmVzcyA9IGdldEFkZHJlc3M7XG5cdGZ1bmN0aW9uIGlzQWRkcmVzcyhhZGRyZXNzKSB7XG5cdCAgICB0cnkge1xuXHQgICAgICAgIGdldEFkZHJlc3MoYWRkcmVzcyk7XG5cdCAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9XG5cdCAgICBjYXRjaCAoZXJyb3IpIHsgfVxuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHR9XG5cdGV4cG9ydHMuaXNBZGRyZXNzID0gaXNBZGRyZXNzO1xuXHRmdW5jdGlvbiBnZXRJY2FwQWRkcmVzcyhhZGRyZXNzKSB7XG5cdCAgICB2YXIgYmFzZTM2ID0gKG5ldyBibi5CTihnZXRBZGRyZXNzKGFkZHJlc3MpLnN1YnN0cmluZygyKSwgMTYpKS50b1N0cmluZygzNikudG9VcHBlckNhc2UoKTtcblx0ICAgIHdoaWxlIChiYXNlMzYubGVuZ3RoIDwgMzApIHtcblx0ICAgICAgICBiYXNlMzYgPSBcIjBcIiArIGJhc2UzNjtcblx0ICAgIH1cblx0ICAgIHJldHVybiBcIlhFXCIgKyBpYmFuQ2hlY2tzdW0oXCJYRTAwXCIgKyBiYXNlMzYpICsgYmFzZTM2O1xuXHR9XG5cdGV4cG9ydHMuZ2V0SWNhcEFkZHJlc3MgPSBnZXRJY2FwQWRkcmVzcztcblx0Ly8gaHR0cDovL2V0aGVyZXVtLnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy83NjAvaG93LWlzLXRoZS1hZGRyZXNzLW9mLWFuLWV0aGVyZXVtLWNvbnRyYWN0LWNvbXB1dGVkXG5cdGZ1bmN0aW9uIGdldENvbnRyYWN0QWRkcmVzcyh0cmFuc2FjdGlvbikge1xuXHQgICAgdmFyIGZyb20gPSBudWxsO1xuXHQgICAgdHJ5IHtcblx0ICAgICAgICBmcm9tID0gZ2V0QWRkcmVzcyh0cmFuc2FjdGlvbi5mcm9tKTtcblx0ICAgIH1cblx0ICAgIGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJtaXNzaW5nIGZyb20gYWRkcmVzc1wiLCBcInRyYW5zYWN0aW9uXCIsIHRyYW5zYWN0aW9uKTtcblx0ICAgIH1cblx0ICAgIHZhciBub25jZSA9IGxpYiQxLnN0cmlwWmVyb3MobGliJDEuYXJyYXlpZnkobGliJDIuQmlnTnVtYmVyLmZyb20odHJhbnNhY3Rpb24ubm9uY2UpLnRvSGV4U3RyaW5nKCkpKTtcblx0ICAgIHJldHVybiBnZXRBZGRyZXNzKGxpYiQxLmhleERhdGFTbGljZShsaWIkNC5rZWNjYWsyNTYobGliJDUuZW5jb2RlKFtmcm9tLCBub25jZV0pKSwgMTIpKTtcblx0fVxuXHRleHBvcnRzLmdldENvbnRyYWN0QWRkcmVzcyA9IGdldENvbnRyYWN0QWRkcmVzcztcblx0ZnVuY3Rpb24gZ2V0Q3JlYXRlMkFkZHJlc3MoZnJvbSwgc2FsdCwgaW5pdENvZGVIYXNoKSB7XG5cdCAgICBpZiAobGliJDEuaGV4RGF0YUxlbmd0aChzYWx0KSAhPT0gMzIpIHtcblx0ICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwic2FsdCBtdXN0IGJlIDMyIGJ5dGVzXCIsIFwic2FsdFwiLCBzYWx0KTtcblx0ICAgIH1cblx0ICAgIGlmIChsaWIkMS5oZXhEYXRhTGVuZ3RoKGluaXRDb2RlSGFzaCkgIT09IDMyKSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImluaXRDb2RlSGFzaCBtdXN0IGJlIDMyIGJ5dGVzXCIsIFwiaW5pdENvZGVIYXNoXCIsIGluaXRDb2RlSGFzaCk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gZ2V0QWRkcmVzcyhsaWIkMS5oZXhEYXRhU2xpY2UobGliJDQua2VjY2FrMjU2KGxpYiQxLmNvbmNhdChbXCIweGZmXCIsIGdldEFkZHJlc3MoZnJvbSksIHNhbHQsIGluaXRDb2RlSGFzaF0pKSwgMTIpKTtcblx0fVxuXHRleHBvcnRzLmdldENyZWF0ZTJBZGRyZXNzID0gZ2V0Q3JlYXRlMkFkZHJlc3M7XG5cblx0fSk7XG5cblx0dmFyIGluZGV4JDYgPSB1bndyYXBFeHBvcnRzKGxpYiQ2KTtcblx0dmFyIGxpYl8xJDYgPSBsaWIkNi5nZXRBZGRyZXNzO1xuXHR2YXIgbGliXzIkNSA9IGxpYiQ2LmlzQWRkcmVzcztcblx0dmFyIGxpYl8zJDQgPSBsaWIkNi5nZXRJY2FwQWRkcmVzcztcblx0dmFyIGxpYl80JDMgPSBsaWIkNi5nZXRDb250cmFjdEFkZHJlc3M7XG5cdHZhciBsaWJfNSQzID0gbGliJDYuZ2V0Q3JlYXRlMkFkZHJlc3M7XG5cblx0dmFyIGFkZHJlc3MgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19leHRlbmRzID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG5cdCAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcblx0ICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG5cdCAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cblx0ICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG5cdCAgICB9O1xuXHR9KSgpO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cblxuXG5cdHZhciBBZGRyZXNzQ29kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoQWRkcmVzc0NvZGVyLCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gQWRkcmVzc0NvZGVyKGxvY2FsTmFtZSkge1xuXHQgICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBcImFkZHJlc3NcIiwgXCJhZGRyZXNzXCIsIGxvY2FsTmFtZSwgZmFsc2UpIHx8IHRoaXM7XG5cdCAgICB9XG5cdCAgICBBZGRyZXNzQ29kZXIucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uICh3cml0ZXIsIHZhbHVlKSB7XG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgbGliJDYuZ2V0QWRkcmVzcyh2YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKGVycm9yLm1lc3NhZ2UsIHZhbHVlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHdyaXRlci53cml0ZVZhbHVlKHZhbHVlKTtcblx0ICAgIH07XG5cdCAgICBBZGRyZXNzQ29kZXIucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uIChyZWFkZXIpIHtcblx0ICAgICAgICByZXR1cm4gbGliJDYuZ2V0QWRkcmVzcyhsaWIkMS5oZXhaZXJvUGFkKHJlYWRlci5yZWFkVmFsdWUoKS50b0hleFN0cmluZygpLCAyMCkpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBBZGRyZXNzQ29kZXI7XG5cdH0oYWJzdHJhY3RDb2Rlci5Db2RlcikpO1xuXHRleHBvcnRzLkFkZHJlc3NDb2RlciA9IEFkZHJlc3NDb2RlcjtcblxuXHR9KTtcblxuXHR2YXIgYWRkcmVzcyQxID0gdW53cmFwRXhwb3J0cyhhZGRyZXNzKTtcblx0dmFyIGFkZHJlc3NfMiA9IGFkZHJlc3MuQWRkcmVzc0NvZGVyO1xuXG5cdHZhciBhbm9ueW1vdXMgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19leHRlbmRzID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG5cdCAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcblx0ICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG5cdCAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cblx0ICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG5cdCAgICB9O1xuXHR9KSgpO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cblx0Ly8gQ2xvbmVzIHRoZSBmdW5jdGlvbmFsaXR5IG9mIGFuIGV4aXN0aW5nIENvZGVyLCBidXQgd2l0aG91dCBhIGxvY2FsTmFtZVxuXHR2YXIgQW5vbnltb3VzQ29kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoQW5vbnltb3VzQ29kZXIsIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBBbm9ueW1vdXNDb2Rlcihjb2Rlcikge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvZGVyLm5hbWUsIGNvZGVyLnR5cGUsIHVuZGVmaW5lZCwgY29kZXIuZHluYW1pYykgfHwgdGhpcztcblx0ICAgICAgICBfdGhpcy5jb2RlciA9IGNvZGVyO1xuXHQgICAgICAgIHJldHVybiBfdGhpcztcblx0ICAgIH1cblx0ICAgIEFub255bW91c0NvZGVyLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiAod3JpdGVyLCB2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLmNvZGVyLmVuY29kZSh3cml0ZXIsIHZhbHVlKTtcblx0ICAgIH07XG5cdCAgICBBbm9ueW1vdXNDb2Rlci5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gKHJlYWRlcikge1xuXHQgICAgICAgIHJldHVybiB0aGlzLmNvZGVyLmRlY29kZShyZWFkZXIpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBBbm9ueW1vdXNDb2Rlcjtcblx0fShhYnN0cmFjdENvZGVyLkNvZGVyKSk7XG5cdGV4cG9ydHMuQW5vbnltb3VzQ29kZXIgPSBBbm9ueW1vdXNDb2RlcjtcblxuXHR9KTtcblxuXHR2YXIgYW5vbnltb3VzJDEgPSB1bndyYXBFeHBvcnRzKGFub255bW91cyk7XG5cdHZhciBhbm9ueW1vdXNfMSA9IGFub255bW91cy5Bbm9ueW1vdXNDb2RlcjtcblxuXHR2YXIgYXJyYXkgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19leHRlbmRzID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG5cdCAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcblx0ICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG5cdCAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cblx0ICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG5cdCAgICB9O1xuXHR9KSgpO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cblxuXHR2YXIgbG9nZ2VyID0gbmV3IGxpYi5Mb2dnZXIoX3ZlcnNpb24kOC52ZXJzaW9uKTtcblxuXG5cdGZ1bmN0aW9uIHBhY2sod3JpdGVyLCBjb2RlcnMsIHZhbHVlcykge1xuXHQgICAgdmFyIGFycmF5VmFsdWVzID0gbnVsbDtcblx0ICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcblx0ICAgICAgICBhcnJheVZhbHVlcyA9IHZhbHVlcztcblx0ICAgIH1cblx0ICAgIGVsc2UgaWYgKHZhbHVlcyAmJiB0eXBlb2YgKHZhbHVlcykgPT09IFwib2JqZWN0XCIpIHtcblx0ICAgICAgICB2YXIgdW5pcXVlXzEgPSB7fTtcblx0ICAgICAgICBhcnJheVZhbHVlcyA9IGNvZGVycy5tYXAoZnVuY3Rpb24gKGNvZGVyKSB7XG5cdCAgICAgICAgICAgIHZhciBuYW1lID0gY29kZXIubG9jYWxOYW1lO1xuXHQgICAgICAgICAgICBpZiAoIW5hbWUpIHtcblx0ICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IGVuY29kZSBvYmplY3QgZm9yIHNpZ25hdHVyZSB3aXRoIG1pc3NpbmcgbmFtZXNcIiwgbGliLkxvZ2dlci5lcnJvcnMuSU5WQUxJRF9BUkdVTUVOVCwge1xuXHQgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50OiBcInZhbHVlc1wiLFxuXHQgICAgICAgICAgICAgICAgICAgIGNvZGVyOiBjb2Rlcixcblx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVzXG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAodW5pcXVlXzFbbmFtZV0pIHtcblx0ICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IGVuY29kZSBvYmplY3QgZm9yIHNpZ25hdHVyZSB3aXRoIGR1cGxpY2F0ZSBuYW1lc1wiLCBsaWIuTG9nZ2VyLmVycm9ycy5JTlZBTElEX0FSR1VNRU5ULCB7XG5cdCAgICAgICAgICAgICAgICAgICAgYXJndW1lbnQ6IFwidmFsdWVzXCIsXG5cdCAgICAgICAgICAgICAgICAgICAgY29kZXI6IGNvZGVyLFxuXHQgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZXNcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHVuaXF1ZV8xW25hbWVdID0gdHJ1ZTtcblx0ICAgICAgICAgICAgcmV0dXJuIHZhbHVlc1tuYW1lXTtcblx0ICAgICAgICB9KTtcblx0ICAgIH1cblx0ICAgIGVsc2Uge1xuXHQgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHR1cGxlIHZhbHVlXCIsIFwidHVwbGVcIiwgdmFsdWVzKTtcblx0ICAgIH1cblx0ICAgIGlmIChjb2RlcnMubGVuZ3RoICE9PSBhcnJheVZhbHVlcy5sZW5ndGgpIHtcblx0ICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidHlwZXMvdmFsdWUgbGVuZ3RoIG1pc21hdGNoXCIsIFwidHVwbGVcIiwgdmFsdWVzKTtcblx0ICAgIH1cblx0ICAgIHZhciBzdGF0aWNXcml0ZXIgPSBuZXcgYWJzdHJhY3RDb2Rlci5Xcml0ZXIod3JpdGVyLndvcmRTaXplKTtcblx0ICAgIHZhciBkeW5hbWljV3JpdGVyID0gbmV3IGFic3RyYWN0Q29kZXIuV3JpdGVyKHdyaXRlci53b3JkU2l6ZSk7XG5cdCAgICB2YXIgdXBkYXRlRnVuY3MgPSBbXTtcblx0ICAgIGNvZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChjb2RlciwgaW5kZXgpIHtcblx0ICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVZhbHVlc1tpbmRleF07XG5cdCAgICAgICAgaWYgKGNvZGVyLmR5bmFtaWMpIHtcblx0ICAgICAgICAgICAgLy8gR2V0IGN1cnJlbnQgZHluYW1pYyBvZmZzZXQgKGZvciB0aGUgZnV0dXJlIHBvaW50ZXIpXG5cdCAgICAgICAgICAgIHZhciBkeW5hbWljT2Zmc2V0XzEgPSBkeW5hbWljV3JpdGVyLmxlbmd0aDtcblx0ICAgICAgICAgICAgLy8gRW5jb2RlIHRoZSBkeW5hbWljIHZhbHVlIGludG8gdGhlIGR5bmFtaWNXcml0ZXJcblx0ICAgICAgICAgICAgY29kZXIuZW5jb2RlKGR5bmFtaWNXcml0ZXIsIHZhbHVlKTtcblx0ICAgICAgICAgICAgLy8gUHJlcGFyZSB0byBwb3B1bGF0ZSB0aGUgY29ycmVjdCBvZmZzZXQgb25jZSB3ZSBhcmUgZG9uZVxuXHQgICAgICAgICAgICB2YXIgdXBkYXRlRnVuY18xID0gc3RhdGljV3JpdGVyLndyaXRlVXBkYXRhYmxlVmFsdWUoKTtcblx0ICAgICAgICAgICAgdXBkYXRlRnVuY3MucHVzaChmdW5jdGlvbiAoYmFzZU9mZnNldCkge1xuXHQgICAgICAgICAgICAgICAgdXBkYXRlRnVuY18xKGJhc2VPZmZzZXQgKyBkeW5hbWljT2Zmc2V0XzEpO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIGNvZGVyLmVuY29kZShzdGF0aWNXcml0ZXIsIHZhbHVlKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8vIEJhY2tmaWxsIGFsbCB0aGUgZHluYW1pYyBvZmZzZXRzLCBub3cgdGhhdCB3ZSBrbm93IHRoZSBzdGF0aWMgbGVuZ3RoXG5cdCAgICB1cGRhdGVGdW5jcy5mb3JFYWNoKGZ1bmN0aW9uIChmdW5jKSB7IGZ1bmMoc3RhdGljV3JpdGVyLmxlbmd0aCk7IH0pO1xuXHQgICAgdmFyIGxlbmd0aCA9IHdyaXRlci53cml0ZUJ5dGVzKHN0YXRpY1dyaXRlci5kYXRhKTtcblx0ICAgIGxlbmd0aCArPSB3cml0ZXIud3JpdGVCeXRlcyhkeW5hbWljV3JpdGVyLmRhdGEpO1xuXHQgICAgcmV0dXJuIGxlbmd0aDtcblx0fVxuXHRleHBvcnRzLnBhY2sgPSBwYWNrO1xuXHRmdW5jdGlvbiB1bnBhY2socmVhZGVyLCBjb2RlcnMpIHtcblx0ICAgIHZhciB2YWx1ZXMgPSBbXTtcblx0ICAgIC8vIEEgcmVhZGVyIGFuY2hvcmVkIHRvIHRoaXMgYmFzZVxuXHQgICAgdmFyIGJhc2VSZWFkZXIgPSByZWFkZXIuc3ViUmVhZGVyKDApO1xuXHQgICAgLy8gVGhlIGFtb3VudCBvZiBkeW5hbWljIGRhdGEgcmVhZDsgdG8gY29uc3VtZSBsYXRlciB0byBzeW5jaHJvbml6ZVxuXHQgICAgdmFyIGR5bmFtaWNMZW5ndGggPSAwO1xuXHQgICAgY29kZXJzLmZvckVhY2goZnVuY3Rpb24gKGNvZGVyKSB7XG5cdCAgICAgICAgdmFyIHZhbHVlID0gbnVsbDtcblx0ICAgICAgICBpZiAoY29kZXIuZHluYW1pYykge1xuXHQgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gcmVhZGVyLnJlYWRWYWx1ZSgpO1xuXHQgICAgICAgICAgICB2YXIgb2Zmc2V0UmVhZGVyID0gYmFzZVJlYWRlci5zdWJSZWFkZXIob2Zmc2V0LnRvTnVtYmVyKCkpO1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgdmFsdWUgPSBjb2Rlci5kZWNvZGUob2Zmc2V0UmVhZGVyKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgIC8vIENhbm5vdCByZWNvdmVyIGZyb20gdGhpc1xuXHQgICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IGxpYi5Mb2dnZXIuZXJyb3JzLkJVRkZFUl9PVkVSUlVOKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB2YWx1ZSA9IGVycm9yO1xuXHQgICAgICAgICAgICAgICAgdmFsdWUuYmFzZVR5cGUgPSBjb2Rlci5uYW1lO1xuXHQgICAgICAgICAgICAgICAgdmFsdWUubmFtZSA9IGNvZGVyLmxvY2FsTmFtZTtcblx0ICAgICAgICAgICAgICAgIHZhbHVlLnR5cGUgPSBjb2Rlci50eXBlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGR5bmFtaWNMZW5ndGggKz0gb2Zmc2V0UmVhZGVyLmNvbnN1bWVkO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIHZhbHVlID0gY29kZXIuZGVjb2RlKHJlYWRlcik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBDYW5ub3QgcmVjb3ZlciBmcm9tIHRoaXNcblx0ICAgICAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID09PSBsaWIuTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTikge1xuXHQgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdmFsdWUgPSBlcnJvcjtcblx0ICAgICAgICAgICAgICAgIHZhbHVlLmJhc2VUeXBlID0gY29kZXIubmFtZTtcblx0ICAgICAgICAgICAgICAgIHZhbHVlLm5hbWUgPSBjb2Rlci5sb2NhbE5hbWU7XG5cdCAgICAgICAgICAgICAgICB2YWx1ZS50eXBlID0gY29kZXIudHlwZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodmFsdWUgIT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8vIEBUT0RPOiBnZXQgcmlkIG9mIHRoaXMgYW4gc2VlIGlmIGl0IHN0aWxsIHdvcmtzP1xuXHQgICAgLy8gQ29uc3VtZSB0aGUgZHluYW1pYyBjb21wb25lbnRzIGluIHRoZSBtYWluIHJlYWRlclxuXHQgICAgcmVhZGVyLnJlYWRCeXRlcyhkeW5hbWljTGVuZ3RoKTtcblx0ICAgIC8vIFdlIG9ubHkgb3V0cHV0IG5hbWVkIHByb3BlcnRpZXMgZm9yIHVuaXF1ZWx5IG5hbWVkIGNvZGVyc1xuXHQgICAgdmFyIHVuaXF1ZU5hbWVzID0gY29kZXJzLnJlZHVjZShmdW5jdGlvbiAoYWNjdW0sIGNvZGVyKSB7XG5cdCAgICAgICAgdmFyIG5hbWUgPSBjb2Rlci5sb2NhbE5hbWU7XG5cdCAgICAgICAgaWYgKG5hbWUpIHtcblx0ICAgICAgICAgICAgaWYgKCFhY2N1bVtuYW1lXSkge1xuXHQgICAgICAgICAgICAgICAgYWNjdW1bbmFtZV0gPSAwO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGFjY3VtW25hbWVdKys7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBhY2N1bTtcblx0ICAgIH0sIHt9KTtcblx0ICAgIC8vIEFkZCBhbnkgbmFtZWQgcGFyYW1ldGVycyAoaS5lLiB0dXBsZXMpXG5cdCAgICBjb2RlcnMuZm9yRWFjaChmdW5jdGlvbiAoY29kZXIsIGluZGV4KSB7XG5cdCAgICAgICAgdmFyIG5hbWUgPSBjb2Rlci5sb2NhbE5hbWU7XG5cdCAgICAgICAgaWYgKCFuYW1lIHx8IHVuaXF1ZU5hbWVzW25hbWVdICE9PSAxKSB7XG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKG5hbWUgPT09IFwibGVuZ3RoXCIpIHtcblx0ICAgICAgICAgICAgbmFtZSA9IFwiX2xlbmd0aFwiO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodmFsdWVzW25hbWVdICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgdmFsdWUgPSB2YWx1ZXNbaW5kZXhdO1xuXHQgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWx1ZXMsIG5hbWUsIHtcblx0ICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyB0aHJvdyB2YWx1ZTsgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIHZhbHVlc1tuYW1lXSA9IHZhbHVlO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoaSkge1xuXHQgICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlc1tpXTtcblx0ICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsdWVzLCBpLCB7XG5cdCAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgdGhyb3cgdmFsdWU7IH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgX2xvb3BfMShpKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBPYmplY3QuZnJlZXplKHZhbHVlcyk7XG5cdH1cblx0ZXhwb3J0cy51bnBhY2sgPSB1bnBhY2s7XG5cdHZhciBBcnJheUNvZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHQgICAgX19leHRlbmRzKEFycmF5Q29kZXIsIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBBcnJheUNvZGVyKGNvZGVyLCBsZW5ndGgsIGxvY2FsTmFtZSkge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgdmFyIHR5cGUgPSAoY29kZXIudHlwZSArIFwiW1wiICsgKGxlbmd0aCA+PSAwID8gbGVuZ3RoIDogXCJcIikgKyBcIl1cIik7XG5cdCAgICAgICAgdmFyIGR5bmFtaWMgPSAobGVuZ3RoID09PSAtMSB8fCBjb2Rlci5keW5hbWljKTtcblx0ICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIFwiYXJyYXlcIiwgdHlwZSwgbG9jYWxOYW1lLCBkeW5hbWljKSB8fCB0aGlzO1xuXHQgICAgICAgIF90aGlzLmNvZGVyID0gY29kZXI7XG5cdCAgICAgICAgX3RoaXMubGVuZ3RoID0gbGVuZ3RoO1xuXHQgICAgICAgIHJldHVybiBfdGhpcztcblx0ICAgIH1cblx0ICAgIEFycmF5Q29kZXIucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uICh3cml0ZXIsIHZhbHVlKSB7XG5cdCAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuXHQgICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKFwiZXhwZWN0ZWQgYXJyYXkgdmFsdWVcIiwgdmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgY291bnQgPSB0aGlzLmxlbmd0aDtcblx0ICAgICAgICBpZiAoY291bnQgPT09IC0xKSB7XG5cdCAgICAgICAgICAgIGNvdW50ID0gdmFsdWUubGVuZ3RoO1xuXHQgICAgICAgICAgICB3cml0ZXIud3JpdGVWYWx1ZSh2YWx1ZS5sZW5ndGgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBsb2dnZXIuY2hlY2tBcmd1bWVudENvdW50KGNvdW50LCB2YWx1ZS5sZW5ndGgsIFwiY29kZXIgYXJyYXlcIiArICh0aGlzLmxvY2FsTmFtZSA/IChcIiBcIiArIHRoaXMubG9jYWxOYW1lKSA6IFwiXCIpKTtcblx0ICAgICAgICB2YXIgY29kZXJzID0gW107XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICBjb2RlcnMucHVzaCh0aGlzLmNvZGVyKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHBhY2sod3JpdGVyLCBjb2RlcnMsIHZhbHVlKTtcblx0ICAgIH07XG5cdCAgICBBcnJheUNvZGVyLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiAocmVhZGVyKSB7XG5cdCAgICAgICAgdmFyIGNvdW50ID0gdGhpcy5sZW5ndGg7XG5cdCAgICAgICAgaWYgKGNvdW50ID09PSAtMSkge1xuXHQgICAgICAgICAgICBjb3VudCA9IHJlYWRlci5yZWFkVmFsdWUoKS50b051bWJlcigpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgY29kZXJzID0gW107XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG5cdCAgICAgICAgICAgIGNvZGVycy5wdXNoKG5ldyBhbm9ueW1vdXMuQW5vbnltb3VzQ29kZXIodGhpcy5jb2RlcikpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcmVhZGVyLmNvZXJjZSh0aGlzLm5hbWUsIHVucGFjayhyZWFkZXIsIGNvZGVycykpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBBcnJheUNvZGVyO1xuXHR9KGFic3RyYWN0Q29kZXIuQ29kZXIpKTtcblx0ZXhwb3J0cy5BcnJheUNvZGVyID0gQXJyYXlDb2RlcjtcblxuXHR9KTtcblxuXHR2YXIgYXJyYXkkMSA9IHVud3JhcEV4cG9ydHMoYXJyYXkpO1xuXHR2YXIgYXJyYXlfMSA9IGFycmF5LnBhY2s7XG5cdHZhciBhcnJheV8yID0gYXJyYXkudW5wYWNrO1xuXHR2YXIgYXJyYXlfMyA9IGFycmF5LkFycmF5Q29kZXI7XG5cblx0dmFyIGJvb2xlYW5fMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciBfX2V4dGVuZHMgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcblx0ICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuXHQgICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcblx0ICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuXHQgICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcblx0ICAgIH07XG5cdH0pKCk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXHR2YXIgQm9vbGVhbkNvZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHQgICAgX19leHRlbmRzKEJvb2xlYW5Db2RlciwgX3N1cGVyKTtcblx0ICAgIGZ1bmN0aW9uIEJvb2xlYW5Db2Rlcihsb2NhbE5hbWUpIHtcblx0ICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgXCJib29sXCIsIFwiYm9vbFwiLCBsb2NhbE5hbWUsIGZhbHNlKSB8fCB0aGlzO1xuXHQgICAgfVxuXHQgICAgQm9vbGVhbkNvZGVyLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiAod3JpdGVyLCB2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiB3cml0ZXIud3JpdGVWYWx1ZSh2YWx1ZSA/IDEgOiAwKTtcblx0ICAgIH07XG5cdCAgICBCb29sZWFuQ29kZXIucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uIChyZWFkZXIpIHtcblx0ICAgICAgICByZXR1cm4gcmVhZGVyLmNvZXJjZSh0aGlzLnR5cGUsICFyZWFkZXIucmVhZFZhbHVlKCkuaXNaZXJvKCkpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBCb29sZWFuQ29kZXI7XG5cdH0oYWJzdHJhY3RDb2Rlci5Db2RlcikpO1xuXHRleHBvcnRzLkJvb2xlYW5Db2RlciA9IEJvb2xlYW5Db2RlcjtcblxuXHR9KTtcblxuXHR2YXIgYm9vbGVhbiA9IHVud3JhcEV4cG9ydHMoYm9vbGVhbl8xKTtcblx0dmFyIGJvb2xlYW5fMiA9IGJvb2xlYW5fMS5Cb29sZWFuQ29kZXI7XG5cblx0dmFyIGJ5dGVzID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0dmFyIF9fZXh0ZW5kcyA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuXHQgICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuXHQgICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG5cdCAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuXHQgICAgfTtcblx0fSkoKTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5cblx0dmFyIER5bmFtaWNCeXRlc0NvZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHQgICAgX19leHRlbmRzKER5bmFtaWNCeXRlc0NvZGVyLCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gRHluYW1pY0J5dGVzQ29kZXIodHlwZSwgbG9jYWxOYW1lKSB7XG5cdCAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHR5cGUsIHR5cGUsIGxvY2FsTmFtZSwgdHJ1ZSkgfHwgdGhpcztcblx0ICAgIH1cblx0ICAgIER5bmFtaWNCeXRlc0NvZGVyLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiAod3JpdGVyLCB2YWx1ZSkge1xuXHQgICAgICAgIHZhbHVlID0gbGliJDEuYXJyYXlpZnkodmFsdWUpO1xuXHQgICAgICAgIHZhciBsZW5ndGggPSB3cml0ZXIud3JpdGVWYWx1ZSh2YWx1ZS5sZW5ndGgpO1xuXHQgICAgICAgIGxlbmd0aCArPSB3cml0ZXIud3JpdGVCeXRlcyh2YWx1ZSk7XG5cdCAgICAgICAgcmV0dXJuIGxlbmd0aDtcblx0ICAgIH07XG5cdCAgICBEeW5hbWljQnl0ZXNDb2Rlci5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gKHJlYWRlcikge1xuXHQgICAgICAgIHJldHVybiByZWFkZXIucmVhZEJ5dGVzKHJlYWRlci5yZWFkVmFsdWUoKS50b051bWJlcigpKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gRHluYW1pY0J5dGVzQ29kZXI7XG5cdH0oYWJzdHJhY3RDb2Rlci5Db2RlcikpO1xuXHRleHBvcnRzLkR5bmFtaWNCeXRlc0NvZGVyID0gRHluYW1pY0J5dGVzQ29kZXI7XG5cdHZhciBCeXRlc0NvZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHQgICAgX19leHRlbmRzKEJ5dGVzQ29kZXIsIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBCeXRlc0NvZGVyKGxvY2FsTmFtZSkge1xuXHQgICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBcImJ5dGVzXCIsIGxvY2FsTmFtZSkgfHwgdGhpcztcblx0ICAgIH1cblx0ICAgIEJ5dGVzQ29kZXIucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uIChyZWFkZXIpIHtcblx0ICAgICAgICByZXR1cm4gcmVhZGVyLmNvZXJjZSh0aGlzLm5hbWUsIGxpYiQxLmhleGxpZnkoX3N1cGVyLnByb3RvdHlwZS5kZWNvZGUuY2FsbCh0aGlzLCByZWFkZXIpKSk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIEJ5dGVzQ29kZXI7XG5cdH0oRHluYW1pY0J5dGVzQ29kZXIpKTtcblx0ZXhwb3J0cy5CeXRlc0NvZGVyID0gQnl0ZXNDb2RlcjtcblxuXHR9KTtcblxuXHR2YXIgYnl0ZXMkMSA9IHVud3JhcEV4cG9ydHMoYnl0ZXMpO1xuXHR2YXIgYnl0ZXNfMiA9IGJ5dGVzLkR5bmFtaWNCeXRlc0NvZGVyO1xuXHR2YXIgYnl0ZXNfMyA9IGJ5dGVzLkJ5dGVzQ29kZXI7XG5cblx0dmFyIGZpeGVkQnl0ZXMgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19leHRlbmRzID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG5cdCAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcblx0ICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG5cdCAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cblx0ICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG5cdCAgICB9O1xuXHR9KSgpO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cblxuXHQvLyBAVE9ETzogTWVyZ2UgdGhpcyB3aXRoIGJ5dGVzXG5cdHZhciBGaXhlZEJ5dGVzQ29kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoRml4ZWRCeXRlc0NvZGVyLCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gRml4ZWRCeXRlc0NvZGVyKHNpemUsIGxvY2FsTmFtZSkge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgdmFyIG5hbWUgPSBcImJ5dGVzXCIgKyBTdHJpbmcoc2l6ZSk7XG5cdCAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lLCBuYW1lLCBsb2NhbE5hbWUsIGZhbHNlKSB8fCB0aGlzO1xuXHQgICAgICAgIF90aGlzLnNpemUgPSBzaXplO1xuXHQgICAgICAgIHJldHVybiBfdGhpcztcblx0ICAgIH1cblx0ICAgIEZpeGVkQnl0ZXNDb2Rlci5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gKHdyaXRlciwgdmFsdWUpIHtcblx0ICAgICAgICB2YXIgZGF0YSA9IGxpYiQxLmFycmF5aWZ5KHZhbHVlKTtcblx0ICAgICAgICBpZiAoZGF0YS5sZW5ndGggIT09IHRoaXMuc2l6ZSkge1xuXHQgICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKFwiaW5jb3JyZWN0IGRhdGEgbGVuZ3RoXCIsIHZhbHVlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHdyaXRlci53cml0ZUJ5dGVzKGRhdGEpO1xuXHQgICAgfTtcblx0ICAgIEZpeGVkQnl0ZXNDb2Rlci5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gKHJlYWRlcikge1xuXHQgICAgICAgIHJldHVybiByZWFkZXIuY29lcmNlKHRoaXMubmFtZSwgbGliJDEuaGV4bGlmeShyZWFkZXIucmVhZEJ5dGVzKHRoaXMuc2l6ZSkpKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gRml4ZWRCeXRlc0NvZGVyO1xuXHR9KGFic3RyYWN0Q29kZXIuQ29kZXIpKTtcblx0ZXhwb3J0cy5GaXhlZEJ5dGVzQ29kZXIgPSBGaXhlZEJ5dGVzQ29kZXI7XG5cblx0fSk7XG5cblx0dmFyIGZpeGVkQnl0ZXMkMSA9IHVud3JhcEV4cG9ydHMoZml4ZWRCeXRlcyk7XG5cdHZhciBmaXhlZEJ5dGVzXzEgPSBmaXhlZEJ5dGVzLkZpeGVkQnl0ZXNDb2RlcjtcblxuXHR2YXIgX251bGwgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19leHRlbmRzID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG5cdCAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcblx0ICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG5cdCAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cblx0ICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG5cdCAgICB9O1xuXHR9KSgpO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cblx0dmFyIE51bGxDb2RlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0ICAgIF9fZXh0ZW5kcyhOdWxsQ29kZXIsIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBOdWxsQ29kZXIobG9jYWxOYW1lKSB7XG5cdCAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIFwibnVsbFwiLCBcIlwiLCBsb2NhbE5hbWUsIGZhbHNlKSB8fCB0aGlzO1xuXHQgICAgfVxuXHQgICAgTnVsbENvZGVyLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiAod3JpdGVyLCB2YWx1ZSkge1xuXHQgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoXCJub3QgbnVsbFwiLCB2YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB3cml0ZXIud3JpdGVCeXRlcyhbXSk7XG5cdCAgICB9O1xuXHQgICAgTnVsbENvZGVyLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiAocmVhZGVyKSB7XG5cdCAgICAgICAgcmVhZGVyLnJlYWRCeXRlcygwKTtcblx0ICAgICAgICByZXR1cm4gcmVhZGVyLmNvZXJjZSh0aGlzLm5hbWUsIG51bGwpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBOdWxsQ29kZXI7XG5cdH0oYWJzdHJhY3RDb2Rlci5Db2RlcikpO1xuXHRleHBvcnRzLk51bGxDb2RlciA9IE51bGxDb2RlcjtcblxuXHR9KTtcblxuXHR2YXIgX251bGwkMSA9IHVud3JhcEV4cG9ydHMoX251bGwpO1xuXHR2YXIgX251bGxfMSA9IF9udWxsLk51bGxDb2RlcjtcblxuXHR2YXIgbGliJDcgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cblx0dmFyIEFkZHJlc3NaZXJvID0gXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIjtcblx0ZXhwb3J0cy5BZGRyZXNzWmVybyA9IEFkZHJlc3NaZXJvO1xuXHR2YXIgSGFzaFplcm8gPSBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO1xuXHRleHBvcnRzLkhhc2haZXJvID0gSGFzaFplcm87XG5cdC8vIE5GS0MgKGNvbXBvc2VkKSAgICAgICAgICAgICAvLyAoZGVjb21wb3NlZClcblx0dmFyIEV0aGVyU3ltYm9sID0gXCJcXHUwMzllXCI7IC8vIFwiXFx1RDgzNVxcdURGNjNcIjtcblx0ZXhwb3J0cy5FdGhlclN5bWJvbCA9IEV0aGVyU3ltYm9sO1xuXHR2YXIgTmVnYXRpdmVPbmUgPSBsaWIkMi5CaWdOdW1iZXIuZnJvbSgtMSk7XG5cdGV4cG9ydHMuTmVnYXRpdmVPbmUgPSBOZWdhdGl2ZU9uZTtcblx0dmFyIFplcm8gPSBsaWIkMi5CaWdOdW1iZXIuZnJvbSgwKTtcblx0ZXhwb3J0cy5aZXJvID0gWmVybztcblx0dmFyIE9uZSA9IGxpYiQyLkJpZ051bWJlci5mcm9tKDEpO1xuXHRleHBvcnRzLk9uZSA9IE9uZTtcblx0dmFyIFR3byA9IGxpYiQyLkJpZ051bWJlci5mcm9tKDIpO1xuXHRleHBvcnRzLlR3byA9IFR3bztcblx0dmFyIFdlaVBlckV0aGVyID0gbGliJDIuQmlnTnVtYmVyLmZyb20oXCIxMDAwMDAwMDAwMDAwMDAwMDAwXCIpO1xuXHRleHBvcnRzLldlaVBlckV0aGVyID0gV2VpUGVyRXRoZXI7XG5cdHZhciBNYXhVaW50MjU2ID0gbGliJDIuQmlnTnVtYmVyLmZyb20oXCIweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZcIik7XG5cdGV4cG9ydHMuTWF4VWludDI1NiA9IE1heFVpbnQyNTY7XG5cblx0fSk7XG5cblx0dmFyIGluZGV4JDcgPSB1bndyYXBFeHBvcnRzKGxpYiQ3KTtcblx0dmFyIGxpYl8xJDcgPSBsaWIkNy5BZGRyZXNzWmVybztcblx0dmFyIGxpYl8yJDYgPSBsaWIkNy5IYXNoWmVybztcblx0dmFyIGxpYl8zJDUgPSBsaWIkNy5FdGhlclN5bWJvbDtcblx0dmFyIGxpYl80JDQgPSBsaWIkNy5OZWdhdGl2ZU9uZTtcblx0dmFyIGxpYl81JDQgPSBsaWIkNy5aZXJvO1xuXHR2YXIgbGliXzYkMiA9IGxpYiQ3Lk9uZTtcblx0dmFyIGxpYl83JDIgPSBsaWIkNy5Ud287XG5cdHZhciBsaWJfOCQxID0gbGliJDcuV2VpUGVyRXRoZXI7XG5cdHZhciBsaWJfOSQxID0gbGliJDcuTWF4VWludDI1NjtcblxuXHR2YXIgbnVtYmVyID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0dmFyIF9fZXh0ZW5kcyA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuXHQgICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuXHQgICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG5cdCAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuXHQgICAgfTtcblx0fSkoKTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5cblxuXHR2YXIgTnVtYmVyQ29kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoTnVtYmVyQ29kZXIsIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBOdW1iZXJDb2RlcihzaXplLCBzaWduZWQsIGxvY2FsTmFtZSkge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgdmFyIG5hbWUgPSAoKHNpZ25lZCA/IFwiaW50XCIgOiBcInVpbnRcIikgKyAoc2l6ZSAqIDgpKTtcblx0ICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG5hbWUsIG5hbWUsIGxvY2FsTmFtZSwgZmFsc2UpIHx8IHRoaXM7XG5cdCAgICAgICAgX3RoaXMuc2l6ZSA9IHNpemU7XG5cdCAgICAgICAgX3RoaXMuc2lnbmVkID0gc2lnbmVkO1xuXHQgICAgICAgIHJldHVybiBfdGhpcztcblx0ICAgIH1cblx0ICAgIE51bWJlckNvZGVyLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiAod3JpdGVyLCB2YWx1ZSkge1xuXHQgICAgICAgIHZhciB2ID0gbGliJDIuQmlnTnVtYmVyLmZyb20odmFsdWUpO1xuXHQgICAgICAgIC8vIENoZWNrIGJvdW5kcyBhcmUgc2FmZSBmb3IgZW5jb2Rpbmdcblx0ICAgICAgICB2YXIgbWF4VWludFZhbHVlID0gbGliJDcuTWF4VWludDI1Ni5tYXNrKHdyaXRlci53b3JkU2l6ZSAqIDgpO1xuXHQgICAgICAgIGlmICh0aGlzLnNpZ25lZCkge1xuXHQgICAgICAgICAgICB2YXIgYm91bmRzID0gbWF4VWludFZhbHVlLm1hc2sodGhpcy5zaXplICogOCAtIDEpO1xuXHQgICAgICAgICAgICBpZiAodi5ndChib3VuZHMpIHx8IHYubHQoYm91bmRzLmFkZChsaWIkNy5PbmUpLm11bChsaWIkNy5OZWdhdGl2ZU9uZSkpKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKFwidmFsdWUgb3V0LW9mLWJvdW5kc1wiLCB2YWx1ZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAodi5sdChsaWIkNy5aZXJvKSB8fCB2Lmd0KG1heFVpbnRWYWx1ZS5tYXNrKHRoaXMuc2l6ZSAqIDgpKSkge1xuXHQgICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKFwidmFsdWUgb3V0LW9mLWJvdW5kc1wiLCB2YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHYgPSB2LnRvVHdvcyh0aGlzLnNpemUgKiA4KS5tYXNrKHRoaXMuc2l6ZSAqIDgpO1xuXHQgICAgICAgIGlmICh0aGlzLnNpZ25lZCkge1xuXHQgICAgICAgICAgICB2ID0gdi5mcm9tVHdvcyh0aGlzLnNpemUgKiA4KS50b1R3b3MoOCAqIHdyaXRlci53b3JkU2l6ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB3cml0ZXIud3JpdGVWYWx1ZSh2KTtcblx0ICAgIH07XG5cdCAgICBOdW1iZXJDb2Rlci5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gKHJlYWRlcikge1xuXHQgICAgICAgIHZhciB2YWx1ZSA9IHJlYWRlci5yZWFkVmFsdWUoKS5tYXNrKHRoaXMuc2l6ZSAqIDgpO1xuXHQgICAgICAgIGlmICh0aGlzLnNpZ25lZCkge1xuXHQgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmZyb21Ud29zKHRoaXMuc2l6ZSAqIDgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcmVhZGVyLmNvZXJjZSh0aGlzLm5hbWUsIHZhbHVlKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gTnVtYmVyQ29kZXI7XG5cdH0oYWJzdHJhY3RDb2Rlci5Db2RlcikpO1xuXHRleHBvcnRzLk51bWJlckNvZGVyID0gTnVtYmVyQ29kZXI7XG5cblx0fSk7XG5cblx0dmFyIG51bWJlciQxID0gdW53cmFwRXhwb3J0cyhudW1iZXIpO1xuXHR2YXIgbnVtYmVyXzEgPSBudW1iZXIuTnVtYmVyQ29kZXI7XG5cblx0dmFyIF92ZXJzaW9uJGUgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMudmVyc2lvbiA9IFwic3RyaW5ncy81LjAuMlwiO1xuXG5cdH0pO1xuXG5cdHZhciBfdmVyc2lvbiRmID0gdW53cmFwRXhwb3J0cyhfdmVyc2lvbiRlKTtcblx0dmFyIF92ZXJzaW9uXzEkNyA9IF92ZXJzaW9uJGUudmVyc2lvbjtcblxuXHR2YXIgdXRmOCA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXG5cblx0dmFyIGxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJGUudmVyc2lvbik7XG5cdC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0dmFyIFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybTtcblx0KGZ1bmN0aW9uIChVbmljb2RlTm9ybWFsaXphdGlvbkZvcm0pIHtcblx0ICAgIFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybVtcImN1cnJlbnRcIl0gPSBcIlwiO1xuXHQgICAgVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtW1wiTkZDXCJdID0gXCJORkNcIjtcblx0ICAgIFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybVtcIk5GRFwiXSA9IFwiTkZEXCI7XG5cdCAgICBVbmljb2RlTm9ybWFsaXphdGlvbkZvcm1bXCJORktDXCJdID0gXCJORktDXCI7XG5cdCAgICBVbmljb2RlTm9ybWFsaXphdGlvbkZvcm1bXCJORktEXCJdID0gXCJORktEXCI7XG5cdH0pKFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybSA9IGV4cG9ydHMuVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtIHx8IChleHBvcnRzLlVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybSA9IHt9KSk7XG5cdDtcblx0dmFyIFV0ZjhFcnJvclJlYXNvbjtcblx0KGZ1bmN0aW9uIChVdGY4RXJyb3JSZWFzb24pIHtcblx0ICAgIC8vIEEgY29udGludWF0aW9uIGJ5dGUgd2FzIHByZXNlbnQgd2hlcmUgdGhlcmUgd2FzIG5vdGhpbmcgdG8gY29udGludWVcblx0ICAgIC8vIC0gb2Zmc2V0ID0gdGhlIGluZGV4IHRoZSBjb2RlcG9pbnQgYmVnYW4gaW5cblx0ICAgIFV0ZjhFcnJvclJlYXNvbltcIlVORVhQRUNURURfQ09OVElOVUVcIl0gPSBcInVuZXhwZWN0ZWQgY29udGludWF0aW9uIGJ5dGVcIjtcblx0ICAgIC8vIEFuIGludmFsaWQgKG5vbi1jb250aW51YXRpb24pIGJ5dGUgdG8gc3RhcnQgYSBVVEYtOCBjb2RlcG9pbnQgd2FzIGZvdW5kXG5cdCAgICAvLyAtIG9mZnNldCA9IHRoZSBpbmRleCB0aGUgY29kZXBvaW50IGJlZ2FuIGluXG5cdCAgICBVdGY4RXJyb3JSZWFzb25bXCJCQURfUFJFRklYXCJdID0gXCJiYWQgY29kZXBvaW50IHByZWZpeFwiO1xuXHQgICAgLy8gVGhlIHN0cmluZyBpcyB0b28gc2hvcnQgdG8gcHJvY2VzcyB0aGUgZXhwZWN0ZWQgY29kZXBvaW50XG5cdCAgICAvLyAtIG9mZnNldCA9IHRoZSBpbmRleCB0aGUgY29kZXBvaW50IGJlZ2FuIGluXG5cdCAgICBVdGY4RXJyb3JSZWFzb25bXCJPVkVSUlVOXCJdID0gXCJzdHJpbmcgb3ZlcnJ1blwiO1xuXHQgICAgLy8gQSBtaXNzaW5nIGNvbnRpbnVhdGlvbiBieXRlIHdhcyBleHBlY3RlZCBidXQgbm90IGZvdW5kXG5cdCAgICAvLyAtIG9mZnNldCA9IHRoZSBpbmRleCB0aGUgY29udGludWF0aW9uIGJ5dGUgd2FzIGV4cGVjdGVkIGF0XG5cdCAgICBVdGY4RXJyb3JSZWFzb25bXCJNSVNTSU5HX0NPTlRJTlVFXCJdID0gXCJtaXNzaW5nIGNvbnRpbnVhdGlvbiBieXRlXCI7XG5cdCAgICAvLyBUaGUgY29tcHV0ZWQgY29kZSBwb2ludCBpcyBvdXRzaWRlIHRoZSByYW5nZSBmb3IgVVRGLThcblx0ICAgIC8vIC0gb2Zmc2V0ICAgICAgID0gc3RhcnQgb2YgdGhpcyBjb2RlcG9pbnRcblx0ICAgIC8vIC0gYmFkQ29kZXBvaW50ID0gdGhlIGNvbXB1dGVkIGNvZGVwb2ludDsgb3V0c2lkZSB0aGUgVVRGLTggcmFuZ2Vcblx0ICAgIFV0ZjhFcnJvclJlYXNvbltcIk9VVF9PRl9SQU5HRVwiXSA9IFwib3V0IG9mIFVURi04IHJhbmdlXCI7XG5cdCAgICAvLyBVVEYtOCBzdHJpbmdzIG1heSBub3QgY29udGFpbiBVVEYtMTYgc3Vycm9nYXRlIHBhaXJzXG5cdCAgICAvLyAtIG9mZnNldCAgICAgICA9IHN0YXJ0IG9mIHRoaXMgY29kZXBvaW50XG5cdCAgICAvLyAtIGJhZENvZGVwb2ludCA9IHRoZSBjb21wdXRlZCBjb2RlcG9pbnQ7IGluc2lkZSB0aGUgVVRGLTE2IHN1cnJvZ2F0ZSByYW5nZVxuXHQgICAgVXRmOEVycm9yUmVhc29uW1wiVVRGMTZfU1VSUk9HQVRFXCJdID0gXCJVVEYtMTYgc3Vycm9nYXRlXCI7XG5cdCAgICAvLyBUaGUgc3RyaW5nIGlzIGFuIG92ZXJsb25nIHJlcGVyZXNlbnRhdGlvblxuXHQgICAgLy8gLSBvZmZzZXQgICAgICAgPSBzdGFydCBvZiB0aGlzIGNvZGVwb2ludFxuXHQgICAgLy8gLSBiYWRDb2RlcG9pbnQgPSB0aGUgY29tcHV0ZWQgY29kZXBvaW50OyBhbHJlYWR5IGJvdW5kcyBjaGVja2VkXG5cdCAgICBVdGY4RXJyb3JSZWFzb25bXCJPVkVSTE9OR1wiXSA9IFwib3ZlcmxvbmcgcmVwcmVzZW50YXRpb25cIjtcblx0fSkoVXRmOEVycm9yUmVhc29uID0gZXhwb3J0cy5VdGY4RXJyb3JSZWFzb24gfHwgKGV4cG9ydHMuVXRmOEVycm9yUmVhc29uID0ge30pKTtcblx0O1xuXHRmdW5jdGlvbiBlcnJvckZ1bmMocmVhc29uLCBvZmZzZXQsIGJ5dGVzLCBvdXRwdXQsIGJhZENvZGVwb2ludCkge1xuXHQgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGNvZGVwb2ludCBhdCBvZmZzZXQgXCIgKyBvZmZzZXQgKyBcIjsgXCIgKyByZWFzb24sIFwiYnl0ZXNcIiwgYnl0ZXMpO1xuXHR9XG5cdGZ1bmN0aW9uIGlnbm9yZUZ1bmMocmVhc29uLCBvZmZzZXQsIGJ5dGVzLCBvdXRwdXQsIGJhZENvZGVwb2ludCkge1xuXHQgICAgLy8gSWYgdGhlcmUgaXMgYW4gaW52YWxpZCBwcmVmaXggKGluY2x1ZGluZyBzdHJheSBjb250aW51YXRpb24pLCBza2lwIGFueSBhZGRpdGlvbmFsIGNvbnRpbnVhdGlvbiBieXRlc1xuXHQgICAgaWYgKHJlYXNvbiA9PT0gVXRmOEVycm9yUmVhc29uLkJBRF9QUkVGSVggfHwgcmVhc29uID09PSBVdGY4RXJyb3JSZWFzb24uVU5FWFBFQ1RFRF9DT05USU5VRSkge1xuXHQgICAgICAgIHZhciBpID0gMDtcblx0ICAgICAgICBmb3IgKHZhciBvID0gb2Zmc2V0ICsgMTsgbyA8IGJ5dGVzLmxlbmd0aDsgbysrKSB7XG5cdCAgICAgICAgICAgIGlmIChieXRlc1tvXSA+PiA2ICE9PSAweDAyKSB7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpKys7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBpO1xuXHQgICAgfVxuXHQgICAgLy8gVGhpcyBieXRlIHJ1bnMgdXMgcGFzdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHNvIGp1c3QganVtcCB0byB0aGUgZW5kXG5cdCAgICAvLyAoYnV0IHRoZSBmaXJzdCBieXRlIHdhcyByZWFkIGFscmVhZHkgcmVhZCBhbmQgdGhlcmVmb3JlIHNraXBwZWQpXG5cdCAgICBpZiAocmVhc29uID09PSBVdGY4RXJyb3JSZWFzb24uT1ZFUlJVTikge1xuXHQgICAgICAgIHJldHVybiBieXRlcy5sZW5ndGggLSBvZmZzZXQgLSAxO1xuXHQgICAgfVxuXHQgICAgLy8gTm90aGluZyB0byBza2lwXG5cdCAgICByZXR1cm4gMDtcblx0fVxuXHRmdW5jdGlvbiByZXBsYWNlRnVuYyhyZWFzb24sIG9mZnNldCwgYnl0ZXMsIG91dHB1dCwgYmFkQ29kZXBvaW50KSB7XG5cdCAgICAvLyBPdmVybG9uZyByZXByZXNlbnRhdGlvbnMgYXJlIG90aGVyd2lzZSBcInZhbGlkXCIgY29kZSBwb2ludHM7IGp1c3Qgbm9uLWRlaXN0aW5ndGlzaGVkXG5cdCAgICBpZiAocmVhc29uID09PSBVdGY4RXJyb3JSZWFzb24uT1ZFUkxPTkcpIHtcblx0ICAgICAgICBvdXRwdXQucHVzaChiYWRDb2RlcG9pbnQpO1xuXHQgICAgICAgIHJldHVybiAwO1xuXHQgICAgfVxuXHQgICAgLy8gUHV0IHRoZSByZXBsYWNlbWVudCBjaGFyYWN0ZXIgaW50byB0aGUgb3V0cHV0XG5cdCAgICBvdXRwdXQucHVzaCgweGZmZmQpO1xuXHQgICAgLy8gT3RoZXJ3aXNlLCBwcm9jZXNzIGFzIGlmIGlnbm9yaW5nIGVycm9yc1xuXHQgICAgcmV0dXJuIGlnbm9yZUZ1bmMocmVhc29uLCBvZmZzZXQsIGJ5dGVzLCBvdXRwdXQsIGJhZENvZGVwb2ludCk7XG5cdH1cblx0Ly8gQ29tbW9uIGVycm9yIGhhbmRpbmcgc3RyYXRlZ2llc1xuXHRleHBvcnRzLlV0ZjhFcnJvckZ1bmNzID0gT2JqZWN0LmZyZWV6ZSh7XG5cdCAgICBlcnJvcjogZXJyb3JGdW5jLFxuXHQgICAgaWdub3JlOiBpZ25vcmVGdW5jLFxuXHQgICAgcmVwbGFjZTogcmVwbGFjZUZ1bmNcblx0fSk7XG5cdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTMzNTY0OTMvZGVjb2RlLXV0Zi04LXdpdGgtamF2YXNjcmlwdCMxMzY5MTQ5OVxuXHRmdW5jdGlvbiBnZXRVdGY4Q29kZVBvaW50cyhieXRlcywgb25FcnJvcikge1xuXHQgICAgaWYgKG9uRXJyb3IgPT0gbnVsbCkge1xuXHQgICAgICAgIG9uRXJyb3IgPSBleHBvcnRzLlV0ZjhFcnJvckZ1bmNzLmVycm9yO1xuXHQgICAgfVxuXHQgICAgYnl0ZXMgPSBsaWIkMS5hcnJheWlmeShieXRlcyk7XG5cdCAgICB2YXIgcmVzdWx0ID0gW107XG5cdCAgICB2YXIgaSA9IDA7XG5cdCAgICAvLyBJbnZhbGlkIGJ5dGVzIGFyZSBpZ25vcmVkXG5cdCAgICB3aGlsZSAoaSA8IGJ5dGVzLmxlbmd0aCkge1xuXHQgICAgICAgIHZhciBjID0gYnl0ZXNbaSsrXTtcblx0ICAgICAgICAvLyAweHh4IHh4eHhcblx0ICAgICAgICBpZiAoYyA+PiA3ID09PSAwKSB7XG5cdCAgICAgICAgICAgIHJlc3VsdC5wdXNoKGMpO1xuXHQgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gTXVsdGlieXRlOyBob3cgbWFueSBieXRlcyBsZWZ0IGZvciB0aGlzIGNoYXJhY3Rlcj9cblx0ICAgICAgICB2YXIgZXh0cmFMZW5ndGggPSBudWxsO1xuXHQgICAgICAgIHZhciBvdmVybG9uZ01hc2sgPSBudWxsO1xuXHQgICAgICAgIC8vIDExMHggeHh4eCAxMHh4IHh4eHhcblx0ICAgICAgICBpZiAoKGMgJiAweGUwKSA9PT0gMHhjMCkge1xuXHQgICAgICAgICAgICBleHRyYUxlbmd0aCA9IDE7XG5cdCAgICAgICAgICAgIG92ZXJsb25nTWFzayA9IDB4N2Y7XG5cdCAgICAgICAgICAgIC8vIDExMTAgeHh4eCAxMHh4IHh4eHggMTB4eCB4eHh4XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2UgaWYgKChjICYgMHhmMCkgPT09IDB4ZTApIHtcblx0ICAgICAgICAgICAgZXh0cmFMZW5ndGggPSAyO1xuXHQgICAgICAgICAgICBvdmVybG9uZ01hc2sgPSAweDdmZjtcblx0ICAgICAgICAgICAgLy8gMTExMSAweHh4IDEweHggeHh4eCAxMHh4IHh4eHggMTB4eCB4eHh4XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2UgaWYgKChjICYgMHhmOCkgPT09IDB4ZjApIHtcblx0ICAgICAgICAgICAgZXh0cmFMZW5ndGggPSAzO1xuXHQgICAgICAgICAgICBvdmVybG9uZ01hc2sgPSAweGZmZmY7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICBpZiAoKGMgJiAweGMwKSA9PT0gMHg4MCkge1xuXHQgICAgICAgICAgICAgICAgaSArPSBvbkVycm9yKFV0ZjhFcnJvclJlYXNvbi5VTkVYUEVDVEVEX0NPTlRJTlVFLCBpIC0gMSwgYnl0ZXMsIHJlc3VsdCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBpICs9IG9uRXJyb3IoVXRmOEVycm9yUmVhc29uLkJBRF9QUkVGSVgsIGkgLSAxLCBieXRlcywgcmVzdWx0KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gRG8gd2UgaGF2ZSBlbm91Z2ggYnl0ZXMgaW4gb3VyIGRhdGE/XG5cdCAgICAgICAgaWYgKGkgLSAxICsgZXh0cmFMZW5ndGggPj0gYnl0ZXMubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgIGkgKz0gb25FcnJvcihVdGY4RXJyb3JSZWFzb24uT1ZFUlJVTiwgaSAtIDEsIGJ5dGVzLCByZXN1bHQpO1xuXHQgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gUmVtb3ZlIHRoZSBsZW5ndGggcHJlZml4IGZyb20gdGhlIGNoYXJcblx0ICAgICAgICB2YXIgcmVzID0gYyAmICgoMSA8PCAoOCAtIGV4dHJhTGVuZ3RoIC0gMSkpIC0gMSk7XG5cdCAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBleHRyYUxlbmd0aDsgaisrKSB7XG5cdCAgICAgICAgICAgIHZhciBuZXh0Q2hhciA9IGJ5dGVzW2ldO1xuXHQgICAgICAgICAgICAvLyBJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlXG5cdCAgICAgICAgICAgIGlmICgobmV4dENoYXIgJiAweGMwKSAhPSAweDgwKSB7XG5cdCAgICAgICAgICAgICAgICBpICs9IG9uRXJyb3IoVXRmOEVycm9yUmVhc29uLk1JU1NJTkdfQ09OVElOVUUsIGksIGJ5dGVzLCByZXN1bHQpO1xuXHQgICAgICAgICAgICAgICAgcmVzID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIDtcblx0ICAgICAgICAgICAgcmVzID0gKHJlcyA8PCA2KSB8IChuZXh0Q2hhciAmIDB4M2YpO1xuXHQgICAgICAgICAgICBpKys7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIFNlZSBhYm92ZSBsb29wIGZvciBpbnZhbGlkIGNvbnRpbXVhdGlvbiBieXRlXG5cdCAgICAgICAgaWYgKHJlcyA9PT0gbnVsbCkge1xuXHQgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gTWF4aW11bSBjb2RlIHBvaW50XG5cdCAgICAgICAgaWYgKHJlcyA+IDB4MTBmZmZmKSB7XG5cdCAgICAgICAgICAgIGkgKz0gb25FcnJvcihVdGY4RXJyb3JSZWFzb24uT1VUX09GX1JBTkdFLCBpIC0gMSAtIGV4dHJhTGVuZ3RoLCBieXRlcywgcmVzdWx0LCByZXMpO1xuXHQgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gUmVzZXJ2ZWQgZm9yIFVURi0xNiBzdXJyb2dhdGUgaGFsdmVzXG5cdCAgICAgICAgaWYgKHJlcyA+PSAweGQ4MDAgJiYgcmVzIDw9IDB4ZGZmZikge1xuXHQgICAgICAgICAgICBpICs9IG9uRXJyb3IoVXRmOEVycm9yUmVhc29uLlVURjE2X1NVUlJPR0FURSwgaSAtIDEgLSBleHRyYUxlbmd0aCwgYnl0ZXMsIHJlc3VsdCwgcmVzKTtcblx0ICAgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIENoZWNrIGZvciBvdmVybG9uZyBzZXF1ZW5jZXMgKG1vcmUgYnl0ZXMgdGhhbiBuZWVkZWQpXG5cdCAgICAgICAgaWYgKHJlcyA8PSBvdmVybG9uZ01hc2spIHtcblx0ICAgICAgICAgICAgaSArPSBvbkVycm9yKFV0ZjhFcnJvclJlYXNvbi5PVkVSTE9ORywgaSAtIDEgLSBleHRyYUxlbmd0aCwgYnl0ZXMsIHJlc3VsdCwgcmVzKTtcblx0ICAgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJlc3VsdC5wdXNoKHJlcyk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHR9XG5cdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTg3Mjk0MDUvaG93LXRvLWNvbnZlcnQtdXRmOC1zdHJpbmctdG8tYnl0ZS1hcnJheVxuXHRmdW5jdGlvbiB0b1V0ZjhCeXRlcyhzdHIsIGZvcm0pIHtcblx0ICAgIGlmIChmb3JtID09PSB2b2lkIDApIHsgZm9ybSA9IFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybS5jdXJyZW50OyB9XG5cdCAgICBpZiAoZm9ybSAhPSBVbmljb2RlTm9ybWFsaXphdGlvbkZvcm0uY3VycmVudCkge1xuXHQgICAgICAgIGxvZ2dlci5jaGVja05vcm1hbGl6ZSgpO1xuXHQgICAgICAgIHN0ciA9IHN0ci5ub3JtYWxpemUoZm9ybSk7XG5cdCAgICB9XG5cdCAgICB2YXIgcmVzdWx0ID0gW107XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG5cdCAgICAgICAgaWYgKGMgPCAweDgwKSB7XG5cdCAgICAgICAgICAgIHJlc3VsdC5wdXNoKGMpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIGlmIChjIDwgMHg4MDApIHtcblx0ICAgICAgICAgICAgcmVzdWx0LnB1c2goKGMgPj4gNikgfCAweGMwKTtcblx0ICAgICAgICAgICAgcmVzdWx0LnB1c2goKGMgJiAweDNmKSB8IDB4ODApO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIGlmICgoYyAmIDB4ZmMwMCkgPT0gMHhkODAwKSB7XG5cdCAgICAgICAgICAgIGkrKztcblx0ICAgICAgICAgICAgdmFyIGMyID0gc3RyLmNoYXJDb2RlQXQoaSk7XG5cdCAgICAgICAgICAgIGlmIChpID49IHN0ci5sZW5ndGggfHwgKGMyICYgMHhmYzAwKSAhPT0gMHhkYzAwKSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHV0Zi04IHN0cmluZ1wiKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAvLyBTdXJyb2dhdGUgUGFpclxuXHQgICAgICAgICAgICB2YXIgcGFpciA9IDB4MTAwMDAgKyAoKGMgJiAweDAzZmYpIDw8IDEwKSArIChjMiAmIDB4MDNmZik7XG5cdCAgICAgICAgICAgIHJlc3VsdC5wdXNoKChwYWlyID4+IDE4KSB8IDB4ZjApO1xuXHQgICAgICAgICAgICByZXN1bHQucHVzaCgoKHBhaXIgPj4gMTIpICYgMHgzZikgfCAweDgwKTtcblx0ICAgICAgICAgICAgcmVzdWx0LnB1c2goKChwYWlyID4+IDYpICYgMHgzZikgfCAweDgwKTtcblx0ICAgICAgICAgICAgcmVzdWx0LnB1c2goKHBhaXIgJiAweDNmKSB8IDB4ODApO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgcmVzdWx0LnB1c2goKGMgPj4gMTIpIHwgMHhlMCk7XG5cdCAgICAgICAgICAgIHJlc3VsdC5wdXNoKCgoYyA+PiA2KSAmIDB4M2YpIHwgMHg4MCk7XG5cdCAgICAgICAgICAgIHJlc3VsdC5wdXNoKChjICYgMHgzZikgfCAweDgwKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbGliJDEuYXJyYXlpZnkocmVzdWx0KTtcblx0fVxuXHRleHBvcnRzLnRvVXRmOEJ5dGVzID0gdG9VdGY4Qnl0ZXM7XG5cdDtcblx0ZnVuY3Rpb24gZXNjYXBlQ2hhcih2YWx1ZSkge1xuXHQgICAgdmFyIGhleCA9IChcIjAwMDBcIiArIHZhbHVlLnRvU3RyaW5nKDE2KSk7XG5cdCAgICByZXR1cm4gXCJcXFxcdVwiICsgaGV4LnN1YnN0cmluZyhoZXgubGVuZ3RoIC0gNCk7XG5cdH1cblx0ZnVuY3Rpb24gX3RvRXNjYXBlZFV0ZjhTdHJpbmcoYnl0ZXMsIG9uRXJyb3IpIHtcblx0ICAgIHJldHVybiAnXCInICsgZ2V0VXRmOENvZGVQb2ludHMoYnl0ZXMsIG9uRXJyb3IpLm1hcChmdW5jdGlvbiAoY29kZVBvaW50KSB7XG5cdCAgICAgICAgaWYgKGNvZGVQb2ludCA8IDI1Nikge1xuXHQgICAgICAgICAgICBzd2l0Y2ggKGNvZGVQb2ludCkge1xuXHQgICAgICAgICAgICAgICAgY2FzZSA4OiByZXR1cm4gXCJcXFxcYlwiO1xuXHQgICAgICAgICAgICAgICAgY2FzZSA5OiByZXR1cm4gXCJcXFxcdFwiO1xuXHQgICAgICAgICAgICAgICAgY2FzZSAxMDogcmV0dXJuIFwiXFxcXG5cIjtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMTM6IHJldHVybiBcIlxcXFxyXCI7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDM0OiByZXR1cm4gXCJcXFxcXFxcIlwiO1xuXHQgICAgICAgICAgICAgICAgY2FzZSA5MjogcmV0dXJuIFwiXFxcXFxcXFxcIjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAoY29kZVBvaW50ID49IDMyICYmIGNvZGVQb2ludCA8IDEyNykge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZVBvaW50KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoY29kZVBvaW50IDw9IDB4ZmZmZikge1xuXHQgICAgICAgICAgICByZXR1cm4gZXNjYXBlQ2hhcihjb2RlUG9pbnQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMDtcblx0ICAgICAgICByZXR1cm4gZXNjYXBlQ2hhcigoKGNvZGVQb2ludCA+PiAxMCkgJiAweDNmZikgKyAweGQ4MDApICsgZXNjYXBlQ2hhcigoY29kZVBvaW50ICYgMHgzZmYpICsgMHhkYzAwKTtcblx0ICAgIH0pLmpvaW4oXCJcIikgKyAnXCInO1xuXHR9XG5cdGV4cG9ydHMuX3RvRXNjYXBlZFV0ZjhTdHJpbmcgPSBfdG9Fc2NhcGVkVXRmOFN0cmluZztcblx0ZnVuY3Rpb24gX3RvVXRmOFN0cmluZyhjb2RlUG9pbnRzKSB7XG5cdCAgICByZXR1cm4gY29kZVBvaW50cy5tYXAoZnVuY3Rpb24gKGNvZGVQb2ludCkge1xuXHQgICAgICAgIGlmIChjb2RlUG9pbnQgPD0gMHhmZmZmKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwO1xuXHQgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoKGNvZGVQb2ludCA+PiAxMCkgJiAweDNmZikgKyAweGQ4MDApLCAoKGNvZGVQb2ludCAmIDB4M2ZmKSArIDB4ZGMwMCkpO1xuXHQgICAgfSkuam9pbihcIlwiKTtcblx0fVxuXHRleHBvcnRzLl90b1V0ZjhTdHJpbmcgPSBfdG9VdGY4U3RyaW5nO1xuXHRmdW5jdGlvbiB0b1V0ZjhTdHJpbmcoYnl0ZXMsIG9uRXJyb3IpIHtcblx0ICAgIHJldHVybiBfdG9VdGY4U3RyaW5nKGdldFV0ZjhDb2RlUG9pbnRzKGJ5dGVzLCBvbkVycm9yKSk7XG5cdH1cblx0ZXhwb3J0cy50b1V0ZjhTdHJpbmcgPSB0b1V0ZjhTdHJpbmc7XG5cdGZ1bmN0aW9uIHRvVXRmOENvZGVQb2ludHMoc3RyLCBmb3JtKSB7XG5cdCAgICBpZiAoZm9ybSA9PT0gdm9pZCAwKSB7IGZvcm0gPSBVbmljb2RlTm9ybWFsaXphdGlvbkZvcm0uY3VycmVudDsgfVxuXHQgICAgcmV0dXJuIGdldFV0ZjhDb2RlUG9pbnRzKHRvVXRmOEJ5dGVzKHN0ciwgZm9ybSkpO1xuXHR9XG5cdGV4cG9ydHMudG9VdGY4Q29kZVBvaW50cyA9IHRvVXRmOENvZGVQb2ludHM7XG5cblx0fSk7XG5cblx0dmFyIHV0ZjgkMSA9IHVud3JhcEV4cG9ydHModXRmOCk7XG5cdHZhciB1dGY4XzEgPSB1dGY4LlVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybTtcblx0dmFyIHV0ZjhfMiA9IHV0ZjguVXRmOEVycm9yUmVhc29uO1xuXHR2YXIgdXRmOF8zID0gdXRmOC5VdGY4RXJyb3JGdW5jcztcblx0dmFyIHV0ZjhfNCA9IHV0ZjgudG9VdGY4Qnl0ZXM7XG5cdHZhciB1dGY4XzUgPSB1dGY4Ll90b0VzY2FwZWRVdGY4U3RyaW5nO1xuXHR2YXIgdXRmOF82ID0gdXRmOC5fdG9VdGY4U3RyaW5nO1xuXHR2YXIgdXRmOF83ID0gdXRmOC50b1V0ZjhTdHJpbmc7XG5cdHZhciB1dGY4XzggPSB1dGY4LnRvVXRmOENvZGVQb2ludHM7XG5cblx0dmFyIGJ5dGVzMzIgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cblxuXG5cdGZ1bmN0aW9uIGZvcm1hdEJ5dGVzMzJTdHJpbmcodGV4dCkge1xuXHQgICAgLy8gR2V0IHRoZSBieXRlc1xuXHQgICAgdmFyIGJ5dGVzID0gdXRmOC50b1V0ZjhCeXRlcyh0ZXh0KTtcblx0ICAgIC8vIENoZWNrIHdlIGhhdmUgcm9vbSBmb3IgbnVsbC10ZXJtaW5hdGlvblxuXHQgICAgaWYgKGJ5dGVzLmxlbmd0aCA+IDMxKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYnl0ZXMzMiBzdHJpbmcgbXVzdCBiZSBsZXNzIHRoYW4gMzIgYnl0ZXNcIik7XG5cdCAgICB9XG5cdCAgICAvLyBaZXJvLXBhZCAoaW1wbGljaXRseSBudWxsLXRlcm1pbmF0ZXMpXG5cdCAgICByZXR1cm4gbGliJDEuaGV4bGlmeShsaWIkMS5jb25jYXQoW2J5dGVzLCBsaWIkNy5IYXNoWmVyb10pLnNsaWNlKDAsIDMyKSk7XG5cdH1cblx0ZXhwb3J0cy5mb3JtYXRCeXRlczMyU3RyaW5nID0gZm9ybWF0Qnl0ZXMzMlN0cmluZztcblx0ZnVuY3Rpb24gcGFyc2VCeXRlczMyU3RyaW5nKGJ5dGVzKSB7XG5cdCAgICB2YXIgZGF0YSA9IGxpYiQxLmFycmF5aWZ5KGJ5dGVzKTtcblx0ICAgIC8vIE11c3QgYmUgMzIgYnl0ZXMgd2l0aCBhIG51bGwtdGVybWluYXRpb25cblx0ICAgIGlmIChkYXRhLmxlbmd0aCAhPT0gMzIpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGJ5dGVzMzIgLSBub3QgMzIgYnl0ZXMgbG9uZ1wiKTtcblx0ICAgIH1cblx0ICAgIGlmIChkYXRhWzMxXSAhPT0gMCkge1xuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYnl0ZXMzMiBzdHJpbmcgLSBubyBudWxsIHRlcm1pbmF0b3JcIik7XG5cdCAgICB9XG5cdCAgICAvLyBGaW5kIHRoZSBudWxsIHRlcm1pbmF0aW9uXG5cdCAgICB2YXIgbGVuZ3RoID0gMzE7XG5cdCAgICB3aGlsZSAoZGF0YVtsZW5ndGggLSAxXSA9PT0gMCkge1xuXHQgICAgICAgIGxlbmd0aC0tO1xuXHQgICAgfVxuXHQgICAgLy8gRGV0ZXJtaW5lIHRoZSBzdHJpbmcgdmFsdWVcblx0ICAgIHJldHVybiB1dGY4LnRvVXRmOFN0cmluZyhkYXRhLnNsaWNlKDAsIGxlbmd0aCkpO1xuXHR9XG5cdGV4cG9ydHMucGFyc2VCeXRlczMyU3RyaW5nID0gcGFyc2VCeXRlczMyU3RyaW5nO1xuXG5cdH0pO1xuXG5cdHZhciBieXRlczMyJDEgPSB1bndyYXBFeHBvcnRzKGJ5dGVzMzIpO1xuXHR2YXIgYnl0ZXMzMl8xID0gYnl0ZXMzMi5mb3JtYXRCeXRlczMyU3RyaW5nO1xuXHR2YXIgYnl0ZXMzMl8yID0gYnl0ZXMzMi5wYXJzZUJ5dGVzMzJTdHJpbmc7XG5cblx0dmFyIGlkbmEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cblx0ZnVuY3Rpb24gYnl0ZXMyKGRhdGEpIHtcblx0ICAgIGlmICgoZGF0YS5sZW5ndGggJSA0KSAhPT0gMCkge1xuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJhZCBkYXRhXCIpO1xuXHQgICAgfVxuXHQgICAgdmFyIHJlc3VsdCA9IFtdO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSA0KSB7XG5cdCAgICAgICAgcmVzdWx0LnB1c2gocGFyc2VJbnQoZGF0YS5zdWJzdHJpbmcoaSwgaSArIDQpLCAxNikpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVUYWJsZShkYXRhLCBmdW5jKSB7XG5cdCAgICBpZiAoIWZ1bmMpIHtcblx0ICAgICAgICBmdW5jID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBbcGFyc2VJbnQodmFsdWUsIDE2KV07IH07XG5cdCAgICB9XG5cdCAgICB2YXIgbG8gPSAwO1xuXHQgICAgdmFyIHJlc3VsdCA9IHt9O1xuXHQgICAgZGF0YS5zcGxpdChcIixcIikuZm9yRWFjaChmdW5jdGlvbiAocGFpcikge1xuXHQgICAgICAgIHZhciBjb21wcyA9IHBhaXIuc3BsaXQoXCI6XCIpO1xuXHQgICAgICAgIGxvICs9IHBhcnNlSW50KGNvbXBzWzBdLCAxNik7XG5cdCAgICAgICAgcmVzdWx0W2xvXSA9IGZ1bmMoY29tcHNbMV0pO1xuXHQgICAgfSk7XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHR9XG5cdGZ1bmN0aW9uIGNyZWF0ZVJhbmdlVGFibGUoZGF0YSkge1xuXHQgICAgdmFyIGhpID0gMDtcblx0ICAgIHJldHVybiBkYXRhLnNwbGl0KFwiLFwiKS5tYXAoZnVuY3Rpb24gKHYpIHtcblx0ICAgICAgICB2YXIgY29tcHMgPSB2LnNwbGl0KFwiLVwiKTtcblx0ICAgICAgICBpZiAoY29tcHMubGVuZ3RoID09PSAxKSB7XG5cdCAgICAgICAgICAgIGNvbXBzWzFdID0gXCIwXCI7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2UgaWYgKGNvbXBzWzFdID09PSBcIlwiKSB7XG5cdCAgICAgICAgICAgIGNvbXBzWzFdID0gXCIxXCI7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBsbyA9IGhpICsgcGFyc2VJbnQoY29tcHNbMF0sIDE2KTtcblx0ICAgICAgICBoaSA9IHBhcnNlSW50KGNvbXBzWzFdLCAxNik7XG5cdCAgICAgICAgcmV0dXJuIHsgbDogbG8sIGg6IGhpIH07XG5cdCAgICB9KTtcblx0fVxuXHRmdW5jdGlvbiBtYXRjaE1hcCh2YWx1ZSwgcmFuZ2VzKSB7XG5cdCAgICB2YXIgbG8gPSAwO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICB2YXIgcmFuZ2UgPSByYW5nZXNbaV07XG5cdCAgICAgICAgbG8gKz0gcmFuZ2UubDtcblx0ICAgICAgICBpZiAodmFsdWUgPj0gbG8gJiYgdmFsdWUgPD0gbG8gKyByYW5nZS5oICYmICgodmFsdWUgLSBsbykgJSAocmFuZ2UuZCB8fCAxKSkgPT09IDApIHtcblx0ICAgICAgICAgICAgaWYgKHJhbmdlLmUgJiYgcmFuZ2UuZS5pbmRleE9mKHZhbHVlIC0gbG8pICE9PSAtMSkge1xuXHQgICAgICAgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHJhbmdlO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiBudWxsO1xuXHR9XG5cdHZhciBUYWJsZV9BXzFfcmFuZ2VzID0gY3JlYXRlUmFuZ2VUYWJsZShcIjIyMSwxMy0xYiw1Zi0sNDAtMTAsNTEtZiwxMS0zLDMtMywyLTIsMi00LDgsMiwxNSwyZCwyOC04LDg4LDQ4LDI3LSwzLTUsMTEtMjAsMjctLDgsMjgsMy01LDEyLDE4LGItYSwxYy00LDYtMTYsMi1kLDItMiwyLDFiLTQsMTctOSw4Zi0sMTAsZiwxZi0yLDFjLTM0LDMzLTE0ZSw0LDM2LSwxMy0sNi0yLDFhLWYsNCw5LSwzLSwxNyw4LDItMiw1LSwyLDgtLDMtLDQtOCwyLTMsMyw2LSwxNi02LDItLDctMywzLSwxNyw4LDMsMywzLSwyLDYtMywzLSw0LWEsNSwyLTYsMTAtYiw0LDgsMiw0LDE3LDgsMyw2LSxiLDQsNC0sMi1lLDItNCxiLTEwLDQsOS0sMy0sMTcsOCwzLSw1LSw5LTIsMy0sNC03LDMtMywzLDQtMyxjLTEwLDMsNy0yLDQsNS0yLDMsMiwzLTIsMy0yLDQtMiw5LDQtMyw2LTIsNCw1LTgsMi1lLGQtZCw0LDksNCwxOCxiLDYtMyw4LDQsNS02LDMtOCwzLTMsYi0xMSwzLDksNCwxOCxiLDYtMyw4LDQsNS02LDMtNiwyLDMtMyxiLTExLDMsOSw0LDE4LDExLTMsNy0sNCw1LTgsMi03LDMtMyxiLTExLDMsMTMtMiwxOSxhLDItLDgtMiwyLTMsNywyLDktMTEsNC1iLDNiLTMsMWUtMjQsMywyLSwzLDItLDItNSw1LDgsNCwyLDItLDMsZSw0LSw2LDIsNy0sYi0sMy0yMSw0OSwyMy01LDFjLTMsOSwyNSwxMC0sMi0yZiwyMyw2LDMsOC0yLDUtNSwxYi00NSwyNy05LDJhLSwyLTMsNWItNCw0NS00LDUzLTUsOCw0MCwyLDUtLDgsMiw1LSwyOCwyLDUtLDIwLDIsNS0sOCwyLDUtLDgsOCwxOCwyMCwyLDUtLDgsMjgsMTQtNSwxZC0yMiw1Ni1iLDI3Ny04LDFlLTIsNTItZSxlLDgtYSwxOC04LDE1LWIsZSw0LDMtYiw1ZS0yLGItMTUsMTAsYi01LDU5LTcsMmItNTU1LDlkLTMsNWItNSwxNy0sNy0sMjctLDctLDksMiwyLDIsMjAtLDM2LDEwLGYtLDcsMTQtLDQsYSw1NC0zLDItNiw2LTUsOS0sMWMtMTAsMTMtMWQsMWMtMTQsM2MtLDEwLTYsMzItYiwyNDAtMzAsMjgtMTgsYy0xNCxhMCwxMTUtLDMsNjYtLGItNzYsNSw1LSwxZCwyNCwyLDUtMiwyLDgtLDM1LTIsMTksZi0xMCwxZC0zLDMxMS0zN2YsMWIsNWEtYixkNy0xOSxkLTMsNDEsNTctLDY4LTQsMjktMyw1ZiwyOS0zNywyZS0yLDI1LWMsMmMtMiw0ZS0zLDMwLDc4LTMsNjQtLDIwLDE5YjctNDksNTFhNy01OSw0OGUtMiwzOC03MzgsMmJhNS01YiwyMjJmLSwzYy05NCw4LWIsNi00LDFiLDYsMiwzLDMsNmQtMjAsMTZlLWYsNDEtLDM3LTcsMmUtMiwxMS1mLDUtYiwxOC0sYiwxNCw1LTMsNiw4OC0sMixiZi0yLDctLDctLDctLDQtMiw4LDgtOSw4LTJmZiwyMCw1LWIsMWMtYjQsMjctLDI3LWNiYjEsZjctOSwyOC0yLGI1LTIyMSw1Niw0OCwzLSwyLSwzLSw1LGQsMiw1LDMsNDIsNS0sOSw4LDFkLDUsNiwyLTIsOCwxNTMtMywxMjMtMywzMy0yN2ZkLGE2ZGEtNTEyOCwyMWYtNWRmLDMtZmZmZCwzLWZmZmQsMy1mZmZkLDMtZmZmZCwzLWZmZmQsMy1mZmZkLDMtZmZmZCwzLWZmZmQsMy1mZmZkLDMtZmZmZCwzLWZmZmQsMywyLTFkLDYxLWZmN2RcIik7XG5cdC8vIEBUT0RPOiBNYWtlIHRoaXMgcmVsYXRpdmUuLi5cblx0dmFyIFRhYmxlX0JfMV9mbGFncyA9IFwiYWQsMzRmLDE4MDYsMTgwYiwxODBjLDE4MGQsMjAwYiwyMDBjLDIwMGQsMjA2MCxmZWZmXCIuc3BsaXQoXCIsXCIpLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gcGFyc2VJbnQodiwgMTYpOyB9KTtcblx0dmFyIFRhYmxlX0JfMl9yYW5nZXMgPSBbXG5cdCAgICB7IGg6IDI1LCBzOiAzMiwgbDogNjUgfSxcblx0ICAgIHsgaDogMzAsIHM6IDMyLCBlOiBbMjNdLCBsOiAxMjcgfSxcblx0ICAgIHsgaDogNTQsIHM6IDEsIGU6IFs0OF0sIGw6IDY0LCBkOiAyIH0sXG5cdCAgICB7IGg6IDE0LCBzOiAxLCBsOiA1NywgZDogMiB9LFxuXHQgICAgeyBoOiA0NCwgczogMSwgbDogMTcsIGQ6IDIgfSxcblx0ICAgIHsgaDogMTAsIHM6IDEsIGU6IFsyLCA2LCA4XSwgbDogNjEsIGQ6IDIgfSxcblx0ICAgIHsgaDogMTYsIHM6IDEsIGw6IDY4LCBkOiAyIH0sXG5cdCAgICB7IGg6IDg0LCBzOiAxLCBlOiBbMTgsIDI0LCA2Nl0sIGw6IDE5LCBkOiAyIH0sXG5cdCAgICB7IGg6IDI2LCBzOiAzMiwgZTogWzE3XSwgbDogNDM1IH0sXG5cdCAgICB7IGg6IDIyLCBzOiAxLCBsOiA3MSwgZDogMiB9LFxuXHQgICAgeyBoOiAxNSwgczogODAsIGw6IDQwIH0sXG5cdCAgICB7IGg6IDMxLCBzOiAzMiwgbDogMTYgfSxcblx0ICAgIHsgaDogMzIsIHM6IDEsIGw6IDgwLCBkOiAyIH0sXG5cdCAgICB7IGg6IDUyLCBzOiAxLCBsOiA0MiwgZDogMiB9LFxuXHQgICAgeyBoOiAxMiwgczogMSwgbDogNTUsIGQ6IDIgfSxcblx0ICAgIHsgaDogNDAsIHM6IDEsIGU6IFszOF0sIGw6IDE1LCBkOiAyIH0sXG5cdCAgICB7IGg6IDE0LCBzOiAxLCBsOiA0OCwgZDogMiB9LFxuXHQgICAgeyBoOiAzNywgczogNDgsIGw6IDQ5IH0sXG5cdCAgICB7IGg6IDE0OCwgczogMSwgbDogNjM1MSwgZDogMiB9LFxuXHQgICAgeyBoOiA4OCwgczogMSwgbDogMTYwLCBkOiAyIH0sXG5cdCAgICB7IGg6IDE1LCBzOiAxNiwgbDogNzA0IH0sXG5cdCAgICB7IGg6IDI1LCBzOiAyNiwgbDogODU0IH0sXG5cdCAgICB7IGg6IDI1LCBzOiAzMiwgbDogNTU5MTUgfSxcblx0ICAgIHsgaDogMzcsIHM6IDQwLCBsOiAxMjQ3IH0sXG5cdCAgICB7IGg6IDI1LCBzOiAtMTE5NzExLCBsOiA1MzI0OCB9LFxuXHQgICAgeyBoOiAyNSwgczogLTExOTc2MywgbDogNTIgfSxcblx0ICAgIHsgaDogMjUsIHM6IC0xMTk4MTUsIGw6IDUyIH0sXG5cdCAgICB7IGg6IDI1LCBzOiAtMTE5ODY3LCBlOiBbMSwgNCwgNSwgNywgOCwgMTEsIDEyLCAxN10sIGw6IDUyIH0sXG5cdCAgICB7IGg6IDI1LCBzOiAtMTE5OTE5LCBsOiA1MiB9LFxuXHQgICAgeyBoOiAyNCwgczogLTExOTk3MSwgZTogWzIsIDcsIDgsIDE3XSwgbDogNTIgfSxcblx0ICAgIHsgaDogMjQsIHM6IC0xMjAwMjMsIGU6IFsyLCA3LCAxMywgMTUsIDE2LCAxN10sIGw6IDUyIH0sXG5cdCAgICB7IGg6IDI1LCBzOiAtMTIwMDc1LCBsOiA1MiB9LFxuXHQgICAgeyBoOiAyNSwgczogLTEyMDEyNywgbDogNTIgfSxcblx0ICAgIHsgaDogMjUsIHM6IC0xMjAxNzksIGw6IDUyIH0sXG5cdCAgICB7IGg6IDI1LCBzOiAtMTIwMjMxLCBsOiA1MiB9LFxuXHQgICAgeyBoOiAyNSwgczogLTEyMDI4MywgbDogNTIgfSxcblx0ICAgIHsgaDogMjUsIHM6IC0xMjAzMzUsIGw6IDUyIH0sXG5cdCAgICB7IGg6IDI0LCBzOiAtMTE5NTQzLCBlOiBbMTddLCBsOiA1NiB9LFxuXHQgICAgeyBoOiAyNCwgczogLTExOTYwMSwgZTogWzE3XSwgbDogNTggfSxcblx0ICAgIHsgaDogMjQsIHM6IC0xMTk2NTksIGU6IFsxN10sIGw6IDU4IH0sXG5cdCAgICB7IGg6IDI0LCBzOiAtMTE5NzE3LCBlOiBbMTddLCBsOiA1OCB9LFxuXHQgICAgeyBoOiAyNCwgczogLTExOTc3NSwgZTogWzE3XSwgbDogNTggfVxuXHRdO1xuXHR2YXIgVGFibGVfQl8yX2x1dF9hYnMgPSBjcmVhdGVUYWJsZShcImI1OjNiYyxjMzpmZiw3OjczLDI6MjUzLDU6MjU0LDM6MjU2LDE6MjU3LDU6MjU5LDE6MjViLDM6MjYwLDE6MjYzLDI6MjY5LDE6MjY4LDU6MjZmLDE6MjcyLDI6Mjc1LDc6MjgwLDM6MjgzLDU6Mjg4LDM6MjhhLDE6MjhiLDU6MjkyLDNmOjE5NSwxOjFiZiwyOToxOWUsMTI1OjNiOSw4YjozYjIsMTozYjgsMTozYzUsMzozYzYsMTozYzAsMWE6M2JhLDE6M2MxLDE6M2MzLDI6M2I4LDE6M2I1LDFiYzk6M2I5LDFjOjFmNzYsMToxZjc3LGY6MWY3YSwxOjFmN2IsZDoxZjc4LDE6MWY3OSwxOjFmN2MsMToxZjdkLDEwNzo2Myw1OjI1Yiw0OjY4LDE6NjgsMTo2OCwzOjY5LDE6NjksMTo2YywzOjZlLDQ6NzAsMTo3MSwxOjcyLDE6NzIsMTo3Miw3OjdhLDI6M2M5LDI6N2EsMjo2YiwxOmU1LDE6NjIsMTo2MywzOjY1LDE6NjYsMjo2ZCxiOjNiMywxOjNjMCw2OjY0LDFiNTc0OjNiOCwxYTozYzMsMjA6M2I4LDFhOjNjMywyMDozYjgsMWE6M2MzLDIwOjNiOCwxYTozYzMsMjA6M2I4LDFhOjNjM1wiKTtcblx0dmFyIFRhYmxlX0JfMl9sdXRfcmVsID0gY3JlYXRlVGFibGUoXCIxNzk6MSwyOjEsMjoxLDU6MSwyOjEsYTo0ZixhOjEsODoxLDI6MSwyOjEsMzoxLDU6MSwzOjEsNDoxLDI6MSwzOjEsNDoxLDg6MiwxOjEsMjoyLDE6MSwyOjIsMjc6MiwxOTU6MjYsMjoyNSwxOjI1LDE6MjUsMjo0MCwyOjNmLDE6M2YsMzM6MSwxMTotNiwxOi05LDFhYzc6LTNhLDZkOi04LDE6LTgsMTotOCwxOi04LDE6LTgsMTotOCwxOi04LDE6LTgsOTotOCwxOi04LDE6LTgsMTotOCwxOi04LDE6LTgsYjotOCwxOi04LDE6LTgsMTotOCwxOi04LDE6LTgsMTotOCwxOi04LDk6LTgsMTotOCwxOi04LDE6LTgsMTotOCwxOi04LDE6LTgsMTotOCw5Oi04LDE6LTgsMTotOCwxOi04LDE6LTgsMTotOCxjOi04LDI6LTgsMjotOCwyOi04LDk6LTgsMTotOCwxOi04LDE6LTgsMTotOCwxOi04LDE6LTgsMTotOCw0OTotOCwxOi04LDE6LTRhLDE6LTRhLGQ6LTU2LDE6LTU2LDE6LTU2LDE6LTU2LGQ6LTgsMTotOCxmOi04LDE6LTgsMzotN1wiKTtcblx0dmFyIFRhYmxlX0JfMl9jb21wbGV4ID0gY3JlYXRlVGFibGUoXCJkZjowMDczMDA3Myw1MTowMDY5MDMwNywxOTowMkJDMDA2RSxhNzowMDZBMDMwQywxOGE6MDAyMDAzQjksMTY6MDNCOTAzMDgwMzAxLDIwOjAzQzUwMzA4MDMwMSwxZDc6MDU2NTA1ODIsMTkwZjowMDY4MDMzMSwxOjAwNzQwMzA4LDE6MDA3NzAzMEEsMTowMDc5MDMwQSwxOjAwNjEwMkJFLGI2OjAzQzUwMzEzLDI6MDNDNTAzMTMwMzAwLDI6MDNDNTAzMTMwMzAxLDI6MDNDNTAzMTMwMzQyLDJhOjFGMDAwM0I5LDE6MUYwMTAzQjksMToxRjAyMDNCOSwxOjFGMDMwM0I5LDE6MUYwNDAzQjksMToxRjA1MDNCOSwxOjFGMDYwM0I5LDE6MUYwNzAzQjksMToxRjAwMDNCOSwxOjFGMDEwM0I5LDE6MUYwMjAzQjksMToxRjAzMDNCOSwxOjFGMDQwM0I5LDE6MUYwNTAzQjksMToxRjA2MDNCOSwxOjFGMDcwM0I5LDE6MUYyMDAzQjksMToxRjIxMDNCOSwxOjFGMjIwM0I5LDE6MUYyMzAzQjksMToxRjI0MDNCOSwxOjFGMjUwM0I5LDE6MUYyNjAzQjksMToxRjI3MDNCOSwxOjFGMjAwM0I5LDE6MUYyMTAzQjksMToxRjIyMDNCOSwxOjFGMjMwM0I5LDE6MUYyNDAzQjksMToxRjI1MDNCOSwxOjFGMjYwM0I5LDE6MUYyNzAzQjksMToxRjYwMDNCOSwxOjFGNjEwM0I5LDE6MUY2MjAzQjksMToxRjYzMDNCOSwxOjFGNjQwM0I5LDE6MUY2NTAzQjksMToxRjY2MDNCOSwxOjFGNjcwM0I5LDE6MUY2MDAzQjksMToxRjYxMDNCOSwxOjFGNjIwM0I5LDE6MUY2MzAzQjksMToxRjY0MDNCOSwxOjFGNjUwM0I5LDE6MUY2NjAzQjksMToxRjY3MDNCOSwzOjFGNzAwM0I5LDE6MDNCMTAzQjksMTowM0FDMDNCOSwyOjAzQjEwMzQyLDE6MDNCMTAzNDIwM0I5LDU6MDNCMTAzQjksNjoxRjc0MDNCOSwxOjAzQjcwM0I5LDE6MDNBRTAzQjksMjowM0I3MDM0MiwxOjAzQjcwMzQyMDNCOSw1OjAzQjcwM0I5LDY6MDNCOTAzMDgwMzAwLDE6MDNCOTAzMDgwMzAxLDM6MDNCOTAzNDIsMTowM0I5MDMwODAzNDIsYjowM0M1MDMwODAzMDAsMTowM0M1MDMwODAzMDEsMTowM0MxMDMxMywyOjAzQzUwMzQyLDE6MDNDNTAzMDgwMzQyLGI6MUY3QzAzQjksMTowM0M5MDNCOSwxOjAzQ0UwM0I5LDI6MDNDOTAzNDIsMTowM0M5MDM0MjAzQjksNTowM0M5MDNCOSxhYzowMDcyMDA3Myw1YjowMEIwMDA2Myw2OjAwQjAwMDY2LGQ6MDA2RTAwNkYsYTowMDczMDA2RCwxOjAwNzQwMDY1MDA2QywxOjAwNzQwMDZELDEyNGY6MDA2ODAwNzAwMDYxLDI6MDA2MTAwNzUsMjowMDZGMDA3NixiOjAwNzAwMDYxLDE6MDA2RTAwNjEsMTowM0JDMDA2MSwxOjAwNkQwMDYxLDE6MDA2QjAwNjEsMTowMDZCMDA2MiwxOjAwNkQwMDYyLDE6MDA2NzAwNjIsMzowMDcwMDA2NiwxOjAwNkUwMDY2LDE6MDNCQzAwNjYsNDowMDY4MDA3QSwxOjAwNkIwMDY4MDA3QSwxOjAwNkQwMDY4MDA3QSwxOjAwNjcwMDY4MDA3QSwxOjAwNzQwMDY4MDA3QSwxNTowMDcwMDA2MSwxOjAwNkIwMDcwMDA2MSwxOjAwNkQwMDcwMDA2MSwxOjAwNjcwMDcwMDA2MSw4OjAwNzAwMDc2LDE6MDA2RTAwNzYsMTowM0JDMDA3NiwxOjAwNkQwMDc2LDE6MDA2QjAwNzYsMTowMDZEMDA3NiwxOjAwNzAwMDc3LDE6MDA2RTAwNzcsMTowM0JDMDA3NywxOjAwNkQwMDc3LDE6MDA2QjAwNzcsMTowMDZEMDA3NywxOjAwNkIwM0M5LDE6MDA2RDAzQzksMjowMDYyMDA3MSwzOjAwNjMyMjE1MDA2QjAwNjcsMTowMDYzMDA2RjAwMkUsMTowMDY0MDA2MiwxOjAwNjcwMDc5LDI6MDA2ODAwNzAsMjowMDZCMDA2QiwxOjAwNkIwMDZELDk6MDA3MDAwNjgsMjowMDcwMDA3MDAwNkQsMTowMDcwMDA3MiwyOjAwNzMwMDc2LDE6MDA3NzAwNjIsYzcyMzowMDY2MDA2NiwxOjAwNjYwMDY5LDE6MDA2NjAwNkMsMTowMDY2MDA2NjAwNjksMTowMDY2MDA2NjAwNkMsMTowMDczMDA3NCwxOjAwNzMwMDc0LGQ6MDU3NDA1NzYsMTowNTc0MDU2NSwxOjA1NzQwNTZCLDE6MDU3RTA1NzYsMTowNTc0MDU2RFwiLCBieXRlczIpO1xuXHR2YXIgVGFibGVfQ19yYW5nZXMgPSBjcmVhdGVSYW5nZVRhYmxlKFwiODAtMjAsMmEwLSwzOWMsMzIsZjcxLDE4ZSw3ZjItZiwxOS03LDMwLTQsNy01LGY4MS1iLDUsYTgwMC0yMGZmLDRkMS0xZiwxMTAsZmEtNixkMTc0LTcsMmU4NC0sZmZmZi0sZmZmZi0sZmZmZi0sZmZmZi0sZmZmZi0sZmZmZi0sZmZmZi0sZmZmZi0sZmZmZi0sZmZmZi0sZmZmZi0sZmZmZi0sMiwxZi01ZixmZjdmLTIwMDAxXCIpO1xuXHRmdW5jdGlvbiBmbGF0dGVuKHZhbHVlcykge1xuXHQgICAgcmV0dXJuIHZhbHVlcy5yZWR1Y2UoZnVuY3Rpb24gKGFjY3VtLCB2YWx1ZSkge1xuXHQgICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7IGFjY3VtLnB1c2godmFsdWUpOyB9KTtcblx0ICAgICAgICByZXR1cm4gYWNjdW07XG5cdCAgICB9LCBbXSk7XG5cdH1cblx0ZnVuY3Rpb24gX25hbWVwcmVwVGFibGVBMShjb2RlcG9pbnQpIHtcblx0ICAgIHJldHVybiAhIW1hdGNoTWFwKGNvZGVwb2ludCwgVGFibGVfQV8xX3Jhbmdlcyk7XG5cdH1cblx0ZXhwb3J0cy5fbmFtZXByZXBUYWJsZUExID0gX25hbWVwcmVwVGFibGVBMTtcblx0ZnVuY3Rpb24gX25hbWVwcmVwVGFibGVCMihjb2RlcG9pbnQpIHtcblx0ICAgIHZhciByYW5nZSA9IG1hdGNoTWFwKGNvZGVwb2ludCwgVGFibGVfQl8yX3Jhbmdlcyk7XG5cdCAgICBpZiAocmFuZ2UpIHtcblx0ICAgICAgICByZXR1cm4gW2NvZGVwb2ludCArIHJhbmdlLnNdO1xuXHQgICAgfVxuXHQgICAgdmFyIGNvZGVzID0gVGFibGVfQl8yX2x1dF9hYnNbY29kZXBvaW50XTtcblx0ICAgIGlmIChjb2Rlcykge1xuXHQgICAgICAgIHJldHVybiBjb2Rlcztcblx0ICAgIH1cblx0ICAgIHZhciBzaGlmdCA9IFRhYmxlX0JfMl9sdXRfcmVsW2NvZGVwb2ludF07XG5cdCAgICBpZiAoc2hpZnQpIHtcblx0ICAgICAgICByZXR1cm4gW2NvZGVwb2ludCArIHNoaWZ0WzBdXTtcblx0ICAgIH1cblx0ICAgIHZhciBjb21wbGV4ID0gVGFibGVfQl8yX2NvbXBsZXhbY29kZXBvaW50XTtcblx0ICAgIGlmIChjb21wbGV4KSB7XG5cdCAgICAgICAgcmV0dXJuIGNvbXBsZXg7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbnVsbDtcblx0fVxuXHRleHBvcnRzLl9uYW1lcHJlcFRhYmxlQjIgPSBfbmFtZXByZXBUYWJsZUIyO1xuXHRmdW5jdGlvbiBfbmFtZXByZXBUYWJsZUMoY29kZXBvaW50KSB7XG5cdCAgICByZXR1cm4gISFtYXRjaE1hcChjb2RlcG9pbnQsIFRhYmxlX0NfcmFuZ2VzKTtcblx0fVxuXHRleHBvcnRzLl9uYW1lcHJlcFRhYmxlQyA9IF9uYW1lcHJlcFRhYmxlQztcblx0ZnVuY3Rpb24gbmFtZXByZXAodmFsdWUpIHtcblx0ICAgIC8vIFRoaXMgYWxsb3dzIHBsYXRmb3JtcyB3aXRoIGluY29tcGxldGUgbm9ybWFsaXplIHRvIGJ5cGFzc1xuXHQgICAgLy8gaXQgZm9yIHZlcnkgYmFzaWMgbmFtZXMgd2hpY2ggdGhlIGJ1aWx0LWluIHRvTG93ZXJDYXNlXG5cdCAgICAvLyB3aWxsIGNlcnRhaW5seSBoYW5kbGUgY29ycmVjdGx5XG5cdCAgICBpZiAodmFsdWUubWF0Y2goL15bYS16MC05LV0qJC9pKSAmJiB2YWx1ZS5sZW5ndGggPD0gNTkpIHtcblx0ICAgICAgICByZXR1cm4gdmFsdWUudG9Mb3dlckNhc2UoKTtcblx0ICAgIH1cblx0ICAgIC8vIEdldCB0aGUgY29kZSBwb2ludHMgKGtlZXBpbmcgdGhlIGN1cnJlbnQgbm9ybWFsaXphdGlvbilcblx0ICAgIHZhciBjb2RlcyA9IHV0ZjgudG9VdGY4Q29kZVBvaW50cyh2YWx1ZSk7XG5cdCAgICBjb2RlcyA9IGZsYXR0ZW4oY29kZXMubWFwKGZ1bmN0aW9uIChjb2RlKSB7XG5cdCAgICAgICAgLy8gU3Vic3RpdHV0ZSBUYWJsZSBCLjEgKE1hcHMgdG8gTm90aGluZylcblx0ICAgICAgICBpZiAoVGFibGVfQl8xX2ZsYWdzLmluZGV4T2YoY29kZSkgPj0gMCkge1xuXHQgICAgICAgICAgICByZXR1cm4gW107XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChjb2RlID49IDB4ZmUwMCAmJiBjb2RlIDw9IDB4ZmUwZikge1xuXHQgICAgICAgICAgICByZXR1cm4gW107XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIFN1YnN0aXR1dGUgVGFibGUgQi4yIChDYXNlIEZvbGRpbmcpXG5cdCAgICAgICAgdmFyIGNvZGVzVGFibGVCMiA9IF9uYW1lcHJlcFRhYmxlQjIoY29kZSk7XG5cdCAgICAgICAgaWYgKGNvZGVzVGFibGVCMikge1xuXHQgICAgICAgICAgICByZXR1cm4gY29kZXNUYWJsZUIyO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBObyBTdWJzdGl0dXRpb25cblx0ICAgICAgICByZXR1cm4gW2NvZGVdO1xuXHQgICAgfSkpO1xuXHQgICAgLy8gTm9ybWFsaXplIHVzaW5nIGZvcm0gS0Ncblx0ICAgIGNvZGVzID0gdXRmOC50b1V0ZjhDb2RlUG9pbnRzKHV0ZjguX3RvVXRmOFN0cmluZyhjb2RlcyksIHV0ZjguVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtLk5GS0MpO1xuXHQgICAgLy8gUHJvaGliaXQgVGFibGVzIEMuMS4yLCBDLjIuMiwgQy4zLCBDLjQsIEMuNSwgQy42LCBDLjcsIEMuOCwgQy45XG5cdCAgICBjb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChjb2RlKSB7XG5cdCAgICAgICAgaWYgKF9uYW1lcHJlcFRhYmxlQyhjb2RlKSkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTVFJJTkdQUkVQX0NPTlRBSU5TX1BST0hJQklURURcIik7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvLyBQcm9oaWJpdCBVbmFzc2lnbmVkIENvZGUgUG9pbnRzIChUYWJsZSBBLjEpXG5cdCAgICBjb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChjb2RlKSB7XG5cdCAgICAgICAgaWYgKF9uYW1lcHJlcFRhYmxlQTEoY29kZSkpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU1RSSU5HUFJFUF9DT05UQUlOU19VTkFTU0lHTkVEXCIpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLy8gSUROQSBleHRyYXNcblx0ICAgIHZhciBuYW1lID0gdXRmOC5fdG9VdGY4U3RyaW5nKGNvZGVzKTtcblx0ICAgIC8vIElETkE6IDQuMi4zLjFcblx0ICAgIGlmIChuYW1lLnN1YnN0cmluZygwLCAxKSA9PT0gXCItXCIgfHwgbmFtZS5zdWJzdHJpbmcoMiwgNCkgPT09IFwiLS1cIiB8fCBuYW1lLnN1YnN0cmluZyhuYW1lLmxlbmd0aCAtIDEpID09PSBcIi1cIikge1xuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgaHlwaGVuXCIpO1xuXHQgICAgfVxuXHQgICAgLy8gSUROQTogNC4yLjRcblx0ICAgIGlmIChuYW1lLmxlbmd0aCA+IDYzKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidG9vIGxvbmdcIik7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbmFtZTtcblx0fVxuXHRleHBvcnRzLm5hbWVwcmVwID0gbmFtZXByZXA7XG5cblx0fSk7XG5cblx0dmFyIGlkbmEkMSA9IHVud3JhcEV4cG9ydHMoaWRuYSk7XG5cdHZhciBpZG5hXzEgPSBpZG5hLl9uYW1lcHJlcFRhYmxlQTE7XG5cdHZhciBpZG5hXzIgPSBpZG5hLl9uYW1lcHJlcFRhYmxlQjI7XG5cdHZhciBpZG5hXzMgPSBpZG5hLl9uYW1lcHJlcFRhYmxlQztcblx0dmFyIGlkbmFfNCA9IGlkbmEubmFtZXByZXA7XG5cblx0dmFyIGxpYiQ4ID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5cdGV4cG9ydHMuZm9ybWF0Qnl0ZXMzMlN0cmluZyA9IGJ5dGVzMzIuZm9ybWF0Qnl0ZXMzMlN0cmluZztcblx0ZXhwb3J0cy5wYXJzZUJ5dGVzMzJTdHJpbmcgPSBieXRlczMyLnBhcnNlQnl0ZXMzMlN0cmluZztcblxuXHRleHBvcnRzLm5hbWVwcmVwID0gaWRuYS5uYW1lcHJlcDtcblxuXHRleHBvcnRzLl90b0VzY2FwZWRVdGY4U3RyaW5nID0gdXRmOC5fdG9Fc2NhcGVkVXRmOFN0cmluZztcblx0ZXhwb3J0cy50b1V0ZjhCeXRlcyA9IHV0ZjgudG9VdGY4Qnl0ZXM7XG5cdGV4cG9ydHMudG9VdGY4Q29kZVBvaW50cyA9IHV0ZjgudG9VdGY4Q29kZVBvaW50cztcblx0ZXhwb3J0cy50b1V0ZjhTdHJpbmcgPSB1dGY4LnRvVXRmOFN0cmluZztcblx0ZXhwb3J0cy5Vbmljb2RlTm9ybWFsaXphdGlvbkZvcm0gPSB1dGY4LlVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybTtcblx0ZXhwb3J0cy5VdGY4RXJyb3JGdW5jcyA9IHV0ZjguVXRmOEVycm9yRnVuY3M7XG5cdGV4cG9ydHMuVXRmOEVycm9yUmVhc29uID0gdXRmOC5VdGY4RXJyb3JSZWFzb247XG5cblx0fSk7XG5cblx0dmFyIGluZGV4JDggPSB1bndyYXBFeHBvcnRzKGxpYiQ4KTtcblx0dmFyIGxpYl8xJDggPSBsaWIkOC5mb3JtYXRCeXRlczMyU3RyaW5nO1xuXHR2YXIgbGliXzIkNyA9IGxpYiQ4LnBhcnNlQnl0ZXMzMlN0cmluZztcblx0dmFyIGxpYl8zJDYgPSBsaWIkOC5uYW1lcHJlcDtcblx0dmFyIGxpYl80JDUgPSBsaWIkOC5fdG9Fc2NhcGVkVXRmOFN0cmluZztcblx0dmFyIGxpYl81JDUgPSBsaWIkOC50b1V0ZjhCeXRlcztcblx0dmFyIGxpYl82JDMgPSBsaWIkOC50b1V0ZjhDb2RlUG9pbnRzO1xuXHR2YXIgbGliXzckMyA9IGxpYiQ4LnRvVXRmOFN0cmluZztcblx0dmFyIGxpYl84JDIgPSBsaWIkOC5Vbmljb2RlTm9ybWFsaXphdGlvbkZvcm07XG5cdHZhciBsaWJfOSQyID0gbGliJDguVXRmOEVycm9yRnVuY3M7XG5cdHZhciBsaWJfMTAkMSA9IGxpYiQ4LlV0ZjhFcnJvclJlYXNvbjtcblxuXHR2YXIgc3RyaW5nID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0dmFyIF9fZXh0ZW5kcyA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuXHQgICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuXHQgICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG5cdCAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuXHQgICAgfTtcblx0fSkoKTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5cblx0dmFyIFN0cmluZ0NvZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHQgICAgX19leHRlbmRzKFN0cmluZ0NvZGVyLCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gU3RyaW5nQ29kZXIobG9jYWxOYW1lKSB7XG5cdCAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIFwic3RyaW5nXCIsIGxvY2FsTmFtZSkgfHwgdGhpcztcblx0ICAgIH1cblx0ICAgIFN0cmluZ0NvZGVyLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiAod3JpdGVyLCB2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmVuY29kZS5jYWxsKHRoaXMsIHdyaXRlciwgbGliJDgudG9VdGY4Qnl0ZXModmFsdWUpKTtcblx0ICAgIH07XG5cdCAgICBTdHJpbmdDb2Rlci5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gKHJlYWRlcikge1xuXHQgICAgICAgIHJldHVybiBsaWIkOC50b1V0ZjhTdHJpbmcoX3N1cGVyLnByb3RvdHlwZS5kZWNvZGUuY2FsbCh0aGlzLCByZWFkZXIpKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gU3RyaW5nQ29kZXI7XG5cdH0oYnl0ZXMuRHluYW1pY0J5dGVzQ29kZXIpKTtcblx0ZXhwb3J0cy5TdHJpbmdDb2RlciA9IFN0cmluZ0NvZGVyO1xuXG5cdH0pO1xuXG5cdHZhciBzdHJpbmckMSA9IHVud3JhcEV4cG9ydHMoc3RyaW5nKTtcblx0dmFyIHN0cmluZ18xID0gc3RyaW5nLlN0cmluZ0NvZGVyO1xuXG5cdHZhciB0dXBsZSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciBfX2V4dGVuZHMgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcblx0ICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuXHQgICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcblx0ICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuXHQgICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcblx0ICAgIH07XG5cdH0pKCk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXG5cdHZhciBUdXBsZUNvZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHQgICAgX19leHRlbmRzKFR1cGxlQ29kZXIsIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBUdXBsZUNvZGVyKGNvZGVycywgbG9jYWxOYW1lKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICB2YXIgZHluYW1pYyA9IGZhbHNlO1xuXHQgICAgICAgIHZhciB0eXBlcyA9IFtdO1xuXHQgICAgICAgIGNvZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChjb2Rlcikge1xuXHQgICAgICAgICAgICBpZiAoY29kZXIuZHluYW1pYykge1xuXHQgICAgICAgICAgICAgICAgZHluYW1pYyA9IHRydWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdHlwZXMucHVzaChjb2Rlci50eXBlKTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgICB2YXIgdHlwZSA9IChcInR1cGxlKFwiICsgdHlwZXMuam9pbihcIixcIikgKyBcIilcIik7XG5cdCAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBcInR1cGxlXCIsIHR5cGUsIGxvY2FsTmFtZSwgZHluYW1pYykgfHwgdGhpcztcblx0ICAgICAgICBfdGhpcy5jb2RlcnMgPSBjb2RlcnM7XG5cdCAgICAgICAgcmV0dXJuIF90aGlzO1xuXHQgICAgfVxuXHQgICAgVHVwbGVDb2Rlci5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gKHdyaXRlciwgdmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gYXJyYXkucGFjayh3cml0ZXIsIHRoaXMuY29kZXJzLCB2YWx1ZSk7XG5cdCAgICB9O1xuXHQgICAgVHVwbGVDb2Rlci5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gKHJlYWRlcikge1xuXHQgICAgICAgIHJldHVybiByZWFkZXIuY29lcmNlKHRoaXMubmFtZSwgYXJyYXkudW5wYWNrKHJlYWRlciwgdGhpcy5jb2RlcnMpKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVHVwbGVDb2Rlcjtcblx0fShhYnN0cmFjdENvZGVyLkNvZGVyKSk7XG5cdGV4cG9ydHMuVHVwbGVDb2RlciA9IFR1cGxlQ29kZXI7XG5cblx0fSk7XG5cblx0dmFyIHR1cGxlJDEgPSB1bndyYXBFeHBvcnRzKHR1cGxlKTtcblx0dmFyIHR1cGxlXzEgPSB0dXBsZS5UdXBsZUNvZGVyO1xuXG5cdHZhciBhYmlDb2RlciA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0Ly8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vd2lraS93aWtpL0V0aGVyZXVtLUNvbnRyYWN0LUFCSVxuXG5cblxuXG5cdHZhciBsb2dnZXIgPSBuZXcgbGliLkxvZ2dlcihfdmVyc2lvbiQ4LnZlcnNpb24pO1xuXG5cblxuXG5cblxuXG5cblxuXG5cblx0dmFyIHBhcmFtVHlwZUJ5dGVzID0gbmV3IFJlZ0V4cCgvXmJ5dGVzKFswLTldKikkLyk7XG5cdHZhciBwYXJhbVR5cGVOdW1iZXIgPSBuZXcgUmVnRXhwKC9eKHU/aW50KShbMC05XSopJC8pO1xuXHR2YXIgQWJpQ29kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBBYmlDb2Rlcihjb2VyY2VGdW5jKSB7XG5cdCAgICAgICAgdmFyIF9uZXdUYXJnZXQgPSB0aGlzLmNvbnN0cnVjdG9yO1xuXHQgICAgICAgIGxvZ2dlci5jaGVja05ldyhfbmV3VGFyZ2V0LCBBYmlDb2Rlcik7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJjb2VyY2VGdW5jXCIsIGNvZXJjZUZ1bmMgfHwgbnVsbCk7XG5cdCAgICB9XG5cdCAgICBBYmlDb2Rlci5wcm90b3R5cGUuX2dldENvZGVyID0gZnVuY3Rpb24gKHBhcmFtKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICBzd2l0Y2ggKHBhcmFtLmJhc2VUeXBlKSB7XG5cdCAgICAgICAgICAgIGNhc2UgXCJhZGRyZXNzXCI6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGFkZHJlc3MuQWRkcmVzc0NvZGVyKHBhcmFtLm5hbWUpO1xuXHQgICAgICAgICAgICBjYXNlIFwiYm9vbFwiOlxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBib29sZWFuXzEuQm9vbGVhbkNvZGVyKHBhcmFtLm5hbWUpO1xuXHQgICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHN0cmluZy5TdHJpbmdDb2RlcihwYXJhbS5uYW1lKTtcblx0ICAgICAgICAgICAgY2FzZSBcImJ5dGVzXCI6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGJ5dGVzLkJ5dGVzQ29kZXIocGFyYW0ubmFtZSk7XG5cdCAgICAgICAgICAgIGNhc2UgXCJhcnJheVwiOlxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBhcnJheS5BcnJheUNvZGVyKHRoaXMuX2dldENvZGVyKHBhcmFtLmFycmF5Q2hpbGRyZW4pLCBwYXJhbS5hcnJheUxlbmd0aCwgcGFyYW0ubmFtZSk7XG5cdCAgICAgICAgICAgIGNhc2UgXCJ0dXBsZVwiOlxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0dXBsZS5UdXBsZUNvZGVyKChwYXJhbS5jb21wb25lbnRzIHx8IFtdKS5tYXAoZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fZ2V0Q29kZXIoY29tcG9uZW50KTtcblx0ICAgICAgICAgICAgICAgIH0pLCBwYXJhbS5uYW1lKTtcblx0ICAgICAgICAgICAgY2FzZSBcIlwiOlxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBfbnVsbC5OdWxsQ29kZXIocGFyYW0ubmFtZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIHU/aW50WzAtOV0qXG5cdCAgICAgICAgdmFyIG1hdGNoID0gcGFyYW0udHlwZS5tYXRjaChwYXJhbVR5cGVOdW1iZXIpO1xuXHQgICAgICAgIGlmIChtYXRjaCkge1xuXHQgICAgICAgICAgICB2YXIgc2l6ZSA9IHBhcnNlSW50KG1hdGNoWzJdIHx8IFwiMjU2XCIpO1xuXHQgICAgICAgICAgICBpZiAoc2l6ZSA9PT0gMCB8fCBzaXplID4gMjU2IHx8IChzaXplICUgOCkgIT09IDApIHtcblx0ICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIFwiICsgbWF0Y2hbMV0gKyBcIiBiaXQgbGVuZ3RoXCIsIFwicGFyYW1cIiwgcGFyYW0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgbnVtYmVyLk51bWJlckNvZGVyKHNpemUgLyA4LCAobWF0Y2hbMV0gPT09IFwiaW50XCIpLCBwYXJhbS5uYW1lKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gYnl0ZXNbMC05XStcblx0ICAgICAgICBtYXRjaCA9IHBhcmFtLnR5cGUubWF0Y2gocGFyYW1UeXBlQnl0ZXMpO1xuXHQgICAgICAgIGlmIChtYXRjaCkge1xuXHQgICAgICAgICAgICB2YXIgc2l6ZSA9IHBhcnNlSW50KG1hdGNoWzFdKTtcblx0ICAgICAgICAgICAgaWYgKHNpemUgPT09IDAgfHwgc2l6ZSA+IDMyKSB7XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBieXRlcyBsZW5ndGhcIiwgXCJwYXJhbVwiLCBwYXJhbSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBmaXhlZEJ5dGVzLkZpeGVkQnl0ZXNDb2RlcihzaXplLCBwYXJhbS5uYW1lKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHR5cGVcIiwgXCJ0eXBlXCIsIHBhcmFtLnR5cGUpO1xuXHQgICAgfTtcblx0ICAgIEFiaUNvZGVyLnByb3RvdHlwZS5fZ2V0V29yZFNpemUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAzMjsgfTtcblx0ICAgIEFiaUNvZGVyLnByb3RvdHlwZS5fZ2V0UmVhZGVyID0gZnVuY3Rpb24gKGRhdGEpIHtcblx0ICAgICAgICByZXR1cm4gbmV3IGFic3RyYWN0Q29kZXIuUmVhZGVyKGRhdGEsIHRoaXMuX2dldFdvcmRTaXplKCksIHRoaXMuY29lcmNlRnVuYyk7XG5cdCAgICB9O1xuXHQgICAgQWJpQ29kZXIucHJvdG90eXBlLl9nZXRXcml0ZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBhYnN0cmFjdENvZGVyLldyaXRlcih0aGlzLl9nZXRXb3JkU2l6ZSgpKTtcblx0ICAgIH07XG5cdCAgICBBYmlDb2Rlci5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gKHR5cGVzLCB2YWx1ZXMpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIGlmICh0eXBlcy5sZW5ndGggIT09IHZhbHVlcy5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJ0eXBlcy92YWx1ZXMgbGVuZ3RoIG1pc21hdGNoXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLklOVkFMSURfQVJHVU1FTlQsIHtcblx0ICAgICAgICAgICAgICAgIGNvdW50OiB7IHR5cGVzOiB0eXBlcy5sZW5ndGgsIHZhbHVlczogdmFsdWVzLmxlbmd0aCB9LFxuXHQgICAgICAgICAgICAgICAgdmFsdWU6IHsgdHlwZXM6IHR5cGVzLCB2YWx1ZXM6IHZhbHVlcyB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgY29kZXJzID0gdHlwZXMubWFwKGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiBfdGhpcy5fZ2V0Q29kZXIoZnJhZ21lbnRzLlBhcmFtVHlwZS5mcm9tKHR5cGUpKTsgfSk7XG5cdCAgICAgICAgdmFyIGNvZGVyID0gKG5ldyB0dXBsZS5UdXBsZUNvZGVyKGNvZGVycywgXCJfXCIpKTtcblx0ICAgICAgICB2YXIgd3JpdGVyID0gdGhpcy5fZ2V0V3JpdGVyKCk7XG5cdCAgICAgICAgY29kZXIuZW5jb2RlKHdyaXRlciwgdmFsdWVzKTtcblx0ICAgICAgICByZXR1cm4gd3JpdGVyLmRhdGE7XG5cdCAgICB9O1xuXHQgICAgQWJpQ29kZXIucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uICh0eXBlcywgZGF0YSkge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgdmFyIGNvZGVycyA9IHR5cGVzLm1hcChmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gX3RoaXMuX2dldENvZGVyKGZyYWdtZW50cy5QYXJhbVR5cGUuZnJvbSh0eXBlKSk7IH0pO1xuXHQgICAgICAgIHZhciBjb2RlciA9IG5ldyB0dXBsZS5UdXBsZUNvZGVyKGNvZGVycywgXCJfXCIpO1xuXHQgICAgICAgIHJldHVybiBjb2Rlci5kZWNvZGUodGhpcy5fZ2V0UmVhZGVyKGxpYiQxLmFycmF5aWZ5KGRhdGEpKSk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIEFiaUNvZGVyO1xuXHR9KCkpO1xuXHRleHBvcnRzLkFiaUNvZGVyID0gQWJpQ29kZXI7XG5cdGV4cG9ydHMuZGVmYXVsdEFiaUNvZGVyID0gbmV3IEFiaUNvZGVyKCk7XG5cblx0fSk7XG5cblx0dmFyIGFiaUNvZGVyJDEgPSB1bndyYXBFeHBvcnRzKGFiaUNvZGVyKTtcblx0dmFyIGFiaUNvZGVyXzEgPSBhYmlDb2Rlci5BYmlDb2Rlcjtcblx0dmFyIGFiaUNvZGVyXzIgPSBhYmlDb2Rlci5kZWZhdWx0QWJpQ29kZXI7XG5cblx0dmFyIF92ZXJzaW9uJGcgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMudmVyc2lvbiA9IFwiaGFzaC81LjAuMlwiO1xuXG5cdH0pO1xuXG5cdHZhciBfdmVyc2lvbiRoID0gdW53cmFwRXhwb3J0cyhfdmVyc2lvbiRnKTtcblx0dmFyIF92ZXJzaW9uXzEkOCA9IF92ZXJzaW9uJGcudmVyc2lvbjtcblxuXHR2YXIgbGliJDkgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cblxuXG5cblxuXHR2YXIgbG9nZ2VyID0gbmV3IGxpYi5Mb2dnZXIoX3ZlcnNpb24kZy52ZXJzaW9uKTtcblx0Ly8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHR2YXIgWmVyb3MgPSBuZXcgVWludDhBcnJheShbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF0pO1xuXHR2YXIgUGFydGl0aW9uID0gbmV3IFJlZ0V4cChcIl4oKC4qKVxcXFwuKT8oW14uXSspJFwiKTtcblx0ZnVuY3Rpb24gaXNWYWxpZE5hbWUobmFtZSkge1xuXHQgICAgdHJ5IHtcblx0ICAgICAgICB2YXIgY29tcHMgPSBuYW1lLnNwbGl0KFwiLlwiKTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbXBzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIGlmIChsaWIkOC5uYW1lcHJlcChjb21wc1tpXSkubGVuZ3RoID09PSAwKSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJlbXB0eVwiKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblx0ICAgIGNhdGNoIChlcnJvcikgeyB9XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdH1cblx0ZXhwb3J0cy5pc1ZhbGlkTmFtZSA9IGlzVmFsaWROYW1lO1xuXHRmdW5jdGlvbiBuYW1laGFzaChuYW1lKSB7XG5cdCAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0ICAgIGlmICh0eXBlb2YgKG5hbWUpICE9PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYWRkcmVzcyAtIFwiICsgU3RyaW5nKG5hbWUpLCBcIm5hbWVcIiwgbmFtZSk7XG5cdCAgICB9XG5cdCAgICB2YXIgcmVzdWx0ID0gWmVyb3M7XG5cdCAgICB3aGlsZSAobmFtZS5sZW5ndGgpIHtcblx0ICAgICAgICB2YXIgcGFydGl0aW9uID0gbmFtZS5tYXRjaChQYXJ0aXRpb24pO1xuXHQgICAgICAgIHZhciBsYWJlbCA9IGxpYiQ4LnRvVXRmOEJ5dGVzKGxpYiQ4Lm5hbWVwcmVwKHBhcnRpdGlvblszXSkpO1xuXHQgICAgICAgIHJlc3VsdCA9IGxpYiQ0LmtlY2NhazI1NihsaWIkMS5jb25jYXQoW3Jlc3VsdCwgbGliJDQua2VjY2FrMjU2KGxhYmVsKV0pKTtcblx0ICAgICAgICBuYW1lID0gcGFydGl0aW9uWzJdIHx8IFwiXCI7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbGliJDEuaGV4bGlmeShyZXN1bHQpO1xuXHR9XG5cdGV4cG9ydHMubmFtZWhhc2ggPSBuYW1laGFzaDtcblx0ZnVuY3Rpb24gaWQodGV4dCkge1xuXHQgICAgcmV0dXJuIGxpYiQ0LmtlY2NhazI1NihsaWIkOC50b1V0ZjhCeXRlcyh0ZXh0KSk7XG5cdH1cblx0ZXhwb3J0cy5pZCA9IGlkO1xuXHRleHBvcnRzLm1lc3NhZ2VQcmVmaXggPSBcIlxceDE5RXRoZXJldW0gU2lnbmVkIE1lc3NhZ2U6XFxuXCI7XG5cdGZ1bmN0aW9uIGhhc2hNZXNzYWdlKG1lc3NhZ2UpIHtcblx0ICAgIGlmICh0eXBlb2YgKG1lc3NhZ2UpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgbWVzc2FnZSA9IGxpYiQ4LnRvVXRmOEJ5dGVzKG1lc3NhZ2UpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGxpYiQ0LmtlY2NhazI1NihsaWIkMS5jb25jYXQoW1xuXHQgICAgICAgIGxpYiQ4LnRvVXRmOEJ5dGVzKGV4cG9ydHMubWVzc2FnZVByZWZpeCksXG5cdCAgICAgICAgbGliJDgudG9VdGY4Qnl0ZXMoU3RyaW5nKG1lc3NhZ2UubGVuZ3RoKSksXG5cdCAgICAgICAgbWVzc2FnZVxuXHQgICAgXSkpO1xuXHR9XG5cdGV4cG9ydHMuaGFzaE1lc3NhZ2UgPSBoYXNoTWVzc2FnZTtcblxuXHR9KTtcblxuXHR2YXIgaW5kZXgkOSA9IHVud3JhcEV4cG9ydHMobGliJDkpO1xuXHR2YXIgbGliXzEkOSA9IGxpYiQ5LmlzVmFsaWROYW1lO1xuXHR2YXIgbGliXzIkOCA9IGxpYiQ5Lm5hbWVoYXNoO1xuXHR2YXIgbGliXzMkNyA9IGxpYiQ5LmlkO1xuXHR2YXIgbGliXzQkNiA9IGxpYiQ5Lm1lc3NhZ2VQcmVmaXg7XG5cdHZhciBsaWJfNSQ2ID0gbGliJDkuaGFzaE1lc3NhZ2U7XG5cblx0dmFyIF9pbnRlcmZhY2UgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19leHRlbmRzID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG5cdCAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcblx0ICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG5cdCAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cblx0ICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG5cdCAgICB9O1xuXHR9KSgpO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cblxuXG5cblxuXG5cblxuXHRleHBvcnRzLmNoZWNrUmVzdWx0RXJyb3JzID0gYWJzdHJhY3RDb2Rlci5jaGVja1Jlc3VsdEVycm9ycztcblxuXG5cblx0dmFyIGxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJDgudmVyc2lvbik7XG5cdHZhciBMb2dEZXNjcmlwdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0ICAgIF9fZXh0ZW5kcyhMb2dEZXNjcmlwdGlvbiwgX3N1cGVyKTtcblx0ICAgIGZ1bmN0aW9uIExvZ0Rlc2NyaXB0aW9uKCkge1xuXHQgICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblx0ICAgIH1cblx0ICAgIHJldHVybiBMb2dEZXNjcmlwdGlvbjtcblx0fShsaWIkMy5EZXNjcmlwdGlvbikpO1xuXHRleHBvcnRzLkxvZ0Rlc2NyaXB0aW9uID0gTG9nRGVzY3JpcHRpb247XG5cdHZhciBUcmFuc2FjdGlvbkRlc2NyaXB0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHQgICAgX19leHRlbmRzKFRyYW5zYWN0aW9uRGVzY3JpcHRpb24sIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBUcmFuc2FjdGlvbkRlc2NyaXB0aW9uKCkge1xuXHQgICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblx0ICAgIH1cblx0ICAgIHJldHVybiBUcmFuc2FjdGlvbkRlc2NyaXB0aW9uO1xuXHR9KGxpYiQzLkRlc2NyaXB0aW9uKSk7XG5cdGV4cG9ydHMuVHJhbnNhY3Rpb25EZXNjcmlwdGlvbiA9IFRyYW5zYWN0aW9uRGVzY3JpcHRpb247XG5cdHZhciBJbmRleGVkID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHQgICAgX19leHRlbmRzKEluZGV4ZWQsIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBJbmRleGVkKCkge1xuXHQgICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblx0ICAgIH1cblx0ICAgIEluZGV4ZWQuaXNJbmRleGVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9pc0luZGV4ZWQpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBJbmRleGVkO1xuXHR9KGxpYiQzLkRlc2NyaXB0aW9uKSk7XG5cdGV4cG9ydHMuSW5kZXhlZCA9IEluZGV4ZWQ7XG5cdGZ1bmN0aW9uIHdyYXBBY2Nlc3NFcnJvcihwcm9wZXJ0eSwgZXJyb3IpIHtcblx0ICAgIHZhciB3cmFwID0gbmV3IEVycm9yKFwiZGVmZXJyZWQgZXJyb3IgZHVyaW5nIEFCSSBkZWNvZGluZyB0cmlnZ2VyZWQgYWNjZXNzaW5nIFwiICsgcHJvcGVydHkpO1xuXHQgICAgd3JhcC5lcnJvciA9IGVycm9yO1xuXHQgICAgcmV0dXJuIHdyYXA7XG5cdH1cblx0Lypcblx0ZnVuY3Rpb24gY2hlY2tOYW1lcyhmcmFnbWVudDogRnJhZ21lbnQsIHR5cGU6IFwiaW5wdXRcIiB8IFwib3V0cHV0XCIsIHBhcmFtczogQXJyYXk8UGFyYW1UeXBlPik6IHZvaWQge1xuXHQgICAgcGFyYW1zLnJlZHVjZSgoYWNjdW0sIHBhcmFtKSA9PiB7XG5cdCAgICAgICAgaWYgKHBhcmFtLm5hbWUpIHtcblx0ICAgICAgICAgICAgaWYgKGFjY3VtW3BhcmFtLm5hbWVdKSB7XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKGBkdXBsaWNhdGUgJHsgdHlwZSB9IHBhcmFtZXRlciAkeyBKU09OLnN0cmluZ2lmeShwYXJhbS5uYW1lKSB9IGluICR7IGZyYWdtZW50LmZvcm1hdChcImZ1bGxcIikgfWAsIFwiZnJhZ21lbnRcIiwgZnJhZ21lbnQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGFjY3VtW3BhcmFtLm5hbWVdID0gdHJ1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGFjY3VtO1xuXHQgICAgfSwgPHsgWyBuYW1lOiBzdHJpbmcgXTogYm9vbGVhbiB9PnsgfSk7XG5cdH1cblx0Ki9cblx0dmFyIEludGVyZmFjZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIEludGVyZmFjZShmcmFnbWVudHMkMSkge1xuXHQgICAgICAgIHZhciBfbmV3VGFyZ2V0ID0gdGhpcy5jb25zdHJ1Y3Rvcjtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIGxvZ2dlci5jaGVja05ldyhfbmV3VGFyZ2V0LCBJbnRlcmZhY2UpO1xuXHQgICAgICAgIHZhciBhYmkgPSBbXTtcblx0ICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudHMkMSkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgYWJpID0gSlNPTi5wYXJzZShmcmFnbWVudHMkMSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICBhYmkgPSBmcmFnbWVudHMkMTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJmcmFnbWVudHNcIiwgYWJpLm1hcChmdW5jdGlvbiAoZnJhZ21lbnQpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50cy5GcmFnbWVudC5mcm9tKGZyYWdtZW50KTtcblx0ICAgICAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKGZyYWdtZW50KSB7IHJldHVybiAoZnJhZ21lbnQgIT0gbnVsbCk7IH0pKTtcblx0ICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcIl9hYmlDb2RlclwiLCBsaWIkMy5nZXRTdGF0aWMoKF9uZXdUYXJnZXQpLCBcImdldEFiaUNvZGVyXCIpKCkpO1xuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KHRoaXMsIFwiZnVuY3Rpb25zXCIsIHt9KTtcblx0ICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcImVycm9yc1wiLCB7fSk7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJldmVudHNcIiwge30pO1xuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KHRoaXMsIFwic3RydWN0c1wiLCB7fSk7XG5cdCAgICAgICAgLy8gQWRkIGFsbCBmcmFnbWVudHMgYnkgdGhlaXIgc2lnbmF0dXJlXG5cdCAgICAgICAgdGhpcy5mcmFnbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZnJhZ21lbnQpIHtcblx0ICAgICAgICAgICAgdmFyIGJ1Y2tldCA9IG51bGw7XG5cdCAgICAgICAgICAgIHN3aXRjaCAoZnJhZ21lbnQudHlwZSkge1xuXHQgICAgICAgICAgICAgICAgY2FzZSBcImNvbnN0cnVjdG9yXCI6XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmRlcGxveSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2FybihcImR1cGxpY2F0ZSBkZWZpbml0aW9uIC0gY29uc3RydWN0b3JcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgLy9jaGVja05hbWVzKGZyYWdtZW50LCBcImlucHV0XCIsIGZyYWdtZW50LmlucHV0cyk7XG5cdCAgICAgICAgICAgICAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkoX3RoaXMsIFwiZGVwbG95XCIsIGZyYWdtZW50KTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcblx0ICAgICAgICAgICAgICAgICAgICAvL2NoZWNrTmFtZXMoZnJhZ21lbnQsIFwiaW5wdXRcIiwgZnJhZ21lbnQuaW5wdXRzKTtcblx0ICAgICAgICAgICAgICAgICAgICAvL2NoZWNrTmFtZXMoZnJhZ21lbnQsIFwib3V0cHV0XCIsICg8RnVuY3Rpb25GcmFnbWVudD5mcmFnbWVudCkub3V0cHV0cyk7XG5cdCAgICAgICAgICAgICAgICAgICAgYnVja2V0ID0gX3RoaXMuZnVuY3Rpb25zO1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgY2FzZSBcImV2ZW50XCI6XG5cdCAgICAgICAgICAgICAgICAgICAgLy9jaGVja05hbWVzKGZyYWdtZW50LCBcImlucHV0XCIsIGZyYWdtZW50LmlucHV0cyk7XG5cdCAgICAgICAgICAgICAgICAgICAgYnVja2V0ID0gX3RoaXMuZXZlbnRzO1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIHNpZ25hdHVyZSA9IGZyYWdtZW50LmZvcm1hdCgpO1xuXHQgICAgICAgICAgICBpZiAoYnVja2V0W3NpZ25hdHVyZV0pIHtcblx0ICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKFwiZHVwbGljYXRlIGRlZmluaXRpb24gLSBcIiArIHNpZ25hdHVyZSk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgYnVja2V0W3NpZ25hdHVyZV0gPSBmcmFnbWVudDtcblx0ICAgICAgICB9KTtcblx0ICAgICAgICAvLyBJZiB3ZSBkbyBub3QgaGF2ZSBhIGNvbnN0cnVjdG9yIGFkZCBhIGRlZmF1bHRcblx0ICAgICAgICBpZiAoIXRoaXMuZGVwbG95KSB7XG5cdCAgICAgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KHRoaXMsIFwiZGVwbG95XCIsIGZyYWdtZW50cy5Db25zdHJ1Y3RvckZyYWdtZW50LmZyb20oe1xuXHQgICAgICAgICAgICAgICAgcGF5YWJsZTogZmFsc2UsXG5cdCAgICAgICAgICAgICAgICB0eXBlOiBcImNvbnN0cnVjdG9yXCJcblx0ICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcIl9pc0ludGVyZmFjZVwiLCB0cnVlKTtcblx0ICAgIH1cblx0ICAgIEludGVyZmFjZS5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuXHQgICAgICAgIGlmICghZm9ybWF0KSB7XG5cdCAgICAgICAgICAgIGZvcm1hdCA9IGZyYWdtZW50cy5Gb3JtYXRUeXBlcy5mdWxsO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoZm9ybWF0ID09PSBmcmFnbWVudHMuRm9ybWF0VHlwZXMuc2lnaGFzaCkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW50ZXJmYWNlIGRvZXMgbm90IHN1cHBvcnQgZm9ybWF0dGluZyBzaWdoYXNoXCIsIFwiZm9ybWF0XCIsIGZvcm1hdCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBhYmkgPSB0aGlzLmZyYWdtZW50cy5tYXAoZnVuY3Rpb24gKGZyYWdtZW50KSB7IHJldHVybiBmcmFnbWVudC5mb3JtYXQoZm9ybWF0KTsgfSk7XG5cdCAgICAgICAgLy8gV2UgbmVlZCB0byByZS1idW5kbGUgdGhlIEpTT04gZnJhZ21lbnRzIGEgYml0XG5cdCAgICAgICAgaWYgKGZvcm1hdCA9PT0gZnJhZ21lbnRzLkZvcm1hdFR5cGVzLmpzb24pIHtcblx0ICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFiaS5tYXAoZnVuY3Rpb24gKGopIHsgcmV0dXJuIEpTT04ucGFyc2Uoaik7IH0pKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGFiaTtcblx0ICAgIH07XG5cdCAgICAvLyBTdWItY2xhc3NlcyBjYW4gb3ZlcnJpZGUgdGhlc2UgdG8gaGFuZGxlIG90aGVyIGJsb2NrY2hhaW5zXG5cdCAgICBJbnRlcmZhY2UuZ2V0QWJpQ29kZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIGFiaUNvZGVyLmRlZmF1bHRBYmlDb2Rlcjtcblx0ICAgIH07XG5cdCAgICBJbnRlcmZhY2UuZ2V0QWRkcmVzcyA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG5cdCAgICAgICAgcmV0dXJuIGxpYiQ2LmdldEFkZHJlc3MoYWRkcmVzcyk7XG5cdCAgICB9O1xuXHQgICAgSW50ZXJmYWNlLmdldFNpZ2hhc2ggPSBmdW5jdGlvbiAoZnVuY3Rpb25GcmFnbWVudCkge1xuXHQgICAgICAgIHJldHVybiBsaWIkMS5oZXhEYXRhU2xpY2UobGliJDkuaWQoZnVuY3Rpb25GcmFnbWVudC5mb3JtYXQoKSksIDAsIDQpO1xuXHQgICAgfTtcblx0ICAgIEludGVyZmFjZS5nZXRFdmVudFRvcGljID0gZnVuY3Rpb24gKGV2ZW50RnJhZ21lbnQpIHtcblx0ICAgICAgICByZXR1cm4gbGliJDkuaWQoZXZlbnRGcmFnbWVudC5mb3JtYXQoKSk7XG5cdCAgICB9O1xuXHQgICAgLy8gRmluZCBhIGZ1bmN0aW9uIGRlZmluaXRpb24gYnkgYW55IG1lYW5zIG5lY2Vzc2FyeSAodW5sZXNzIGl0IGlzIGFtYmlndW91cylcblx0ICAgIEludGVyZmFjZS5wcm90b3R5cGUuZ2V0RnVuY3Rpb24gPSBmdW5jdGlvbiAobmFtZU9yU2lnbmF0dXJlT3JTaWdoYXNoKSB7XG5cdCAgICAgICAgaWYgKGxpYiQxLmlzSGV4U3RyaW5nKG5hbWVPclNpZ25hdHVyZU9yU2lnaGFzaCkpIHtcblx0ICAgICAgICAgICAgZm9yICh2YXIgbmFtZV8xIGluIHRoaXMuZnVuY3Rpb25zKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAobmFtZU9yU2lnbmF0dXJlT3JTaWdoYXNoID09PSB0aGlzLmdldFNpZ2hhc2gobmFtZV8xKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZ1bmN0aW9uc1tuYW1lXzFdO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJubyBtYXRjaGluZyBmdW5jdGlvblwiLCBcInNpZ2hhc2hcIiwgbmFtZU9yU2lnbmF0dXJlT3JTaWdoYXNoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gSXQgaXMgYSBiYXJlIG5hbWUsIGxvb2sgdXAgdGhlIGZ1bmN0aW9uICh3aWxsIHJldHVybiBudWxsIGlmIGFtYmlndW91cylcblx0ICAgICAgICBpZiAobmFtZU9yU2lnbmF0dXJlT3JTaWdoYXNoLmluZGV4T2YoXCIoXCIpID09PSAtMSkge1xuXHQgICAgICAgICAgICB2YXIgbmFtZV8yID0gbmFtZU9yU2lnbmF0dXJlT3JTaWdoYXNoLnRyaW0oKTtcblx0ICAgICAgICAgICAgdmFyIG1hdGNoaW5nID0gT2JqZWN0LmtleXModGhpcy5mdW5jdGlvbnMpLmZpbHRlcihmdW5jdGlvbiAoZikgeyByZXR1cm4gKGYuc3BsaXQoXCIoXCIgLyogZml4OikgKi8pWzBdID09PSBuYW1lXzIpOyB9KTtcblx0ICAgICAgICAgICAgaWYgKG1hdGNoaW5nLmxlbmd0aCA9PT0gMCkge1xuXHQgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm5vIG1hdGNoaW5nIGZ1bmN0aW9uXCIsIFwibmFtZVwiLCBuYW1lXzIpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2UgaWYgKG1hdGNoaW5nLmxlbmd0aCA+IDEpIHtcblx0ICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJtdWx0aXBsZSBtYXRjaGluZyBmdW5jdGlvbnNcIiwgXCJuYW1lXCIsIG5hbWVfMik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnVuY3Rpb25zW21hdGNoaW5nWzBdXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gTm9ybWxpemUgdGhlIHNpZ25hdHVyZSBhbmQgbG9va3VwIHRoZSBmdW5jdGlvblxuXHQgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmZ1bmN0aW9uc1tmcmFnbWVudHMuRnVuY3Rpb25GcmFnbWVudC5mcm9tU3RyaW5nKG5hbWVPclNpZ25hdHVyZU9yU2lnaGFzaCkuZm9ybWF0KCldO1xuXHQgICAgICAgIGlmICghcmVzdWx0KSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJubyBtYXRjaGluZyBmdW5jdGlvblwiLCBcInNpZ25hdHVyZVwiLCBuYW1lT3JTaWduYXR1cmVPclNpZ2hhc2gpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfTtcblx0ICAgIC8vIEZpbmQgYW4gZXZlbnQgZGVmaW5pdGlvbiBieSBhbnkgbWVhbnMgbmVjZXNzYXJ5ICh1bmxlc3MgaXQgaXMgYW1iaWd1b3VzKVxuXHQgICAgSW50ZXJmYWNlLnByb3RvdHlwZS5nZXRFdmVudCA9IGZ1bmN0aW9uIChuYW1lT3JTaWduYXR1cmVPclRvcGljKSB7XG5cdCAgICAgICAgaWYgKGxpYiQxLmlzSGV4U3RyaW5nKG5hbWVPclNpZ25hdHVyZU9yVG9waWMpKSB7XG5cdCAgICAgICAgICAgIHZhciB0b3BpY2hhc2ggPSBuYW1lT3JTaWduYXR1cmVPclRvcGljLnRvTG93ZXJDYXNlKCk7XG5cdCAgICAgICAgICAgIGZvciAodmFyIG5hbWVfMyBpbiB0aGlzLmV2ZW50cykge1xuXHQgICAgICAgICAgICAgICAgaWYgKHRvcGljaGFzaCA9PT0gdGhpcy5nZXRFdmVudFRvcGljKG5hbWVfMykpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ldmVudHNbbmFtZV8zXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwibm8gbWF0Y2hpbmcgZXZlbnRcIiwgXCJ0b3BpY2hhc2hcIiwgdG9waWNoYXNoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gSXQgaXMgYSBiYXJlIG5hbWUsIGxvb2sgdXAgdGhlIGZ1bmN0aW9uICh3aWxsIHJldHVybiBudWxsIGlmIGFtYmlndW91cylcblx0ICAgICAgICBpZiAobmFtZU9yU2lnbmF0dXJlT3JUb3BpYy5pbmRleE9mKFwiKFwiKSA9PT0gLTEpIHtcblx0ICAgICAgICAgICAgdmFyIG5hbWVfNCA9IG5hbWVPclNpZ25hdHVyZU9yVG9waWMudHJpbSgpO1xuXHQgICAgICAgICAgICB2YXIgbWF0Y2hpbmcgPSBPYmplY3Qua2V5cyh0aGlzLmV2ZW50cykuZmlsdGVyKGZ1bmN0aW9uIChmKSB7IHJldHVybiAoZi5zcGxpdChcIihcIiAvKiBmaXg6KSAqLylbMF0gPT09IG5hbWVfNCk7IH0pO1xuXHQgICAgICAgICAgICBpZiAobWF0Y2hpbmcubGVuZ3RoID09PSAwKSB7XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwibm8gbWF0Y2hpbmcgZXZlbnRcIiwgXCJuYW1lXCIsIG5hbWVfNCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSBpZiAobWF0Y2hpbmcubGVuZ3RoID4gMSkge1xuXHQgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm11bHRpcGxlIG1hdGNoaW5nIGV2ZW50c1wiLCBcIm5hbWVcIiwgbmFtZV80KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5ldmVudHNbbWF0Y2hpbmdbMF1dO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBOb3JtbGl6ZSB0aGUgc2lnbmF0dXJlIGFuZCBsb29rdXAgdGhlIGZ1bmN0aW9uXG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuZXZlbnRzW2ZyYWdtZW50cy5FdmVudEZyYWdtZW50LmZyb21TdHJpbmcobmFtZU9yU2lnbmF0dXJlT3JUb3BpYykuZm9ybWF0KCldO1xuXHQgICAgICAgIGlmICghcmVzdWx0KSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJubyBtYXRjaGluZyBldmVudFwiLCBcInNpZ25hdHVyZVwiLCBuYW1lT3JTaWduYXR1cmVPclRvcGljKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgIH07XG5cdCAgICAvLyBHZXQgdGhlIHNpZ2hhc2ggKHRoZSBieXRlczQgc2VsZWN0b3IpIHVzZWQgYnkgU29saWRpdHkgdG8gaWRlbnRpZnkgYSBmdW5jdGlvblxuXHQgICAgSW50ZXJmYWNlLnByb3RvdHlwZS5nZXRTaWdoYXNoID0gZnVuY3Rpb24gKGZ1bmN0aW9uRnJhZ21lbnQpIHtcblx0ICAgICAgICBpZiAodHlwZW9mIChmdW5jdGlvbkZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgICAgICBmdW5jdGlvbkZyYWdtZW50ID0gdGhpcy5nZXRGdW5jdGlvbihmdW5jdGlvbkZyYWdtZW50KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGxpYiQzLmdldFN0YXRpYyh0aGlzLmNvbnN0cnVjdG9yLCBcImdldFNpZ2hhc2hcIikoZnVuY3Rpb25GcmFnbWVudCk7XG5cdCAgICB9O1xuXHQgICAgLy8gR2V0IHRoZSB0b3BpYyAodGhlIGJ5dGVzMzIgaGFzaCkgdXNlZCBieSBTb2xpZGl0eSB0byBpZGVudGlmeSBhbiBldmVudFxuXHQgICAgSW50ZXJmYWNlLnByb3RvdHlwZS5nZXRFdmVudFRvcGljID0gZnVuY3Rpb24gKGV2ZW50RnJhZ21lbnQpIHtcblx0ICAgICAgICBpZiAodHlwZW9mIChldmVudEZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgICAgICBldmVudEZyYWdtZW50ID0gdGhpcy5nZXRFdmVudChldmVudEZyYWdtZW50KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGxpYiQzLmdldFN0YXRpYyh0aGlzLmNvbnN0cnVjdG9yLCBcImdldEV2ZW50VG9waWNcIikoZXZlbnRGcmFnbWVudCk7XG5cdCAgICB9O1xuXHQgICAgSW50ZXJmYWNlLnByb3RvdHlwZS5fZGVjb2RlUGFyYW1zID0gZnVuY3Rpb24gKHBhcmFtcywgZGF0YSkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9hYmlDb2Rlci5kZWNvZGUocGFyYW1zLCBkYXRhKTtcblx0ICAgIH07XG5cdCAgICBJbnRlcmZhY2UucHJvdG90eXBlLl9lbmNvZGVQYXJhbXMgPSBmdW5jdGlvbiAocGFyYW1zLCB2YWx1ZXMpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fYWJpQ29kZXIuZW5jb2RlKHBhcmFtcywgdmFsdWVzKTtcblx0ICAgIH07XG5cdCAgICBJbnRlcmZhY2UucHJvdG90eXBlLmVuY29kZURlcGxveSA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fZW5jb2RlUGFyYW1zKHRoaXMuZGVwbG95LmlucHV0cywgdmFsdWVzIHx8IFtdKTtcblx0ICAgIH07XG5cdCAgICAvLyBEZWNvZGUgdGhlIGRhdGEgZm9yIGEgZnVuY3Rpb24gY2FsbCAoZS5nLiB0eC5kYXRhKVxuXHQgICAgSW50ZXJmYWNlLnByb3RvdHlwZS5kZWNvZGVGdW5jdGlvbkRhdGEgPSBmdW5jdGlvbiAoZnVuY3Rpb25GcmFnbWVudCwgZGF0YSkge1xuXHQgICAgICAgIGlmICh0eXBlb2YgKGZ1bmN0aW9uRnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uRnJhZ21lbnQgPSB0aGlzLmdldEZ1bmN0aW9uKGZ1bmN0aW9uRnJhZ21lbnQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgYnl0ZXMgPSBsaWIkMS5hcnJheWlmeShkYXRhKTtcblx0ICAgICAgICBpZiAobGliJDEuaGV4bGlmeShieXRlcy5zbGljZSgwLCA0KSkgIT09IHRoaXMuZ2V0U2lnaGFzaChmdW5jdGlvbkZyYWdtZW50KSkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiZGF0YSBzaWduYXR1cmUgZG9lcyBub3QgbWF0Y2ggZnVuY3Rpb24gXCIgKyBmdW5jdGlvbkZyYWdtZW50Lm5hbWUgKyBcIi5cIiwgXCJkYXRhXCIsIGxpYiQxLmhleGxpZnkoYnl0ZXMpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX2RlY29kZVBhcmFtcyhmdW5jdGlvbkZyYWdtZW50LmlucHV0cywgYnl0ZXMuc2xpY2UoNCkpO1xuXHQgICAgfTtcblx0ICAgIC8vIEVuY29kZSB0aGUgZGF0YSBmb3IgYSBmdW5jdGlvbiBjYWxsIChlLmcuIHR4LmRhdGEpXG5cdCAgICBJbnRlcmZhY2UucHJvdG90eXBlLmVuY29kZUZ1bmN0aW9uRGF0YSA9IGZ1bmN0aW9uIChmdW5jdGlvbkZyYWdtZW50LCB2YWx1ZXMpIHtcblx0ICAgICAgICBpZiAodHlwZW9mIChmdW5jdGlvbkZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgICAgICBmdW5jdGlvbkZyYWdtZW50ID0gdGhpcy5nZXRGdW5jdGlvbihmdW5jdGlvbkZyYWdtZW50KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGxpYiQxLmhleGxpZnkobGliJDEuY29uY2F0KFtcblx0ICAgICAgICAgICAgdGhpcy5nZXRTaWdoYXNoKGZ1bmN0aW9uRnJhZ21lbnQpLFxuXHQgICAgICAgICAgICB0aGlzLl9lbmNvZGVQYXJhbXMoZnVuY3Rpb25GcmFnbWVudC5pbnB1dHMsIHZhbHVlcyB8fCBbXSlcblx0ICAgICAgICBdKSk7XG5cdCAgICB9O1xuXHQgICAgLy8gRGVjb2RlIHRoZSByZXN1bHQgZnJvbSBhIGZ1bmN0aW9uIGNhbGwgKGUuZy4gZnJvbSBldGhfY2FsbClcblx0ICAgIEludGVyZmFjZS5wcm90b3R5cGUuZGVjb2RlRnVuY3Rpb25SZXN1bHQgPSBmdW5jdGlvbiAoZnVuY3Rpb25GcmFnbWVudCwgZGF0YSkge1xuXHQgICAgICAgIGlmICh0eXBlb2YgKGZ1bmN0aW9uRnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uRnJhZ21lbnQgPSB0aGlzLmdldEZ1bmN0aW9uKGZ1bmN0aW9uRnJhZ21lbnQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgYnl0ZXMgPSBsaWIkMS5hcnJheWlmeShkYXRhKTtcblx0ICAgICAgICB2YXIgcmVhc29uID0gbnVsbDtcblx0ICAgICAgICB2YXIgZXJyb3JTaWduYXR1cmUgPSBudWxsO1xuXHQgICAgICAgIHN3aXRjaCAoYnl0ZXMubGVuZ3RoICUgdGhpcy5fYWJpQ29kZXIuX2dldFdvcmRTaXplKCkpIHtcblx0ICAgICAgICAgICAgY2FzZSAwOlxuXHQgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYWJpQ29kZXIuZGVjb2RlKGZ1bmN0aW9uRnJhZ21lbnQub3V0cHV0cywgYnl0ZXMpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlIDQ6XG5cdCAgICAgICAgICAgICAgICBpZiAobGliJDEuaGV4bGlmeShieXRlcy5zbGljZSgwLCA0KSkgPT09IFwiMHgwOGMzNzlhMFwiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZXJyb3JTaWduYXR1cmUgPSBcIkVycm9yKHN0cmluZylcIjtcblx0ICAgICAgICAgICAgICAgICAgICByZWFzb24gPSB0aGlzLl9hYmlDb2Rlci5kZWNvZGUoW1wic3RyaW5nXCJdLCBieXRlcy5zbGljZSg0KSlbMF07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwiY2FsbCByZXZlcnQgZXhjZXB0aW9uXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLkNBTExfRVhDRVBUSU9OLCB7XG5cdCAgICAgICAgICAgIG1ldGhvZDogZnVuY3Rpb25GcmFnbWVudC5mb3JtYXQoKSxcblx0ICAgICAgICAgICAgZXJyb3JTaWduYXR1cmU6IGVycm9yU2lnbmF0dXJlLFxuXHQgICAgICAgICAgICBlcnJvckFyZ3M6IFtyZWFzb25dLFxuXHQgICAgICAgICAgICByZWFzb246IHJlYXNvblxuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIC8vIEVuY29kZSB0aGUgcmVzdWx0IGZvciBhIGZ1bmN0aW9uIGNhbGwgKGUuZy4gZm9yIGV0aF9jYWxsKVxuXHQgICAgSW50ZXJmYWNlLnByb3RvdHlwZS5lbmNvZGVGdW5jdGlvblJlc3VsdCA9IGZ1bmN0aW9uIChmdW5jdGlvbkZyYWdtZW50LCB2YWx1ZXMpIHtcblx0ICAgICAgICBpZiAodHlwZW9mIChmdW5jdGlvbkZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgICAgICBmdW5jdGlvbkZyYWdtZW50ID0gdGhpcy5nZXRGdW5jdGlvbihmdW5jdGlvbkZyYWdtZW50KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGxpYiQxLmhleGxpZnkodGhpcy5fYWJpQ29kZXIuZW5jb2RlKGZ1bmN0aW9uRnJhZ21lbnQub3V0cHV0cywgdmFsdWVzIHx8IFtdKSk7XG5cdCAgICB9O1xuXHQgICAgLy8gQ3JlYXRlIHRoZSBmaWx0ZXIgZm9yIHRoZSBldmVudCB3aXRoIHNlYXJjaCBjcml0ZXJpYSAoZS5nLiBmb3IgZXRoX2ZpbHRlckxvZylcblx0ICAgIEludGVyZmFjZS5wcm90b3R5cGUuZW5jb2RlRmlsdGVyVG9waWNzID0gZnVuY3Rpb24gKGV2ZW50RnJhZ21lbnQsIHZhbHVlcykge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgaWYgKHR5cGVvZiAoZXZlbnRGcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgZXZlbnRGcmFnbWVudCA9IHRoaXMuZ2V0RXZlbnQoZXZlbnRGcmFnbWVudCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICh2YWx1ZXMubGVuZ3RoID4gZXZlbnRGcmFnbWVudC5pbnB1dHMubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidG9vIG1hbnkgYXJndW1lbnRzIGZvciBcIiArIGV2ZW50RnJhZ21lbnQuZm9ybWF0KCksIGxpYi5Mb2dnZXIuZXJyb3JzLlVORVhQRUNURURfQVJHVU1FTlQsIHtcblx0ICAgICAgICAgICAgICAgIGFyZ3VtZW50OiBcInZhbHVlc1wiLFxuXHQgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlc1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHRvcGljcyA9IFtdO1xuXHQgICAgICAgIGlmICghZXZlbnRGcmFnbWVudC5hbm9ueW1vdXMpIHtcblx0ICAgICAgICAgICAgdG9waWNzLnB1c2godGhpcy5nZXRFdmVudFRvcGljKGV2ZW50RnJhZ21lbnQpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGVuY29kZVRvcGljID0gZnVuY3Rpb24gKHBhcmFtLCB2YWx1ZSkge1xuXHQgICAgICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGxpYiQ5LmlkKHZhbHVlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIGlmIChwYXJhbS50eXBlID09PSBcImJ5dGVzXCIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBsaWIkNC5rZWNjYWsyNTYobGliJDEuaGV4bGlmeSh2YWx1ZSkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIC8vIENoZWNrIGFkZHJlc3NlcyBhcmUgdmFsaWRcblx0ICAgICAgICAgICAgaWYgKHBhcmFtLnR5cGUgPT09IFwiYWRkcmVzc1wiKSB7XG5cdCAgICAgICAgICAgICAgICBfdGhpcy5fYWJpQ29kZXIuZW5jb2RlKFtcImFkZHJlc3NcIl0sIFt2YWx1ZV0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBsaWIkMS5oZXhaZXJvUGFkKGxpYiQxLmhleGxpZnkodmFsdWUpLCAzMik7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICB2YWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG5cdCAgICAgICAgICAgIHZhciBwYXJhbSA9IGV2ZW50RnJhZ21lbnQuaW5wdXRzW2luZGV4XTtcblx0ICAgICAgICAgICAgaWYgKCFwYXJhbS5pbmRleGVkKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJjYW5ub3QgZmlsdGVyIG5vbi1pbmRleGVkIHBhcmFtZXRlcnM7IG11c3QgYmUgbnVsbFwiLCAoXCJjb250cmFjdC5cIiArIHBhcmFtLm5hbWUpLCB2YWx1ZSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgIHRvcGljcy5wdXNoKG51bGwpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtLmJhc2VUeXBlID09PSBcImFycmF5XCIgfHwgcGFyYW0uYmFzZVR5cGUgPT09IFwidHVwbGVcIikge1xuXHQgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImZpbHRlcmluZyB3aXRoIHR1cGxlcyBvciBhcnJheXMgbm90IHN1cHBvcnRlZFwiLCAoXCJjb250cmFjdC5cIiArIHBhcmFtLm5hbWUpLCB2YWx1ZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0ICAgICAgICAgICAgICAgIHRvcGljcy5wdXNoKHZhbHVlLm1hcChmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIGVuY29kZVRvcGljKHBhcmFtLCB2YWx1ZSk7IH0pKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRvcGljcy5wdXNoKGVuY29kZVRvcGljKHBhcmFtLCB2YWx1ZSkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgLy8gVHJpbSBvZmYgdHJhaWxpbmcgbnVsbHNcblx0ICAgICAgICB3aGlsZSAodG9waWNzLmxlbmd0aCAmJiB0b3BpY3NbdG9waWNzLmxlbmd0aCAtIDFdID09PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHRvcGljcy5wb3AoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRvcGljcztcblx0ICAgIH07XG5cdCAgICBJbnRlcmZhY2UucHJvdG90eXBlLmVuY29kZUV2ZW50TG9nID0gZnVuY3Rpb24gKGV2ZW50RnJhZ21lbnQsIHZhbHVlcykge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgaWYgKHR5cGVvZiAoZXZlbnRGcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgZXZlbnRGcmFnbWVudCA9IHRoaXMuZ2V0RXZlbnQoZXZlbnRGcmFnbWVudCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciB0b3BpY3MgPSBbXTtcblx0ICAgICAgICB2YXIgZGF0YVR5cGVzID0gW107XG5cdCAgICAgICAgdmFyIGRhdGFWYWx1ZXMgPSBbXTtcblx0ICAgICAgICBpZiAoIWV2ZW50RnJhZ21lbnQuYW5vbnltb3VzKSB7XG5cdCAgICAgICAgICAgIHRvcGljcy5wdXNoKHRoaXMuZ2V0RXZlbnRUb3BpYyhldmVudEZyYWdtZW50KSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICh2YWx1ZXMubGVuZ3RoICE9PSBldmVudEZyYWdtZW50LmlucHV0cy5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImV2ZW50IGFyZ3VtZW50cy92YWx1ZXMgbWlzbWF0Y2hcIiwgXCJ2YWx1ZXNcIiwgdmFsdWVzKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZXZlbnRGcmFnbWVudC5pbnB1dHMuZm9yRWFjaChmdW5jdGlvbiAocGFyYW0sIGluZGV4KSB7XG5cdCAgICAgICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlc1tpbmRleF07XG5cdCAgICAgICAgICAgIGlmIChwYXJhbS5pbmRleGVkKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgICAgICAgICAgICAgIHRvcGljcy5wdXNoKGxpYiQ5LmlkKHZhbHVlKSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJhbS50eXBlID09PSBcImJ5dGVzXCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0b3BpY3MucHVzaChsaWIkNC5rZWNjYWsyNTYodmFsdWUpKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtLmJhc2VUeXBlID09PSBcInR1cGxlXCIgfHwgcGFyYW0uYmFzZVR5cGUgPT09IFwiYXJyYXlcIikge1xuXHQgICAgICAgICAgICAgICAgICAgIC8vIEBUT09EXG5cdCAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkXCIpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdG9waWNzLnB1c2goX3RoaXMuX2FiaUNvZGVyLmVuY29kZShbcGFyYW0udHlwZV0sIFt2YWx1ZV0pKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIGRhdGFUeXBlcy5wdXNoKHBhcmFtKTtcblx0ICAgICAgICAgICAgICAgIGRhdGFWYWx1ZXMucHVzaCh2YWx1ZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICBkYXRhOiB0aGlzLl9hYmlDb2Rlci5lbmNvZGUoZGF0YVR5cGVzLCBkYXRhVmFsdWVzKSxcblx0ICAgICAgICAgICAgdG9waWNzOiB0b3BpY3Ncblx0ICAgICAgICB9O1xuXHQgICAgfTtcblx0ICAgIC8vIERlY29kZSBhIGZpbHRlciBmb3IgdGhlIGV2ZW50IGFuZCB0aGUgc2VhcmNoIGNyaXRlcmlhXG5cdCAgICBJbnRlcmZhY2UucHJvdG90eXBlLmRlY29kZUV2ZW50TG9nID0gZnVuY3Rpb24gKGV2ZW50RnJhZ21lbnQsIGRhdGEsIHRvcGljcykge1xuXHQgICAgICAgIGlmICh0eXBlb2YgKGV2ZW50RnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgIGV2ZW50RnJhZ21lbnQgPSB0aGlzLmdldEV2ZW50KGV2ZW50RnJhZ21lbnQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodG9waWNzICE9IG51bGwgJiYgIWV2ZW50RnJhZ21lbnQuYW5vbnltb3VzKSB7XG5cdCAgICAgICAgICAgIHZhciB0b3BpY0hhc2ggPSB0aGlzLmdldEV2ZW50VG9waWMoZXZlbnRGcmFnbWVudCk7XG5cdCAgICAgICAgICAgIGlmICghbGliJDEuaXNIZXhTdHJpbmcodG9waWNzWzBdLCAzMikgfHwgdG9waWNzWzBdLnRvTG93ZXJDYXNlKCkgIT09IHRvcGljSGFzaCkge1xuXHQgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJmcmFnbWVudC90b3BpYyBtaXNtYXRjaFwiLCBsaWIuTG9nZ2VyLmVycm9ycy5JTlZBTElEX0FSR1VNRU5ULCB7IGFyZ3VtZW50OiBcInRvcGljc1swXVwiLCBleHBlY3RlZDogdG9waWNIYXNoLCB2YWx1ZTogdG9waWNzWzBdIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRvcGljcyA9IHRvcGljcy5zbGljZSgxKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGluZGV4ZWQgPSBbXTtcblx0ICAgICAgICB2YXIgbm9uSW5kZXhlZCA9IFtdO1xuXHQgICAgICAgIHZhciBkeW5hbWljID0gW107XG5cdCAgICAgICAgZXZlbnRGcmFnbWVudC5pbnB1dHMuZm9yRWFjaChmdW5jdGlvbiAocGFyYW0sIGluZGV4KSB7XG5cdCAgICAgICAgICAgIGlmIChwYXJhbS5pbmRleGVkKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gXCJzdHJpbmdcIiB8fCBwYXJhbS50eXBlID09PSBcImJ5dGVzXCIgfHwgcGFyYW0uYmFzZVR5cGUgPT09IFwidHVwbGVcIiB8fCBwYXJhbS5iYXNlVHlwZSA9PT0gXCJhcnJheVwiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaW5kZXhlZC5wdXNoKGZyYWdtZW50cy5QYXJhbVR5cGUuZnJvbU9iamVjdCh7IHR5cGU6IFwiYnl0ZXMzMlwiLCBuYW1lOiBwYXJhbS5uYW1lIH0pKTtcblx0ICAgICAgICAgICAgICAgICAgICBkeW5hbWljLnB1c2godHJ1ZSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICBpbmRleGVkLnB1c2gocGFyYW0pO1xuXHQgICAgICAgICAgICAgICAgICAgIGR5bmFtaWMucHVzaChmYWxzZSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBub25JbmRleGVkLnB1c2gocGFyYW0pO1xuXHQgICAgICAgICAgICAgICAgZHluYW1pYy5wdXNoKGZhbHNlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHZhciByZXN1bHRJbmRleGVkID0gKHRvcGljcyAhPSBudWxsKSA/IHRoaXMuX2FiaUNvZGVyLmRlY29kZShpbmRleGVkLCBsaWIkMS5jb25jYXQodG9waWNzKSkgOiBudWxsO1xuXHQgICAgICAgIHZhciByZXN1bHROb25JbmRleGVkID0gdGhpcy5fYWJpQ29kZXIuZGVjb2RlKG5vbkluZGV4ZWQsIGRhdGEpO1xuXHQgICAgICAgIHZhciByZXN1bHQgPSBbXTtcblx0ICAgICAgICB2YXIgbm9uSW5kZXhlZEluZGV4ID0gMCwgaW5kZXhlZEluZGV4ID0gMDtcblx0ICAgICAgICBldmVudEZyYWdtZW50LmlucHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbSwgaW5kZXgpIHtcblx0ICAgICAgICAgICAgaWYgKHBhcmFtLmluZGV4ZWQpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChyZXN1bHRJbmRleGVkID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXN1bHRbaW5kZXhdID0gbmV3IEluZGV4ZWQoeyBfaXNJbmRleGVkOiB0cnVlLCBoYXNoOiBudWxsIH0pO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAoZHluYW1pY1tpbmRleF0pIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXN1bHRbaW5kZXhdID0gbmV3IEluZGV4ZWQoeyBfaXNJbmRleGVkOiB0cnVlLCBoYXNoOiByZXN1bHRJbmRleGVkW2luZGV4ZWRJbmRleCsrXSB9KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSByZXN1bHRJbmRleGVkW2luZGV4ZWRJbmRleCsrXTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBlcnJvcjtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSByZXN1bHROb25JbmRleGVkW25vbkluZGV4ZWRJbmRleCsrXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBlcnJvcjtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAvLyBBZGQgdGhlIGtleXdvcmQgYXJndW1lbnQgaWYgbmFtZWQgYW5kIHNhZmVcblx0ICAgICAgICAgICAgaWYgKHBhcmFtLm5hbWUgJiYgcmVzdWx0W3BhcmFtLm5hbWVdID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgIHZhciB2YWx1ZV8xID0gcmVzdWx0W2luZGV4XTtcblx0ICAgICAgICAgICAgICAgIC8vIE1ha2UgZXJyb3IgbmFtZWQgdmFsdWVzIHRocm93IG9uIGFjY2Vzc1xuXHQgICAgICAgICAgICAgICAgaWYgKHZhbHVlXzEgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXN1bHQsIHBhcmFtLm5hbWUsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHRocm93IHdyYXBBY2Nlc3NFcnJvcihcInByb3BlcnR5IFwiICsgSlNPTi5zdHJpbmdpZnkocGFyYW0ubmFtZSksIHZhbHVlXzEpOyB9XG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXN1bHRbcGFyYW0ubmFtZV0gPSB2YWx1ZV8xO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoaSkge1xuXHQgICAgICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHRbaV07XG5cdCAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzdWx0LCBpLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHRocm93IHdyYXBBY2Nlc3NFcnJvcihcImluZGV4IFwiICsgaSwgdmFsdWUpOyB9XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH07XG5cdCAgICAgICAgLy8gTWFrZSBhbGwgZXJyb3IgaW5kZXhlZCB2YWx1ZXMgdGhyb3cgb24gYWNjZXNzXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgX2xvb3BfMShpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIE9iamVjdC5mcmVlemUocmVzdWx0KTtcblx0ICAgIH07XG5cdCAgICAvLyBHaXZlbiBhIHRyYW5zYWN0aW9uLCBmaW5kIHRoZSBtYXRjaGluZyBmdW5jdGlvbiBmcmFnbWVudCAoaWYgYW55KSBhbmRcblx0ICAgIC8vIGRldGVybWluZSBhbGwgaXRzIHByb3BlcnRpZXMgYW5kIGNhbGwgcGFyYW1ldGVyc1xuXHQgICAgSW50ZXJmYWNlLnByb3RvdHlwZS5wYXJzZVRyYW5zYWN0aW9uID0gZnVuY3Rpb24gKHR4KSB7XG5cdCAgICAgICAgdmFyIGZyYWdtZW50ID0gdGhpcy5nZXRGdW5jdGlvbih0eC5kYXRhLnN1YnN0cmluZygwLCAxMCkudG9Mb3dlckNhc2UoKSk7XG5cdCAgICAgICAgaWYgKCFmcmFnbWVudCkge1xuXHQgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkRlc2NyaXB0aW9uKHtcblx0ICAgICAgICAgICAgYXJnczogdGhpcy5fYWJpQ29kZXIuZGVjb2RlKGZyYWdtZW50LmlucHV0cywgXCIweFwiICsgdHguZGF0YS5zdWJzdHJpbmcoMTApKSxcblx0ICAgICAgICAgICAgZnVuY3Rpb25GcmFnbWVudDogZnJhZ21lbnQsXG5cdCAgICAgICAgICAgIG5hbWU6IGZyYWdtZW50Lm5hbWUsXG5cdCAgICAgICAgICAgIHNpZ25hdHVyZTogZnJhZ21lbnQuZm9ybWF0KCksXG5cdCAgICAgICAgICAgIHNpZ2hhc2g6IHRoaXMuZ2V0U2lnaGFzaChmcmFnbWVudCksXG5cdCAgICAgICAgICAgIHZhbHVlOiBsaWIkMi5CaWdOdW1iZXIuZnJvbSh0eC52YWx1ZSB8fCBcIjBcIiksXG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgLy8gR2l2ZW4gYW4gZXZlbnQgbG9nLCBmaW5kIHRoZSBtYXRjaGluZyBldmVudCBmcmFnbWVudCAoaWYgYW55KSBhbmRcblx0ICAgIC8vIGRldGVybWluZSBhbGwgaXRzIHByb3BlcnRpZXMgYW5kIHZhbHVlc1xuXHQgICAgSW50ZXJmYWNlLnByb3RvdHlwZS5wYXJzZUxvZyA9IGZ1bmN0aW9uIChsb2cpIHtcblx0ICAgICAgICB2YXIgZnJhZ21lbnQgPSB0aGlzLmdldEV2ZW50KGxvZy50b3BpY3NbMF0pO1xuXHQgICAgICAgIGlmICghZnJhZ21lbnQgfHwgZnJhZ21lbnQuYW5vbnltb3VzKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBAVE9ETzogSWYgYW5vbnltb3VzLCBhbmQgdGhlIG9ubHkgbWV0aG9kLCBhbmQgdGhlIGlucHV0IGNvdW50IG1hdGNoZXMsIHNob3VsZCB3ZSBwYXJzZT9cblx0ICAgICAgICAvLyAgICAgICAgUHJvYmFibHkgbm90LCBiZWNhdXNlIGp1c3QgYmVjYXVzZSBpdCBpcyB0aGUgb25seSBldmVudCBpbiB0aGUgQUJJIGRvZXNcblx0ICAgICAgICAvLyAgICAgICAgbm90IG1lYW4gd2UgaGF2ZSB0aGUgZnVsbCBBQkk7IG1heWJlIGpzdXQgYSBmcmFnbWVudD9cblx0ICAgICAgICByZXR1cm4gbmV3IExvZ0Rlc2NyaXB0aW9uKHtcblx0ICAgICAgICAgICAgZXZlbnRGcmFnbWVudDogZnJhZ21lbnQsXG5cdCAgICAgICAgICAgIG5hbWU6IGZyYWdtZW50Lm5hbWUsXG5cdCAgICAgICAgICAgIHNpZ25hdHVyZTogZnJhZ21lbnQuZm9ybWF0KCksXG5cdCAgICAgICAgICAgIHRvcGljOiB0aGlzLmdldEV2ZW50VG9waWMoZnJhZ21lbnQpLFxuXHQgICAgICAgICAgICBhcmdzOiB0aGlzLmRlY29kZUV2ZW50TG9nKGZyYWdtZW50LCBsb2cuZGF0YSwgbG9nLnRvcGljcylcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICAvKlxuXHQgICAgc3RhdGljIGZyb20odmFsdWU6IEFycmF5PEZyYWdtZW50IHwgc3RyaW5nIHwgSnNvbkFiaT4gfCBzdHJpbmcgfCBJbnRlcmZhY2UpIHtcblx0ICAgICAgICBpZiAoSW50ZXJmYWNlLmlzSW50ZXJmYWNlKHZhbHVlKSkge1xuXHQgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICh0eXBlb2YodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgSW50ZXJmYWNlKEpTT04ucGFyc2UodmFsdWUpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIG5ldyBJbnRlcmZhY2UodmFsdWUpO1xuXHQgICAgfVxuXHQgICAgKi9cblx0ICAgIEludGVyZmFjZS5pc0ludGVyZmFjZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5faXNJbnRlcmZhY2UpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBJbnRlcmZhY2U7XG5cdH0oKSk7XG5cdGV4cG9ydHMuSW50ZXJmYWNlID0gSW50ZXJmYWNlO1xuXG5cdH0pO1xuXG5cdHZhciBfaW50ZXJmYWNlJDEgPSB1bndyYXBFeHBvcnRzKF9pbnRlcmZhY2UpO1xuXHR2YXIgX2ludGVyZmFjZV8xID0gX2ludGVyZmFjZS5jaGVja1Jlc3VsdEVycm9ycztcblx0dmFyIF9pbnRlcmZhY2VfMiA9IF9pbnRlcmZhY2UuTG9nRGVzY3JpcHRpb247XG5cdHZhciBfaW50ZXJmYWNlXzMgPSBfaW50ZXJmYWNlLlRyYW5zYWN0aW9uRGVzY3JpcHRpb247XG5cdHZhciBfaW50ZXJmYWNlXzQgPSBfaW50ZXJmYWNlLkluZGV4ZWQ7XG5cdHZhciBfaW50ZXJmYWNlXzUgPSBfaW50ZXJmYWNlLkludGVyZmFjZTtcblxuXHR2YXIgbGliJGEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cblx0ZXhwb3J0cy5Db25zdHJ1Y3RvckZyYWdtZW50ID0gZnJhZ21lbnRzLkNvbnN0cnVjdG9yRnJhZ21lbnQ7XG5cdGV4cG9ydHMuRXZlbnRGcmFnbWVudCA9IGZyYWdtZW50cy5FdmVudEZyYWdtZW50O1xuXHRleHBvcnRzLkZvcm1hdFR5cGVzID0gZnJhZ21lbnRzLkZvcm1hdFR5cGVzO1xuXHRleHBvcnRzLkZyYWdtZW50ID0gZnJhZ21lbnRzLkZyYWdtZW50O1xuXHRleHBvcnRzLkZ1bmN0aW9uRnJhZ21lbnQgPSBmcmFnbWVudHMuRnVuY3Rpb25GcmFnbWVudDtcblx0ZXhwb3J0cy5QYXJhbVR5cGUgPSBmcmFnbWVudHMuUGFyYW1UeXBlO1xuXG5cdGV4cG9ydHMuQWJpQ29kZXIgPSBhYmlDb2Rlci5BYmlDb2Rlcjtcblx0ZXhwb3J0cy5kZWZhdWx0QWJpQ29kZXIgPSBhYmlDb2Rlci5kZWZhdWx0QWJpQ29kZXI7XG5cblx0ZXhwb3J0cy5jaGVja1Jlc3VsdEVycm9ycyA9IF9pbnRlcmZhY2UuY2hlY2tSZXN1bHRFcnJvcnM7XG5cdGV4cG9ydHMuSW5kZXhlZCA9IF9pbnRlcmZhY2UuSW5kZXhlZDtcblx0ZXhwb3J0cy5JbnRlcmZhY2UgPSBfaW50ZXJmYWNlLkludGVyZmFjZTtcblx0ZXhwb3J0cy5Mb2dEZXNjcmlwdGlvbiA9IF9pbnRlcmZhY2UuTG9nRGVzY3JpcHRpb247XG5cdGV4cG9ydHMuVHJhbnNhY3Rpb25EZXNjcmlwdGlvbiA9IF9pbnRlcmZhY2UuVHJhbnNhY3Rpb25EZXNjcmlwdGlvbjtcblxuXHR9KTtcblxuXHR2YXIgaW5kZXgkYSA9IHVud3JhcEV4cG9ydHMobGliJGEpO1xuXHR2YXIgbGliXzEkYSA9IGxpYiRhLkNvbnN0cnVjdG9yRnJhZ21lbnQ7XG5cdHZhciBsaWJfMiQ5ID0gbGliJGEuRXZlbnRGcmFnbWVudDtcblx0dmFyIGxpYl8zJDggPSBsaWIkYS5Gb3JtYXRUeXBlcztcblx0dmFyIGxpYl80JDcgPSBsaWIkYS5GcmFnbWVudDtcblx0dmFyIGxpYl81JDcgPSBsaWIkYS5GdW5jdGlvbkZyYWdtZW50O1xuXHR2YXIgbGliXzYkNCA9IGxpYiRhLlBhcmFtVHlwZTtcblx0dmFyIGxpYl83JDQgPSBsaWIkYS5BYmlDb2Rlcjtcblx0dmFyIGxpYl84JDMgPSBsaWIkYS5kZWZhdWx0QWJpQ29kZXI7XG5cdHZhciBsaWJfOSQzID0gbGliJGEuY2hlY2tSZXN1bHRFcnJvcnM7XG5cdHZhciBsaWJfMTAkMiA9IGxpYiRhLkluZGV4ZWQ7XG5cdHZhciBsaWJfMTEkMSA9IGxpYiRhLkludGVyZmFjZTtcblx0dmFyIGxpYl8xMiQxID0gbGliJGEuTG9nRGVzY3JpcHRpb247XG5cdHZhciBsaWJfMTMkMSA9IGxpYiRhLlRyYW5zYWN0aW9uRGVzY3JpcHRpb247XG5cblx0dmFyIF92ZXJzaW9uJGkgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMudmVyc2lvbiA9IFwiYWJzdHJhY3QtcHJvdmlkZXIvNS4wLjJcIjtcblxuXHR9KTtcblxuXHR2YXIgX3ZlcnNpb24kaiA9IHVud3JhcEV4cG9ydHMoX3ZlcnNpb24kaSk7XG5cdHZhciBfdmVyc2lvbl8xJDkgPSBfdmVyc2lvbiRpLnZlcnNpb247XG5cblx0dmFyIGxpYiRiID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0dmFyIF9fZXh0ZW5kcyA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuXHQgICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuXHQgICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG5cdCAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuXHQgICAgfTtcblx0fSkoKTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5cblxuXG5cdHZhciBsb2dnZXIgPSBuZXcgbGliLkxvZ2dlcihfdmVyc2lvbiRpLnZlcnNpb24pO1xuXHQ7XG5cdDtcblx0Ly9leHBvcnQgdHlwZSBDYWxsVHJhbnNhY3Rpb25hYmxlID0ge1xuXHQvLyAgICBjYWxsKHRyYW5zYWN0aW9uOiBUcmFuc2FjdGlvblJlcXVlc3QpOiBQcm9taXNlPFRyYW5zYWN0aW9uUmVzcG9uc2U+O1xuXHQvL307XG5cdHZhciBGb3JrRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoRm9ya0V2ZW50LCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gRm9ya0V2ZW50KCkge1xuXHQgICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblx0ICAgIH1cblx0ICAgIEZvcmtFdmVudC5pc0ZvcmtFdmVudCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5faXNGb3JrRXZlbnQpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBGb3JrRXZlbnQ7XG5cdH0obGliJDMuRGVzY3JpcHRpb24pKTtcblx0ZXhwb3J0cy5Gb3JrRXZlbnQgPSBGb3JrRXZlbnQ7XG5cdHZhciBCbG9ja0ZvcmtFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0ICAgIF9fZXh0ZW5kcyhCbG9ja0ZvcmtFdmVudCwgX3N1cGVyKTtcblx0ICAgIGZ1bmN0aW9uIEJsb2NrRm9ya0V2ZW50KGJsb2NrSGFzaCwgZXhwaXJ5KSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICBpZiAoIWxpYiQxLmlzSGV4U3RyaW5nKGJsb2NrSGFzaCwgMzIpKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGJsb2NrSGFzaFwiLCBcImJsb2NrSGFzaFwiLCBibG9ja0hhc2gpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHtcblx0ICAgICAgICAgICAgX2lzRm9ya0V2ZW50OiB0cnVlLFxuXHQgICAgICAgICAgICBfaXNCbG9ja0ZvcmtFdmVudDogdHJ1ZSxcblx0ICAgICAgICAgICAgZXhwaXJ5OiAoZXhwaXJ5IHx8IDApLFxuXHQgICAgICAgICAgICBibG9ja0hhc2g6IGJsb2NrSGFzaFxuXHQgICAgICAgIH0pIHx8IHRoaXM7XG5cdCAgICAgICAgcmV0dXJuIF90aGlzO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIEJsb2NrRm9ya0V2ZW50O1xuXHR9KEZvcmtFdmVudCkpO1xuXHRleHBvcnRzLkJsb2NrRm9ya0V2ZW50ID0gQmxvY2tGb3JrRXZlbnQ7XG5cdHZhciBUcmFuc2FjdGlvbkZvcmtFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0ICAgIF9fZXh0ZW5kcyhUcmFuc2FjdGlvbkZvcmtFdmVudCwgX3N1cGVyKTtcblx0ICAgIGZ1bmN0aW9uIFRyYW5zYWN0aW9uRm9ya0V2ZW50KGhhc2gsIGV4cGlyeSkge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgaWYgKCFsaWIkMS5pc0hleFN0cmluZyhoYXNoLCAzMikpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgdHJhbnNhY3Rpb24gaGFzaFwiLCBcImhhc2hcIiwgaGFzaCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywge1xuXHQgICAgICAgICAgICBfaXNGb3JrRXZlbnQ6IHRydWUsXG5cdCAgICAgICAgICAgIF9pc1RyYW5zYWN0aW9uRm9ya0V2ZW50OiB0cnVlLFxuXHQgICAgICAgICAgICBleHBpcnk6IChleHBpcnkgfHwgMCksXG5cdCAgICAgICAgICAgIGhhc2g6IGhhc2hcblx0ICAgICAgICB9KSB8fCB0aGlzO1xuXHQgICAgICAgIHJldHVybiBfdGhpcztcblx0ICAgIH1cblx0ICAgIHJldHVybiBUcmFuc2FjdGlvbkZvcmtFdmVudDtcblx0fShGb3JrRXZlbnQpKTtcblx0ZXhwb3J0cy5UcmFuc2FjdGlvbkZvcmtFdmVudCA9IFRyYW5zYWN0aW9uRm9ya0V2ZW50O1xuXHR2YXIgVHJhbnNhY3Rpb25PcmRlckZvcmtFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0ICAgIF9fZXh0ZW5kcyhUcmFuc2FjdGlvbk9yZGVyRm9ya0V2ZW50LCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gVHJhbnNhY3Rpb25PcmRlckZvcmtFdmVudChiZWZvcmVIYXNoLCBhZnRlckhhc2gsIGV4cGlyeSkge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgaWYgKCFsaWIkMS5pc0hleFN0cmluZyhiZWZvcmVIYXNoLCAzMikpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgdHJhbnNhY3Rpb24gaGFzaFwiLCBcImJlZm9yZUhhc2hcIiwgYmVmb3JlSGFzaCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICghbGliJDEuaXNIZXhTdHJpbmcoYWZ0ZXJIYXNoLCAzMikpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgdHJhbnNhY3Rpb24gaGFzaFwiLCBcImFmdGVySGFzaFwiLCBhZnRlckhhc2gpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHtcblx0ICAgICAgICAgICAgX2lzRm9ya0V2ZW50OiB0cnVlLFxuXHQgICAgICAgICAgICBfaXNUcmFuc2FjdGlvbk9yZGVyRm9ya0V2ZW50OiB0cnVlLFxuXHQgICAgICAgICAgICBleHBpcnk6IChleHBpcnkgfHwgMCksXG5cdCAgICAgICAgICAgIGJlZm9yZUhhc2g6IGJlZm9yZUhhc2gsXG5cdCAgICAgICAgICAgIGFmdGVySGFzaDogYWZ0ZXJIYXNoXG5cdCAgICAgICAgfSkgfHwgdGhpcztcblx0ICAgICAgICByZXR1cm4gX3RoaXM7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gVHJhbnNhY3Rpb25PcmRlckZvcmtFdmVudDtcblx0fShGb3JrRXZlbnQpKTtcblx0ZXhwb3J0cy5UcmFuc2FjdGlvbk9yZGVyRm9ya0V2ZW50ID0gVHJhbnNhY3Rpb25PcmRlckZvcmtFdmVudDtcblx0Ly8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQvLyBFeHBvcnRlZCBBYnN0cmFjdHNcblx0dmFyIFByb3ZpZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gUHJvdmlkZXIoKSB7XG5cdCAgICAgICAgdmFyIF9uZXdUYXJnZXQgPSB0aGlzLmNvbnN0cnVjdG9yO1xuXHQgICAgICAgIGxvZ2dlci5jaGVja0Fic3RyYWN0KF9uZXdUYXJnZXQsIFByb3ZpZGVyKTtcblx0ICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcIl9pc1Byb3ZpZGVyXCIsIHRydWUpO1xuXHQgICAgfVxuXHQgICAgLy8gQWxpYXMgZm9yIFwib25cIlxuXHQgICAgUHJvdmlkZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5vbihldmVudE5hbWUsIGxpc3RlbmVyKTtcblx0ICAgIH07XG5cdCAgICAvLyBBbGlhcyBmb3IgXCJvZmZcIlxuXHQgICAgUHJvdmlkZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5vZmYoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG5cdCAgICB9O1xuXHQgICAgUHJvdmlkZXIuaXNQcm92aWRlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5faXNQcm92aWRlcik7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFByb3ZpZGVyO1xuXHR9KCkpO1xuXHRleHBvcnRzLlByb3ZpZGVyID0gUHJvdmlkZXI7XG5cblx0fSk7XG5cblx0dmFyIGluZGV4JGIgPSB1bndyYXBFeHBvcnRzKGxpYiRiKTtcblx0dmFyIGxpYl8xJGIgPSBsaWIkYi5Gb3JrRXZlbnQ7XG5cdHZhciBsaWJfMiRhID0gbGliJGIuQmxvY2tGb3JrRXZlbnQ7XG5cdHZhciBsaWJfMyQ5ID0gbGliJGIuVHJhbnNhY3Rpb25Gb3JrRXZlbnQ7XG5cdHZhciBsaWJfNCQ4ID0gbGliJGIuVHJhbnNhY3Rpb25PcmRlckZvcmtFdmVudDtcblx0dmFyIGxpYl81JDggPSBsaWIkYi5Qcm92aWRlcjtcblxuXHR2YXIgX3ZlcnNpb24kayA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy52ZXJzaW9uID0gXCJhYnN0cmFjdC1zaWduZXIvNS4wLjJcIjtcblxuXHR9KTtcblxuXHR2YXIgX3ZlcnNpb24kbCA9IHVud3JhcEV4cG9ydHMoX3ZlcnNpb24kayk7XG5cdHZhciBfdmVyc2lvbl8xJGEgPSBfdmVyc2lvbiRrLnZlcnNpb247XG5cblx0dmFyIGxpYiRjID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0dmFyIF9fZXh0ZW5kcyA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuXHQgICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuXHQgICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG5cdCAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuXHQgICAgfTtcblx0fSkoKTtcblx0dmFyIF9fYXdhaXRlciA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcblx0ICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuXHQgICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdCAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuXHQgICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuXHQgICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG5cdCAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuXHQgICAgfSk7XG5cdH07XG5cdHZhciBfX2dlbmVyYXRvciA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcblx0ICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG5cdCAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcblx0ICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuXHQgICAgZnVuY3Rpb24gc3RlcChvcCkge1xuXHQgICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcblx0ICAgICAgICB3aGlsZSAoXykgdHJ5IHtcblx0ICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuXHQgICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG5cdCAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcblx0ICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG5cdCAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuXHQgICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuXHQgICAgfVxuXHR9O1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cblxuXG5cdHZhciBsb2dnZXIgPSBuZXcgbGliLkxvZ2dlcihfdmVyc2lvbiRrLnZlcnNpb24pO1xuXHR2YXIgYWxsb3dlZFRyYW5zYWN0aW9uS2V5cyA9IFtcblx0ICAgIFwiY2hhaW5JZFwiLCBcImRhdGFcIiwgXCJmcm9tXCIsIFwiZ2FzTGltaXRcIiwgXCJnYXNQcmljZVwiLCBcIm5vbmNlXCIsIFwidG9cIiwgXCJ2YWx1ZVwiXG5cdF07XG5cdC8vIFN1Yi1DbGFzcyBOb3Rlczpcblx0Ly8gIC0gQSBTaWduZXIgTVVTVCBhbHdheXMgbWFrZSBzdXJlLCB0aGF0IGlmIHByZXNlbnQsIHRoZSBcImZyb21cIiBmaWVsZFxuXHQvLyAgICBtYXRjaGVzIHRoZSBTaWduZXIsIGJlZm9yZSBzZW5kaW5nIG9yIHNpZ25pbmcgYSB0cmFuc2FjdGlvblxuXHQvLyAgLSBBIFNpZ25lciBTSE9VTEQgYWx3YXlzIHdyYXAgcHJpdmF0ZSBpbmZvcm1hdGlvbiAoc3VjaCBhcyBhIHByaXZhdGVcblx0Ly8gICAga2V5IG9yIG1uZW1vbmljKSBpbiBhIGZ1bmN0aW9uLCBzbyB0aGF0IGNvbnNvbGUubG9nIGRvZXMgbm90IGxlYWtcblx0Ly8gICAgdGhlIGRhdGFcblx0dmFyIFNpZ25lciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vIFN1Yi1jbGFzc2VzIE1VU1QgY2FsbCBzdXBlclxuXHQgICAgZnVuY3Rpb24gU2lnbmVyKCkge1xuXHQgICAgICAgIHZhciBfbmV3VGFyZ2V0ID0gdGhpcy5jb25zdHJ1Y3Rvcjtcblx0ICAgICAgICBsb2dnZXIuY2hlY2tBYnN0cmFjdChfbmV3VGFyZ2V0LCBTaWduZXIpO1xuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX2lzU2lnbmVyXCIsIHRydWUpO1xuXHQgICAgfVxuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy8gU3ViLWNsYXNzZXMgTUFZIG92ZXJyaWRlIHRoZXNlXG5cdCAgICBTaWduZXIucHJvdG90eXBlLmdldEJhbGFuY2UgPSBmdW5jdGlvbiAoYmxvY2tUYWcpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrUHJvdmlkZXIoXCJnZXRCYWxhbmNlXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnByb3ZpZGVyLmdldEJhbGFuY2UodGhpcy5nZXRBZGRyZXNzKCksIGJsb2NrVGFnKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgU2lnbmVyLnByb3RvdHlwZS5nZXRUcmFuc2FjdGlvbkNvdW50ID0gZnVuY3Rpb24gKGJsb2NrVGFnKSB7XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGVja1Byb3ZpZGVyKFwiZ2V0VHJhbnNhY3Rpb25Db3VudFwiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbkNvdW50KHRoaXMuZ2V0QWRkcmVzcygpLCBibG9ja1RhZyldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIC8vIFBvcHVsYXRlcyBcImZyb21cIiBpZiB1bnNwZWNpZmllZCwgYW5kIGVzdGltYXRlcyB0aGUgZ2FzIGZvciB0aGUgdHJhbnNhdGlvblxuXHQgICAgU2lnbmVyLnByb3RvdHlwZS5lc3RpbWF0ZUdhcyA9IGZ1bmN0aW9uICh0cmFuc2FjdGlvbikge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIHR4O1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGVja1Byb3ZpZGVyKFwiZXN0aW1hdGVHYXNcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGxpYiQzLnJlc29sdmVQcm9wZXJ0aWVzKHRoaXMuY2hlY2tUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR4ID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnByb3ZpZGVyLmVzdGltYXRlR2FzKHR4KV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgLy8gUG9wdWxhdGVzIFwiZnJvbVwiIGlmIHVuc3BlY2lmaWVkLCBhbmQgY2FsbHMgd2l0aCB0aGUgdHJhbnNhdGlvblxuXHQgICAgU2lnbmVyLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBibG9ja1RhZykge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIHR4O1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGVja1Byb3ZpZGVyKFwiY2FsbFwiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgbGliJDMucmVzb2x2ZVByb3BlcnRpZXModGhpcy5jaGVja1RyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHggPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucHJvdmlkZXIuY2FsbCh0eCwgYmxvY2tUYWcpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICAvLyBQb3B1bGF0ZXMgYWxsIGZpZWxkcyBpbiBhIHRyYW5zYWN0aW9uLCBzaWducyBpdCBhbmQgc2VuZHMgaXQgdG8gdGhlIG5ldHdvcmtcblx0ICAgIFNpZ25lci5wcm90b3R5cGUuc2VuZFRyYW5zYWN0aW9uID0gZnVuY3Rpb24gKHRyYW5zYWN0aW9uKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICB0aGlzLl9jaGVja1Byb3ZpZGVyKFwic2VuZFRyYW5zYWN0aW9uXCIpO1xuXHQgICAgICAgIHJldHVybiB0aGlzLnBvcHVsYXRlVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pLnRoZW4oZnVuY3Rpb24gKHR4KSB7XG5cdCAgICAgICAgICAgIHJldHVybiBfdGhpcy5zaWduVHJhbnNhY3Rpb24odHgpLnRoZW4oZnVuY3Rpb24gKHNpZ25lZFR4KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMucHJvdmlkZXIuc2VuZFRyYW5zYWN0aW9uKHNpZ25lZFR4KTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgU2lnbmVyLnByb3RvdHlwZS5nZXRDaGFpbklkID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIG5ldHdvcms7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrUHJvdmlkZXIoXCJnZXRDaGFpbklkXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnByb3ZpZGVyLmdldE5ldHdvcmsoKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBuZXR3b3JrID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbmV0d29yay5jaGFpbklkXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgU2lnbmVyLnByb3RvdHlwZS5nZXRHYXNQcmljZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrUHJvdmlkZXIoXCJnZXRHYXNQcmljZVwiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5wcm92aWRlci5nZXRHYXNQcmljZSgpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBTaWduZXIucHJvdG90eXBlLnJlc29sdmVOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrUHJvdmlkZXIoXCJyZXNvbHZlTmFtZVwiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5wcm92aWRlci5yZXNvbHZlTmFtZShuYW1lKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgLy8gQ2hlY2tzIGEgdHJhbnNhY3Rpb24gZG9lcyBub3QgY29udGFpbiBpbnZhbGlkIGtleXMgYW5kIGlmXG5cdCAgICAvLyBubyBcImZyb21cIiBpcyBwcm92aWRlZCwgcG9wdWxhdGVzIGl0LlxuXHQgICAgLy8gLSBkb2VzIE5PVCByZXF1aXJlIGEgcHJvdmlkZXJcblx0ICAgIC8vIC0gYWRkcyBcImZyb21cIiBpcyBub3QgcHJlc2VudFxuXHQgICAgLy8gLSByZXR1cm5zIGEgQ09QWSAoc2FmZSB0byBtdXRhdGUgdGhlIHJlc3VsdClcblx0ICAgIC8vIEJ5IGRlZmF1bHQgY2FsbGVkIGZyb206IChvdmVycmlkaW5nIHRoZXNlIHByZXZlbnRzIGl0KVxuXHQgICAgLy8gICAtIGNhbGxcblx0ICAgIC8vICAgLSBlc3RpbWF0ZUdhc1xuXHQgICAgLy8gICAtIHBvcHVsYXRlVHJhbnNhY3Rpb24gKGFuZCB0aGVyZWZvciBzZW5kVHJhbnNhY3Rpb24pXG5cdCAgICBTaWduZXIucHJvdG90eXBlLmNoZWNrVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAodHJhbnNhY3Rpb24pIHtcblx0ICAgICAgICBmb3IgKHZhciBrZXkgaW4gdHJhbnNhY3Rpb24pIHtcblx0ICAgICAgICAgICAgaWYgKGFsbG93ZWRUcmFuc2FjdGlvbktleXMuaW5kZXhPZihrZXkpID09PSAtMSkge1xuXHQgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgdHJhbnNhY3Rpb24ga2V5OiBcIiArIGtleSwgXCJ0cmFuc2FjdGlvblwiLCB0cmFuc2FjdGlvbik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHR4ID0gbGliJDMuc2hhbGxvd0NvcHkodHJhbnNhY3Rpb24pO1xuXHQgICAgICAgIGlmICh0eC5mcm9tID09IG51bGwpIHtcblx0ICAgICAgICAgICAgdHguZnJvbSA9IHRoaXMuZ2V0QWRkcmVzcygpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgLy8gTWFrZSBzdXJlIGFueSBwcm92aWRlZCBhZGRyZXNzIG1hdGNoZXMgdGhpcyBzaWduZXJcblx0ICAgICAgICAgICAgdHguZnJvbSA9IFByb21pc2UuYWxsKFtcblx0ICAgICAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZSh0eC5mcm9tKSxcblx0ICAgICAgICAgICAgICAgIHRoaXMuZ2V0QWRkcmVzcygpXG5cdCAgICAgICAgICAgIF0pLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHJlc3VsdFswXSAhPT0gcmVzdWx0WzFdKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImZyb20gYWRkcmVzcyBtaXNtYXRjaFwiLCBcInRyYW5zYWN0aW9uXCIsIHRyYW5zYWN0aW9uKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRbMF07XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdHg7XG5cdCAgICB9O1xuXHQgICAgLy8gUG9wdWxhdGVzIEFMTCBrZXlzIGZvciBhIHRyYW5zYWN0aW9uIGFuZCBjaGVja3MgdGhhdCBcImZyb21cIiBtYXRjaGVzXG5cdCAgICAvLyB0aGlzIFNpZ25lci4gU2hvdWxkIGJlIHVzZWQgYnkgc2VuZFRyYW5zYWN0aW9uIGJ1dCBOT1QgYnkgc2lnblRyYW5zYWN0aW9uLlxuXHQgICAgLy8gQnkgZGVmYXVsdCBjYWxsZWQgZnJvbTogKG92ZXJyaWRpbmcgdGhlc2UgcHJldmVudHMgaXQpXG5cdCAgICAvLyAgIC0gc2VuZFRyYW5zYWN0aW9uXG5cdCAgICBTaWduZXIucHJvdG90eXBlLnBvcHVsYXRlVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAodHJhbnNhY3Rpb24pIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciB0eDtcblx0ICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgbGliJDMucmVzb2x2ZVByb3BlcnRpZXModGhpcy5jaGVja1RyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHggPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eC50byAhPSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eC50byA9IFByb21pc2UucmVzb2x2ZSh0eC50bykudGhlbihmdW5jdGlvbiAodG8pIHsgcmV0dXJuIF90aGlzLnJlc29sdmVOYW1lKHRvKTsgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR4Lmdhc1ByaWNlID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4Lmdhc1ByaWNlID0gdGhpcy5nZXRHYXNQcmljZSgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eC5ub25jZSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eC5ub25jZSA9IHRoaXMuZ2V0VHJhbnNhY3Rpb25Db3VudChcInBlbmRpbmdcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR4Lmdhc0xpbWl0ID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4Lmdhc0xpbWl0ID0gdGhpcy5lc3RpbWF0ZUdhcyh0eCkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IGVzdGltYXRlIGdhczsgdHJhbnNhY3Rpb24gbWF5IGZhaWwgb3IgbWF5IHJlcXVpcmUgbWFudWFsIGdhcyBsaW1pdFwiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTlBSRURJQ1RBQkxFX0dBU19MSU1JVCwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4OiB0eFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR4LmNoYWluSWQgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHguY2hhaW5JZCA9IHRoaXMuZ2V0Q2hhaW5JZCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHguY2hhaW5JZCA9IFByb21pc2UuYWxsKFtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQcm9taXNlLnJlc29sdmUodHguY2hhaW5JZCksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRDaGFpbklkKClcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pLnRoZW4oZnVuY3Rpb24gKHJlc3VsdHMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0c1sxXSAhPT0gMCAmJiByZXN1bHRzWzBdICE9PSByZXN1bHRzWzFdKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJjaGFpbklkIGFkZHJlc3MgbWlzbWF0Y2hcIiwgXCJ0cmFuc2FjdGlvblwiLCB0cmFuc2FjdGlvbik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzWzBdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgbGliJDMucmVzb2x2ZVByb3BlcnRpZXModHgpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvLyBTdWItY2xhc3NlcyBTSE9VTEQgbGVhdmUgdGhlc2UgYWxvbmVcblx0ICAgIFNpZ25lci5wcm90b3R5cGUuX2NoZWNrUHJvdmlkZXIgPSBmdW5jdGlvbiAob3BlcmF0aW9uKSB7XG5cdCAgICAgICAgaWYgKCF0aGlzLnByb3ZpZGVyKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwibWlzc2luZyBwcm92aWRlclwiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcblx0ICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogKG9wZXJhdGlvbiB8fCBcIl9jaGVja1Byb3ZpZGVyXCIpXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICBTaWduZXIuaXNTaWduZXIgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX2lzU2lnbmVyKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gU2lnbmVyO1xuXHR9KCkpO1xuXHRleHBvcnRzLlNpZ25lciA9IFNpZ25lcjtcblx0dmFyIFZvaWRTaWduZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoVm9pZFNpZ25lciwgX3N1cGVyKTtcblx0ICAgIGZ1bmN0aW9uIFZvaWRTaWduZXIoYWRkcmVzcywgcHJvdmlkZXIpIHtcblx0ICAgICAgICB2YXIgX25ld1RhcmdldCA9IHRoaXMuY29uc3RydWN0b3I7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICBsb2dnZXIuY2hlY2tOZXcoX25ld1RhcmdldCwgVm9pZFNpZ25lcik7XG5cdCAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KF90aGlzLCBcImFkZHJlc3NcIiwgYWRkcmVzcyk7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkoX3RoaXMsIFwicHJvdmlkZXJcIiwgcHJvdmlkZXIgfHwgbnVsbCk7XG5cdCAgICAgICAgcmV0dXJuIF90aGlzO1xuXHQgICAgfVxuXHQgICAgVm9pZFNpZ25lci5wcm90b3R5cGUuZ2V0QWRkcmVzcyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuYWRkcmVzcyk7XG5cdCAgICB9O1xuXHQgICAgVm9pZFNpZ25lci5wcm90b3R5cGUuX2ZhaWwgPSBmdW5jdGlvbiAobWVzc2FnZSwgb3BlcmF0aW9uKSB7XG5cdCAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihtZXNzYWdlLCBsaWIuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHsgb3BlcmF0aW9uOiBvcGVyYXRpb24gfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgVm9pZFNpZ25lci5wcm90b3R5cGUuc2lnbk1lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9mYWlsKFwiVm9pZFNpZ25lciBjYW5ub3Qgc2lnbiBtZXNzYWdlc1wiLCBcInNpZ25NZXNzYWdlXCIpO1xuXHQgICAgfTtcblx0ICAgIFZvaWRTaWduZXIucHJvdG90eXBlLnNpZ25UcmFuc2FjdGlvbiA9IGZ1bmN0aW9uICh0cmFuc2FjdGlvbikge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9mYWlsKFwiVm9pZFNpZ25lciBjYW5ub3Qgc2lnbiB0cmFuc2FjdGlvbnNcIiwgXCJzaWduVHJhbnNhY3Rpb25cIik7XG5cdCAgICB9O1xuXHQgICAgVm9pZFNpZ25lci5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uIChwcm92aWRlcikge1xuXHQgICAgICAgIHJldHVybiBuZXcgVm9pZFNpZ25lcih0aGlzLmFkZHJlc3MsIHByb3ZpZGVyKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVm9pZFNpZ25lcjtcblx0fShTaWduZXIpKTtcblx0ZXhwb3J0cy5Wb2lkU2lnbmVyID0gVm9pZFNpZ25lcjtcblxuXHR9KTtcblxuXHR2YXIgaW5kZXgkYyA9IHVud3JhcEV4cG9ydHMobGliJGMpO1xuXHR2YXIgbGliXzEkYyA9IGxpYiRjLlNpZ25lcjtcblx0dmFyIGxpYl8yJGIgPSBsaWIkYy5Wb2lkU2lnbmVyO1xuXG5cdHZhciBfdmVyc2lvbiRtID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLnZlcnNpb24gPSBcImNvbnRyYWN0cy81LjAuMlwiO1xuXG5cdH0pO1xuXG5cdHZhciBfdmVyc2lvbiRuID0gdW53cmFwRXhwb3J0cyhfdmVyc2lvbiRtKTtcblx0dmFyIF92ZXJzaW9uXzEkYiA9IF92ZXJzaW9uJG0udmVyc2lvbjtcblxuXHR2YXIgbGliJGQgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19leHRlbmRzID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG5cdCAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcblx0ICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG5cdCAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cblx0ICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG5cdCAgICB9O1xuXHR9KSgpO1xuXHR2YXIgX19hd2FpdGVyID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuXHQgICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG5cdCAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG5cdCAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG5cdCAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cblx0ICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG5cdCAgICB9KTtcblx0fTtcblx0dmFyIF9fZ2VuZXJhdG9yID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuXHQgICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcblx0ICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuXHQgICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG5cdCAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG5cdCAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuXHQgICAgICAgIHdoaWxlIChfKSB0cnkge1xuXHQgICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG5cdCAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcblx0ICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuXHQgICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuXHQgICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcblx0ICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG5cdCAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG5cdCAgICB9XG5cdH07XG5cdHZhciBfX3NwcmVhZEFycmF5cyA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX3NwcmVhZEFycmF5cykgfHwgZnVuY3Rpb24gKCkge1xuXHQgICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XG5cdCAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXG5cdCAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXG5cdCAgICAgICAgICAgIHJba10gPSBhW2pdO1xuXHQgICAgcmV0dXJuIHI7XG5cdH07XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXG5cblxuXG5cblx0Ly9pbXBvcnQgeyBBZGRyZXNzWmVybyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9jb25zdGFudHNcIjtcblxuXHQvLyBAVE9PRCByZW1vdmUgZGVwZW5kZW5jZXMgdHJhbnNhY3Rpb25zXG5cblxuXHR2YXIgbG9nZ2VyID0gbmV3IGxpYi5Mb2dnZXIoX3ZlcnNpb24kbS52ZXJzaW9uKTtcblx0O1xuXHQ7XG5cdC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0dmFyIGFsbG93ZWRUcmFuc2FjdGlvbktleXMgPSB7XG5cdCAgICBjaGFpbklkOiB0cnVlLCBkYXRhOiB0cnVlLCBmcm9tOiB0cnVlLCBnYXNMaW1pdDogdHJ1ZSwgZ2FzUHJpY2U6IHRydWUsIG5vbmNlOiB0cnVlLCB0bzogdHJ1ZSwgdmFsdWU6IHRydWVcblx0fTtcblx0ZnVuY3Rpb24gcmVzb2x2ZU5hbWUocmVzb2x2ZXIsIG5hbWVPclByb21pc2UpIHtcblx0ICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgbmFtZTtcblx0ICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgbmFtZU9yUHJvbWlzZV07XG5cdCAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgbmFtZSA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAvLyBJZiBpdCBpcyBhbHJlYWR5IGFuIGFkZHJlc3MsIGp1c3QgdXNlIGl0IChhZnRlciBhZGRpbmcgY2hlY2tzdW0pXG5cdCAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGxpYiQ2LmdldEFkZHJlc3MobmFtZSldO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghcmVzb2x2ZXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJhIHByb3ZpZGVyIG9yIHNpZ25lciBpcyBuZWVkZWQgdG8gcmVzb2x2ZSBFTlMgbmFtZXNcIiwgbGliLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwicmVzb2x2ZU5hbWVcIlxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgcmVzb2x2ZXIucmVzb2x2ZU5hbWUobmFtZSldO1xuXHQgICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgfSk7XG5cdH1cblx0Ly8gUmVjdXJzaXZlbHkgcmVwbGFjZXMgRU5TIG5hbWVzIHdpdGggcHJvbWlzZXMgdG8gcmVzb2x2ZSB0aGUgbmFtZSBhbmQgcmVzb2x2ZXMgYWxsIHByb3BlcnRpZXNcblx0ZnVuY3Rpb24gcmVzb2x2ZUFkZHJlc3NlcyhyZXNvbHZlciwgdmFsdWUsIHBhcmFtVHlwZSkge1xuXHQgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyYW1UeXBlKSkge1xuXHQgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwYXJhbVR5cGUubWFwKGZ1bmN0aW9uIChwYXJhbVR5cGUsIGluZGV4KSB7XG5cdCAgICAgICAgICAgIHJldHVybiByZXNvbHZlQWRkcmVzc2VzKHJlc29sdmVyLCAoKEFycmF5LmlzQXJyYXkodmFsdWUpKSA/IHZhbHVlW2luZGV4XSA6IHZhbHVlW3BhcmFtVHlwZS5uYW1lXSksIHBhcmFtVHlwZSk7XG5cdCAgICAgICAgfSkpO1xuXHQgICAgfVxuXHQgICAgaWYgKHBhcmFtVHlwZS50eXBlID09PSBcImFkZHJlc3NcIikge1xuXHQgICAgICAgIHJldHVybiByZXNvbHZlTmFtZShyZXNvbHZlciwgdmFsdWUpO1xuXHQgICAgfVxuXHQgICAgaWYgKHBhcmFtVHlwZS50eXBlID09PSBcInR1cGxlXCIpIHtcblx0ICAgICAgICByZXR1cm4gcmVzb2x2ZUFkZHJlc3NlcyhyZXNvbHZlciwgdmFsdWUsIHBhcmFtVHlwZS5jb21wb25lbnRzKTtcblx0ICAgIH1cblx0ICAgIGlmIChwYXJhbVR5cGUuYmFzZVR5cGUgPT09IFwiYXJyYXlcIikge1xuXHQgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB2YWx1ZSBmb3IgYXJyYXlcIik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBQcm9taXNlLmFsbCh2YWx1ZS5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHJlc29sdmVBZGRyZXNzZXMocmVzb2x2ZXIsIHYsIHBhcmFtVHlwZS5hcnJheUNoaWxkcmVuKTsgfSkpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSk7XG5cdH1cblx0ZnVuY3Rpb24gcG9wdWxhdGVUcmFuc2FjdGlvbihjb250cmFjdCwgZnJhZ21lbnQsIGFyZ3MpIHtcblx0ICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3ZlcnJpZGVzLCByZXNvbHZlZCwgdHgsIHJvLCByb1ZhbHVlLCBsZWZ0b3ZlcnM7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMDpcblx0ICAgICAgICAgICAgICAgICAgICBvdmVycmlkZXMgPSB7fTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IGZyYWdtZW50LmlucHV0cy5sZW5ndGggKyAxICYmIHR5cGVvZiAoYXJnc1thcmdzLmxlbmd0aCAtIDFdKSA9PT0gXCJvYmplY3RcIikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBvdmVycmlkZXMgPSBsaWIkMy5zaGFsbG93Q29weShhcmdzLnBvcCgpKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBwYXJhbWV0ZXIgY291bnQgbWF0Y2hlc1xuXHQgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5jaGVja0FyZ3VtZW50Q291bnQoYXJncy5sZW5ndGgsIGZyYWdtZW50LmlucHV0cy5sZW5ndGgsIFwicGFzc2VkIHRvIGNvbnRyYWN0XCIpO1xuXHQgICAgICAgICAgICAgICAgICAgIC8vIFBvcHVsYXRlIFwiZnJvbVwiIG92ZXJyaWRlIChhbGxvdyBwcm9taXNlcylcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoY29udHJhY3Quc2lnbmVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdmVycmlkZXMuZnJvbSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29udHJhY3RzIHdpdGggYSBTaWduZXIgYXJlIGZyb20gdGhlIFNpZ25lcidzIGZyYW1lLW9mLXJlZmVyZW5jZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1dCB3ZSBhbGxvdyBvdmVycmlkaW5nIFwiZnJvbVwiIGlmIGl0IG1hdGNoZXMgdGhlIHNpZ25lclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcnJpZGVzLmZyb20gPSBsaWIkMy5yZXNvbHZlUHJvcGVydGllcyh7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcnJpZGU6IHJlc29sdmVOYW1lKGNvbnRyYWN0LnNpZ25lciwgb3ZlcnJpZGVzLmZyb20pLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25lcjogY29udHJhY3Quc2lnbmVyLmdldEFkZHJlc3MoKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoY2hlY2spIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaWIkNi5nZXRBZGRyZXNzKGNoZWNrLnNpZ25lcikgIT09IGNoZWNrLm92ZXJyaWRlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIkNvbnRyYWN0IHdpdGggYSBTaWduZXIgY2Fubm90IG92ZXJyaWRlIGZyb21cIiwgbGliLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcIm92ZXJyaWRlcy5mcm9tXCJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBjaGVjay5vdmVycmlkZV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTsgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVycmlkZXMuZnJvbSA9IGNvbnRyYWN0LnNpZ25lci5nZXRBZGRyZXNzKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob3ZlcnJpZGVzLmZyb20pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcnJpZGVzLmZyb20gPSByZXNvbHZlTmFtZShjb250cmFjdC5wcm92aWRlciwgb3ZlcnJpZGVzLmZyb20pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvL30gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnRyYWN0cyB3aXRob3V0IGEgc2lnbmVyIGNhbiBvdmVycmlkZSBcImZyb21cIiwgYW5kIGlmXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVuc3BlY2lmaWVkIHRoZSB6ZXJvIGFkZHJlc3MgaXMgdXNlZFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvL292ZXJyaWRlcy5mcm9tID0gQWRkcmVzc1plcm87XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGxpYiQzLnJlc29sdmVQcm9wZXJ0aWVzKHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IHJlc29sdmVBZGRyZXNzZXMoY29udHJhY3Quc2lnbmVyIHx8IGNvbnRyYWN0LnByb3ZpZGVyLCBhcmdzLCBmcmFnbWVudC5pbnB1dHMpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogY29udHJhY3QucmVzb2x2ZWRBZGRyZXNzLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcnJpZGVzOiAobGliJDMucmVzb2x2ZVByb3BlcnRpZXMob3ZlcnJpZGVzKSB8fCB7fSlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuXHQgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgIHJlc29sdmVkID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIHR4ID0ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBjb250cmFjdC5pbnRlcmZhY2UuZW5jb2RlRnVuY3Rpb25EYXRhKGZyYWdtZW50LCByZXNvbHZlZC5hcmdzKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdG86IHJlc29sdmVkLmFkZHJlc3Ncblx0ICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgIHJvID0gcmVzb2x2ZWQub3ZlcnJpZGVzO1xuXHQgICAgICAgICAgICAgICAgICAgIC8vIFBvcHVsYXRlIHNpbXBsZSBvdmVycmlkZXNcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocm8ubm9uY2UgIT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0eC5ub25jZSA9IGxpYiQyLkJpZ051bWJlci5mcm9tKHJvLm5vbmNlKS50b051bWJlcigpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAocm8uZ2FzTGltaXQgIT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0eC5nYXNMaW1pdCA9IGxpYiQyLkJpZ051bWJlci5mcm9tKHJvLmdhc0xpbWl0KTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHJvLmdhc1ByaWNlICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHguZ2FzUHJpY2UgPSBsaWIkMi5CaWdOdW1iZXIuZnJvbShyby5nYXNQcmljZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChyby5mcm9tICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHguZnJvbSA9IHJvLmZyb207XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIHdhcyBubyBcImdhc0xpbWl0XCIgb3ZlcnJpZGUsIGJ1dCB0aGUgQUJJIHNwZWNpZmllcyBhIGRlZmF1bHQsIHVzZSBpdFxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0eC5nYXNMaW1pdCA9PSBudWxsICYmIGZyYWdtZW50LmdhcyAhPSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR4Lmdhc0xpbWl0ID0gbGliJDIuQmlnTnVtYmVyLmZyb20oZnJhZ21lbnQuZ2FzKS5hZGQoMjEwMDApO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAvLyBQb3B1bGF0ZSBcInZhbHVlXCIgb3ZlcnJpZGVcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocm8udmFsdWUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcm9WYWx1ZSA9IGxpYiQyLkJpZ051bWJlci5mcm9tKHJvLnZhbHVlKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyb1ZhbHVlLmlzWmVybygpICYmICFmcmFnbWVudC5wYXlhYmxlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIm5vbi1wYXlhYmxlIG1ldGhvZCBjYW5ub3Qgb3ZlcnJpZGUgdmFsdWVcIiwgbGliLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcIm92ZXJyaWRlcy52YWx1ZVwiLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBvdmVycmlkZXMudmFsdWVcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR4LnZhbHVlID0gcm9WYWx1ZTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gUmVtdm9lIHRoZSBvdmVycmlkZXNcblx0ICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3ZlcnJpZGVzLm5vbmNlO1xuXHQgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvdmVycmlkZXMuZ2FzTGltaXQ7XG5cdCAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG92ZXJyaWRlcy5nYXNQcmljZTtcblx0ICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3ZlcnJpZGVzLmZyb207XG5cdCAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG92ZXJyaWRlcy52YWx1ZTtcblx0ICAgICAgICAgICAgICAgICAgICBsZWZ0b3ZlcnMgPSBPYmplY3Qua2V5cyhvdmVycmlkZXMpLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7IHJldHVybiAob3ZlcnJpZGVzW2tleV0gIT0gbnVsbCk7IH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0b3ZlcnMubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IG92ZXJyaWRlIFwiICsgbGVmdG92ZXJzLm1hcChmdW5jdGlvbiAobCkgeyByZXR1cm4gSlNPTi5zdHJpbmdpZnkobCk7IH0pLmpvaW4oXCIsXCIpLCBsaWIuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJvdmVycmlkZXNcIixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJyaWRlczogbGVmdG92ZXJzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdHhdO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdCAgICB9KTtcblx0fVxuXHRmdW5jdGlvbiBidWlsZFBvcHVsYXRlKGNvbnRyYWN0LCBmcmFnbWVudCkge1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgYXJncyA9IFtdO1xuXHQgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG5cdCAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcG9wdWxhdGVUcmFuc2FjdGlvbihjb250cmFjdCwgZnJhZ21lbnQsIGFyZ3MpXTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHR9XG5cdGZ1bmN0aW9uIGJ1aWxkRXN0aW1hdGUoY29udHJhY3QsIGZyYWdtZW50KSB7XG5cdCAgICB2YXIgc2lnbmVyT3JQcm92aWRlciA9IChjb250cmFjdC5zaWduZXIgfHwgY29udHJhY3QucHJvdmlkZXIpO1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgYXJncyA9IFtdO1xuXHQgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG5cdCAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgdHg7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2lnbmVyT3JQcm92aWRlcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJlc3RpbWF0ZSByZXF1aXJlIGEgcHJvdmlkZXIgb3Igc2lnbmVyXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJlc3RpbWF0ZUdhc1wiXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBwb3B1bGF0ZVRyYW5zYWN0aW9uKGNvbnRyYWN0LCBmcmFnbWVudCwgYXJncyldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHggPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHNpZ25lck9yUHJvdmlkZXIuZXN0aW1hdGVHYXModHgpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdH1cblx0ZnVuY3Rpb24gYnVpbGRDYWxsKGNvbnRyYWN0LCBmcmFnbWVudCwgY29sbGFwc2VTaW1wbGUpIHtcblx0ICAgIHZhciBzaWduZXJPclByb3ZpZGVyID0gKGNvbnRyYWN0LnNpZ25lciB8fCBjb250cmFjdC5wcm92aWRlcik7XG5cdCAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBhcmdzID0gW107XG5cdCAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcblx0ICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBibG9ja1RhZywgb3ZlcnJpZGVzLCB0eCwgcmVzdWx0LCB2YWx1ZTtcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tUYWcgPSB1bmRlZmluZWQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGFyZ3MubGVuZ3RoID09PSBmcmFnbWVudC5pbnB1dHMubGVuZ3RoICsgMSAmJiB0eXBlb2YgKGFyZ3NbYXJncy5sZW5ndGggLSAxXSkgPT09IFwib2JqZWN0XCIpKSByZXR1cm4gWzMgLypicmVhayovLCAzXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcnJpZGVzID0gbGliJDMuc2hhbGxvd0NvcHkoYXJncy5wb3AoKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG92ZXJyaWRlcy5ibG9ja1RhZyAhPSBudWxsKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIG92ZXJyaWRlcy5ibG9ja1RhZ107XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBibG9ja1RhZyA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAyO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG92ZXJyaWRlcy5ibG9ja1RhZztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKG92ZXJyaWRlcyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMztcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGNvbnRyYWN0LmRlcGxveVRyYW5zYWN0aW9uICE9IG51bGwpKSByZXR1cm4gWzMgLypicmVhayovLCA1XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgY29udHJhY3QuX2RlcGxveWVkKGJsb2NrVGFnKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gNTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbNCAvKnlpZWxkKi8sIHBvcHVsYXRlVHJhbnNhY3Rpb24oY29udHJhY3QsIGZyYWdtZW50LCBhcmdzKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0eCA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgc2lnbmVyT3JQcm92aWRlci5jYWxsKHR4LCBibG9ja1RhZyldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBjb250cmFjdC5pbnRlcmZhY2UuZGVjb2RlRnVuY3Rpb25SZXN1bHQoZnJhZ21lbnQsIHJlc3VsdCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29sbGFwc2VTaW1wbGUgJiYgZnJhZ21lbnQub3V0cHV0cy5sZW5ndGggPT09IDEpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlWzBdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHZhbHVlXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID09PSBsaWIuTG9nZ2VyLmVycm9ycy5DQUxMX0VYQ0VQVElPTikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLmFkZHJlc3MgPSBjb250cmFjdC5hZGRyZXNzO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLmFyZ3MgPSBhcmdzO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLnRyYW5zYWN0aW9uID0gdHg7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0fVxuXHRmdW5jdGlvbiBidWlsZFNlbmQoY29udHJhY3QsIGZyYWdtZW50KSB7XG5cdCAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBhcmdzID0gW107XG5cdCAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcblx0ICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciB0eFJlcXVlc3QsIHR4LCB3YWl0O1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnRyYWN0LnNpZ25lcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJzZW5kaW5nIGEgdHJhbnNhY3Rpb24gcmVxdWlyZXMgYSBzaWduZXJcIiwgbGliLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInNlbmRUcmFuc2FjdGlvblwiXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShjb250cmFjdC5kZXBsb3lUcmFuc2FjdGlvbiAhPSBudWxsKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGNvbnRyYWN0Ll9kZXBsb3llZCgpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAyO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFs0IC8qeWllbGQqLywgcG9wdWxhdGVUcmFuc2FjdGlvbihjb250cmFjdCwgZnJhZ21lbnQsIGFyZ3MpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR4UmVxdWVzdCA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgY29udHJhY3Quc2lnbmVyLnNlbmRUcmFuc2FjdGlvbih0eFJlcXVlc3QpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR4ID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB3YWl0ID0gdHgud2FpdC5iaW5kKHR4KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHgud2FpdCA9IGZ1bmN0aW9uIChjb25maXJtYXRpb25zKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2FpdChjb25maXJtYXRpb25zKS50aGVuKGZ1bmN0aW9uIChyZWNlaXB0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWlwdC5ldmVudHMgPSByZWNlaXB0LmxvZ3MubWFwKGZ1bmN0aW9uIChsb2cpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV2ZW50ID0gbGliJDMuZGVlcENvcHkobG9nKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnNlZCA9IG51bGw7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWQgPSBjb250cmFjdC5pbnRlcmZhY2UucGFyc2VMb2cobG9nKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkgeyB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1Y2Nlc3NmdWxseSBwYXJzZWQgdGhlIGV2ZW50IGxvZzsgaW5jbHVkZSBpdFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5hcmdzID0gcGFyc2VkLmFyZ3M7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5kZWNvZGUgPSBmdW5jdGlvbiAoZGF0YSwgdG9waWNzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRyYWN0LmludGVyZmFjZS5kZWNvZGVFdmVudExvZyhwYXJzZWQuZXZlbnRGcmFnbWVudCwgZGF0YSwgdG9waWNzKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5ldmVudCA9IHBhcnNlZC5uYW1lO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuZXZlbnRTaWduYXR1cmUgPSBwYXJzZWQuc2lnbmF0dXJlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZWZ1bCBvcGVyYXRpb25zXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29udHJhY3QucHJvdmlkZXI7IH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmdldEJsb2NrID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRyYWN0LnByb3ZpZGVyLmdldEJsb2NrKHJlY2VpcHQuYmxvY2tIYXNoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuZ2V0VHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udHJhY3QucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb24ocmVjZWlwdC50cmFuc2FjdGlvbkhhc2gpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5nZXRUcmFuc2FjdGlvblJlY2VpcHQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlY2VpcHQpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlY2VpcHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHR4XTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHR9XG5cdGZ1bmN0aW9uIGJ1aWxkRGVmYXVsdChjb250cmFjdCwgZnJhZ21lbnQsIGNvbGxhcHNlU2ltcGxlKSB7XG5cdCAgICBpZiAoZnJhZ21lbnQuY29uc3RhbnQpIHtcblx0ICAgICAgICByZXR1cm4gYnVpbGRDYWxsKGNvbnRyYWN0LCBmcmFnbWVudCwgY29sbGFwc2VTaW1wbGUpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGJ1aWxkU2VuZChjb250cmFjdCwgZnJhZ21lbnQpO1xuXHR9XG5cdGZ1bmN0aW9uIGdldEV2ZW50VGFnKGZpbHRlcikge1xuXHQgICAgaWYgKGZpbHRlci5hZGRyZXNzICYmIChmaWx0ZXIudG9waWNzID09IG51bGwgfHwgZmlsdGVyLnRvcGljcy5sZW5ndGggPT09IDApKSB7XG5cdCAgICAgICAgcmV0dXJuIFwiKlwiO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIChmaWx0ZXIuYWRkcmVzcyB8fCBcIipcIikgKyBcIkBcIiArIChmaWx0ZXIudG9waWNzID8gZmlsdGVyLnRvcGljcy5tYXAoZnVuY3Rpb24gKHRvcGljKSB7XG5cdCAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodG9waWMpKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0b3BpYy5qb2luKFwifFwiKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRvcGljO1xuXHQgICAgfSkuam9pbihcIjpcIikgOiBcIlwiKTtcblx0fVxuXHR2YXIgUnVubmluZ0V2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gUnVubmluZ0V2ZW50KHRhZywgZmlsdGVyKSB7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJ0YWdcIiwgdGFnKTtcblx0ICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcImZpbHRlclwiLCBmaWx0ZXIpO1xuXHQgICAgICAgIHRoaXMuX2xpc3RlbmVycyA9IFtdO1xuXHQgICAgfVxuXHQgICAgUnVubmluZ0V2ZW50LnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIChsaXN0ZW5lciwgb25jZSkge1xuXHQgICAgICAgIHRoaXMuX2xpc3RlbmVycy5wdXNoKHsgbGlzdGVuZXI6IGxpc3RlbmVyLCBvbmNlOiBvbmNlIH0pO1xuXHQgICAgfTtcblx0ICAgIFJ1bm5pbmdFdmVudC5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiAobGlzdGVuZXIpIHtcblx0ICAgICAgICB2YXIgZG9uZSA9IGZhbHNlO1xuXHQgICAgICAgIHRoaXMuX2xpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcblx0ICAgICAgICAgICAgaWYgKGRvbmUgfHwgaXRlbS5saXN0ZW5lciAhPT0gbGlzdGVuZXIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuXHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgUnVubmluZ0V2ZW50LnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gW107XG5cdCAgICB9O1xuXHQgICAgUnVubmluZ0V2ZW50LnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX2xpc3RlbmVycy5tYXAoZnVuY3Rpb24gKGkpIHsgcmV0dXJuIGkubGlzdGVuZXI7IH0pO1xuXHQgICAgfTtcblx0ICAgIFJ1bm5pbmdFdmVudC5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fbGlzdGVuZXJzLmxlbmd0aDtcblx0ICAgIH07XG5cdCAgICBSdW5uaW5nRXZlbnQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIChhcmdzKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICB2YXIgbGlzdGVuZXJDb3VudCA9IHRoaXMubGlzdGVuZXJDb3VudCgpO1xuXHQgICAgICAgIHRoaXMuX2xpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcblx0ICAgICAgICAgICAgdmFyIGFyZ3NDb3B5ID0gYXJncy5zbGljZSgpO1xuXHQgICAgICAgICAgICAvLyBDYWxsIHRoZSBjYWxsYmFjayBpbiB0aGUgbmV4dCBldmVudCBsb29wXG5cdCAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgaXRlbS5saXN0ZW5lci5hcHBseShfdGhpcywgYXJnc0NvcHkpO1xuXHQgICAgICAgICAgICB9LCAwKTtcblx0ICAgICAgICAgICAgLy8gUmVzY2hlZHVsZSBpdCBpZiBpdCBub3QgXCJvbmNlXCJcblx0ICAgICAgICAgICAgcmV0dXJuICEoaXRlbS5vbmNlKTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgICByZXR1cm4gbGlzdGVuZXJDb3VudDtcblx0ICAgIH07XG5cdCAgICBSdW5uaW5nRXZlbnQucHJvdG90eXBlLnByZXBhcmVFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgfTtcblx0ICAgIC8vIFJldHVybnMgdGhlIGFycmF5IHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIGFuIGVtaXRcblx0ICAgIFJ1bm5pbmdFdmVudC5wcm90b3R5cGUuZ2V0RW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgIHJldHVybiBbZXZlbnRdO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBSdW5uaW5nRXZlbnQ7XG5cdH0oKSk7XG5cdHZhciBFcnJvclJ1bm5pbmdFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0ICAgIF9fZXh0ZW5kcyhFcnJvclJ1bm5pbmdFdmVudCwgX3N1cGVyKTtcblx0ICAgIGZ1bmN0aW9uIEVycm9yUnVubmluZ0V2ZW50KCkge1xuXHQgICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBcImVycm9yXCIsIG51bGwpIHx8IHRoaXM7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gRXJyb3JSdW5uaW5nRXZlbnQ7XG5cdH0oUnVubmluZ0V2ZW50KSk7XG5cdC8vIEBUT0RPIEZyYWdtZW50IHNob3VsZCBpbmhlcml0IFdpbGRjYXJkPyBhbmQganVzdCBvdmVycmlkZSBnZXRFbWl0P1xuXHQvLyAgICAgICBvciBoYXZlIGEgY29tbW9uIGFic3RyYWN0IHN1cGVyIGNsYXNzLCB3aXRoIGVub3VnaCBjb25zdHJ1Y3RvclxuXHQvLyAgICAgICBvcHRpb25zIHRvIGNvbmZpZ3VyZSBib3RoLlxuXHQvLyBBIEZyYWdtZW50IEV2ZW50IHdpbGwgcG9wdWxhdGUgYWxsIHRoZSBwcm9wZXJ0aWVzIHRoYXQgV2lsZGNhcmRcblx0Ly8gd2lsbCwgYW5kIGFkZGl0aW9hbmxseSBkZXJlZmVyZW5jZSB0aGUgYXJndW1lbnRzIHdoZW4gZW1pdHRpbmdcblx0dmFyIEZyYWdtZW50UnVubmluZ0V2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHQgICAgX19leHRlbmRzKEZyYWdtZW50UnVubmluZ0V2ZW50LCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gRnJhZ21lbnRSdW5uaW5nRXZlbnQoYWRkcmVzcywgY29udHJhY3RJbnRlcmZhY2UsIGZyYWdtZW50LCB0b3BpY3MpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIHZhciBmaWx0ZXIgPSB7XG5cdCAgICAgICAgICAgIGFkZHJlc3M6IGFkZHJlc3Ncblx0ICAgICAgICB9O1xuXHQgICAgICAgIHZhciB0b3BpYyA9IGNvbnRyYWN0SW50ZXJmYWNlLmdldEV2ZW50VG9waWMoZnJhZ21lbnQpO1xuXHQgICAgICAgIGlmICh0b3BpY3MpIHtcblx0ICAgICAgICAgICAgaWYgKHRvcGljICE9PSB0b3BpY3NbMF0pIHtcblx0ICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ0b3BpYyBtaXNtYXRjaFwiLCBcInRvcGljc1wiLCB0b3BpY3MpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGZpbHRlci50b3BpY3MgPSB0b3BpY3Muc2xpY2UoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIGZpbHRlci50b3BpY3MgPSBbdG9waWNdO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGdldEV2ZW50VGFnKGZpbHRlciksIGZpbHRlcikgfHwgdGhpcztcblx0ICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seShfdGhpcywgXCJhZGRyZXNzXCIsIGFkZHJlc3MpO1xuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KF90aGlzLCBcImludGVyZmFjZVwiLCBjb250cmFjdEludGVyZmFjZSk7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkoX3RoaXMsIFwiZnJhZ21lbnRcIiwgZnJhZ21lbnQpO1xuXHQgICAgICAgIHJldHVybiBfdGhpcztcblx0ICAgIH1cblx0ICAgIEZyYWdtZW50UnVubmluZ0V2ZW50LnByb3RvdHlwZS5wcmVwYXJlRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIF9zdXBlci5wcm90b3R5cGUucHJlcGFyZUV2ZW50LmNhbGwodGhpcywgZXZlbnQpO1xuXHQgICAgICAgIGV2ZW50LmV2ZW50ID0gdGhpcy5mcmFnbWVudC5uYW1lO1xuXHQgICAgICAgIGV2ZW50LmV2ZW50U2lnbmF0dXJlID0gdGhpcy5mcmFnbWVudC5mb3JtYXQoKTtcblx0ICAgICAgICBldmVudC5kZWNvZGUgPSBmdW5jdGlvbiAoZGF0YSwgdG9waWNzKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBfdGhpcy5pbnRlcmZhY2UuZGVjb2RlRXZlbnRMb2coX3RoaXMuZnJhZ21lbnQsIGRhdGEsIHRvcGljcyk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICBldmVudC5hcmdzID0gdGhpcy5pbnRlcmZhY2UuZGVjb2RlRXZlbnRMb2codGhpcy5mcmFnbWVudCwgZXZlbnQuZGF0YSwgZXZlbnQudG9waWNzKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG5cdCAgICAgICAgICAgIGV2ZW50LmFyZ3MgPSBudWxsO1xuXHQgICAgICAgICAgICBldmVudC5kZWNvZGVFcnJvciA9IGVycm9yO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICBGcmFnbWVudFJ1bm5pbmdFdmVudC5wcm90b3R5cGUuZ2V0RW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgIHZhciBlcnJvcnMgPSBsaWIkYS5jaGVja1Jlc3VsdEVycm9ycyhldmVudC5hcmdzKTtcblx0ICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xuXHQgICAgICAgICAgICB0aHJvdyBlcnJvcnNbMF0uZXJyb3I7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBhcmdzID0gKGV2ZW50LmFyZ3MgfHwgW10pLnNsaWNlKCk7XG5cdCAgICAgICAgYXJncy5wdXNoKGV2ZW50KTtcblx0ICAgICAgICByZXR1cm4gYXJncztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gRnJhZ21lbnRSdW5uaW5nRXZlbnQ7XG5cdH0oUnVubmluZ0V2ZW50KSk7XG5cdC8vIEEgV2lsZGFyZCBFdmVudCB3aWxsIGF0dGVtcHQgdG8gcG9wdWxhdGU6XG5cdC8vICAtIGV2ZW50ICAgICAgICAgICAgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IG5hbWVcblx0Ly8gIC0gZXZlbnRTaWduYXR1cmUgICBUaGUgZnVsbCBzaWduYXR1cmUgb2YgdGhlIGV2ZW50XG5cdC8vICAtIGRlY29kZSAgICAgICAgICAgQSBmdW5jdGlvbiB0byBkZWNvZGUgZGF0YSBhbmQgdG9waWNzXG5cdC8vICAtIGFyZ3MgICAgICAgICAgICAgVGhlIGRlY29kZWQgZGF0YSBhbmQgdG9waWNzXG5cdHZhciBXaWxkY2FyZFJ1bm5pbmdFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0ICAgIF9fZXh0ZW5kcyhXaWxkY2FyZFJ1bm5pbmdFdmVudCwgX3N1cGVyKTtcblx0ICAgIGZ1bmN0aW9uIFdpbGRjYXJkUnVubmluZ0V2ZW50KGFkZHJlc3MsIGNvbnRyYWN0SW50ZXJmYWNlKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgXCIqXCIsIHsgYWRkcmVzczogYWRkcmVzcyB9KSB8fCB0aGlzO1xuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KF90aGlzLCBcImFkZHJlc3NcIiwgYWRkcmVzcyk7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkoX3RoaXMsIFwiaW50ZXJmYWNlXCIsIGNvbnRyYWN0SW50ZXJmYWNlKTtcblx0ICAgICAgICByZXR1cm4gX3RoaXM7XG5cdCAgICB9XG5cdCAgICBXaWxkY2FyZFJ1bm5pbmdFdmVudC5wcm90b3R5cGUucHJlcGFyZUV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICBfc3VwZXIucHJvdG90eXBlLnByZXBhcmVFdmVudC5jYWxsKHRoaXMsIGV2ZW50KTtcblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICB2YXIgcGFyc2VkXzEgPSB0aGlzLmludGVyZmFjZS5wYXJzZUxvZyhldmVudCk7XG5cdCAgICAgICAgICAgIGV2ZW50LmV2ZW50ID0gcGFyc2VkXzEubmFtZTtcblx0ICAgICAgICAgICAgZXZlbnQuZXZlbnRTaWduYXR1cmUgPSBwYXJzZWRfMS5zaWduYXR1cmU7XG5cdCAgICAgICAgICAgIGV2ZW50LmRlY29kZSA9IGZ1bmN0aW9uIChkYXRhLCB0b3BpY3MpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5pbnRlcmZhY2UuZGVjb2RlRXZlbnRMb2cocGFyc2VkXzEuZXZlbnRGcmFnbWVudCwgZGF0YSwgdG9waWNzKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgZXZlbnQuYXJncyA9IHBhcnNlZF8xLmFyZ3M7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgICAgICAvLyBObyBtYXRjaGluZyBldmVudFxuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICByZXR1cm4gV2lsZGNhcmRSdW5uaW5nRXZlbnQ7XG5cdH0oUnVubmluZ0V2ZW50KSk7XG5cdHZhciBDb250cmFjdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIENvbnRyYWN0KGFkZHJlc3NPck5hbWUsIGNvbnRyYWN0SW50ZXJmYWNlLCBzaWduZXJPclByb3ZpZGVyKSB7XG5cdCAgICAgICAgdmFyIF9uZXdUYXJnZXQgPSB0aGlzLmNvbnN0cnVjdG9yO1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgbG9nZ2VyLmNoZWNrTmV3KF9uZXdUYXJnZXQsIENvbnRyYWN0KTtcblx0ICAgICAgICAvLyBAVE9ETzogTWF5YmUgc3RpbGwgY2hlY2sgdGhlIGFkZHJlc3NPck5hbWUgbG9va3MgbGlrZSBhIHZhbGlkIGFkZHJlc3Mgb3IgbmFtZT9cblx0ICAgICAgICAvL2FkZHJlc3MgPSBnZXRBZGRyZXNzKGFkZHJlc3MpO1xuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KHRoaXMsIFwiaW50ZXJmYWNlXCIsIGxpYiQzLmdldFN0YXRpYygoX25ld1RhcmdldCksIFwiZ2V0SW50ZXJmYWNlXCIpKGNvbnRyYWN0SW50ZXJmYWNlKSk7XG5cdCAgICAgICAgaWYgKHNpZ25lck9yUHJvdmlkZXIgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcInByb3ZpZGVyXCIsIG51bGwpO1xuXHQgICAgICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcInNpZ25lclwiLCBudWxsKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAobGliJGMuU2lnbmVyLmlzU2lnbmVyKHNpZ25lck9yUHJvdmlkZXIpKSB7XG5cdCAgICAgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KHRoaXMsIFwicHJvdmlkZXJcIiwgc2lnbmVyT3JQcm92aWRlci5wcm92aWRlciB8fCBudWxsKTtcblx0ICAgICAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJzaWduZXJcIiwgc2lnbmVyT3JQcm92aWRlcik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2UgaWYgKGxpYiRiLlByb3ZpZGVyLmlzUHJvdmlkZXIoc2lnbmVyT3JQcm92aWRlcikpIHtcblx0ICAgICAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJwcm92aWRlclwiLCBzaWduZXJPclByb3ZpZGVyKTtcblx0ICAgICAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJzaWduZXJcIiwgbnVsbCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBzaWduZXIgb3IgcHJvdmlkZXJcIiwgXCJzaWduZXJPclByb3ZpZGVyXCIsIHNpZ25lck9yUHJvdmlkZXIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcImNhbGxTdGF0aWNcIiwge30pO1xuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KHRoaXMsIFwiZXN0aW1hdGVHYXNcIiwge30pO1xuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KHRoaXMsIFwiZnVuY3Rpb25zXCIsIHt9KTtcblx0ICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcInBvcHVsYXRlVHJhbnNhY3Rpb25cIiwge30pO1xuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KHRoaXMsIFwiZmlsdGVyc1wiLCB7fSk7XG5cdCAgICAgICAge1xuXHQgICAgICAgICAgICB2YXIgdW5pcXVlRmlsdGVyc18xID0ge307XG5cdCAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuaW50ZXJmYWNlLmV2ZW50cykuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnRTaWduYXR1cmUpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBldmVudCA9IF90aGlzLmludGVyZmFjZS5ldmVudHNbZXZlbnRTaWduYXR1cmVdO1xuXHQgICAgICAgICAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkoX3RoaXMuZmlsdGVycywgZXZlbnRTaWduYXR1cmUsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogX3RoaXMuYWRkcmVzcyxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdG9waWNzOiBfdGhpcy5pbnRlcmZhY2UuZW5jb2RlRmlsdGVyVG9waWNzKGV2ZW50LCBhcmdzKVxuXHQgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIGlmICghdW5pcXVlRmlsdGVyc18xW2V2ZW50Lm5hbWVdKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdW5pcXVlRmlsdGVyc18xW2V2ZW50Lm5hbWVdID0gW107XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB1bmlxdWVGaWx0ZXJzXzFbZXZlbnQubmFtZV0ucHVzaChldmVudFNpZ25hdHVyZSk7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICBPYmplY3Qua2V5cyh1bmlxdWVGaWx0ZXJzXzEpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBmaWx0ZXJzID0gdW5pcXVlRmlsdGVyc18xW25hbWVdO1xuXHQgICAgICAgICAgICAgICAgaWYgKGZpbHRlcnMubGVuZ3RoID09PSAxKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkoX3RoaXMuZmlsdGVycywgbmFtZSwgX3RoaXMuZmlsdGVyc1tmaWx0ZXJzWzBdXSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2FybihcIkR1cGxpY2F0ZSBkZWZpbml0aW9uIG9mIFwiICsgbmFtZSArIFwiIChcIiArIGZpbHRlcnMuam9pbihcIiwgXCIpICsgXCIpXCIpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfcnVubmluZ0V2ZW50c1wiLCB7fSk7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfd3JhcHBlZEVtaXRzXCIsIHt9KTtcblx0ICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcImFkZHJlc3NcIiwgYWRkcmVzc09yTmFtZSk7XG5cdCAgICAgICAgaWYgKHRoaXMucHJvdmlkZXIpIHtcblx0ICAgICAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJyZXNvbHZlZEFkZHJlc3NcIiwgdGhpcy5wcm92aWRlci5yZXNvbHZlTmFtZShhZGRyZXNzT3JOYW1lKS50aGVuKGZ1bmN0aW9uIChhZGRyZXNzKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoYWRkcmVzcyA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibmFtZSBub3QgZm91bmRcIik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gYWRkcmVzcztcblx0ICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkVSUk9SOiBDYW5ub3QgZmluZCBDb250cmFjdCAtIFwiICsgYWRkcmVzc09yTmFtZSk7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcblx0ICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KHRoaXMsIFwicmVzb2x2ZWRBZGRyZXNzXCIsIFByb21pc2UucmVzb2x2ZShsaWIkNi5nZXRBZGRyZXNzKGFkZHJlc3NPck5hbWUpKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBXaXRob3V0IGEgcHJvdmlkZXIsIHdlIGNhbm5vdCB1c2UgRU5TIG5hbWVzXG5cdCAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInByb3ZpZGVyIGlzIHJlcXVpcmVkIHRvIHVzZSBFTlMgbmFtZSBhcyBjb250cmFjdCBhZGRyZXNzXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuXHQgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJuZXcgQ29udHJhY3RcIlxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHVuaXF1ZU5hbWVzID0ge307XG5cdCAgICAgICAgdmFyIHVuaXF1ZVNpZ25hdHVyZXMgPSB7fTtcblx0ICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmludGVyZmFjZS5mdW5jdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKHNpZ25hdHVyZSkge1xuXHQgICAgICAgICAgICB2YXIgZnJhZ21lbnQgPSBfdGhpcy5pbnRlcmZhY2UuZnVuY3Rpb25zW3NpZ25hdHVyZV07XG5cdCAgICAgICAgICAgIC8vIENoZWNrIHRoYXQgdGhlIHNpZ25hdHVyZSBpcyB1bmlxdWU7IGlmIG5vdCB0aGUgQUJJIGdlbmVyYXRpb24gaGFzXG5cdCAgICAgICAgICAgIC8vIG5vdCBiZWVuIGNsZWFuZWQgb3IgbWF5IGJlIGluY29ycmVjdGx5IGdlbmVyYXRlZFxuXHQgICAgICAgICAgICBpZiAodW5pcXVlU2lnbmF0dXJlc1tzaWduYXR1cmVdKSB7XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIud2FybihcIkR1cGxpY2F0ZSBBQkkgZW50cnkgZm9yIFwiICsgSlNPTi5zdHJpbmdpZnkobmFtZSkpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHVuaXF1ZVNpZ25hdHVyZXNbc2lnbmF0dXJlXSA9IHRydWU7XG5cdCAgICAgICAgICAgIC8vIFRyYWNrIHVuaXF1ZSBuYW1lczsgd2Ugb25seSBleHBvc2UgYmFyZSBuYW1lZCBmdW5jdGlvbnMgaWYgdGhleVxuXHQgICAgICAgICAgICAvLyBhcmUgYW1iaWd1b3VzXG5cdCAgICAgICAgICAgIHtcblx0ICAgICAgICAgICAgICAgIHZhciBuYW1lXzEgPSBmcmFnbWVudC5uYW1lO1xuXHQgICAgICAgICAgICAgICAgaWYgKCF1bmlxdWVOYW1lc1tuYW1lXzFdKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdW5pcXVlTmFtZXNbbmFtZV8xXSA9IFtdO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdW5pcXVlTmFtZXNbbmFtZV8xXS5wdXNoKHNpZ25hdHVyZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKF90aGlzW3NpZ25hdHVyZV0gPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkoX3RoaXMsIHNpZ25hdHVyZSwgYnVpbGREZWZhdWx0KF90aGlzLCBmcmFnbWVudCwgdHJ1ZSkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIC8vIFdlIGRvIG5vdCBjb2xsYXBzZSBzaW1wbGUgY2FsbHMgb24gdGhpcyBidWNrZXQsIHdoaWNoIGFsbG93c1xuXHQgICAgICAgICAgICAvLyBmcmFtZXdvcmtzIHRvIHNhZmVseSB1c2UgdGhpcyB3aXRob3V0IGludHJvc3BlY3Rpb24gYXMgd2VsbCBhc1xuXHQgICAgICAgICAgICAvLyBhbGxvd3MgZGVjb2RpbmcgZXJyb3IgcmVjb3ZlcnkuXG5cdCAgICAgICAgICAgIGlmIChfdGhpcy5mdW5jdGlvbnNbc2lnbmF0dXJlXSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seShfdGhpcy5mdW5jdGlvbnMsIHNpZ25hdHVyZSwgYnVpbGREZWZhdWx0KF90aGlzLCBmcmFnbWVudCwgZmFsc2UpKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAoX3RoaXMuY2FsbFN0YXRpY1tzaWduYXR1cmVdID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KF90aGlzLmNhbGxTdGF0aWMsIHNpZ25hdHVyZSwgYnVpbGRDYWxsKF90aGlzLCBmcmFnbWVudCwgdHJ1ZSkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmIChfdGhpcy5wb3B1bGF0ZVRyYW5zYWN0aW9uW3NpZ25hdHVyZV0gPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkoX3RoaXMucG9wdWxhdGVUcmFuc2FjdGlvbiwgc2lnbmF0dXJlLCBidWlsZFBvcHVsYXRlKF90aGlzLCBmcmFnbWVudCkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmIChfdGhpcy5lc3RpbWF0ZUdhc1tzaWduYXR1cmVdID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KF90aGlzLmVzdGltYXRlR2FzLCBzaWduYXR1cmUsIGJ1aWxkRXN0aW1hdGUoX3RoaXMsIGZyYWdtZW50KSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgICAgICBPYmplY3Qua2V5cyh1bmlxdWVOYW1lcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuXHQgICAgICAgICAgICAvLyBBbWJpZ3VvdXMgbmFtZXMgdG8gbm90IGdldCBhdHRhY2hlZCBhcyBiYXJlIG5hbWVzXG5cdCAgICAgICAgICAgIHZhciBzaWduYXR1cmVzID0gdW5pcXVlTmFtZXNbbmFtZV07XG5cdCAgICAgICAgICAgIGlmIChzaWduYXR1cmVzLmxlbmd0aCA+IDEpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgc2lnbmF0dXJlID0gc2lnbmF0dXJlc1swXTtcblx0ICAgICAgICAgICAgaWYgKF90aGlzW25hbWVdID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KF90aGlzLCBuYW1lLCBfdGhpc1tzaWduYXR1cmVdKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAoX3RoaXMuZnVuY3Rpb25zW25hbWVdID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KF90aGlzLmZ1bmN0aW9ucywgbmFtZSwgX3RoaXMuZnVuY3Rpb25zW3NpZ25hdHVyZV0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmIChfdGhpcy5jYWxsU3RhdGljW25hbWVdID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KF90aGlzLmNhbGxTdGF0aWMsIG5hbWUsIF90aGlzLmNhbGxTdGF0aWNbc2lnbmF0dXJlXSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKF90aGlzLnBvcHVsYXRlVHJhbnNhY3Rpb25bbmFtZV0gPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkoX3RoaXMucG9wdWxhdGVUcmFuc2FjdGlvbiwgbmFtZSwgX3RoaXMucG9wdWxhdGVUcmFuc2FjdGlvbltzaWduYXR1cmVdKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAoX3RoaXMuZXN0aW1hdGVHYXNbbmFtZV0gPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkoX3RoaXMuZXN0aW1hdGVHYXMsIG5hbWUsIF90aGlzLmVzdGltYXRlR2FzW3NpZ25hdHVyZV0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdCAgICB9XG5cdCAgICBDb250cmFjdC5nZXRDb250cmFjdEFkZHJlc3MgPSBmdW5jdGlvbiAodHJhbnNhY3Rpb24pIHtcblx0ICAgICAgICByZXR1cm4gbGliJDYuZ2V0Q29udHJhY3RBZGRyZXNzKHRyYW5zYWN0aW9uKTtcblx0ICAgIH07XG5cdCAgICBDb250cmFjdC5nZXRJbnRlcmZhY2UgPSBmdW5jdGlvbiAoY29udHJhY3RJbnRlcmZhY2UpIHtcblx0ICAgICAgICBpZiAobGliJGEuSW50ZXJmYWNlLmlzSW50ZXJmYWNlKGNvbnRyYWN0SW50ZXJmYWNlKSkge1xuXHQgICAgICAgICAgICByZXR1cm4gY29udHJhY3RJbnRlcmZhY2U7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBuZXcgbGliJGEuSW50ZXJmYWNlKGNvbnRyYWN0SW50ZXJmYWNlKTtcblx0ICAgIH07XG5cdCAgICAvLyBAVE9ETzogQWxsb3cgdGltZW91dD9cblx0ICAgIENvbnRyYWN0LnByb3RvdHlwZS5kZXBsb3llZCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fZGVwbG95ZWQoKTtcblx0ICAgIH07XG5cdCAgICBDb250cmFjdC5wcm90b3R5cGUuX2RlcGxveWVkID0gZnVuY3Rpb24gKGJsb2NrVGFnKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICBpZiAoIXRoaXMuX2RlcGxveWVkUHJvbWlzZSkge1xuXHQgICAgICAgICAgICAvLyBJZiB3ZSB3ZXJlIGp1c3QgZGVwbG95ZWQsIHdlIGtub3cgdGhlIHRyYW5zYWN0aW9uIHdlIHNob3VsZCBvY2N1ciBpblxuXHQgICAgICAgICAgICBpZiAodGhpcy5kZXBsb3lUcmFuc2FjdGlvbikge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fZGVwbG95ZWRQcm9taXNlID0gdGhpcy5kZXBsb3lUcmFuc2FjdGlvbi53YWl0KCkudGhlbihmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAvLyBAVE9ETzogT25jZSB3ZSBhbGxvdyBhIHRpbWVvdXQgdG8gYmUgcGFzc2VkIGluLCB3ZSB3aWxsIHdhaXRcblx0ICAgICAgICAgICAgICAgIC8vIHVwIHRvIHRoYXQgbWFueSBibG9ja3MgZm9yIGdldENvZGVcblx0ICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgcG9sbCBmb3Igb3VyIGNvZGUgdG8gYmUgZGVwbG95ZWRcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2RlcGxveWVkUHJvbWlzZSA9IHRoaXMucHJvdmlkZXIuZ2V0Q29kZSh0aGlzLmFkZHJlc3MsIGJsb2NrVGFnKS50aGVuKGZ1bmN0aW9uIChjb2RlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgPT09IFwiMHhcIikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImNvbnRyYWN0IG5vdCBkZXBsb3llZFwiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogX3RoaXMuYWRkcmVzcyxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJnZXREZXBsb3llZFwiXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcy5fZGVwbG95ZWRQcm9taXNlO1xuXHQgICAgfTtcblx0ICAgIC8vIEBUT0RPOlxuXHQgICAgLy8gZXN0aW1hdGVGYWxsYmFjayhvdmVycmlkZXM/OiBUcmFuc2FjdGlvblJlcXVlc3QpOiBQcm9taXNlPEJpZ051bWJlcj5cblx0ICAgIC8vIEBUT0RPOlxuXHQgICAgLy8gZXN0aW1hdGVEZXBsb3koYnl0ZWNvZGU6IHN0cmluZywgLi4uYXJncyk6IFByb21pc2U8QmlnTnVtYmVyPlxuXHQgICAgQ29udHJhY3QucHJvdG90eXBlLmZhbGxiYWNrID0gZnVuY3Rpb24gKG92ZXJyaWRlcykge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgaWYgKCF0aGlzLnNpZ25lcikge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInNlbmRpbmcgYSB0cmFuc2FjdGlvbnMgcmVxdWlyZSBhIHNpZ25lclwiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHsgb3BlcmF0aW9uOiBcInNlbmRUcmFuc2FjdGlvbihmYWxsYmFjaylcIiB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHR4ID0gbGliJDMuc2hhbGxvd0NvcHkob3ZlcnJpZGVzIHx8IHt9KTtcblx0ICAgICAgICBbXCJmcm9tXCIsIFwidG9cIl0uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdCAgICAgICAgICAgIGlmICh0eFtrZXldID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImNhbm5vdCBvdmVycmlkZSBcIiArIGtleSwgbGliLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7IG9wZXJhdGlvbjoga2V5IH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHR4LnRvID0gdGhpcy5yZXNvbHZlZEFkZHJlc3M7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZGVwbG95ZWQoKS50aGVuKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNpZ25lci5zZW5kVHJhbnNhY3Rpb24odHgpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIC8vIFJlY29ubmVjdCB0byBhIGRpZmZlcmVudCBzaWduZXIgb3IgcHJvdmlkZXJcblx0ICAgIENvbnRyYWN0LnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKHNpZ25lck9yUHJvdmlkZXIpIHtcblx0ICAgICAgICBpZiAodHlwZW9mIChzaWduZXJPclByb3ZpZGVyKSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgICAgICBzaWduZXJPclByb3ZpZGVyID0gbmV3IGxpYiRjLlZvaWRTaWduZXIoc2lnbmVyT3JQcm92aWRlciwgdGhpcy5wcm92aWRlcik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBjb250cmFjdCA9IG5ldyAodGhpcy5jb25zdHJ1Y3RvcikodGhpcy5hZGRyZXNzLCB0aGlzLmludGVyZmFjZSwgc2lnbmVyT3JQcm92aWRlcik7XG5cdCAgICAgICAgaWYgKHRoaXMuZGVwbG95VHJhbnNhY3Rpb24pIHtcblx0ICAgICAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkoY29udHJhY3QsIFwiZGVwbG95VHJhbnNhY3Rpb25cIiwgdGhpcy5kZXBsb3lUcmFuc2FjdGlvbik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBjb250cmFjdDtcblx0ICAgIH07XG5cdCAgICAvLyBSZS1hdHRhY2ggdG8gYSBkaWZmZXJlbnQgb24tY2hhaW4gaW5zdGFuY2Ugb2YgdGhpcyBjb250cmFjdFxuXHQgICAgQ29udHJhY3QucHJvdG90eXBlLmF0dGFjaCA9IGZ1bmN0aW9uIChhZGRyZXNzT3JOYW1lKSB7XG5cdCAgICAgICAgcmV0dXJuIG5ldyAodGhpcy5jb25zdHJ1Y3RvcikoYWRkcmVzc09yTmFtZSwgdGhpcy5pbnRlcmZhY2UsIHRoaXMuc2lnbmVyIHx8IHRoaXMucHJvdmlkZXIpO1xuXHQgICAgfTtcblx0ICAgIENvbnRyYWN0LmlzSW5kZXhlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiBsaWIkYS5JbmRleGVkLmlzSW5kZXhlZCh2YWx1ZSk7XG5cdCAgICB9O1xuXHQgICAgQ29udHJhY3QucHJvdG90eXBlLl9ub3JtYWxpemVSdW5uaW5nRXZlbnQgPSBmdW5jdGlvbiAocnVubmluZ0V2ZW50KSB7XG5cdCAgICAgICAgLy8gQWxyZWFkeSBoYXZlIGFuIGluc3RhbmNlIG9mIHRoaXMgZXZlbnQgcnVubmluZzsgd2UgY2FuIHJlLXVzZSBpdFxuXHQgICAgICAgIGlmICh0aGlzLl9ydW5uaW5nRXZlbnRzW3J1bm5pbmdFdmVudC50YWddKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9ydW5uaW5nRXZlbnRzW3J1bm5pbmdFdmVudC50YWddO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcnVubmluZ0V2ZW50O1xuXHQgICAgfTtcblx0ICAgIENvbnRyYWN0LnByb3RvdHlwZS5fZ2V0UnVubmluZ0V2ZW50ID0gZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuXHQgICAgICAgIGlmICh0eXBlb2YgKGV2ZW50TmFtZSkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgLy8gTGlzdGVuIGZvciBcImVycm9yXCIgZXZlbnRzIChpZiB5b3VyIGNvbnRyYWN0IGhhcyBhbiBlcnJvciBldmVudCwgaW5jbHVkZVxuXHQgICAgICAgICAgICAvLyB0aGUgZnVsbCBzaWduYXR1cmUgdG8gYnlwYXNzIHRoaXMgc3BlY2lhbCBldmVudCBrZXl3b3JkKVxuXHQgICAgICAgICAgICBpZiAoZXZlbnROYW1lID09PSBcImVycm9yXCIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ub3JtYWxpemVSdW5uaW5nRXZlbnQobmV3IEVycm9yUnVubmluZ0V2ZW50KCkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIC8vIExpc3RlbiBmb3IgYW55IGV2ZW50IHRoYXQgaXMgcmVnaXN0ZXJlZFxuXHQgICAgICAgICAgICBpZiAoZXZlbnROYW1lID09PSBcImV2ZW50XCIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ub3JtYWxpemVSdW5uaW5nRXZlbnQobmV3IFJ1bm5pbmdFdmVudChcImV2ZW50XCIsIG51bGwpKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAvLyBMaXN0ZW4gZm9yIGFueSBldmVudFxuXHQgICAgICAgICAgICBpZiAoZXZlbnROYW1lID09PSBcIipcIikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25vcm1hbGl6ZVJ1bm5pbmdFdmVudChuZXcgV2lsZGNhcmRSdW5uaW5nRXZlbnQodGhpcy5hZGRyZXNzLCB0aGlzLmludGVyZmFjZSkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIC8vIEdldCB0aGUgZXZlbnQgRnJhZ21lbnQgKHRocm93cyBpZiBhbWJpZ3VvdXMvdW5rbm93biBldmVudClcblx0ICAgICAgICAgICAgdmFyIGZyYWdtZW50ID0gdGhpcy5pbnRlcmZhY2UuZ2V0RXZlbnQoZXZlbnROYW1lKTtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25vcm1hbGl6ZVJ1bm5pbmdFdmVudChuZXcgRnJhZ21lbnRSdW5uaW5nRXZlbnQodGhpcy5hZGRyZXNzLCB0aGlzLmludGVyZmFjZSwgZnJhZ21lbnQpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gV2UgaGF2ZSB0b3BpY3MgdG8gZmlsdGVyIGJ5Li4uXG5cdCAgICAgICAgaWYgKGV2ZW50TmFtZS50b3BpY3MgJiYgZXZlbnROYW1lLnRvcGljcy5sZW5ndGggPiAwKSB7XG5cdCAgICAgICAgICAgIC8vIElzIGl0IGEga25vd24gdG9waWNoYXNoPyAodGhyb3dzIGlmIG5vIG1hdGNoaW5nIHRvcGljaGFzaClcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIHZhciB0b3BpYyA9IGV2ZW50TmFtZS50b3BpY3NbMF07XG5cdCAgICAgICAgICAgICAgICBpZiAodHlwZW9mICh0b3BpYykgIT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHRvcGljXCIpOyAvLyBAVE9ETzogTWF5IGhhcHBlbiBmb3IgYW5vbnltb3VzIGV2ZW50c1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdmFyIGZyYWdtZW50ID0gdGhpcy5pbnRlcmZhY2UuZ2V0RXZlbnQodG9waWMpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25vcm1hbGl6ZVJ1bm5pbmdFdmVudChuZXcgRnJhZ21lbnRSdW5uaW5nRXZlbnQodGhpcy5hZGRyZXNzLCB0aGlzLmludGVyZmFjZSwgZnJhZ21lbnQsIGV2ZW50TmFtZS50b3BpY3MpKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuXHQgICAgICAgICAgICAvLyBGaWx0ZXIgYnkgdGhlIHVua25vd24gdG9waWNoYXNoXG5cdCAgICAgICAgICAgIHZhciBmaWx0ZXIgPSB7XG5cdCAgICAgICAgICAgICAgICBhZGRyZXNzOiB0aGlzLmFkZHJlc3MsXG5cdCAgICAgICAgICAgICAgICB0b3BpY3M6IGV2ZW50TmFtZS50b3BpY3Ncblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25vcm1hbGl6ZVJ1bm5pbmdFdmVudChuZXcgUnVubmluZ0V2ZW50KGdldEV2ZW50VGFnKGZpbHRlciksIGZpbHRlcikpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcy5fbm9ybWFsaXplUnVubmluZ0V2ZW50KG5ldyBXaWxkY2FyZFJ1bm5pbmdFdmVudCh0aGlzLmFkZHJlc3MsIHRoaXMuaW50ZXJmYWNlKSk7XG5cdCAgICB9O1xuXHQgICAgQ29udHJhY3QucHJvdG90eXBlLl9jaGVja1J1bm5pbmdFdmVudHMgPSBmdW5jdGlvbiAocnVubmluZ0V2ZW50KSB7XG5cdCAgICAgICAgaWYgKHJ1bm5pbmdFdmVudC5saXN0ZW5lckNvdW50KCkgPT09IDApIHtcblx0ICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3J1bm5pbmdFdmVudHNbcnVubmluZ0V2ZW50LnRhZ107XG5cdCAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSBwb2xsZXIgZm9yIHRoaXMsIHJlbW92ZSBpdFxuXHQgICAgICAgICAgICB2YXIgZW1pdCA9IHRoaXMuX3dyYXBwZWRFbWl0c1tydW5uaW5nRXZlbnQudGFnXTtcblx0ICAgICAgICAgICAgaWYgKGVtaXQpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMucHJvdmlkZXIub2ZmKHJ1bm5pbmdFdmVudC5maWx0ZXIsIGVtaXQpO1xuXHQgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3dyYXBwZWRFbWl0c1tydW5uaW5nRXZlbnQudGFnXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvLyBTdWJjbGFzc2VzIGNhbiBvdmVycmlkZSB0aGlzIHRvIGdyYWNlZnVsbHkgcmVjb3ZlclxuXHQgICAgLy8gZnJvbSBwYXJzZSBlcnJvcnMgaWYgdGhleSB3aXNoXG5cdCAgICBDb250cmFjdC5wcm90b3R5cGUuX3dyYXBFdmVudCA9IGZ1bmN0aW9uIChydW5uaW5nRXZlbnQsIGxvZywgbGlzdGVuZXIpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIHZhciBldmVudCA9IGxpYiQzLmRlZXBDb3B5KGxvZyk7XG5cdCAgICAgICAgZXZlbnQucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGlmICghbGlzdGVuZXIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBydW5uaW5nRXZlbnQucmVtb3ZlTGlzdGVuZXIobGlzdGVuZXIpO1xuXHQgICAgICAgICAgICBfdGhpcy5fY2hlY2tSdW5uaW5nRXZlbnRzKHJ1bm5pbmdFdmVudCk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBldmVudC5nZXRCbG9jayA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnByb3ZpZGVyLmdldEJsb2NrKGxvZy5ibG9ja0hhc2gpOyB9O1xuXHQgICAgICAgIGV2ZW50LmdldFRyYW5zYWN0aW9uID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb24obG9nLnRyYW5zYWN0aW9uSGFzaCk7IH07XG5cdCAgICAgICAgZXZlbnQuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KGxvZy50cmFuc2FjdGlvbkhhc2gpOyB9O1xuXHQgICAgICAgIC8vIFRoaXMgbWF5IHRocm93IGlmIHRoZSB0b3BpY3MgYW5kIGRhdGEgbWlzbWF0Y2ggdGhlIHNpZ25hdHVyZVxuXHQgICAgICAgIHJ1bm5pbmdFdmVudC5wcmVwYXJlRXZlbnQoZXZlbnQpO1xuXHQgICAgICAgIHJldHVybiBldmVudDtcblx0ICAgIH07XG5cdCAgICBDb250cmFjdC5wcm90b3R5cGUuX2FkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAocnVubmluZ0V2ZW50LCBsaXN0ZW5lciwgb25jZSkge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgaWYgKCF0aGlzLnByb3ZpZGVyKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiZXZlbnRzIHJlcXVpcmUgYSBwcm92aWRlciBvciBhIHNpZ25lciB3aXRoIGEgcHJvdmlkZXJcIiwgbGliLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7IG9wZXJhdGlvbjogXCJvbmNlXCIgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJ1bm5pbmdFdmVudC5hZGRMaXN0ZW5lcihsaXN0ZW5lciwgb25jZSk7XG5cdCAgICAgICAgLy8gVHJhY2sgdGhpcyBydW5uaW5nIGV2ZW50IGFuZCBpdHMgbGlzdGVuZXJzIChtYXkgYWxyZWFkeSBiZSB0aGVyZTsgYnV0IG5vIGhhcmQgaW4gdXBkYXRpbmcpXG5cdCAgICAgICAgdGhpcy5fcnVubmluZ0V2ZW50c1tydW5uaW5nRXZlbnQudGFnXSA9IHJ1bm5pbmdFdmVudDtcblx0ICAgICAgICAvLyBJZiB3ZSBhcmUgbm90IHBvbGxpbmcgdGhlIHByb3ZpZGVyLCBzdGFydCBwb2xsaW5nXG5cdCAgICAgICAgaWYgKCF0aGlzLl93cmFwcGVkRW1pdHNbcnVubmluZ0V2ZW50LnRhZ10pIHtcblx0ICAgICAgICAgICAgdmFyIHdyYXBwZWRFbWl0ID0gZnVuY3Rpb24gKGxvZykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGV2ZW50ID0gX3RoaXMuX3dyYXBFdmVudChydW5uaW5nRXZlbnQsIGxvZywgbGlzdGVuZXIpO1xuXHQgICAgICAgICAgICAgICAgLy8gVHJ5IHRvIGVtaXQgdGhlIHJlc3VsdCBmb3IgdGhlIHBhcmFtZXRlcml6ZWQgZXZlbnQuLi5cblx0ICAgICAgICAgICAgICAgIGlmIChldmVudC5kZWNvZGVFcnJvciA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBydW5uaW5nRXZlbnQuZ2V0RW1pdChldmVudCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQuYXBwbHkoX3RoaXMsIF9fc3ByZWFkQXJyYXlzKFtydW5uaW5nRXZlbnQuZmlsdGVyXSwgYXJncykpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuZGVjb2RlRXJyb3IgPSBlcnJvci5lcnJvcjtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAvLyBBbHdheXMgZW1pdCBcImV2ZW50XCIgZm9yIGZyYWdtZW50LWJhc2UgZXZlbnRzXG5cdCAgICAgICAgICAgICAgICBpZiAocnVubmluZ0V2ZW50LmZpbHRlciAhPSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcImV2ZW50XCIsIGV2ZW50KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIC8vIEVtaXQgXCJlcnJvclwiIGlmIHRoZXJlIHdhcyBhbiBlcnJvclxuXHQgICAgICAgICAgICAgICAgaWYgKGV2ZW50LmRlY29kZUVycm9yICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwiZXJyb3JcIiwgZXZlbnQuZGVjb2RlRXJyb3IsIGV2ZW50KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgdGhpcy5fd3JhcHBlZEVtaXRzW3J1bm5pbmdFdmVudC50YWddID0gd3JhcHBlZEVtaXQ7XG5cdCAgICAgICAgICAgIC8vIFNwZWNpYWwgZXZlbnRzLCBsaWtlIFwiZXJyb3JcIiBkbyBub3QgaGF2ZSBhIGZpbHRlclxuXHQgICAgICAgICAgICBpZiAocnVubmluZ0V2ZW50LmZpbHRlciAhPSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnByb3ZpZGVyLm9uKHJ1bm5pbmdFdmVudC5maWx0ZXIsIHdyYXBwZWRFbWl0KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICBDb250cmFjdC5wcm90b3R5cGUucXVlcnlGaWx0ZXIgPSBmdW5jdGlvbiAoZXZlbnQsIGZyb21CbG9ja09yQmxvY2toYXNoLCB0b0Jsb2NrKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICB2YXIgcnVubmluZ0V2ZW50ID0gdGhpcy5fZ2V0UnVubmluZ0V2ZW50KGV2ZW50KTtcblx0ICAgICAgICB2YXIgZmlsdGVyID0gbGliJDMuc2hhbGxvd0NvcHkocnVubmluZ0V2ZW50LmZpbHRlcik7XG5cdCAgICAgICAgaWYgKHR5cGVvZiAoZnJvbUJsb2NrT3JCbG9ja2hhc2gpID09PSBcInN0cmluZ1wiICYmIGxpYiQxLmlzSGV4U3RyaW5nKGZyb21CbG9ja09yQmxvY2toYXNoLCAzMikpIHtcblx0ICAgICAgICAgICAgaWYgKHRvQmxvY2sgIT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImNhbm5vdCBzcGVjaWZ5IHRvQmxvY2sgd2l0aCBibG9ja2hhc2hcIiwgXCJ0b0Jsb2NrXCIsIHRvQmxvY2spO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGZpbHRlci5ibG9ja0hhc2ggPSBmcm9tQmxvY2tPckJsb2NraGFzaDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIGZpbHRlci5mcm9tQmxvY2sgPSAoKGZyb21CbG9ja09yQmxvY2toYXNoICE9IG51bGwpID8gZnJvbUJsb2NrT3JCbG9ja2hhc2ggOiAwKTtcblx0ICAgICAgICAgICAgZmlsdGVyLnRvQmxvY2sgPSAoKHRvQmxvY2sgIT0gbnVsbCkgPyB0b0Jsb2NrIDogXCJsYXRlc3RcIik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLmdldExvZ3MoZmlsdGVyKS50aGVuKGZ1bmN0aW9uIChsb2dzKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBsb2dzLm1hcChmdW5jdGlvbiAobG9nKSB7IHJldHVybiBfdGhpcy5fd3JhcEV2ZW50KHJ1bm5pbmdFdmVudCwgbG9nLCBudWxsKTsgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgQ29udHJhY3QucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2ZW50LCBsaXN0ZW5lcikge1xuXHQgICAgICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXIodGhpcy5fZ2V0UnVubmluZ0V2ZW50KGV2ZW50KSwgbGlzdGVuZXIsIGZhbHNlKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICBDb250cmFjdC5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIChldmVudCwgbGlzdGVuZXIpIHtcblx0ICAgICAgICB0aGlzLl9hZGRFdmVudExpc3RlbmVyKHRoaXMuX2dldFJ1bm5pbmdFdmVudChldmVudCksIGxpc3RlbmVyLCB0cnVlKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICBDb250cmFjdC5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIChldmVudE5hbWUpIHtcblx0ICAgICAgICB2YXIgYXJncyA9IFtdO1xuXHQgICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG5cdCAgICAgICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICghdGhpcy5wcm92aWRlcikge1xuXHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBydW5uaW5nRXZlbnQgPSB0aGlzLl9nZXRSdW5uaW5nRXZlbnQoZXZlbnROYW1lKTtcblx0ICAgICAgICB2YXIgcmVzdWx0ID0gKHJ1bm5pbmdFdmVudC5ydW4oYXJncykgPiAwKTtcblx0ICAgICAgICAvLyBNYXkgaGF2ZSBkcmFpbmVkIGFsbCB0aGUgXCJvbmNlXCIgZXZlbnRzOyBjaGVjayBmb3IgbGl2aW5nIGV2ZW50c1xuXHQgICAgICAgIHRoaXMuX2NoZWNrUnVubmluZ0V2ZW50cyhydW5uaW5nRXZlbnQpO1xuXHQgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9O1xuXHQgICAgQ29udHJhY3QucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG5cdCAgICAgICAgaWYgKCF0aGlzLnByb3ZpZGVyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiAwO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcy5fZ2V0UnVubmluZ0V2ZW50KGV2ZW50TmFtZSkubGlzdGVuZXJDb3VudCgpO1xuXHQgICAgfTtcblx0ICAgIENvbnRyYWN0LnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG5cdCAgICAgICAgaWYgKCF0aGlzLnByb3ZpZGVyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBbXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGV2ZW50TmFtZSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHZhciByZXN1bHRfMSA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciB0YWcgaW4gdGhpcy5fcnVubmluZ0V2ZW50cykge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fcnVubmluZ0V2ZW50c1t0YWddLmxpc3RlbmVycygpLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVzdWx0XzEucHVzaChsaXN0ZW5lcik7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gcmVzdWx0XzE7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzLl9nZXRSdW5uaW5nRXZlbnQoZXZlbnROYW1lKS5saXN0ZW5lcnMoKTtcblx0ICAgIH07XG5cdCAgICBDb250cmFjdC5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuXHQgICAgICAgIGlmICghdGhpcy5wcm92aWRlcikge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGV2ZW50TmFtZSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIGZvciAodmFyIHRhZyBpbiB0aGlzLl9ydW5uaW5nRXZlbnRzKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgcnVubmluZ0V2ZW50XzEgPSB0aGlzLl9ydW5uaW5nRXZlbnRzW3RhZ107XG5cdCAgICAgICAgICAgICAgICBydW5uaW5nRXZlbnRfMS5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrUnVubmluZ0V2ZW50cyhydW5uaW5nRXZlbnRfMSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIERlbGV0ZSBhbnkgbGlzdGVuZXJzXG5cdCAgICAgICAgdmFyIHJ1bm5pbmdFdmVudCA9IHRoaXMuX2dldFJ1bm5pbmdFdmVudChldmVudE5hbWUpO1xuXHQgICAgICAgIHJ1bm5pbmdFdmVudC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcblx0ICAgICAgICB0aGlzLl9jaGVja1J1bm5pbmdFdmVudHMocnVubmluZ0V2ZW50KTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICBDb250cmFjdC5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcblx0ICAgICAgICBpZiAoIXRoaXMucHJvdmlkZXIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBydW5uaW5nRXZlbnQgPSB0aGlzLl9nZXRSdW5uaW5nRXZlbnQoZXZlbnROYW1lKTtcblx0ICAgICAgICBydW5uaW5nRXZlbnQucmVtb3ZlTGlzdGVuZXIobGlzdGVuZXIpO1xuXHQgICAgICAgIHRoaXMuX2NoZWNrUnVubmluZ0V2ZW50cyhydW5uaW5nRXZlbnQpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIENvbnRyYWN0LnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGxpc3RlbmVyKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMub2ZmKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBDb250cmFjdDtcblx0fSgpKTtcblx0ZXhwb3J0cy5Db250cmFjdCA9IENvbnRyYWN0O1xuXHR2YXIgQ29udHJhY3RGYWN0b3J5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gQ29udHJhY3RGYWN0b3J5KGNvbnRyYWN0SW50ZXJmYWNlLCBieXRlY29kZSwgc2lnbmVyKSB7XG5cdCAgICAgICAgdmFyIF9uZXdUYXJnZXQgPSB0aGlzLmNvbnN0cnVjdG9yO1xuXHQgICAgICAgIHZhciBieXRlY29kZUhleCA9IG51bGw7XG5cdCAgICAgICAgaWYgKHR5cGVvZiAoYnl0ZWNvZGUpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgIGJ5dGVjb2RlSGV4ID0gYnl0ZWNvZGU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2UgaWYgKGxpYiQxLmlzQnl0ZXMoYnl0ZWNvZGUpKSB7XG5cdCAgICAgICAgICAgIGJ5dGVjb2RlSGV4ID0gbGliJDEuaGV4bGlmeShieXRlY29kZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2UgaWYgKGJ5dGVjb2RlICYmIHR5cGVvZiAoYnl0ZWNvZGUub2JqZWN0KSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgICAgICAvLyBBbGxvdyB0aGUgYnl0ZWNvZGUgb2JqZWN0IGZyb20gdGhlIFNvbGlkaXR5IGNvbXBpbGVyXG5cdCAgICAgICAgICAgIGJ5dGVjb2RlSGV4ID0gYnl0ZWNvZGUub2JqZWN0O1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgLy8gQ3Jhc2ggaW4gdGhlIG5leHQgdmVyaWZpY2F0aW9uIHN0ZXBcblx0ICAgICAgICAgICAgYnl0ZWNvZGVIZXggPSBcIiFcIjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gTWFrZSBzdXJlIGl0IGlzIDB4IHByZWZpeGVkXG5cdCAgICAgICAgaWYgKGJ5dGVjb2RlSGV4LnN1YnN0cmluZygwLCAyKSAhPT0gXCIweFwiKSB7XG5cdCAgICAgICAgICAgIGJ5dGVjb2RlSGV4ID0gXCIweFwiICsgYnl0ZWNvZGVIZXg7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgZmluYWwgcmVzdWx0IGlzIHZhbGlkIGJ5dGVjb2RlXG5cdCAgICAgICAgaWYgKCFsaWIkMS5pc0hleFN0cmluZyhieXRlY29kZUhleCkgfHwgKGJ5dGVjb2RlSGV4Lmxlbmd0aCAlIDIpKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGJ5dGVjb2RlXCIsIFwiYnl0ZWNvZGVcIiwgYnl0ZWNvZGUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgc2lnbmVyLCBtYWtlIHN1cmUgaXQgaXMgdmFsaWRcblx0ICAgICAgICBpZiAoc2lnbmVyICYmICFsaWIkYy5TaWduZXIuaXNTaWduZXIoc2lnbmVyKSkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBzaWduZXJcIiwgXCJzaWduZXJcIiwgc2lnbmVyKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJieXRlY29kZVwiLCBieXRlY29kZUhleCk7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJpbnRlcmZhY2VcIiwgbGliJDMuZ2V0U3RhdGljKChfbmV3VGFyZ2V0KSwgXCJnZXRJbnRlcmZhY2VcIikoY29udHJhY3RJbnRlcmZhY2UpKTtcblx0ICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcInNpZ25lclwiLCBzaWduZXIgfHwgbnVsbCk7XG5cdCAgICB9XG5cdCAgICAvLyBAVE9ETzogRnV0dXJlOyByZW5hbWUgdG8gcG9wdWx0ZVRyYW5zYWN0aW9uP1xuXHQgICAgQ29udHJhY3RGYWN0b3J5LnByb3RvdHlwZS5nZXREZXBsb3lUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgYXJncyA9IFtdO1xuXHQgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG5cdCAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHR4ID0ge307XG5cdCAgICAgICAgLy8gSWYgd2UgaGF2ZSAxIGFkZGl0aW9uYWwgYXJndW1lbnQsIHdlIGFsbG93IHRyYW5zYWN0aW9uIG92ZXJyaWRlc1xuXHQgICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gdGhpcy5pbnRlcmZhY2UuZGVwbG95LmlucHV0cy5sZW5ndGggKyAxICYmIHR5cGVvZiAoYXJnc1thcmdzLmxlbmd0aCAtIDFdKSA9PT0gXCJvYmplY3RcIikge1xuXHQgICAgICAgICAgICB0eCA9IGxpYiQzLnNoYWxsb3dDb3B5KGFyZ3MucG9wKCkpO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gdHgpIHtcblx0ICAgICAgICAgICAgICAgIGlmICghYWxsb3dlZFRyYW5zYWN0aW9uS2V5c1trZXldKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB0cmFuc2FjdGlvbiBvdmVycmlkZSBcIiArIGtleSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gRG8gbm90IGFsbG93IHRoZXNlIHRvIGJlIG92ZXJyaWRkZW4gaW4gYSBkZXBsb3ltZW50IHRyYW5zYWN0aW9uXG5cdCAgICAgICAgW1wiZGF0YVwiLCBcImZyb21cIiwgXCJ0b1wiXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0ICAgICAgICAgICAgaWYgKHR4W2tleV0gPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IG92ZXJyaWRlIFwiICsga2V5LCBsaWIuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHsgb3BlcmF0aW9uOiBrZXkgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBjYWxsIG1hdGNoZXMgdGhlIGNvbnN0cnVjdG9yIHNpZ25hdHVyZVxuXHQgICAgICAgIGxvZ2dlci5jaGVja0FyZ3VtZW50Q291bnQoYXJncy5sZW5ndGgsIHRoaXMuaW50ZXJmYWNlLmRlcGxveS5pbnB1dHMubGVuZ3RoLCBcIiBpbiBDb250cmFjdCBjb25zdHJ1Y3RvclwiKTtcblx0ICAgICAgICAvLyBTZXQgdGhlIGRhdGEgdG8gdGhlIGJ5dGVjb2RlICsgdGhlIGVuY29kZWQgY29uc3RydWN0b3IgYXJndW1lbnRzXG5cdCAgICAgICAgdHguZGF0YSA9IGxpYiQxLmhleGxpZnkobGliJDEuY29uY2F0KFtcblx0ICAgICAgICAgICAgdGhpcy5ieXRlY29kZSxcblx0ICAgICAgICAgICAgdGhpcy5pbnRlcmZhY2UuZW5jb2RlRGVwbG95KGFyZ3MpXG5cdCAgICAgICAgXSkpO1xuXHQgICAgICAgIHJldHVybiB0eDtcblx0ICAgIH07XG5cdCAgICBDb250cmFjdEZhY3RvcnkucHJvdG90eXBlLmRlcGxveSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgYXJncyA9IFtdO1xuXHQgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG5cdCAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgb3ZlcnJpZGVzLCBwYXJhbXMsIHVuc2lnbmVkVHgsIHR4LCBhZGRyZXNzLCBjb250cmFjdDtcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcnJpZGVzID0ge307XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIDEgZXh0cmEgcGFyYW1ldGVyIHdhcyBwYXNzZWQgaW4sIGl0IGNvbnRhaW5zIG92ZXJyaWRlc1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IHRoaXMuaW50ZXJmYWNlLmRlcGxveS5pbnB1dHMubGVuZ3RoICsgMSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcnJpZGVzID0gYXJncy5wb3AoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGNhbGwgbWF0Y2hlcyB0aGUgY29uc3RydWN0b3Igc2lnbmF0dXJlXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5jaGVja0FyZ3VtZW50Q291bnQoYXJncy5sZW5ndGgsIHRoaXMuaW50ZXJmYWNlLmRlcGxveS5pbnB1dHMubGVuZ3RoLCBcIiBpbiBDb250cmFjdCBjb25zdHJ1Y3RvclwiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgcmVzb2x2ZUFkZHJlc3Nlcyh0aGlzLnNpZ25lciwgYXJncywgdGhpcy5pbnRlcmZhY2UuZGVwbG95LmlucHV0cyldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMucHVzaChvdmVycmlkZXMpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB1bnNpZ25lZFR4ID0gdGhpcy5nZXREZXBsb3lUcmFuc2FjdGlvbi5hcHBseSh0aGlzLCBwYXJhbXMpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnNpZ25lci5zZW5kVHJhbnNhY3Rpb24odW5zaWduZWRUeCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHggPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3MgPSBsaWIkMy5nZXRTdGF0aWModGhpcy5jb25zdHJ1Y3RvciwgXCJnZXRDb250cmFjdEFkZHJlc3NcIikodHgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb250cmFjdCA9IGxpYiQzLmdldFN0YXRpYyh0aGlzLmNvbnN0cnVjdG9yLCBcImdldENvbnRyYWN0XCIpKGFkZHJlc3MsIHRoaXMuaW50ZXJmYWNlLCB0aGlzLnNpZ25lcik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KGNvbnRyYWN0LCBcImRlcGxveVRyYW5zYWN0aW9uXCIsIHR4KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGNvbnRyYWN0XTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgQ29udHJhY3RGYWN0b3J5LnByb3RvdHlwZS5hdHRhY2ggPSBmdW5jdGlvbiAoYWRkcmVzcykge1xuXHQgICAgICAgIHJldHVybiAodGhpcy5jb25zdHJ1Y3RvcikuZ2V0Q29udHJhY3QoYWRkcmVzcywgdGhpcy5pbnRlcmZhY2UsIHRoaXMuc2lnbmVyKTtcblx0ICAgIH07XG5cdCAgICBDb250cmFjdEZhY3RvcnkucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAoc2lnbmVyKSB7XG5cdCAgICAgICAgcmV0dXJuIG5ldyAodGhpcy5jb25zdHJ1Y3RvcikodGhpcy5pbnRlcmZhY2UsIHRoaXMuYnl0ZWNvZGUsIHNpZ25lcik7XG5cdCAgICB9O1xuXHQgICAgQ29udHJhY3RGYWN0b3J5LmZyb21Tb2xpZGl0eSA9IGZ1bmN0aW9uIChjb21waWxlck91dHB1dCwgc2lnbmVyKSB7XG5cdCAgICAgICAgaWYgKGNvbXBpbGVyT3V0cHV0ID09IG51bGwpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJtaXNzaW5nIGNvbXBpbGVyIG91dHB1dFwiLCBsaWIuTG9nZ2VyLmVycm9ycy5NSVNTSU5HX0FSR1VNRU5ULCB7IGFyZ3VtZW50OiBcImNvbXBpbGVyT3V0cHV0XCIgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICh0eXBlb2YgKGNvbXBpbGVyT3V0cHV0KSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgICAgICBjb21waWxlck91dHB1dCA9IEpTT04ucGFyc2UoY29tcGlsZXJPdXRwdXQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgYWJpID0gY29tcGlsZXJPdXRwdXQuYWJpO1xuXHQgICAgICAgIHZhciBieXRlY29kZSA9IG51bGw7XG5cdCAgICAgICAgaWYgKGNvbXBpbGVyT3V0cHV0LmJ5dGVjb2RlKSB7XG5cdCAgICAgICAgICAgIGJ5dGVjb2RlID0gY29tcGlsZXJPdXRwdXQuYnl0ZWNvZGU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2UgaWYgKGNvbXBpbGVyT3V0cHV0LmV2bSAmJiBjb21waWxlck91dHB1dC5ldm0uYnl0ZWNvZGUpIHtcblx0ICAgICAgICAgICAgYnl0ZWNvZGUgPSBjb21waWxlck91dHB1dC5ldm0uYnl0ZWNvZGU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBuZXcgdGhpcyhhYmksIGJ5dGVjb2RlLCBzaWduZXIpO1xuXHQgICAgfTtcblx0ICAgIENvbnRyYWN0RmFjdG9yeS5nZXRJbnRlcmZhY2UgPSBmdW5jdGlvbiAoY29udHJhY3RJbnRlcmZhY2UpIHtcblx0ICAgICAgICByZXR1cm4gQ29udHJhY3QuZ2V0SW50ZXJmYWNlKGNvbnRyYWN0SW50ZXJmYWNlKTtcblx0ICAgIH07XG5cdCAgICBDb250cmFjdEZhY3RvcnkuZ2V0Q29udHJhY3RBZGRyZXNzID0gZnVuY3Rpb24gKHR4KSB7XG5cdCAgICAgICAgcmV0dXJuIGxpYiQ2LmdldENvbnRyYWN0QWRkcmVzcyh0eCk7XG5cdCAgICB9O1xuXHQgICAgQ29udHJhY3RGYWN0b3J5LmdldENvbnRyYWN0ID0gZnVuY3Rpb24gKGFkZHJlc3MsIGNvbnRyYWN0SW50ZXJmYWNlLCBzaWduZXIpIHtcblx0ICAgICAgICByZXR1cm4gbmV3IENvbnRyYWN0KGFkZHJlc3MsIGNvbnRyYWN0SW50ZXJmYWNlLCBzaWduZXIpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBDb250cmFjdEZhY3Rvcnk7XG5cdH0oKSk7XG5cdGV4cG9ydHMuQ29udHJhY3RGYWN0b3J5ID0gQ29udHJhY3RGYWN0b3J5O1xuXG5cdH0pO1xuXG5cdHZhciBpbmRleCRkID0gdW53cmFwRXhwb3J0cyhsaWIkZCk7XG5cdHZhciBsaWJfMSRkID0gbGliJGQuQ29udHJhY3Q7XG5cdHZhciBsaWJfMiRjID0gbGliJGQuQ29udHJhY3RGYWN0b3J5O1xuXG5cdHZhciBsaWIkZSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdC8qKlxuXHQgKiB2YXIgYmFzZXggPSByZXF1aXJlKFwiYmFzZS14XCIpO1xuXHQgKlxuXHQgKiBUaGlzIGltcGxlbWVudGF0aW9uIGlzIGhlYXZpbHkgYmFzZWQgb24gYmFzZS14LiBUaGUgbWFpbiByZWFzb24gdG9cblx0ICogZGV2aWF0ZSB3YXMgdG8gcHJldmVudCB0aGUgZGVwZW5kZW5jeSBvZiBCdWZmZXIuXG5cdCAqXG5cdCAqIENvbnRyaWJ1dG9yczpcblx0ICpcblx0ICogYmFzZS14IGVuY29kaW5nXG5cdCAqIEZvcmtlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9jcnlwdG9jb2luanMvYnM1OFxuXHQgKiBPcmlnaW5hbGx5IHdyaXR0ZW4gYnkgTWlrZSBIZWFybiBmb3IgQml0Y29pbkpcblx0ICogQ29weXJpZ2h0IChjKSAyMDExIEdvb2dsZSBJbmNcblx0ICogUG9ydGVkIHRvIEphdmFTY3JpcHQgYnkgU3RlZmFuIFRob21hc1xuXHQgKiBNZXJnZWQgQnVmZmVyIHJlZmFjdG9yaW5ncyBmcm9tIGJhc2U1OC1uYXRpdmUgYnkgU3RlcGhlbiBQYWlyXG5cdCAqIENvcHlyaWdodCAoYykgMjAxMyBCaXRQYXkgSW5jXG5cdCAqXG5cdCAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXHQgKlxuXHQgKiBDb3B5cmlnaHQgYmFzZS14IGNvbnRyaWJ1dG9ycyAoYykgMjAxNlxuXHQgKlxuXHQgKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuXHQgKiBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksXG5cdCAqIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb25cblx0ICogdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsXG5cdCAqIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuXHQgKiBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXHQgKlxuXHQgKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuXHQgKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuXHQgKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5cdCAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuXHQgKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcblx0ICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuXHQgKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuXHQgKiBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTXG5cdCAqIElOIFRIRSBTT0ZUV0FSRS5cblx0ICpcblx0ICovXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXG5cdHZhciBCYXNlWCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIEJhc2VYKGFscGhhYmV0KSB7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJhbHBoYWJldFwiLCBhbHBoYWJldCk7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJiYXNlXCIsIGFscGhhYmV0Lmxlbmd0aCk7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfYWxwaGFiZXRNYXBcIiwge30pO1xuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX2xlYWRlclwiLCBhbHBoYWJldC5jaGFyQXQoMCkpO1xuXHQgICAgICAgIC8vIHByZS1jb21wdXRlIGxvb2t1cCB0YWJsZVxuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxwaGFiZXQubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgdGhpcy5fYWxwaGFiZXRNYXBbYWxwaGFiZXQuY2hhckF0KGkpXSA9IGk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgQmFzZVgucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHZhciBzb3VyY2UgPSBsaWIkMS5hcnJheWlmeSh2YWx1ZSk7XG5cdCAgICAgICAgaWYgKHNvdXJjZS5sZW5ndGggPT09IDApIHtcblx0ICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBkaWdpdHMgPSBbMF07XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2UubGVuZ3RoOyArK2kpIHtcblx0ICAgICAgICAgICAgdmFyIGNhcnJ5ID0gc291cmNlW2ldO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRpZ2l0cy5sZW5ndGg7ICsraikge1xuXHQgICAgICAgICAgICAgICAgY2FycnkgKz0gZGlnaXRzW2pdIDw8IDg7XG5cdCAgICAgICAgICAgICAgICBkaWdpdHNbal0gPSBjYXJyeSAlIHRoaXMuYmFzZTtcblx0ICAgICAgICAgICAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gdGhpcy5iYXNlKSB8IDA7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgd2hpbGUgKGNhcnJ5ID4gMCkge1xuXHQgICAgICAgICAgICAgICAgZGlnaXRzLnB1c2goY2FycnkgJSB0aGlzLmJhc2UpO1xuXHQgICAgICAgICAgICAgICAgY2FycnkgPSAoY2FycnkgLyB0aGlzLmJhc2UpIHwgMDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgc3RyaW5nID0gXCJcIjtcblx0ICAgICAgICAvLyBkZWFsIHdpdGggbGVhZGluZyB6ZXJvc1xuXHQgICAgICAgIGZvciAodmFyIGsgPSAwOyBzb3VyY2Vba10gPT09IDAgJiYgayA8IHNvdXJjZS5sZW5ndGggLSAxOyArK2spIHtcblx0ICAgICAgICAgICAgc3RyaW5nICs9IHRoaXMuX2xlYWRlcjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gY29udmVydCBkaWdpdHMgdG8gYSBzdHJpbmdcblx0ICAgICAgICBmb3IgKHZhciBxID0gZGlnaXRzLmxlbmd0aCAtIDE7IHEgPj0gMDsgLS1xKSB7XG5cdCAgICAgICAgICAgIHN0cmluZyArPSB0aGlzLmFscGhhYmV0W2RpZ2l0c1txXV07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBzdHJpbmc7XG5cdCAgICB9O1xuXHQgICAgQmFzZVgucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSAhPT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgU3RyaW5nXCIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgYnl0ZXMgPSBbXTtcblx0ICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShieXRlcyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGJ5dGVzLnB1c2goMCk7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICB2YXIgYnl0ZSA9IHRoaXMuX2FscGhhYmV0TWFwW3ZhbHVlW2ldXTtcblx0ICAgICAgICAgICAgaWYgKGJ5dGUgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm9uLWJhc2VcIiArIHRoaXMuYmFzZSArIFwiIGNoYXJhY3RlclwiKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgY2FycnkgPSBieXRlO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGJ5dGVzLmxlbmd0aDsgKytqKSB7XG5cdCAgICAgICAgICAgICAgICBjYXJyeSArPSBieXRlc1tqXSAqIHRoaXMuYmFzZTtcblx0ICAgICAgICAgICAgICAgIGJ5dGVzW2pdID0gY2FycnkgJiAweGZmO1xuXHQgICAgICAgICAgICAgICAgY2FycnkgPj49IDg7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgd2hpbGUgKGNhcnJ5ID4gMCkge1xuXHQgICAgICAgICAgICAgICAgYnl0ZXMucHVzaChjYXJyeSAmIDB4ZmYpO1xuXHQgICAgICAgICAgICAgICAgY2FycnkgPj49IDg7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gZGVhbCB3aXRoIGxlYWRpbmcgemVyb3Ncblx0ICAgICAgICBmb3IgKHZhciBrID0gMDsgdmFsdWVba10gPT09IHRoaXMuX2xlYWRlciAmJiBrIDwgdmFsdWUubGVuZ3RoIC0gMTsgKytrKSB7XG5cdCAgICAgICAgICAgIGJ5dGVzLnB1c2goMCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBsaWIkMS5hcnJheWlmeShuZXcgVWludDhBcnJheShieXRlcy5yZXZlcnNlKCkpKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gQmFzZVg7XG5cdH0oKSk7XG5cdGV4cG9ydHMuQmFzZVggPSBCYXNlWDtcblx0dmFyIEJhc2UzMiA9IG5ldyBCYXNlWChcImFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MjM0NTY3XCIpO1xuXHRleHBvcnRzLkJhc2UzMiA9IEJhc2UzMjtcblx0dmFyIEJhc2U1OCA9IG5ldyBCYXNlWChcIjEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXpcIik7XG5cdGV4cG9ydHMuQmFzZTU4ID0gQmFzZTU4O1xuXHQvL2NvbnNvbGUubG9nKEJhc2U1OC5kZWNvZGUoXCJRbWQyVjc3N281WHZKYllNZU1iOGsyblU1ZjhkM2NpVVE1WXBZdVdoenY4aURqXCIpKVxuXHQvL2NvbnNvbGUubG9nKEJhc2U1OC5lbmNvZGUoQmFzZTU4LmRlY29kZShcIlFtZDJWNzc3bzVYdkpiWU1lTWI4azJuVTVmOGQzY2lVUTVZcFl1V2h6djhpRGpcIikpKVxuXG5cdH0pO1xuXG5cdHZhciBpbmRleCRlID0gdW53cmFwRXhwb3J0cyhsaWIkZSk7XG5cdHZhciBsaWJfMSRlID0gbGliJGUuQmFzZVg7XG5cdHZhciBsaWJfMiRkID0gbGliJGUuQmFzZTMyO1xuXHR2YXIgbGliXzMkYSA9IGxpYiRlLkJhc2U1ODtcblxuXHR2YXIgbWluaW1hbGlzdGljQXNzZXJ0ID0gYXNzZXJ0O1xuXG5cdGZ1bmN0aW9uIGFzc2VydCh2YWwsIG1zZykge1xuXHQgIGlmICghdmFsKVxuXHQgICAgdGhyb3cgbmV3IEVycm9yKG1zZyB8fCAnQXNzZXJ0aW9uIGZhaWxlZCcpO1xuXHR9XG5cblx0YXNzZXJ0LmVxdWFsID0gZnVuY3Rpb24gYXNzZXJ0RXF1YWwobCwgciwgbXNnKSB7XG5cdCAgaWYgKGwgIT0gcilcblx0ICAgIHRocm93IG5ldyBFcnJvcihtc2cgfHwgKCdBc3NlcnRpb24gZmFpbGVkOiAnICsgbCArICcgIT0gJyArIHIpKTtcblx0fTtcblxuXHR2YXIgaW5oZXJpdHNfYnJvd3NlciA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcblx0aWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcblx0ICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuXHQgICAgaWYgKHN1cGVyQ3Rvcikge1xuXHQgICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3Rvcjtcblx0ICAgICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcblx0ICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuXHQgICAgICAgICAgdmFsdWU6IGN0b3IsXG5cdCAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcblx0ICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuXHQgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG5cdCAgICAgICAgfVxuXHQgICAgICB9KTtcblx0ICAgIH1cblx0ICB9O1xuXHR9IGVsc2Uge1xuXHQgIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG5cdCAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcblx0ICAgIGlmIChzdXBlckN0b3IpIHtcblx0ICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3I7XG5cdCAgICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9O1xuXHQgICAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlO1xuXHQgICAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpO1xuXHQgICAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3I7XG5cdCAgICB9XG5cdCAgfTtcblx0fVxuXHR9KTtcblxuXHQndXNlIHN0cmljdCc7XG5cblxuXG5cblx0dmFyIGluaGVyaXRzXzEgPSBpbmhlcml0c19icm93c2VyO1xuXG5cdGZ1bmN0aW9uIHRvQXJyYXkobXNnLCBlbmMpIHtcblx0ICBpZiAoQXJyYXkuaXNBcnJheShtc2cpKVxuXHQgICAgcmV0dXJuIG1zZy5zbGljZSgpO1xuXHQgIGlmICghbXNnKVxuXHQgICAgcmV0dXJuIFtdO1xuXHQgIHZhciByZXMgPSBbXTtcblx0ICBpZiAodHlwZW9mIG1zZyA9PT0gJ3N0cmluZycpIHtcblx0ICAgIGlmICghZW5jKSB7XG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgdmFyIGMgPSBtc2cuY2hhckNvZGVBdChpKTtcblx0ICAgICAgICB2YXIgaGkgPSBjID4+IDg7XG5cdCAgICAgICAgdmFyIGxvID0gYyAmIDB4ZmY7XG5cdCAgICAgICAgaWYgKGhpKVxuXHQgICAgICAgICAgcmVzLnB1c2goaGksIGxvKTtcblx0ICAgICAgICBlbHNlXG5cdCAgICAgICAgICByZXMucHVzaChsbyk7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSBpZiAoZW5jID09PSAnaGV4Jykge1xuXHQgICAgICBtc2cgPSBtc2cucmVwbGFjZSgvW15hLXowLTldKy9pZywgJycpO1xuXHQgICAgICBpZiAobXNnLmxlbmd0aCAlIDIgIT09IDApXG5cdCAgICAgICAgbXNnID0gJzAnICsgbXNnO1xuXHQgICAgICBmb3IgKGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSArPSAyKVxuXHQgICAgICAgIHJlcy5wdXNoKHBhcnNlSW50KG1zZ1tpXSArIG1zZ1tpICsgMV0sIDE2KSk7XG5cdCAgICB9XG5cdCAgfSBlbHNlIHtcblx0ICAgIGZvciAoaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyspXG5cdCAgICAgIHJlc1tpXSA9IG1zZ1tpXSB8IDA7XG5cdCAgfVxuXHQgIHJldHVybiByZXM7XG5cdH1cblx0dmFyIHRvQXJyYXlfMSA9IHRvQXJyYXk7XG5cblx0ZnVuY3Rpb24gdG9IZXgobXNnKSB7XG5cdCAgdmFyIHJlcyA9ICcnO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKVxuXHQgICAgcmVzICs9IHplcm8yKG1zZ1tpXS50b1N0cmluZygxNikpO1xuXHQgIHJldHVybiByZXM7XG5cdH1cblx0dmFyIHRvSGV4XzEgPSB0b0hleDtcblxuXHRmdW5jdGlvbiBodG9ubCh3KSB7XG5cdCAgdmFyIHJlcyA9ICh3ID4+PiAyNCkgfFxuXHQgICAgICAgICAgICAoKHcgPj4+IDgpICYgMHhmZjAwKSB8XG5cdCAgICAgICAgICAgICgodyA8PCA4KSAmIDB4ZmYwMDAwKSB8XG5cdCAgICAgICAgICAgICgodyAmIDB4ZmYpIDw8IDI0KTtcblx0ICByZXR1cm4gcmVzID4+PiAwO1xuXHR9XG5cdHZhciBodG9ubF8xID0gaHRvbmw7XG5cblx0ZnVuY3Rpb24gdG9IZXgzMihtc2csIGVuZGlhbikge1xuXHQgIHZhciByZXMgPSAnJztcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKykge1xuXHQgICAgdmFyIHcgPSBtc2dbaV07XG5cdCAgICBpZiAoZW5kaWFuID09PSAnbGl0dGxlJylcblx0ICAgICAgdyA9IGh0b25sKHcpO1xuXHQgICAgcmVzICs9IHplcm84KHcudG9TdHJpbmcoMTYpKTtcblx0ICB9XG5cdCAgcmV0dXJuIHJlcztcblx0fVxuXHR2YXIgdG9IZXgzMl8xID0gdG9IZXgzMjtcblxuXHRmdW5jdGlvbiB6ZXJvMih3b3JkKSB7XG5cdCAgaWYgKHdvcmQubGVuZ3RoID09PSAxKVxuXHQgICAgcmV0dXJuICcwJyArIHdvcmQ7XG5cdCAgZWxzZVxuXHQgICAgcmV0dXJuIHdvcmQ7XG5cdH1cblx0dmFyIHplcm8yXzEgPSB6ZXJvMjtcblxuXHRmdW5jdGlvbiB6ZXJvOCh3b3JkKSB7XG5cdCAgaWYgKHdvcmQubGVuZ3RoID09PSA3KVxuXHQgICAgcmV0dXJuICcwJyArIHdvcmQ7XG5cdCAgZWxzZSBpZiAod29yZC5sZW5ndGggPT09IDYpXG5cdCAgICByZXR1cm4gJzAwJyArIHdvcmQ7XG5cdCAgZWxzZSBpZiAod29yZC5sZW5ndGggPT09IDUpXG5cdCAgICByZXR1cm4gJzAwMCcgKyB3b3JkO1xuXHQgIGVsc2UgaWYgKHdvcmQubGVuZ3RoID09PSA0KVxuXHQgICAgcmV0dXJuICcwMDAwJyArIHdvcmQ7XG5cdCAgZWxzZSBpZiAod29yZC5sZW5ndGggPT09IDMpXG5cdCAgICByZXR1cm4gJzAwMDAwJyArIHdvcmQ7XG5cdCAgZWxzZSBpZiAod29yZC5sZW5ndGggPT09IDIpXG5cdCAgICByZXR1cm4gJzAwMDAwMCcgKyB3b3JkO1xuXHQgIGVsc2UgaWYgKHdvcmQubGVuZ3RoID09PSAxKVxuXHQgICAgcmV0dXJuICcwMDAwMDAwJyArIHdvcmQ7XG5cdCAgZWxzZVxuXHQgICAgcmV0dXJuIHdvcmQ7XG5cdH1cblx0dmFyIHplcm84XzEgPSB6ZXJvODtcblxuXHRmdW5jdGlvbiBqb2luMzIobXNnLCBzdGFydCwgZW5kLCBlbmRpYW4pIHtcblx0ICB2YXIgbGVuID0gZW5kIC0gc3RhcnQ7XG5cdCAgbWluaW1hbGlzdGljQXNzZXJ0KGxlbiAlIDQgPT09IDApO1xuXHQgIHZhciByZXMgPSBuZXcgQXJyYXkobGVuIC8gNCk7XG5cdCAgZm9yICh2YXIgaSA9IDAsIGsgPSBzdGFydDsgaSA8IHJlcy5sZW5ndGg7IGkrKywgayArPSA0KSB7XG5cdCAgICB2YXIgdztcblx0ICAgIGlmIChlbmRpYW4gPT09ICdiaWcnKVxuXHQgICAgICB3ID0gKG1zZ1trXSA8PCAyNCkgfCAobXNnW2sgKyAxXSA8PCAxNikgfCAobXNnW2sgKyAyXSA8PCA4KSB8IG1zZ1trICsgM107XG5cdCAgICBlbHNlXG5cdCAgICAgIHcgPSAobXNnW2sgKyAzXSA8PCAyNCkgfCAobXNnW2sgKyAyXSA8PCAxNikgfCAobXNnW2sgKyAxXSA8PCA4KSB8IG1zZ1trXTtcblx0ICAgIHJlc1tpXSA9IHcgPj4+IDA7XG5cdCAgfVxuXHQgIHJldHVybiByZXM7XG5cdH1cblx0dmFyIGpvaW4zMl8xID0gam9pbjMyO1xuXG5cdGZ1bmN0aW9uIHNwbGl0MzIobXNnLCBlbmRpYW4pIHtcblx0ICB2YXIgcmVzID0gbmV3IEFycmF5KG1zZy5sZW5ndGggKiA0KTtcblx0ICBmb3IgKHZhciBpID0gMCwgayA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyssIGsgKz0gNCkge1xuXHQgICAgdmFyIG0gPSBtc2dbaV07XG5cdCAgICBpZiAoZW5kaWFuID09PSAnYmlnJykge1xuXHQgICAgICByZXNba10gPSBtID4+PiAyNDtcblx0ICAgICAgcmVzW2sgKyAxXSA9IChtID4+PiAxNikgJiAweGZmO1xuXHQgICAgICByZXNbayArIDJdID0gKG0gPj4+IDgpICYgMHhmZjtcblx0ICAgICAgcmVzW2sgKyAzXSA9IG0gJiAweGZmO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmVzW2sgKyAzXSA9IG0gPj4+IDI0O1xuXHQgICAgICByZXNbayArIDJdID0gKG0gPj4+IDE2KSAmIDB4ZmY7XG5cdCAgICAgIHJlc1trICsgMV0gPSAobSA+Pj4gOCkgJiAweGZmO1xuXHQgICAgICByZXNba10gPSBtICYgMHhmZjtcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIHJlcztcblx0fVxuXHR2YXIgc3BsaXQzMl8xID0gc3BsaXQzMjtcblxuXHRmdW5jdGlvbiByb3RyMzIodywgYikge1xuXHQgIHJldHVybiAodyA+Pj4gYikgfCAodyA8PCAoMzIgLSBiKSk7XG5cdH1cblx0dmFyIHJvdHIzMl8xID0gcm90cjMyO1xuXG5cdGZ1bmN0aW9uIHJvdGwzMih3LCBiKSB7XG5cdCAgcmV0dXJuICh3IDw8IGIpIHwgKHcgPj4+ICgzMiAtIGIpKTtcblx0fVxuXHR2YXIgcm90bDMyXzEgPSByb3RsMzI7XG5cblx0ZnVuY3Rpb24gc3VtMzIoYSwgYikge1xuXHQgIHJldHVybiAoYSArIGIpID4+PiAwO1xuXHR9XG5cdHZhciBzdW0zMl8xID0gc3VtMzI7XG5cblx0ZnVuY3Rpb24gc3VtMzJfMyhhLCBiLCBjKSB7XG5cdCAgcmV0dXJuIChhICsgYiArIGMpID4+PiAwO1xuXHR9XG5cdHZhciBzdW0zMl8zXzEgPSBzdW0zMl8zO1xuXG5cdGZ1bmN0aW9uIHN1bTMyXzQoYSwgYiwgYywgZCkge1xuXHQgIHJldHVybiAoYSArIGIgKyBjICsgZCkgPj4+IDA7XG5cdH1cblx0dmFyIHN1bTMyXzRfMSA9IHN1bTMyXzQ7XG5cblx0ZnVuY3Rpb24gc3VtMzJfNShhLCBiLCBjLCBkLCBlKSB7XG5cdCAgcmV0dXJuIChhICsgYiArIGMgKyBkICsgZSkgPj4+IDA7XG5cdH1cblx0dmFyIHN1bTMyXzVfMSA9IHN1bTMyXzU7XG5cblx0ZnVuY3Rpb24gc3VtNjQoYnVmLCBwb3MsIGFoLCBhbCkge1xuXHQgIHZhciBiaCA9IGJ1Zltwb3NdO1xuXHQgIHZhciBibCA9IGJ1Zltwb3MgKyAxXTtcblxuXHQgIHZhciBsbyA9IChhbCArIGJsKSA+Pj4gMDtcblx0ICB2YXIgaGkgPSAobG8gPCBhbCA/IDEgOiAwKSArIGFoICsgYmg7XG5cdCAgYnVmW3Bvc10gPSBoaSA+Pj4gMDtcblx0ICBidWZbcG9zICsgMV0gPSBsbztcblx0fVxuXHR2YXIgc3VtNjRfMSA9IHN1bTY0O1xuXG5cdGZ1bmN0aW9uIHN1bTY0X2hpKGFoLCBhbCwgYmgsIGJsKSB7XG5cdCAgdmFyIGxvID0gKGFsICsgYmwpID4+PiAwO1xuXHQgIHZhciBoaSA9IChsbyA8IGFsID8gMSA6IDApICsgYWggKyBiaDtcblx0ICByZXR1cm4gaGkgPj4+IDA7XG5cdH1cblx0dmFyIHN1bTY0X2hpXzEgPSBzdW02NF9oaTtcblxuXHRmdW5jdGlvbiBzdW02NF9sbyhhaCwgYWwsIGJoLCBibCkge1xuXHQgIHZhciBsbyA9IGFsICsgYmw7XG5cdCAgcmV0dXJuIGxvID4+PiAwO1xuXHR9XG5cdHZhciBzdW02NF9sb18xID0gc3VtNjRfbG87XG5cblx0ZnVuY3Rpb24gc3VtNjRfNF9oaShhaCwgYWwsIGJoLCBibCwgY2gsIGNsLCBkaCwgZGwpIHtcblx0ICB2YXIgY2FycnkgPSAwO1xuXHQgIHZhciBsbyA9IGFsO1xuXHQgIGxvID0gKGxvICsgYmwpID4+PiAwO1xuXHQgIGNhcnJ5ICs9IGxvIDwgYWwgPyAxIDogMDtcblx0ICBsbyA9IChsbyArIGNsKSA+Pj4gMDtcblx0ICBjYXJyeSArPSBsbyA8IGNsID8gMSA6IDA7XG5cdCAgbG8gPSAobG8gKyBkbCkgPj4+IDA7XG5cdCAgY2FycnkgKz0gbG8gPCBkbCA/IDEgOiAwO1xuXG5cdCAgdmFyIGhpID0gYWggKyBiaCArIGNoICsgZGggKyBjYXJyeTtcblx0ICByZXR1cm4gaGkgPj4+IDA7XG5cdH1cblx0dmFyIHN1bTY0XzRfaGlfMSA9IHN1bTY0XzRfaGk7XG5cblx0ZnVuY3Rpb24gc3VtNjRfNF9sbyhhaCwgYWwsIGJoLCBibCwgY2gsIGNsLCBkaCwgZGwpIHtcblx0ICB2YXIgbG8gPSBhbCArIGJsICsgY2wgKyBkbDtcblx0ICByZXR1cm4gbG8gPj4+IDA7XG5cdH1cblx0dmFyIHN1bTY0XzRfbG9fMSA9IHN1bTY0XzRfbG87XG5cblx0ZnVuY3Rpb24gc3VtNjRfNV9oaShhaCwgYWwsIGJoLCBibCwgY2gsIGNsLCBkaCwgZGwsIGVoLCBlbCkge1xuXHQgIHZhciBjYXJyeSA9IDA7XG5cdCAgdmFyIGxvID0gYWw7XG5cdCAgbG8gPSAobG8gKyBibCkgPj4+IDA7XG5cdCAgY2FycnkgKz0gbG8gPCBhbCA/IDEgOiAwO1xuXHQgIGxvID0gKGxvICsgY2wpID4+PiAwO1xuXHQgIGNhcnJ5ICs9IGxvIDwgY2wgPyAxIDogMDtcblx0ICBsbyA9IChsbyArIGRsKSA+Pj4gMDtcblx0ICBjYXJyeSArPSBsbyA8IGRsID8gMSA6IDA7XG5cdCAgbG8gPSAobG8gKyBlbCkgPj4+IDA7XG5cdCAgY2FycnkgKz0gbG8gPCBlbCA/IDEgOiAwO1xuXG5cdCAgdmFyIGhpID0gYWggKyBiaCArIGNoICsgZGggKyBlaCArIGNhcnJ5O1xuXHQgIHJldHVybiBoaSA+Pj4gMDtcblx0fVxuXHR2YXIgc3VtNjRfNV9oaV8xID0gc3VtNjRfNV9oaTtcblxuXHRmdW5jdGlvbiBzdW02NF81X2xvKGFoLCBhbCwgYmgsIGJsLCBjaCwgY2wsIGRoLCBkbCwgZWgsIGVsKSB7XG5cdCAgdmFyIGxvID0gYWwgKyBibCArIGNsICsgZGwgKyBlbDtcblxuXHQgIHJldHVybiBsbyA+Pj4gMDtcblx0fVxuXHR2YXIgc3VtNjRfNV9sb18xID0gc3VtNjRfNV9sbztcblxuXHRmdW5jdGlvbiByb3RyNjRfaGkoYWgsIGFsLCBudW0pIHtcblx0ICB2YXIgciA9IChhbCA8PCAoMzIgLSBudW0pKSB8IChhaCA+Pj4gbnVtKTtcblx0ICByZXR1cm4gciA+Pj4gMDtcblx0fVxuXHR2YXIgcm90cjY0X2hpXzEgPSByb3RyNjRfaGk7XG5cblx0ZnVuY3Rpb24gcm90cjY0X2xvKGFoLCBhbCwgbnVtKSB7XG5cdCAgdmFyIHIgPSAoYWggPDwgKDMyIC0gbnVtKSkgfCAoYWwgPj4+IG51bSk7XG5cdCAgcmV0dXJuIHIgPj4+IDA7XG5cdH1cblx0dmFyIHJvdHI2NF9sb18xID0gcm90cjY0X2xvO1xuXG5cdGZ1bmN0aW9uIHNocjY0X2hpKGFoLCBhbCwgbnVtKSB7XG5cdCAgcmV0dXJuIGFoID4+PiBudW07XG5cdH1cblx0dmFyIHNocjY0X2hpXzEgPSBzaHI2NF9oaTtcblxuXHRmdW5jdGlvbiBzaHI2NF9sbyhhaCwgYWwsIG51bSkge1xuXHQgIHZhciByID0gKGFoIDw8ICgzMiAtIG51bSkpIHwgKGFsID4+PiBudW0pO1xuXHQgIHJldHVybiByID4+PiAwO1xuXHR9XG5cdHZhciBzaHI2NF9sb18xID0gc2hyNjRfbG87XG5cblx0dmFyIHV0aWxzID0ge1xuXHRcdGluaGVyaXRzOiBpbmhlcml0c18xLFxuXHRcdHRvQXJyYXk6IHRvQXJyYXlfMSxcblx0XHR0b0hleDogdG9IZXhfMSxcblx0XHRodG9ubDogaHRvbmxfMSxcblx0XHR0b0hleDMyOiB0b0hleDMyXzEsXG5cdFx0emVybzI6IHplcm8yXzEsXG5cdFx0emVybzg6IHplcm84XzEsXG5cdFx0am9pbjMyOiBqb2luMzJfMSxcblx0XHRzcGxpdDMyOiBzcGxpdDMyXzEsXG5cdFx0cm90cjMyOiByb3RyMzJfMSxcblx0XHRyb3RsMzI6IHJvdGwzMl8xLFxuXHRcdHN1bTMyOiBzdW0zMl8xLFxuXHRcdHN1bTMyXzM6IHN1bTMyXzNfMSxcblx0XHRzdW0zMl80OiBzdW0zMl80XzEsXG5cdFx0c3VtMzJfNTogc3VtMzJfNV8xLFxuXHRcdHN1bTY0OiBzdW02NF8xLFxuXHRcdHN1bTY0X2hpOiBzdW02NF9oaV8xLFxuXHRcdHN1bTY0X2xvOiBzdW02NF9sb18xLFxuXHRcdHN1bTY0XzRfaGk6IHN1bTY0XzRfaGlfMSxcblx0XHRzdW02NF80X2xvOiBzdW02NF80X2xvXzEsXG5cdFx0c3VtNjRfNV9oaTogc3VtNjRfNV9oaV8xLFxuXHRcdHN1bTY0XzVfbG86IHN1bTY0XzVfbG9fMSxcblx0XHRyb3RyNjRfaGk6IHJvdHI2NF9oaV8xLFxuXHRcdHJvdHI2NF9sbzogcm90cjY0X2xvXzEsXG5cdFx0c2hyNjRfaGk6IHNocjY0X2hpXzEsXG5cdFx0c2hyNjRfbG86IHNocjY0X2xvXzFcblx0fTtcblxuXHQndXNlIHN0cmljdCc7XG5cblxuXG5cblx0ZnVuY3Rpb24gQmxvY2tIYXNoKCkge1xuXHQgIHRoaXMucGVuZGluZyA9IG51bGw7XG5cdCAgdGhpcy5wZW5kaW5nVG90YWwgPSAwO1xuXHQgIHRoaXMuYmxvY2tTaXplID0gdGhpcy5jb25zdHJ1Y3Rvci5ibG9ja1NpemU7XG5cdCAgdGhpcy5vdXRTaXplID0gdGhpcy5jb25zdHJ1Y3Rvci5vdXRTaXplO1xuXHQgIHRoaXMuaG1hY1N0cmVuZ3RoID0gdGhpcy5jb25zdHJ1Y3Rvci5obWFjU3RyZW5ndGg7XG5cdCAgdGhpcy5wYWRMZW5ndGggPSB0aGlzLmNvbnN0cnVjdG9yLnBhZExlbmd0aCAvIDg7XG5cdCAgdGhpcy5lbmRpYW4gPSAnYmlnJztcblxuXHQgIHRoaXMuX2RlbHRhOCA9IHRoaXMuYmxvY2tTaXplIC8gODtcblx0ICB0aGlzLl9kZWx0YTMyID0gdGhpcy5ibG9ja1NpemUgLyAzMjtcblx0fVxuXHR2YXIgQmxvY2tIYXNoXzEgPSBCbG9ja0hhc2g7XG5cblx0QmxvY2tIYXNoLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUobXNnLCBlbmMpIHtcblx0ICAvLyBDb252ZXJ0IG1lc3NhZ2UgdG8gYXJyYXksIHBhZCBpdCwgYW5kIGpvaW4gaW50byAzMmJpdCBibG9ja3Ncblx0ICBtc2cgPSB1dGlscy50b0FycmF5KG1zZywgZW5jKTtcblx0ICBpZiAoIXRoaXMucGVuZGluZylcblx0ICAgIHRoaXMucGVuZGluZyA9IG1zZztcblx0ICBlbHNlXG5cdCAgICB0aGlzLnBlbmRpbmcgPSB0aGlzLnBlbmRpbmcuY29uY2F0KG1zZyk7XG5cdCAgdGhpcy5wZW5kaW5nVG90YWwgKz0gbXNnLmxlbmd0aDtcblxuXHQgIC8vIEVub3VnaCBkYXRhLCB0cnkgdXBkYXRpbmdcblx0ICBpZiAodGhpcy5wZW5kaW5nLmxlbmd0aCA+PSB0aGlzLl9kZWx0YTgpIHtcblx0ICAgIG1zZyA9IHRoaXMucGVuZGluZztcblxuXHQgICAgLy8gUHJvY2VzcyBwZW5kaW5nIGRhdGEgaW4gYmxvY2tzXG5cdCAgICB2YXIgciA9IG1zZy5sZW5ndGggJSB0aGlzLl9kZWx0YTg7XG5cdCAgICB0aGlzLnBlbmRpbmcgPSBtc2cuc2xpY2UobXNnLmxlbmd0aCAtIHIsIG1zZy5sZW5ndGgpO1xuXHQgICAgaWYgKHRoaXMucGVuZGluZy5sZW5ndGggPT09IDApXG5cdCAgICAgIHRoaXMucGVuZGluZyA9IG51bGw7XG5cblx0ICAgIG1zZyA9IHV0aWxzLmpvaW4zMihtc2csIDAsIG1zZy5sZW5ndGggLSByLCB0aGlzLmVuZGlhbik7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkgKz0gdGhpcy5fZGVsdGEzMilcblx0ICAgICAgdGhpcy5fdXBkYXRlKG1zZywgaSwgaSArIHRoaXMuX2RlbHRhMzIpO1xuXHQgIH1cblxuXHQgIHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdEJsb2NrSGFzaC5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gZGlnZXN0KGVuYykge1xuXHQgIHRoaXMudXBkYXRlKHRoaXMuX3BhZCgpKTtcblx0ICBtaW5pbWFsaXN0aWNBc3NlcnQodGhpcy5wZW5kaW5nID09PSBudWxsKTtcblxuXHQgIHJldHVybiB0aGlzLl9kaWdlc3QoZW5jKTtcblx0fTtcblxuXHRCbG9ja0hhc2gucHJvdG90eXBlLl9wYWQgPSBmdW5jdGlvbiBwYWQoKSB7XG5cdCAgdmFyIGxlbiA9IHRoaXMucGVuZGluZ1RvdGFsO1xuXHQgIHZhciBieXRlcyA9IHRoaXMuX2RlbHRhODtcblx0ICB2YXIgayA9IGJ5dGVzIC0gKChsZW4gKyB0aGlzLnBhZExlbmd0aCkgJSBieXRlcyk7XG5cdCAgdmFyIHJlcyA9IG5ldyBBcnJheShrICsgdGhpcy5wYWRMZW5ndGgpO1xuXHQgIHJlc1swXSA9IDB4ODA7XG5cdCAgZm9yICh2YXIgaSA9IDE7IGkgPCBrOyBpKyspXG5cdCAgICByZXNbaV0gPSAwO1xuXG5cdCAgLy8gQXBwZW5kIGxlbmd0aFxuXHQgIGxlbiA8PD0gMztcblx0ICBpZiAodGhpcy5lbmRpYW4gPT09ICdiaWcnKSB7XG5cdCAgICBmb3IgKHZhciB0ID0gODsgdCA8IHRoaXMucGFkTGVuZ3RoOyB0KyspXG5cdCAgICAgIHJlc1tpKytdID0gMDtcblxuXHQgICAgcmVzW2krK10gPSAwO1xuXHQgICAgcmVzW2krK10gPSAwO1xuXHQgICAgcmVzW2krK10gPSAwO1xuXHQgICAgcmVzW2krK10gPSAwO1xuXHQgICAgcmVzW2krK10gPSAobGVuID4+PiAyNCkgJiAweGZmO1xuXHQgICAgcmVzW2krK10gPSAobGVuID4+PiAxNikgJiAweGZmO1xuXHQgICAgcmVzW2krK10gPSAobGVuID4+PiA4KSAmIDB4ZmY7XG5cdCAgICByZXNbaSsrXSA9IGxlbiAmIDB4ZmY7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHJlc1tpKytdID0gbGVuICYgMHhmZjtcblx0ICAgIHJlc1tpKytdID0gKGxlbiA+Pj4gOCkgJiAweGZmO1xuXHQgICAgcmVzW2krK10gPSAobGVuID4+PiAxNikgJiAweGZmO1xuXHQgICAgcmVzW2krK10gPSAobGVuID4+PiAyNCkgJiAweGZmO1xuXHQgICAgcmVzW2krK10gPSAwO1xuXHQgICAgcmVzW2krK10gPSAwO1xuXHQgICAgcmVzW2krK10gPSAwO1xuXHQgICAgcmVzW2krK10gPSAwO1xuXG5cdCAgICBmb3IgKHQgPSA4OyB0IDwgdGhpcy5wYWRMZW5ndGg7IHQrKylcblx0ICAgICAgcmVzW2krK10gPSAwO1xuXHQgIH1cblxuXHQgIHJldHVybiByZXM7XG5cdH07XG5cblx0dmFyIGNvbW1vbiA9IHtcblx0XHRCbG9ja0hhc2g6IEJsb2NrSGFzaF8xXG5cdH07XG5cblx0dmFyIF8xID0ge307XG5cblx0dmFyIF8yMjQgPSB7fTtcblxuXHQndXNlIHN0cmljdCc7XG5cblxuXHR2YXIgcm90cjMyJDEgPSB1dGlscy5yb3RyMzI7XG5cblx0ZnVuY3Rpb24gZnRfMShzLCB4LCB5LCB6KSB7XG5cdCAgaWYgKHMgPT09IDApXG5cdCAgICByZXR1cm4gY2gzMih4LCB5LCB6KTtcblx0ICBpZiAocyA9PT0gMSB8fCBzID09PSAzKVxuXHQgICAgcmV0dXJuIHAzMih4LCB5LCB6KTtcblx0ICBpZiAocyA9PT0gMilcblx0ICAgIHJldHVybiBtYWozMih4LCB5LCB6KTtcblx0fVxuXHR2YXIgZnRfMV8xID0gZnRfMTtcblxuXHRmdW5jdGlvbiBjaDMyKHgsIHksIHopIHtcblx0ICByZXR1cm4gKHggJiB5KSBeICgofngpICYgeik7XG5cdH1cblx0dmFyIGNoMzJfMSA9IGNoMzI7XG5cblx0ZnVuY3Rpb24gbWFqMzIoeCwgeSwgeikge1xuXHQgIHJldHVybiAoeCAmIHkpIF4gKHggJiB6KSBeICh5ICYgeik7XG5cdH1cblx0dmFyIG1hajMyXzEgPSBtYWozMjtcblxuXHRmdW5jdGlvbiBwMzIoeCwgeSwgeikge1xuXHQgIHJldHVybiB4IF4geSBeIHo7XG5cdH1cblx0dmFyIHAzMl8xID0gcDMyO1xuXG5cdGZ1bmN0aW9uIHMwXzI1Nih4KSB7XG5cdCAgcmV0dXJuIHJvdHIzMiQxKHgsIDIpIF4gcm90cjMyJDEoeCwgMTMpIF4gcm90cjMyJDEoeCwgMjIpO1xuXHR9XG5cdHZhciBzMF8yNTZfMSA9IHMwXzI1NjtcblxuXHRmdW5jdGlvbiBzMV8yNTYoeCkge1xuXHQgIHJldHVybiByb3RyMzIkMSh4LCA2KSBeIHJvdHIzMiQxKHgsIDExKSBeIHJvdHIzMiQxKHgsIDI1KTtcblx0fVxuXHR2YXIgczFfMjU2XzEgPSBzMV8yNTY7XG5cblx0ZnVuY3Rpb24gZzBfMjU2KHgpIHtcblx0ICByZXR1cm4gcm90cjMyJDEoeCwgNykgXiByb3RyMzIkMSh4LCAxOCkgXiAoeCA+Pj4gMyk7XG5cdH1cblx0dmFyIGcwXzI1Nl8xID0gZzBfMjU2O1xuXG5cdGZ1bmN0aW9uIGcxXzI1Nih4KSB7XG5cdCAgcmV0dXJuIHJvdHIzMiQxKHgsIDE3KSBeIHJvdHIzMiQxKHgsIDE5KSBeICh4ID4+PiAxMCk7XG5cdH1cblx0dmFyIGcxXzI1Nl8xID0gZzFfMjU2O1xuXG5cdHZhciBjb21tb24kMSA9IHtcblx0XHRmdF8xOiBmdF8xXzEsXG5cdFx0Y2gzMjogY2gzMl8xLFxuXHRcdG1hajMyOiBtYWozMl8xLFxuXHRcdHAzMjogcDMyXzEsXG5cdFx0czBfMjU2OiBzMF8yNTZfMSxcblx0XHRzMV8yNTY6IHMxXzI1Nl8xLFxuXHRcdGcwXzI1NjogZzBfMjU2XzEsXG5cdFx0ZzFfMjU2OiBnMV8yNTZfMVxuXHR9O1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXG5cblxuXG5cblx0dmFyIHN1bTMyJDEgPSB1dGlscy5zdW0zMjtcblx0dmFyIHN1bTMyXzQkMSA9IHV0aWxzLnN1bTMyXzQ7XG5cdHZhciBzdW0zMl81JDEgPSB1dGlscy5zdW0zMl81O1xuXHR2YXIgY2gzMiQxID0gY29tbW9uJDEuY2gzMjtcblx0dmFyIG1hajMyJDEgPSBjb21tb24kMS5tYWozMjtcblx0dmFyIHMwXzI1NiQxID0gY29tbW9uJDEuczBfMjU2O1xuXHR2YXIgczFfMjU2JDEgPSBjb21tb24kMS5zMV8yNTY7XG5cdHZhciBnMF8yNTYkMSA9IGNvbW1vbiQxLmcwXzI1Njtcblx0dmFyIGcxXzI1NiQxID0gY29tbW9uJDEuZzFfMjU2O1xuXG5cdHZhciBCbG9ja0hhc2gkMSA9IGNvbW1vbi5CbG9ja0hhc2g7XG5cblx0dmFyIHNoYTI1Nl9LID0gW1xuXHQgIDB4NDI4YTJmOTgsIDB4NzEzNzQ0OTEsIDB4YjVjMGZiY2YsIDB4ZTliNWRiYTUsXG5cdCAgMHgzOTU2YzI1YiwgMHg1OWYxMTFmMSwgMHg5MjNmODJhNCwgMHhhYjFjNWVkNSxcblx0ICAweGQ4MDdhYTk4LCAweDEyODM1YjAxLCAweDI0MzE4NWJlLCAweDU1MGM3ZGMzLFxuXHQgIDB4NzJiZTVkNzQsIDB4ODBkZWIxZmUsIDB4OWJkYzA2YTcsIDB4YzE5YmYxNzQsXG5cdCAgMHhlNDliNjljMSwgMHhlZmJlNDc4NiwgMHgwZmMxOWRjNiwgMHgyNDBjYTFjYyxcblx0ICAweDJkZTkyYzZmLCAweDRhNzQ4NGFhLCAweDVjYjBhOWRjLCAweDc2Zjk4OGRhLFxuXHQgIDB4OTgzZTUxNTIsIDB4YTgzMWM2NmQsIDB4YjAwMzI3YzgsIDB4YmY1OTdmYzcsXG5cdCAgMHhjNmUwMGJmMywgMHhkNWE3OTE0NywgMHgwNmNhNjM1MSwgMHgxNDI5Mjk2Nyxcblx0ICAweDI3YjcwYTg1LCAweDJlMWIyMTM4LCAweDRkMmM2ZGZjLCAweDUzMzgwZDEzLFxuXHQgIDB4NjUwYTczNTQsIDB4NzY2YTBhYmIsIDB4ODFjMmM5MmUsIDB4OTI3MjJjODUsXG5cdCAgMHhhMmJmZThhMSwgMHhhODFhNjY0YiwgMHhjMjRiOGI3MCwgMHhjNzZjNTFhMyxcblx0ICAweGQxOTJlODE5LCAweGQ2OTkwNjI0LCAweGY0MGUzNTg1LCAweDEwNmFhMDcwLFxuXHQgIDB4MTlhNGMxMTYsIDB4MWUzNzZjMDgsIDB4Mjc0ODc3NGMsIDB4MzRiMGJjYjUsXG5cdCAgMHgzOTFjMGNiMywgMHg0ZWQ4YWE0YSwgMHg1YjljY2E0ZiwgMHg2ODJlNmZmMyxcblx0ICAweDc0OGY4MmVlLCAweDc4YTU2MzZmLCAweDg0Yzg3ODE0LCAweDhjYzcwMjA4LFxuXHQgIDB4OTBiZWZmZmEsIDB4YTQ1MDZjZWIsIDB4YmVmOWEzZjcsIDB4YzY3MTc4ZjJcblx0XTtcblxuXHRmdW5jdGlvbiBTSEEyNTYoKSB7XG5cdCAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNIQTI1NikpXG5cdCAgICByZXR1cm4gbmV3IFNIQTI1NigpO1xuXG5cdCAgQmxvY2tIYXNoJDEuY2FsbCh0aGlzKTtcblx0ICB0aGlzLmggPSBbXG5cdCAgICAweDZhMDllNjY3LCAweGJiNjdhZTg1LCAweDNjNmVmMzcyLCAweGE1NGZmNTNhLFxuXHQgICAgMHg1MTBlNTI3ZiwgMHg5YjA1Njg4YywgMHgxZjgzZDlhYiwgMHg1YmUwY2QxOVxuXHQgIF07XG5cdCAgdGhpcy5rID0gc2hhMjU2X0s7XG5cdCAgdGhpcy5XID0gbmV3IEFycmF5KDY0KTtcblx0fVxuXHR1dGlscy5pbmhlcml0cyhTSEEyNTYsIEJsb2NrSGFzaCQxKTtcblx0dmFyIF8yNTYgPSBTSEEyNTY7XG5cblx0U0hBMjU2LmJsb2NrU2l6ZSA9IDUxMjtcblx0U0hBMjU2Lm91dFNpemUgPSAyNTY7XG5cdFNIQTI1Ni5obWFjU3RyZW5ndGggPSAxOTI7XG5cdFNIQTI1Ni5wYWRMZW5ndGggPSA2NDtcblxuXHRTSEEyNTYucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiBfdXBkYXRlKG1zZywgc3RhcnQpIHtcblx0ICB2YXIgVyA9IHRoaXMuVztcblxuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKylcblx0ICAgIFdbaV0gPSBtc2dbc3RhcnQgKyBpXTtcblx0ICBmb3IgKDsgaSA8IFcubGVuZ3RoOyBpKyspXG5cdCAgICBXW2ldID0gc3VtMzJfNCQxKGcxXzI1NiQxKFdbaSAtIDJdKSwgV1tpIC0gN10sIGcwXzI1NiQxKFdbaSAtIDE1XSksIFdbaSAtIDE2XSk7XG5cblx0ICB2YXIgYSA9IHRoaXMuaFswXTtcblx0ICB2YXIgYiA9IHRoaXMuaFsxXTtcblx0ICB2YXIgYyA9IHRoaXMuaFsyXTtcblx0ICB2YXIgZCA9IHRoaXMuaFszXTtcblx0ICB2YXIgZSA9IHRoaXMuaFs0XTtcblx0ICB2YXIgZiA9IHRoaXMuaFs1XTtcblx0ICB2YXIgZyA9IHRoaXMuaFs2XTtcblx0ICB2YXIgaCA9IHRoaXMuaFs3XTtcblxuXHQgIG1pbmltYWxpc3RpY0Fzc2VydCh0aGlzLmsubGVuZ3RoID09PSBXLmxlbmd0aCk7XG5cdCAgZm9yIChpID0gMDsgaSA8IFcubGVuZ3RoOyBpKyspIHtcblx0ICAgIHZhciBUMSA9IHN1bTMyXzUkMShoLCBzMV8yNTYkMShlKSwgY2gzMiQxKGUsIGYsIGcpLCB0aGlzLmtbaV0sIFdbaV0pO1xuXHQgICAgdmFyIFQyID0gc3VtMzIkMShzMF8yNTYkMShhKSwgbWFqMzIkMShhLCBiLCBjKSk7XG5cdCAgICBoID0gZztcblx0ICAgIGcgPSBmO1xuXHQgICAgZiA9IGU7XG5cdCAgICBlID0gc3VtMzIkMShkLCBUMSk7XG5cdCAgICBkID0gYztcblx0ICAgIGMgPSBiO1xuXHQgICAgYiA9IGE7XG5cdCAgICBhID0gc3VtMzIkMShUMSwgVDIpO1xuXHQgIH1cblxuXHQgIHRoaXMuaFswXSA9IHN1bTMyJDEodGhpcy5oWzBdLCBhKTtcblx0ICB0aGlzLmhbMV0gPSBzdW0zMiQxKHRoaXMuaFsxXSwgYik7XG5cdCAgdGhpcy5oWzJdID0gc3VtMzIkMSh0aGlzLmhbMl0sIGMpO1xuXHQgIHRoaXMuaFszXSA9IHN1bTMyJDEodGhpcy5oWzNdLCBkKTtcblx0ICB0aGlzLmhbNF0gPSBzdW0zMiQxKHRoaXMuaFs0XSwgZSk7XG5cdCAgdGhpcy5oWzVdID0gc3VtMzIkMSh0aGlzLmhbNV0sIGYpO1xuXHQgIHRoaXMuaFs2XSA9IHN1bTMyJDEodGhpcy5oWzZdLCBnKTtcblx0ICB0aGlzLmhbN10gPSBzdW0zMiQxKHRoaXMuaFs3XSwgaCk7XG5cdH07XG5cblx0U0hBMjU2LnByb3RvdHlwZS5fZGlnZXN0ID0gZnVuY3Rpb24gZGlnZXN0KGVuYykge1xuXHQgIGlmIChlbmMgPT09ICdoZXgnKVxuXHQgICAgcmV0dXJuIHV0aWxzLnRvSGV4MzIodGhpcy5oLCAnYmlnJyk7XG5cdCAgZWxzZVxuXHQgICAgcmV0dXJuIHV0aWxzLnNwbGl0MzIodGhpcy5oLCAnYmlnJyk7XG5cdH07XG5cblx0dmFyIF8zODQgPSB7fTtcblxuXHQndXNlIHN0cmljdCc7XG5cblxuXG5cblxuXHR2YXIgcm90cjY0X2hpJDEgPSB1dGlscy5yb3RyNjRfaGk7XG5cdHZhciByb3RyNjRfbG8kMSA9IHV0aWxzLnJvdHI2NF9sbztcblx0dmFyIHNocjY0X2hpJDEgPSB1dGlscy5zaHI2NF9oaTtcblx0dmFyIHNocjY0X2xvJDEgPSB1dGlscy5zaHI2NF9sbztcblx0dmFyIHN1bTY0JDEgPSB1dGlscy5zdW02NDtcblx0dmFyIHN1bTY0X2hpJDEgPSB1dGlscy5zdW02NF9oaTtcblx0dmFyIHN1bTY0X2xvJDEgPSB1dGlscy5zdW02NF9sbztcblx0dmFyIHN1bTY0XzRfaGkkMSA9IHV0aWxzLnN1bTY0XzRfaGk7XG5cdHZhciBzdW02NF80X2xvJDEgPSB1dGlscy5zdW02NF80X2xvO1xuXHR2YXIgc3VtNjRfNV9oaSQxID0gdXRpbHMuc3VtNjRfNV9oaTtcblx0dmFyIHN1bTY0XzVfbG8kMSA9IHV0aWxzLnN1bTY0XzVfbG87XG5cblx0dmFyIEJsb2NrSGFzaCQyID0gY29tbW9uLkJsb2NrSGFzaDtcblxuXHR2YXIgc2hhNTEyX0sgPSBbXG5cdCAgMHg0MjhhMmY5OCwgMHhkNzI4YWUyMiwgMHg3MTM3NDQ5MSwgMHgyM2VmNjVjZCxcblx0ICAweGI1YzBmYmNmLCAweGVjNGQzYjJmLCAweGU5YjVkYmE1LCAweDgxODlkYmJjLFxuXHQgIDB4Mzk1NmMyNWIsIDB4ZjM0OGI1MzgsIDB4NTlmMTExZjEsIDB4YjYwNWQwMTksXG5cdCAgMHg5MjNmODJhNCwgMHhhZjE5NGY5YiwgMHhhYjFjNWVkNSwgMHhkYTZkODExOCxcblx0ICAweGQ4MDdhYTk4LCAweGEzMDMwMjQyLCAweDEyODM1YjAxLCAweDQ1NzA2ZmJlLFxuXHQgIDB4MjQzMTg1YmUsIDB4NGVlNGIyOGMsIDB4NTUwYzdkYzMsIDB4ZDVmZmI0ZTIsXG5cdCAgMHg3MmJlNWQ3NCwgMHhmMjdiODk2ZiwgMHg4MGRlYjFmZSwgMHgzYjE2OTZiMSxcblx0ICAweDliZGMwNmE3LCAweDI1YzcxMjM1LCAweGMxOWJmMTc0LCAweGNmNjkyNjk0LFxuXHQgIDB4ZTQ5YjY5YzEsIDB4OWVmMTRhZDIsIDB4ZWZiZTQ3ODYsIDB4Mzg0ZjI1ZTMsXG5cdCAgMHgwZmMxOWRjNiwgMHg4YjhjZDViNSwgMHgyNDBjYTFjYywgMHg3N2FjOWM2NSxcblx0ICAweDJkZTkyYzZmLCAweDU5MmIwMjc1LCAweDRhNzQ4NGFhLCAweDZlYTZlNDgzLFxuXHQgIDB4NWNiMGE5ZGMsIDB4YmQ0MWZiZDQsIDB4NzZmOTg4ZGEsIDB4ODMxMTUzYjUsXG5cdCAgMHg5ODNlNTE1MiwgMHhlZTY2ZGZhYiwgMHhhODMxYzY2ZCwgMHgyZGI0MzIxMCxcblx0ICAweGIwMDMyN2M4LCAweDk4ZmIyMTNmLCAweGJmNTk3ZmM3LCAweGJlZWYwZWU0LFxuXHQgIDB4YzZlMDBiZjMsIDB4M2RhODhmYzIsIDB4ZDVhNzkxNDcsIDB4OTMwYWE3MjUsXG5cdCAgMHgwNmNhNjM1MSwgMHhlMDAzODI2ZiwgMHgxNDI5Mjk2NywgMHgwYTBlNmU3MCxcblx0ICAweDI3YjcwYTg1LCAweDQ2ZDIyZmZjLCAweDJlMWIyMTM4LCAweDVjMjZjOTI2LFxuXHQgIDB4NGQyYzZkZmMsIDB4NWFjNDJhZWQsIDB4NTMzODBkMTMsIDB4OWQ5NWIzZGYsXG5cdCAgMHg2NTBhNzM1NCwgMHg4YmFmNjNkZSwgMHg3NjZhMGFiYiwgMHgzYzc3YjJhOCxcblx0ICAweDgxYzJjOTJlLCAweDQ3ZWRhZWU2LCAweDkyNzIyYzg1LCAweDE0ODIzNTNiLFxuXHQgIDB4YTJiZmU4YTEsIDB4NGNmMTAzNjQsIDB4YTgxYTY2NGIsIDB4YmM0MjMwMDEsXG5cdCAgMHhjMjRiOGI3MCwgMHhkMGY4OTc5MSwgMHhjNzZjNTFhMywgMHgwNjU0YmUzMCxcblx0ICAweGQxOTJlODE5LCAweGQ2ZWY1MjE4LCAweGQ2OTkwNjI0LCAweDU1NjVhOTEwLFxuXHQgIDB4ZjQwZTM1ODUsIDB4NTc3MTIwMmEsIDB4MTA2YWEwNzAsIDB4MzJiYmQxYjgsXG5cdCAgMHgxOWE0YzExNiwgMHhiOGQyZDBjOCwgMHgxZTM3NmMwOCwgMHg1MTQxYWI1Myxcblx0ICAweDI3NDg3NzRjLCAweGRmOGVlYjk5LCAweDM0YjBiY2I1LCAweGUxOWI0OGE4LFxuXHQgIDB4MzkxYzBjYjMsIDB4YzVjOTVhNjMsIDB4NGVkOGFhNGEsIDB4ZTM0MThhY2IsXG5cdCAgMHg1YjljY2E0ZiwgMHg3NzYzZTM3MywgMHg2ODJlNmZmMywgMHhkNmIyYjhhMyxcblx0ICAweDc0OGY4MmVlLCAweDVkZWZiMmZjLCAweDc4YTU2MzZmLCAweDQzMTcyZjYwLFxuXHQgIDB4ODRjODc4MTQsIDB4YTFmMGFiNzIsIDB4OGNjNzAyMDgsIDB4MWE2NDM5ZWMsXG5cdCAgMHg5MGJlZmZmYSwgMHgyMzYzMWUyOCwgMHhhNDUwNmNlYiwgMHhkZTgyYmRlOSxcblx0ICAweGJlZjlhM2Y3LCAweGIyYzY3OTE1LCAweGM2NzE3OGYyLCAweGUzNzI1MzJiLFxuXHQgIDB4Y2EyNzNlY2UsIDB4ZWEyNjYxOWMsIDB4ZDE4NmI4YzcsIDB4MjFjMGMyMDcsXG5cdCAgMHhlYWRhN2RkNiwgMHhjZGUwZWIxZSwgMHhmNTdkNGY3ZiwgMHhlZTZlZDE3OCxcblx0ICAweDA2ZjA2N2FhLCAweDcyMTc2ZmJhLCAweDBhNjM3ZGM1LCAweGEyYzg5OGE2LFxuXHQgIDB4MTEzZjk4MDQsIDB4YmVmOTBkYWUsIDB4MWI3MTBiMzUsIDB4MTMxYzQ3MWIsXG5cdCAgMHgyOGRiNzdmNSwgMHgyMzA0N2Q4NCwgMHgzMmNhYWI3YiwgMHg0MGM3MjQ5Myxcblx0ICAweDNjOWViZTBhLCAweDE1YzliZWJjLCAweDQzMWQ2N2M0LCAweDljMTAwZDRjLFxuXHQgIDB4NGNjNWQ0YmUsIDB4Y2IzZTQyYjYsIDB4NTk3ZjI5OWMsIDB4ZmM2NTdlMmEsXG5cdCAgMHg1ZmNiNmZhYiwgMHgzYWQ2ZmFlYywgMHg2YzQ0MTk4YywgMHg0YTQ3NTgxN1xuXHRdO1xuXG5cdGZ1bmN0aW9uIFNIQTUxMigpIHtcblx0ICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU0hBNTEyKSlcblx0ICAgIHJldHVybiBuZXcgU0hBNTEyKCk7XG5cblx0ICBCbG9ja0hhc2gkMi5jYWxsKHRoaXMpO1xuXHQgIHRoaXMuaCA9IFtcblx0ICAgIDB4NmEwOWU2NjcsIDB4ZjNiY2M5MDgsXG5cdCAgICAweGJiNjdhZTg1LCAweDg0Y2FhNzNiLFxuXHQgICAgMHgzYzZlZjM3MiwgMHhmZTk0ZjgyYixcblx0ICAgIDB4YTU0ZmY1M2EsIDB4NWYxZDM2ZjEsXG5cdCAgICAweDUxMGU1MjdmLCAweGFkZTY4MmQxLFxuXHQgICAgMHg5YjA1Njg4YywgMHgyYjNlNmMxZixcblx0ICAgIDB4MWY4M2Q5YWIsIDB4ZmI0MWJkNmIsXG5cdCAgICAweDViZTBjZDE5LCAweDEzN2UyMTc5IF07XG5cdCAgdGhpcy5rID0gc2hhNTEyX0s7XG5cdCAgdGhpcy5XID0gbmV3IEFycmF5KDE2MCk7XG5cdH1cblx0dXRpbHMuaW5oZXJpdHMoU0hBNTEyLCBCbG9ja0hhc2gkMik7XG5cdHZhciBfNTEyID0gU0hBNTEyO1xuXG5cdFNIQTUxMi5ibG9ja1NpemUgPSAxMDI0O1xuXHRTSEE1MTIub3V0U2l6ZSA9IDUxMjtcblx0U0hBNTEyLmhtYWNTdHJlbmd0aCA9IDE5Mjtcblx0U0hBNTEyLnBhZExlbmd0aCA9IDEyODtcblxuXHRTSEE1MTIucHJvdG90eXBlLl9wcmVwYXJlQmxvY2sgPSBmdW5jdGlvbiBfcHJlcGFyZUJsb2NrKG1zZywgc3RhcnQpIHtcblx0ICB2YXIgVyA9IHRoaXMuVztcblxuXHQgIC8vIDMyIHggMzJiaXQgd29yZHNcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IDMyOyBpKyspXG5cdCAgICBXW2ldID0gbXNnW3N0YXJ0ICsgaV07XG5cdCAgZm9yICg7IGkgPCBXLmxlbmd0aDsgaSArPSAyKSB7XG5cdCAgICB2YXIgYzBfaGkgPSBnMV81MTJfaGkoV1tpIC0gNF0sIFdbaSAtIDNdKTsgIC8vIGkgLSAyXG5cdCAgICB2YXIgYzBfbG8gPSBnMV81MTJfbG8oV1tpIC0gNF0sIFdbaSAtIDNdKTtcblx0ICAgIHZhciBjMV9oaSA9IFdbaSAtIDE0XTsgIC8vIGkgLSA3XG5cdCAgICB2YXIgYzFfbG8gPSBXW2kgLSAxM107XG5cdCAgICB2YXIgYzJfaGkgPSBnMF81MTJfaGkoV1tpIC0gMzBdLCBXW2kgLSAyOV0pOyAgLy8gaSAtIDE1XG5cdCAgICB2YXIgYzJfbG8gPSBnMF81MTJfbG8oV1tpIC0gMzBdLCBXW2kgLSAyOV0pO1xuXHQgICAgdmFyIGMzX2hpID0gV1tpIC0gMzJdOyAgLy8gaSAtIDE2XG5cdCAgICB2YXIgYzNfbG8gPSBXW2kgLSAzMV07XG5cblx0ICAgIFdbaV0gPSBzdW02NF80X2hpJDEoXG5cdCAgICAgIGMwX2hpLCBjMF9sbyxcblx0ICAgICAgYzFfaGksIGMxX2xvLFxuXHQgICAgICBjMl9oaSwgYzJfbG8sXG5cdCAgICAgIGMzX2hpLCBjM19sbyk7XG5cdCAgICBXW2kgKyAxXSA9IHN1bTY0XzRfbG8kMShcblx0ICAgICAgYzBfaGksIGMwX2xvLFxuXHQgICAgICBjMV9oaSwgYzFfbG8sXG5cdCAgICAgIGMyX2hpLCBjMl9sbyxcblx0ICAgICAgYzNfaGksIGMzX2xvKTtcblx0ICB9XG5cdH07XG5cblx0U0hBNTEyLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gX3VwZGF0ZShtc2csIHN0YXJ0KSB7XG5cdCAgdGhpcy5fcHJlcGFyZUJsb2NrKG1zZywgc3RhcnQpO1xuXG5cdCAgdmFyIFcgPSB0aGlzLlc7XG5cblx0ICB2YXIgYWggPSB0aGlzLmhbMF07XG5cdCAgdmFyIGFsID0gdGhpcy5oWzFdO1xuXHQgIHZhciBiaCA9IHRoaXMuaFsyXTtcblx0ICB2YXIgYmwgPSB0aGlzLmhbM107XG5cdCAgdmFyIGNoID0gdGhpcy5oWzRdO1xuXHQgIHZhciBjbCA9IHRoaXMuaFs1XTtcblx0ICB2YXIgZGggPSB0aGlzLmhbNl07XG5cdCAgdmFyIGRsID0gdGhpcy5oWzddO1xuXHQgIHZhciBlaCA9IHRoaXMuaFs4XTtcblx0ICB2YXIgZWwgPSB0aGlzLmhbOV07XG5cdCAgdmFyIGZoID0gdGhpcy5oWzEwXTtcblx0ICB2YXIgZmwgPSB0aGlzLmhbMTFdO1xuXHQgIHZhciBnaCA9IHRoaXMuaFsxMl07XG5cdCAgdmFyIGdsID0gdGhpcy5oWzEzXTtcblx0ICB2YXIgaGggPSB0aGlzLmhbMTRdO1xuXHQgIHZhciBobCA9IHRoaXMuaFsxNV07XG5cblx0ICBtaW5pbWFsaXN0aWNBc3NlcnQodGhpcy5rLmxlbmd0aCA9PT0gVy5sZW5ndGgpO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgVy5sZW5ndGg7IGkgKz0gMikge1xuXHQgICAgdmFyIGMwX2hpID0gaGg7XG5cdCAgICB2YXIgYzBfbG8gPSBobDtcblx0ICAgIHZhciBjMV9oaSA9IHMxXzUxMl9oaShlaCwgZWwpO1xuXHQgICAgdmFyIGMxX2xvID0gczFfNTEyX2xvKGVoLCBlbCk7XG5cdCAgICB2YXIgYzJfaGkgPSBjaDY0X2hpKGVoLCBlbCwgZmgsIGZsLCBnaCwgZ2wpO1xuXHQgICAgdmFyIGMyX2xvID0gY2g2NF9sbyhlaCwgZWwsIGZoLCBmbCwgZ2gsIGdsKTtcblx0ICAgIHZhciBjM19oaSA9IHRoaXMua1tpXTtcblx0ICAgIHZhciBjM19sbyA9IHRoaXMua1tpICsgMV07XG5cdCAgICB2YXIgYzRfaGkgPSBXW2ldO1xuXHQgICAgdmFyIGM0X2xvID0gV1tpICsgMV07XG5cblx0ICAgIHZhciBUMV9oaSA9IHN1bTY0XzVfaGkkMShcblx0ICAgICAgYzBfaGksIGMwX2xvLFxuXHQgICAgICBjMV9oaSwgYzFfbG8sXG5cdCAgICAgIGMyX2hpLCBjMl9sbyxcblx0ICAgICAgYzNfaGksIGMzX2xvLFxuXHQgICAgICBjNF9oaSwgYzRfbG8pO1xuXHQgICAgdmFyIFQxX2xvID0gc3VtNjRfNV9sbyQxKFxuXHQgICAgICBjMF9oaSwgYzBfbG8sXG5cdCAgICAgIGMxX2hpLCBjMV9sbyxcblx0ICAgICAgYzJfaGksIGMyX2xvLFxuXHQgICAgICBjM19oaSwgYzNfbG8sXG5cdCAgICAgIGM0X2hpLCBjNF9sbyk7XG5cblx0ICAgIGMwX2hpID0gczBfNTEyX2hpKGFoLCBhbCk7XG5cdCAgICBjMF9sbyA9IHMwXzUxMl9sbyhhaCwgYWwpO1xuXHQgICAgYzFfaGkgPSBtYWo2NF9oaShhaCwgYWwsIGJoLCBibCwgY2gsIGNsKTtcblx0ICAgIGMxX2xvID0gbWFqNjRfbG8oYWgsIGFsLCBiaCwgYmwsIGNoLCBjbCk7XG5cblx0ICAgIHZhciBUMl9oaSA9IHN1bTY0X2hpJDEoYzBfaGksIGMwX2xvLCBjMV9oaSwgYzFfbG8pO1xuXHQgICAgdmFyIFQyX2xvID0gc3VtNjRfbG8kMShjMF9oaSwgYzBfbG8sIGMxX2hpLCBjMV9sbyk7XG5cblx0ICAgIGhoID0gZ2g7XG5cdCAgICBobCA9IGdsO1xuXG5cdCAgICBnaCA9IGZoO1xuXHQgICAgZ2wgPSBmbDtcblxuXHQgICAgZmggPSBlaDtcblx0ICAgIGZsID0gZWw7XG5cblx0ICAgIGVoID0gc3VtNjRfaGkkMShkaCwgZGwsIFQxX2hpLCBUMV9sbyk7XG5cdCAgICBlbCA9IHN1bTY0X2xvJDEoZGwsIGRsLCBUMV9oaSwgVDFfbG8pO1xuXG5cdCAgICBkaCA9IGNoO1xuXHQgICAgZGwgPSBjbDtcblxuXHQgICAgY2ggPSBiaDtcblx0ICAgIGNsID0gYmw7XG5cblx0ICAgIGJoID0gYWg7XG5cdCAgICBibCA9IGFsO1xuXG5cdCAgICBhaCA9IHN1bTY0X2hpJDEoVDFfaGksIFQxX2xvLCBUMl9oaSwgVDJfbG8pO1xuXHQgICAgYWwgPSBzdW02NF9sbyQxKFQxX2hpLCBUMV9sbywgVDJfaGksIFQyX2xvKTtcblx0ICB9XG5cblx0ICBzdW02NCQxKHRoaXMuaCwgMCwgYWgsIGFsKTtcblx0ICBzdW02NCQxKHRoaXMuaCwgMiwgYmgsIGJsKTtcblx0ICBzdW02NCQxKHRoaXMuaCwgNCwgY2gsIGNsKTtcblx0ICBzdW02NCQxKHRoaXMuaCwgNiwgZGgsIGRsKTtcblx0ICBzdW02NCQxKHRoaXMuaCwgOCwgZWgsIGVsKTtcblx0ICBzdW02NCQxKHRoaXMuaCwgMTAsIGZoLCBmbCk7XG5cdCAgc3VtNjQkMSh0aGlzLmgsIDEyLCBnaCwgZ2wpO1xuXHQgIHN1bTY0JDEodGhpcy5oLCAxNCwgaGgsIGhsKTtcblx0fTtcblxuXHRTSEE1MTIucHJvdG90eXBlLl9kaWdlc3QgPSBmdW5jdGlvbiBkaWdlc3QoZW5jKSB7XG5cdCAgaWYgKGVuYyA9PT0gJ2hleCcpXG5cdCAgICByZXR1cm4gdXRpbHMudG9IZXgzMih0aGlzLmgsICdiaWcnKTtcblx0ICBlbHNlXG5cdCAgICByZXR1cm4gdXRpbHMuc3BsaXQzMih0aGlzLmgsICdiaWcnKTtcblx0fTtcblxuXHRmdW5jdGlvbiBjaDY0X2hpKHhoLCB4bCwgeWgsIHlsLCB6aCkge1xuXHQgIHZhciByID0gKHhoICYgeWgpIF4gKCh+eGgpICYgemgpO1xuXHQgIGlmIChyIDwgMClcblx0ICAgIHIgKz0gMHgxMDAwMDAwMDA7XG5cdCAgcmV0dXJuIHI7XG5cdH1cblxuXHRmdW5jdGlvbiBjaDY0X2xvKHhoLCB4bCwgeWgsIHlsLCB6aCwgemwpIHtcblx0ICB2YXIgciA9ICh4bCAmIHlsKSBeICgofnhsKSAmIHpsKTtcblx0ICBpZiAociA8IDApXG5cdCAgICByICs9IDB4MTAwMDAwMDAwO1xuXHQgIHJldHVybiByO1xuXHR9XG5cblx0ZnVuY3Rpb24gbWFqNjRfaGkoeGgsIHhsLCB5aCwgeWwsIHpoKSB7XG5cdCAgdmFyIHIgPSAoeGggJiB5aCkgXiAoeGggJiB6aCkgXiAoeWggJiB6aCk7XG5cdCAgaWYgKHIgPCAwKVxuXHQgICAgciArPSAweDEwMDAwMDAwMDtcblx0ICByZXR1cm4gcjtcblx0fVxuXG5cdGZ1bmN0aW9uIG1hajY0X2xvKHhoLCB4bCwgeWgsIHlsLCB6aCwgemwpIHtcblx0ICB2YXIgciA9ICh4bCAmIHlsKSBeICh4bCAmIHpsKSBeICh5bCAmIHpsKTtcblx0ICBpZiAociA8IDApXG5cdCAgICByICs9IDB4MTAwMDAwMDAwO1xuXHQgIHJldHVybiByO1xuXHR9XG5cblx0ZnVuY3Rpb24gczBfNTEyX2hpKHhoLCB4bCkge1xuXHQgIHZhciBjMF9oaSA9IHJvdHI2NF9oaSQxKHhoLCB4bCwgMjgpO1xuXHQgIHZhciBjMV9oaSA9IHJvdHI2NF9oaSQxKHhsLCB4aCwgMik7ICAvLyAzNFxuXHQgIHZhciBjMl9oaSA9IHJvdHI2NF9oaSQxKHhsLCB4aCwgNyk7ICAvLyAzOVxuXG5cdCAgdmFyIHIgPSBjMF9oaSBeIGMxX2hpIF4gYzJfaGk7XG5cdCAgaWYgKHIgPCAwKVxuXHQgICAgciArPSAweDEwMDAwMDAwMDtcblx0ICByZXR1cm4gcjtcblx0fVxuXG5cdGZ1bmN0aW9uIHMwXzUxMl9sbyh4aCwgeGwpIHtcblx0ICB2YXIgYzBfbG8gPSByb3RyNjRfbG8kMSh4aCwgeGwsIDI4KTtcblx0ICB2YXIgYzFfbG8gPSByb3RyNjRfbG8kMSh4bCwgeGgsIDIpOyAgLy8gMzRcblx0ICB2YXIgYzJfbG8gPSByb3RyNjRfbG8kMSh4bCwgeGgsIDcpOyAgLy8gMzlcblxuXHQgIHZhciByID0gYzBfbG8gXiBjMV9sbyBeIGMyX2xvO1xuXHQgIGlmIChyIDwgMClcblx0ICAgIHIgKz0gMHgxMDAwMDAwMDA7XG5cdCAgcmV0dXJuIHI7XG5cdH1cblxuXHRmdW5jdGlvbiBzMV81MTJfaGkoeGgsIHhsKSB7XG5cdCAgdmFyIGMwX2hpID0gcm90cjY0X2hpJDEoeGgsIHhsLCAxNCk7XG5cdCAgdmFyIGMxX2hpID0gcm90cjY0X2hpJDEoeGgsIHhsLCAxOCk7XG5cdCAgdmFyIGMyX2hpID0gcm90cjY0X2hpJDEoeGwsIHhoLCA5KTsgIC8vIDQxXG5cblx0ICB2YXIgciA9IGMwX2hpIF4gYzFfaGkgXiBjMl9oaTtcblx0ICBpZiAociA8IDApXG5cdCAgICByICs9IDB4MTAwMDAwMDAwO1xuXHQgIHJldHVybiByO1xuXHR9XG5cblx0ZnVuY3Rpb24gczFfNTEyX2xvKHhoLCB4bCkge1xuXHQgIHZhciBjMF9sbyA9IHJvdHI2NF9sbyQxKHhoLCB4bCwgMTQpO1xuXHQgIHZhciBjMV9sbyA9IHJvdHI2NF9sbyQxKHhoLCB4bCwgMTgpO1xuXHQgIHZhciBjMl9sbyA9IHJvdHI2NF9sbyQxKHhsLCB4aCwgOSk7ICAvLyA0MVxuXG5cdCAgdmFyIHIgPSBjMF9sbyBeIGMxX2xvIF4gYzJfbG87XG5cdCAgaWYgKHIgPCAwKVxuXHQgICAgciArPSAweDEwMDAwMDAwMDtcblx0ICByZXR1cm4gcjtcblx0fVxuXG5cdGZ1bmN0aW9uIGcwXzUxMl9oaSh4aCwgeGwpIHtcblx0ICB2YXIgYzBfaGkgPSByb3RyNjRfaGkkMSh4aCwgeGwsIDEpO1xuXHQgIHZhciBjMV9oaSA9IHJvdHI2NF9oaSQxKHhoLCB4bCwgOCk7XG5cdCAgdmFyIGMyX2hpID0gc2hyNjRfaGkkMSh4aCwgeGwsIDcpO1xuXG5cdCAgdmFyIHIgPSBjMF9oaSBeIGMxX2hpIF4gYzJfaGk7XG5cdCAgaWYgKHIgPCAwKVxuXHQgICAgciArPSAweDEwMDAwMDAwMDtcblx0ICByZXR1cm4gcjtcblx0fVxuXG5cdGZ1bmN0aW9uIGcwXzUxMl9sbyh4aCwgeGwpIHtcblx0ICB2YXIgYzBfbG8gPSByb3RyNjRfbG8kMSh4aCwgeGwsIDEpO1xuXHQgIHZhciBjMV9sbyA9IHJvdHI2NF9sbyQxKHhoLCB4bCwgOCk7XG5cdCAgdmFyIGMyX2xvID0gc2hyNjRfbG8kMSh4aCwgeGwsIDcpO1xuXG5cdCAgdmFyIHIgPSBjMF9sbyBeIGMxX2xvIF4gYzJfbG87XG5cdCAgaWYgKHIgPCAwKVxuXHQgICAgciArPSAweDEwMDAwMDAwMDtcblx0ICByZXR1cm4gcjtcblx0fVxuXG5cdGZ1bmN0aW9uIGcxXzUxMl9oaSh4aCwgeGwpIHtcblx0ICB2YXIgYzBfaGkgPSByb3RyNjRfaGkkMSh4aCwgeGwsIDE5KTtcblx0ICB2YXIgYzFfaGkgPSByb3RyNjRfaGkkMSh4bCwgeGgsIDI5KTsgIC8vIDYxXG5cdCAgdmFyIGMyX2hpID0gc2hyNjRfaGkkMSh4aCwgeGwsIDYpO1xuXG5cdCAgdmFyIHIgPSBjMF9oaSBeIGMxX2hpIF4gYzJfaGk7XG5cdCAgaWYgKHIgPCAwKVxuXHQgICAgciArPSAweDEwMDAwMDAwMDtcblx0ICByZXR1cm4gcjtcblx0fVxuXG5cdGZ1bmN0aW9uIGcxXzUxMl9sbyh4aCwgeGwpIHtcblx0ICB2YXIgYzBfbG8gPSByb3RyNjRfbG8kMSh4aCwgeGwsIDE5KTtcblx0ICB2YXIgYzFfbG8gPSByb3RyNjRfbG8kMSh4bCwgeGgsIDI5KTsgIC8vIDYxXG5cdCAgdmFyIGMyX2xvID0gc2hyNjRfbG8kMSh4aCwgeGwsIDYpO1xuXG5cdCAgdmFyIHIgPSBjMF9sbyBeIGMxX2xvIF4gYzJfbG87XG5cdCAgaWYgKHIgPCAwKVxuXHQgICAgciArPSAweDEwMDAwMDAwMDtcblx0ICByZXR1cm4gcjtcblx0fVxuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgc2hhMSA9IF8xO1xuXHR2YXIgc2hhMjI0ID0gXzIyNDtcblx0dmFyIHNoYTI1NiA9IF8yNTY7XG5cdHZhciBzaGEzODQgPSBfMzg0O1xuXHR2YXIgc2hhNTEyID0gXzUxMjtcblxuXHR2YXIgc2hhID0ge1xuXHRcdHNoYTE6IHNoYTEsXG5cdFx0c2hhMjI0OiBzaGEyMjQsXG5cdFx0c2hhMjU2OiBzaGEyNTYsXG5cdFx0c2hhMzg0OiBzaGEzODQsXG5cdFx0c2hhNTEyOiBzaGE1MTJcblx0fTtcblxuXHQndXNlIHN0cmljdCc7XG5cblxuXG5cblx0dmFyIHJvdGwzMiQxID0gdXRpbHMucm90bDMyO1xuXHR2YXIgc3VtMzIkMiA9IHV0aWxzLnN1bTMyO1xuXHR2YXIgc3VtMzJfMyQxID0gdXRpbHMuc3VtMzJfMztcblx0dmFyIHN1bTMyXzQkMiA9IHV0aWxzLnN1bTMyXzQ7XG5cdHZhciBCbG9ja0hhc2gkMyA9IGNvbW1vbi5CbG9ja0hhc2g7XG5cblx0ZnVuY3Rpb24gUklQRU1EMTYwKCkge1xuXHQgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSSVBFTUQxNjApKVxuXHQgICAgcmV0dXJuIG5ldyBSSVBFTUQxNjAoKTtcblxuXHQgIEJsb2NrSGFzaCQzLmNhbGwodGhpcyk7XG5cblx0ICB0aGlzLmggPSBbIDB4Njc0NTIzMDEsIDB4ZWZjZGFiODksIDB4OThiYWRjZmUsIDB4MTAzMjU0NzYsIDB4YzNkMmUxZjAgXTtcblx0ICB0aGlzLmVuZGlhbiA9ICdsaXR0bGUnO1xuXHR9XG5cdHV0aWxzLmluaGVyaXRzKFJJUEVNRDE2MCwgQmxvY2tIYXNoJDMpO1xuXHR2YXIgcmlwZW1kMTYwID0gUklQRU1EMTYwO1xuXG5cdFJJUEVNRDE2MC5ibG9ja1NpemUgPSA1MTI7XG5cdFJJUEVNRDE2MC5vdXRTaXplID0gMTYwO1xuXHRSSVBFTUQxNjAuaG1hY1N0cmVuZ3RoID0gMTkyO1xuXHRSSVBFTUQxNjAucGFkTGVuZ3RoID0gNjQ7XG5cblx0UklQRU1EMTYwLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKG1zZywgc3RhcnQpIHtcblx0ICB2YXIgQSA9IHRoaXMuaFswXTtcblx0ICB2YXIgQiA9IHRoaXMuaFsxXTtcblx0ICB2YXIgQyA9IHRoaXMuaFsyXTtcblx0ICB2YXIgRCA9IHRoaXMuaFszXTtcblx0ICB2YXIgRSA9IHRoaXMuaFs0XTtcblx0ICB2YXIgQWggPSBBO1xuXHQgIHZhciBCaCA9IEI7XG5cdCAgdmFyIENoID0gQztcblx0ICB2YXIgRGggPSBEO1xuXHQgIHZhciBFaCA9IEU7XG5cdCAgZm9yICh2YXIgaiA9IDA7IGogPCA4MDsgaisrKSB7XG5cdCAgICB2YXIgVCA9IHN1bTMyJDIoXG5cdCAgICAgIHJvdGwzMiQxKFxuXHQgICAgICAgIHN1bTMyXzQkMihBLCBmKGosIEIsIEMsIEQpLCBtc2dbcltqXSArIHN0YXJ0XSwgSyhqKSksXG5cdCAgICAgICAgc1tqXSksXG5cdCAgICAgIEUpO1xuXHQgICAgQSA9IEU7XG5cdCAgICBFID0gRDtcblx0ICAgIEQgPSByb3RsMzIkMShDLCAxMCk7XG5cdCAgICBDID0gQjtcblx0ICAgIEIgPSBUO1xuXHQgICAgVCA9IHN1bTMyJDIoXG5cdCAgICAgIHJvdGwzMiQxKFxuXHQgICAgICAgIHN1bTMyXzQkMihBaCwgZig3OSAtIGosIEJoLCBDaCwgRGgpLCBtc2dbcmhbal0gKyBzdGFydF0sIEtoKGopKSxcblx0ICAgICAgICBzaFtqXSksXG5cdCAgICAgIEVoKTtcblx0ICAgIEFoID0gRWg7XG5cdCAgICBFaCA9IERoO1xuXHQgICAgRGggPSByb3RsMzIkMShDaCwgMTApO1xuXHQgICAgQ2ggPSBCaDtcblx0ICAgIEJoID0gVDtcblx0ICB9XG5cdCAgVCA9IHN1bTMyXzMkMSh0aGlzLmhbMV0sIEMsIERoKTtcblx0ICB0aGlzLmhbMV0gPSBzdW0zMl8zJDEodGhpcy5oWzJdLCBELCBFaCk7XG5cdCAgdGhpcy5oWzJdID0gc3VtMzJfMyQxKHRoaXMuaFszXSwgRSwgQWgpO1xuXHQgIHRoaXMuaFszXSA9IHN1bTMyXzMkMSh0aGlzLmhbNF0sIEEsIEJoKTtcblx0ICB0aGlzLmhbNF0gPSBzdW0zMl8zJDEodGhpcy5oWzBdLCBCLCBDaCk7XG5cdCAgdGhpcy5oWzBdID0gVDtcblx0fTtcblxuXHRSSVBFTUQxNjAucHJvdG90eXBlLl9kaWdlc3QgPSBmdW5jdGlvbiBkaWdlc3QoZW5jKSB7XG5cdCAgaWYgKGVuYyA9PT0gJ2hleCcpXG5cdCAgICByZXR1cm4gdXRpbHMudG9IZXgzMih0aGlzLmgsICdsaXR0bGUnKTtcblx0ICBlbHNlXG5cdCAgICByZXR1cm4gdXRpbHMuc3BsaXQzMih0aGlzLmgsICdsaXR0bGUnKTtcblx0fTtcblxuXHRmdW5jdGlvbiBmKGosIHgsIHksIHopIHtcblx0ICBpZiAoaiA8PSAxNSlcblx0ICAgIHJldHVybiB4IF4geSBeIHo7XG5cdCAgZWxzZSBpZiAoaiA8PSAzMSlcblx0ICAgIHJldHVybiAoeCAmIHkpIHwgKCh+eCkgJiB6KTtcblx0ICBlbHNlIGlmIChqIDw9IDQ3KVxuXHQgICAgcmV0dXJuICh4IHwgKH55KSkgXiB6O1xuXHQgIGVsc2UgaWYgKGogPD0gNjMpXG5cdCAgICByZXR1cm4gKHggJiB6KSB8ICh5ICYgKH56KSk7XG5cdCAgZWxzZVxuXHQgICAgcmV0dXJuIHggXiAoeSB8ICh+eikpO1xuXHR9XG5cblx0ZnVuY3Rpb24gSyhqKSB7XG5cdCAgaWYgKGogPD0gMTUpXG5cdCAgICByZXR1cm4gMHgwMDAwMDAwMDtcblx0ICBlbHNlIGlmIChqIDw9IDMxKVxuXHQgICAgcmV0dXJuIDB4NWE4Mjc5OTk7XG5cdCAgZWxzZSBpZiAoaiA8PSA0Nylcblx0ICAgIHJldHVybiAweDZlZDllYmExO1xuXHQgIGVsc2UgaWYgKGogPD0gNjMpXG5cdCAgICByZXR1cm4gMHg4ZjFiYmNkYztcblx0ICBlbHNlXG5cdCAgICByZXR1cm4gMHhhOTUzZmQ0ZTtcblx0fVxuXG5cdGZ1bmN0aW9uIEtoKGopIHtcblx0ICBpZiAoaiA8PSAxNSlcblx0ICAgIHJldHVybiAweDUwYTI4YmU2O1xuXHQgIGVsc2UgaWYgKGogPD0gMzEpXG5cdCAgICByZXR1cm4gMHg1YzRkZDEyNDtcblx0ICBlbHNlIGlmIChqIDw9IDQ3KVxuXHQgICAgcmV0dXJuIDB4NmQ3MDNlZjM7XG5cdCAgZWxzZSBpZiAoaiA8PSA2Mylcblx0ICAgIHJldHVybiAweDdhNmQ3NmU5O1xuXHQgIGVsc2Vcblx0ICAgIHJldHVybiAweDAwMDAwMDAwO1xuXHR9XG5cblx0dmFyIHIgPSBbXG5cdCAgMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMiwgMTMsIDE0LCAxNSxcblx0ICA3LCA0LCAxMywgMSwgMTAsIDYsIDE1LCAzLCAxMiwgMCwgOSwgNSwgMiwgMTQsIDExLCA4LFxuXHQgIDMsIDEwLCAxNCwgNCwgOSwgMTUsIDgsIDEsIDIsIDcsIDAsIDYsIDEzLCAxMSwgNSwgMTIsXG5cdCAgMSwgOSwgMTEsIDEwLCAwLCA4LCAxMiwgNCwgMTMsIDMsIDcsIDE1LCAxNCwgNSwgNiwgMixcblx0ICA0LCAwLCA1LCA5LCA3LCAxMiwgMiwgMTAsIDE0LCAxLCAzLCA4LCAxMSwgNiwgMTUsIDEzXG5cdF07XG5cblx0dmFyIHJoID0gW1xuXHQgIDUsIDE0LCA3LCAwLCA5LCAyLCAxMSwgNCwgMTMsIDYsIDE1LCA4LCAxLCAxMCwgMywgMTIsXG5cdCAgNiwgMTEsIDMsIDcsIDAsIDEzLCA1LCAxMCwgMTQsIDE1LCA4LCAxMiwgNCwgOSwgMSwgMixcblx0ICAxNSwgNSwgMSwgMywgNywgMTQsIDYsIDksIDExLCA4LCAxMiwgMiwgMTAsIDAsIDQsIDEzLFxuXHQgIDgsIDYsIDQsIDEsIDMsIDExLCAxNSwgMCwgNSwgMTIsIDIsIDEzLCA5LCA3LCAxMCwgMTQsXG5cdCAgMTIsIDE1LCAxMCwgNCwgMSwgNSwgOCwgNywgNiwgMiwgMTMsIDE0LCAwLCAzLCA5LCAxMVxuXHRdO1xuXG5cdHZhciBzID0gW1xuXHQgIDExLCAxNCwgMTUsIDEyLCA1LCA4LCA3LCA5LCAxMSwgMTMsIDE0LCAxNSwgNiwgNywgOSwgOCxcblx0ICA3LCA2LCA4LCAxMywgMTEsIDksIDcsIDE1LCA3LCAxMiwgMTUsIDksIDExLCA3LCAxMywgMTIsXG5cdCAgMTEsIDEzLCA2LCA3LCAxNCwgOSwgMTMsIDE1LCAxNCwgOCwgMTMsIDYsIDUsIDEyLCA3LCA1LFxuXHQgIDExLCAxMiwgMTQsIDE1LCAxNCwgMTUsIDksIDgsIDksIDE0LCA1LCA2LCA4LCA2LCA1LCAxMixcblx0ICA5LCAxNSwgNSwgMTEsIDYsIDgsIDEzLCAxMiwgNSwgMTIsIDEzLCAxNCwgMTEsIDgsIDUsIDZcblx0XTtcblxuXHR2YXIgc2ggPSBbXG5cdCAgOCwgOSwgOSwgMTEsIDEzLCAxNSwgMTUsIDUsIDcsIDcsIDgsIDExLCAxNCwgMTQsIDEyLCA2LFxuXHQgIDksIDEzLCAxNSwgNywgMTIsIDgsIDksIDExLCA3LCA3LCAxMiwgNywgNiwgMTUsIDEzLCAxMSxcblx0ICA5LCA3LCAxNSwgMTEsIDgsIDYsIDYsIDE0LCAxMiwgMTMsIDUsIDE0LCAxMywgMTMsIDcsIDUsXG5cdCAgMTUsIDUsIDgsIDExLCAxNCwgMTQsIDYsIDE0LCA2LCA5LCAxMiwgOSwgMTIsIDUsIDE1LCA4LFxuXHQgIDgsIDUsIDEyLCA5LCAxMiwgNSwgMTQsIDYsIDgsIDEzLCA2LCA1LCAxNSwgMTMsIDExLCAxMVxuXHRdO1xuXG5cdHZhciByaXBlbWQgPSB7XG5cdFx0cmlwZW1kMTYwOiByaXBlbWQxNjBcblx0fTtcblxuXHQndXNlIHN0cmljdCc7XG5cblxuXG5cblx0ZnVuY3Rpb24gSG1hYyhoYXNoLCBrZXksIGVuYykge1xuXHQgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBIbWFjKSlcblx0ICAgIHJldHVybiBuZXcgSG1hYyhoYXNoLCBrZXksIGVuYyk7XG5cdCAgdGhpcy5IYXNoID0gaGFzaDtcblx0ICB0aGlzLmJsb2NrU2l6ZSA9IGhhc2guYmxvY2tTaXplIC8gODtcblx0ICB0aGlzLm91dFNpemUgPSBoYXNoLm91dFNpemUgLyA4O1xuXHQgIHRoaXMuaW5uZXIgPSBudWxsO1xuXHQgIHRoaXMub3V0ZXIgPSBudWxsO1xuXG5cdCAgdGhpcy5faW5pdCh1dGlscy50b0FycmF5KGtleSwgZW5jKSk7XG5cdH1cblx0dmFyIGhtYWMgPSBIbWFjO1xuXG5cdEhtYWMucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gaW5pdChrZXkpIHtcblx0ICAvLyBTaG9ydGVuIGtleSwgaWYgbmVlZGVkXG5cdCAgaWYgKGtleS5sZW5ndGggPiB0aGlzLmJsb2NrU2l6ZSlcblx0ICAgIGtleSA9IG5ldyB0aGlzLkhhc2goKS51cGRhdGUoa2V5KS5kaWdlc3QoKTtcblx0ICBtaW5pbWFsaXN0aWNBc3NlcnQoa2V5Lmxlbmd0aCA8PSB0aGlzLmJsb2NrU2l6ZSk7XG5cblx0ICAvLyBBZGQgcGFkZGluZyB0byBrZXlcblx0ICBmb3IgKHZhciBpID0ga2V5Lmxlbmd0aDsgaSA8IHRoaXMuYmxvY2tTaXplOyBpKyspXG5cdCAgICBrZXkucHVzaCgwKTtcblxuXHQgIGZvciAoaSA9IDA7IGkgPCBrZXkubGVuZ3RoOyBpKyspXG5cdCAgICBrZXlbaV0gXj0gMHgzNjtcblx0ICB0aGlzLmlubmVyID0gbmV3IHRoaXMuSGFzaCgpLnVwZGF0ZShrZXkpO1xuXG5cdCAgLy8gMHgzNiBeIDB4NWMgPSAweDZhXG5cdCAgZm9yIChpID0gMDsgaSA8IGtleS5sZW5ndGg7IGkrKylcblx0ICAgIGtleVtpXSBePSAweDZhO1xuXHQgIHRoaXMub3V0ZXIgPSBuZXcgdGhpcy5IYXNoKCkudXBkYXRlKGtleSk7XG5cdH07XG5cblx0SG1hYy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKG1zZywgZW5jKSB7XG5cdCAgdGhpcy5pbm5lci51cGRhdGUobXNnLCBlbmMpO1xuXHQgIHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdEhtYWMucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uIGRpZ2VzdChlbmMpIHtcblx0ICB0aGlzLm91dGVyLnVwZGF0ZSh0aGlzLmlubmVyLmRpZ2VzdCgpKTtcblx0ICByZXR1cm4gdGhpcy5vdXRlci5kaWdlc3QoZW5jKTtcblx0fTtcblxuXHR2YXIgaGFzaF8xID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHR2YXIgaGFzaCA9IGV4cG9ydHM7XG5cblx0aGFzaC51dGlscyA9IHV0aWxzO1xuXHRoYXNoLmNvbW1vbiA9IGNvbW1vbjtcblx0aGFzaC5zaGEgPSBzaGE7XG5cdGhhc2gucmlwZW1kID0gcmlwZW1kO1xuXHRoYXNoLmhtYWMgPSBobWFjO1xuXG5cdC8vIFByb3h5IGhhc2ggZnVuY3Rpb25zIHRvIHRoZSBtYWluIG9iamVjdFxuXHRoYXNoLnNoYTEgPSBoYXNoLnNoYS5zaGExO1xuXHRoYXNoLnNoYTI1NiA9IGhhc2guc2hhLnNoYTI1Njtcblx0aGFzaC5zaGEyMjQgPSBoYXNoLnNoYS5zaGEyMjQ7XG5cdGhhc2guc2hhMzg0ID0gaGFzaC5zaGEuc2hhMzg0O1xuXHRoYXNoLnNoYTUxMiA9IGhhc2guc2hhLnNoYTUxMjtcblx0aGFzaC5yaXBlbWQxNjAgPSBoYXNoLnJpcGVtZC5yaXBlbWQxNjA7XG5cdH0pO1xuXHR2YXIgaGFzaF8yID0gaGFzaF8xLmhtYWM7XG5cdHZhciBoYXNoXzMgPSBoYXNoXzEucmlwZW1kMTYwO1xuXHR2YXIgaGFzaF80ID0gaGFzaF8xLnNoYTI1Njtcblx0dmFyIGhhc2hfNSA9IGhhc2hfMS5zaGE1MTI7XG5cblx0dmFyIF92ZXJzaW9uJG8gPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMudmVyc2lvbiA9IFwic2hhMi81LjAuMlwiO1xuXG5cdH0pO1xuXG5cdHZhciBfdmVyc2lvbiRwID0gdW53cmFwRXhwb3J0cyhfdmVyc2lvbiRvKTtcblx0dmFyIF92ZXJzaW9uXzEkYyA9IF92ZXJzaW9uJG8udmVyc2lvbjtcblxuXHR2YXIgYnJvd3NlciA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciBfX2ltcG9ydFN0YXIgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG5cdCAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuXHQgICAgdmFyIHJlc3VsdCA9IHt9O1xuXHQgICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcblx0ICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdHZhciBoYXNoID0gX19pbXBvcnRTdGFyKGhhc2hfMSk7XG5cblxuXG5cdHZhciBsb2dnZXIgPSBuZXcgbGliLkxvZ2dlcihfdmVyc2lvbiRvLnZlcnNpb24pO1xuXHR2YXIgU3VwcG9ydGVkQWxnb3JpdGhtO1xuXHQoZnVuY3Rpb24gKFN1cHBvcnRlZEFsZ29yaXRobSkge1xuXHQgICAgU3VwcG9ydGVkQWxnb3JpdGhtW1wic2hhMjU2XCJdID0gXCJzaGEyNTZcIjtcblx0ICAgIFN1cHBvcnRlZEFsZ29yaXRobVtcInNoYTUxMlwiXSA9IFwic2hhNTEyXCI7XG5cdH0pKFN1cHBvcnRlZEFsZ29yaXRobSA9IGV4cG9ydHMuU3VwcG9ydGVkQWxnb3JpdGhtIHx8IChleHBvcnRzLlN1cHBvcnRlZEFsZ29yaXRobSA9IHt9KSk7XG5cdDtcblx0ZnVuY3Rpb24gcmlwZW1kMTYwKGRhdGEpIHtcblx0ICAgIHJldHVybiBcIjB4XCIgKyAoaGFzaC5yaXBlbWQxNjAoKS51cGRhdGUobGliJDEuYXJyYXlpZnkoZGF0YSkpLmRpZ2VzdChcImhleFwiKSk7XG5cdH1cblx0ZXhwb3J0cy5yaXBlbWQxNjAgPSByaXBlbWQxNjA7XG5cdGZ1bmN0aW9uIHNoYTI1NihkYXRhKSB7XG5cdCAgICByZXR1cm4gXCIweFwiICsgKGhhc2guc2hhMjU2KCkudXBkYXRlKGxpYiQxLmFycmF5aWZ5KGRhdGEpKS5kaWdlc3QoXCJoZXhcIikpO1xuXHR9XG5cdGV4cG9ydHMuc2hhMjU2ID0gc2hhMjU2O1xuXHRmdW5jdGlvbiBzaGE1MTIoZGF0YSkge1xuXHQgICAgcmV0dXJuIFwiMHhcIiArIChoYXNoLnNoYTUxMigpLnVwZGF0ZShsaWIkMS5hcnJheWlmeShkYXRhKSkuZGlnZXN0KFwiaGV4XCIpKTtcblx0fVxuXHRleHBvcnRzLnNoYTUxMiA9IHNoYTUxMjtcblx0ZnVuY3Rpb24gY29tcHV0ZUhtYWMoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcblx0ICAgIGlmICghU3VwcG9ydGVkQWxnb3JpdGhtW2FsZ29yaXRobV0pIHtcblx0ICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInVuc3VwcG9ydGVkIGFsZ29yaXRobSBcIiArIGFsZ29yaXRobSwgbGliLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG5cdCAgICAgICAgICAgIG9wZXJhdGlvbjogXCJobWFjXCIsXG5cdCAgICAgICAgICAgIGFsZ29yaXRobTogYWxnb3JpdGhtXG5cdCAgICAgICAgfSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gXCIweFwiICsgaGFzaC5obWFjKGhhc2hbYWxnb3JpdGhtXSwgbGliJDEuYXJyYXlpZnkoa2V5KSkudXBkYXRlKGxpYiQxLmFycmF5aWZ5KGRhdGEpKS5kaWdlc3QoXCJoZXhcIik7XG5cdH1cblx0ZXhwb3J0cy5jb21wdXRlSG1hYyA9IGNvbXB1dGVIbWFjO1xuXG5cdH0pO1xuXG5cdHZhciBicm93c2VyJDEgPSB1bndyYXBFeHBvcnRzKGJyb3dzZXIpO1xuXHR2YXIgYnJvd3Nlcl8xID0gYnJvd3Nlci5TdXBwb3J0ZWRBbGdvcml0aG07XG5cdHZhciBicm93c2VyXzIgPSBicm93c2VyLnJpcGVtZDE2MDtcblx0dmFyIGJyb3dzZXJfMyA9IGJyb3dzZXIuc2hhMjU2O1xuXHR2YXIgYnJvd3Nlcl80ID0gYnJvd3Nlci5zaGE1MTI7XG5cdHZhciBicm93c2VyXzUgPSBicm93c2VyLmNvbXB1dGVIbWFjO1xuXG5cdHZhciBicm93c2VyJDIgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cblxuXHRmdW5jdGlvbiBwYmtkZjIocGFzc3dvcmQsIHNhbHQsIGl0ZXJhdGlvbnMsIGtleWxlbiwgaGFzaEFsZ29yaXRobSkge1xuXHQgICAgcGFzc3dvcmQgPSBsaWIkMS5hcnJheWlmeShwYXNzd29yZCk7XG5cdCAgICBzYWx0ID0gbGliJDEuYXJyYXlpZnkoc2FsdCk7XG5cdCAgICB2YXIgaExlbjtcblx0ICAgIHZhciBsID0gMTtcblx0ICAgIHZhciBESyA9IG5ldyBVaW50OEFycmF5KGtleWxlbik7XG5cdCAgICB2YXIgYmxvY2sxID0gbmV3IFVpbnQ4QXJyYXkoc2FsdC5sZW5ndGggKyA0KTtcblx0ICAgIGJsb2NrMS5zZXQoc2FsdCk7XG5cdCAgICAvL3NhbHQuY29weShibG9jazEsIDAsIDAsIHNhbHQubGVuZ3RoKVxuXHQgICAgdmFyIHI7XG5cdCAgICB2YXIgVDtcblx0ICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IGw7IGkrKykge1xuXHQgICAgICAgIC8vYmxvY2sxLndyaXRlVUludDMyQkUoaSwgc2FsdC5sZW5ndGgpXG5cdCAgICAgICAgYmxvY2sxW3NhbHQubGVuZ3RoXSA9IChpID4+IDI0KSAmIDB4ZmY7XG5cdCAgICAgICAgYmxvY2sxW3NhbHQubGVuZ3RoICsgMV0gPSAoaSA+PiAxNikgJiAweGZmO1xuXHQgICAgICAgIGJsb2NrMVtzYWx0Lmxlbmd0aCArIDJdID0gKGkgPj4gOCkgJiAweGZmO1xuXHQgICAgICAgIGJsb2NrMVtzYWx0Lmxlbmd0aCArIDNdID0gaSAmIDB4ZmY7XG5cdCAgICAgICAgLy9sZXQgVSA9IGNyZWF0ZUhtYWMocGFzc3dvcmQpLnVwZGF0ZShibG9jazEpLmRpZ2VzdCgpO1xuXHQgICAgICAgIHZhciBVID0gbGliJDEuYXJyYXlpZnkoYnJvd3Nlci5jb21wdXRlSG1hYyhoYXNoQWxnb3JpdGhtLCBwYXNzd29yZCwgYmxvY2sxKSk7XG5cdCAgICAgICAgaWYgKCFoTGVuKSB7XG5cdCAgICAgICAgICAgIGhMZW4gPSBVLmxlbmd0aDtcblx0ICAgICAgICAgICAgVCA9IG5ldyBVaW50OEFycmF5KGhMZW4pO1xuXHQgICAgICAgICAgICBsID0gTWF0aC5jZWlsKGtleWxlbiAvIGhMZW4pO1xuXHQgICAgICAgICAgICByID0ga2V5bGVuIC0gKGwgLSAxKSAqIGhMZW47XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vVS5jb3B5KFQsIDAsIDAsIGhMZW4pXG5cdCAgICAgICAgVC5zZXQoVSk7XG5cdCAgICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCBpdGVyYXRpb25zOyBqKyspIHtcblx0ICAgICAgICAgICAgLy9VID0gY3JlYXRlSG1hYyhwYXNzd29yZCkudXBkYXRlKFUpLmRpZ2VzdCgpO1xuXHQgICAgICAgICAgICBVID0gbGliJDEuYXJyYXlpZnkoYnJvd3Nlci5jb21wdXRlSG1hYyhoYXNoQWxnb3JpdGhtLCBwYXNzd29yZCwgVSkpO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGhMZW47IGsrKylcblx0ICAgICAgICAgICAgICAgIFRba10gXj0gVVtrXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGRlc3RQb3MgPSAoaSAtIDEpICogaExlbjtcblx0ICAgICAgICB2YXIgbGVuID0gKGkgPT09IGwgPyByIDogaExlbik7XG5cdCAgICAgICAgLy9ULmNvcHkoREssIGRlc3RQb3MsIDAsIGxlbilcblx0ICAgICAgICBESy5zZXQobGliJDEuYXJyYXlpZnkoVCkuc2xpY2UoMCwgbGVuKSwgZGVzdFBvcyk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbGliJDEuaGV4bGlmeShESyk7XG5cdH1cblx0ZXhwb3J0cy5wYmtkZjIgPSBwYmtkZjI7XG5cblx0fSk7XG5cblx0dmFyIGJyb3dzZXIkMyA9IHVud3JhcEV4cG9ydHMoYnJvd3NlciQyKTtcblx0dmFyIGJyb3dzZXJfMSQxID0gYnJvd3NlciQyLnBia2RmMjtcblxuXHR2YXIgdmVyc2lvbiA9IFwiNi41LjNcIjtcblx0dmFyIF9wYWNrYWdlID0ge1xuXHRcdHZlcnNpb246IHZlcnNpb25cblx0fTtcblxuXHR2YXIgX3BhY2thZ2UkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0XHR2ZXJzaW9uOiB2ZXJzaW9uLFxuXHRcdCdkZWZhdWx0JzogX3BhY2thZ2Vcblx0fSk7XG5cblx0dmFyIGJuJDEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5cdChmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdCAgJ3VzZSBzdHJpY3QnO1xuXG5cdCAgLy8gVXRpbHNcblx0ICBmdW5jdGlvbiBhc3NlcnQgKHZhbCwgbXNnKSB7XG5cdCAgICBpZiAoIXZhbCkgdGhyb3cgbmV3IEVycm9yKG1zZyB8fCAnQXNzZXJ0aW9uIGZhaWxlZCcpO1xuXHQgIH1cblxuXHQgIC8vIENvdWxkIHVzZSBgaW5oZXJpdHNgIG1vZHVsZSwgYnV0IGRvbid0IHdhbnQgdG8gbW92ZSBmcm9tIHNpbmdsZSBmaWxlXG5cdCAgLy8gYXJjaGl0ZWN0dXJlIHlldC5cblx0ICBmdW5jdGlvbiBpbmhlcml0cyAoY3Rvciwgc3VwZXJDdG9yKSB7XG5cdCAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3Rvcjtcblx0ICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9O1xuXHQgICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZTtcblx0ICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKCk7XG5cdCAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3I7XG5cdCAgfVxuXG5cdCAgLy8gQk5cblxuXHQgIGZ1bmN0aW9uIEJOIChudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuXHQgICAgaWYgKEJOLmlzQk4obnVtYmVyKSkge1xuXHQgICAgICByZXR1cm4gbnVtYmVyO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLm5lZ2F0aXZlID0gMDtcblx0ICAgIHRoaXMud29yZHMgPSBudWxsO1xuXHQgICAgdGhpcy5sZW5ndGggPSAwO1xuXG5cdCAgICAvLyBSZWR1Y3Rpb24gY29udGV4dFxuXHQgICAgdGhpcy5yZWQgPSBudWxsO1xuXG5cdCAgICBpZiAobnVtYmVyICE9PSBudWxsKSB7XG5cdCAgICAgIGlmIChiYXNlID09PSAnbGUnIHx8IGJhc2UgPT09ICdiZScpIHtcblx0ICAgICAgICBlbmRpYW4gPSBiYXNlO1xuXHQgICAgICAgIGJhc2UgPSAxMDtcblx0ICAgICAgfVxuXG5cdCAgICAgIHRoaXMuX2luaXQobnVtYmVyIHx8IDAsIGJhc2UgfHwgMTAsIGVuZGlhbiB8fCAnYmUnKTtcblx0ICAgIH1cblx0ICB9XG5cdCAgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKSB7XG5cdCAgICBtb2R1bGUuZXhwb3J0cyA9IEJOO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBleHBvcnRzLkJOID0gQk47XG5cdCAgfVxuXG5cdCAgQk4uQk4gPSBCTjtcblx0ICBCTi53b3JkU2l6ZSA9IDI2O1xuXG5cdCAgdmFyIEJ1ZmZlcjtcblx0ICB0cnkge1xuXHQgICAgQnVmZmVyID0gcmVxdWlyZSQkMC5CdWZmZXI7XG5cdCAgfSBjYXRjaCAoZSkge1xuXHQgIH1cblxuXHQgIEJOLmlzQk4gPSBmdW5jdGlvbiBpc0JOIChudW0pIHtcblx0ICAgIGlmIChudW0gaW5zdGFuY2VvZiBCTikge1xuXHQgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIG51bSAhPT0gbnVsbCAmJiB0eXBlb2YgbnVtID09PSAnb2JqZWN0JyAmJlxuXHQgICAgICBudW0uY29uc3RydWN0b3Iud29yZFNpemUgPT09IEJOLndvcmRTaXplICYmIEFycmF5LmlzQXJyYXkobnVtLndvcmRzKTtcblx0ICB9O1xuXG5cdCAgQk4ubWF4ID0gZnVuY3Rpb24gbWF4IChsZWZ0LCByaWdodCkge1xuXHQgICAgaWYgKGxlZnQuY21wKHJpZ2h0KSA+IDApIHJldHVybiBsZWZ0O1xuXHQgICAgcmV0dXJuIHJpZ2h0O1xuXHQgIH07XG5cblx0ICBCTi5taW4gPSBmdW5jdGlvbiBtaW4gKGxlZnQsIHJpZ2h0KSB7XG5cdCAgICBpZiAobGVmdC5jbXAocmlnaHQpIDwgMCkgcmV0dXJuIGxlZnQ7XG5cdCAgICByZXR1cm4gcmlnaHQ7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIGluaXQgKG51bWJlciwgYmFzZSwgZW5kaWFuKSB7XG5cdCAgICBpZiAodHlwZW9mIG51bWJlciA9PT0gJ251bWJlcicpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuX2luaXROdW1iZXIobnVtYmVyLCBiYXNlLCBlbmRpYW4pO1xuXHQgICAgfVxuXG5cdCAgICBpZiAodHlwZW9mIG51bWJlciA9PT0gJ29iamVjdCcpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuX2luaXRBcnJheShudW1iZXIsIGJhc2UsIGVuZGlhbik7XG5cdCAgICB9XG5cblx0ICAgIGlmIChiYXNlID09PSAnaGV4Jykge1xuXHQgICAgICBiYXNlID0gMTY7XG5cdCAgICB9XG5cdCAgICBhc3NlcnQoYmFzZSA9PT0gKGJhc2UgfCAwKSAmJiBiYXNlID49IDIgJiYgYmFzZSA8PSAzNik7XG5cblx0ICAgIG51bWJlciA9IG51bWJlci50b1N0cmluZygpLnJlcGxhY2UoL1xccysvZywgJycpO1xuXHQgICAgdmFyIHN0YXJ0ID0gMDtcblx0ICAgIGlmIChudW1iZXJbMF0gPT09ICctJykge1xuXHQgICAgICBzdGFydCsrO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoYmFzZSA9PT0gMTYpIHtcblx0ICAgICAgdGhpcy5fcGFyc2VIZXgobnVtYmVyLCBzdGFydCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB0aGlzLl9wYXJzZUJhc2UobnVtYmVyLCBiYXNlLCBzdGFydCk7XG5cdCAgICB9XG5cblx0ICAgIGlmIChudW1iZXJbMF0gPT09ICctJykge1xuXHQgICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5zdHJpcCgpO1xuXG5cdCAgICBpZiAoZW5kaWFuICE9PSAnbGUnKSByZXR1cm47XG5cblx0ICAgIHRoaXMuX2luaXRBcnJheSh0aGlzLnRvQXJyYXkoKSwgYmFzZSwgZW5kaWFuKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLl9pbml0TnVtYmVyID0gZnVuY3Rpb24gX2luaXROdW1iZXIgKG51bWJlciwgYmFzZSwgZW5kaWFuKSB7XG5cdCAgICBpZiAobnVtYmVyIDwgMCkge1xuXHQgICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcblx0ICAgICAgbnVtYmVyID0gLW51bWJlcjtcblx0ICAgIH1cblx0ICAgIGlmIChudW1iZXIgPCAweDQwMDAwMDApIHtcblx0ICAgICAgdGhpcy53b3JkcyA9IFsgbnVtYmVyICYgMHgzZmZmZmZmIF07XG5cdCAgICAgIHRoaXMubGVuZ3RoID0gMTtcblx0ICAgIH0gZWxzZSBpZiAobnVtYmVyIDwgMHgxMDAwMDAwMDAwMDAwMCkge1xuXHQgICAgICB0aGlzLndvcmRzID0gW1xuXHQgICAgICAgIG51bWJlciAmIDB4M2ZmZmZmZixcblx0ICAgICAgICAobnVtYmVyIC8gMHg0MDAwMDAwKSAmIDB4M2ZmZmZmZlxuXHQgICAgICBdO1xuXHQgICAgICB0aGlzLmxlbmd0aCA9IDI7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBhc3NlcnQobnVtYmVyIDwgMHgyMDAwMDAwMDAwMDAwMCk7IC8vIDIgXiA1MyAodW5zYWZlKVxuXHQgICAgICB0aGlzLndvcmRzID0gW1xuXHQgICAgICAgIG51bWJlciAmIDB4M2ZmZmZmZixcblx0ICAgICAgICAobnVtYmVyIC8gMHg0MDAwMDAwKSAmIDB4M2ZmZmZmZixcblx0ICAgICAgICAxXG5cdCAgICAgIF07XG5cdCAgICAgIHRoaXMubGVuZ3RoID0gMztcblx0ICAgIH1cblxuXHQgICAgaWYgKGVuZGlhbiAhPT0gJ2xlJykgcmV0dXJuO1xuXG5cdCAgICAvLyBSZXZlcnNlIHRoZSBieXRlc1xuXHQgICAgdGhpcy5faW5pdEFycmF5KHRoaXMudG9BcnJheSgpLCBiYXNlLCBlbmRpYW4pO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuX2luaXRBcnJheSA9IGZ1bmN0aW9uIF9pbml0QXJyYXkgKG51bWJlciwgYmFzZSwgZW5kaWFuKSB7XG5cdCAgICAvLyBQZXJoYXBzIGEgVWludDhBcnJheVxuXHQgICAgYXNzZXJ0KHR5cGVvZiBudW1iZXIubGVuZ3RoID09PSAnbnVtYmVyJyk7XG5cdCAgICBpZiAobnVtYmVyLmxlbmd0aCA8PSAwKSB7XG5cdCAgICAgIHRoaXMud29yZHMgPSBbIDAgXTtcblx0ICAgICAgdGhpcy5sZW5ndGggPSAxO1xuXHQgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH1cblxuXHQgICAgdGhpcy5sZW5ndGggPSBNYXRoLmNlaWwobnVtYmVyLmxlbmd0aCAvIDMpO1xuXHQgICAgdGhpcy53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdGhpcy53b3Jkc1tpXSA9IDA7XG5cdCAgICB9XG5cblx0ICAgIHZhciBqLCB3O1xuXHQgICAgdmFyIG9mZiA9IDA7XG5cdCAgICBpZiAoZW5kaWFuID09PSAnYmUnKSB7XG5cdCAgICAgIGZvciAoaSA9IG51bWJlci5sZW5ndGggLSAxLCBqID0gMDsgaSA+PSAwOyBpIC09IDMpIHtcblx0ICAgICAgICB3ID0gbnVtYmVyW2ldIHwgKG51bWJlcltpIC0gMV0gPDwgOCkgfCAobnVtYmVyW2kgLSAyXSA8PCAxNik7XG5cdCAgICAgICAgdGhpcy53b3Jkc1tqXSB8PSAodyA8PCBvZmYpICYgMHgzZmZmZmZmO1xuXHQgICAgICAgIHRoaXMud29yZHNbaiArIDFdID0gKHcgPj4+ICgyNiAtIG9mZikpICYgMHgzZmZmZmZmO1xuXHQgICAgICAgIG9mZiArPSAyNDtcblx0ICAgICAgICBpZiAob2ZmID49IDI2KSB7XG5cdCAgICAgICAgICBvZmYgLT0gMjY7XG5cdCAgICAgICAgICBqKys7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9IGVsc2UgaWYgKGVuZGlhbiA9PT0gJ2xlJykge1xuXHQgICAgICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IG51bWJlci5sZW5ndGg7IGkgKz0gMykge1xuXHQgICAgICAgIHcgPSBudW1iZXJbaV0gfCAobnVtYmVyW2kgKyAxXSA8PCA4KSB8IChudW1iZXJbaSArIDJdIDw8IDE2KTtcblx0ICAgICAgICB0aGlzLndvcmRzW2pdIHw9ICh3IDw8IG9mZikgJiAweDNmZmZmZmY7XG5cdCAgICAgICAgdGhpcy53b3Jkc1tqICsgMV0gPSAodyA+Pj4gKDI2IC0gb2ZmKSkgJiAweDNmZmZmZmY7XG5cdCAgICAgICAgb2ZmICs9IDI0O1xuXHQgICAgICAgIGlmIChvZmYgPj0gMjYpIHtcblx0ICAgICAgICAgIG9mZiAtPSAyNjtcblx0ICAgICAgICAgIGorKztcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG5cdCAgfTtcblxuXHQgIGZ1bmN0aW9uIHBhcnNlSGV4IChzdHIsIHN0YXJ0LCBlbmQpIHtcblx0ICAgIHZhciByID0gMDtcblx0ICAgIHZhciBsZW4gPSBNYXRoLm1pbihzdHIubGVuZ3RoLCBlbmQpO1xuXHQgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgbGVuOyBpKyspIHtcblx0ICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKSAtIDQ4O1xuXG5cdCAgICAgIHIgPDw9IDQ7XG5cblx0ICAgICAgLy8gJ2EnIC0gJ2YnXG5cdCAgICAgIGlmIChjID49IDQ5ICYmIGMgPD0gNTQpIHtcblx0ICAgICAgICByIHw9IGMgLSA0OSArIDB4YTtcblxuXHQgICAgICAvLyAnQScgLSAnRidcblx0ICAgICAgfSBlbHNlIGlmIChjID49IDE3ICYmIGMgPD0gMjIpIHtcblx0ICAgICAgICByIHw9IGMgLSAxNyArIDB4YTtcblxuXHQgICAgICAvLyAnMCcgLSAnOSdcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICByIHw9IGMgJiAweGY7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiByO1xuXHQgIH1cblxuXHQgIEJOLnByb3RvdHlwZS5fcGFyc2VIZXggPSBmdW5jdGlvbiBfcGFyc2VIZXggKG51bWJlciwgc3RhcnQpIHtcblx0ICAgIC8vIENyZWF0ZSBwb3NzaWJseSBiaWdnZXIgYXJyYXkgdG8gZW5zdXJlIHRoYXQgaXQgZml0cyB0aGUgbnVtYmVyXG5cdCAgICB0aGlzLmxlbmd0aCA9IE1hdGguY2VpbCgobnVtYmVyLmxlbmd0aCAtIHN0YXJ0KSAvIDYpO1xuXHQgICAgdGhpcy53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdGhpcy53b3Jkc1tpXSA9IDA7XG5cdCAgICB9XG5cblx0ICAgIHZhciBqLCB3O1xuXHQgICAgLy8gU2NhbiAyNC1iaXQgY2h1bmtzIGFuZCBhZGQgdGhlbSB0byB0aGUgbnVtYmVyXG5cdCAgICB2YXIgb2ZmID0gMDtcblx0ICAgIGZvciAoaSA9IG51bWJlci5sZW5ndGggLSA2LCBqID0gMDsgaSA+PSBzdGFydDsgaSAtPSA2KSB7XG5cdCAgICAgIHcgPSBwYXJzZUhleChudW1iZXIsIGksIGkgKyA2KTtcblx0ICAgICAgdGhpcy53b3Jkc1tqXSB8PSAodyA8PCBvZmYpICYgMHgzZmZmZmZmO1xuXHQgICAgICAvLyBOT1RFOiBgMHgzZmZmZmZgIGlzIGludGVudGlvbmFsIGhlcmUsIDI2Yml0cyBtYXggc2hpZnQgKyAyNGJpdCBoZXggbGltYlxuXHQgICAgICB0aGlzLndvcmRzW2ogKyAxXSB8PSB3ID4+PiAoMjYgLSBvZmYpICYgMHgzZmZmZmY7XG5cdCAgICAgIG9mZiArPSAyNDtcblx0ICAgICAgaWYgKG9mZiA+PSAyNikge1xuXHQgICAgICAgIG9mZiAtPSAyNjtcblx0ICAgICAgICBqKys7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIGlmIChpICsgNiAhPT0gc3RhcnQpIHtcblx0ICAgICAgdyA9IHBhcnNlSGV4KG51bWJlciwgc3RhcnQsIGkgKyA2KTtcblx0ICAgICAgdGhpcy53b3Jkc1tqXSB8PSAodyA8PCBvZmYpICYgMHgzZmZmZmZmO1xuXHQgICAgICB0aGlzLndvcmRzW2ogKyAxXSB8PSB3ID4+PiAoMjYgLSBvZmYpICYgMHgzZmZmZmY7XG5cdCAgICB9XG5cdCAgICB0aGlzLnN0cmlwKCk7XG5cdCAgfTtcblxuXHQgIGZ1bmN0aW9uIHBhcnNlQmFzZSAoc3RyLCBzdGFydCwgZW5kLCBtdWwpIHtcblx0ICAgIHZhciByID0gMDtcblx0ICAgIHZhciBsZW4gPSBNYXRoLm1pbihzdHIubGVuZ3RoLCBlbmQpO1xuXHQgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgbGVuOyBpKyspIHtcblx0ICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKSAtIDQ4O1xuXG5cdCAgICAgIHIgKj0gbXVsO1xuXG5cdCAgICAgIC8vICdhJ1xuXHQgICAgICBpZiAoYyA+PSA0OSkge1xuXHQgICAgICAgIHIgKz0gYyAtIDQ5ICsgMHhhO1xuXG5cdCAgICAgIC8vICdBJ1xuXHQgICAgICB9IGVsc2UgaWYgKGMgPj0gMTcpIHtcblx0ICAgICAgICByICs9IGMgLSAxNyArIDB4YTtcblxuXHQgICAgICAvLyAnMCcgLSAnOSdcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICByICs9IGM7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiByO1xuXHQgIH1cblxuXHQgIEJOLnByb3RvdHlwZS5fcGFyc2VCYXNlID0gZnVuY3Rpb24gX3BhcnNlQmFzZSAobnVtYmVyLCBiYXNlLCBzdGFydCkge1xuXHQgICAgLy8gSW5pdGlhbGl6ZSBhcyB6ZXJvXG5cdCAgICB0aGlzLndvcmRzID0gWyAwIF07XG5cdCAgICB0aGlzLmxlbmd0aCA9IDE7XG5cblx0ICAgIC8vIEZpbmQgbGVuZ3RoIG9mIGxpbWIgaW4gYmFzZVxuXHQgICAgZm9yICh2YXIgbGltYkxlbiA9IDAsIGxpbWJQb3cgPSAxOyBsaW1iUG93IDw9IDB4M2ZmZmZmZjsgbGltYlBvdyAqPSBiYXNlKSB7XG5cdCAgICAgIGxpbWJMZW4rKztcblx0ICAgIH1cblx0ICAgIGxpbWJMZW4tLTtcblx0ICAgIGxpbWJQb3cgPSAobGltYlBvdyAvIGJhc2UpIHwgMDtcblxuXHQgICAgdmFyIHRvdGFsID0gbnVtYmVyLmxlbmd0aCAtIHN0YXJ0O1xuXHQgICAgdmFyIG1vZCA9IHRvdGFsICUgbGltYkxlbjtcblx0ICAgIHZhciBlbmQgPSBNYXRoLm1pbih0b3RhbCwgdG90YWwgLSBtb2QpICsgc3RhcnQ7XG5cblx0ICAgIHZhciB3b3JkID0gMDtcblx0ICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSBsaW1iTGVuKSB7XG5cdCAgICAgIHdvcmQgPSBwYXJzZUJhc2UobnVtYmVyLCBpLCBpICsgbGltYkxlbiwgYmFzZSk7XG5cblx0ICAgICAgdGhpcy5pbXVsbihsaW1iUG93KTtcblx0ICAgICAgaWYgKHRoaXMud29yZHNbMF0gKyB3b3JkIDwgMHg0MDAwMDAwKSB7XG5cdCAgICAgICAgdGhpcy53b3Jkc1swXSArPSB3b3JkO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHRoaXMuX2lhZGRuKHdvcmQpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGlmIChtb2QgIT09IDApIHtcblx0ICAgICAgdmFyIHBvdyA9IDE7XG5cdCAgICAgIHdvcmQgPSBwYXJzZUJhc2UobnVtYmVyLCBpLCBudW1iZXIubGVuZ3RoLCBiYXNlKTtcblxuXHQgICAgICBmb3IgKGkgPSAwOyBpIDwgbW9kOyBpKyspIHtcblx0ICAgICAgICBwb3cgKj0gYmFzZTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHRoaXMuaW11bG4ocG93KTtcblx0ICAgICAgaWYgKHRoaXMud29yZHNbMF0gKyB3b3JkIDwgMHg0MDAwMDAwKSB7XG5cdCAgICAgICAgdGhpcy53b3Jkc1swXSArPSB3b3JkO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHRoaXMuX2lhZGRuKHdvcmQpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAoZGVzdCkge1xuXHQgICAgZGVzdC53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgZGVzdC53b3Jkc1tpXSA9IHRoaXMud29yZHNbaV07XG5cdCAgICB9XG5cdCAgICBkZXN0Lmxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuXHQgICAgZGVzdC5uZWdhdGl2ZSA9IHRoaXMubmVnYXRpdmU7XG5cdCAgICBkZXN0LnJlZCA9IHRoaXMucmVkO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSAoKSB7XG5cdCAgICB2YXIgciA9IG5ldyBCTihudWxsKTtcblx0ICAgIHRoaXMuY29weShyKTtcblx0ICAgIHJldHVybiByO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuX2V4cGFuZCA9IGZ1bmN0aW9uIF9leHBhbmQgKHNpemUpIHtcblx0ICAgIHdoaWxlICh0aGlzLmxlbmd0aCA8IHNpemUpIHtcblx0ICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCsrXSA9IDA7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXG5cdCAgLy8gUmVtb3ZlIGxlYWRpbmcgYDBgIGZyb20gYHRoaXNgXG5cdCAgQk4ucHJvdG90eXBlLnN0cmlwID0gZnVuY3Rpb24gc3RyaXAgKCkge1xuXHQgICAgd2hpbGUgKHRoaXMubGVuZ3RoID4gMSAmJiB0aGlzLndvcmRzW3RoaXMubGVuZ3RoIC0gMV0gPT09IDApIHtcblx0ICAgICAgdGhpcy5sZW5ndGgtLTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB0aGlzLl9ub3JtU2lnbigpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuX25vcm1TaWduID0gZnVuY3Rpb24gX25vcm1TaWduICgpIHtcblx0ICAgIC8vIC0wID0gMFxuXHQgICAgaWYgKHRoaXMubGVuZ3RoID09PSAxICYmIHRoaXMud29yZHNbMF0gPT09IDApIHtcblx0ICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcblx0ICAgIHJldHVybiAodGhpcy5yZWQgPyAnPEJOLVI6ICcgOiAnPEJOOiAnKSArIHRoaXMudG9TdHJpbmcoMTYpICsgJz4nO1xuXHQgIH07XG5cblx0ICAvKlxuXG5cdCAgdmFyIHplcm9zID0gW107XG5cdCAgdmFyIGdyb3VwU2l6ZXMgPSBbXTtcblx0ICB2YXIgZ3JvdXBCYXNlcyA9IFtdO1xuXG5cdCAgdmFyIHMgPSAnJztcblx0ICB2YXIgaSA9IC0xO1xuXHQgIHdoaWxlICgrK2kgPCBCTi53b3JkU2l6ZSkge1xuXHQgICAgemVyb3NbaV0gPSBzO1xuXHQgICAgcyArPSAnMCc7XG5cdCAgfVxuXHQgIGdyb3VwU2l6ZXNbMF0gPSAwO1xuXHQgIGdyb3VwU2l6ZXNbMV0gPSAwO1xuXHQgIGdyb3VwQmFzZXNbMF0gPSAwO1xuXHQgIGdyb3VwQmFzZXNbMV0gPSAwO1xuXHQgIHZhciBiYXNlID0gMiAtIDE7XG5cdCAgd2hpbGUgKCsrYmFzZSA8IDM2ICsgMSkge1xuXHQgICAgdmFyIGdyb3VwU2l6ZSA9IDA7XG5cdCAgICB2YXIgZ3JvdXBCYXNlID0gMTtcblx0ICAgIHdoaWxlIChncm91cEJhc2UgPCAoMSA8PCBCTi53b3JkU2l6ZSkgLyBiYXNlKSB7XG5cdCAgICAgIGdyb3VwQmFzZSAqPSBiYXNlO1xuXHQgICAgICBncm91cFNpemUgKz0gMTtcblx0ICAgIH1cblx0ICAgIGdyb3VwU2l6ZXNbYmFzZV0gPSBncm91cFNpemU7XG5cdCAgICBncm91cEJhc2VzW2Jhc2VdID0gZ3JvdXBCYXNlO1xuXHQgIH1cblxuXHQgICovXG5cblx0ICB2YXIgemVyb3MgPSBbXG5cdCAgICAnJyxcblx0ICAgICcwJyxcblx0ICAgICcwMCcsXG5cdCAgICAnMDAwJyxcblx0ICAgICcwMDAwJyxcblx0ICAgICcwMDAwMCcsXG5cdCAgICAnMDAwMDAwJyxcblx0ICAgICcwMDAwMDAwJyxcblx0ICAgICcwMDAwMDAwMCcsXG5cdCAgICAnMDAwMDAwMDAwJyxcblx0ICAgICcwMDAwMDAwMDAwJyxcblx0ICAgICcwMDAwMDAwMDAwMCcsXG5cdCAgICAnMDAwMDAwMDAwMDAwJyxcblx0ICAgICcwMDAwMDAwMDAwMDAwJyxcblx0ICAgICcwMDAwMDAwMDAwMDAwMCcsXG5cdCAgICAnMDAwMDAwMDAwMDAwMDAwJyxcblx0ICAgICcwMDAwMDAwMDAwMDAwMDAwJyxcblx0ICAgICcwMDAwMDAwMDAwMDAwMDAwMCcsXG5cdCAgICAnMDAwMDAwMDAwMDAwMDAwMDAwJyxcblx0ICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwJyxcblx0ICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG5cdCAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcblx0ICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcblx0ICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG5cdCAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcblx0ICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJ1xuXHQgIF07XG5cblx0ICB2YXIgZ3JvdXBTaXplcyA9IFtcblx0ICAgIDAsIDAsXG5cdCAgICAyNSwgMTYsIDEyLCAxMSwgMTAsIDksIDgsXG5cdCAgICA4LCA3LCA3LCA3LCA3LCA2LCA2LFxuXHQgICAgNiwgNiwgNiwgNiwgNiwgNSwgNSxcblx0ICAgIDUsIDUsIDUsIDUsIDUsIDUsIDUsXG5cdCAgICA1LCA1LCA1LCA1LCA1LCA1LCA1XG5cdCAgXTtcblxuXHQgIHZhciBncm91cEJhc2VzID0gW1xuXHQgICAgMCwgMCxcblx0ICAgIDMzNTU0NDMyLCA0MzA0NjcyMSwgMTY3NzcyMTYsIDQ4ODI4MTI1LCA2MDQ2NjE3NiwgNDAzNTM2MDcsIDE2Nzc3MjE2LFxuXHQgICAgNDMwNDY3MjEsIDEwMDAwMDAwLCAxOTQ4NzE3MSwgMzU4MzE4MDgsIDYyNzQ4NTE3LCA3NTI5NTM2LCAxMTM5MDYyNSxcblx0ICAgIDE2Nzc3MjE2LCAyNDEzNzU2OSwgMzQwMTIyMjQsIDQ3MDQ1ODgxLCA2NDAwMDAwMCwgNDA4NDEwMSwgNTE1MzYzMixcblx0ICAgIDY0MzYzNDMsIDc5NjI2MjQsIDk3NjU2MjUsIDExODgxMzc2LCAxNDM0ODkwNywgMTcyMTAzNjgsIDIwNTExMTQ5LFxuXHQgICAgMjQzMDAwMDAsIDI4NjI5MTUxLCAzMzU1NDQzMiwgMzkxMzUzOTMsIDQ1NDM1NDI0LCA1MjUyMTg3NSwgNjA0NjYxNzZcblx0ICBdO1xuXG5cdCAgQk4ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKGJhc2UsIHBhZGRpbmcpIHtcblx0ICAgIGJhc2UgPSBiYXNlIHx8IDEwO1xuXHQgICAgcGFkZGluZyA9IHBhZGRpbmcgfCAwIHx8IDE7XG5cblx0ICAgIHZhciBvdXQ7XG5cdCAgICBpZiAoYmFzZSA9PT0gMTYgfHwgYmFzZSA9PT0gJ2hleCcpIHtcblx0ICAgICAgb3V0ID0gJyc7XG5cdCAgICAgIHZhciBvZmYgPSAwO1xuXHQgICAgICB2YXIgY2FycnkgPSAwO1xuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICB2YXIgdyA9IHRoaXMud29yZHNbaV07XG5cdCAgICAgICAgdmFyIHdvcmQgPSAoKCh3IDw8IG9mZikgfCBjYXJyeSkgJiAweGZmZmZmZikudG9TdHJpbmcoMTYpO1xuXHQgICAgICAgIGNhcnJ5ID0gKHcgPj4+ICgyNCAtIG9mZikpICYgMHhmZmZmZmY7XG5cdCAgICAgICAgaWYgKGNhcnJ5ICE9PSAwIHx8IGkgIT09IHRoaXMubGVuZ3RoIC0gMSkge1xuXHQgICAgICAgICAgb3V0ID0gemVyb3NbNiAtIHdvcmQubGVuZ3RoXSArIHdvcmQgKyBvdXQ7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIG91dCA9IHdvcmQgKyBvdXQ7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIG9mZiArPSAyO1xuXHQgICAgICAgIGlmIChvZmYgPj0gMjYpIHtcblx0ICAgICAgICAgIG9mZiAtPSAyNjtcblx0ICAgICAgICAgIGktLTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG5cdCAgICAgICAgb3V0ID0gY2FycnkudG9TdHJpbmcoMTYpICsgb3V0O1xuXHQgICAgICB9XG5cdCAgICAgIHdoaWxlIChvdXQubGVuZ3RoICUgcGFkZGluZyAhPT0gMCkge1xuXHQgICAgICAgIG91dCA9ICcwJyArIG91dDtcblx0ICAgICAgfVxuXHQgICAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuXHQgICAgICAgIG91dCA9ICctJyArIG91dDtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gb3V0O1xuXHQgICAgfVxuXG5cdCAgICBpZiAoYmFzZSA9PT0gKGJhc2UgfCAwKSAmJiBiYXNlID49IDIgJiYgYmFzZSA8PSAzNikge1xuXHQgICAgICAvLyB2YXIgZ3JvdXBTaXplID0gTWF0aC5mbG9vcihCTi53b3JkU2l6ZSAqIE1hdGguTE4yIC8gTWF0aC5sb2coYmFzZSkpO1xuXHQgICAgICB2YXIgZ3JvdXBTaXplID0gZ3JvdXBTaXplc1tiYXNlXTtcblx0ICAgICAgLy8gdmFyIGdyb3VwQmFzZSA9IE1hdGgucG93KGJhc2UsIGdyb3VwU2l6ZSk7XG5cdCAgICAgIHZhciBncm91cEJhc2UgPSBncm91cEJhc2VzW2Jhc2VdO1xuXHQgICAgICBvdXQgPSAnJztcblx0ICAgICAgdmFyIGMgPSB0aGlzLmNsb25lKCk7XG5cdCAgICAgIGMubmVnYXRpdmUgPSAwO1xuXHQgICAgICB3aGlsZSAoIWMuaXNaZXJvKCkpIHtcblx0ICAgICAgICB2YXIgciA9IGMubW9kbihncm91cEJhc2UpLnRvU3RyaW5nKGJhc2UpO1xuXHQgICAgICAgIGMgPSBjLmlkaXZuKGdyb3VwQmFzZSk7XG5cblx0ICAgICAgICBpZiAoIWMuaXNaZXJvKCkpIHtcblx0ICAgICAgICAgIG91dCA9IHplcm9zW2dyb3VwU2l6ZSAtIHIubGVuZ3RoXSArIHIgKyBvdXQ7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIG91dCA9IHIgKyBvdXQ7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIGlmICh0aGlzLmlzWmVybygpKSB7XG5cdCAgICAgICAgb3V0ID0gJzAnICsgb3V0O1xuXHQgICAgICB9XG5cdCAgICAgIHdoaWxlIChvdXQubGVuZ3RoICUgcGFkZGluZyAhPT0gMCkge1xuXHQgICAgICAgIG91dCA9ICcwJyArIG91dDtcblx0ICAgICAgfVxuXHQgICAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuXHQgICAgICAgIG91dCA9ICctJyArIG91dDtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gb3V0O1xuXHQgICAgfVxuXG5cdCAgICBhc3NlcnQoZmFsc2UsICdCYXNlIHNob3VsZCBiZSBiZXR3ZWVuIDIgYW5kIDM2Jyk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uIHRvTnVtYmVyICgpIHtcblx0ICAgIHZhciByZXQgPSB0aGlzLndvcmRzWzBdO1xuXHQgICAgaWYgKHRoaXMubGVuZ3RoID09PSAyKSB7XG5cdCAgICAgIHJldCArPSB0aGlzLndvcmRzWzFdICogMHg0MDAwMDAwO1xuXHQgICAgfSBlbHNlIGlmICh0aGlzLmxlbmd0aCA9PT0gMyAmJiB0aGlzLndvcmRzWzJdID09PSAweDAxKSB7XG5cdCAgICAgIC8vIE5PVEU6IGF0IHRoaXMgc3RhZ2UgaXQgaXMga25vd24gdGhhdCB0aGUgdG9wIGJpdCBpcyBzZXRcblx0ICAgICAgcmV0ICs9IDB4MTAwMDAwMDAwMDAwMDAgKyAodGhpcy53b3Jkc1sxXSAqIDB4NDAwMDAwMCk7XG5cdCAgICB9IGVsc2UgaWYgKHRoaXMubGVuZ3RoID4gMikge1xuXHQgICAgICBhc3NlcnQoZmFsc2UsICdOdW1iZXIgY2FuIG9ubHkgc2FmZWx5IHN0b3JlIHVwIHRvIDUzIGJpdHMnKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkgPyAtcmV0IDogcmV0O1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcblx0ICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKDE2KTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLnRvQnVmZmVyID0gZnVuY3Rpb24gdG9CdWZmZXIgKGVuZGlhbiwgbGVuZ3RoKSB7XG5cdCAgICBhc3NlcnQodHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpO1xuXHQgICAgcmV0dXJuIHRoaXMudG9BcnJheUxpa2UoQnVmZmVyLCBlbmRpYW4sIGxlbmd0aCk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gdG9BcnJheSAoZW5kaWFuLCBsZW5ndGgpIHtcblx0ICAgIHJldHVybiB0aGlzLnRvQXJyYXlMaWtlKEFycmF5LCBlbmRpYW4sIGxlbmd0aCk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS50b0FycmF5TGlrZSA9IGZ1bmN0aW9uIHRvQXJyYXlMaWtlIChBcnJheVR5cGUsIGVuZGlhbiwgbGVuZ3RoKSB7XG5cdCAgICB2YXIgYnl0ZUxlbmd0aCA9IHRoaXMuYnl0ZUxlbmd0aCgpO1xuXHQgICAgdmFyIHJlcUxlbmd0aCA9IGxlbmd0aCB8fCBNYXRoLm1heCgxLCBieXRlTGVuZ3RoKTtcblx0ICAgIGFzc2VydChieXRlTGVuZ3RoIDw9IHJlcUxlbmd0aCwgJ2J5dGUgYXJyYXkgbG9uZ2VyIHRoYW4gZGVzaXJlZCBsZW5ndGgnKTtcblx0ICAgIGFzc2VydChyZXFMZW5ndGggPiAwLCAnUmVxdWVzdGVkIGFycmF5IGxlbmd0aCA8PSAwJyk7XG5cblx0ICAgIHRoaXMuc3RyaXAoKTtcblx0ICAgIHZhciBsaXR0bGVFbmRpYW4gPSBlbmRpYW4gPT09ICdsZSc7XG5cdCAgICB2YXIgcmVzID0gbmV3IEFycmF5VHlwZShyZXFMZW5ndGgpO1xuXG5cdCAgICB2YXIgYiwgaTtcblx0ICAgIHZhciBxID0gdGhpcy5jbG9uZSgpO1xuXHQgICAgaWYgKCFsaXR0bGVFbmRpYW4pIHtcblx0ICAgICAgLy8gQXNzdW1lIGJpZy1lbmRpYW5cblx0ICAgICAgZm9yIChpID0gMDsgaSA8IHJlcUxlbmd0aCAtIGJ5dGVMZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHJlc1tpXSA9IDA7XG5cdCAgICAgIH1cblxuXHQgICAgICBmb3IgKGkgPSAwOyAhcS5pc1plcm8oKTsgaSsrKSB7XG5cdCAgICAgICAgYiA9IHEuYW5kbG4oMHhmZik7XG5cdCAgICAgICAgcS5pdXNocm4oOCk7XG5cblx0ICAgICAgICByZXNbcmVxTGVuZ3RoIC0gaSAtIDFdID0gYjtcblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgZm9yIChpID0gMDsgIXEuaXNaZXJvKCk7IGkrKykge1xuXHQgICAgICAgIGIgPSBxLmFuZGxuKDB4ZmYpO1xuXHQgICAgICAgIHEuaXVzaHJuKDgpO1xuXG5cdCAgICAgICAgcmVzW2ldID0gYjtcblx0ICAgICAgfVxuXG5cdCAgICAgIGZvciAoOyBpIDwgcmVxTGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICByZXNbaV0gPSAwO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiByZXM7XG5cdCAgfTtcblxuXHQgIGlmIChNYXRoLmNsejMyKSB7XG5cdCAgICBCTi5wcm90b3R5cGUuX2NvdW50Qml0cyA9IGZ1bmN0aW9uIF9jb3VudEJpdHMgKHcpIHtcblx0ICAgICAgcmV0dXJuIDMyIC0gTWF0aC5jbHozMih3KTtcblx0ICAgIH07XG5cdCAgfSBlbHNlIHtcblx0ICAgIEJOLnByb3RvdHlwZS5fY291bnRCaXRzID0gZnVuY3Rpb24gX2NvdW50Qml0cyAodykge1xuXHQgICAgICB2YXIgdCA9IHc7XG5cdCAgICAgIHZhciByID0gMDtcblx0ICAgICAgaWYgKHQgPj0gMHgxMDAwKSB7XG5cdCAgICAgICAgciArPSAxMztcblx0ICAgICAgICB0ID4+Pj0gMTM7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKHQgPj0gMHg0MCkge1xuXHQgICAgICAgIHIgKz0gNztcblx0ICAgICAgICB0ID4+Pj0gNztcblx0ICAgICAgfVxuXHQgICAgICBpZiAodCA+PSAweDgpIHtcblx0ICAgICAgICByICs9IDQ7XG5cdCAgICAgICAgdCA+Pj49IDQ7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKHQgPj0gMHgwMikge1xuXHQgICAgICAgIHIgKz0gMjtcblx0ICAgICAgICB0ID4+Pj0gMjtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gciArIHQ7XG5cdCAgICB9O1xuXHQgIH1cblxuXHQgIEJOLnByb3RvdHlwZS5femVyb0JpdHMgPSBmdW5jdGlvbiBfemVyb0JpdHMgKHcpIHtcblx0ICAgIC8vIFNob3J0LWN1dFxuXHQgICAgaWYgKHcgPT09IDApIHJldHVybiAyNjtcblxuXHQgICAgdmFyIHQgPSB3O1xuXHQgICAgdmFyIHIgPSAwO1xuXHQgICAgaWYgKCh0ICYgMHgxZmZmKSA9PT0gMCkge1xuXHQgICAgICByICs9IDEzO1xuXHQgICAgICB0ID4+Pj0gMTM7XG5cdCAgICB9XG5cdCAgICBpZiAoKHQgJiAweDdmKSA9PT0gMCkge1xuXHQgICAgICByICs9IDc7XG5cdCAgICAgIHQgPj4+PSA3O1xuXHQgICAgfVxuXHQgICAgaWYgKCh0ICYgMHhmKSA9PT0gMCkge1xuXHQgICAgICByICs9IDQ7XG5cdCAgICAgIHQgPj4+PSA0O1xuXHQgICAgfVxuXHQgICAgaWYgKCh0ICYgMHgzKSA9PT0gMCkge1xuXHQgICAgICByICs9IDI7XG5cdCAgICAgIHQgPj4+PSAyO1xuXHQgICAgfVxuXHQgICAgaWYgKCh0ICYgMHgxKSA9PT0gMCkge1xuXHQgICAgICByKys7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcjtcblx0ICB9O1xuXG5cdCAgLy8gUmV0dXJuIG51bWJlciBvZiB1c2VkIGJpdHMgaW4gYSBCTlxuXHQgIEJOLnByb3RvdHlwZS5iaXRMZW5ndGggPSBmdW5jdGlvbiBiaXRMZW5ndGggKCkge1xuXHQgICAgdmFyIHcgPSB0aGlzLndvcmRzW3RoaXMubGVuZ3RoIC0gMV07XG5cdCAgICB2YXIgaGkgPSB0aGlzLl9jb3VudEJpdHModyk7XG5cdCAgICByZXR1cm4gKHRoaXMubGVuZ3RoIC0gMSkgKiAyNiArIGhpO1xuXHQgIH07XG5cblx0ICBmdW5jdGlvbiB0b0JpdEFycmF5IChudW0pIHtcblx0ICAgIHZhciB3ID0gbmV3IEFycmF5KG51bS5iaXRMZW5ndGgoKSk7XG5cblx0ICAgIGZvciAodmFyIGJpdCA9IDA7IGJpdCA8IHcubGVuZ3RoOyBiaXQrKykge1xuXHQgICAgICB2YXIgb2ZmID0gKGJpdCAvIDI2KSB8IDA7XG5cdCAgICAgIHZhciB3Yml0ID0gYml0ICUgMjY7XG5cblx0ICAgICAgd1tiaXRdID0gKG51bS53b3Jkc1tvZmZdICYgKDEgPDwgd2JpdCkpID4+PiB3Yml0O1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdztcblx0ICB9XG5cblx0ICAvLyBOdW1iZXIgb2YgdHJhaWxpbmcgemVybyBiaXRzXG5cdCAgQk4ucHJvdG90eXBlLnplcm9CaXRzID0gZnVuY3Rpb24gemVyb0JpdHMgKCkge1xuXHQgICAgaWYgKHRoaXMuaXNaZXJvKCkpIHJldHVybiAwO1xuXG5cdCAgICB2YXIgciA9IDA7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIGIgPSB0aGlzLl96ZXJvQml0cyh0aGlzLndvcmRzW2ldKTtcblx0ICAgICAgciArPSBiO1xuXHQgICAgICBpZiAoYiAhPT0gMjYpIGJyZWFrO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHI7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5ieXRlTGVuZ3RoID0gZnVuY3Rpb24gYnl0ZUxlbmd0aCAoKSB7XG5cdCAgICByZXR1cm4gTWF0aC5jZWlsKHRoaXMuYml0TGVuZ3RoKCkgLyA4KTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLnRvVHdvcyA9IGZ1bmN0aW9uIHRvVHdvcyAod2lkdGgpIHtcblx0ICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLmFicygpLmlub3RuKHdpZHRoKS5pYWRkbigxKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB0aGlzLmNsb25lKCk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5mcm9tVHdvcyA9IGZ1bmN0aW9uIGZyb21Ud29zICh3aWR0aCkge1xuXHQgICAgaWYgKHRoaXMudGVzdG4od2lkdGggLSAxKSkge1xuXHQgICAgICByZXR1cm4gdGhpcy5ub3RuKHdpZHRoKS5pYWRkbigxKS5pbmVnKCk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdGhpcy5jbG9uZSgpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuaXNOZWcgPSBmdW5jdGlvbiBpc05lZyAoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5uZWdhdGl2ZSAhPT0gMDtcblx0ICB9O1xuXG5cdCAgLy8gUmV0dXJuIG5lZ2F0aXZlIGNsb25lIG9mIGB0aGlzYFxuXHQgIEJOLnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbiBuZWcgKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbmVnKCk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5pbmVnID0gZnVuY3Rpb24gaW5lZyAoKSB7XG5cdCAgICBpZiAoIXRoaXMuaXNaZXJvKCkpIHtcblx0ICAgICAgdGhpcy5uZWdhdGl2ZSBePSAxO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXG5cdCAgLy8gT3IgYG51bWAgd2l0aCBgdGhpc2AgaW4tcGxhY2Vcblx0ICBCTi5wcm90b3R5cGUuaXVvciA9IGZ1bmN0aW9uIGl1b3IgKG51bSkge1xuXHQgICAgd2hpbGUgKHRoaXMubGVuZ3RoIDwgbnVtLmxlbmd0aCkge1xuXHQgICAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoKytdID0gMDtcblx0ICAgIH1cblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW0ubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdGhpcy53b3Jkc1tpXSA9IHRoaXMud29yZHNbaV0gfCBudW0ud29yZHNbaV07XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5pb3IgPSBmdW5jdGlvbiBpb3IgKG51bSkge1xuXHQgICAgYXNzZXJ0KCh0aGlzLm5lZ2F0aXZlIHwgbnVtLm5lZ2F0aXZlKSA9PT0gMCk7XG5cdCAgICByZXR1cm4gdGhpcy5pdW9yKG51bSk7XG5cdCAgfTtcblxuXHQgIC8vIE9yIGBudW1gIHdpdGggYHRoaXNgXG5cdCAgQk4ucHJvdG90eXBlLm9yID0gZnVuY3Rpb24gb3IgKG51bSkge1xuXHQgICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pb3IobnVtKTtcblx0ICAgIHJldHVybiBudW0uY2xvbmUoKS5pb3IodGhpcyk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS51b3IgPSBmdW5jdGlvbiB1b3IgKG51bSkge1xuXHQgICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdW9yKG51bSk7XG5cdCAgICByZXR1cm4gbnVtLmNsb25lKCkuaXVvcih0aGlzKTtcblx0ICB9O1xuXG5cdCAgLy8gQW5kIGBudW1gIHdpdGggYHRoaXNgIGluLXBsYWNlXG5cdCAgQk4ucHJvdG90eXBlLml1YW5kID0gZnVuY3Rpb24gaXVhbmQgKG51bSkge1xuXHQgICAgLy8gYiA9IG1pbi1sZW5ndGgobnVtLCB0aGlzKVxuXHQgICAgdmFyIGI7XG5cdCAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSB7XG5cdCAgICAgIGIgPSBudW07XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBiID0gdGhpcztcblx0ICAgIH1cblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHRoaXMud29yZHNbaV0gPSB0aGlzLndvcmRzW2ldICYgbnVtLndvcmRzW2ldO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLmxlbmd0aCA9IGIubGVuZ3RoO1xuXG5cdCAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuaWFuZCA9IGZ1bmN0aW9uIGlhbmQgKG51bSkge1xuXHQgICAgYXNzZXJ0KCh0aGlzLm5lZ2F0aXZlIHwgbnVtLm5lZ2F0aXZlKSA9PT0gMCk7XG5cdCAgICByZXR1cm4gdGhpcy5pdWFuZChudW0pO1xuXHQgIH07XG5cblx0ICAvLyBBbmQgYG51bWAgd2l0aCBgdGhpc2Bcblx0ICBCTi5wcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gYW5kIChudW0pIHtcblx0ICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaWFuZChudW0pO1xuXHQgICAgcmV0dXJuIG51bS5jbG9uZSgpLmlhbmQodGhpcyk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS51YW5kID0gZnVuY3Rpb24gdWFuZCAobnVtKSB7XG5cdCAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLml1YW5kKG51bSk7XG5cdCAgICByZXR1cm4gbnVtLmNsb25lKCkuaXVhbmQodGhpcyk7XG5cdCAgfTtcblxuXHQgIC8vIFhvciBgbnVtYCB3aXRoIGB0aGlzYCBpbi1wbGFjZVxuXHQgIEJOLnByb3RvdHlwZS5pdXhvciA9IGZ1bmN0aW9uIGl1eG9yIChudW0pIHtcblx0ICAgIC8vIGEubGVuZ3RoID4gYi5sZW5ndGhcblx0ICAgIHZhciBhO1xuXHQgICAgdmFyIGI7XG5cdCAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSB7XG5cdCAgICAgIGEgPSB0aGlzO1xuXHQgICAgICBiID0gbnVtO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgYSA9IG51bTtcblx0ICAgICAgYiA9IHRoaXM7XG5cdCAgICB9XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuXHQgICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXSBeIGIud29yZHNbaV07XG5cdCAgICB9XG5cblx0ICAgIGlmICh0aGlzICE9PSBhKSB7XG5cdCAgICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHRoaXMud29yZHNbaV0gPSBhLndvcmRzW2ldO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHRoaXMubGVuZ3RoID0gYS5sZW5ndGg7XG5cblx0ICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5peG9yID0gZnVuY3Rpb24gaXhvciAobnVtKSB7XG5cdCAgICBhc3NlcnQoKHRoaXMubmVnYXRpdmUgfCBudW0ubmVnYXRpdmUpID09PSAwKTtcblx0ICAgIHJldHVybiB0aGlzLml1eG9yKG51bSk7XG5cdCAgfTtcblxuXHQgIC8vIFhvciBgbnVtYCB3aXRoIGB0aGlzYFxuXHQgIEJOLnByb3RvdHlwZS54b3IgPSBmdW5jdGlvbiB4b3IgKG51bSkge1xuXHQgICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5peG9yKG51bSk7XG5cdCAgICByZXR1cm4gbnVtLmNsb25lKCkuaXhvcih0aGlzKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLnV4b3IgPSBmdW5jdGlvbiB1eG9yIChudW0pIHtcblx0ICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaXV4b3IobnVtKTtcblx0ICAgIHJldHVybiBudW0uY2xvbmUoKS5pdXhvcih0aGlzKTtcblx0ICB9O1xuXG5cdCAgLy8gTm90IGBgdGhpc2BgIHdpdGggYGB3aWR0aGBgIGJpdHdpZHRoXG5cdCAgQk4ucHJvdG90eXBlLmlub3RuID0gZnVuY3Rpb24gaW5vdG4gKHdpZHRoKSB7XG5cdCAgICBhc3NlcnQodHlwZW9mIHdpZHRoID09PSAnbnVtYmVyJyAmJiB3aWR0aCA+PSAwKTtcblxuXHQgICAgdmFyIGJ5dGVzTmVlZGVkID0gTWF0aC5jZWlsKHdpZHRoIC8gMjYpIHwgMDtcblx0ICAgIHZhciBiaXRzTGVmdCA9IHdpZHRoICUgMjY7XG5cblx0ICAgIC8vIEV4dGVuZCB0aGUgYnVmZmVyIHdpdGggbGVhZGluZyB6ZXJvZXNcblx0ICAgIHRoaXMuX2V4cGFuZChieXRlc05lZWRlZCk7XG5cblx0ICAgIGlmIChiaXRzTGVmdCA+IDApIHtcblx0ICAgICAgYnl0ZXNOZWVkZWQtLTtcblx0ICAgIH1cblxuXHQgICAgLy8gSGFuZGxlIGNvbXBsZXRlIHdvcmRzXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzTmVlZGVkOyBpKyspIHtcblx0ICAgICAgdGhpcy53b3Jkc1tpXSA9IH50aGlzLndvcmRzW2ldICYgMHgzZmZmZmZmO1xuXHQgICAgfVxuXG5cdCAgICAvLyBIYW5kbGUgdGhlIHJlc2lkdWVcblx0ICAgIGlmIChiaXRzTGVmdCA+IDApIHtcblx0ICAgICAgdGhpcy53b3Jkc1tpXSA9IH50aGlzLndvcmRzW2ldICYgKDB4M2ZmZmZmZiA+PiAoMjYgLSBiaXRzTGVmdCkpO1xuXHQgICAgfVxuXG5cdCAgICAvLyBBbmQgcmVtb3ZlIGxlYWRpbmcgemVyb2VzXG5cdCAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUubm90biA9IGZ1bmN0aW9uIG5vdG4gKHdpZHRoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlub3RuKHdpZHRoKTtcblx0ICB9O1xuXG5cdCAgLy8gU2V0IGBiaXRgIG9mIGB0aGlzYFxuXHQgIEJOLnByb3RvdHlwZS5zZXRuID0gZnVuY3Rpb24gc2V0biAoYml0LCB2YWwpIHtcblx0ICAgIGFzc2VydCh0eXBlb2YgYml0ID09PSAnbnVtYmVyJyAmJiBiaXQgPj0gMCk7XG5cblx0ICAgIHZhciBvZmYgPSAoYml0IC8gMjYpIHwgMDtcblx0ICAgIHZhciB3Yml0ID0gYml0ICUgMjY7XG5cblx0ICAgIHRoaXMuX2V4cGFuZChvZmYgKyAxKTtcblxuXHQgICAgaWYgKHZhbCkge1xuXHQgICAgICB0aGlzLndvcmRzW29mZl0gPSB0aGlzLndvcmRzW29mZl0gfCAoMSA8PCB3Yml0KTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHRoaXMud29yZHNbb2ZmXSA9IHRoaXMud29yZHNbb2ZmXSAmIH4oMSA8PCB3Yml0KTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcblx0ICB9O1xuXG5cdCAgLy8gQWRkIGBudW1gIHRvIGB0aGlzYCBpbi1wbGFjZVxuXHQgIEJOLnByb3RvdHlwZS5pYWRkID0gZnVuY3Rpb24gaWFkZCAobnVtKSB7XG5cdCAgICB2YXIgcjtcblxuXHQgICAgLy8gbmVnYXRpdmUgKyBwb3NpdGl2ZVxuXHQgICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDAgJiYgbnVtLm5lZ2F0aXZlID09PSAwKSB7XG5cdCAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuXHQgICAgICByID0gdGhpcy5pc3ViKG51bSk7XG5cdCAgICAgIHRoaXMubmVnYXRpdmUgXj0gMTtcblx0ICAgICAgcmV0dXJuIHRoaXMuX25vcm1TaWduKCk7XG5cblx0ICAgIC8vIHBvc2l0aXZlICsgbmVnYXRpdmVcblx0ICAgIH0gZWxzZSBpZiAodGhpcy5uZWdhdGl2ZSA9PT0gMCAmJiBudW0ubmVnYXRpdmUgIT09IDApIHtcblx0ICAgICAgbnVtLm5lZ2F0aXZlID0gMDtcblx0ICAgICAgciA9IHRoaXMuaXN1YihudW0pO1xuXHQgICAgICBudW0ubmVnYXRpdmUgPSAxO1xuXHQgICAgICByZXR1cm4gci5fbm9ybVNpZ24oKTtcblx0ICAgIH1cblxuXHQgICAgLy8gYS5sZW5ndGggPiBiLmxlbmd0aFxuXHQgICAgdmFyIGEsIGI7XG5cdCAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSB7XG5cdCAgICAgIGEgPSB0aGlzO1xuXHQgICAgICBiID0gbnVtO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgYSA9IG51bTtcblx0ICAgICAgYiA9IHRoaXM7XG5cdCAgICB9XG5cblx0ICAgIHZhciBjYXJyeSA9IDA7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgciA9IChhLndvcmRzW2ldIHwgMCkgKyAoYi53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG5cdCAgICAgIHRoaXMud29yZHNbaV0gPSByICYgMHgzZmZmZmZmO1xuXHQgICAgICBjYXJyeSA9IHIgPj4+IDI2O1xuXHQgICAgfVxuXHQgICAgZm9yICg7IGNhcnJ5ICE9PSAwICYmIGkgPCBhLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHIgPSAoYS53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG5cdCAgICAgIHRoaXMud29yZHNbaV0gPSByICYgMHgzZmZmZmZmO1xuXHQgICAgICBjYXJyeSA9IHIgPj4+IDI2O1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLmxlbmd0aCA9IGEubGVuZ3RoO1xuXHQgICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG5cdCAgICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGhdID0gY2Fycnk7XG5cdCAgICAgIHRoaXMubGVuZ3RoKys7XG5cdCAgICAvLyBDb3B5IHRoZSByZXN0IG9mIHRoZSB3b3Jkc1xuXHQgICAgfSBlbHNlIGlmIChhICE9PSB0aGlzKSB7XG5cdCAgICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHRoaXMud29yZHNbaV0gPSBhLndvcmRzW2ldO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cblx0ICAvLyBBZGQgYG51bWAgdG8gYHRoaXNgXG5cdCAgQk4ucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAobnVtKSB7XG5cdCAgICB2YXIgcmVzO1xuXHQgICAgaWYgKG51bS5uZWdhdGl2ZSAhPT0gMCAmJiB0aGlzLm5lZ2F0aXZlID09PSAwKSB7XG5cdCAgICAgIG51bS5uZWdhdGl2ZSA9IDA7XG5cdCAgICAgIHJlcyA9IHRoaXMuc3ViKG51bSk7XG5cdCAgICAgIG51bS5uZWdhdGl2ZSBePSAxO1xuXHQgICAgICByZXR1cm4gcmVzO1xuXHQgICAgfSBlbHNlIGlmIChudW0ubmVnYXRpdmUgPT09IDAgJiYgdGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuXHQgICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcblx0ICAgICAgcmVzID0gbnVtLnN1Yih0aGlzKTtcblx0ICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG5cdCAgICAgIHJldHVybiByZXM7XG5cdCAgICB9XG5cblx0ICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaWFkZChudW0pO1xuXG5cdCAgICByZXR1cm4gbnVtLmNsb25lKCkuaWFkZCh0aGlzKTtcblx0ICB9O1xuXG5cdCAgLy8gU3VidHJhY3QgYG51bWAgZnJvbSBgdGhpc2AgaW4tcGxhY2Vcblx0ICBCTi5wcm90b3R5cGUuaXN1YiA9IGZ1bmN0aW9uIGlzdWIgKG51bSkge1xuXHQgICAgLy8gdGhpcyAtICgtbnVtKSA9IHRoaXMgKyBudW1cblx0ICAgIGlmIChudW0ubmVnYXRpdmUgIT09IDApIHtcblx0ICAgICAgbnVtLm5lZ2F0aXZlID0gMDtcblx0ICAgICAgdmFyIHIgPSB0aGlzLmlhZGQobnVtKTtcblx0ICAgICAgbnVtLm5lZ2F0aXZlID0gMTtcblx0ICAgICAgcmV0dXJuIHIuX25vcm1TaWduKCk7XG5cblx0ICAgIC8vIC10aGlzIC0gbnVtID0gLSh0aGlzICsgbnVtKVxuXHQgICAgfSBlbHNlIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG5cdCAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuXHQgICAgICB0aGlzLmlhZGQobnVtKTtcblx0ICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG5cdCAgICAgIHJldHVybiB0aGlzLl9ub3JtU2lnbigpO1xuXHQgICAgfVxuXG5cdCAgICAvLyBBdCB0aGlzIHBvaW50IGJvdGggbnVtYmVycyBhcmUgcG9zaXRpdmVcblx0ICAgIHZhciBjbXAgPSB0aGlzLmNtcChudW0pO1xuXG5cdCAgICAvLyBPcHRpbWl6YXRpb24gLSB6ZXJvaWZ5XG5cdCAgICBpZiAoY21wID09PSAwKSB7XG5cdCAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuXHQgICAgICB0aGlzLmxlbmd0aCA9IDE7XG5cdCAgICAgIHRoaXMud29yZHNbMF0gPSAwO1xuXHQgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH1cblxuXHQgICAgLy8gYSA+IGJcblx0ICAgIHZhciBhLCBiO1xuXHQgICAgaWYgKGNtcCA+IDApIHtcblx0ICAgICAgYSA9IHRoaXM7XG5cdCAgICAgIGIgPSBudW07XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBhID0gbnVtO1xuXHQgICAgICBiID0gdGhpcztcblx0ICAgIH1cblxuXHQgICAgdmFyIGNhcnJ5ID0gMDtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuXHQgICAgICByID0gKGEud29yZHNbaV0gfCAwKSAtIChiLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcblx0ICAgICAgY2FycnkgPSByID4+IDI2O1xuXHQgICAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcblx0ICAgIH1cblx0ICAgIGZvciAoOyBjYXJyeSAhPT0gMCAmJiBpIDwgYS5sZW5ndGg7IGkrKykge1xuXHQgICAgICByID0gKGEud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuXHQgICAgICBjYXJyeSA9IHIgPj4gMjY7XG5cdCAgICAgIHRoaXMud29yZHNbaV0gPSByICYgMHgzZmZmZmZmO1xuXHQgICAgfVxuXG5cdCAgICAvLyBDb3B5IHJlc3Qgb2YgdGhlIHdvcmRzXG5cdCAgICBpZiAoY2FycnkgPT09IDAgJiYgaSA8IGEubGVuZ3RoICYmIGEgIT09IHRoaXMpIHtcblx0ICAgICAgZm9yICg7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV07XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgdGhpcy5sZW5ndGggPSBNYXRoLm1heCh0aGlzLmxlbmd0aCwgaSk7XG5cblx0ICAgIGlmIChhICE9PSB0aGlzKSB7XG5cdCAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuXHQgIH07XG5cblx0ICAvLyBTdWJ0cmFjdCBgbnVtYCBmcm9tIGB0aGlzYFxuXHQgIEJOLnByb3RvdHlwZS5zdWIgPSBmdW5jdGlvbiBzdWIgKG51bSkge1xuXHQgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc3ViKG51bSk7XG5cdCAgfTtcblxuXHQgIGZ1bmN0aW9uIHNtYWxsTXVsVG8gKHNlbGYsIG51bSwgb3V0KSB7XG5cdCAgICBvdXQubmVnYXRpdmUgPSBudW0ubmVnYXRpdmUgXiBzZWxmLm5lZ2F0aXZlO1xuXHQgICAgdmFyIGxlbiA9IChzZWxmLmxlbmd0aCArIG51bS5sZW5ndGgpIHwgMDtcblx0ICAgIG91dC5sZW5ndGggPSBsZW47XG5cdCAgICBsZW4gPSAobGVuIC0gMSkgfCAwO1xuXG5cdCAgICAvLyBQZWVsIG9uZSBpdGVyYXRpb24gKGNvbXBpbGVyIGNhbid0IGRvIGl0LCBiZWNhdXNlIG9mIGNvZGUgY29tcGxleGl0eSlcblx0ICAgIHZhciBhID0gc2VsZi53b3Jkc1swXSB8IDA7XG5cdCAgICB2YXIgYiA9IG51bS53b3Jkc1swXSB8IDA7XG5cdCAgICB2YXIgciA9IGEgKiBiO1xuXG5cdCAgICB2YXIgbG8gPSByICYgMHgzZmZmZmZmO1xuXHQgICAgdmFyIGNhcnJ5ID0gKHIgLyAweDQwMDAwMDApIHwgMDtcblx0ICAgIG91dC53b3Jkc1swXSA9IGxvO1xuXG5cdCAgICBmb3IgKHZhciBrID0gMTsgayA8IGxlbjsgaysrKSB7XG5cdCAgICAgIC8vIFN1bSBhbGwgd29yZHMgd2l0aCB0aGUgc2FtZSBgaSArIGogPSBrYCBhbmQgYWNjdW11bGF0ZSBgbmNhcnJ5YCxcblx0ICAgICAgLy8gbm90ZSB0aGF0IG5jYXJyeSBjb3VsZCBiZSA+PSAweDNmZmZmZmZcblx0ICAgICAgdmFyIG5jYXJyeSA9IGNhcnJ5ID4+PiAyNjtcblx0ICAgICAgdmFyIHJ3b3JkID0gY2FycnkgJiAweDNmZmZmZmY7XG5cdCAgICAgIHZhciBtYXhKID0gTWF0aC5taW4oaywgbnVtLmxlbmd0aCAtIDEpO1xuXHQgICAgICBmb3IgKHZhciBqID0gTWF0aC5tYXgoMCwgayAtIHNlbGYubGVuZ3RoICsgMSk7IGogPD0gbWF4SjsgaisrKSB7XG5cdCAgICAgICAgdmFyIGkgPSAoayAtIGopIHwgMDtcblx0ICAgICAgICBhID0gc2VsZi53b3Jkc1tpXSB8IDA7XG5cdCAgICAgICAgYiA9IG51bS53b3Jkc1tqXSB8IDA7XG5cdCAgICAgICAgciA9IGEgKiBiICsgcndvcmQ7XG5cdCAgICAgICAgbmNhcnJ5ICs9IChyIC8gMHg0MDAwMDAwKSB8IDA7XG5cdCAgICAgICAgcndvcmQgPSByICYgMHgzZmZmZmZmO1xuXHQgICAgICB9XG5cdCAgICAgIG91dC53b3Jkc1trXSA9IHJ3b3JkIHwgMDtcblx0ICAgICAgY2FycnkgPSBuY2FycnkgfCAwO1xuXHQgICAgfVxuXHQgICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG5cdCAgICAgIG91dC53b3Jkc1trXSA9IGNhcnJ5IHwgMDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIG91dC5sZW5ndGgtLTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIG91dC5zdHJpcCgpO1xuXHQgIH1cblxuXHQgIC8vIFRPRE8oaW5kdXRueSk6IGl0IG1heSBiZSByZWFzb25hYmxlIHRvIG9taXQgaXQgZm9yIHVzZXJzIHdobyBkb24ndCBuZWVkXG5cdCAgLy8gdG8gd29yayB3aXRoIDI1Ni1iaXQgbnVtYmVycywgb3RoZXJ3aXNlIGl0IGdpdmVzIDIwJSBpbXByb3ZlbWVudCBmb3IgMjU2LWJpdFxuXHQgIC8vIG11bHRpcGxpY2F0aW9uIChsaWtlIGVsbGlwdGljIHNlY3AyNTZrMSkuXG5cdCAgdmFyIGNvbWIxME11bFRvID0gZnVuY3Rpb24gY29tYjEwTXVsVG8gKHNlbGYsIG51bSwgb3V0KSB7XG5cdCAgICB2YXIgYSA9IHNlbGYud29yZHM7XG5cdCAgICB2YXIgYiA9IG51bS53b3Jkcztcblx0ICAgIHZhciBvID0gb3V0LndvcmRzO1xuXHQgICAgdmFyIGMgPSAwO1xuXHQgICAgdmFyIGxvO1xuXHQgICAgdmFyIG1pZDtcblx0ICAgIHZhciBoaTtcblx0ICAgIHZhciBhMCA9IGFbMF0gfCAwO1xuXHQgICAgdmFyIGFsMCA9IGEwICYgMHgxZmZmO1xuXHQgICAgdmFyIGFoMCA9IGEwID4+PiAxMztcblx0ICAgIHZhciBhMSA9IGFbMV0gfCAwO1xuXHQgICAgdmFyIGFsMSA9IGExICYgMHgxZmZmO1xuXHQgICAgdmFyIGFoMSA9IGExID4+PiAxMztcblx0ICAgIHZhciBhMiA9IGFbMl0gfCAwO1xuXHQgICAgdmFyIGFsMiA9IGEyICYgMHgxZmZmO1xuXHQgICAgdmFyIGFoMiA9IGEyID4+PiAxMztcblx0ICAgIHZhciBhMyA9IGFbM10gfCAwO1xuXHQgICAgdmFyIGFsMyA9IGEzICYgMHgxZmZmO1xuXHQgICAgdmFyIGFoMyA9IGEzID4+PiAxMztcblx0ICAgIHZhciBhNCA9IGFbNF0gfCAwO1xuXHQgICAgdmFyIGFsNCA9IGE0ICYgMHgxZmZmO1xuXHQgICAgdmFyIGFoNCA9IGE0ID4+PiAxMztcblx0ICAgIHZhciBhNSA9IGFbNV0gfCAwO1xuXHQgICAgdmFyIGFsNSA9IGE1ICYgMHgxZmZmO1xuXHQgICAgdmFyIGFoNSA9IGE1ID4+PiAxMztcblx0ICAgIHZhciBhNiA9IGFbNl0gfCAwO1xuXHQgICAgdmFyIGFsNiA9IGE2ICYgMHgxZmZmO1xuXHQgICAgdmFyIGFoNiA9IGE2ID4+PiAxMztcblx0ICAgIHZhciBhNyA9IGFbN10gfCAwO1xuXHQgICAgdmFyIGFsNyA9IGE3ICYgMHgxZmZmO1xuXHQgICAgdmFyIGFoNyA9IGE3ID4+PiAxMztcblx0ICAgIHZhciBhOCA9IGFbOF0gfCAwO1xuXHQgICAgdmFyIGFsOCA9IGE4ICYgMHgxZmZmO1xuXHQgICAgdmFyIGFoOCA9IGE4ID4+PiAxMztcblx0ICAgIHZhciBhOSA9IGFbOV0gfCAwO1xuXHQgICAgdmFyIGFsOSA9IGE5ICYgMHgxZmZmO1xuXHQgICAgdmFyIGFoOSA9IGE5ID4+PiAxMztcblx0ICAgIHZhciBiMCA9IGJbMF0gfCAwO1xuXHQgICAgdmFyIGJsMCA9IGIwICYgMHgxZmZmO1xuXHQgICAgdmFyIGJoMCA9IGIwID4+PiAxMztcblx0ICAgIHZhciBiMSA9IGJbMV0gfCAwO1xuXHQgICAgdmFyIGJsMSA9IGIxICYgMHgxZmZmO1xuXHQgICAgdmFyIGJoMSA9IGIxID4+PiAxMztcblx0ICAgIHZhciBiMiA9IGJbMl0gfCAwO1xuXHQgICAgdmFyIGJsMiA9IGIyICYgMHgxZmZmO1xuXHQgICAgdmFyIGJoMiA9IGIyID4+PiAxMztcblx0ICAgIHZhciBiMyA9IGJbM10gfCAwO1xuXHQgICAgdmFyIGJsMyA9IGIzICYgMHgxZmZmO1xuXHQgICAgdmFyIGJoMyA9IGIzID4+PiAxMztcblx0ICAgIHZhciBiNCA9IGJbNF0gfCAwO1xuXHQgICAgdmFyIGJsNCA9IGI0ICYgMHgxZmZmO1xuXHQgICAgdmFyIGJoNCA9IGI0ID4+PiAxMztcblx0ICAgIHZhciBiNSA9IGJbNV0gfCAwO1xuXHQgICAgdmFyIGJsNSA9IGI1ICYgMHgxZmZmO1xuXHQgICAgdmFyIGJoNSA9IGI1ID4+PiAxMztcblx0ICAgIHZhciBiNiA9IGJbNl0gfCAwO1xuXHQgICAgdmFyIGJsNiA9IGI2ICYgMHgxZmZmO1xuXHQgICAgdmFyIGJoNiA9IGI2ID4+PiAxMztcblx0ICAgIHZhciBiNyA9IGJbN10gfCAwO1xuXHQgICAgdmFyIGJsNyA9IGI3ICYgMHgxZmZmO1xuXHQgICAgdmFyIGJoNyA9IGI3ID4+PiAxMztcblx0ICAgIHZhciBiOCA9IGJbOF0gfCAwO1xuXHQgICAgdmFyIGJsOCA9IGI4ICYgMHgxZmZmO1xuXHQgICAgdmFyIGJoOCA9IGI4ID4+PiAxMztcblx0ICAgIHZhciBiOSA9IGJbOV0gfCAwO1xuXHQgICAgdmFyIGJsOSA9IGI5ICYgMHgxZmZmO1xuXHQgICAgdmFyIGJoOSA9IGI5ID4+PiAxMztcblxuXHQgICAgb3V0Lm5lZ2F0aXZlID0gc2VsZi5uZWdhdGl2ZSBeIG51bS5uZWdhdGl2ZTtcblx0ICAgIG91dC5sZW5ndGggPSAxOTtcblx0ICAgIC8qIGsgPSAwICovXG5cdCAgICBsbyA9IE1hdGguaW11bChhbDAsIGJsMCk7XG5cdCAgICBtaWQgPSBNYXRoLmltdWwoYWwwLCBiaDApO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsMCkpIHwgMDtcblx0ICAgIGhpID0gTWF0aC5pbXVsKGFoMCwgYmgwKTtcblx0ICAgIHZhciB3MCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcblx0ICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MCA+Pj4gMjYpKSB8IDA7XG5cdCAgICB3MCAmPSAweDNmZmZmZmY7XG5cdCAgICAvKiBrID0gMSAqL1xuXHQgICAgbG8gPSBNYXRoLmltdWwoYWwxLCBibDApO1xuXHQgICAgbWlkID0gTWF0aC5pbXVsKGFsMSwgYmgwKTtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDApKSB8IDA7XG5cdCAgICBoaSA9IE1hdGguaW11bChhaDEsIGJoMCk7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsMSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDEpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmwxKSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDEpKSB8IDA7XG5cdCAgICB2YXIgdzEgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG5cdCAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEgPj4+IDI2KSkgfCAwO1xuXHQgICAgdzEgJj0gMHgzZmZmZmZmO1xuXHQgICAgLyogayA9IDIgKi9cblx0ICAgIGxvID0gTWF0aC5pbXVsKGFsMiwgYmwwKTtcblx0ICAgIG1pZCA9IE1hdGguaW11bChhbDIsIGJoMCk7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmwwKSkgfCAwO1xuXHQgICAgaGkgPSBNYXRoLmltdWwoYWgyLCBiaDApO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDEpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmgxKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsMSkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmgxKSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDIpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmgyKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsMikpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmgyKSkgfCAwO1xuXHQgICAgdmFyIHcyID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuXHQgICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcyID4+PiAyNikpIHwgMDtcblx0ICAgIHcyICY9IDB4M2ZmZmZmZjtcblx0ICAgIC8qIGsgPSAzICovXG5cdCAgICBsbyA9IE1hdGguaW11bChhbDMsIGJsMCk7XG5cdCAgICBtaWQgPSBNYXRoLmltdWwoYWwzLCBiaDApO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsMCkpIHwgMDtcblx0ICAgIGhpID0gTWF0aC5pbXVsKGFoMywgYmgwKTtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmwxKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoMSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDEpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoMSkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmwyKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoMikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDIpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoMikpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmwzKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoMykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDMpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoMykpIHwgMDtcblx0ICAgIHZhciB3MyA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcblx0ICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MyA+Pj4gMjYpKSB8IDA7XG5cdCAgICB3MyAmPSAweDNmZmZmZmY7XG5cdCAgICAvKiBrID0gNCAqL1xuXHQgICAgbG8gPSBNYXRoLmltdWwoYWw0LCBibDApO1xuXHQgICAgbWlkID0gTWF0aC5pbXVsKGFsNCwgYmgwKTtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDApKSB8IDA7XG5cdCAgICBoaSA9IE1hdGguaW11bChhaDQsIGJoMCk7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsMSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDEpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmwxKSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDEpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsMikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDIpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmwyKSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDIpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsMykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDMpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmwzKSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDMpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsNCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDQpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw0KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDQpKSB8IDA7XG5cdCAgICB2YXIgdzQgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG5cdCAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzQgPj4+IDI2KSkgfCAwO1xuXHQgICAgdzQgJj0gMHgzZmZmZmZmO1xuXHQgICAgLyogayA9IDUgKi9cblx0ICAgIGxvID0gTWF0aC5pbXVsKGFsNSwgYmwwKTtcblx0ICAgIG1pZCA9IE1hdGguaW11bChhbDUsIGJoMCk7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmwwKSkgfCAwO1xuXHQgICAgaGkgPSBNYXRoLmltdWwoYWg1LCBiaDApO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDEpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmgxKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsMSkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmgxKSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDIpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmgyKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsMikpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmgyKSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDMpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmgzKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsMykpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmgzKSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDQpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg0KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsNCkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg0KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDUpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg1KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsNSkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg1KSkgfCAwO1xuXHQgICAgdmFyIHc1ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuXHQgICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc1ID4+PiAyNikpIHwgMDtcblx0ICAgIHc1ICY9IDB4M2ZmZmZmZjtcblx0ICAgIC8qIGsgPSA2ICovXG5cdCAgICBsbyA9IE1hdGguaW11bChhbDYsIGJsMCk7XG5cdCAgICBtaWQgPSBNYXRoLmltdWwoYWw2LCBiaDApO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsMCkpIHwgMDtcblx0ICAgIGhpID0gTWF0aC5pbXVsKGFoNiwgYmgwKTtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmwxKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoMSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDEpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoMSkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmwyKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoMikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDIpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoMikpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmwzKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoMykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDMpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoMykpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw0KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoNCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDQpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoNCkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw1KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoNSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDUpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoNSkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw2KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoNikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDYpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoNikpIHwgMDtcblx0ICAgIHZhciB3NiA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcblx0ICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3NiA+Pj4gMjYpKSB8IDA7XG5cdCAgICB3NiAmPSAweDNmZmZmZmY7XG5cdCAgICAvKiBrID0gNyAqL1xuXHQgICAgbG8gPSBNYXRoLmltdWwoYWw3LCBibDApO1xuXHQgICAgbWlkID0gTWF0aC5pbXVsKGFsNywgYmgwKTtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDApKSB8IDA7XG5cdCAgICBoaSA9IE1hdGguaW11bChhaDcsIGJoMCk7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsMSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDEpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmwxKSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDEpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsMikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDIpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmwyKSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDIpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsMykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDMpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmwzKSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDMpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsNCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDQpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw0KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDQpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsNSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDUpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw1KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDUpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsNikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDYpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw2KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDYpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsNykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDcpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw3KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDcpKSB8IDA7XG5cdCAgICB2YXIgdzcgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG5cdCAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzcgPj4+IDI2KSkgfCAwO1xuXHQgICAgdzcgJj0gMHgzZmZmZmZmO1xuXHQgICAgLyogayA9IDggKi9cblx0ICAgIGxvID0gTWF0aC5pbXVsKGFsOCwgYmwwKTtcblx0ICAgIG1pZCA9IE1hdGguaW11bChhbDgsIGJoMCk7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmwwKSkgfCAwO1xuXHQgICAgaGkgPSBNYXRoLmltdWwoYWg4LCBiaDApO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDEpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmgxKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsMSkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmgxKSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDIpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmgyKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsMikpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmgyKSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDMpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmgzKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsMykpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmgzKSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDQpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg0KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsNCkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg0KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDUpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg1KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsNSkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg1KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDYpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg2KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsNikpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg2KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDcpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg3KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsNykpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg3KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDgpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg4KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsOCkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg4KSkgfCAwO1xuXHQgICAgdmFyIHc4ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuXHQgICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc4ID4+PiAyNikpIHwgMDtcblx0ICAgIHc4ICY9IDB4M2ZmZmZmZjtcblx0ICAgIC8qIGsgPSA5ICovXG5cdCAgICBsbyA9IE1hdGguaW11bChhbDksIGJsMCk7XG5cdCAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDApO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsMCkpIHwgMDtcblx0ICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmgwKTtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmwxKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoMSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDEpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoMSkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmwyKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoMikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDIpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoMikpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmwzKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoMykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDMpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoMykpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw0KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoNCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDQpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoNCkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw1KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoNSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDUpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoNSkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw2KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoNikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDYpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoNikpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw3KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoNykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDcpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoNykpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw4KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoOCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDgpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoOCkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw5KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoOSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDkpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoOSkpIHwgMDtcblx0ICAgIHZhciB3OSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcblx0ICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3OSA+Pj4gMjYpKSB8IDA7XG5cdCAgICB3OSAmPSAweDNmZmZmZmY7XG5cdCAgICAvKiBrID0gMTAgKi9cblx0ICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwxKTtcblx0ICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoMSk7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmwxKSkgfCAwO1xuXHQgICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDEpO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDIpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmgyKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsMikpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmgyKSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDMpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmgzKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsMykpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmgzKSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDQpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg0KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsNCkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg0KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDUpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg1KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsNSkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg1KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDYpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg2KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsNikpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg2KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDcpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg3KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsNykpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg3KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDgpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg4KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsOCkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg4KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDkpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg5KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsOSkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg5KSkgfCAwO1xuXHQgICAgdmFyIHcxMCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcblx0ICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTAgPj4+IDI2KSkgfCAwO1xuXHQgICAgdzEwICY9IDB4M2ZmZmZmZjtcblx0ICAgIC8qIGsgPSAxMSAqL1xuXHQgICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDIpO1xuXHQgICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmgyKTtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDIpKSB8IDA7XG5cdCAgICBoaSA9IE1hdGguaW11bChhaDksIGJoMik7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsMykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDMpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmwzKSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDMpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsNCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDQpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw0KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDQpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsNSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDUpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw1KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDUpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsNikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDYpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw2KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDYpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsNykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDcpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw3KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDcpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsOCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDgpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw4KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDgpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsOSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDkpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw5KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDkpKSB8IDA7XG5cdCAgICB2YXIgdzExID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuXHQgICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxMSA+Pj4gMjYpKSB8IDA7XG5cdCAgICB3MTEgJj0gMHgzZmZmZmZmO1xuXHQgICAgLyogayA9IDEyICovXG5cdCAgICBsbyA9IE1hdGguaW11bChhbDksIGJsMyk7XG5cdCAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDMpO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsMykpIHwgMDtcblx0ICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmgzKTtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw0KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoNCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDQpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoNCkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw1KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoNSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDUpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoNSkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw2KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoNikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDYpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoNikpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw3KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoNykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDcpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoNykpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw4KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoOCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDgpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoOCkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw5KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoOSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDkpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoOSkpIHwgMDtcblx0ICAgIHZhciB3MTIgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG5cdCAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEyID4+PiAyNikpIHwgMDtcblx0ICAgIHcxMiAmPSAweDNmZmZmZmY7XG5cdCAgICAvKiBrID0gMTMgKi9cblx0ICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw0KTtcblx0ICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoNCk7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw0KSkgfCAwO1xuXHQgICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDQpO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDUpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg1KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsNSkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg1KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDYpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg2KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsNikpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg2KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDcpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg3KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsNykpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg3KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDgpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg4KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsOCkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg4KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDkpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg5KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsOSkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg5KSkgfCAwO1xuXHQgICAgdmFyIHcxMyA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcblx0ICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTMgPj4+IDI2KSkgfCAwO1xuXHQgICAgdzEzICY9IDB4M2ZmZmZmZjtcblx0ICAgIC8qIGsgPSAxNCAqL1xuXHQgICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDUpO1xuXHQgICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg1KTtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDUpKSB8IDA7XG5cdCAgICBoaSA9IE1hdGguaW11bChhaDksIGJoNSk7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsNikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDYpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw2KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDYpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsNykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDcpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw3KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDcpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsOCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDgpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw4KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDgpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsOSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDkpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw5KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDkpKSB8IDA7XG5cdCAgICB2YXIgdzE0ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuXHQgICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxNCA+Pj4gMjYpKSB8IDA7XG5cdCAgICB3MTQgJj0gMHgzZmZmZmZmO1xuXHQgICAgLyogayA9IDE1ICovXG5cdCAgICBsbyA9IE1hdGguaW11bChhbDksIGJsNik7XG5cdCAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDYpO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsNikpIHwgMDtcblx0ICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg2KTtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw3KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoNykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDcpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoNykpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw4KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoOCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDgpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoOCkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw5KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoOSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDkpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoOSkpIHwgMDtcblx0ICAgIHZhciB3MTUgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG5cdCAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE1ID4+PiAyNikpIHwgMDtcblx0ICAgIHcxNSAmPSAweDNmZmZmZmY7XG5cdCAgICAvKiBrID0gMTYgKi9cblx0ICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw3KTtcblx0ICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoNyk7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw3KSkgfCAwO1xuXHQgICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDcpO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDgpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg4KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsOCkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg4KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDkpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg5KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsOSkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg5KSkgfCAwO1xuXHQgICAgdmFyIHcxNiA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcblx0ICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTYgPj4+IDI2KSkgfCAwO1xuXHQgICAgdzE2ICY9IDB4M2ZmZmZmZjtcblx0ICAgIC8qIGsgPSAxNyAqL1xuXHQgICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDgpO1xuXHQgICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg4KTtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDgpKSB8IDA7XG5cdCAgICBoaSA9IE1hdGguaW11bChhaDksIGJoOCk7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsOSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDkpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw5KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDkpKSB8IDA7XG5cdCAgICB2YXIgdzE3ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuXHQgICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxNyA+Pj4gMjYpKSB8IDA7XG5cdCAgICB3MTcgJj0gMHgzZmZmZmZmO1xuXHQgICAgLyogayA9IDE4ICovXG5cdCAgICBsbyA9IE1hdGguaW11bChhbDksIGJsOSk7XG5cdCAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDkpO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsOSkpIHwgMDtcblx0ICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg5KTtcblx0ICAgIHZhciB3MTggPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG5cdCAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE4ID4+PiAyNikpIHwgMDtcblx0ICAgIHcxOCAmPSAweDNmZmZmZmY7XG5cdCAgICBvWzBdID0gdzA7XG5cdCAgICBvWzFdID0gdzE7XG5cdCAgICBvWzJdID0gdzI7XG5cdCAgICBvWzNdID0gdzM7XG5cdCAgICBvWzRdID0gdzQ7XG5cdCAgICBvWzVdID0gdzU7XG5cdCAgICBvWzZdID0gdzY7XG5cdCAgICBvWzddID0gdzc7XG5cdCAgICBvWzhdID0gdzg7XG5cdCAgICBvWzldID0gdzk7XG5cdCAgICBvWzEwXSA9IHcxMDtcblx0ICAgIG9bMTFdID0gdzExO1xuXHQgICAgb1sxMl0gPSB3MTI7XG5cdCAgICBvWzEzXSA9IHcxMztcblx0ICAgIG9bMTRdID0gdzE0O1xuXHQgICAgb1sxNV0gPSB3MTU7XG5cdCAgICBvWzE2XSA9IHcxNjtcblx0ICAgIG9bMTddID0gdzE3O1xuXHQgICAgb1sxOF0gPSB3MTg7XG5cdCAgICBpZiAoYyAhPT0gMCkge1xuXHQgICAgICBvWzE5XSA9IGM7XG5cdCAgICAgIG91dC5sZW5ndGgrKztcblx0ICAgIH1cblx0ICAgIHJldHVybiBvdXQ7XG5cdCAgfTtcblxuXHQgIC8vIFBvbHlmaWxsIGNvbWJcblx0ICBpZiAoIU1hdGguaW11bCkge1xuXHQgICAgY29tYjEwTXVsVG8gPSBzbWFsbE11bFRvO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGJpZ011bFRvIChzZWxmLCBudW0sIG91dCkge1xuXHQgICAgb3V0Lm5lZ2F0aXZlID0gbnVtLm5lZ2F0aXZlIF4gc2VsZi5uZWdhdGl2ZTtcblx0ICAgIG91dC5sZW5ndGggPSBzZWxmLmxlbmd0aCArIG51bS5sZW5ndGg7XG5cblx0ICAgIHZhciBjYXJyeSA9IDA7XG5cdCAgICB2YXIgaG5jYXJyeSA9IDA7XG5cdCAgICBmb3IgKHZhciBrID0gMDsgayA8IG91dC5sZW5ndGggLSAxOyBrKyspIHtcblx0ICAgICAgLy8gU3VtIGFsbCB3b3JkcyB3aXRoIHRoZSBzYW1lIGBpICsgaiA9IGtgIGFuZCBhY2N1bXVsYXRlIGBuY2FycnlgLFxuXHQgICAgICAvLyBub3RlIHRoYXQgbmNhcnJ5IGNvdWxkIGJlID49IDB4M2ZmZmZmZlxuXHQgICAgICB2YXIgbmNhcnJ5ID0gaG5jYXJyeTtcblx0ICAgICAgaG5jYXJyeSA9IDA7XG5cdCAgICAgIHZhciByd29yZCA9IGNhcnJ5ICYgMHgzZmZmZmZmO1xuXHQgICAgICB2YXIgbWF4SiA9IE1hdGgubWluKGssIG51bS5sZW5ndGggLSAxKTtcblx0ICAgICAgZm9yICh2YXIgaiA9IE1hdGgubWF4KDAsIGsgLSBzZWxmLmxlbmd0aCArIDEpOyBqIDw9IG1heEo7IGorKykge1xuXHQgICAgICAgIHZhciBpID0gayAtIGo7XG5cdCAgICAgICAgdmFyIGEgPSBzZWxmLndvcmRzW2ldIHwgMDtcblx0ICAgICAgICB2YXIgYiA9IG51bS53b3Jkc1tqXSB8IDA7XG5cdCAgICAgICAgdmFyIHIgPSBhICogYjtcblxuXHQgICAgICAgIHZhciBsbyA9IHIgJiAweDNmZmZmZmY7XG5cdCAgICAgICAgbmNhcnJ5ID0gKG5jYXJyeSArICgociAvIDB4NDAwMDAwMCkgfCAwKSkgfCAwO1xuXHQgICAgICAgIGxvID0gKGxvICsgcndvcmQpIHwgMDtcblx0ICAgICAgICByd29yZCA9IGxvICYgMHgzZmZmZmZmO1xuXHQgICAgICAgIG5jYXJyeSA9IChuY2FycnkgKyAobG8gPj4+IDI2KSkgfCAwO1xuXG5cdCAgICAgICAgaG5jYXJyeSArPSBuY2FycnkgPj4+IDI2O1xuXHQgICAgICAgIG5jYXJyeSAmPSAweDNmZmZmZmY7XG5cdCAgICAgIH1cblx0ICAgICAgb3V0LndvcmRzW2tdID0gcndvcmQ7XG5cdCAgICAgIGNhcnJ5ID0gbmNhcnJ5O1xuXHQgICAgICBuY2FycnkgPSBobmNhcnJ5O1xuXHQgICAgfVxuXHQgICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG5cdCAgICAgIG91dC53b3Jkc1trXSA9IGNhcnJ5O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgb3V0Lmxlbmd0aC0tO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gb3V0LnN0cmlwKCk7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24ganVtYm9NdWxUbyAoc2VsZiwgbnVtLCBvdXQpIHtcblx0ICAgIHZhciBmZnRtID0gbmV3IEZGVE0oKTtcblx0ICAgIHJldHVybiBmZnRtLm11bHAoc2VsZiwgbnVtLCBvdXQpO1xuXHQgIH1cblxuXHQgIEJOLnByb3RvdHlwZS5tdWxUbyA9IGZ1bmN0aW9uIG11bFRvIChudW0sIG91dCkge1xuXHQgICAgdmFyIHJlcztcblx0ICAgIHZhciBsZW4gPSB0aGlzLmxlbmd0aCArIG51bS5sZW5ndGg7XG5cdCAgICBpZiAodGhpcy5sZW5ndGggPT09IDEwICYmIG51bS5sZW5ndGggPT09IDEwKSB7XG5cdCAgICAgIHJlcyA9IGNvbWIxME11bFRvKHRoaXMsIG51bSwgb3V0KTtcblx0ICAgIH0gZWxzZSBpZiAobGVuIDwgNjMpIHtcblx0ICAgICAgcmVzID0gc21hbGxNdWxUbyh0aGlzLCBudW0sIG91dCk7XG5cdCAgICB9IGVsc2UgaWYgKGxlbiA8IDEwMjQpIHtcblx0ICAgICAgcmVzID0gYmlnTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmVzID0ganVtYm9NdWxUbyh0aGlzLCBudW0sIG91dCk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiByZXM7XG5cdCAgfTtcblxuXHQgIC8vIENvb2xleS1UdWtleSBhbGdvcml0aG0gZm9yIEZGVFxuXHQgIC8vIHNsaWdodGx5IHJldmlzaXRlZCB0byByZWx5IG9uIGxvb3BpbmcgaW5zdGVhZCBvZiByZWN1cnNpb25cblxuXHQgIGZ1bmN0aW9uIEZGVE0gKHgsIHkpIHtcblx0ICAgIHRoaXMueCA9IHg7XG5cdCAgICB0aGlzLnkgPSB5O1xuXHQgIH1cblxuXHQgIEZGVE0ucHJvdG90eXBlLm1ha2VSQlQgPSBmdW5jdGlvbiBtYWtlUkJUIChOKSB7XG5cdCAgICB2YXIgdCA9IG5ldyBBcnJheShOKTtcblx0ICAgIHZhciBsID0gQk4ucHJvdG90eXBlLl9jb3VudEJpdHMoTikgLSAxO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcblx0ICAgICAgdFtpXSA9IHRoaXMucmV2QmluKGksIGwsIE4pO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdDtcblx0ICB9O1xuXG5cdCAgLy8gUmV0dXJucyBiaW5hcnktcmV2ZXJzZWQgcmVwcmVzZW50YXRpb24gb2YgYHhgXG5cdCAgRkZUTS5wcm90b3R5cGUucmV2QmluID0gZnVuY3Rpb24gcmV2QmluICh4LCBsLCBOKSB7XG5cdCAgICBpZiAoeCA9PT0gMCB8fCB4ID09PSBOIC0gMSkgcmV0dXJuIHg7XG5cblx0ICAgIHZhciByYiA9IDA7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuXHQgICAgICByYiB8PSAoeCAmIDEpIDw8IChsIC0gaSAtIDEpO1xuXHQgICAgICB4ID4+PSAxO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gcmI7XG5cdCAgfTtcblxuXHQgIC8vIFBlcmZvcm1zIFwidHdlZWRsaW5nXCIgcGhhc2UsIHRoZXJlZm9yZSAnZW11bGF0aW5nJ1xuXHQgIC8vIGJlaGF2aW91ciBvZiB0aGUgcmVjdXJzaXZlIGFsZ29yaXRobVxuXHQgIEZGVE0ucHJvdG90eXBlLnBlcm11dGUgPSBmdW5jdGlvbiBwZXJtdXRlIChyYnQsIHJ3cywgaXdzLCBydHdzLCBpdHdzLCBOKSB7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IE47IGkrKykge1xuXHQgICAgICBydHdzW2ldID0gcndzW3JidFtpXV07XG5cdCAgICAgIGl0d3NbaV0gPSBpd3NbcmJ0W2ldXTtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgRkZUTS5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gdHJhbnNmb3JtIChyd3MsIGl3cywgcnR3cywgaXR3cywgTiwgcmJ0KSB7XG5cdCAgICB0aGlzLnBlcm11dGUocmJ0LCByd3MsIGl3cywgcnR3cywgaXR3cywgTik7XG5cblx0ICAgIGZvciAodmFyIHMgPSAxOyBzIDwgTjsgcyA8PD0gMSkge1xuXHQgICAgICB2YXIgbCA9IHMgPDwgMTtcblxuXHQgICAgICB2YXIgcnR3ZGYgPSBNYXRoLmNvcygyICogTWF0aC5QSSAvIGwpO1xuXHQgICAgICB2YXIgaXR3ZGYgPSBNYXRoLnNpbigyICogTWF0aC5QSSAvIGwpO1xuXG5cdCAgICAgIGZvciAodmFyIHAgPSAwOyBwIDwgTjsgcCArPSBsKSB7XG5cdCAgICAgICAgdmFyIHJ0d2RmXyA9IHJ0d2RmO1xuXHQgICAgICAgIHZhciBpdHdkZl8gPSBpdHdkZjtcblxuXHQgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgczsgaisrKSB7XG5cdCAgICAgICAgICB2YXIgcmUgPSBydHdzW3AgKyBqXTtcblx0ICAgICAgICAgIHZhciBpZSA9IGl0d3NbcCArIGpdO1xuXG5cdCAgICAgICAgICB2YXIgcm8gPSBydHdzW3AgKyBqICsgc107XG5cdCAgICAgICAgICB2YXIgaW8gPSBpdHdzW3AgKyBqICsgc107XG5cblx0ICAgICAgICAgIHZhciByeCA9IHJ0d2RmXyAqIHJvIC0gaXR3ZGZfICogaW87XG5cblx0ICAgICAgICAgIGlvID0gcnR3ZGZfICogaW8gKyBpdHdkZl8gKiBybztcblx0ICAgICAgICAgIHJvID0gcng7XG5cblx0ICAgICAgICAgIHJ0d3NbcCArIGpdID0gcmUgKyBybztcblx0ICAgICAgICAgIGl0d3NbcCArIGpdID0gaWUgKyBpbztcblxuXHQgICAgICAgICAgcnR3c1twICsgaiArIHNdID0gcmUgLSBybztcblx0ICAgICAgICAgIGl0d3NbcCArIGogKyBzXSA9IGllIC0gaW87XG5cblx0ICAgICAgICAgIC8qIGpzaGludCBtYXhkZXB0aCA6IGZhbHNlICovXG5cdCAgICAgICAgICBpZiAoaiAhPT0gbCkge1xuXHQgICAgICAgICAgICByeCA9IHJ0d2RmICogcnR3ZGZfIC0gaXR3ZGYgKiBpdHdkZl87XG5cblx0ICAgICAgICAgICAgaXR3ZGZfID0gcnR3ZGYgKiBpdHdkZl8gKyBpdHdkZiAqIHJ0d2RmXztcblx0ICAgICAgICAgICAgcnR3ZGZfID0gcng7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIEZGVE0ucHJvdG90eXBlLmd1ZXNzTGVuMTNiID0gZnVuY3Rpb24gZ3Vlc3NMZW4xM2IgKG4sIG0pIHtcblx0ICAgIHZhciBOID0gTWF0aC5tYXgobSwgbikgfCAxO1xuXHQgICAgdmFyIG9kZCA9IE4gJiAxO1xuXHQgICAgdmFyIGkgPSAwO1xuXHQgICAgZm9yIChOID0gTiAvIDIgfCAwOyBOOyBOID0gTiA+Pj4gMSkge1xuXHQgICAgICBpKys7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiAxIDw8IGkgKyAxICsgb2RkO1xuXHQgIH07XG5cblx0ICBGRlRNLnByb3RvdHlwZS5jb25qdWdhdGUgPSBmdW5jdGlvbiBjb25qdWdhdGUgKHJ3cywgaXdzLCBOKSB7XG5cdCAgICBpZiAoTiA8PSAxKSByZXR1cm47XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTiAvIDI7IGkrKykge1xuXHQgICAgICB2YXIgdCA9IHJ3c1tpXTtcblxuXHQgICAgICByd3NbaV0gPSByd3NbTiAtIGkgLSAxXTtcblx0ICAgICAgcndzW04gLSBpIC0gMV0gPSB0O1xuXG5cdCAgICAgIHQgPSBpd3NbaV07XG5cblx0ICAgICAgaXdzW2ldID0gLWl3c1tOIC0gaSAtIDFdO1xuXHQgICAgICBpd3NbTiAtIGkgLSAxXSA9IC10O1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICBGRlRNLnByb3RvdHlwZS5ub3JtYWxpemUxM2IgPSBmdW5jdGlvbiBub3JtYWxpemUxM2IgKHdzLCBOKSB7XG5cdCAgICB2YXIgY2FycnkgPSAwO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOIC8gMjsgaSsrKSB7XG5cdCAgICAgIHZhciB3ID0gTWF0aC5yb3VuZCh3c1syICogaSArIDFdIC8gTikgKiAweDIwMDAgK1xuXHQgICAgICAgIE1hdGgucm91bmQod3NbMiAqIGldIC8gTikgK1xuXHQgICAgICAgIGNhcnJ5O1xuXG5cdCAgICAgIHdzW2ldID0gdyAmIDB4M2ZmZmZmZjtcblxuXHQgICAgICBpZiAodyA8IDB4NDAwMDAwMCkge1xuXHQgICAgICAgIGNhcnJ5ID0gMDtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBjYXJyeSA9IHcgLyAweDQwMDAwMDAgfCAwO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB3cztcblx0ICB9O1xuXG5cdCAgRkZUTS5wcm90b3R5cGUuY29udmVydDEzYiA9IGZ1bmN0aW9uIGNvbnZlcnQxM2IgKHdzLCBsZW4sIHJ3cywgTikge1xuXHQgICAgdmFyIGNhcnJ5ID0gMDtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0ICAgICAgY2FycnkgPSBjYXJyeSArICh3c1tpXSB8IDApO1xuXG5cdCAgICAgIHJ3c1syICogaV0gPSBjYXJyeSAmIDB4MWZmZjsgY2FycnkgPSBjYXJyeSA+Pj4gMTM7XG5cdCAgICAgIHJ3c1syICogaSArIDFdID0gY2FycnkgJiAweDFmZmY7IGNhcnJ5ID0gY2FycnkgPj4+IDEzO1xuXHQgICAgfVxuXG5cdCAgICAvLyBQYWQgd2l0aCB6ZXJvZXNcblx0ICAgIGZvciAoaSA9IDIgKiBsZW47IGkgPCBOOyArK2kpIHtcblx0ICAgICAgcndzW2ldID0gMDtcblx0ICAgIH1cblxuXHQgICAgYXNzZXJ0KGNhcnJ5ID09PSAwKTtcblx0ICAgIGFzc2VydCgoY2FycnkgJiB+MHgxZmZmKSA9PT0gMCk7XG5cdCAgfTtcblxuXHQgIEZGVE0ucHJvdG90eXBlLnN0dWIgPSBmdW5jdGlvbiBzdHViIChOKSB7XG5cdCAgICB2YXIgcGggPSBuZXcgQXJyYXkoTik7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IE47IGkrKykge1xuXHQgICAgICBwaFtpXSA9IDA7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBwaDtcblx0ICB9O1xuXG5cdCAgRkZUTS5wcm90b3R5cGUubXVscCA9IGZ1bmN0aW9uIG11bHAgKHgsIHksIG91dCkge1xuXHQgICAgdmFyIE4gPSAyICogdGhpcy5ndWVzc0xlbjEzYih4Lmxlbmd0aCwgeS5sZW5ndGgpO1xuXG5cdCAgICB2YXIgcmJ0ID0gdGhpcy5tYWtlUkJUKE4pO1xuXG5cdCAgICB2YXIgXyA9IHRoaXMuc3R1YihOKTtcblxuXHQgICAgdmFyIHJ3cyA9IG5ldyBBcnJheShOKTtcblx0ICAgIHZhciByd3N0ID0gbmV3IEFycmF5KE4pO1xuXHQgICAgdmFyIGl3c3QgPSBuZXcgQXJyYXkoTik7XG5cblx0ICAgIHZhciBucndzID0gbmV3IEFycmF5KE4pO1xuXHQgICAgdmFyIG5yd3N0ID0gbmV3IEFycmF5KE4pO1xuXHQgICAgdmFyIG5pd3N0ID0gbmV3IEFycmF5KE4pO1xuXG5cdCAgICB2YXIgcm13cyA9IG91dC53b3Jkcztcblx0ICAgIHJtd3MubGVuZ3RoID0gTjtcblxuXHQgICAgdGhpcy5jb252ZXJ0MTNiKHgud29yZHMsIHgubGVuZ3RoLCByd3MsIE4pO1xuXHQgICAgdGhpcy5jb252ZXJ0MTNiKHkud29yZHMsIHkubGVuZ3RoLCBucndzLCBOKTtcblxuXHQgICAgdGhpcy50cmFuc2Zvcm0ocndzLCBfLCByd3N0LCBpd3N0LCBOLCByYnQpO1xuXHQgICAgdGhpcy50cmFuc2Zvcm0obnJ3cywgXywgbnJ3c3QsIG5pd3N0LCBOLCByYnQpO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IE47IGkrKykge1xuXHQgICAgICB2YXIgcnggPSByd3N0W2ldICogbnJ3c3RbaV0gLSBpd3N0W2ldICogbml3c3RbaV07XG5cdCAgICAgIGl3c3RbaV0gPSByd3N0W2ldICogbml3c3RbaV0gKyBpd3N0W2ldICogbnJ3c3RbaV07XG5cdCAgICAgIHJ3c3RbaV0gPSByeDtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5jb25qdWdhdGUocndzdCwgaXdzdCwgTik7XG5cdCAgICB0aGlzLnRyYW5zZm9ybShyd3N0LCBpd3N0LCBybXdzLCBfLCBOLCByYnQpO1xuXHQgICAgdGhpcy5jb25qdWdhdGUocm13cywgXywgTik7XG5cdCAgICB0aGlzLm5vcm1hbGl6ZTEzYihybXdzLCBOKTtcblxuXHQgICAgb3V0Lm5lZ2F0aXZlID0geC5uZWdhdGl2ZSBeIHkubmVnYXRpdmU7XG5cdCAgICBvdXQubGVuZ3RoID0geC5sZW5ndGggKyB5Lmxlbmd0aDtcblx0ICAgIHJldHVybiBvdXQuc3RyaXAoKTtcblx0ICB9O1xuXG5cdCAgLy8gTXVsdGlwbHkgYHRoaXNgIGJ5IGBudW1gXG5cdCAgQk4ucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bCAobnVtKSB7XG5cdCAgICB2YXIgb3V0ID0gbmV3IEJOKG51bGwpO1xuXHQgICAgb3V0LndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoICsgbnVtLmxlbmd0aCk7XG5cdCAgICByZXR1cm4gdGhpcy5tdWxUbyhudW0sIG91dCk7XG5cdCAgfTtcblxuXHQgIC8vIE11bHRpcGx5IGVtcGxveWluZyBGRlRcblx0ICBCTi5wcm90b3R5cGUubXVsZiA9IGZ1bmN0aW9uIG11bGYgKG51bSkge1xuXHQgICAgdmFyIG91dCA9IG5ldyBCTihudWxsKTtcblx0ICAgIG91dC53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCArIG51bS5sZW5ndGgpO1xuXHQgICAgcmV0dXJuIGp1bWJvTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuXHQgIH07XG5cblx0ICAvLyBJbi1wbGFjZSBNdWx0aXBsaWNhdGlvblxuXHQgIEJOLnByb3RvdHlwZS5pbXVsID0gZnVuY3Rpb24gaW11bCAobnVtKSB7XG5cdCAgICByZXR1cm4gdGhpcy5jbG9uZSgpLm11bFRvKG51bSwgdGhpcyk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5pbXVsbiA9IGZ1bmN0aW9uIGltdWxuIChudW0pIHtcblx0ICAgIGFzc2VydCh0eXBlb2YgbnVtID09PSAnbnVtYmVyJyk7XG5cdCAgICBhc3NlcnQobnVtIDwgMHg0MDAwMDAwKTtcblxuXHQgICAgLy8gQ2Fycnlcblx0ICAgIHZhciBjYXJyeSA9IDA7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIHcgPSAodGhpcy53b3Jkc1tpXSB8IDApICogbnVtO1xuXHQgICAgICB2YXIgbG8gPSAodyAmIDB4M2ZmZmZmZikgKyAoY2FycnkgJiAweDNmZmZmZmYpO1xuXHQgICAgICBjYXJyeSA+Pj0gMjY7XG5cdCAgICAgIGNhcnJ5ICs9ICh3IC8gMHg0MDAwMDAwKSB8IDA7XG5cdCAgICAgIC8vIE5PVEU6IGxvIGlzIDI3Yml0IG1heGltdW1cblx0ICAgICAgY2FycnkgKz0gbG8gPj4+IDI2O1xuXHQgICAgICB0aGlzLndvcmRzW2ldID0gbG8gJiAweDNmZmZmZmY7XG5cdCAgICB9XG5cblx0ICAgIGlmIChjYXJyeSAhPT0gMCkge1xuXHQgICAgICB0aGlzLndvcmRzW2ldID0gY2Fycnk7XG5cdCAgICAgIHRoaXMubGVuZ3RoKys7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUubXVsbiA9IGZ1bmN0aW9uIG11bG4gKG51bSkge1xuXHQgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbXVsbihudW0pO1xuXHQgIH07XG5cblx0ICAvLyBgdGhpc2AgKiBgdGhpc2Bcblx0ICBCTi5wcm90b3R5cGUuc3FyID0gZnVuY3Rpb24gc3FyICgpIHtcblx0ICAgIHJldHVybiB0aGlzLm11bCh0aGlzKTtcblx0ICB9O1xuXG5cdCAgLy8gYHRoaXNgICogYHRoaXNgIGluLXBsYWNlXG5cdCAgQk4ucHJvdG90eXBlLmlzcXIgPSBmdW5jdGlvbiBpc3FyICgpIHtcblx0ICAgIHJldHVybiB0aGlzLmltdWwodGhpcy5jbG9uZSgpKTtcblx0ICB9O1xuXG5cdCAgLy8gTWF0aC5wb3coYHRoaXNgLCBgbnVtYClcblx0ICBCTi5wcm90b3R5cGUucG93ID0gZnVuY3Rpb24gcG93IChudW0pIHtcblx0ICAgIHZhciB3ID0gdG9CaXRBcnJheShudW0pO1xuXHQgICAgaWYgKHcubGVuZ3RoID09PSAwKSByZXR1cm4gbmV3IEJOKDEpO1xuXG5cdCAgICAvLyBTa2lwIGxlYWRpbmcgemVyb2VzXG5cdCAgICB2YXIgcmVzID0gdGhpcztcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdy5sZW5ndGg7IGkrKywgcmVzID0gcmVzLnNxcigpKSB7XG5cdCAgICAgIGlmICh3W2ldICE9PSAwKSBicmVhaztcblx0ICAgIH1cblxuXHQgICAgaWYgKCsraSA8IHcubGVuZ3RoKSB7XG5cdCAgICAgIGZvciAodmFyIHEgPSByZXMuc3FyKCk7IGkgPCB3Lmxlbmd0aDsgaSsrLCBxID0gcS5zcXIoKSkge1xuXHQgICAgICAgIGlmICh3W2ldID09PSAwKSBjb250aW51ZTtcblxuXHQgICAgICAgIHJlcyA9IHJlcy5tdWwocSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHJlcztcblx0ICB9O1xuXG5cdCAgLy8gU2hpZnQtbGVmdCBpbi1wbGFjZVxuXHQgIEJOLnByb3RvdHlwZS5pdXNobG4gPSBmdW5jdGlvbiBpdXNobG4gKGJpdHMpIHtcblx0ICAgIGFzc2VydCh0eXBlb2YgYml0cyA9PT0gJ251bWJlcicgJiYgYml0cyA+PSAwKTtcblx0ICAgIHZhciByID0gYml0cyAlIDI2O1xuXHQgICAgdmFyIHMgPSAoYml0cyAtIHIpIC8gMjY7XG5cdCAgICB2YXIgY2FycnlNYXNrID0gKDB4M2ZmZmZmZiA+Pj4gKDI2IC0gcikpIDw8ICgyNiAtIHIpO1xuXHQgICAgdmFyIGk7XG5cblx0ICAgIGlmIChyICE9PSAwKSB7XG5cdCAgICAgIHZhciBjYXJyeSA9IDA7XG5cblx0ICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICB2YXIgbmV3Q2FycnkgPSB0aGlzLndvcmRzW2ldICYgY2FycnlNYXNrO1xuXHQgICAgICAgIHZhciBjID0gKCh0aGlzLndvcmRzW2ldIHwgMCkgLSBuZXdDYXJyeSkgPDwgcjtcblx0ICAgICAgICB0aGlzLndvcmRzW2ldID0gYyB8IGNhcnJ5O1xuXHQgICAgICAgIGNhcnJ5ID0gbmV3Q2FycnkgPj4+ICgyNiAtIHIpO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKGNhcnJ5KSB7XG5cdCAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGNhcnJ5O1xuXHQgICAgICAgIHRoaXMubGVuZ3RoKys7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgaWYgKHMgIT09IDApIHtcblx0ICAgICAgZm9yIChpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHQgICAgICAgIHRoaXMud29yZHNbaSArIHNdID0gdGhpcy53b3Jkc1tpXTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGZvciAoaSA9IDA7IGkgPCBzOyBpKyspIHtcblx0ICAgICAgICB0aGlzLndvcmRzW2ldID0gMDtcblx0ICAgICAgfVxuXG5cdCAgICAgIHRoaXMubGVuZ3RoICs9IHM7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5pc2hsbiA9IGZ1bmN0aW9uIGlzaGxuIChiaXRzKSB7XG5cdCAgICAvLyBUT0RPKGluZHV0bnkpOiBpbXBsZW1lbnQgbWVcblx0ICAgIGFzc2VydCh0aGlzLm5lZ2F0aXZlID09PSAwKTtcblx0ICAgIHJldHVybiB0aGlzLml1c2hsbihiaXRzKTtcblx0ICB9O1xuXG5cdCAgLy8gU2hpZnQtcmlnaHQgaW4tcGxhY2Vcblx0ICAvLyBOT1RFOiBgaGludGAgaXMgYSBsb3dlc3QgYml0IGJlZm9yZSB0cmFpbGluZyB6ZXJvZXNcblx0ICAvLyBOT1RFOiBpZiBgZXh0ZW5kZWRgIGlzIHByZXNlbnQgLSBpdCB3aWxsIGJlIGZpbGxlZCB3aXRoIGRlc3Ryb3llZCBiaXRzXG5cdCAgQk4ucHJvdG90eXBlLml1c2hybiA9IGZ1bmN0aW9uIGl1c2hybiAoYml0cywgaGludCwgZXh0ZW5kZWQpIHtcblx0ICAgIGFzc2VydCh0eXBlb2YgYml0cyA9PT0gJ251bWJlcicgJiYgYml0cyA+PSAwKTtcblx0ICAgIHZhciBoO1xuXHQgICAgaWYgKGhpbnQpIHtcblx0ICAgICAgaCA9IChoaW50IC0gKGhpbnQgJSAyNikpIC8gMjY7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBoID0gMDtcblx0ICAgIH1cblxuXHQgICAgdmFyIHIgPSBiaXRzICUgMjY7XG5cdCAgICB2YXIgcyA9IE1hdGgubWluKChiaXRzIC0gcikgLyAyNiwgdGhpcy5sZW5ndGgpO1xuXHQgICAgdmFyIG1hc2sgPSAweDNmZmZmZmYgXiAoKDB4M2ZmZmZmZiA+Pj4gcikgPDwgcik7XG5cdCAgICB2YXIgbWFza2VkV29yZHMgPSBleHRlbmRlZDtcblxuXHQgICAgaCAtPSBzO1xuXHQgICAgaCA9IE1hdGgubWF4KDAsIGgpO1xuXG5cdCAgICAvLyBFeHRlbmRlZCBtb2RlLCBjb3B5IG1hc2tlZCBwYXJ0XG5cdCAgICBpZiAobWFza2VkV29yZHMpIHtcblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyBpKyspIHtcblx0ICAgICAgICBtYXNrZWRXb3Jkcy53b3Jkc1tpXSA9IHRoaXMud29yZHNbaV07XG5cdCAgICAgIH1cblx0ICAgICAgbWFza2VkV29yZHMubGVuZ3RoID0gcztcblx0ICAgIH1cblxuXHQgICAgaWYgKHMgPT09IDApIHtcblx0ICAgICAgLy8gTm8tb3AsIHdlIHNob3VsZCBub3QgbW92ZSBhbnl0aGluZyBhdCBhbGxcblx0ICAgIH0gZWxzZSBpZiAodGhpcy5sZW5ndGggPiBzKSB7XG5cdCAgICAgIHRoaXMubGVuZ3RoIC09IHM7XG5cdCAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgdGhpcy53b3Jkc1tpXSA9IHRoaXMud29yZHNbaSArIHNdO1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB0aGlzLndvcmRzWzBdID0gMDtcblx0ICAgICAgdGhpcy5sZW5ndGggPSAxO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgY2FycnkgPSAwO1xuXHQgICAgZm9yIChpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDAgJiYgKGNhcnJ5ICE9PSAwIHx8IGkgPj0gaCk7IGktLSkge1xuXHQgICAgICB2YXIgd29yZCA9IHRoaXMud29yZHNbaV0gfCAwO1xuXHQgICAgICB0aGlzLndvcmRzW2ldID0gKGNhcnJ5IDw8ICgyNiAtIHIpKSB8ICh3b3JkID4+PiByKTtcblx0ICAgICAgY2FycnkgPSB3b3JkICYgbWFzaztcblx0ICAgIH1cblxuXHQgICAgLy8gUHVzaCBjYXJyaWVkIGJpdHMgYXMgYSBtYXNrXG5cdCAgICBpZiAobWFza2VkV29yZHMgJiYgY2FycnkgIT09IDApIHtcblx0ICAgICAgbWFza2VkV29yZHMud29yZHNbbWFza2VkV29yZHMubGVuZ3RoKytdID0gY2Fycnk7XG5cdCAgICB9XG5cblx0ICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuXHQgICAgICB0aGlzLndvcmRzWzBdID0gMDtcblx0ICAgICAgdGhpcy5sZW5ndGggPSAxO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuaXNocm4gPSBmdW5jdGlvbiBpc2hybiAoYml0cywgaGludCwgZXh0ZW5kZWQpIHtcblx0ICAgIC8vIFRPRE8oaW5kdXRueSk6IGltcGxlbWVudCBtZVxuXHQgICAgYXNzZXJ0KHRoaXMubmVnYXRpdmUgPT09IDApO1xuXHQgICAgcmV0dXJuIHRoaXMuaXVzaHJuKGJpdHMsIGhpbnQsIGV4dGVuZGVkKTtcblx0ICB9O1xuXG5cdCAgLy8gU2hpZnQtbGVmdFxuXHQgIEJOLnByb3RvdHlwZS5zaGxuID0gZnVuY3Rpb24gc2hsbiAoYml0cykge1xuXHQgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc2hsbihiaXRzKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLnVzaGxuID0gZnVuY3Rpb24gdXNobG4gKGJpdHMpIHtcblx0ICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXVzaGxuKGJpdHMpO1xuXHQgIH07XG5cblx0ICAvLyBTaGlmdC1yaWdodFxuXHQgIEJOLnByb3RvdHlwZS5zaHJuID0gZnVuY3Rpb24gc2hybiAoYml0cykge1xuXHQgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc2hybihiaXRzKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLnVzaHJuID0gZnVuY3Rpb24gdXNocm4gKGJpdHMpIHtcblx0ICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXVzaHJuKGJpdHMpO1xuXHQgIH07XG5cblx0ICAvLyBUZXN0IGlmIG4gYml0IGlzIHNldFxuXHQgIEJOLnByb3RvdHlwZS50ZXN0biA9IGZ1bmN0aW9uIHRlc3RuIChiaXQpIHtcblx0ICAgIGFzc2VydCh0eXBlb2YgYml0ID09PSAnbnVtYmVyJyAmJiBiaXQgPj0gMCk7XG5cdCAgICB2YXIgciA9IGJpdCAlIDI2O1xuXHQgICAgdmFyIHMgPSAoYml0IC0gcikgLyAyNjtcblx0ICAgIHZhciBxID0gMSA8PCByO1xuXG5cdCAgICAvLyBGYXN0IGNhc2U6IGJpdCBpcyBtdWNoIGhpZ2hlciB0aGFuIGFsbCBleGlzdGluZyB3b3Jkc1xuXHQgICAgaWYgKHRoaXMubGVuZ3RoIDw9IHMpIHJldHVybiBmYWxzZTtcblxuXHQgICAgLy8gQ2hlY2sgYml0IGFuZCByZXR1cm5cblx0ICAgIHZhciB3ID0gdGhpcy53b3Jkc1tzXTtcblxuXHQgICAgcmV0dXJuICEhKHcgJiBxKTtcblx0ICB9O1xuXG5cdCAgLy8gUmV0dXJuIG9ubHkgbG93ZXJzIGJpdHMgb2YgbnVtYmVyIChpbi1wbGFjZSlcblx0ICBCTi5wcm90b3R5cGUuaW1hc2tuID0gZnVuY3Rpb24gaW1hc2tuIChiaXRzKSB7XG5cdCAgICBhc3NlcnQodHlwZW9mIGJpdHMgPT09ICdudW1iZXInICYmIGJpdHMgPj0gMCk7XG5cdCAgICB2YXIgciA9IGJpdHMgJSAyNjtcblx0ICAgIHZhciBzID0gKGJpdHMgLSByKSAvIDI2O1xuXG5cdCAgICBhc3NlcnQodGhpcy5uZWdhdGl2ZSA9PT0gMCwgJ2ltYXNrbiB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmUgbnVtYmVycycpO1xuXG5cdCAgICBpZiAodGhpcy5sZW5ndGggPD0gcykge1xuXHQgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH1cblxuXHQgICAgaWYgKHIgIT09IDApIHtcblx0ICAgICAgcysrO1xuXHQgICAgfVxuXHQgICAgdGhpcy5sZW5ndGggPSBNYXRoLm1pbihzLCB0aGlzLmxlbmd0aCk7XG5cblx0ICAgIGlmIChyICE9PSAwKSB7XG5cdCAgICAgIHZhciBtYXNrID0gMHgzZmZmZmZmIF4gKCgweDNmZmZmZmYgPj4+IHIpIDw8IHIpO1xuXHQgICAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoIC0gMV0gJj0gbWFzaztcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcblx0ICB9O1xuXG5cdCAgLy8gUmV0dXJuIG9ubHkgbG93ZXJzIGJpdHMgb2YgbnVtYmVyXG5cdCAgQk4ucHJvdG90eXBlLm1hc2tuID0gZnVuY3Rpb24gbWFza24gKGJpdHMpIHtcblx0ICAgIHJldHVybiB0aGlzLmNsb25lKCkuaW1hc2tuKGJpdHMpO1xuXHQgIH07XG5cblx0ICAvLyBBZGQgcGxhaW4gbnVtYmVyIGBudW1gIHRvIGB0aGlzYFxuXHQgIEJOLnByb3RvdHlwZS5pYWRkbiA9IGZ1bmN0aW9uIGlhZGRuIChudW0pIHtcblx0ICAgIGFzc2VydCh0eXBlb2YgbnVtID09PSAnbnVtYmVyJyk7XG5cdCAgICBhc3NlcnQobnVtIDwgMHg0MDAwMDAwKTtcblx0ICAgIGlmIChudW0gPCAwKSByZXR1cm4gdGhpcy5pc3VibigtbnVtKTtcblxuXHQgICAgLy8gUG9zc2libGUgc2lnbiBjaGFuZ2Vcblx0ICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG5cdCAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSAmJiAodGhpcy53b3Jkc1swXSB8IDApIDwgbnVtKSB7XG5cdCAgICAgICAgdGhpcy53b3Jkc1swXSA9IG51bSAtICh0aGlzLndvcmRzWzBdIHwgMCk7XG5cdCAgICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgIH1cblxuXHQgICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcblx0ICAgICAgdGhpcy5pc3VibihudW0pO1xuXHQgICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcblx0ICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9XG5cblx0ICAgIC8vIEFkZCB3aXRob3V0IGNoZWNrc1xuXHQgICAgcmV0dXJuIHRoaXMuX2lhZGRuKG51bSk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5faWFkZG4gPSBmdW5jdGlvbiBfaWFkZG4gKG51bSkge1xuXHQgICAgdGhpcy53b3Jkc1swXSArPSBudW07XG5cblx0ICAgIC8vIENhcnJ5XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoICYmIHRoaXMud29yZHNbaV0gPj0gMHg0MDAwMDAwOyBpKyspIHtcblx0ICAgICAgdGhpcy53b3Jkc1tpXSAtPSAweDQwMDAwMDA7XG5cdCAgICAgIGlmIChpID09PSB0aGlzLmxlbmd0aCAtIDEpIHtcblx0ICAgICAgICB0aGlzLndvcmRzW2kgKyAxXSA9IDE7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdGhpcy53b3Jkc1tpICsgMV0rKztcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgdGhpcy5sZW5ndGggPSBNYXRoLm1heCh0aGlzLmxlbmd0aCwgaSArIDEpO1xuXG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXG5cdCAgLy8gU3VidHJhY3QgcGxhaW4gbnVtYmVyIGBudW1gIGZyb20gYHRoaXNgXG5cdCAgQk4ucHJvdG90eXBlLmlzdWJuID0gZnVuY3Rpb24gaXN1Ym4gKG51bSkge1xuXHQgICAgYXNzZXJ0KHR5cGVvZiBudW0gPT09ICdudW1iZXInKTtcblx0ICAgIGFzc2VydChudW0gPCAweDQwMDAwMDApO1xuXHQgICAgaWYgKG51bSA8IDApIHJldHVybiB0aGlzLmlhZGRuKC1udW0pO1xuXG5cdCAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuXHQgICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcblx0ICAgICAgdGhpcy5pYWRkbihudW0pO1xuXHQgICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcblx0ICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMud29yZHNbMF0gLT0gbnVtO1xuXG5cdCAgICBpZiAodGhpcy5sZW5ndGggPT09IDEgJiYgdGhpcy53b3Jkc1swXSA8IDApIHtcblx0ICAgICAgdGhpcy53b3Jkc1swXSA9IC10aGlzLndvcmRzWzBdO1xuXHQgICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIC8vIENhcnJ5XG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGggJiYgdGhpcy53b3Jkc1tpXSA8IDA7IGkrKykge1xuXHQgICAgICAgIHRoaXMud29yZHNbaV0gKz0gMHg0MDAwMDAwO1xuXHQgICAgICAgIHRoaXMud29yZHNbaSArIDFdIC09IDE7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmFkZG4gPSBmdW5jdGlvbiBhZGRuIChudW0pIHtcblx0ICAgIHJldHVybiB0aGlzLmNsb25lKCkuaWFkZG4obnVtKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLnN1Ym4gPSBmdW5jdGlvbiBzdWJuIChudW0pIHtcblx0ICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXN1Ym4obnVtKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmlhYnMgPSBmdW5jdGlvbiBpYWJzICgpIHtcblx0ICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuXG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmFicyA9IGZ1bmN0aW9uIGFicyAoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlhYnMoKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLl9pc2hsbnN1Ym11bCA9IGZ1bmN0aW9uIF9pc2hsbnN1Ym11bCAobnVtLCBtdWwsIHNoaWZ0KSB7XG5cdCAgICB2YXIgbGVuID0gbnVtLmxlbmd0aCArIHNoaWZ0O1xuXHQgICAgdmFyIGk7XG5cblx0ICAgIHRoaXMuX2V4cGFuZChsZW4pO1xuXG5cdCAgICB2YXIgdztcblx0ICAgIHZhciBjYXJyeSA9IDA7XG5cdCAgICBmb3IgKGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHcgPSAodGhpcy53b3Jkc1tpICsgc2hpZnRdIHwgMCkgKyBjYXJyeTtcblx0ICAgICAgdmFyIHJpZ2h0ID0gKG51bS53b3Jkc1tpXSB8IDApICogbXVsO1xuXHQgICAgICB3IC09IHJpZ2h0ICYgMHgzZmZmZmZmO1xuXHQgICAgICBjYXJyeSA9ICh3ID4+IDI2KSAtICgocmlnaHQgLyAweDQwMDAwMDApIHwgMCk7XG5cdCAgICAgIHRoaXMud29yZHNbaSArIHNoaWZ0XSA9IHcgJiAweDNmZmZmZmY7XG5cdCAgICB9XG5cdCAgICBmb3IgKDsgaSA8IHRoaXMubGVuZ3RoIC0gc2hpZnQ7IGkrKykge1xuXHQgICAgICB3ID0gKHRoaXMud29yZHNbaSArIHNoaWZ0XSB8IDApICsgY2Fycnk7XG5cdCAgICAgIGNhcnJ5ID0gdyA+PiAyNjtcblx0ICAgICAgdGhpcy53b3Jkc1tpICsgc2hpZnRdID0gdyAmIDB4M2ZmZmZmZjtcblx0ICAgIH1cblxuXHQgICAgaWYgKGNhcnJ5ID09PSAwKSByZXR1cm4gdGhpcy5zdHJpcCgpO1xuXG5cdCAgICAvLyBTdWJ0cmFjdGlvbiBvdmVyZmxvd1xuXHQgICAgYXNzZXJ0KGNhcnJ5ID09PSAtMSk7XG5cdCAgICBjYXJyeSA9IDA7XG5cdCAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICB3ID0gLSh0aGlzLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcblx0ICAgICAgY2FycnkgPSB3ID4+IDI2O1xuXHQgICAgICB0aGlzLndvcmRzW2ldID0gdyAmIDB4M2ZmZmZmZjtcblx0ICAgIH1cblx0ICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuXG5cdCAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuX3dvcmREaXYgPSBmdW5jdGlvbiBfd29yZERpdiAobnVtLCBtb2RlKSB7XG5cdCAgICB2YXIgc2hpZnQgPSB0aGlzLmxlbmd0aCAtIG51bS5sZW5ndGg7XG5cblx0ICAgIHZhciBhID0gdGhpcy5jbG9uZSgpO1xuXHQgICAgdmFyIGIgPSBudW07XG5cblx0ICAgIC8vIE5vcm1hbGl6ZVxuXHQgICAgdmFyIGJoaSA9IGIud29yZHNbYi5sZW5ndGggLSAxXSB8IDA7XG5cdCAgICB2YXIgYmhpQml0cyA9IHRoaXMuX2NvdW50Qml0cyhiaGkpO1xuXHQgICAgc2hpZnQgPSAyNiAtIGJoaUJpdHM7XG5cdCAgICBpZiAoc2hpZnQgIT09IDApIHtcblx0ICAgICAgYiA9IGIudXNobG4oc2hpZnQpO1xuXHQgICAgICBhLml1c2hsbihzaGlmdCk7XG5cdCAgICAgIGJoaSA9IGIud29yZHNbYi5sZW5ndGggLSAxXSB8IDA7XG5cdCAgICB9XG5cblx0ICAgIC8vIEluaXRpYWxpemUgcXVvdGllbnRcblx0ICAgIHZhciBtID0gYS5sZW5ndGggLSBiLmxlbmd0aDtcblx0ICAgIHZhciBxO1xuXG5cdCAgICBpZiAobW9kZSAhPT0gJ21vZCcpIHtcblx0ICAgICAgcSA9IG5ldyBCTihudWxsKTtcblx0ICAgICAgcS5sZW5ndGggPSBtICsgMTtcblx0ICAgICAgcS53b3JkcyA9IG5ldyBBcnJheShxLmxlbmd0aCk7XG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcS5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHEud29yZHNbaV0gPSAwO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHZhciBkaWZmID0gYS5jbG9uZSgpLl9pc2hsbnN1Ym11bChiLCAxLCBtKTtcblx0ICAgIGlmIChkaWZmLm5lZ2F0aXZlID09PSAwKSB7XG5cdCAgICAgIGEgPSBkaWZmO1xuXHQgICAgICBpZiAocSkge1xuXHQgICAgICAgIHEud29yZHNbbV0gPSAxO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGZvciAodmFyIGogPSBtIC0gMTsgaiA+PSAwOyBqLS0pIHtcblx0ICAgICAgdmFyIHFqID0gKGEud29yZHNbYi5sZW5ndGggKyBqXSB8IDApICogMHg0MDAwMDAwICtcblx0ICAgICAgICAoYS53b3Jkc1tiLmxlbmd0aCArIGogLSAxXSB8IDApO1xuXG5cdCAgICAgIC8vIE5PVEU6IChxaiAvIGJoaSkgaXMgKDB4M2ZmZmZmZiAqIDB4NDAwMDAwMCArIDB4M2ZmZmZmZikgLyAweDIwMDAwMDAgbWF4XG5cdCAgICAgIC8vICgweDdmZmZmZmYpXG5cdCAgICAgIHFqID0gTWF0aC5taW4oKHFqIC8gYmhpKSB8IDAsIDB4M2ZmZmZmZik7XG5cblx0ICAgICAgYS5faXNobG5zdWJtdWwoYiwgcWosIGopO1xuXHQgICAgICB3aGlsZSAoYS5uZWdhdGl2ZSAhPT0gMCkge1xuXHQgICAgICAgIHFqLS07XG5cdCAgICAgICAgYS5uZWdhdGl2ZSA9IDA7XG5cdCAgICAgICAgYS5faXNobG5zdWJtdWwoYiwgMSwgaik7XG5cdCAgICAgICAgaWYgKCFhLmlzWmVybygpKSB7XG5cdCAgICAgICAgICBhLm5lZ2F0aXZlIF49IDE7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIGlmIChxKSB7XG5cdCAgICAgICAgcS53b3Jkc1tqXSA9IHFqO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICBpZiAocSkge1xuXHQgICAgICBxLnN0cmlwKCk7XG5cdCAgICB9XG5cdCAgICBhLnN0cmlwKCk7XG5cblx0ICAgIC8vIERlbm9ybWFsaXplXG5cdCAgICBpZiAobW9kZSAhPT0gJ2RpdicgJiYgc2hpZnQgIT09IDApIHtcblx0ICAgICAgYS5pdXNocm4oc2hpZnQpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4ge1xuXHQgICAgICBkaXY6IHEgfHwgbnVsbCxcblx0ICAgICAgbW9kOiBhXG5cdCAgICB9O1xuXHQgIH07XG5cblx0ICAvLyBOT1RFOiAxKSBgbW9kZWAgY2FuIGJlIHNldCB0byBgbW9kYCB0byByZXF1ZXN0IG1vZCBvbmx5LFxuXHQgIC8vICAgICAgIHRvIGBkaXZgIHRvIHJlcXVlc3QgZGl2IG9ubHksIG9yIGJlIGFic2VudCB0b1xuXHQgIC8vICAgICAgIHJlcXVlc3QgYm90aCBkaXYgJiBtb2Rcblx0ICAvLyAgICAgICAyKSBgcG9zaXRpdmVgIGlzIHRydWUgaWYgdW5zaWduZWQgbW9kIGlzIHJlcXVlc3RlZFxuXHQgIEJOLnByb3RvdHlwZS5kaXZtb2QgPSBmdW5jdGlvbiBkaXZtb2QgKG51bSwgbW9kZSwgcG9zaXRpdmUpIHtcblx0ICAgIGFzc2VydCghbnVtLmlzWmVybygpKTtcblxuXHQgICAgaWYgKHRoaXMuaXNaZXJvKCkpIHtcblx0ICAgICAgcmV0dXJuIHtcblx0ICAgICAgICBkaXY6IG5ldyBCTigwKSxcblx0ICAgICAgICBtb2Q6IG5ldyBCTigwKVxuXHQgICAgICB9O1xuXHQgICAgfVxuXG5cdCAgICB2YXIgZGl2LCBtb2QsIHJlcztcblx0ICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwICYmIG51bS5uZWdhdGl2ZSA9PT0gMCkge1xuXHQgICAgICByZXMgPSB0aGlzLm5lZygpLmRpdm1vZChudW0sIG1vZGUpO1xuXG5cdCAgICAgIGlmIChtb2RlICE9PSAnbW9kJykge1xuXHQgICAgICAgIGRpdiA9IHJlcy5kaXYubmVnKCk7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAobW9kZSAhPT0gJ2RpdicpIHtcblx0ICAgICAgICBtb2QgPSByZXMubW9kLm5lZygpO1xuXHQgICAgICAgIGlmIChwb3NpdGl2ZSAmJiBtb2QubmVnYXRpdmUgIT09IDApIHtcblx0ICAgICAgICAgIG1vZC5pYWRkKG51bSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuIHtcblx0ICAgICAgICBkaXY6IGRpdixcblx0ICAgICAgICBtb2Q6IG1vZFxuXHQgICAgICB9O1xuXHQgICAgfVxuXG5cdCAgICBpZiAodGhpcy5uZWdhdGl2ZSA9PT0gMCAmJiBudW0ubmVnYXRpdmUgIT09IDApIHtcblx0ICAgICAgcmVzID0gdGhpcy5kaXZtb2QobnVtLm5lZygpLCBtb2RlKTtcblxuXHQgICAgICBpZiAobW9kZSAhPT0gJ21vZCcpIHtcblx0ICAgICAgICBkaXYgPSByZXMuZGl2Lm5lZygpO1xuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuIHtcblx0ICAgICAgICBkaXY6IGRpdixcblx0ICAgICAgICBtb2Q6IHJlcy5tb2Rcblx0ICAgICAgfTtcblx0ICAgIH1cblxuXHQgICAgaWYgKCh0aGlzLm5lZ2F0aXZlICYgbnVtLm5lZ2F0aXZlKSAhPT0gMCkge1xuXHQgICAgICByZXMgPSB0aGlzLm5lZygpLmRpdm1vZChudW0ubmVnKCksIG1vZGUpO1xuXG5cdCAgICAgIGlmIChtb2RlICE9PSAnZGl2Jykge1xuXHQgICAgICAgIG1vZCA9IHJlcy5tb2QubmVnKCk7XG5cdCAgICAgICAgaWYgKHBvc2l0aXZlICYmIG1vZC5uZWdhdGl2ZSAhPT0gMCkge1xuXHQgICAgICAgICAgbW9kLmlzdWIobnVtKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICByZXR1cm4ge1xuXHQgICAgICAgIGRpdjogcmVzLmRpdixcblx0ICAgICAgICBtb2Q6IG1vZFxuXHQgICAgICB9O1xuXHQgICAgfVxuXG5cdCAgICAvLyBCb3RoIG51bWJlcnMgYXJlIHBvc2l0aXZlIGF0IHRoaXMgcG9pbnRcblxuXHQgICAgLy8gU3RyaXAgYm90aCBudW1iZXJzIHRvIGFwcHJveGltYXRlIHNoaWZ0IHZhbHVlXG5cdCAgICBpZiAobnVtLmxlbmd0aCA+IHRoaXMubGVuZ3RoIHx8IHRoaXMuY21wKG51bSkgPCAwKSB7XG5cdCAgICAgIHJldHVybiB7XG5cdCAgICAgICAgZGl2OiBuZXcgQk4oMCksXG5cdCAgICAgICAgbW9kOiB0aGlzXG5cdCAgICAgIH07XG5cdCAgICB9XG5cblx0ICAgIC8vIFZlcnkgc2hvcnQgcmVkdWN0aW9uXG5cdCAgICBpZiAobnVtLmxlbmd0aCA9PT0gMSkge1xuXHQgICAgICBpZiAobW9kZSA9PT0gJ2RpdicpIHtcblx0ICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgZGl2OiB0aGlzLmRpdm4obnVtLndvcmRzWzBdKSxcblx0ICAgICAgICAgIG1vZDogbnVsbFxuXHQgICAgICAgIH07XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAobW9kZSA9PT0gJ21vZCcpIHtcblx0ICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgZGl2OiBudWxsLFxuXHQgICAgICAgICAgbW9kOiBuZXcgQk4odGhpcy5tb2RuKG51bS53b3Jkc1swXSkpXG5cdCAgICAgICAgfTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHJldHVybiB7XG5cdCAgICAgICAgZGl2OiB0aGlzLmRpdm4obnVtLndvcmRzWzBdKSxcblx0ICAgICAgICBtb2Q6IG5ldyBCTih0aGlzLm1vZG4obnVtLndvcmRzWzBdKSlcblx0ICAgICAgfTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHRoaXMuX3dvcmREaXYobnVtLCBtb2RlKTtcblx0ICB9O1xuXG5cdCAgLy8gRmluZCBgdGhpc2AgLyBgbnVtYFxuXHQgIEJOLnByb3RvdHlwZS5kaXYgPSBmdW5jdGlvbiBkaXYgKG51bSkge1xuXHQgICAgcmV0dXJuIHRoaXMuZGl2bW9kKG51bSwgJ2RpdicsIGZhbHNlKS5kaXY7XG5cdCAgfTtcblxuXHQgIC8vIEZpbmQgYHRoaXNgICUgYG51bWBcblx0ICBCTi5wcm90b3R5cGUubW9kID0gZnVuY3Rpb24gbW9kIChudW0pIHtcblx0ICAgIHJldHVybiB0aGlzLmRpdm1vZChudW0sICdtb2QnLCBmYWxzZSkubW9kO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUudW1vZCA9IGZ1bmN0aW9uIHVtb2QgKG51bSkge1xuXHQgICAgcmV0dXJuIHRoaXMuZGl2bW9kKG51bSwgJ21vZCcsIHRydWUpLm1vZDtcblx0ICB9O1xuXG5cdCAgLy8gRmluZCBSb3VuZChgdGhpc2AgLyBgbnVtYClcblx0ICBCTi5wcm90b3R5cGUuZGl2Um91bmQgPSBmdW5jdGlvbiBkaXZSb3VuZCAobnVtKSB7XG5cdCAgICB2YXIgZG0gPSB0aGlzLmRpdm1vZChudW0pO1xuXG5cdCAgICAvLyBGYXN0IGNhc2UgLSBleGFjdCBkaXZpc2lvblxuXHQgICAgaWYgKGRtLm1vZC5pc1plcm8oKSkgcmV0dXJuIGRtLmRpdjtcblxuXHQgICAgdmFyIG1vZCA9IGRtLmRpdi5uZWdhdGl2ZSAhPT0gMCA/IGRtLm1vZC5pc3ViKG51bSkgOiBkbS5tb2Q7XG5cblx0ICAgIHZhciBoYWxmID0gbnVtLnVzaHJuKDEpO1xuXHQgICAgdmFyIHIyID0gbnVtLmFuZGxuKDEpO1xuXHQgICAgdmFyIGNtcCA9IG1vZC5jbXAoaGFsZik7XG5cblx0ICAgIC8vIFJvdW5kIGRvd25cblx0ICAgIGlmIChjbXAgPCAwIHx8IHIyID09PSAxICYmIGNtcCA9PT0gMCkgcmV0dXJuIGRtLmRpdjtcblxuXHQgICAgLy8gUm91bmQgdXBcblx0ICAgIHJldHVybiBkbS5kaXYubmVnYXRpdmUgIT09IDAgPyBkbS5kaXYuaXN1Ym4oMSkgOiBkbS5kaXYuaWFkZG4oMSk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5tb2RuID0gZnVuY3Rpb24gbW9kbiAobnVtKSB7XG5cdCAgICBhc3NlcnQobnVtIDw9IDB4M2ZmZmZmZik7XG5cdCAgICB2YXIgcCA9ICgxIDw8IDI2KSAlIG51bTtcblxuXHQgICAgdmFyIGFjYyA9IDA7XG5cdCAgICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHQgICAgICBhY2MgPSAocCAqIGFjYyArICh0aGlzLndvcmRzW2ldIHwgMCkpICUgbnVtO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gYWNjO1xuXHQgIH07XG5cblx0ICAvLyBJbi1wbGFjZSBkaXZpc2lvbiBieSBudW1iZXJcblx0ICBCTi5wcm90b3R5cGUuaWRpdm4gPSBmdW5jdGlvbiBpZGl2biAobnVtKSB7XG5cdCAgICBhc3NlcnQobnVtIDw9IDB4M2ZmZmZmZik7XG5cblx0ICAgIHZhciBjYXJyeSA9IDA7XG5cdCAgICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHQgICAgICB2YXIgdyA9ICh0aGlzLndvcmRzW2ldIHwgMCkgKyBjYXJyeSAqIDB4NDAwMDAwMDtcblx0ICAgICAgdGhpcy53b3Jkc1tpXSA9ICh3IC8gbnVtKSB8IDA7XG5cdCAgICAgIGNhcnJ5ID0gdyAlIG51bTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmRpdm4gPSBmdW5jdGlvbiBkaXZuIChudW0pIHtcblx0ICAgIHJldHVybiB0aGlzLmNsb25lKCkuaWRpdm4obnVtKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmVnY2QgPSBmdW5jdGlvbiBlZ2NkIChwKSB7XG5cdCAgICBhc3NlcnQocC5uZWdhdGl2ZSA9PT0gMCk7XG5cdCAgICBhc3NlcnQoIXAuaXNaZXJvKCkpO1xuXG5cdCAgICB2YXIgeCA9IHRoaXM7XG5cdCAgICB2YXIgeSA9IHAuY2xvbmUoKTtcblxuXHQgICAgaWYgKHgubmVnYXRpdmUgIT09IDApIHtcblx0ICAgICAgeCA9IHgudW1vZChwKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHggPSB4LmNsb25lKCk7XG5cdCAgICB9XG5cblx0ICAgIC8vIEEgKiB4ICsgQiAqIHkgPSB4XG5cdCAgICB2YXIgQSA9IG5ldyBCTigxKTtcblx0ICAgIHZhciBCID0gbmV3IEJOKDApO1xuXG5cdCAgICAvLyBDICogeCArIEQgKiB5ID0geVxuXHQgICAgdmFyIEMgPSBuZXcgQk4oMCk7XG5cdCAgICB2YXIgRCA9IG5ldyBCTigxKTtcblxuXHQgICAgdmFyIGcgPSAwO1xuXG5cdCAgICB3aGlsZSAoeC5pc0V2ZW4oKSAmJiB5LmlzRXZlbigpKSB7XG5cdCAgICAgIHguaXVzaHJuKDEpO1xuXHQgICAgICB5Lml1c2hybigxKTtcblx0ICAgICAgKytnO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgeXAgPSB5LmNsb25lKCk7XG5cdCAgICB2YXIgeHAgPSB4LmNsb25lKCk7XG5cblx0ICAgIHdoaWxlICgheC5pc1plcm8oKSkge1xuXHQgICAgICBmb3IgKHZhciBpID0gMCwgaW0gPSAxOyAoeC53b3Jkc1swXSAmIGltKSA9PT0gMCAmJiBpIDwgMjY7ICsraSwgaW0gPDw9IDEpO1xuXHQgICAgICBpZiAoaSA+IDApIHtcblx0ICAgICAgICB4Lml1c2hybihpKTtcblx0ICAgICAgICB3aGlsZSAoaS0tID4gMCkge1xuXHQgICAgICAgICAgaWYgKEEuaXNPZGQoKSB8fCBCLmlzT2RkKCkpIHtcblx0ICAgICAgICAgICAgQS5pYWRkKHlwKTtcblx0ICAgICAgICAgICAgQi5pc3ViKHhwKTtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgQS5pdXNocm4oMSk7XG5cdCAgICAgICAgICBCLml1c2hybigxKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICBmb3IgKHZhciBqID0gMCwgam0gPSAxOyAoeS53b3Jkc1swXSAmIGptKSA9PT0gMCAmJiBqIDwgMjY7ICsraiwgam0gPDw9IDEpO1xuXHQgICAgICBpZiAoaiA+IDApIHtcblx0ICAgICAgICB5Lml1c2hybihqKTtcblx0ICAgICAgICB3aGlsZSAoai0tID4gMCkge1xuXHQgICAgICAgICAgaWYgKEMuaXNPZGQoKSB8fCBELmlzT2RkKCkpIHtcblx0ICAgICAgICAgICAgQy5pYWRkKHlwKTtcblx0ICAgICAgICAgICAgRC5pc3ViKHhwKTtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgQy5pdXNocm4oMSk7XG5cdCAgICAgICAgICBELml1c2hybigxKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoeC5jbXAoeSkgPj0gMCkge1xuXHQgICAgICAgIHguaXN1Yih5KTtcblx0ICAgICAgICBBLmlzdWIoQyk7XG5cdCAgICAgICAgQi5pc3ViKEQpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHkuaXN1Yih4KTtcblx0ICAgICAgICBDLmlzdWIoQSk7XG5cdCAgICAgICAgRC5pc3ViKEIpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB7XG5cdCAgICAgIGE6IEMsXG5cdCAgICAgIGI6IEQsXG5cdCAgICAgIGdjZDogeS5pdXNobG4oZylcblx0ICAgIH07XG5cdCAgfTtcblxuXHQgIC8vIFRoaXMgaXMgcmVkdWNlZCBpbmNhcm5hdGlvbiBvZiB0aGUgYmluYXJ5IEVFQVxuXHQgIC8vIGFib3ZlLCBkZXNpZ25hdGVkIHRvIGludmVydCBtZW1iZXJzIG9mIHRoZVxuXHQgIC8vIF9wcmltZV8gZmllbGRzIEYocCkgYXQgYSBtYXhpbWFsIHNwZWVkXG5cdCAgQk4ucHJvdG90eXBlLl9pbnZtcCA9IGZ1bmN0aW9uIF9pbnZtcCAocCkge1xuXHQgICAgYXNzZXJ0KHAubmVnYXRpdmUgPT09IDApO1xuXHQgICAgYXNzZXJ0KCFwLmlzWmVybygpKTtcblxuXHQgICAgdmFyIGEgPSB0aGlzO1xuXHQgICAgdmFyIGIgPSBwLmNsb25lKCk7XG5cblx0ICAgIGlmIChhLm5lZ2F0aXZlICE9PSAwKSB7XG5cdCAgICAgIGEgPSBhLnVtb2QocCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBhID0gYS5jbG9uZSgpO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgeDEgPSBuZXcgQk4oMSk7XG5cdCAgICB2YXIgeDIgPSBuZXcgQk4oMCk7XG5cblx0ICAgIHZhciBkZWx0YSA9IGIuY2xvbmUoKTtcblxuXHQgICAgd2hpbGUgKGEuY21wbigxKSA+IDAgJiYgYi5jbXBuKDEpID4gMCkge1xuXHQgICAgICBmb3IgKHZhciBpID0gMCwgaW0gPSAxOyAoYS53b3Jkc1swXSAmIGltKSA9PT0gMCAmJiBpIDwgMjY7ICsraSwgaW0gPDw9IDEpO1xuXHQgICAgICBpZiAoaSA+IDApIHtcblx0ICAgICAgICBhLml1c2hybihpKTtcblx0ICAgICAgICB3aGlsZSAoaS0tID4gMCkge1xuXHQgICAgICAgICAgaWYgKHgxLmlzT2RkKCkpIHtcblx0ICAgICAgICAgICAgeDEuaWFkZChkZWx0YSk7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIHgxLml1c2hybigxKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICBmb3IgKHZhciBqID0gMCwgam0gPSAxOyAoYi53b3Jkc1swXSAmIGptKSA9PT0gMCAmJiBqIDwgMjY7ICsraiwgam0gPDw9IDEpO1xuXHQgICAgICBpZiAoaiA+IDApIHtcblx0ICAgICAgICBiLml1c2hybihqKTtcblx0ICAgICAgICB3aGlsZSAoai0tID4gMCkge1xuXHQgICAgICAgICAgaWYgKHgyLmlzT2RkKCkpIHtcblx0ICAgICAgICAgICAgeDIuaWFkZChkZWx0YSk7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIHgyLml1c2hybigxKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoYS5jbXAoYikgPj0gMCkge1xuXHQgICAgICAgIGEuaXN1YihiKTtcblx0ICAgICAgICB4MS5pc3ViKHgyKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBiLmlzdWIoYSk7XG5cdCAgICAgICAgeDIuaXN1Yih4MSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgdmFyIHJlcztcblx0ICAgIGlmIChhLmNtcG4oMSkgPT09IDApIHtcblx0ICAgICAgcmVzID0geDE7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXMgPSB4Mjtcblx0ICAgIH1cblxuXHQgICAgaWYgKHJlcy5jbXBuKDApIDwgMCkge1xuXHQgICAgICByZXMuaWFkZChwKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHJlcztcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmdjZCA9IGZ1bmN0aW9uIGdjZCAobnVtKSB7XG5cdCAgICBpZiAodGhpcy5pc1plcm8oKSkgcmV0dXJuIG51bS5hYnMoKTtcblx0ICAgIGlmIChudW0uaXNaZXJvKCkpIHJldHVybiB0aGlzLmFicygpO1xuXG5cdCAgICB2YXIgYSA9IHRoaXMuY2xvbmUoKTtcblx0ICAgIHZhciBiID0gbnVtLmNsb25lKCk7XG5cdCAgICBhLm5lZ2F0aXZlID0gMDtcblx0ICAgIGIubmVnYXRpdmUgPSAwO1xuXG5cdCAgICAvLyBSZW1vdmUgY29tbW9uIGZhY3RvciBvZiB0d29cblx0ICAgIGZvciAodmFyIHNoaWZ0ID0gMDsgYS5pc0V2ZW4oKSAmJiBiLmlzRXZlbigpOyBzaGlmdCsrKSB7XG5cdCAgICAgIGEuaXVzaHJuKDEpO1xuXHQgICAgICBiLml1c2hybigxKTtcblx0ICAgIH1cblxuXHQgICAgZG8ge1xuXHQgICAgICB3aGlsZSAoYS5pc0V2ZW4oKSkge1xuXHQgICAgICAgIGEuaXVzaHJuKDEpO1xuXHQgICAgICB9XG5cdCAgICAgIHdoaWxlIChiLmlzRXZlbigpKSB7XG5cdCAgICAgICAgYi5pdXNocm4oMSk7XG5cdCAgICAgIH1cblxuXHQgICAgICB2YXIgciA9IGEuY21wKGIpO1xuXHQgICAgICBpZiAociA8IDApIHtcblx0ICAgICAgICAvLyBTd2FwIGBhYCBhbmQgYGJgIHRvIG1ha2UgYGFgIGFsd2F5cyBiaWdnZXIgdGhhbiBgYmBcblx0ICAgICAgICB2YXIgdCA9IGE7XG5cdCAgICAgICAgYSA9IGI7XG5cdCAgICAgICAgYiA9IHQ7XG5cdCAgICAgIH0gZWxzZSBpZiAociA9PT0gMCB8fCBiLmNtcG4oMSkgPT09IDApIHtcblx0ICAgICAgICBicmVhaztcblx0ICAgICAgfVxuXG5cdCAgICAgIGEuaXN1YihiKTtcblx0ICAgIH0gd2hpbGUgKHRydWUpO1xuXG5cdCAgICByZXR1cm4gYi5pdXNobG4oc2hpZnQpO1xuXHQgIH07XG5cblx0ICAvLyBJbnZlcnQgbnVtYmVyIGluIHRoZSBmaWVsZCBGKG51bSlcblx0ICBCTi5wcm90b3R5cGUuaW52bSA9IGZ1bmN0aW9uIGludm0gKG51bSkge1xuXHQgICAgcmV0dXJuIHRoaXMuZWdjZChudW0pLmEudW1vZChudW0pO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuaXNFdmVuID0gZnVuY3Rpb24gaXNFdmVuICgpIHtcblx0ICAgIHJldHVybiAodGhpcy53b3Jkc1swXSAmIDEpID09PSAwO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuaXNPZGQgPSBmdW5jdGlvbiBpc09kZCAoKSB7XG5cdCAgICByZXR1cm4gKHRoaXMud29yZHNbMF0gJiAxKSA9PT0gMTtcblx0ICB9O1xuXG5cdCAgLy8gQW5kIGZpcnN0IHdvcmQgYW5kIG51bVxuXHQgIEJOLnByb3RvdHlwZS5hbmRsbiA9IGZ1bmN0aW9uIGFuZGxuIChudW0pIHtcblx0ICAgIHJldHVybiB0aGlzLndvcmRzWzBdICYgbnVtO1xuXHQgIH07XG5cblx0ICAvLyBJbmNyZW1lbnQgYXQgdGhlIGJpdCBwb3NpdGlvbiBpbi1saW5lXG5cdCAgQk4ucHJvdG90eXBlLmJpbmNuID0gZnVuY3Rpb24gYmluY24gKGJpdCkge1xuXHQgICAgYXNzZXJ0KHR5cGVvZiBiaXQgPT09ICdudW1iZXInKTtcblx0ICAgIHZhciByID0gYml0ICUgMjY7XG5cdCAgICB2YXIgcyA9IChiaXQgLSByKSAvIDI2O1xuXHQgICAgdmFyIHEgPSAxIDw8IHI7XG5cblx0ICAgIC8vIEZhc3QgY2FzZTogYml0IGlzIG11Y2ggaGlnaGVyIHRoYW4gYWxsIGV4aXN0aW5nIHdvcmRzXG5cdCAgICBpZiAodGhpcy5sZW5ndGggPD0gcykge1xuXHQgICAgICB0aGlzLl9leHBhbmQocyArIDEpO1xuXHQgICAgICB0aGlzLndvcmRzW3NdIHw9IHE7XG5cdCAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfVxuXG5cdCAgICAvLyBBZGQgYml0IGFuZCBwcm9wYWdhdGUsIGlmIG5lZWRlZFxuXHQgICAgdmFyIGNhcnJ5ID0gcTtcblx0ICAgIGZvciAodmFyIGkgPSBzOyBjYXJyeSAhPT0gMCAmJiBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICB2YXIgdyA9IHRoaXMud29yZHNbaV0gfCAwO1xuXHQgICAgICB3ICs9IGNhcnJ5O1xuXHQgICAgICBjYXJyeSA9IHcgPj4+IDI2O1xuXHQgICAgICB3ICY9IDB4M2ZmZmZmZjtcblx0ICAgICAgdGhpcy53b3Jkc1tpXSA9IHc7XG5cdCAgICB9XG5cdCAgICBpZiAoY2FycnkgIT09IDApIHtcblx0ICAgICAgdGhpcy53b3Jkc1tpXSA9IGNhcnJ5O1xuXHQgICAgICB0aGlzLmxlbmd0aCsrO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5pc1plcm8gPSBmdW5jdGlvbiBpc1plcm8gKCkge1xuXHQgICAgcmV0dXJuIHRoaXMubGVuZ3RoID09PSAxICYmIHRoaXMud29yZHNbMF0gPT09IDA7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5jbXBuID0gZnVuY3Rpb24gY21wbiAobnVtKSB7XG5cdCAgICB2YXIgbmVnYXRpdmUgPSBudW0gPCAwO1xuXG5cdCAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiAhbmVnYXRpdmUpIHJldHVybiAtMTtcblx0ICAgIGlmICh0aGlzLm5lZ2F0aXZlID09PSAwICYmIG5lZ2F0aXZlKSByZXR1cm4gMTtcblxuXHQgICAgdGhpcy5zdHJpcCgpO1xuXG5cdCAgICB2YXIgcmVzO1xuXHQgICAgaWYgKHRoaXMubGVuZ3RoID4gMSkge1xuXHQgICAgICByZXMgPSAxO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgaWYgKG5lZ2F0aXZlKSB7XG5cdCAgICAgICAgbnVtID0gLW51bTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGFzc2VydChudW0gPD0gMHgzZmZmZmZmLCAnTnVtYmVyIGlzIHRvbyBiaWcnKTtcblxuXHQgICAgICB2YXIgdyA9IHRoaXMud29yZHNbMF0gfCAwO1xuXHQgICAgICByZXMgPSB3ID09PSBudW0gPyAwIDogdyA8IG51bSA/IC0xIDogMTtcblx0ICAgIH1cblx0ICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSByZXR1cm4gLXJlcyB8IDA7XG5cdCAgICByZXR1cm4gcmVzO1xuXHQgIH07XG5cblx0ICAvLyBDb21wYXJlIHR3byBudW1iZXJzIGFuZCByZXR1cm46XG5cdCAgLy8gMSAtIGlmIGB0aGlzYCA+IGBudW1gXG5cdCAgLy8gMCAtIGlmIGB0aGlzYCA9PSBgbnVtYFxuXHQgIC8vIC0xIC0gaWYgYHRoaXNgIDwgYG51bWBcblx0ICBCTi5wcm90b3R5cGUuY21wID0gZnVuY3Rpb24gY21wIChudW0pIHtcblx0ICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwICYmIG51bS5uZWdhdGl2ZSA9PT0gMCkgcmV0dXJuIC0xO1xuXHQgICAgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgbnVtLm5lZ2F0aXZlICE9PSAwKSByZXR1cm4gMTtcblxuXHQgICAgdmFyIHJlcyA9IHRoaXMudWNtcChudW0pO1xuXHQgICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHJldHVybiAtcmVzIHwgMDtcblx0ICAgIHJldHVybiByZXM7XG5cdCAgfTtcblxuXHQgIC8vIFVuc2lnbmVkIGNvbXBhcmlzb25cblx0ICBCTi5wcm90b3R5cGUudWNtcCA9IGZ1bmN0aW9uIHVjbXAgKG51bSkge1xuXHQgICAgLy8gQXQgdGhpcyBwb2ludCBib3RoIG51bWJlcnMgaGF2ZSB0aGUgc2FtZSBzaWduXG5cdCAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gMTtcblx0ICAgIGlmICh0aGlzLmxlbmd0aCA8IG51bS5sZW5ndGgpIHJldHVybiAtMTtcblxuXHQgICAgdmFyIHJlcyA9IDA7XG5cdCAgICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHQgICAgICB2YXIgYSA9IHRoaXMud29yZHNbaV0gfCAwO1xuXHQgICAgICB2YXIgYiA9IG51bS53b3Jkc1tpXSB8IDA7XG5cblx0ICAgICAgaWYgKGEgPT09IGIpIGNvbnRpbnVlO1xuXHQgICAgICBpZiAoYSA8IGIpIHtcblx0ICAgICAgICByZXMgPSAtMTtcblx0ICAgICAgfSBlbHNlIGlmIChhID4gYikge1xuXHQgICAgICAgIHJlcyA9IDE7XG5cdCAgICAgIH1cblx0ICAgICAgYnJlYWs7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcmVzO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuZ3RuID0gZnVuY3Rpb24gZ3RuIChudW0pIHtcblx0ICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA9PT0gMTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmd0ID0gZnVuY3Rpb24gZ3QgKG51bSkge1xuXHQgICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPT09IDE7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5ndGVuID0gZnVuY3Rpb24gZ3RlbiAobnVtKSB7XG5cdCAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPj0gMDtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmd0ZSA9IGZ1bmN0aW9uIGd0ZSAobnVtKSB7XG5cdCAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA+PSAwO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUubHRuID0gZnVuY3Rpb24gbHRuIChudW0pIHtcblx0ICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA9PT0gLTE7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5sdCA9IGZ1bmN0aW9uIGx0IChudW0pIHtcblx0ICAgIHJldHVybiB0aGlzLmNtcChudW0pID09PSAtMTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmx0ZW4gPSBmdW5jdGlvbiBsdGVuIChudW0pIHtcblx0ICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA8PSAwO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUubHRlID0gZnVuY3Rpb24gbHRlIChudW0pIHtcblx0ICAgIHJldHVybiB0aGlzLmNtcChudW0pIDw9IDA7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5lcW4gPSBmdW5jdGlvbiBlcW4gKG51bSkge1xuXHQgICAgcmV0dXJuIHRoaXMuY21wbihudW0pID09PSAwO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbiBlcSAobnVtKSB7XG5cdCAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA9PT0gMDtcblx0ICB9O1xuXG5cdCAgLy9cblx0ICAvLyBBIHJlZHVjZSBjb250ZXh0LCBjb3VsZCBiZSB1c2luZyBtb250Z29tZXJ5IG9yIHNvbWV0aGluZyBiZXR0ZXIsIGRlcGVuZGluZ1xuXHQgIC8vIG9uIHRoZSBgbWAgaXRzZWxmLlxuXHQgIC8vXG5cdCAgQk4ucmVkID0gZnVuY3Rpb24gcmVkIChudW0pIHtcblx0ICAgIHJldHVybiBuZXcgUmVkKG51bSk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS50b1JlZCA9IGZ1bmN0aW9uIHRvUmVkIChjdHgpIHtcblx0ICAgIGFzc2VydCghdGhpcy5yZWQsICdBbHJlYWR5IGEgbnVtYmVyIGluIHJlZHVjdGlvbiBjb250ZXh0Jyk7XG5cdCAgICBhc3NlcnQodGhpcy5uZWdhdGl2ZSA9PT0gMCwgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmVzJyk7XG5cdCAgICByZXR1cm4gY3R4LmNvbnZlcnRUbyh0aGlzKS5fZm9yY2VSZWQoY3R4KTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmZyb21SZWQgPSBmdW5jdGlvbiBmcm9tUmVkICgpIHtcblx0ICAgIGFzc2VydCh0aGlzLnJlZCwgJ2Zyb21SZWQgd29ya3Mgb25seSB3aXRoIG51bWJlcnMgaW4gcmVkdWN0aW9uIGNvbnRleHQnKTtcblx0ICAgIHJldHVybiB0aGlzLnJlZC5jb252ZXJ0RnJvbSh0aGlzKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLl9mb3JjZVJlZCA9IGZ1bmN0aW9uIF9mb3JjZVJlZCAoY3R4KSB7XG5cdCAgICB0aGlzLnJlZCA9IGN0eDtcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuZm9yY2VSZWQgPSBmdW5jdGlvbiBmb3JjZVJlZCAoY3R4KSB7XG5cdCAgICBhc3NlcnQoIXRoaXMucmVkLCAnQWxyZWFkeSBhIG51bWJlciBpbiByZWR1Y3Rpb24gY29udGV4dCcpO1xuXHQgICAgcmV0dXJuIHRoaXMuX2ZvcmNlUmVkKGN0eCk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5yZWRBZGQgPSBmdW5jdGlvbiByZWRBZGQgKG51bSkge1xuXHQgICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkQWRkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuXHQgICAgcmV0dXJuIHRoaXMucmVkLmFkZCh0aGlzLCBudW0pO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUucmVkSUFkZCA9IGZ1bmN0aW9uIHJlZElBZGQgKG51bSkge1xuXHQgICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkSUFkZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcblx0ICAgIHJldHVybiB0aGlzLnJlZC5pYWRkKHRoaXMsIG51bSk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5yZWRTdWIgPSBmdW5jdGlvbiByZWRTdWIgKG51bSkge1xuXHQgICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkU3ViIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuXHQgICAgcmV0dXJuIHRoaXMucmVkLnN1Yih0aGlzLCBudW0pO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUucmVkSVN1YiA9IGZ1bmN0aW9uIHJlZElTdWIgKG51bSkge1xuXHQgICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkSVN1YiB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcblx0ICAgIHJldHVybiB0aGlzLnJlZC5pc3ViKHRoaXMsIG51bSk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5yZWRTaGwgPSBmdW5jdGlvbiByZWRTaGwgKG51bSkge1xuXHQgICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkU2hsIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuXHQgICAgcmV0dXJuIHRoaXMucmVkLnNobCh0aGlzLCBudW0pO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUucmVkTXVsID0gZnVuY3Rpb24gcmVkTXVsIChudW0pIHtcblx0ICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZE11bCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcblx0ICAgIHRoaXMucmVkLl92ZXJpZnkyKHRoaXMsIG51bSk7XG5cdCAgICByZXR1cm4gdGhpcy5yZWQubXVsKHRoaXMsIG51bSk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5yZWRJTXVsID0gZnVuY3Rpb24gcmVkSU11bCAobnVtKSB7XG5cdCAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRNdWwgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG5cdCAgICB0aGlzLnJlZC5fdmVyaWZ5Mih0aGlzLCBudW0pO1xuXHQgICAgcmV0dXJuIHRoaXMucmVkLmltdWwodGhpcywgbnVtKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLnJlZFNxciA9IGZ1bmN0aW9uIHJlZFNxciAoKSB7XG5cdCAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRTcXIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG5cdCAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcblx0ICAgIHJldHVybiB0aGlzLnJlZC5zcXIodGhpcyk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5yZWRJU3FyID0gZnVuY3Rpb24gcmVkSVNxciAoKSB7XG5cdCAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRJU3FyIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuXHQgICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG5cdCAgICByZXR1cm4gdGhpcy5yZWQuaXNxcih0aGlzKTtcblx0ICB9O1xuXG5cdCAgLy8gU3F1YXJlIHJvb3Qgb3ZlciBwXG5cdCAgQk4ucHJvdG90eXBlLnJlZFNxcnQgPSBmdW5jdGlvbiByZWRTcXJ0ICgpIHtcblx0ICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZFNxcnQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG5cdCAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcblx0ICAgIHJldHVybiB0aGlzLnJlZC5zcXJ0KHRoaXMpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUucmVkSW52bSA9IGZ1bmN0aW9uIHJlZEludm0gKCkge1xuXHQgICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkSW52bSB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcblx0ICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuXHQgICAgcmV0dXJuIHRoaXMucmVkLmludm0odGhpcyk7XG5cdCAgfTtcblxuXHQgIC8vIFJldHVybiBuZWdhdGl2ZSBjbG9uZSBvZiBgdGhpc2AgJSBgcmVkIG1vZHVsb2Bcblx0ICBCTi5wcm90b3R5cGUucmVkTmVnID0gZnVuY3Rpb24gcmVkTmVnICgpIHtcblx0ICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZE5lZyB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcblx0ICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuXHQgICAgcmV0dXJuIHRoaXMucmVkLm5lZyh0aGlzKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLnJlZFBvdyA9IGZ1bmN0aW9uIHJlZFBvdyAobnVtKSB7XG5cdCAgICBhc3NlcnQodGhpcy5yZWQgJiYgIW51bS5yZWQsICdyZWRQb3cobm9ybWFsTnVtKScpO1xuXHQgICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG5cdCAgICByZXR1cm4gdGhpcy5yZWQucG93KHRoaXMsIG51bSk7XG5cdCAgfTtcblxuXHQgIC8vIFByaW1lIG51bWJlcnMgd2l0aCBlZmZpY2llbnQgcmVkdWN0aW9uXG5cdCAgdmFyIHByaW1lcyA9IHtcblx0ICAgIGsyNTY6IG51bGwsXG5cdCAgICBwMjI0OiBudWxsLFxuXHQgICAgcDE5MjogbnVsbCxcblx0ICAgIHAyNTUxOTogbnVsbFxuXHQgIH07XG5cblx0ICAvLyBQc2V1ZG8tTWVyc2VubmUgcHJpbWVcblx0ICBmdW5jdGlvbiBNUHJpbWUgKG5hbWUsIHApIHtcblx0ICAgIC8vIFAgPSAyIF4gTiAtIEtcblx0ICAgIHRoaXMubmFtZSA9IG5hbWU7XG5cdCAgICB0aGlzLnAgPSBuZXcgQk4ocCwgMTYpO1xuXHQgICAgdGhpcy5uID0gdGhpcy5wLmJpdExlbmd0aCgpO1xuXHQgICAgdGhpcy5rID0gbmV3IEJOKDEpLml1c2hsbih0aGlzLm4pLmlzdWIodGhpcy5wKTtcblxuXHQgICAgdGhpcy50bXAgPSB0aGlzLl90bXAoKTtcblx0ICB9XG5cblx0ICBNUHJpbWUucHJvdG90eXBlLl90bXAgPSBmdW5jdGlvbiBfdG1wICgpIHtcblx0ICAgIHZhciB0bXAgPSBuZXcgQk4obnVsbCk7XG5cdCAgICB0bXAud29yZHMgPSBuZXcgQXJyYXkoTWF0aC5jZWlsKHRoaXMubiAvIDEzKSk7XG5cdCAgICByZXR1cm4gdG1wO1xuXHQgIH07XG5cblx0ICBNUHJpbWUucHJvdG90eXBlLmlyZWR1Y2UgPSBmdW5jdGlvbiBpcmVkdWNlIChudW0pIHtcblx0ICAgIC8vIEFzc3VtZXMgdGhhdCBgbnVtYCBpcyBsZXNzIHRoYW4gYFBeMmBcblx0ICAgIC8vIG51bSA9IEhJICogKDIgXiBOIC0gSykgKyBISSAqIEsgKyBMTyA9IEhJICogSyArIExPIChtb2QgUClcblx0ICAgIHZhciByID0gbnVtO1xuXHQgICAgdmFyIHJsZW47XG5cblx0ICAgIGRvIHtcblx0ICAgICAgdGhpcy5zcGxpdChyLCB0aGlzLnRtcCk7XG5cdCAgICAgIHIgPSB0aGlzLmltdWxLKHIpO1xuXHQgICAgICByID0gci5pYWRkKHRoaXMudG1wKTtcblx0ICAgICAgcmxlbiA9IHIuYml0TGVuZ3RoKCk7XG5cdCAgICB9IHdoaWxlIChybGVuID4gdGhpcy5uKTtcblxuXHQgICAgdmFyIGNtcCA9IHJsZW4gPCB0aGlzLm4gPyAtMSA6IHIudWNtcCh0aGlzLnApO1xuXHQgICAgaWYgKGNtcCA9PT0gMCkge1xuXHQgICAgICByLndvcmRzWzBdID0gMDtcblx0ICAgICAgci5sZW5ndGggPSAxO1xuXHQgICAgfSBlbHNlIGlmIChjbXAgPiAwKSB7XG5cdCAgICAgIHIuaXN1Yih0aGlzLnApO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgaWYgKHIuc3RyaXAgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgIC8vIHIgaXMgQk4gdjQgaW5zdGFuY2Vcblx0ICAgICAgICByLnN0cmlwKCk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgLy8gciBpcyBCTiB2NSBpbnN0YW5jZVxuXHQgICAgICAgIHIuX3N0cmlwKCk7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHI7XG5cdCAgfTtcblxuXHQgIE1QcmltZS5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiBzcGxpdCAoaW5wdXQsIG91dCkge1xuXHQgICAgaW5wdXQuaXVzaHJuKHRoaXMubiwgMCwgb3V0KTtcblx0ICB9O1xuXG5cdCAgTVByaW1lLnByb3RvdHlwZS5pbXVsSyA9IGZ1bmN0aW9uIGltdWxLIChudW0pIHtcblx0ICAgIHJldHVybiBudW0uaW11bCh0aGlzLmspO1xuXHQgIH07XG5cblx0ICBmdW5jdGlvbiBLMjU2ICgpIHtcblx0ICAgIE1QcmltZS5jYWxsKFxuXHQgICAgICB0aGlzLFxuXHQgICAgICAnazI1NicsXG5cdCAgICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmMyZicpO1xuXHQgIH1cblx0ICBpbmhlcml0cyhLMjU2LCBNUHJpbWUpO1xuXG5cdCAgSzI1Ni5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiBzcGxpdCAoaW5wdXQsIG91dHB1dCkge1xuXHQgICAgLy8gMjU2ID0gOSAqIDI2ICsgMjJcblx0ICAgIHZhciBtYXNrID0gMHgzZmZmZmY7XG5cblx0ICAgIHZhciBvdXRMZW4gPSBNYXRoLm1pbihpbnB1dC5sZW5ndGgsIDkpO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXRMZW47IGkrKykge1xuXHQgICAgICBvdXRwdXQud29yZHNbaV0gPSBpbnB1dC53b3Jkc1tpXTtcblx0ICAgIH1cblx0ICAgIG91dHB1dC5sZW5ndGggPSBvdXRMZW47XG5cblx0ICAgIGlmIChpbnB1dC5sZW5ndGggPD0gOSkge1xuXHQgICAgICBpbnB1dC53b3Jkc1swXSA9IDA7XG5cdCAgICAgIGlucHV0Lmxlbmd0aCA9IDE7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgLy8gU2hpZnQgYnkgOSBsaW1ic1xuXHQgICAgdmFyIHByZXYgPSBpbnB1dC53b3Jkc1s5XTtcblx0ICAgIG91dHB1dC53b3Jkc1tvdXRwdXQubGVuZ3RoKytdID0gcHJldiAmIG1hc2s7XG5cblx0ICAgIGZvciAoaSA9IDEwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIG5leHQgPSBpbnB1dC53b3Jkc1tpXSB8IDA7XG5cdCAgICAgIGlucHV0LndvcmRzW2kgLSAxMF0gPSAoKG5leHQgJiBtYXNrKSA8PCA0KSB8IChwcmV2ID4+PiAyMik7XG5cdCAgICAgIHByZXYgPSBuZXh0O1xuXHQgICAgfVxuXHQgICAgcHJldiA+Pj49IDIyO1xuXHQgICAgaW5wdXQud29yZHNbaSAtIDEwXSA9IHByZXY7XG5cdCAgICBpZiAocHJldiA9PT0gMCAmJiBpbnB1dC5sZW5ndGggPiAxMCkge1xuXHQgICAgICBpbnB1dC5sZW5ndGggLT0gMTA7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBpbnB1dC5sZW5ndGggLT0gOTtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgSzI1Ni5wcm90b3R5cGUuaW11bEsgPSBmdW5jdGlvbiBpbXVsSyAobnVtKSB7XG5cdCAgICAvLyBLID0gMHgxMDAwMDAzZDEgPSBbIDB4NDAsIDB4M2QxIF1cblx0ICAgIG51bS53b3Jkc1tudW0ubGVuZ3RoXSA9IDA7XG5cdCAgICBudW0ud29yZHNbbnVtLmxlbmd0aCArIDFdID0gMDtcblx0ICAgIG51bS5sZW5ndGggKz0gMjtcblxuXHQgICAgLy8gYm91bmRlZCBhdDogMHg0MCAqIDB4M2ZmZmZmZiArIDB4M2QwID0gMHgxMDAwMDAzOTBcblx0ICAgIHZhciBsbyA9IDA7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xuXHQgICAgICB2YXIgdyA9IG51bS53b3Jkc1tpXSB8IDA7XG5cdCAgICAgIGxvICs9IHcgKiAweDNkMTtcblx0ICAgICAgbnVtLndvcmRzW2ldID0gbG8gJiAweDNmZmZmZmY7XG5cdCAgICAgIGxvID0gdyAqIDB4NDAgKyAoKGxvIC8gMHg0MDAwMDAwKSB8IDApO1xuXHQgICAgfVxuXG5cdCAgICAvLyBGYXN0IGxlbmd0aCByZWR1Y3Rpb25cblx0ICAgIGlmIChudW0ud29yZHNbbnVtLmxlbmd0aCAtIDFdID09PSAwKSB7XG5cdCAgICAgIG51bS5sZW5ndGgtLTtcblx0ICAgICAgaWYgKG51bS53b3Jkc1tudW0ubGVuZ3RoIC0gMV0gPT09IDApIHtcblx0ICAgICAgICBudW0ubGVuZ3RoLS07XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiBudW07XG5cdCAgfTtcblxuXHQgIGZ1bmN0aW9uIFAyMjQgKCkge1xuXHQgICAgTVByaW1lLmNhbGwoXG5cdCAgICAgIHRoaXMsXG5cdCAgICAgICdwMjI0Jyxcblx0ICAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAxJyk7XG5cdCAgfVxuXHQgIGluaGVyaXRzKFAyMjQsIE1QcmltZSk7XG5cblx0ICBmdW5jdGlvbiBQMTkyICgpIHtcblx0ICAgIE1QcmltZS5jYWxsKFxuXHQgICAgICB0aGlzLFxuXHQgICAgICAncDE5MicsXG5cdCAgICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmZmZiBmZmZmZmZmZicpO1xuXHQgIH1cblx0ICBpbmhlcml0cyhQMTkyLCBNUHJpbWUpO1xuXG5cdCAgZnVuY3Rpb24gUDI1NTE5ICgpIHtcblx0ICAgIC8vIDIgXiAyNTUgLSAxOVxuXHQgICAgTVByaW1lLmNhbGwoXG5cdCAgICAgIHRoaXMsXG5cdCAgICAgICcyNTUxOScsXG5cdCAgICAgICc3ZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmVkJyk7XG5cdCAgfVxuXHQgIGluaGVyaXRzKFAyNTUxOSwgTVByaW1lKTtcblxuXHQgIFAyNTUxOS5wcm90b3R5cGUuaW11bEsgPSBmdW5jdGlvbiBpbXVsSyAobnVtKSB7XG5cdCAgICAvLyBLID0gMHgxM1xuXHQgICAgdmFyIGNhcnJ5ID0gMDtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciBoaSA9IChudW0ud29yZHNbaV0gfCAwKSAqIDB4MTMgKyBjYXJyeTtcblx0ICAgICAgdmFyIGxvID0gaGkgJiAweDNmZmZmZmY7XG5cdCAgICAgIGhpID4+Pj0gMjY7XG5cblx0ICAgICAgbnVtLndvcmRzW2ldID0gbG87XG5cdCAgICAgIGNhcnJ5ID0gaGk7XG5cdCAgICB9XG5cdCAgICBpZiAoY2FycnkgIT09IDApIHtcblx0ICAgICAgbnVtLndvcmRzW251bS5sZW5ndGgrK10gPSBjYXJyeTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBudW07XG5cdCAgfTtcblxuXHQgIC8vIEV4cG9ydGVkIG1vc3RseSBmb3IgdGVzdGluZyBwdXJwb3NlcywgdXNlIHBsYWluIG5hbWUgaW5zdGVhZFxuXHQgIEJOLl9wcmltZSA9IGZ1bmN0aW9uIHByaW1lIChuYW1lKSB7XG5cdCAgICAvLyBDYWNoZWQgdmVyc2lvbiBvZiBwcmltZVxuXHQgICAgaWYgKHByaW1lc1tuYW1lXSkgcmV0dXJuIHByaW1lc1tuYW1lXTtcblxuXHQgICAgdmFyIHByaW1lO1xuXHQgICAgaWYgKG5hbWUgPT09ICdrMjU2Jykge1xuXHQgICAgICBwcmltZSA9IG5ldyBLMjU2KCk7XG5cdCAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdwMjI0Jykge1xuXHQgICAgICBwcmltZSA9IG5ldyBQMjI0KCk7XG5cdCAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdwMTkyJykge1xuXHQgICAgICBwcmltZSA9IG5ldyBQMTkyKCk7XG5cdCAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdwMjU1MTknKSB7XG5cdCAgICAgIHByaW1lID0gbmV3IFAyNTUxOSgpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHByaW1lICcgKyBuYW1lKTtcblx0ICAgIH1cblx0ICAgIHByaW1lc1tuYW1lXSA9IHByaW1lO1xuXG5cdCAgICByZXR1cm4gcHJpbWU7XG5cdCAgfTtcblxuXHQgIC8vXG5cdCAgLy8gQmFzZSByZWR1Y3Rpb24gZW5naW5lXG5cdCAgLy9cblx0ICBmdW5jdGlvbiBSZWQgKG0pIHtcblx0ICAgIGlmICh0eXBlb2YgbSA9PT0gJ3N0cmluZycpIHtcblx0ICAgICAgdmFyIHByaW1lID0gQk4uX3ByaW1lKG0pO1xuXHQgICAgICB0aGlzLm0gPSBwcmltZS5wO1xuXHQgICAgICB0aGlzLnByaW1lID0gcHJpbWU7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBhc3NlcnQobS5ndG4oMSksICdtb2R1bHVzIG11c3QgYmUgZ3JlYXRlciB0aGFuIDEnKTtcblx0ICAgICAgdGhpcy5tID0gbTtcblx0ICAgICAgdGhpcy5wcmltZSA9IG51bGw7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgUmVkLnByb3RvdHlwZS5fdmVyaWZ5MSA9IGZ1bmN0aW9uIF92ZXJpZnkxIChhKSB7XG5cdCAgICBhc3NlcnQoYS5uZWdhdGl2ZSA9PT0gMCwgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmVzJyk7XG5cdCAgICBhc3NlcnQoYS5yZWQsICdyZWQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG5cdCAgfTtcblxuXHQgIFJlZC5wcm90b3R5cGUuX3ZlcmlmeTIgPSBmdW5jdGlvbiBfdmVyaWZ5MiAoYSwgYikge1xuXHQgICAgYXNzZXJ0KChhLm5lZ2F0aXZlIHwgYi5uZWdhdGl2ZSkgPT09IDAsICdyZWQgd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlcycpO1xuXHQgICAgYXNzZXJ0KGEucmVkICYmIGEucmVkID09PSBiLnJlZCxcblx0ICAgICAgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcblx0ICB9O1xuXG5cdCAgUmVkLnByb3RvdHlwZS5pbW9kID0gZnVuY3Rpb24gaW1vZCAoYSkge1xuXHQgICAgaWYgKHRoaXMucHJpbWUpIHJldHVybiB0aGlzLnByaW1lLmlyZWR1Y2UoYSkuX2ZvcmNlUmVkKHRoaXMpO1xuXHQgICAgcmV0dXJuIGEudW1vZCh0aGlzLm0pLl9mb3JjZVJlZCh0aGlzKTtcblx0ICB9O1xuXG5cdCAgUmVkLnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbiBuZWcgKGEpIHtcblx0ICAgIGlmIChhLmlzWmVybygpKSB7XG5cdCAgICAgIHJldHVybiBhLmNsb25lKCk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB0aGlzLm0uc3ViKGEpLl9mb3JjZVJlZCh0aGlzKTtcblx0ICB9O1xuXG5cdCAgUmVkLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKGEsIGIpIHtcblx0ICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cblx0ICAgIHZhciByZXMgPSBhLmFkZChiKTtcblx0ICAgIGlmIChyZXMuY21wKHRoaXMubSkgPj0gMCkge1xuXHQgICAgICByZXMuaXN1Yih0aGlzLm0pO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG5cdCAgfTtcblxuXHQgIFJlZC5wcm90b3R5cGUuaWFkZCA9IGZ1bmN0aW9uIGlhZGQgKGEsIGIpIHtcblx0ICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cblx0ICAgIHZhciByZXMgPSBhLmlhZGQoYik7XG5cdCAgICBpZiAocmVzLmNtcCh0aGlzLm0pID49IDApIHtcblx0ICAgICAgcmVzLmlzdWIodGhpcy5tKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiByZXM7XG5cdCAgfTtcblxuXHQgIFJlZC5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24gc3ViIChhLCBiKSB7XG5cdCAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuXG5cdCAgICB2YXIgcmVzID0gYS5zdWIoYik7XG5cdCAgICBpZiAocmVzLmNtcG4oMCkgPCAwKSB7XG5cdCAgICAgIHJlcy5pYWRkKHRoaXMubSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcblx0ICB9O1xuXG5cdCAgUmVkLnByb3RvdHlwZS5pc3ViID0gZnVuY3Rpb24gaXN1YiAoYSwgYikge1xuXHQgICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuXHQgICAgdmFyIHJlcyA9IGEuaXN1YihiKTtcblx0ICAgIGlmIChyZXMuY21wbigwKSA8IDApIHtcblx0ICAgICAgcmVzLmlhZGQodGhpcy5tKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiByZXM7XG5cdCAgfTtcblxuXHQgIFJlZC5wcm90b3R5cGUuc2hsID0gZnVuY3Rpb24gc2hsIChhLCBudW0pIHtcblx0ICAgIHRoaXMuX3ZlcmlmeTEoYSk7XG5cdCAgICByZXR1cm4gdGhpcy5pbW9kKGEudXNobG4obnVtKSk7XG5cdCAgfTtcblxuXHQgIFJlZC5wcm90b3R5cGUuaW11bCA9IGZ1bmN0aW9uIGltdWwgKGEsIGIpIHtcblx0ICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cdCAgICByZXR1cm4gdGhpcy5pbW9kKGEuaW11bChiKSk7XG5cdCAgfTtcblxuXHQgIFJlZC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsIChhLCBiKSB7XG5cdCAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuXHQgICAgcmV0dXJuIHRoaXMuaW1vZChhLm11bChiKSk7XG5cdCAgfTtcblxuXHQgIFJlZC5wcm90b3R5cGUuaXNxciA9IGZ1bmN0aW9uIGlzcXIgKGEpIHtcblx0ICAgIHJldHVybiB0aGlzLmltdWwoYSwgYS5jbG9uZSgpKTtcblx0ICB9O1xuXG5cdCAgUmVkLnByb3RvdHlwZS5zcXIgPSBmdW5jdGlvbiBzcXIgKGEpIHtcblx0ICAgIHJldHVybiB0aGlzLm11bChhLCBhKTtcblx0ICB9O1xuXG5cdCAgUmVkLnByb3RvdHlwZS5zcXJ0ID0gZnVuY3Rpb24gc3FydCAoYSkge1xuXHQgICAgaWYgKGEuaXNaZXJvKCkpIHJldHVybiBhLmNsb25lKCk7XG5cblx0ICAgIHZhciBtb2QzID0gdGhpcy5tLmFuZGxuKDMpO1xuXHQgICAgYXNzZXJ0KG1vZDMgJSAyID09PSAxKTtcblxuXHQgICAgLy8gRmFzdCBjYXNlXG5cdCAgICBpZiAobW9kMyA9PT0gMykge1xuXHQgICAgICB2YXIgcG93ID0gdGhpcy5tLmFkZChuZXcgQk4oMSkpLml1c2hybigyKTtcblx0ICAgICAgcmV0dXJuIHRoaXMucG93KGEsIHBvdyk7XG5cdCAgICB9XG5cblx0ICAgIC8vIFRvbmVsbGktU2hhbmtzIGFsZ29yaXRobSAoVG90YWxseSB1bm9wdGltaXplZCBhbmQgc2xvdylcblx0ICAgIC8vXG5cdCAgICAvLyBGaW5kIFEgYW5kIFMsIHRoYXQgUSAqIDIgXiBTID0gKFAgLSAxKVxuXHQgICAgdmFyIHEgPSB0aGlzLm0uc3VibigxKTtcblx0ICAgIHZhciBzID0gMDtcblx0ICAgIHdoaWxlICghcS5pc1plcm8oKSAmJiBxLmFuZGxuKDEpID09PSAwKSB7XG5cdCAgICAgIHMrKztcblx0ICAgICAgcS5pdXNocm4oMSk7XG5cdCAgICB9XG5cdCAgICBhc3NlcnQoIXEuaXNaZXJvKCkpO1xuXG5cdCAgICB2YXIgb25lID0gbmV3IEJOKDEpLnRvUmVkKHRoaXMpO1xuXHQgICAgdmFyIG5PbmUgPSBvbmUucmVkTmVnKCk7XG5cblx0ICAgIC8vIEZpbmQgcXVhZHJhdGljIG5vbi1yZXNpZHVlXG5cdCAgICAvLyBOT1RFOiBNYXggaXMgc3VjaCBiZWNhdXNlIG9mIGdlbmVyYWxpemVkIFJpZW1hbm4gaHlwb3RoZXNpcy5cblx0ICAgIHZhciBscG93ID0gdGhpcy5tLnN1Ym4oMSkuaXVzaHJuKDEpO1xuXHQgICAgdmFyIHogPSB0aGlzLm0uYml0TGVuZ3RoKCk7XG5cdCAgICB6ID0gbmV3IEJOKDIgKiB6ICogeikudG9SZWQodGhpcyk7XG5cblx0ICAgIHdoaWxlICh0aGlzLnBvdyh6LCBscG93KS5jbXAobk9uZSkgIT09IDApIHtcblx0ICAgICAgei5yZWRJQWRkKG5PbmUpO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgYyA9IHRoaXMucG93KHosIHEpO1xuXHQgICAgdmFyIHIgPSB0aGlzLnBvdyhhLCBxLmFkZG4oMSkuaXVzaHJuKDEpKTtcblx0ICAgIHZhciB0ID0gdGhpcy5wb3coYSwgcSk7XG5cdCAgICB2YXIgbSA9IHM7XG5cdCAgICB3aGlsZSAodC5jbXAob25lKSAhPT0gMCkge1xuXHQgICAgICB2YXIgdG1wID0gdDtcblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IHRtcC5jbXAob25lKSAhPT0gMDsgaSsrKSB7XG5cdCAgICAgICAgdG1wID0gdG1wLnJlZFNxcigpO1xuXHQgICAgICB9XG5cdCAgICAgIGFzc2VydChpIDwgbSk7XG5cdCAgICAgIHZhciBiID0gdGhpcy5wb3coYywgbmV3IEJOKDEpLml1c2hsbihtIC0gaSAtIDEpKTtcblxuXHQgICAgICByID0gci5yZWRNdWwoYik7XG5cdCAgICAgIGMgPSBiLnJlZFNxcigpO1xuXHQgICAgICB0ID0gdC5yZWRNdWwoYyk7XG5cdCAgICAgIG0gPSBpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gcjtcblx0ICB9O1xuXG5cdCAgUmVkLnByb3RvdHlwZS5pbnZtID0gZnVuY3Rpb24gaW52bSAoYSkge1xuXHQgICAgdmFyIGludiA9IGEuX2ludm1wKHRoaXMubSk7XG5cdCAgICBpZiAoaW52Lm5lZ2F0aXZlICE9PSAwKSB7XG5cdCAgICAgIGludi5uZWdhdGl2ZSA9IDA7XG5cdCAgICAgIHJldHVybiB0aGlzLmltb2QoaW52KS5yZWROZWcoKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHJldHVybiB0aGlzLmltb2QoaW52KTtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgUmVkLnByb3RvdHlwZS5wb3cgPSBmdW5jdGlvbiBwb3cgKGEsIG51bSkge1xuXHQgICAgaWYgKG51bS5pc1plcm8oKSkgcmV0dXJuIG5ldyBCTigxKS50b1JlZCh0aGlzKTtcblx0ICAgIGlmIChudW0uY21wbigxKSA9PT0gMCkgcmV0dXJuIGEuY2xvbmUoKTtcblxuXHQgICAgdmFyIHdpbmRvd1NpemUgPSA0O1xuXHQgICAgdmFyIHduZCA9IG5ldyBBcnJheSgxIDw8IHdpbmRvd1NpemUpO1xuXHQgICAgd25kWzBdID0gbmV3IEJOKDEpLnRvUmVkKHRoaXMpO1xuXHQgICAgd25kWzFdID0gYTtcblx0ICAgIGZvciAodmFyIGkgPSAyOyBpIDwgd25kLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHduZFtpXSA9IHRoaXMubXVsKHduZFtpIC0gMV0sIGEpO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgcmVzID0gd25kWzBdO1xuXHQgICAgdmFyIGN1cnJlbnQgPSAwO1xuXHQgICAgdmFyIGN1cnJlbnRMZW4gPSAwO1xuXHQgICAgdmFyIHN0YXJ0ID0gbnVtLmJpdExlbmd0aCgpICUgMjY7XG5cdCAgICBpZiAoc3RhcnQgPT09IDApIHtcblx0ICAgICAgc3RhcnQgPSAyNjtcblx0ICAgIH1cblxuXHQgICAgZm9yIChpID0gbnVtLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdCAgICAgIHZhciB3b3JkID0gbnVtLndvcmRzW2ldO1xuXHQgICAgICBmb3IgKHZhciBqID0gc3RhcnQgLSAxOyBqID49IDA7IGotLSkge1xuXHQgICAgICAgIHZhciBiaXQgPSAod29yZCA+PiBqKSAmIDE7XG5cdCAgICAgICAgaWYgKHJlcyAhPT0gd25kWzBdKSB7XG5cdCAgICAgICAgICByZXMgPSB0aGlzLnNxcihyZXMpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmIChiaXQgPT09IDAgJiYgY3VycmVudCA9PT0gMCkge1xuXHQgICAgICAgICAgY3VycmVudExlbiA9IDA7XG5cdCAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBjdXJyZW50IDw8PSAxO1xuXHQgICAgICAgIGN1cnJlbnQgfD0gYml0O1xuXHQgICAgICAgIGN1cnJlbnRMZW4rKztcblx0ICAgICAgICBpZiAoY3VycmVudExlbiAhPT0gd2luZG93U2l6ZSAmJiAoaSAhPT0gMCB8fCBqICE9PSAwKSkgY29udGludWU7XG5cblx0ICAgICAgICByZXMgPSB0aGlzLm11bChyZXMsIHduZFtjdXJyZW50XSk7XG5cdCAgICAgICAgY3VycmVudExlbiA9IDA7XG5cdCAgICAgICAgY3VycmVudCA9IDA7XG5cdCAgICAgIH1cblx0ICAgICAgc3RhcnQgPSAyNjtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHJlcztcblx0ICB9O1xuXG5cdCAgUmVkLnByb3RvdHlwZS5jb252ZXJ0VG8gPSBmdW5jdGlvbiBjb252ZXJ0VG8gKG51bSkge1xuXHQgICAgdmFyIHIgPSBudW0udW1vZCh0aGlzLm0pO1xuXG5cdCAgICByZXR1cm4gciA9PT0gbnVtID8gci5jbG9uZSgpIDogcjtcblx0ICB9O1xuXG5cdCAgUmVkLnByb3RvdHlwZS5jb252ZXJ0RnJvbSA9IGZ1bmN0aW9uIGNvbnZlcnRGcm9tIChudW0pIHtcblx0ICAgIHZhciByZXMgPSBudW0uY2xvbmUoKTtcblx0ICAgIHJlcy5yZWQgPSBudWxsO1xuXHQgICAgcmV0dXJuIHJlcztcblx0ICB9O1xuXG5cdCAgLy9cblx0ICAvLyBNb250Z29tZXJ5IG1ldGhvZCBlbmdpbmVcblx0ICAvL1xuXG5cdCAgQk4ubW9udCA9IGZ1bmN0aW9uIG1vbnQgKG51bSkge1xuXHQgICAgcmV0dXJuIG5ldyBNb250KG51bSk7XG5cdCAgfTtcblxuXHQgIGZ1bmN0aW9uIE1vbnQgKG0pIHtcblx0ICAgIFJlZC5jYWxsKHRoaXMsIG0pO1xuXG5cdCAgICB0aGlzLnNoaWZ0ID0gdGhpcy5tLmJpdExlbmd0aCgpO1xuXHQgICAgaWYgKHRoaXMuc2hpZnQgJSAyNiAhPT0gMCkge1xuXHQgICAgICB0aGlzLnNoaWZ0ICs9IDI2IC0gKHRoaXMuc2hpZnQgJSAyNik7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuciA9IG5ldyBCTigxKS5pdXNobG4odGhpcy5zaGlmdCk7XG5cdCAgICB0aGlzLnIyID0gdGhpcy5pbW9kKHRoaXMuci5zcXIoKSk7XG5cdCAgICB0aGlzLnJpbnYgPSB0aGlzLnIuX2ludm1wKHRoaXMubSk7XG5cblx0ICAgIHRoaXMubWludiA9IHRoaXMucmludi5tdWwodGhpcy5yKS5pc3VibigxKS5kaXYodGhpcy5tKTtcblx0ICAgIHRoaXMubWludiA9IHRoaXMubWludi51bW9kKHRoaXMucik7XG5cdCAgICB0aGlzLm1pbnYgPSB0aGlzLnIuc3ViKHRoaXMubWludik7XG5cdCAgfVxuXHQgIGluaGVyaXRzKE1vbnQsIFJlZCk7XG5cblx0ICBNb250LnByb3RvdHlwZS5jb252ZXJ0VG8gPSBmdW5jdGlvbiBjb252ZXJ0VG8gKG51bSkge1xuXHQgICAgcmV0dXJuIHRoaXMuaW1vZChudW0udXNobG4odGhpcy5zaGlmdCkpO1xuXHQgIH07XG5cblx0ICBNb250LnByb3RvdHlwZS5jb252ZXJ0RnJvbSA9IGZ1bmN0aW9uIGNvbnZlcnRGcm9tIChudW0pIHtcblx0ICAgIHZhciByID0gdGhpcy5pbW9kKG51bS5tdWwodGhpcy5yaW52KSk7XG5cdCAgICByLnJlZCA9IG51bGw7XG5cdCAgICByZXR1cm4gcjtcblx0ICB9O1xuXG5cdCAgTW9udC5wcm90b3R5cGUuaW11bCA9IGZ1bmN0aW9uIGltdWwgKGEsIGIpIHtcblx0ICAgIGlmIChhLmlzWmVybygpIHx8IGIuaXNaZXJvKCkpIHtcblx0ICAgICAgYS53b3Jkc1swXSA9IDA7XG5cdCAgICAgIGEubGVuZ3RoID0gMTtcblx0ICAgICAgcmV0dXJuIGE7XG5cdCAgICB9XG5cblx0ICAgIHZhciB0ID0gYS5pbXVsKGIpO1xuXHQgICAgdmFyIGMgPSB0Lm1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm1pbnYpLmltYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5tKTtcblx0ICAgIHZhciB1ID0gdC5pc3ViKGMpLml1c2hybih0aGlzLnNoaWZ0KTtcblx0ICAgIHZhciByZXMgPSB1O1xuXG5cdCAgICBpZiAodS5jbXAodGhpcy5tKSA+PSAwKSB7XG5cdCAgICAgIHJlcyA9IHUuaXN1Yih0aGlzLm0pO1xuXHQgICAgfSBlbHNlIGlmICh1LmNtcG4oMCkgPCAwKSB7XG5cdCAgICAgIHJlcyA9IHUuaWFkZCh0aGlzLm0pO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcblx0ICB9O1xuXG5cdCAgTW9udC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsIChhLCBiKSB7XG5cdCAgICBpZiAoYS5pc1plcm8oKSB8fCBiLmlzWmVybygpKSByZXR1cm4gbmV3IEJOKDApLl9mb3JjZVJlZCh0aGlzKTtcblxuXHQgICAgdmFyIHQgPSBhLm11bChiKTtcblx0ICAgIHZhciBjID0gdC5tYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5taW52KS5pbWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubSk7XG5cdCAgICB2YXIgdSA9IHQuaXN1YihjKS5pdXNocm4odGhpcy5zaGlmdCk7XG5cdCAgICB2YXIgcmVzID0gdTtcblx0ICAgIGlmICh1LmNtcCh0aGlzLm0pID49IDApIHtcblx0ICAgICAgcmVzID0gdS5pc3ViKHRoaXMubSk7XG5cdCAgICB9IGVsc2UgaWYgKHUuY21wbigwKSA8IDApIHtcblx0ICAgICAgcmVzID0gdS5pYWRkKHRoaXMubSk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuXHQgIH07XG5cblx0ICBNb250LnByb3RvdHlwZS5pbnZtID0gZnVuY3Rpb24gaW52bSAoYSkge1xuXHQgICAgLy8gKEFSKV4tMSAqIFJeMiA9IChBXi0xICogUl4tMSkgKiBSXjIgPSBBXi0xICogUlxuXHQgICAgdmFyIHJlcyA9IHRoaXMuaW1vZChhLl9pbnZtcCh0aGlzLm0pLm11bCh0aGlzLnIyKSk7XG5cdCAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcblx0ICB9O1xuXHR9KSgnb2JqZWN0JyA9PT0gJ3VuZGVmaW5lZCcgfHwgbW9kdWxlLCBjb21tb25qc0dsb2JhbCk7XG5cdH0pO1xuXG5cdHZhciB1dGlsc18xID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIHV0aWxzID0gZXhwb3J0cztcblxuXHRmdW5jdGlvbiB0b0FycmF5KG1zZywgZW5jKSB7XG5cdCAgaWYgKEFycmF5LmlzQXJyYXkobXNnKSlcblx0ICAgIHJldHVybiBtc2cuc2xpY2UoKTtcblx0ICBpZiAoIW1zZylcblx0ICAgIHJldHVybiBbXTtcblx0ICB2YXIgcmVzID0gW107XG5cdCAgaWYgKHR5cGVvZiBtc2cgIT09ICdzdHJpbmcnKSB7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKylcblx0ICAgICAgcmVzW2ldID0gbXNnW2ldIHwgMDtcblx0ICAgIHJldHVybiByZXM7XG5cdCAgfVxuXHQgIGlmIChlbmMgPT09ICdoZXgnKSB7XG5cdCAgICBtc2cgPSBtc2cucmVwbGFjZSgvW15hLXowLTldKy9pZywgJycpO1xuXHQgICAgaWYgKG1zZy5sZW5ndGggJSAyICE9PSAwKVxuXHQgICAgICBtc2cgPSAnMCcgKyBtc2c7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkgKz0gMilcblx0ICAgICAgcmVzLnB1c2gocGFyc2VJbnQobXNnW2ldICsgbXNnW2kgKyAxXSwgMTYpKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIGMgPSBtc2cuY2hhckNvZGVBdChpKTtcblx0ICAgICAgdmFyIGhpID0gYyA+PiA4O1xuXHQgICAgICB2YXIgbG8gPSBjICYgMHhmZjtcblx0ICAgICAgaWYgKGhpKVxuXHQgICAgICAgIHJlcy5wdXNoKGhpLCBsbyk7XG5cdCAgICAgIGVsc2Vcblx0ICAgICAgICByZXMucHVzaChsbyk7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiByZXM7XG5cdH1cblx0dXRpbHMudG9BcnJheSA9IHRvQXJyYXk7XG5cblx0ZnVuY3Rpb24gemVybzIod29yZCkge1xuXHQgIGlmICh3b3JkLmxlbmd0aCA9PT0gMSlcblx0ICAgIHJldHVybiAnMCcgKyB3b3JkO1xuXHQgIGVsc2Vcblx0ICAgIHJldHVybiB3b3JkO1xuXHR9XG5cdHV0aWxzLnplcm8yID0gemVybzI7XG5cblx0ZnVuY3Rpb24gdG9IZXgobXNnKSB7XG5cdCAgdmFyIHJlcyA9ICcnO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKVxuXHQgICAgcmVzICs9IHplcm8yKG1zZ1tpXS50b1N0cmluZygxNikpO1xuXHQgIHJldHVybiByZXM7XG5cdH1cblx0dXRpbHMudG9IZXggPSB0b0hleDtcblxuXHR1dGlscy5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUoYXJyLCBlbmMpIHtcblx0ICBpZiAoZW5jID09PSAnaGV4Jylcblx0ICAgIHJldHVybiB0b0hleChhcnIpO1xuXHQgIGVsc2Vcblx0ICAgIHJldHVybiBhcnI7XG5cdH07XG5cdH0pO1xuXG5cdHZhciB1dGlsc18xJDEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgdXRpbHMgPSBleHBvcnRzO1xuXG5cblxuXG5cdHV0aWxzLmFzc2VydCA9IG1pbmltYWxpc3RpY0Fzc2VydDtcblx0dXRpbHMudG9BcnJheSA9IHV0aWxzXzEudG9BcnJheTtcblx0dXRpbHMuemVybzIgPSB1dGlsc18xLnplcm8yO1xuXHR1dGlscy50b0hleCA9IHV0aWxzXzEudG9IZXg7XG5cdHV0aWxzLmVuY29kZSA9IHV0aWxzXzEuZW5jb2RlO1xuXG5cdC8vIFJlcHJlc2VudCBudW0gaW4gYSB3LU5BRiBmb3JtXG5cdGZ1bmN0aW9uIGdldE5BRihudW0sIHcsIGJpdHMpIHtcblx0ICB2YXIgbmFmID0gbmV3IEFycmF5KE1hdGgubWF4KG51bS5iaXRMZW5ndGgoKSwgYml0cykgKyAxKTtcblx0ICBuYWYuZmlsbCgwKTtcblxuXHQgIHZhciB3cyA9IDEgPDwgKHcgKyAxKTtcblx0ICB2YXIgayA9IG51bS5jbG9uZSgpO1xuXG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYWYubGVuZ3RoOyBpKyspIHtcblx0ICAgIHZhciB6O1xuXHQgICAgdmFyIG1vZCA9IGsuYW5kbG4od3MgLSAxKTtcblx0ICAgIGlmIChrLmlzT2RkKCkpIHtcblx0ICAgICAgaWYgKG1vZCA+ICh3cyA+PiAxKSAtIDEpXG5cdCAgICAgICAgeiA9ICh3cyA+PiAxKSAtIG1vZDtcblx0ICAgICAgZWxzZVxuXHQgICAgICAgIHogPSBtb2Q7XG5cdCAgICAgIGsuaXN1Ym4oeik7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB6ID0gMDtcblx0ICAgIH1cblxuXHQgICAgbmFmW2ldID0gejtcblx0ICAgIGsuaXVzaHJuKDEpO1xuXHQgIH1cblxuXHQgIHJldHVybiBuYWY7XG5cdH1cblx0dXRpbHMuZ2V0TkFGID0gZ2V0TkFGO1xuXG5cdC8vIFJlcHJlc2VudCBrMSwgazIgaW4gYSBKb2ludCBTcGFyc2UgRm9ybVxuXHRmdW5jdGlvbiBnZXRKU0YoazEsIGsyKSB7XG5cdCAgdmFyIGpzZiA9IFtcblx0ICAgIFtdLFxuXHQgICAgW11cblx0ICBdO1xuXG5cdCAgazEgPSBrMS5jbG9uZSgpO1xuXHQgIGsyID0gazIuY2xvbmUoKTtcblx0ICB2YXIgZDEgPSAwO1xuXHQgIHZhciBkMiA9IDA7XG5cdCAgd2hpbGUgKGsxLmNtcG4oLWQxKSA+IDAgfHwgazIuY21wbigtZDIpID4gMCkge1xuXG5cdCAgICAvLyBGaXJzdCBwaGFzZVxuXHQgICAgdmFyIG0xNCA9IChrMS5hbmRsbigzKSArIGQxKSAmIDM7XG5cdCAgICB2YXIgbTI0ID0gKGsyLmFuZGxuKDMpICsgZDIpICYgMztcblx0ICAgIGlmIChtMTQgPT09IDMpXG5cdCAgICAgIG0xNCA9IC0xO1xuXHQgICAgaWYgKG0yNCA9PT0gMylcblx0ICAgICAgbTI0ID0gLTE7XG5cdCAgICB2YXIgdTE7XG5cdCAgICBpZiAoKG0xNCAmIDEpID09PSAwKSB7XG5cdCAgICAgIHUxID0gMDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHZhciBtOCA9IChrMS5hbmRsbig3KSArIGQxKSAmIDc7XG5cdCAgICAgIGlmICgobTggPT09IDMgfHwgbTggPT09IDUpICYmIG0yNCA9PT0gMilcblx0ICAgICAgICB1MSA9IC1tMTQ7XG5cdCAgICAgIGVsc2Vcblx0ICAgICAgICB1MSA9IG0xNDtcblx0ICAgIH1cblx0ICAgIGpzZlswXS5wdXNoKHUxKTtcblxuXHQgICAgdmFyIHUyO1xuXHQgICAgaWYgKChtMjQgJiAxKSA9PT0gMCkge1xuXHQgICAgICB1MiA9IDA7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB2YXIgbTggPSAoazIuYW5kbG4oNykgKyBkMikgJiA3O1xuXHQgICAgICBpZiAoKG04ID09PSAzIHx8IG04ID09PSA1KSAmJiBtMTQgPT09IDIpXG5cdCAgICAgICAgdTIgPSAtbTI0O1xuXHQgICAgICBlbHNlXG5cdCAgICAgICAgdTIgPSBtMjQ7XG5cdCAgICB9XG5cdCAgICBqc2ZbMV0ucHVzaCh1Mik7XG5cblx0ICAgIC8vIFNlY29uZCBwaGFzZVxuXHQgICAgaWYgKDIgKiBkMSA9PT0gdTEgKyAxKVxuXHQgICAgICBkMSA9IDEgLSBkMTtcblx0ICAgIGlmICgyICogZDIgPT09IHUyICsgMSlcblx0ICAgICAgZDIgPSAxIC0gZDI7XG5cdCAgICBrMS5pdXNocm4oMSk7XG5cdCAgICBrMi5pdXNocm4oMSk7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGpzZjtcblx0fVxuXHR1dGlscy5nZXRKU0YgPSBnZXRKU0Y7XG5cblx0ZnVuY3Rpb24gY2FjaGVkUHJvcGVydHkob2JqLCBuYW1lLCBjb21wdXRlcikge1xuXHQgIHZhciBrZXkgPSAnXycgKyBuYW1lO1xuXHQgIG9iai5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbiBjYWNoZWRQcm9wZXJ0eSgpIHtcblx0ICAgIHJldHVybiB0aGlzW2tleV0gIT09IHVuZGVmaW5lZCA/IHRoaXNba2V5XSA6XG5cdCAgICAgICAgICAgdGhpc1trZXldID0gY29tcHV0ZXIuY2FsbCh0aGlzKTtcblx0ICB9O1xuXHR9XG5cdHV0aWxzLmNhY2hlZFByb3BlcnR5ID0gY2FjaGVkUHJvcGVydHk7XG5cblx0ZnVuY3Rpb24gcGFyc2VCeXRlcyhieXRlcykge1xuXHQgIHJldHVybiB0eXBlb2YgYnl0ZXMgPT09ICdzdHJpbmcnID8gdXRpbHMudG9BcnJheShieXRlcywgJ2hleCcpIDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzO1xuXHR9XG5cdHV0aWxzLnBhcnNlQnl0ZXMgPSBwYXJzZUJ5dGVzO1xuXG5cdGZ1bmN0aW9uIGludEZyb21MRShieXRlcykge1xuXHQgIHJldHVybiBuZXcgYm4kMShieXRlcywgJ2hleCcsICdsZScpO1xuXHR9XG5cdHV0aWxzLmludEZyb21MRSA9IGludEZyb21MRTtcblx0fSk7XG5cblx0dmFyIGJyb3JhbmQgPSBmdW5jdGlvbihsZW5ndGgpIHsgdmFyIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7IChjb21tb25qc0dsb2JhbC5jcnlwdG8gfHwgY29tbW9uanNHbG9iYWwubXNDcnlwdG8pLmdldFJhbmRvbVZhbHVlcyhyZXN1bHQpOyByZXR1cm4gcmVzdWx0OyB9O1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXG5cblx0dmFyIGdldE5BRiA9IHV0aWxzXzEkMS5nZXROQUY7XG5cdHZhciBnZXRKU0YgPSB1dGlsc18xJDEuZ2V0SlNGO1xuXHR2YXIgYXNzZXJ0JDEgPSB1dGlsc18xJDEuYXNzZXJ0O1xuXG5cdGZ1bmN0aW9uIEJhc2VDdXJ2ZSh0eXBlLCBjb25mKSB7XG5cdCAgdGhpcy50eXBlID0gdHlwZTtcblx0ICB0aGlzLnAgPSBuZXcgYm4kMShjb25mLnAsIDE2KTtcblxuXHQgIC8vIFVzZSBNb250Z29tZXJ5LCB3aGVuIHRoZXJlIGlzIG5vIGZhc3QgcmVkdWN0aW9uIGZvciB0aGUgcHJpbWVcblx0ICB0aGlzLnJlZCA9IGNvbmYucHJpbWUgPyBibiQxLnJlZChjb25mLnByaW1lKSA6IGJuJDEubW9udCh0aGlzLnApO1xuXG5cdCAgLy8gVXNlZnVsIGZvciBtYW55IGN1cnZlc1xuXHQgIHRoaXMuemVybyA9IG5ldyBibiQxKDApLnRvUmVkKHRoaXMucmVkKTtcblx0ICB0aGlzLm9uZSA9IG5ldyBibiQxKDEpLnRvUmVkKHRoaXMucmVkKTtcblx0ICB0aGlzLnR3byA9IG5ldyBibiQxKDIpLnRvUmVkKHRoaXMucmVkKTtcblxuXHQgIC8vIEN1cnZlIGNvbmZpZ3VyYXRpb24sIG9wdGlvbmFsXG5cdCAgdGhpcy5uID0gY29uZi5uICYmIG5ldyBibiQxKGNvbmYubiwgMTYpO1xuXHQgIHRoaXMuZyA9IGNvbmYuZyAmJiB0aGlzLnBvaW50RnJvbUpTT04oY29uZi5nLCBjb25mLmdSZWQpO1xuXG5cdCAgLy8gVGVtcG9yYXJ5IGFycmF5c1xuXHQgIHRoaXMuX3duYWZUMSA9IG5ldyBBcnJheSg0KTtcblx0ICB0aGlzLl93bmFmVDIgPSBuZXcgQXJyYXkoNCk7XG5cdCAgdGhpcy5fd25hZlQzID0gbmV3IEFycmF5KDQpO1xuXHQgIHRoaXMuX3duYWZUNCA9IG5ldyBBcnJheSg0KTtcblxuXHQgIHRoaXMuX2JpdExlbmd0aCA9IHRoaXMubiA/IHRoaXMubi5iaXRMZW5ndGgoKSA6IDA7XG5cblx0ICAvLyBHZW5lcmFsaXplZCBHcmVnIE1heHdlbGwncyB0cmlja1xuXHQgIHZhciBhZGp1c3RDb3VudCA9IHRoaXMubiAmJiB0aGlzLnAuZGl2KHRoaXMubik7XG5cdCAgaWYgKCFhZGp1c3RDb3VudCB8fCBhZGp1c3RDb3VudC5jbXBuKDEwMCkgPiAwKSB7XG5cdCAgICB0aGlzLnJlZE4gPSBudWxsO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB0aGlzLl9tYXh3ZWxsVHJpY2sgPSB0cnVlO1xuXHQgICAgdGhpcy5yZWROID0gdGhpcy5uLnRvUmVkKHRoaXMucmVkKTtcblx0ICB9XG5cdH1cblx0dmFyIGJhc2UgPSBCYXNlQ3VydmU7XG5cblx0QmFzZUN1cnZlLnByb3RvdHlwZS5wb2ludCA9IGZ1bmN0aW9uIHBvaW50KCkge1xuXHQgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG5cdH07XG5cblx0QmFzZUN1cnZlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIHZhbGlkYXRlKCkge1xuXHQgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG5cdH07XG5cblx0QmFzZUN1cnZlLnByb3RvdHlwZS5fZml4ZWROYWZNdWwgPSBmdW5jdGlvbiBfZml4ZWROYWZNdWwocCwgaykge1xuXHQgIGFzc2VydCQxKHAucHJlY29tcHV0ZWQpO1xuXHQgIHZhciBkb3VibGVzID0gcC5fZ2V0RG91YmxlcygpO1xuXG5cdCAgdmFyIG5hZiA9IGdldE5BRihrLCAxLCB0aGlzLl9iaXRMZW5ndGgpO1xuXHQgIHZhciBJID0gKDEgPDwgKGRvdWJsZXMuc3RlcCArIDEpKSAtIChkb3VibGVzLnN0ZXAgJSAyID09PSAwID8gMiA6IDEpO1xuXHQgIEkgLz0gMztcblxuXHQgIC8vIFRyYW5zbGF0ZSBpbnRvIG1vcmUgd2luZG93ZWQgZm9ybVxuXHQgIHZhciByZXByID0gW107XG5cdCAgZm9yICh2YXIgaiA9IDA7IGogPCBuYWYubGVuZ3RoOyBqICs9IGRvdWJsZXMuc3RlcCkge1xuXHQgICAgdmFyIG5hZlcgPSAwO1xuXHQgICAgZm9yICh2YXIgayA9IGogKyBkb3VibGVzLnN0ZXAgLSAxOyBrID49IGo7IGstLSlcblx0ICAgICAgbmFmVyA9IChuYWZXIDw8IDEpICsgbmFmW2tdO1xuXHQgICAgcmVwci5wdXNoKG5hZlcpO1xuXHQgIH1cblxuXHQgIHZhciBhID0gdGhpcy5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG5cdCAgdmFyIGIgPSB0aGlzLmpwb2ludChudWxsLCBudWxsLCBudWxsKTtcblx0ICBmb3IgKHZhciBpID0gSTsgaSA+IDA7IGktLSkge1xuXHQgICAgZm9yICh2YXIgaiA9IDA7IGogPCByZXByLmxlbmd0aDsgaisrKSB7XG5cdCAgICAgIHZhciBuYWZXID0gcmVwcltqXTtcblx0ICAgICAgaWYgKG5hZlcgPT09IGkpXG5cdCAgICAgICAgYiA9IGIubWl4ZWRBZGQoZG91Ymxlcy5wb2ludHNbal0pO1xuXHQgICAgICBlbHNlIGlmIChuYWZXID09PSAtaSlcblx0ICAgICAgICBiID0gYi5taXhlZEFkZChkb3VibGVzLnBvaW50c1tqXS5uZWcoKSk7XG5cdCAgICB9XG5cdCAgICBhID0gYS5hZGQoYik7XG5cdCAgfVxuXHQgIHJldHVybiBhLnRvUCgpO1xuXHR9O1xuXG5cdEJhc2VDdXJ2ZS5wcm90b3R5cGUuX3duYWZNdWwgPSBmdW5jdGlvbiBfd25hZk11bChwLCBrKSB7XG5cdCAgdmFyIHcgPSA0O1xuXG5cdCAgLy8gUHJlY29tcHV0ZSB3aW5kb3dcblx0ICB2YXIgbmFmUG9pbnRzID0gcC5fZ2V0TkFGUG9pbnRzKHcpO1xuXHQgIHcgPSBuYWZQb2ludHMud25kO1xuXHQgIHZhciB3bmQgPSBuYWZQb2ludHMucG9pbnRzO1xuXG5cdCAgLy8gR2V0IE5BRiBmb3JtXG5cdCAgdmFyIG5hZiA9IGdldE5BRihrLCB3LCB0aGlzLl9iaXRMZW5ndGgpO1xuXG5cdCAgLy8gQWRkIGB0aGlzYCooTisxKSBmb3IgZXZlcnkgdy1OQUYgaW5kZXhcblx0ICB2YXIgYWNjID0gdGhpcy5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG5cdCAgZm9yICh2YXIgaSA9IG5hZi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHQgICAgLy8gQ291bnQgemVyb2VzXG5cdCAgICBmb3IgKHZhciBrID0gMDsgaSA+PSAwICYmIG5hZltpXSA9PT0gMDsgaS0tKVxuXHQgICAgICBrKys7XG5cdCAgICBpZiAoaSA+PSAwKVxuXHQgICAgICBrKys7XG5cdCAgICBhY2MgPSBhY2MuZGJscChrKTtcblxuXHQgICAgaWYgKGkgPCAwKVxuXHQgICAgICBicmVhaztcblx0ICAgIHZhciB6ID0gbmFmW2ldO1xuXHQgICAgYXNzZXJ0JDEoeiAhPT0gMCk7XG5cdCAgICBpZiAocC50eXBlID09PSAnYWZmaW5lJykge1xuXHQgICAgICAvLyBKICstIFBcblx0ICAgICAgaWYgKHogPiAwKVxuXHQgICAgICAgIGFjYyA9IGFjYy5taXhlZEFkZCh3bmRbKHogLSAxKSA+PiAxXSk7XG5cdCAgICAgIGVsc2Vcblx0ICAgICAgICBhY2MgPSBhY2MubWl4ZWRBZGQod25kWygteiAtIDEpID4+IDFdLm5lZygpKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIC8vIEogKy0gSlxuXHQgICAgICBpZiAoeiA+IDApXG5cdCAgICAgICAgYWNjID0gYWNjLmFkZCh3bmRbKHogLSAxKSA+PiAxXSk7XG5cdCAgICAgIGVsc2Vcblx0ICAgICAgICBhY2MgPSBhY2MuYWRkKHduZFsoLXogLSAxKSA+PiAxXS5uZWcoKSk7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiBwLnR5cGUgPT09ICdhZmZpbmUnID8gYWNjLnRvUCgpIDogYWNjO1xuXHR9O1xuXG5cdEJhc2VDdXJ2ZS5wcm90b3R5cGUuX3duYWZNdWxBZGQgPSBmdW5jdGlvbiBfd25hZk11bEFkZChkZWZXLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29lZmZzLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgamFjb2JpYW5SZXN1bHQpIHtcblx0ICB2YXIgd25kV2lkdGggPSB0aGlzLl93bmFmVDE7XG5cdCAgdmFyIHduZCA9IHRoaXMuX3duYWZUMjtcblx0ICB2YXIgbmFmID0gdGhpcy5fd25hZlQzO1xuXG5cdCAgLy8gRmlsbCBhbGwgYXJyYXlzXG5cdCAgdmFyIG1heCA9IDA7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHQgICAgdmFyIHAgPSBwb2ludHNbaV07XG5cdCAgICB2YXIgbmFmUG9pbnRzID0gcC5fZ2V0TkFGUG9pbnRzKGRlZlcpO1xuXHQgICAgd25kV2lkdGhbaV0gPSBuYWZQb2ludHMud25kO1xuXHQgICAgd25kW2ldID0gbmFmUG9pbnRzLnBvaW50cztcblx0ICB9XG5cblx0ICAvLyBDb21iIHNtYWxsIHdpbmRvdyBOQUZzXG5cdCAgZm9yICh2YXIgaSA9IGxlbiAtIDE7IGkgPj0gMTsgaSAtPSAyKSB7XG5cdCAgICB2YXIgYSA9IGkgLSAxO1xuXHQgICAgdmFyIGIgPSBpO1xuXHQgICAgaWYgKHduZFdpZHRoW2FdICE9PSAxIHx8IHduZFdpZHRoW2JdICE9PSAxKSB7XG5cdCAgICAgIG5hZlthXSA9IGdldE5BRihjb2VmZnNbYV0sIHduZFdpZHRoW2FdLCB0aGlzLl9iaXRMZW5ndGgpO1xuXHQgICAgICBuYWZbYl0gPSBnZXROQUYoY29lZmZzW2JdLCB3bmRXaWR0aFtiXSwgdGhpcy5fYml0TGVuZ3RoKTtcblx0ICAgICAgbWF4ID0gTWF0aC5tYXgobmFmW2FdLmxlbmd0aCwgbWF4KTtcblx0ICAgICAgbWF4ID0gTWF0aC5tYXgobmFmW2JdLmxlbmd0aCwgbWF4KTtcblx0ICAgICAgY29udGludWU7XG5cdCAgICB9XG5cblx0ICAgIHZhciBjb21iID0gW1xuXHQgICAgICBwb2ludHNbYV0sIC8qIDEgKi9cblx0ICAgICAgbnVsbCwgLyogMyAqL1xuXHQgICAgICBudWxsLCAvKiA1ICovXG5cdCAgICAgIHBvaW50c1tiXSAvKiA3ICovXG5cdCAgICBdO1xuXG5cdCAgICAvLyBUcnkgdG8gYXZvaWQgUHJvamVjdGl2ZSBwb2ludHMsIGlmIHBvc3NpYmxlXG5cdCAgICBpZiAocG9pbnRzW2FdLnkuY21wKHBvaW50c1tiXS55KSA9PT0gMCkge1xuXHQgICAgICBjb21iWzFdID0gcG9pbnRzW2FdLmFkZChwb2ludHNbYl0pO1xuXHQgICAgICBjb21iWzJdID0gcG9pbnRzW2FdLnRvSigpLm1peGVkQWRkKHBvaW50c1tiXS5uZWcoKSk7XG5cdCAgICB9IGVsc2UgaWYgKHBvaW50c1thXS55LmNtcChwb2ludHNbYl0ueS5yZWROZWcoKSkgPT09IDApIHtcblx0ICAgICAgY29tYlsxXSA9IHBvaW50c1thXS50b0ooKS5taXhlZEFkZChwb2ludHNbYl0pO1xuXHQgICAgICBjb21iWzJdID0gcG9pbnRzW2FdLmFkZChwb2ludHNbYl0ubmVnKCkpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgY29tYlsxXSA9IHBvaW50c1thXS50b0ooKS5taXhlZEFkZChwb2ludHNbYl0pO1xuXHQgICAgICBjb21iWzJdID0gcG9pbnRzW2FdLnRvSigpLm1peGVkQWRkKHBvaW50c1tiXS5uZWcoKSk7XG5cdCAgICB9XG5cblx0ICAgIHZhciBpbmRleCA9IFtcblx0ICAgICAgLTMsIC8qIC0xIC0xICovXG5cdCAgICAgIC0xLCAvKiAtMSAwICovXG5cdCAgICAgIC01LCAvKiAtMSAxICovXG5cdCAgICAgIC03LCAvKiAwIC0xICovXG5cdCAgICAgIDAsIC8qIDAgMCAqL1xuXHQgICAgICA3LCAvKiAwIDEgKi9cblx0ICAgICAgNSwgLyogMSAtMSAqL1xuXHQgICAgICAxLCAvKiAxIDAgKi9cblx0ICAgICAgMyAgLyogMSAxICovXG5cdCAgICBdO1xuXG5cdCAgICB2YXIganNmID0gZ2V0SlNGKGNvZWZmc1thXSwgY29lZmZzW2JdKTtcblx0ICAgIG1heCA9IE1hdGgubWF4KGpzZlswXS5sZW5ndGgsIG1heCk7XG5cdCAgICBuYWZbYV0gPSBuZXcgQXJyYXkobWF4KTtcblx0ICAgIG5hZltiXSA9IG5ldyBBcnJheShtYXgpO1xuXHQgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtYXg7IGorKykge1xuXHQgICAgICB2YXIgamEgPSBqc2ZbMF1bal0gfCAwO1xuXHQgICAgICB2YXIgamIgPSBqc2ZbMV1bal0gfCAwO1xuXG5cdCAgICAgIG5hZlthXVtqXSA9IGluZGV4WyhqYSArIDEpICogMyArIChqYiArIDEpXTtcblx0ICAgICAgbmFmW2JdW2pdID0gMDtcblx0ICAgICAgd25kW2FdID0gY29tYjtcblx0ICAgIH1cblx0ICB9XG5cblx0ICB2YXIgYWNjID0gdGhpcy5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG5cdCAgdmFyIHRtcCA9IHRoaXMuX3duYWZUNDtcblx0ICBmb3IgKHZhciBpID0gbWF4OyBpID49IDA7IGktLSkge1xuXHQgICAgdmFyIGsgPSAwO1xuXG5cdCAgICB3aGlsZSAoaSA+PSAwKSB7XG5cdCAgICAgIHZhciB6ZXJvID0gdHJ1ZTtcblx0ICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW47IGorKykge1xuXHQgICAgICAgIHRtcFtqXSA9IG5hZltqXVtpXSB8IDA7XG5cdCAgICAgICAgaWYgKHRtcFtqXSAhPT0gMClcblx0ICAgICAgICAgIHplcm8gPSBmYWxzZTtcblx0ICAgICAgfVxuXHQgICAgICBpZiAoIXplcm8pXG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICAgIGsrKztcblx0ICAgICAgaS0tO1xuXHQgICAgfVxuXHQgICAgaWYgKGkgPj0gMClcblx0ICAgICAgaysrO1xuXHQgICAgYWNjID0gYWNjLmRibHAoayk7XG5cdCAgICBpZiAoaSA8IDApXG5cdCAgICAgIGJyZWFrO1xuXG5cdCAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbjsgaisrKSB7XG5cdCAgICAgIHZhciB6ID0gdG1wW2pdO1xuXHQgICAgICB2YXIgcDtcblx0ICAgICAgaWYgKHogPT09IDApXG5cdCAgICAgICAgY29udGludWU7XG5cdCAgICAgIGVsc2UgaWYgKHogPiAwKVxuXHQgICAgICAgIHAgPSB3bmRbal1bKHogLSAxKSA+PiAxXTtcblx0ICAgICAgZWxzZSBpZiAoeiA8IDApXG5cdCAgICAgICAgcCA9IHduZFtqXVsoLXogLSAxKSA+PiAxXS5uZWcoKTtcblxuXHQgICAgICBpZiAocC50eXBlID09PSAnYWZmaW5lJylcblx0ICAgICAgICBhY2MgPSBhY2MubWl4ZWRBZGQocCk7XG5cdCAgICAgIGVsc2Vcblx0ICAgICAgICBhY2MgPSBhY2MuYWRkKHApO1xuXHQgICAgfVxuXHQgIH1cblx0ICAvLyBaZXJvaWZ5IHJlZmVyZW5jZXNcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKVxuXHQgICAgd25kW2ldID0gbnVsbDtcblxuXHQgIGlmIChqYWNvYmlhblJlc3VsdClcblx0ICAgIHJldHVybiBhY2M7XG5cdCAgZWxzZVxuXHQgICAgcmV0dXJuIGFjYy50b1AoKTtcblx0fTtcblxuXHRmdW5jdGlvbiBCYXNlUG9pbnQoY3VydmUsIHR5cGUpIHtcblx0ICB0aGlzLmN1cnZlID0gY3VydmU7XG5cdCAgdGhpcy50eXBlID0gdHlwZTtcblx0ICB0aGlzLnByZWNvbXB1dGVkID0gbnVsbDtcblx0fVxuXHRCYXNlQ3VydmUuQmFzZVBvaW50ID0gQmFzZVBvaW50O1xuXG5cdEJhc2VQb2ludC5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbiBlcSgvKm90aGVyKi8pIHtcblx0ICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xuXHR9O1xuXG5cdEJhc2VQb2ludC5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZSgpIHtcblx0ICByZXR1cm4gdGhpcy5jdXJ2ZS52YWxpZGF0ZSh0aGlzKTtcblx0fTtcblxuXHRCYXNlQ3VydmUucHJvdG90eXBlLmRlY29kZVBvaW50ID0gZnVuY3Rpb24gZGVjb2RlUG9pbnQoYnl0ZXMsIGVuYykge1xuXHQgIGJ5dGVzID0gdXRpbHNfMSQxLnRvQXJyYXkoYnl0ZXMsIGVuYyk7XG5cblx0ICB2YXIgbGVuID0gdGhpcy5wLmJ5dGVMZW5ndGgoKTtcblxuXHQgIC8vIHVuY29tcHJlc3NlZCwgaHlicmlkLW9kZCwgaHlicmlkLWV2ZW5cblx0ICBpZiAoKGJ5dGVzWzBdID09PSAweDA0IHx8IGJ5dGVzWzBdID09PSAweDA2IHx8IGJ5dGVzWzBdID09PSAweDA3KSAmJlxuXHQgICAgICBieXRlcy5sZW5ndGggLSAxID09PSAyICogbGVuKSB7XG5cdCAgICBpZiAoYnl0ZXNbMF0gPT09IDB4MDYpXG5cdCAgICAgIGFzc2VydCQxKGJ5dGVzW2J5dGVzLmxlbmd0aCAtIDFdICUgMiA9PT0gMCk7XG5cdCAgICBlbHNlIGlmIChieXRlc1swXSA9PT0gMHgwNylcblx0ICAgICAgYXNzZXJ0JDEoYnl0ZXNbYnl0ZXMubGVuZ3RoIC0gMV0gJSAyID09PSAxKTtcblxuXHQgICAgdmFyIHJlcyA9ICB0aGlzLnBvaW50KGJ5dGVzLnNsaWNlKDEsIDEgKyBsZW4pLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzLnNsaWNlKDEgKyBsZW4sIDEgKyAyICogbGVuKSk7XG5cblx0ICAgIHJldHVybiByZXM7XG5cdCAgfSBlbHNlIGlmICgoYnl0ZXNbMF0gPT09IDB4MDIgfHwgYnl0ZXNbMF0gPT09IDB4MDMpICYmXG5cdCAgICAgICAgICAgICAgYnl0ZXMubGVuZ3RoIC0gMSA9PT0gbGVuKSB7XG5cdCAgICByZXR1cm4gdGhpcy5wb2ludEZyb21YKGJ5dGVzLnNsaWNlKDEsIDEgKyBsZW4pLCBieXRlc1swXSA9PT0gMHgwMyk7XG5cdCAgfVxuXHQgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBwb2ludCBmb3JtYXQnKTtcblx0fTtcblxuXHRCYXNlUG9pbnQucHJvdG90eXBlLmVuY29kZUNvbXByZXNzZWQgPSBmdW5jdGlvbiBlbmNvZGVDb21wcmVzc2VkKGVuYykge1xuXHQgIHJldHVybiB0aGlzLmVuY29kZShlbmMsIHRydWUpO1xuXHR9O1xuXG5cdEJhc2VQb2ludC5wcm90b3R5cGUuX2VuY29kZSA9IGZ1bmN0aW9uIF9lbmNvZGUoY29tcGFjdCkge1xuXHQgIHZhciBsZW4gPSB0aGlzLmN1cnZlLnAuYnl0ZUxlbmd0aCgpO1xuXHQgIHZhciB4ID0gdGhpcy5nZXRYKCkudG9BcnJheSgnYmUnLCBsZW4pO1xuXG5cdCAgaWYgKGNvbXBhY3QpXG5cdCAgICByZXR1cm4gWyB0aGlzLmdldFkoKS5pc0V2ZW4oKSA/IDB4MDIgOiAweDAzIF0uY29uY2F0KHgpO1xuXG5cdCAgcmV0dXJuIFsgMHgwNCBdLmNvbmNhdCh4LCB0aGlzLmdldFkoKS50b0FycmF5KCdiZScsIGxlbikpIDtcblx0fTtcblxuXHRCYXNlUG9pbnQucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShlbmMsIGNvbXBhY3QpIHtcblx0ICByZXR1cm4gdXRpbHNfMSQxLmVuY29kZSh0aGlzLl9lbmNvZGUoY29tcGFjdCksIGVuYyk7XG5cdH07XG5cblx0QmFzZVBvaW50LnByb3RvdHlwZS5wcmVjb21wdXRlID0gZnVuY3Rpb24gcHJlY29tcHV0ZShwb3dlcikge1xuXHQgIGlmICh0aGlzLnByZWNvbXB1dGVkKVxuXHQgICAgcmV0dXJuIHRoaXM7XG5cblx0ICB2YXIgcHJlY29tcHV0ZWQgPSB7XG5cdCAgICBkb3VibGVzOiBudWxsLFxuXHQgICAgbmFmOiBudWxsLFxuXHQgICAgYmV0YTogbnVsbFxuXHQgIH07XG5cdCAgcHJlY29tcHV0ZWQubmFmID0gdGhpcy5fZ2V0TkFGUG9pbnRzKDgpO1xuXHQgIHByZWNvbXB1dGVkLmRvdWJsZXMgPSB0aGlzLl9nZXREb3VibGVzKDQsIHBvd2VyKTtcblx0ICBwcmVjb21wdXRlZC5iZXRhID0gdGhpcy5fZ2V0QmV0YSgpO1xuXHQgIHRoaXMucHJlY29tcHV0ZWQgPSBwcmVjb21wdXRlZDtcblxuXHQgIHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdEJhc2VQb2ludC5wcm90b3R5cGUuX2hhc0RvdWJsZXMgPSBmdW5jdGlvbiBfaGFzRG91YmxlcyhrKSB7XG5cdCAgaWYgKCF0aGlzLnByZWNvbXB1dGVkKVxuXHQgICAgcmV0dXJuIGZhbHNlO1xuXG5cdCAgdmFyIGRvdWJsZXMgPSB0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXM7XG5cdCAgaWYgKCFkb3VibGVzKVxuXHQgICAgcmV0dXJuIGZhbHNlO1xuXG5cdCAgcmV0dXJuIGRvdWJsZXMucG9pbnRzLmxlbmd0aCA+PSBNYXRoLmNlaWwoKGsuYml0TGVuZ3RoKCkgKyAxKSAvIGRvdWJsZXMuc3RlcCk7XG5cdH07XG5cblx0QmFzZVBvaW50LnByb3RvdHlwZS5fZ2V0RG91YmxlcyA9IGZ1bmN0aW9uIF9nZXREb3VibGVzKHN0ZXAsIHBvd2VyKSB7XG5cdCAgaWYgKHRoaXMucHJlY29tcHV0ZWQgJiYgdGhpcy5wcmVjb21wdXRlZC5kb3VibGVzKVxuXHQgICAgcmV0dXJuIHRoaXMucHJlY29tcHV0ZWQuZG91YmxlcztcblxuXHQgIHZhciBkb3VibGVzID0gWyB0aGlzIF07XG5cdCAgdmFyIGFjYyA9IHRoaXM7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb3dlcjsgaSArPSBzdGVwKSB7XG5cdCAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN0ZXA7IGorKylcblx0ICAgICAgYWNjID0gYWNjLmRibCgpO1xuXHQgICAgZG91Ymxlcy5wdXNoKGFjYyk7XG5cdCAgfVxuXHQgIHJldHVybiB7XG5cdCAgICBzdGVwOiBzdGVwLFxuXHQgICAgcG9pbnRzOiBkb3VibGVzXG5cdCAgfTtcblx0fTtcblxuXHRCYXNlUG9pbnQucHJvdG90eXBlLl9nZXROQUZQb2ludHMgPSBmdW5jdGlvbiBfZ2V0TkFGUG9pbnRzKHduZCkge1xuXHQgIGlmICh0aGlzLnByZWNvbXB1dGVkICYmIHRoaXMucHJlY29tcHV0ZWQubmFmKVxuXHQgICAgcmV0dXJuIHRoaXMucHJlY29tcHV0ZWQubmFmO1xuXG5cdCAgdmFyIHJlcyA9IFsgdGhpcyBdO1xuXHQgIHZhciBtYXggPSAoMSA8PCB3bmQpIC0gMTtcblx0ICB2YXIgZGJsID0gbWF4ID09PSAxID8gbnVsbCA6IHRoaXMuZGJsKCk7XG5cdCAgZm9yICh2YXIgaSA9IDE7IGkgPCBtYXg7IGkrKylcblx0ICAgIHJlc1tpXSA9IHJlc1tpIC0gMV0uYWRkKGRibCk7XG5cdCAgcmV0dXJuIHtcblx0ICAgIHduZDogd25kLFxuXHQgICAgcG9pbnRzOiByZXNcblx0ICB9O1xuXHR9O1xuXG5cdEJhc2VQb2ludC5wcm90b3R5cGUuX2dldEJldGEgPSBmdW5jdGlvbiBfZ2V0QmV0YSgpIHtcblx0ICByZXR1cm4gbnVsbDtcblx0fTtcblxuXHRCYXNlUG9pbnQucHJvdG90eXBlLmRibHAgPSBmdW5jdGlvbiBkYmxwKGspIHtcblx0ICB2YXIgciA9IHRoaXM7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBrOyBpKyspXG5cdCAgICByID0gci5kYmwoKTtcblx0ICByZXR1cm4gcjtcblx0fTtcblxuXHQndXNlIHN0cmljdCc7XG5cblxuXG5cblxuXG5cdHZhciBhc3NlcnQkMiA9IHV0aWxzXzEkMS5hc3NlcnQ7XG5cblx0ZnVuY3Rpb24gU2hvcnRDdXJ2ZShjb25mKSB7XG5cdCAgYmFzZS5jYWxsKHRoaXMsICdzaG9ydCcsIGNvbmYpO1xuXG5cdCAgdGhpcy5hID0gbmV3IGJuJDEoY29uZi5hLCAxNikudG9SZWQodGhpcy5yZWQpO1xuXHQgIHRoaXMuYiA9IG5ldyBibiQxKGNvbmYuYiwgMTYpLnRvUmVkKHRoaXMucmVkKTtcblx0ICB0aGlzLnRpbnYgPSB0aGlzLnR3by5yZWRJbnZtKCk7XG5cblx0ICB0aGlzLnplcm9BID0gdGhpcy5hLmZyb21SZWQoKS5jbXBuKDApID09PSAwO1xuXHQgIHRoaXMudGhyZWVBID0gdGhpcy5hLmZyb21SZWQoKS5zdWIodGhpcy5wKS5jbXBuKC0zKSA9PT0gMDtcblxuXHQgIC8vIElmIHRoZSBjdXJ2ZSBpcyBlbmRvbW9ycGhpYywgcHJlY2FsY3VsYXRlIGJldGEgYW5kIGxhbWJkYVxuXHQgIHRoaXMuZW5kbyA9IHRoaXMuX2dldEVuZG9tb3JwaGlzbShjb25mKTtcblx0ICB0aGlzLl9lbmRvV25hZlQxID0gbmV3IEFycmF5KDQpO1xuXHQgIHRoaXMuX2VuZG9XbmFmVDIgPSBuZXcgQXJyYXkoNCk7XG5cdH1cblx0aW5oZXJpdHNfYnJvd3NlcihTaG9ydEN1cnZlLCBiYXNlKTtcblx0dmFyIHNob3J0XzEgPSBTaG9ydEN1cnZlO1xuXG5cdFNob3J0Q3VydmUucHJvdG90eXBlLl9nZXRFbmRvbW9ycGhpc20gPSBmdW5jdGlvbiBfZ2V0RW5kb21vcnBoaXNtKGNvbmYpIHtcblx0ICAvLyBObyBlZmZpY2llbnQgZW5kb21vcnBoaXNtXG5cdCAgaWYgKCF0aGlzLnplcm9BIHx8ICF0aGlzLmcgfHwgIXRoaXMubiB8fCB0aGlzLnAubW9kbigzKSAhPT0gMSlcblx0ICAgIHJldHVybjtcblxuXHQgIC8vIENvbXB1dGUgYmV0YSBhbmQgbGFtYmRhLCB0aGF0IGxhbWJkYSAqIFAgPSAoYmV0YSAqIFB4OyBQeSlcblx0ICB2YXIgYmV0YTtcblx0ICB2YXIgbGFtYmRhO1xuXHQgIGlmIChjb25mLmJldGEpIHtcblx0ICAgIGJldGEgPSBuZXcgYm4kMShjb25mLmJldGEsIDE2KS50b1JlZCh0aGlzLnJlZCk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHZhciBiZXRhcyA9IHRoaXMuX2dldEVuZG9Sb290cyh0aGlzLnApO1xuXHQgICAgLy8gQ2hvb3NlIHRoZSBzbWFsbGVzdCBiZXRhXG5cdCAgICBiZXRhID0gYmV0YXNbMF0uY21wKGJldGFzWzFdKSA8IDAgPyBiZXRhc1swXSA6IGJldGFzWzFdO1xuXHQgICAgYmV0YSA9IGJldGEudG9SZWQodGhpcy5yZWQpO1xuXHQgIH1cblx0ICBpZiAoY29uZi5sYW1iZGEpIHtcblx0ICAgIGxhbWJkYSA9IG5ldyBibiQxKGNvbmYubGFtYmRhLCAxNik7XG5cdCAgfSBlbHNlIHtcblx0ICAgIC8vIENob29zZSB0aGUgbGFtYmRhIHRoYXQgaXMgbWF0Y2hpbmcgc2VsZWN0ZWQgYmV0YVxuXHQgICAgdmFyIGxhbWJkYXMgPSB0aGlzLl9nZXRFbmRvUm9vdHModGhpcy5uKTtcblx0ICAgIGlmICh0aGlzLmcubXVsKGxhbWJkYXNbMF0pLnguY21wKHRoaXMuZy54LnJlZE11bChiZXRhKSkgPT09IDApIHtcblx0ICAgICAgbGFtYmRhID0gbGFtYmRhc1swXTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGxhbWJkYSA9IGxhbWJkYXNbMV07XG5cdCAgICAgIGFzc2VydCQyKHRoaXMuZy5tdWwobGFtYmRhKS54LmNtcCh0aGlzLmcueC5yZWRNdWwoYmV0YSkpID09PSAwKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICAvLyBHZXQgYmFzaXMgdmVjdG9ycywgdXNlZCBmb3IgYmFsYW5jZWQgbGVuZ3RoLXR3byByZXByZXNlbnRhdGlvblxuXHQgIHZhciBiYXNpcztcblx0ICBpZiAoY29uZi5iYXNpcykge1xuXHQgICAgYmFzaXMgPSBjb25mLmJhc2lzLm1hcChmdW5jdGlvbih2ZWMpIHtcblx0ICAgICAgcmV0dXJuIHtcblx0ICAgICAgICBhOiBuZXcgYm4kMSh2ZWMuYSwgMTYpLFxuXHQgICAgICAgIGI6IG5ldyBibiQxKHZlYy5iLCAxNilcblx0ICAgICAgfTtcblx0ICAgIH0pO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBiYXNpcyA9IHRoaXMuX2dldEVuZG9CYXNpcyhsYW1iZGEpO1xuXHQgIH1cblxuXHQgIHJldHVybiB7XG5cdCAgICBiZXRhOiBiZXRhLFxuXHQgICAgbGFtYmRhOiBsYW1iZGEsXG5cdCAgICBiYXNpczogYmFzaXNcblx0ICB9O1xuXHR9O1xuXG5cdFNob3J0Q3VydmUucHJvdG90eXBlLl9nZXRFbmRvUm9vdHMgPSBmdW5jdGlvbiBfZ2V0RW5kb1Jvb3RzKG51bSkge1xuXHQgIC8vIEZpbmQgcm9vdHMgb2YgZm9yIHheMiArIHggKyAxIGluIEZcblx0ICAvLyBSb290ID0gKC0xICstIFNxcnQoLTMpKSAvIDJcblx0ICAvL1xuXHQgIHZhciByZWQgPSBudW0gPT09IHRoaXMucCA/IHRoaXMucmVkIDogYm4kMS5tb250KG51bSk7XG5cdCAgdmFyIHRpbnYgPSBuZXcgYm4kMSgyKS50b1JlZChyZWQpLnJlZEludm0oKTtcblx0ICB2YXIgbnRpbnYgPSB0aW52LnJlZE5lZygpO1xuXG5cdCAgdmFyIHMgPSBuZXcgYm4kMSgzKS50b1JlZChyZWQpLnJlZE5lZygpLnJlZFNxcnQoKS5yZWRNdWwodGludik7XG5cblx0ICB2YXIgbDEgPSBudGludi5yZWRBZGQocykuZnJvbVJlZCgpO1xuXHQgIHZhciBsMiA9IG50aW52LnJlZFN1YihzKS5mcm9tUmVkKCk7XG5cdCAgcmV0dXJuIFsgbDEsIGwyIF07XG5cdH07XG5cblx0U2hvcnRDdXJ2ZS5wcm90b3R5cGUuX2dldEVuZG9CYXNpcyA9IGZ1bmN0aW9uIF9nZXRFbmRvQmFzaXMobGFtYmRhKSB7XG5cdCAgLy8gYXByeFNxcnQgPj0gc3FydCh0aGlzLm4pXG5cdCAgdmFyIGFwcnhTcXJ0ID0gdGhpcy5uLnVzaHJuKE1hdGguZmxvb3IodGhpcy5uLmJpdExlbmd0aCgpIC8gMikpO1xuXG5cdCAgLy8gMy43NFxuXHQgIC8vIFJ1biBFR0NELCB1bnRpbCByKEwgKyAxKSA8IGFwcnhTcXJ0XG5cdCAgdmFyIHUgPSBsYW1iZGE7XG5cdCAgdmFyIHYgPSB0aGlzLm4uY2xvbmUoKTtcblx0ICB2YXIgeDEgPSBuZXcgYm4kMSgxKTtcblx0ICB2YXIgeTEgPSBuZXcgYm4kMSgwKTtcblx0ICB2YXIgeDIgPSBuZXcgYm4kMSgwKTtcblx0ICB2YXIgeTIgPSBuZXcgYm4kMSgxKTtcblxuXHQgIC8vIE5PVEU6IGFsbCB2ZWN0b3JzIGFyZSByb290cyBvZjogYSArIGIgKiBsYW1iZGEgPSAwIChtb2Qgbilcblx0ICB2YXIgYTA7XG5cdCAgdmFyIGIwO1xuXHQgIC8vIEZpcnN0IHZlY3RvclxuXHQgIHZhciBhMTtcblx0ICB2YXIgYjE7XG5cdCAgLy8gU2Vjb25kIHZlY3RvclxuXHQgIHZhciBhMjtcblx0ICB2YXIgYjI7XG5cblx0ICB2YXIgcHJldlI7XG5cdCAgdmFyIGkgPSAwO1xuXHQgIHZhciByO1xuXHQgIHZhciB4O1xuXHQgIHdoaWxlICh1LmNtcG4oMCkgIT09IDApIHtcblx0ICAgIHZhciBxID0gdi5kaXYodSk7XG5cdCAgICByID0gdi5zdWIocS5tdWwodSkpO1xuXHQgICAgeCA9IHgyLnN1YihxLm11bCh4MSkpO1xuXHQgICAgdmFyIHkgPSB5Mi5zdWIocS5tdWwoeTEpKTtcblxuXHQgICAgaWYgKCFhMSAmJiByLmNtcChhcHJ4U3FydCkgPCAwKSB7XG5cdCAgICAgIGEwID0gcHJldlIubmVnKCk7XG5cdCAgICAgIGIwID0geDE7XG5cdCAgICAgIGExID0gci5uZWcoKTtcblx0ICAgICAgYjEgPSB4O1xuXHQgICAgfSBlbHNlIGlmIChhMSAmJiArK2kgPT09IDIpIHtcblx0ICAgICAgYnJlYWs7XG5cdCAgICB9XG5cdCAgICBwcmV2UiA9IHI7XG5cblx0ICAgIHYgPSB1O1xuXHQgICAgdSA9IHI7XG5cdCAgICB4MiA9IHgxO1xuXHQgICAgeDEgPSB4O1xuXHQgICAgeTIgPSB5MTtcblx0ICAgIHkxID0geTtcblx0ICB9XG5cdCAgYTIgPSByLm5lZygpO1xuXHQgIGIyID0geDtcblxuXHQgIHZhciBsZW4xID0gYTEuc3FyKCkuYWRkKGIxLnNxcigpKTtcblx0ICB2YXIgbGVuMiA9IGEyLnNxcigpLmFkZChiMi5zcXIoKSk7XG5cdCAgaWYgKGxlbjIuY21wKGxlbjEpID49IDApIHtcblx0ICAgIGEyID0gYTA7XG5cdCAgICBiMiA9IGIwO1xuXHQgIH1cblxuXHQgIC8vIE5vcm1hbGl6ZSBzaWduc1xuXHQgIGlmIChhMS5uZWdhdGl2ZSkge1xuXHQgICAgYTEgPSBhMS5uZWcoKTtcblx0ICAgIGIxID0gYjEubmVnKCk7XG5cdCAgfVxuXHQgIGlmIChhMi5uZWdhdGl2ZSkge1xuXHQgICAgYTIgPSBhMi5uZWcoKTtcblx0ICAgIGIyID0gYjIubmVnKCk7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIFtcblx0ICAgIHsgYTogYTEsIGI6IGIxIH0sXG5cdCAgICB7IGE6IGEyLCBiOiBiMiB9XG5cdCAgXTtcblx0fTtcblxuXHRTaG9ydEN1cnZlLnByb3RvdHlwZS5fZW5kb1NwbGl0ID0gZnVuY3Rpb24gX2VuZG9TcGxpdChrKSB7XG5cdCAgdmFyIGJhc2lzID0gdGhpcy5lbmRvLmJhc2lzO1xuXHQgIHZhciB2MSA9IGJhc2lzWzBdO1xuXHQgIHZhciB2MiA9IGJhc2lzWzFdO1xuXG5cdCAgdmFyIGMxID0gdjIuYi5tdWwoaykuZGl2Um91bmQodGhpcy5uKTtcblx0ICB2YXIgYzIgPSB2MS5iLm5lZygpLm11bChrKS5kaXZSb3VuZCh0aGlzLm4pO1xuXG5cdCAgdmFyIHAxID0gYzEubXVsKHYxLmEpO1xuXHQgIHZhciBwMiA9IGMyLm11bCh2Mi5hKTtcblx0ICB2YXIgcTEgPSBjMS5tdWwodjEuYik7XG5cdCAgdmFyIHEyID0gYzIubXVsKHYyLmIpO1xuXG5cdCAgLy8gQ2FsY3VsYXRlIGFuc3dlclxuXHQgIHZhciBrMSA9IGsuc3ViKHAxKS5zdWIocDIpO1xuXHQgIHZhciBrMiA9IHExLmFkZChxMikubmVnKCk7XG5cdCAgcmV0dXJuIHsgazE6IGsxLCBrMjogazIgfTtcblx0fTtcblxuXHRTaG9ydEN1cnZlLnByb3RvdHlwZS5wb2ludEZyb21YID0gZnVuY3Rpb24gcG9pbnRGcm9tWCh4LCBvZGQpIHtcblx0ICB4ID0gbmV3IGJuJDEoeCwgMTYpO1xuXHQgIGlmICgheC5yZWQpXG5cdCAgICB4ID0geC50b1JlZCh0aGlzLnJlZCk7XG5cblx0ICB2YXIgeTIgPSB4LnJlZFNxcigpLnJlZE11bCh4KS5yZWRJQWRkKHgucmVkTXVsKHRoaXMuYSkpLnJlZElBZGQodGhpcy5iKTtcblx0ICB2YXIgeSA9IHkyLnJlZFNxcnQoKTtcblx0ICBpZiAoeS5yZWRTcXIoKS5yZWRTdWIoeTIpLmNtcCh0aGlzLnplcm8pICE9PSAwKVxuXHQgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHBvaW50Jyk7XG5cblx0ICAvLyBYWFggSXMgdGhlcmUgYW55IHdheSB0byB0ZWxsIGlmIHRoZSBudW1iZXIgaXMgb2RkIHdpdGhvdXQgY29udmVydGluZyBpdFxuXHQgIC8vIHRvIG5vbi1yZWQgZm9ybT9cblx0ICB2YXIgaXNPZGQgPSB5LmZyb21SZWQoKS5pc09kZCgpO1xuXHQgIGlmIChvZGQgJiYgIWlzT2RkIHx8ICFvZGQgJiYgaXNPZGQpXG5cdCAgICB5ID0geS5yZWROZWcoKTtcblxuXHQgIHJldHVybiB0aGlzLnBvaW50KHgsIHkpO1xuXHR9O1xuXG5cdFNob3J0Q3VydmUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gdmFsaWRhdGUocG9pbnQpIHtcblx0ICBpZiAocG9pbnQuaW5mKVxuXHQgICAgcmV0dXJuIHRydWU7XG5cblx0ICB2YXIgeCA9IHBvaW50Lng7XG5cdCAgdmFyIHkgPSBwb2ludC55O1xuXG5cdCAgdmFyIGF4ID0gdGhpcy5hLnJlZE11bCh4KTtcblx0ICB2YXIgcmhzID0geC5yZWRTcXIoKS5yZWRNdWwoeCkucmVkSUFkZChheCkucmVkSUFkZCh0aGlzLmIpO1xuXHQgIHJldHVybiB5LnJlZFNxcigpLnJlZElTdWIocmhzKS5jbXBuKDApID09PSAwO1xuXHR9O1xuXG5cdFNob3J0Q3VydmUucHJvdG90eXBlLl9lbmRvV25hZk11bEFkZCA9XG5cdCAgICBmdW5jdGlvbiBfZW5kb1duYWZNdWxBZGQocG9pbnRzLCBjb2VmZnMsIGphY29iaWFuUmVzdWx0KSB7XG5cdCAgdmFyIG5wb2ludHMgPSB0aGlzLl9lbmRvV25hZlQxO1xuXHQgIHZhciBuY29lZmZzID0gdGhpcy5fZW5kb1duYWZUMjtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuXHQgICAgdmFyIHNwbGl0ID0gdGhpcy5fZW5kb1NwbGl0KGNvZWZmc1tpXSk7XG5cdCAgICB2YXIgcCA9IHBvaW50c1tpXTtcblx0ICAgIHZhciBiZXRhID0gcC5fZ2V0QmV0YSgpO1xuXG5cdCAgICBpZiAoc3BsaXQuazEubmVnYXRpdmUpIHtcblx0ICAgICAgc3BsaXQuazEuaW5lZygpO1xuXHQgICAgICBwID0gcC5uZWcodHJ1ZSk7XG5cdCAgICB9XG5cdCAgICBpZiAoc3BsaXQuazIubmVnYXRpdmUpIHtcblx0ICAgICAgc3BsaXQuazIuaW5lZygpO1xuXHQgICAgICBiZXRhID0gYmV0YS5uZWcodHJ1ZSk7XG5cdCAgICB9XG5cblx0ICAgIG5wb2ludHNbaSAqIDJdID0gcDtcblx0ICAgIG5wb2ludHNbaSAqIDIgKyAxXSA9IGJldGE7XG5cdCAgICBuY29lZmZzW2kgKiAyXSA9IHNwbGl0LmsxO1xuXHQgICAgbmNvZWZmc1tpICogMiArIDFdID0gc3BsaXQuazI7XG5cdCAgfVxuXHQgIHZhciByZXMgPSB0aGlzLl93bmFmTXVsQWRkKDEsIG5wb2ludHMsIG5jb2VmZnMsIGkgKiAyLCBqYWNvYmlhblJlc3VsdCk7XG5cblx0ICAvLyBDbGVhbi11cCByZWZlcmVuY2VzIHRvIHBvaW50cyBhbmQgY29lZmZpY2llbnRzXG5cdCAgZm9yICh2YXIgaiA9IDA7IGogPCBpICogMjsgaisrKSB7XG5cdCAgICBucG9pbnRzW2pdID0gbnVsbDtcblx0ICAgIG5jb2VmZnNbal0gPSBudWxsO1xuXHQgIH1cblx0ICByZXR1cm4gcmVzO1xuXHR9O1xuXG5cdGZ1bmN0aW9uIFBvaW50KGN1cnZlLCB4LCB5LCBpc1JlZCkge1xuXHQgIGJhc2UuQmFzZVBvaW50LmNhbGwodGhpcywgY3VydmUsICdhZmZpbmUnKTtcblx0ICBpZiAoeCA9PT0gbnVsbCAmJiB5ID09PSBudWxsKSB7XG5cdCAgICB0aGlzLnggPSBudWxsO1xuXHQgICAgdGhpcy55ID0gbnVsbDtcblx0ICAgIHRoaXMuaW5mID0gdHJ1ZTtcblx0ICB9IGVsc2Uge1xuXHQgICAgdGhpcy54ID0gbmV3IGJuJDEoeCwgMTYpO1xuXHQgICAgdGhpcy55ID0gbmV3IGJuJDEoeSwgMTYpO1xuXHQgICAgLy8gRm9yY2UgcmVkZ29tZXJ5IHJlcHJlc2VudGF0aW9uIHdoZW4gbG9hZGluZyBmcm9tIEpTT05cblx0ICAgIGlmIChpc1JlZCkge1xuXHQgICAgICB0aGlzLnguZm9yY2VSZWQodGhpcy5jdXJ2ZS5yZWQpO1xuXHQgICAgICB0aGlzLnkuZm9yY2VSZWQodGhpcy5jdXJ2ZS5yZWQpO1xuXHQgICAgfVxuXHQgICAgaWYgKCF0aGlzLngucmVkKVxuXHQgICAgICB0aGlzLnggPSB0aGlzLngudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuXHQgICAgaWYgKCF0aGlzLnkucmVkKVxuXHQgICAgICB0aGlzLnkgPSB0aGlzLnkudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuXHQgICAgdGhpcy5pbmYgPSBmYWxzZTtcblx0ICB9XG5cdH1cblx0aW5oZXJpdHNfYnJvd3NlcihQb2ludCwgYmFzZS5CYXNlUG9pbnQpO1xuXG5cdFNob3J0Q3VydmUucHJvdG90eXBlLnBvaW50ID0gZnVuY3Rpb24gcG9pbnQoeCwgeSwgaXNSZWQpIHtcblx0ICByZXR1cm4gbmV3IFBvaW50KHRoaXMsIHgsIHksIGlzUmVkKTtcblx0fTtcblxuXHRTaG9ydEN1cnZlLnByb3RvdHlwZS5wb2ludEZyb21KU09OID0gZnVuY3Rpb24gcG9pbnRGcm9tSlNPTihvYmosIHJlZCkge1xuXHQgIHJldHVybiBQb2ludC5mcm9tSlNPTih0aGlzLCBvYmosIHJlZCk7XG5cdH07XG5cblx0UG9pbnQucHJvdG90eXBlLl9nZXRCZXRhID0gZnVuY3Rpb24gX2dldEJldGEoKSB7XG5cdCAgaWYgKCF0aGlzLmN1cnZlLmVuZG8pXG5cdCAgICByZXR1cm47XG5cblx0ICB2YXIgcHJlID0gdGhpcy5wcmVjb21wdXRlZDtcblx0ICBpZiAocHJlICYmIHByZS5iZXRhKVxuXHQgICAgcmV0dXJuIHByZS5iZXRhO1xuXG5cdCAgdmFyIGJldGEgPSB0aGlzLmN1cnZlLnBvaW50KHRoaXMueC5yZWRNdWwodGhpcy5jdXJ2ZS5lbmRvLmJldGEpLCB0aGlzLnkpO1xuXHQgIGlmIChwcmUpIHtcblx0ICAgIHZhciBjdXJ2ZSA9IHRoaXMuY3VydmU7XG5cdCAgICB2YXIgZW5kb011bCA9IGZ1bmN0aW9uKHApIHtcblx0ICAgICAgcmV0dXJuIGN1cnZlLnBvaW50KHAueC5yZWRNdWwoY3VydmUuZW5kby5iZXRhKSwgcC55KTtcblx0ICAgIH07XG5cdCAgICBwcmUuYmV0YSA9IGJldGE7XG5cdCAgICBiZXRhLnByZWNvbXB1dGVkID0ge1xuXHQgICAgICBiZXRhOiBudWxsLFxuXHQgICAgICBuYWY6IHByZS5uYWYgJiYge1xuXHQgICAgICAgIHduZDogcHJlLm5hZi53bmQsXG5cdCAgICAgICAgcG9pbnRzOiBwcmUubmFmLnBvaW50cy5tYXAoZW5kb011bClcblx0ICAgICAgfSxcblx0ICAgICAgZG91YmxlczogcHJlLmRvdWJsZXMgJiYge1xuXHQgICAgICAgIHN0ZXA6IHByZS5kb3VibGVzLnN0ZXAsXG5cdCAgICAgICAgcG9pbnRzOiBwcmUuZG91Ymxlcy5wb2ludHMubWFwKGVuZG9NdWwpXG5cdCAgICAgIH1cblx0ICAgIH07XG5cdCAgfVxuXHQgIHJldHVybiBiZXRhO1xuXHR9O1xuXG5cdFBvaW50LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG5cdCAgaWYgKCF0aGlzLnByZWNvbXB1dGVkKVxuXHQgICAgcmV0dXJuIFsgdGhpcy54LCB0aGlzLnkgXTtcblxuXHQgIHJldHVybiBbIHRoaXMueCwgdGhpcy55LCB0aGlzLnByZWNvbXB1dGVkICYmIHtcblx0ICAgIGRvdWJsZXM6IHRoaXMucHJlY29tcHV0ZWQuZG91YmxlcyAmJiB7XG5cdCAgICAgIHN0ZXA6IHRoaXMucHJlY29tcHV0ZWQuZG91Ymxlcy5zdGVwLFxuXHQgICAgICBwb2ludHM6IHRoaXMucHJlY29tcHV0ZWQuZG91Ymxlcy5wb2ludHMuc2xpY2UoMSlcblx0ICAgIH0sXG5cdCAgICBuYWY6IHRoaXMucHJlY29tcHV0ZWQubmFmICYmIHtcblx0ICAgICAgd25kOiB0aGlzLnByZWNvbXB1dGVkLm5hZi53bmQsXG5cdCAgICAgIHBvaW50czogdGhpcy5wcmVjb21wdXRlZC5uYWYucG9pbnRzLnNsaWNlKDEpXG5cdCAgICB9XG5cdCAgfSBdO1xuXHR9O1xuXG5cdFBvaW50LmZyb21KU09OID0gZnVuY3Rpb24gZnJvbUpTT04oY3VydmUsIG9iaiwgcmVkKSB7XG5cdCAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKVxuXHQgICAgb2JqID0gSlNPTi5wYXJzZShvYmopO1xuXHQgIHZhciByZXMgPSBjdXJ2ZS5wb2ludChvYmpbMF0sIG9ialsxXSwgcmVkKTtcblx0ICBpZiAoIW9ialsyXSlcblx0ICAgIHJldHVybiByZXM7XG5cblx0ICBmdW5jdGlvbiBvYmoycG9pbnQob2JqKSB7XG5cdCAgICByZXR1cm4gY3VydmUucG9pbnQob2JqWzBdLCBvYmpbMV0sIHJlZCk7XG5cdCAgfVxuXG5cdCAgdmFyIHByZSA9IG9ialsyXTtcblx0ICByZXMucHJlY29tcHV0ZWQgPSB7XG5cdCAgICBiZXRhOiBudWxsLFxuXHQgICAgZG91YmxlczogcHJlLmRvdWJsZXMgJiYge1xuXHQgICAgICBzdGVwOiBwcmUuZG91Ymxlcy5zdGVwLFxuXHQgICAgICBwb2ludHM6IFsgcmVzIF0uY29uY2F0KHByZS5kb3VibGVzLnBvaW50cy5tYXAob2JqMnBvaW50KSlcblx0ICAgIH0sXG5cdCAgICBuYWY6IHByZS5uYWYgJiYge1xuXHQgICAgICB3bmQ6IHByZS5uYWYud25kLFxuXHQgICAgICBwb2ludHM6IFsgcmVzIF0uY29uY2F0KHByZS5uYWYucG9pbnRzLm1hcChvYmoycG9pbnQpKVxuXHQgICAgfVxuXHQgIH07XG5cdCAgcmV0dXJuIHJlcztcblx0fTtcblxuXHRQb2ludC5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QoKSB7XG5cdCAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuXHQgICAgcmV0dXJuICc8RUMgUG9pbnQgSW5maW5pdHk+Jztcblx0ICByZXR1cm4gJzxFQyBQb2ludCB4OiAnICsgdGhpcy54LmZyb21SZWQoKS50b1N0cmluZygxNiwgMikgK1xuXHQgICAgICAnIHk6ICcgKyB0aGlzLnkuZnJvbVJlZCgpLnRvU3RyaW5nKDE2LCAyKSArICc+Jztcblx0fTtcblxuXHRQb2ludC5wcm90b3R5cGUuaXNJbmZpbml0eSA9IGZ1bmN0aW9uIGlzSW5maW5pdHkoKSB7XG5cdCAgcmV0dXJuIHRoaXMuaW5mO1xuXHR9O1xuXG5cdFBvaW50LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQocCkge1xuXHQgIC8vIE8gKyBQID0gUFxuXHQgIGlmICh0aGlzLmluZilcblx0ICAgIHJldHVybiBwO1xuXG5cdCAgLy8gUCArIE8gPSBQXG5cdCAgaWYgKHAuaW5mKVxuXHQgICAgcmV0dXJuIHRoaXM7XG5cblx0ICAvLyBQICsgUCA9IDJQXG5cdCAgaWYgKHRoaXMuZXEocCkpXG5cdCAgICByZXR1cm4gdGhpcy5kYmwoKTtcblxuXHQgIC8vIFAgKyAoLVApID0gT1xuXHQgIGlmICh0aGlzLm5lZygpLmVxKHApKVxuXHQgICAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobnVsbCwgbnVsbCk7XG5cblx0ICAvLyBQICsgUSA9IE9cblx0ICBpZiAodGhpcy54LmNtcChwLngpID09PSAwKVxuXHQgICAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobnVsbCwgbnVsbCk7XG5cblx0ICB2YXIgYyA9IHRoaXMueS5yZWRTdWIocC55KTtcblx0ICBpZiAoYy5jbXBuKDApICE9PSAwKVxuXHQgICAgYyA9IGMucmVkTXVsKHRoaXMueC5yZWRTdWIocC54KS5yZWRJbnZtKCkpO1xuXHQgIHZhciBueCA9IGMucmVkU3FyKCkucmVkSVN1Yih0aGlzLngpLnJlZElTdWIocC54KTtcblx0ICB2YXIgbnkgPSBjLnJlZE11bCh0aGlzLngucmVkU3ViKG54KSkucmVkSVN1Yih0aGlzLnkpO1xuXHQgIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG54LCBueSk7XG5cdH07XG5cblx0UG9pbnQucHJvdG90eXBlLmRibCA9IGZ1bmN0aW9uIGRibCgpIHtcblx0ICBpZiAodGhpcy5pbmYpXG5cdCAgICByZXR1cm4gdGhpcztcblxuXHQgIC8vIDJQID0gT1xuXHQgIHZhciB5czEgPSB0aGlzLnkucmVkQWRkKHRoaXMueSk7XG5cdCAgaWYgKHlzMS5jbXBuKDApID09PSAwKVxuXHQgICAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobnVsbCwgbnVsbCk7XG5cblx0ICB2YXIgYSA9IHRoaXMuY3VydmUuYTtcblxuXHQgIHZhciB4MiA9IHRoaXMueC5yZWRTcXIoKTtcblx0ICB2YXIgZHlpbnYgPSB5czEucmVkSW52bSgpO1xuXHQgIHZhciBjID0geDIucmVkQWRkKHgyKS5yZWRJQWRkKHgyKS5yZWRJQWRkKGEpLnJlZE11bChkeWludik7XG5cblx0ICB2YXIgbnggPSBjLnJlZFNxcigpLnJlZElTdWIodGhpcy54LnJlZEFkZCh0aGlzLngpKTtcblx0ICB2YXIgbnkgPSBjLnJlZE11bCh0aGlzLngucmVkU3ViKG54KSkucmVkSVN1Yih0aGlzLnkpO1xuXHQgIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG54LCBueSk7XG5cdH07XG5cblx0UG9pbnQucHJvdG90eXBlLmdldFggPSBmdW5jdGlvbiBnZXRYKCkge1xuXHQgIHJldHVybiB0aGlzLnguZnJvbVJlZCgpO1xuXHR9O1xuXG5cdFBvaW50LnByb3RvdHlwZS5nZXRZID0gZnVuY3Rpb24gZ2V0WSgpIHtcblx0ICByZXR1cm4gdGhpcy55LmZyb21SZWQoKTtcblx0fTtcblxuXHRQb2ludC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsKGspIHtcblx0ICBrID0gbmV3IGJuJDEoaywgMTYpO1xuXHQgIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIGVsc2UgaWYgKHRoaXMuX2hhc0RvdWJsZXMoaykpXG5cdCAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fZml4ZWROYWZNdWwodGhpcywgayk7XG5cdCAgZWxzZSBpZiAodGhpcy5jdXJ2ZS5lbmRvKVxuXHQgICAgcmV0dXJuIHRoaXMuY3VydmUuX2VuZG9XbmFmTXVsQWRkKFsgdGhpcyBdLCBbIGsgXSk7XG5cdCAgZWxzZVxuXHQgICAgcmV0dXJuIHRoaXMuY3VydmUuX3duYWZNdWwodGhpcywgayk7XG5cdH07XG5cblx0UG9pbnQucHJvdG90eXBlLm11bEFkZCA9IGZ1bmN0aW9uIG11bEFkZChrMSwgcDIsIGsyKSB7XG5cdCAgdmFyIHBvaW50cyA9IFsgdGhpcywgcDIgXTtcblx0ICB2YXIgY29lZmZzID0gWyBrMSwgazIgXTtcblx0ICBpZiAodGhpcy5jdXJ2ZS5lbmRvKVxuXHQgICAgcmV0dXJuIHRoaXMuY3VydmUuX2VuZG9XbmFmTXVsQWRkKHBvaW50cywgY29lZmZzKTtcblx0ICBlbHNlXG5cdCAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fd25hZk11bEFkZCgxLCBwb2ludHMsIGNvZWZmcywgMik7XG5cdH07XG5cblx0UG9pbnQucHJvdG90eXBlLmptdWxBZGQgPSBmdW5jdGlvbiBqbXVsQWRkKGsxLCBwMiwgazIpIHtcblx0ICB2YXIgcG9pbnRzID0gWyB0aGlzLCBwMiBdO1xuXHQgIHZhciBjb2VmZnMgPSBbIGsxLCBrMiBdO1xuXHQgIGlmICh0aGlzLmN1cnZlLmVuZG8pXG5cdCAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fZW5kb1duYWZNdWxBZGQocG9pbnRzLCBjb2VmZnMsIHRydWUpO1xuXHQgIGVsc2Vcblx0ICAgIHJldHVybiB0aGlzLmN1cnZlLl93bmFmTXVsQWRkKDEsIHBvaW50cywgY29lZmZzLCAyLCB0cnVlKTtcblx0fTtcblxuXHRQb2ludC5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbiBlcShwKSB7XG5cdCAgcmV0dXJuIHRoaXMgPT09IHAgfHxcblx0ICAgICAgICAgdGhpcy5pbmYgPT09IHAuaW5mICYmXG5cdCAgICAgICAgICAgICAodGhpcy5pbmYgfHwgdGhpcy54LmNtcChwLngpID09PSAwICYmIHRoaXMueS5jbXAocC55KSA9PT0gMCk7XG5cdH07XG5cblx0UG9pbnQucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uIG5lZyhfcHJlY29tcHV0ZSkge1xuXHQgIGlmICh0aGlzLmluZilcblx0ICAgIHJldHVybiB0aGlzO1xuXG5cdCAgdmFyIHJlcyA9IHRoaXMuY3VydmUucG9pbnQodGhpcy54LCB0aGlzLnkucmVkTmVnKCkpO1xuXHQgIGlmIChfcHJlY29tcHV0ZSAmJiB0aGlzLnByZWNvbXB1dGVkKSB7XG5cdCAgICB2YXIgcHJlID0gdGhpcy5wcmVjb21wdXRlZDtcblx0ICAgIHZhciBuZWdhdGUgPSBmdW5jdGlvbihwKSB7XG5cdCAgICAgIHJldHVybiBwLm5lZygpO1xuXHQgICAgfTtcblx0ICAgIHJlcy5wcmVjb21wdXRlZCA9IHtcblx0ICAgICAgbmFmOiBwcmUubmFmICYmIHtcblx0ICAgICAgICB3bmQ6IHByZS5uYWYud25kLFxuXHQgICAgICAgIHBvaW50czogcHJlLm5hZi5wb2ludHMubWFwKG5lZ2F0ZSlcblx0ICAgICAgfSxcblx0ICAgICAgZG91YmxlczogcHJlLmRvdWJsZXMgJiYge1xuXHQgICAgICAgIHN0ZXA6IHByZS5kb3VibGVzLnN0ZXAsXG5cdCAgICAgICAgcG9pbnRzOiBwcmUuZG91Ymxlcy5wb2ludHMubWFwKG5lZ2F0ZSlcblx0ICAgICAgfVxuXHQgICAgfTtcblx0ICB9XG5cdCAgcmV0dXJuIHJlcztcblx0fTtcblxuXHRQb2ludC5wcm90b3R5cGUudG9KID0gZnVuY3Rpb24gdG9KKCkge1xuXHQgIGlmICh0aGlzLmluZilcblx0ICAgIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChudWxsLCBudWxsLCBudWxsKTtcblxuXHQgIHZhciByZXMgPSB0aGlzLmN1cnZlLmpwb2ludCh0aGlzLngsIHRoaXMueSwgdGhpcy5jdXJ2ZS5vbmUpO1xuXHQgIHJldHVybiByZXM7XG5cdH07XG5cblx0ZnVuY3Rpb24gSlBvaW50KGN1cnZlLCB4LCB5LCB6KSB7XG5cdCAgYmFzZS5CYXNlUG9pbnQuY2FsbCh0aGlzLCBjdXJ2ZSwgJ2phY29iaWFuJyk7XG5cdCAgaWYgKHggPT09IG51bGwgJiYgeSA9PT0gbnVsbCAmJiB6ID09PSBudWxsKSB7XG5cdCAgICB0aGlzLnggPSB0aGlzLmN1cnZlLm9uZTtcblx0ICAgIHRoaXMueSA9IHRoaXMuY3VydmUub25lO1xuXHQgICAgdGhpcy56ID0gbmV3IGJuJDEoMCk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHRoaXMueCA9IG5ldyBibiQxKHgsIDE2KTtcblx0ICAgIHRoaXMueSA9IG5ldyBibiQxKHksIDE2KTtcblx0ICAgIHRoaXMueiA9IG5ldyBibiQxKHosIDE2KTtcblx0ICB9XG5cdCAgaWYgKCF0aGlzLngucmVkKVxuXHQgICAgdGhpcy54ID0gdGhpcy54LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcblx0ICBpZiAoIXRoaXMueS5yZWQpXG5cdCAgICB0aGlzLnkgPSB0aGlzLnkudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuXHQgIGlmICghdGhpcy56LnJlZClcblx0ICAgIHRoaXMueiA9IHRoaXMuei50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG5cblx0ICB0aGlzLnpPbmUgPSB0aGlzLnogPT09IHRoaXMuY3VydmUub25lO1xuXHR9XG5cdGluaGVyaXRzX2Jyb3dzZXIoSlBvaW50LCBiYXNlLkJhc2VQb2ludCk7XG5cblx0U2hvcnRDdXJ2ZS5wcm90b3R5cGUuanBvaW50ID0gZnVuY3Rpb24ganBvaW50KHgsIHksIHopIHtcblx0ICByZXR1cm4gbmV3IEpQb2ludCh0aGlzLCB4LCB5LCB6KTtcblx0fTtcblxuXHRKUG9pbnQucHJvdG90eXBlLnRvUCA9IGZ1bmN0aW9uIHRvUCgpIHtcblx0ICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG5cdCAgICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChudWxsLCBudWxsKTtcblxuXHQgIHZhciB6aW52ID0gdGhpcy56LnJlZEludm0oKTtcblx0ICB2YXIgemludjIgPSB6aW52LnJlZFNxcigpO1xuXHQgIHZhciBheCA9IHRoaXMueC5yZWRNdWwoemludjIpO1xuXHQgIHZhciBheSA9IHRoaXMueS5yZWRNdWwoemludjIpLnJlZE11bCh6aW52KTtcblxuXHQgIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KGF4LCBheSk7XG5cdH07XG5cblx0SlBvaW50LnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbiBuZWcoKSB7XG5cdCAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KHRoaXMueCwgdGhpcy55LnJlZE5lZygpLCB0aGlzLnopO1xuXHR9O1xuXG5cdEpQb2ludC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKHApIHtcblx0ICAvLyBPICsgUCA9IFBcblx0ICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG5cdCAgICByZXR1cm4gcDtcblxuXHQgIC8vIFAgKyBPID0gUFxuXHQgIGlmIChwLmlzSW5maW5pdHkoKSlcblx0ICAgIHJldHVybiB0aGlzO1xuXG5cdCAgLy8gMTJNICsgNFMgKyA3QVxuXHQgIHZhciBwejIgPSBwLnoucmVkU3FyKCk7XG5cdCAgdmFyIHoyID0gdGhpcy56LnJlZFNxcigpO1xuXHQgIHZhciB1MSA9IHRoaXMueC5yZWRNdWwocHoyKTtcblx0ICB2YXIgdTIgPSBwLngucmVkTXVsKHoyKTtcblx0ICB2YXIgczEgPSB0aGlzLnkucmVkTXVsKHB6Mi5yZWRNdWwocC56KSk7XG5cdCAgdmFyIHMyID0gcC55LnJlZE11bCh6Mi5yZWRNdWwodGhpcy56KSk7XG5cblx0ICB2YXIgaCA9IHUxLnJlZFN1Yih1Mik7XG5cdCAgdmFyIHIgPSBzMS5yZWRTdWIoczIpO1xuXHQgIGlmIChoLmNtcG4oMCkgPT09IDApIHtcblx0ICAgIGlmIChyLmNtcG4oMCkgIT09IDApXG5cdCAgICAgIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChudWxsLCBudWxsLCBudWxsKTtcblx0ICAgIGVsc2Vcblx0ICAgICAgcmV0dXJuIHRoaXMuZGJsKCk7XG5cdCAgfVxuXG5cdCAgdmFyIGgyID0gaC5yZWRTcXIoKTtcblx0ICB2YXIgaDMgPSBoMi5yZWRNdWwoaCk7XG5cdCAgdmFyIHYgPSB1MS5yZWRNdWwoaDIpO1xuXG5cdCAgdmFyIG54ID0gci5yZWRTcXIoKS5yZWRJQWRkKGgzKS5yZWRJU3ViKHYpLnJlZElTdWIodik7XG5cdCAgdmFyIG55ID0gci5yZWRNdWwodi5yZWRJU3ViKG54KSkucmVkSVN1YihzMS5yZWRNdWwoaDMpKTtcblx0ICB2YXIgbnogPSB0aGlzLnoucmVkTXVsKHAueikucmVkTXVsKGgpO1xuXG5cdCAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG54LCBueSwgbnopO1xuXHR9O1xuXG5cdEpQb2ludC5wcm90b3R5cGUubWl4ZWRBZGQgPSBmdW5jdGlvbiBtaXhlZEFkZChwKSB7XG5cdCAgLy8gTyArIFAgPSBQXG5cdCAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuXHQgICAgcmV0dXJuIHAudG9KKCk7XG5cblx0ICAvLyBQICsgTyA9IFBcblx0ICBpZiAocC5pc0luZmluaXR5KCkpXG5cdCAgICByZXR1cm4gdGhpcztcblxuXHQgIC8vIDhNICsgM1MgKyA3QVxuXHQgIHZhciB6MiA9IHRoaXMuei5yZWRTcXIoKTtcblx0ICB2YXIgdTEgPSB0aGlzLng7XG5cdCAgdmFyIHUyID0gcC54LnJlZE11bCh6Mik7XG5cdCAgdmFyIHMxID0gdGhpcy55O1xuXHQgIHZhciBzMiA9IHAueS5yZWRNdWwoejIpLnJlZE11bCh0aGlzLnopO1xuXG5cdCAgdmFyIGggPSB1MS5yZWRTdWIodTIpO1xuXHQgIHZhciByID0gczEucmVkU3ViKHMyKTtcblx0ICBpZiAoaC5jbXBuKDApID09PSAwKSB7XG5cdCAgICBpZiAoci5jbXBuKDApICE9PSAwKVxuXHQgICAgICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG5cdCAgICBlbHNlXG5cdCAgICAgIHJldHVybiB0aGlzLmRibCgpO1xuXHQgIH1cblxuXHQgIHZhciBoMiA9IGgucmVkU3FyKCk7XG5cdCAgdmFyIGgzID0gaDIucmVkTXVsKGgpO1xuXHQgIHZhciB2ID0gdTEucmVkTXVsKGgyKTtcblxuXHQgIHZhciBueCA9IHIucmVkU3FyKCkucmVkSUFkZChoMykucmVkSVN1Yih2KS5yZWRJU3ViKHYpO1xuXHQgIHZhciBueSA9IHIucmVkTXVsKHYucmVkSVN1YihueCkpLnJlZElTdWIoczEucmVkTXVsKGgzKSk7XG5cdCAgdmFyIG56ID0gdGhpcy56LnJlZE11bChoKTtcblxuXHQgIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChueCwgbnksIG56KTtcblx0fTtcblxuXHRKUG9pbnQucHJvdG90eXBlLmRibHAgPSBmdW5jdGlvbiBkYmxwKHBvdykge1xuXHQgIGlmIChwb3cgPT09IDApXG5cdCAgICByZXR1cm4gdGhpcztcblx0ICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG5cdCAgICByZXR1cm4gdGhpcztcblx0ICBpZiAoIXBvdylcblx0ICAgIHJldHVybiB0aGlzLmRibCgpO1xuXG5cdCAgaWYgKHRoaXMuY3VydmUuemVyb0EgfHwgdGhpcy5jdXJ2ZS50aHJlZUEpIHtcblx0ICAgIHZhciByID0gdGhpcztcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG93OyBpKyspXG5cdCAgICAgIHIgPSByLmRibCgpO1xuXHQgICAgcmV0dXJuIHI7XG5cdCAgfVxuXG5cdCAgLy8gMU0gKyAyUyArIDFBICsgTiAqICg0UyArIDVNICsgOEEpXG5cdCAgLy8gTiA9IDEgPT4gNk0gKyA2UyArIDlBXG5cdCAgdmFyIGEgPSB0aGlzLmN1cnZlLmE7XG5cdCAgdmFyIHRpbnYgPSB0aGlzLmN1cnZlLnRpbnY7XG5cblx0ICB2YXIganggPSB0aGlzLng7XG5cdCAgdmFyIGp5ID0gdGhpcy55O1xuXHQgIHZhciBqeiA9IHRoaXMuejtcblx0ICB2YXIgano0ID0ganoucmVkU3FyKCkucmVkU3FyKCk7XG5cblx0ICAvLyBSZXVzZSByZXN1bHRzXG5cdCAgdmFyIGp5ZCA9IGp5LnJlZEFkZChqeSk7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb3c7IGkrKykge1xuXHQgICAgdmFyIGp4MiA9IGp4LnJlZFNxcigpO1xuXHQgICAgdmFyIGp5ZDIgPSBqeWQucmVkU3FyKCk7XG5cdCAgICB2YXIganlkNCA9IGp5ZDIucmVkU3FyKCk7XG5cdCAgICB2YXIgYyA9IGp4Mi5yZWRBZGQoangyKS5yZWRJQWRkKGp4MikucmVkSUFkZChhLnJlZE11bChqejQpKTtcblxuXHQgICAgdmFyIHQxID0gangucmVkTXVsKGp5ZDIpO1xuXHQgICAgdmFyIG54ID0gYy5yZWRTcXIoKS5yZWRJU3ViKHQxLnJlZEFkZCh0MSkpO1xuXHQgICAgdmFyIHQyID0gdDEucmVkSVN1YihueCk7XG5cdCAgICB2YXIgZG55ID0gYy5yZWRNdWwodDIpO1xuXHQgICAgZG55ID0gZG55LnJlZElBZGQoZG55KS5yZWRJU3ViKGp5ZDQpO1xuXHQgICAgdmFyIG56ID0ganlkLnJlZE11bChqeik7XG5cdCAgICBpZiAoaSArIDEgPCBwb3cpXG5cdCAgICAgIGp6NCA9IGp6NC5yZWRNdWwoanlkNCk7XG5cblx0ICAgIGp4ID0gbng7XG5cdCAgICBqeiA9IG56O1xuXHQgICAganlkID0gZG55O1xuXHQgIH1cblxuXHQgIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChqeCwganlkLnJlZE11bCh0aW52KSwganopO1xuXHR9O1xuXG5cdEpQb2ludC5wcm90b3R5cGUuZGJsID0gZnVuY3Rpb24gZGJsKCkge1xuXHQgIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcblx0ICAgIHJldHVybiB0aGlzO1xuXG5cdCAgaWYgKHRoaXMuY3VydmUuemVyb0EpXG5cdCAgICByZXR1cm4gdGhpcy5femVyb0RibCgpO1xuXHQgIGVsc2UgaWYgKHRoaXMuY3VydmUudGhyZWVBKVxuXHQgICAgcmV0dXJuIHRoaXMuX3RocmVlRGJsKCk7XG5cdCAgZWxzZVxuXHQgICAgcmV0dXJuIHRoaXMuX2RibCgpO1xuXHR9O1xuXG5cdEpQb2ludC5wcm90b3R5cGUuX3plcm9EYmwgPSBmdW5jdGlvbiBfemVyb0RibCgpIHtcblx0ICB2YXIgbng7XG5cdCAgdmFyIG55O1xuXHQgIHZhciBuejtcblx0ICAvLyBaID0gMVxuXHQgIGlmICh0aGlzLnpPbmUpIHtcblx0ICAgIC8vIGh5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by1zaG9ydHctamFjb2JpYW4tMC5odG1sXG5cdCAgICAvLyAgICAgI2RvdWJsaW5nLW1kYmwtMjAwNy1ibFxuXHQgICAgLy8gMU0gKyA1UyArIDE0QVxuXG5cdCAgICAvLyBYWCA9IFgxXjJcblx0ICAgIHZhciB4eCA9IHRoaXMueC5yZWRTcXIoKTtcblx0ICAgIC8vIFlZID0gWTFeMlxuXHQgICAgdmFyIHl5ID0gdGhpcy55LnJlZFNxcigpO1xuXHQgICAgLy8gWVlZWSA9IFlZXjJcblx0ICAgIHZhciB5eXl5ID0geXkucmVkU3FyKCk7XG5cdCAgICAvLyBTID0gMiAqICgoWDEgKyBZWSleMiAtIFhYIC0gWVlZWSlcblx0ICAgIHZhciBzID0gdGhpcy54LnJlZEFkZCh5eSkucmVkU3FyKCkucmVkSVN1Yih4eCkucmVkSVN1Yih5eXl5KTtcblx0ICAgIHMgPSBzLnJlZElBZGQocyk7XG5cdCAgICAvLyBNID0gMyAqIFhYICsgYTsgYSA9IDBcblx0ICAgIHZhciBtID0geHgucmVkQWRkKHh4KS5yZWRJQWRkKHh4KTtcblx0ICAgIC8vIFQgPSBNIF4gMiAtIDIqU1xuXHQgICAgdmFyIHQgPSBtLnJlZFNxcigpLnJlZElTdWIocykucmVkSVN1YihzKTtcblxuXHQgICAgLy8gOCAqIFlZWVlcblx0ICAgIHZhciB5eXl5OCA9IHl5eXkucmVkSUFkZCh5eXl5KTtcblx0ICAgIHl5eXk4ID0geXl5eTgucmVkSUFkZCh5eXl5OCk7XG5cdCAgICB5eXl5OCA9IHl5eXk4LnJlZElBZGQoeXl5eTgpO1xuXG5cdCAgICAvLyBYMyA9IFRcblx0ICAgIG54ID0gdDtcblx0ICAgIC8vIFkzID0gTSAqIChTIC0gVCkgLSA4ICogWVlZWVxuXHQgICAgbnkgPSBtLnJlZE11bChzLnJlZElTdWIodCkpLnJlZElTdWIoeXl5eTgpO1xuXHQgICAgLy8gWjMgPSAyKlkxXG5cdCAgICBueiA9IHRoaXMueS5yZWRBZGQodGhpcy55KTtcblx0ICB9IGVsc2Uge1xuXHQgICAgLy8gaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXNob3J0dy1qYWNvYmlhbi0wLmh0bWxcblx0ICAgIC8vICAgICAjZG91YmxpbmctZGJsLTIwMDktbFxuXHQgICAgLy8gMk0gKyA1UyArIDEzQVxuXG5cdCAgICAvLyBBID0gWDFeMlxuXHQgICAgdmFyIGEgPSB0aGlzLngucmVkU3FyKCk7XG5cdCAgICAvLyBCID0gWTFeMlxuXHQgICAgdmFyIGIgPSB0aGlzLnkucmVkU3FyKCk7XG5cdCAgICAvLyBDID0gQl4yXG5cdCAgICB2YXIgYyA9IGIucmVkU3FyKCk7XG5cdCAgICAvLyBEID0gMiAqICgoWDEgKyBCKV4yIC0gQSAtIEMpXG5cdCAgICB2YXIgZCA9IHRoaXMueC5yZWRBZGQoYikucmVkU3FyKCkucmVkSVN1YihhKS5yZWRJU3ViKGMpO1xuXHQgICAgZCA9IGQucmVkSUFkZChkKTtcblx0ICAgIC8vIEUgPSAzICogQVxuXHQgICAgdmFyIGUgPSBhLnJlZEFkZChhKS5yZWRJQWRkKGEpO1xuXHQgICAgLy8gRiA9IEVeMlxuXHQgICAgdmFyIGYgPSBlLnJlZFNxcigpO1xuXG5cdCAgICAvLyA4ICogQ1xuXHQgICAgdmFyIGM4ID0gYy5yZWRJQWRkKGMpO1xuXHQgICAgYzggPSBjOC5yZWRJQWRkKGM4KTtcblx0ICAgIGM4ID0gYzgucmVkSUFkZChjOCk7XG5cblx0ICAgIC8vIFgzID0gRiAtIDIgKiBEXG5cdCAgICBueCA9IGYucmVkSVN1YihkKS5yZWRJU3ViKGQpO1xuXHQgICAgLy8gWTMgPSBFICogKEQgLSBYMykgLSA4ICogQ1xuXHQgICAgbnkgPSBlLnJlZE11bChkLnJlZElTdWIobngpKS5yZWRJU3ViKGM4KTtcblx0ICAgIC8vIFozID0gMiAqIFkxICogWjFcblx0ICAgIG56ID0gdGhpcy55LnJlZE11bCh0aGlzLnopO1xuXHQgICAgbnogPSBuei5yZWRJQWRkKG56KTtcblx0ICB9XG5cblx0ICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobngsIG55LCBueik7XG5cdH07XG5cblx0SlBvaW50LnByb3RvdHlwZS5fdGhyZWVEYmwgPSBmdW5jdGlvbiBfdGhyZWVEYmwoKSB7XG5cdCAgdmFyIG54O1xuXHQgIHZhciBueTtcblx0ICB2YXIgbno7XG5cdCAgLy8gWiA9IDFcblx0ICBpZiAodGhpcy56T25lKSB7XG5cdCAgICAvLyBoeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tc2hvcnR3LWphY29iaWFuLTMuaHRtbFxuXHQgICAgLy8gICAgICNkb3VibGluZy1tZGJsLTIwMDctYmxcblx0ICAgIC8vIDFNICsgNVMgKyAxNUFcblxuXHQgICAgLy8gWFggPSBYMV4yXG5cdCAgICB2YXIgeHggPSB0aGlzLngucmVkU3FyKCk7XG5cdCAgICAvLyBZWSA9IFkxXjJcblx0ICAgIHZhciB5eSA9IHRoaXMueS5yZWRTcXIoKTtcblx0ICAgIC8vIFlZWVkgPSBZWV4yXG5cdCAgICB2YXIgeXl5eSA9IHl5LnJlZFNxcigpO1xuXHQgICAgLy8gUyA9IDIgKiAoKFgxICsgWVkpXjIgLSBYWCAtIFlZWVkpXG5cdCAgICB2YXIgcyA9IHRoaXMueC5yZWRBZGQoeXkpLnJlZFNxcigpLnJlZElTdWIoeHgpLnJlZElTdWIoeXl5eSk7XG5cdCAgICBzID0gcy5yZWRJQWRkKHMpO1xuXHQgICAgLy8gTSA9IDMgKiBYWCArIGFcblx0ICAgIHZhciBtID0geHgucmVkQWRkKHh4KS5yZWRJQWRkKHh4KS5yZWRJQWRkKHRoaXMuY3VydmUuYSk7XG5cdCAgICAvLyBUID0gTV4yIC0gMiAqIFNcblx0ICAgIHZhciB0ID0gbS5yZWRTcXIoKS5yZWRJU3ViKHMpLnJlZElTdWIocyk7XG5cdCAgICAvLyBYMyA9IFRcblx0ICAgIG54ID0gdDtcblx0ICAgIC8vIFkzID0gTSAqIChTIC0gVCkgLSA4ICogWVlZWVxuXHQgICAgdmFyIHl5eXk4ID0geXl5eS5yZWRJQWRkKHl5eXkpO1xuXHQgICAgeXl5eTggPSB5eXl5OC5yZWRJQWRkKHl5eXk4KTtcblx0ICAgIHl5eXk4ID0geXl5eTgucmVkSUFkZCh5eXl5OCk7XG5cdCAgICBueSA9IG0ucmVkTXVsKHMucmVkSVN1Yih0KSkucmVkSVN1Yih5eXl5OCk7XG5cdCAgICAvLyBaMyA9IDIgKiBZMVxuXHQgICAgbnogPSB0aGlzLnkucmVkQWRkKHRoaXMueSk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIC8vIGh5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by1zaG9ydHctamFjb2JpYW4tMy5odG1sI2RvdWJsaW5nLWRibC0yMDAxLWJcblx0ICAgIC8vIDNNICsgNVNcblxuXHQgICAgLy8gZGVsdGEgPSBaMV4yXG5cdCAgICB2YXIgZGVsdGEgPSB0aGlzLnoucmVkU3FyKCk7XG5cdCAgICAvLyBnYW1tYSA9IFkxXjJcblx0ICAgIHZhciBnYW1tYSA9IHRoaXMueS5yZWRTcXIoKTtcblx0ICAgIC8vIGJldGEgPSBYMSAqIGdhbW1hXG5cdCAgICB2YXIgYmV0YSA9IHRoaXMueC5yZWRNdWwoZ2FtbWEpO1xuXHQgICAgLy8gYWxwaGEgPSAzICogKFgxIC0gZGVsdGEpICogKFgxICsgZGVsdGEpXG5cdCAgICB2YXIgYWxwaGEgPSB0aGlzLngucmVkU3ViKGRlbHRhKS5yZWRNdWwodGhpcy54LnJlZEFkZChkZWx0YSkpO1xuXHQgICAgYWxwaGEgPSBhbHBoYS5yZWRBZGQoYWxwaGEpLnJlZElBZGQoYWxwaGEpO1xuXHQgICAgLy8gWDMgPSBhbHBoYV4yIC0gOCAqIGJldGFcblx0ICAgIHZhciBiZXRhNCA9IGJldGEucmVkSUFkZChiZXRhKTtcblx0ICAgIGJldGE0ID0gYmV0YTQucmVkSUFkZChiZXRhNCk7XG5cdCAgICB2YXIgYmV0YTggPSBiZXRhNC5yZWRBZGQoYmV0YTQpO1xuXHQgICAgbnggPSBhbHBoYS5yZWRTcXIoKS5yZWRJU3ViKGJldGE4KTtcblx0ICAgIC8vIFozID0gKFkxICsgWjEpXjIgLSBnYW1tYSAtIGRlbHRhXG5cdCAgICBueiA9IHRoaXMueS5yZWRBZGQodGhpcy56KS5yZWRTcXIoKS5yZWRJU3ViKGdhbW1hKS5yZWRJU3ViKGRlbHRhKTtcblx0ICAgIC8vIFkzID0gYWxwaGEgKiAoNCAqIGJldGEgLSBYMykgLSA4ICogZ2FtbWFeMlxuXHQgICAgdmFyIGdnYW1tYTggPSBnYW1tYS5yZWRTcXIoKTtcblx0ICAgIGdnYW1tYTggPSBnZ2FtbWE4LnJlZElBZGQoZ2dhbW1hOCk7XG5cdCAgICBnZ2FtbWE4ID0gZ2dhbW1hOC5yZWRJQWRkKGdnYW1tYTgpO1xuXHQgICAgZ2dhbW1hOCA9IGdnYW1tYTgucmVkSUFkZChnZ2FtbWE4KTtcblx0ICAgIG55ID0gYWxwaGEucmVkTXVsKGJldGE0LnJlZElTdWIobngpKS5yZWRJU3ViKGdnYW1tYTgpO1xuXHQgIH1cblxuXHQgIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChueCwgbnksIG56KTtcblx0fTtcblxuXHRKUG9pbnQucHJvdG90eXBlLl9kYmwgPSBmdW5jdGlvbiBfZGJsKCkge1xuXHQgIHZhciBhID0gdGhpcy5jdXJ2ZS5hO1xuXG5cdCAgLy8gNE0gKyA2UyArIDEwQVxuXHQgIHZhciBqeCA9IHRoaXMueDtcblx0ICB2YXIgankgPSB0aGlzLnk7XG5cdCAgdmFyIGp6ID0gdGhpcy56O1xuXHQgIHZhciBqejQgPSBqei5yZWRTcXIoKS5yZWRTcXIoKTtcblxuXHQgIHZhciBqeDIgPSBqeC5yZWRTcXIoKTtcblx0ICB2YXIgankyID0gankucmVkU3FyKCk7XG5cblx0ICB2YXIgYyA9IGp4Mi5yZWRBZGQoangyKS5yZWRJQWRkKGp4MikucmVkSUFkZChhLnJlZE11bChqejQpKTtcblxuXHQgIHZhciBqeGQ0ID0gangucmVkQWRkKGp4KTtcblx0ICBqeGQ0ID0ganhkNC5yZWRJQWRkKGp4ZDQpO1xuXHQgIHZhciB0MSA9IGp4ZDQucmVkTXVsKGp5Mik7XG5cdCAgdmFyIG54ID0gYy5yZWRTcXIoKS5yZWRJU3ViKHQxLnJlZEFkZCh0MSkpO1xuXHQgIHZhciB0MiA9IHQxLnJlZElTdWIobngpO1xuXG5cdCAgdmFyIGp5ZDggPSBqeTIucmVkU3FyKCk7XG5cdCAganlkOCA9IGp5ZDgucmVkSUFkZChqeWQ4KTtcblx0ICBqeWQ4ID0ganlkOC5yZWRJQWRkKGp5ZDgpO1xuXHQgIGp5ZDggPSBqeWQ4LnJlZElBZGQoanlkOCk7XG5cdCAgdmFyIG55ID0gYy5yZWRNdWwodDIpLnJlZElTdWIoanlkOCk7XG5cdCAgdmFyIG56ID0gankucmVkQWRkKGp5KS5yZWRNdWwoanopO1xuXG5cdCAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG54LCBueSwgbnopO1xuXHR9O1xuXG5cdEpQb2ludC5wcm90b3R5cGUudHJwbCA9IGZ1bmN0aW9uIHRycGwoKSB7XG5cdCAgaWYgKCF0aGlzLmN1cnZlLnplcm9BKVxuXHQgICAgcmV0dXJuIHRoaXMuZGJsKCkuYWRkKHRoaXMpO1xuXG5cdCAgLy8gaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXNob3J0dy1qYWNvYmlhbi0wLmh0bWwjdHJpcGxpbmctdHBsLTIwMDctYmxcblx0ICAvLyA1TSArIDEwUyArIC4uLlxuXG5cdCAgLy8gWFggPSBYMV4yXG5cdCAgdmFyIHh4ID0gdGhpcy54LnJlZFNxcigpO1xuXHQgIC8vIFlZID0gWTFeMlxuXHQgIHZhciB5eSA9IHRoaXMueS5yZWRTcXIoKTtcblx0ICAvLyBaWiA9IFoxXjJcblx0ICB2YXIgenogPSB0aGlzLnoucmVkU3FyKCk7XG5cdCAgLy8gWVlZWSA9IFlZXjJcblx0ICB2YXIgeXl5eSA9IHl5LnJlZFNxcigpO1xuXHQgIC8vIE0gPSAzICogWFggKyBhICogWloyOyBhID0gMFxuXHQgIHZhciBtID0geHgucmVkQWRkKHh4KS5yZWRJQWRkKHh4KTtcblx0ICAvLyBNTSA9IE1eMlxuXHQgIHZhciBtbSA9IG0ucmVkU3FyKCk7XG5cdCAgLy8gRSA9IDYgKiAoKFgxICsgWVkpXjIgLSBYWCAtIFlZWVkpIC0gTU1cblx0ICB2YXIgZSA9IHRoaXMueC5yZWRBZGQoeXkpLnJlZFNxcigpLnJlZElTdWIoeHgpLnJlZElTdWIoeXl5eSk7XG5cdCAgZSA9IGUucmVkSUFkZChlKTtcblx0ICBlID0gZS5yZWRBZGQoZSkucmVkSUFkZChlKTtcblx0ICBlID0gZS5yZWRJU3ViKG1tKTtcblx0ICAvLyBFRSA9IEVeMlxuXHQgIHZhciBlZSA9IGUucmVkU3FyKCk7XG5cdCAgLy8gVCA9IDE2KllZWVlcblx0ICB2YXIgdCA9IHl5eXkucmVkSUFkZCh5eXl5KTtcblx0ICB0ID0gdC5yZWRJQWRkKHQpO1xuXHQgIHQgPSB0LnJlZElBZGQodCk7XG5cdCAgdCA9IHQucmVkSUFkZCh0KTtcblx0ICAvLyBVID0gKE0gKyBFKV4yIC0gTU0gLSBFRSAtIFRcblx0ICB2YXIgdSA9IG0ucmVkSUFkZChlKS5yZWRTcXIoKS5yZWRJU3ViKG1tKS5yZWRJU3ViKGVlKS5yZWRJU3ViKHQpO1xuXHQgIC8vIFgzID0gNCAqIChYMSAqIEVFIC0gNCAqIFlZICogVSlcblx0ICB2YXIgeXl1NCA9IHl5LnJlZE11bCh1KTtcblx0ICB5eXU0ID0geXl1NC5yZWRJQWRkKHl5dTQpO1xuXHQgIHl5dTQgPSB5eXU0LnJlZElBZGQoeXl1NCk7XG5cdCAgdmFyIG54ID0gdGhpcy54LnJlZE11bChlZSkucmVkSVN1Yih5eXU0KTtcblx0ICBueCA9IG54LnJlZElBZGQobngpO1xuXHQgIG54ID0gbngucmVkSUFkZChueCk7XG5cdCAgLy8gWTMgPSA4ICogWTEgKiAoVSAqIChUIC0gVSkgLSBFICogRUUpXG5cdCAgdmFyIG55ID0gdGhpcy55LnJlZE11bCh1LnJlZE11bCh0LnJlZElTdWIodSkpLnJlZElTdWIoZS5yZWRNdWwoZWUpKSk7XG5cdCAgbnkgPSBueS5yZWRJQWRkKG55KTtcblx0ICBueSA9IG55LnJlZElBZGQobnkpO1xuXHQgIG55ID0gbnkucmVkSUFkZChueSk7XG5cdCAgLy8gWjMgPSAoWjEgKyBFKV4yIC0gWlogLSBFRVxuXHQgIHZhciBueiA9IHRoaXMuei5yZWRBZGQoZSkucmVkU3FyKCkucmVkSVN1Yih6eikucmVkSVN1YihlZSk7XG5cblx0ICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobngsIG55LCBueik7XG5cdH07XG5cblx0SlBvaW50LnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwoaywga2Jhc2UpIHtcblx0ICBrID0gbmV3IGJuJDEoaywga2Jhc2UpO1xuXG5cdCAgcmV0dXJuIHRoaXMuY3VydmUuX3duYWZNdWwodGhpcywgayk7XG5cdH07XG5cblx0SlBvaW50LnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIGVxKHApIHtcblx0ICBpZiAocC50eXBlID09PSAnYWZmaW5lJylcblx0ICAgIHJldHVybiB0aGlzLmVxKHAudG9KKCkpO1xuXG5cdCAgaWYgKHRoaXMgPT09IHApXG5cdCAgICByZXR1cm4gdHJ1ZTtcblxuXHQgIC8vIHgxICogejJeMiA9PSB4MiAqIHoxXjJcblx0ICB2YXIgejIgPSB0aGlzLnoucmVkU3FyKCk7XG5cdCAgdmFyIHB6MiA9IHAuei5yZWRTcXIoKTtcblx0ICBpZiAodGhpcy54LnJlZE11bChwejIpLnJlZElTdWIocC54LnJlZE11bCh6MikpLmNtcG4oMCkgIT09IDApXG5cdCAgICByZXR1cm4gZmFsc2U7XG5cblx0ICAvLyB5MSAqIHoyXjMgPT0geTIgKiB6MV4zXG5cdCAgdmFyIHozID0gejIucmVkTXVsKHRoaXMueik7XG5cdCAgdmFyIHB6MyA9IHB6Mi5yZWRNdWwocC56KTtcblx0ICByZXR1cm4gdGhpcy55LnJlZE11bChwejMpLnJlZElTdWIocC55LnJlZE11bCh6MykpLmNtcG4oMCkgPT09IDA7XG5cdH07XG5cblx0SlBvaW50LnByb3RvdHlwZS5lcVhUb1AgPSBmdW5jdGlvbiBlcVhUb1AoeCkge1xuXHQgIHZhciB6cyA9IHRoaXMuei5yZWRTcXIoKTtcblx0ICB2YXIgcnggPSB4LnRvUmVkKHRoaXMuY3VydmUucmVkKS5yZWRNdWwoenMpO1xuXHQgIGlmICh0aGlzLnguY21wKHJ4KSA9PT0gMClcblx0ICAgIHJldHVybiB0cnVlO1xuXG5cdCAgdmFyIHhjID0geC5jbG9uZSgpO1xuXHQgIHZhciB0ID0gdGhpcy5jdXJ2ZS5yZWROLnJlZE11bCh6cyk7XG5cdCAgZm9yICg7Oykge1xuXHQgICAgeGMuaWFkZCh0aGlzLmN1cnZlLm4pO1xuXHQgICAgaWYgKHhjLmNtcCh0aGlzLmN1cnZlLnApID49IDApXG5cdCAgICAgIHJldHVybiBmYWxzZTtcblxuXHQgICAgcngucmVkSUFkZCh0KTtcblx0ICAgIGlmICh0aGlzLnguY21wKHJ4KSA9PT0gMClcblx0ICAgICAgcmV0dXJuIHRydWU7XG5cdCAgfVxuXHR9O1xuXG5cdEpQb2ludC5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QoKSB7XG5cdCAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuXHQgICAgcmV0dXJuICc8RUMgSlBvaW50IEluZmluaXR5Pic7XG5cdCAgcmV0dXJuICc8RUMgSlBvaW50IHg6ICcgKyB0aGlzLngudG9TdHJpbmcoMTYsIDIpICtcblx0ICAgICAgJyB5OiAnICsgdGhpcy55LnRvU3RyaW5nKDE2LCAyKSArXG5cdCAgICAgICcgejogJyArIHRoaXMuei50b1N0cmluZygxNiwgMikgKyAnPic7XG5cdH07XG5cblx0SlBvaW50LnByb3RvdHlwZS5pc0luZmluaXR5ID0gZnVuY3Rpb24gaXNJbmZpbml0eSgpIHtcblx0ICAvLyBYWFggVGhpcyBjb2RlIGFzc3VtZXMgdGhhdCB6ZXJvIGlzIGFsd2F5cyB6ZXJvIGluIHJlZFxuXHQgIHJldHVybiB0aGlzLnouY21wbigwKSA9PT0gMDtcblx0fTtcblxuXHR2YXIgbW9udCA9IHt9O1xuXG5cdHZhciBlZHdhcmRzID0ge307XG5cblx0dmFyIGN1cnZlXzEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgY3VydmUgPSBleHBvcnRzO1xuXG5cdGN1cnZlLmJhc2UgPSBiYXNlO1xuXHRjdXJ2ZS5zaG9ydCA9IHNob3J0XzE7XG5cdGN1cnZlLm1vbnQgPSBtb250O1xuXHRjdXJ2ZS5lZHdhcmRzID0gZWR3YXJkcztcblx0fSk7XG5cblx0dmFyIHNlY3AyNTZrMSA9IHVuZGVmaW5lZDtcblxuXHR2YXIgY3VydmVzXzEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgY3VydmVzID0gZXhwb3J0cztcblxuXG5cblxuXG5cdHZhciBhc3NlcnQgPSB1dGlsc18xJDEuYXNzZXJ0O1xuXG5cdGZ1bmN0aW9uIFByZXNldEN1cnZlKG9wdGlvbnMpIHtcblx0ICBpZiAob3B0aW9ucy50eXBlID09PSAnc2hvcnQnKVxuXHQgICAgdGhpcy5jdXJ2ZSA9IG5ldyBjdXJ2ZV8xLnNob3J0KG9wdGlvbnMpO1xuXHQgIGVsc2UgaWYgKG9wdGlvbnMudHlwZSA9PT0gJ2Vkd2FyZHMnKVxuXHQgICAgdGhpcy5jdXJ2ZSA9IG5ldyBjdXJ2ZV8xLmVkd2FyZHMob3B0aW9ucyk7XG5cdCAgZWxzZVxuXHQgICAgdGhpcy5jdXJ2ZSA9IG5ldyBjdXJ2ZV8xLm1vbnQob3B0aW9ucyk7XG5cdCAgdGhpcy5nID0gdGhpcy5jdXJ2ZS5nO1xuXHQgIHRoaXMubiA9IHRoaXMuY3VydmUubjtcblx0ICB0aGlzLmhhc2ggPSBvcHRpb25zLmhhc2g7XG5cblx0ICBhc3NlcnQodGhpcy5nLnZhbGlkYXRlKCksICdJbnZhbGlkIGN1cnZlJyk7XG5cdCAgYXNzZXJ0KHRoaXMuZy5tdWwodGhpcy5uKS5pc0luZmluaXR5KCksICdJbnZhbGlkIGN1cnZlLCBHKk4gIT0gTycpO1xuXHR9XG5cdGN1cnZlcy5QcmVzZXRDdXJ2ZSA9IFByZXNldEN1cnZlO1xuXG5cdGZ1bmN0aW9uIGRlZmluZUN1cnZlKG5hbWUsIG9wdGlvbnMpIHtcblx0ICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VydmVzLCBuYW1lLCB7XG5cdCAgICBjb25maWd1cmFibGU6IHRydWUsXG5cdCAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXHQgICAgZ2V0OiBmdW5jdGlvbigpIHtcblx0ICAgICAgdmFyIGN1cnZlID0gbmV3IFByZXNldEN1cnZlKG9wdGlvbnMpO1xuXHQgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VydmVzLCBuYW1lLCB7XG5cdCAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuXHQgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cdCAgICAgICAgdmFsdWU6IGN1cnZlXG5cdCAgICAgIH0pO1xuXHQgICAgICByZXR1cm4gY3VydmU7XG5cdCAgICB9XG5cdCAgfSk7XG5cdH1cblxuXHRkZWZpbmVDdXJ2ZSgncDE5MicsIHtcblx0ICB0eXBlOiAnc2hvcnQnLFxuXHQgIHByaW1lOiAncDE5MicsXG5cdCAgcDogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmZmZmIGZmZmZmZmZmJyxcblx0ICBhOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZmZmYgZmZmZmZmZmMnLFxuXHQgIGI6ICc2NDIxMDUxOSBlNTljODBlNyAwZmE3ZTlhYiA3MjI0MzA0OSBmZWI4ZGVlYyBjMTQ2YjliMScsXG5cdCAgbjogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIDk5ZGVmODM2IDE0NmJjOWIxIGI0ZDIyODMxJyxcblx0ICBoYXNoOiBoYXNoXzEuc2hhMjU2LFxuXHQgIGdSZWQ6IGZhbHNlLFxuXHQgIGc6IFtcblx0ICAgICcxODhkYTgwZSBiMDMwOTBmNiA3Y2JmMjBlYiA0M2ExODgwMCBmNGZmMGFmZCA4MmZmMTAxMicsXG5cdCAgICAnMDcxOTJiOTUgZmZjOGRhNzggNjMxMDExZWQgNmIyNGNkZDUgNzNmOTc3YTEgMWU3OTQ4MTEnXG5cdCAgXVxuXHR9KTtcblxuXHRkZWZpbmVDdXJ2ZSgncDIyNCcsIHtcblx0ICB0eXBlOiAnc2hvcnQnLFxuXHQgIHByaW1lOiAncDIyNCcsXG5cdCAgcDogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAxJyxcblx0ICBhOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUnLFxuXHQgIGI6ICdiNDA1MGE4NSAwYzA0YjNhYiBmNTQxMzI1NiA1MDQ0YjBiNyBkN2JmZDhiYSAyNzBiMzk0MyAyMzU1ZmZiNCcsXG5cdCAgbjogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmYxNmEyIGUwYjhmMDNlIDEzZGQyOTQ1IDVjNWMyYTNkJyxcblx0ICBoYXNoOiBoYXNoXzEuc2hhMjU2LFxuXHQgIGdSZWQ6IGZhbHNlLFxuXHQgIGc6IFtcblx0ICAgICdiNzBlMGNiZCA2YmI0YmY3ZiAzMjEzOTBiOSA0YTAzYzFkMyA1NmMyMTEyMiAzNDMyODBkNiAxMTVjMWQyMScsXG5cdCAgICAnYmQzNzYzODggYjVmNzIzZmIgNGMyMmRmZTYgY2Q0Mzc1YTAgNWEwNzQ3NjQgNDRkNTgxOTkgODUwMDdlMzQnXG5cdCAgXVxuXHR9KTtcblxuXHRkZWZpbmVDdXJ2ZSgncDI1NicsIHtcblx0ICB0eXBlOiAnc2hvcnQnLFxuXHQgIHByaW1lOiBudWxsLFxuXHQgIHA6ICdmZmZmZmZmZiAwMDAwMDAwMSAwMDAwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMCBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZicsXG5cdCAgYTogJ2ZmZmZmZmZmIDAwMDAwMDAxIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAwIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZjJyxcblx0ICBiOiAnNWFjNjM1ZDggYWEzYTkzZTcgYjNlYmJkNTUgNzY5ODg2YmMgNjUxZDA2YjAgY2M1M2IwZjYgM2JjZTNjM2UgMjdkMjYwNGInLFxuXHQgIG46ICdmZmZmZmZmZiAwMDAwMDAwMCBmZmZmZmZmZiBmZmZmZmZmZiBiY2U2ZmFhZCBhNzE3OWU4NCBmM2I5Y2FjMiBmYzYzMjU1MScsXG5cdCAgaGFzaDogaGFzaF8xLnNoYTI1Nixcblx0ICBnUmVkOiBmYWxzZSxcblx0ICBnOiBbXG5cdCAgICAnNmIxN2QxZjIgZTEyYzQyNDcgZjhiY2U2ZTUgNjNhNDQwZjIgNzcwMzdkODEgMmRlYjMzYTAgZjRhMTM5NDUgZDg5OGMyOTYnLFxuXHQgICAgJzRmZTM0MmUyIGZlMWE3ZjliIDhlZTdlYjRhIDdjMGY5ZTE2IDJiY2UzMzU3IDZiMzE1ZWNlIGNiYjY0MDY4IDM3YmY1MWY1J1xuXHQgIF1cblx0fSk7XG5cblx0ZGVmaW5lQ3VydmUoJ3AzODQnLCB7XG5cdCAgdHlwZTogJ3Nob3J0Jyxcblx0ICBwcmltZTogbnVsbCxcblx0ICBwOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgJyArXG5cdCAgICAgJ2ZmZmZmZmZlIGZmZmZmZmZmIDAwMDAwMDAwIDAwMDAwMDAwIGZmZmZmZmZmJyxcblx0ICBhOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgJyArXG5cdCAgICAgJ2ZmZmZmZmZlIGZmZmZmZmZmIDAwMDAwMDAwIDAwMDAwMDAwIGZmZmZmZmZjJyxcblx0ICBiOiAnYjMzMTJmYTcgZTIzZWU3ZTQgOTg4ZTA1NmIgZTNmODJkMTkgMTgxZDljNmUgZmU4MTQxMTIgMDMxNDA4OGYgJyArXG5cdCAgICAgJzUwMTM4NzVhIGM2NTYzOThkIDhhMmVkMTlkIDJhODVjOGVkIGQzZWMyYWVmJyxcblx0ICBuOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgYzc2MzRkODEgJyArXG5cdCAgICAgJ2Y0MzcyZGRmIDU4MWEwZGIyIDQ4YjBhNzdhIGVjZWMxOTZhIGNjYzUyOTczJyxcblx0ICBoYXNoOiBoYXNoXzEuc2hhMzg0LFxuXHQgIGdSZWQ6IGZhbHNlLFxuXHQgIGc6IFtcblx0ICAgICdhYTg3Y2EyMiBiZThiMDUzNyA4ZWIxYzcxZSBmMzIwYWQ3NCA2ZTFkM2I2MiA4YmE3OWI5OCA1OWY3NDFlMCA4MjU0MmEzOCAnICtcblx0ICAgICc1NTAyZjI1ZCBiZjU1Mjk2YyAzYTU0NWUzOCA3Mjc2MGFiNycsXG5cdCAgICAnMzYxN2RlNGEgOTYyNjJjNmYgNWQ5ZTk4YmYgOTI5MmRjMjkgZjhmNDFkYmQgMjg5YTE0N2MgZTlkYTMxMTMgYjVmMGI4YzAgJyArXG5cdCAgICAnMGE2MGIxY2UgMWQ3ZTgxOWQgN2E0MzFkN2MgOTBlYTBlNWYnXG5cdCAgXVxuXHR9KTtcblxuXHRkZWZpbmVDdXJ2ZSgncDUyMScsIHtcblx0ICB0eXBlOiAnc2hvcnQnLFxuXHQgIHByaW1lOiBudWxsLFxuXHQgIHA6ICcwMDAwMDFmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAnICtcblx0ICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgJyArXG5cdCAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmJyxcblx0ICBhOiAnMDAwMDAxZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgJyArXG5cdCAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmICcgK1xuXHQgICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmYycsXG5cdCAgYjogJzAwMDAwMDUxIDk1M2ViOTYxIDhlMWM5YTFmIDkyOWEyMWEwIGI2ODU0MGVlIGEyZGE3MjViICcgK1xuXHQgICAgICc5OWIzMTVmMyBiOGI0ODk5MSA4ZWYxMDllMSA1NjE5Mzk1MSBlYzdlOTM3YiAxNjUyYzBiZCAnICtcblx0ICAgICAnM2JiMWJmMDcgMzU3M2RmODggM2QyYzM0ZjEgZWY0NTFmZDQgNmI1MDNmMDAnLFxuXHQgIG46ICcwMDAwMDFmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAnICtcblx0ICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmEgNTE4Njg3ODMgYmYyZjk2NmIgN2ZjYzAxNDggJyArXG5cdCAgICAgJ2Y3MDlhNWQwIDNiYjVjOWI4IDg5OWM0N2FlIGJiNmZiNzFlIDkxMzg2NDA5Jyxcblx0ICBoYXNoOiBoYXNoXzEuc2hhNTEyLFxuXHQgIGdSZWQ6IGZhbHNlLFxuXHQgIGc6IFtcblx0ICAgICcwMDAwMDBjNiA4NThlMDZiNyAwNDA0ZTljZCA5ZTNlY2I2NiAyMzk1YjQ0MiA5YzY0ODEzOSAnICtcblx0ICAgICcwNTNmYjUyMSBmODI4YWY2MCA2YjRkM2RiYSBhMTRiNWU3NyBlZmU3NTkyOCBmZTFkYzEyNyAnICtcblx0ICAgICdhMmZmYThkZSAzMzQ4YjNjMSA4NTZhNDI5YiBmOTdlN2UzMSBjMmU1YmQ2NicsXG5cdCAgICAnMDAwMDAxMTggMzkyOTZhNzggOWEzYmMwMDQgNWM4YTVmYjQgMmM3ZDFiZDkgOThmNTQ0NDkgJyArXG5cdCAgICAnNTc5YjQ0NjggMTdhZmJkMTcgMjczZTY2MmMgOTdlZTcyOTkgNWVmNDI2NDAgYzU1MGI5MDEgJyArXG5cdCAgICAnM2ZhZDA3NjEgMzUzYzcwODYgYTI3MmMyNDAgODhiZTk0NzYgOWZkMTY2NTAnXG5cdCAgXVxuXHR9KTtcblxuXHRkZWZpbmVDdXJ2ZSgnY3VydmUyNTUxOScsIHtcblx0ICB0eXBlOiAnbW9udCcsXG5cdCAgcHJpbWU6ICdwMjU1MTknLFxuXHQgIHA6ICc3ZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmVkJyxcblx0ICBhOiAnNzZkMDYnLFxuXHQgIGI6ICcxJyxcblx0ICBuOiAnMTAwMDAwMDAwMDAwMDAwMCAwMDAwMDAwMDAwMDAwMDAwIDE0ZGVmOWRlYTJmNzljZDYgNTgxMjYzMWE1Y2Y1ZDNlZCcsXG5cdCAgaGFzaDogaGFzaF8xLnNoYTI1Nixcblx0ICBnUmVkOiBmYWxzZSxcblx0ICBnOiBbXG5cdCAgICAnOSdcblx0ICBdXG5cdH0pO1xuXG5cdGRlZmluZUN1cnZlKCdlZDI1NTE5Jywge1xuXHQgIHR5cGU6ICdlZHdhcmRzJyxcblx0ICBwcmltZTogJ3AyNTUxOScsXG5cdCAgcDogJzdmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZWQnLFxuXHQgIGE6ICctMScsXG5cdCAgYzogJzEnLFxuXHQgIC8vIC0xMjE2NjUgKiAoMTIxNjY2XigtMSkpIChtb2QgUClcblx0ICBkOiAnNTIwMzZjZWUyYjZmZmU3MyA4Y2M3NDA3OTc3NzllODk4IDAwNzAwYTRkNDE0MWQ4YWIgNzVlYjRkY2ExMzU5NzhhMycsXG5cdCAgbjogJzEwMDAwMDAwMDAwMDAwMDAgMDAwMDAwMDAwMDAwMDAwMCAxNGRlZjlkZWEyZjc5Y2Q2IDU4MTI2MzFhNWNmNWQzZWQnLFxuXHQgIGhhc2g6IGhhc2hfMS5zaGEyNTYsXG5cdCAgZ1JlZDogZmFsc2UsXG5cdCAgZzogW1xuXHQgICAgJzIxNjkzNmQzY2Q2ZTUzZmVjMGE0ZTIzMWZkZDZkYzVjNjkyY2M3NjA5NTI1YTdiMmM5NTYyZDYwOGYyNWQ1MWEnLFxuXG5cdCAgICAvLyA0LzVcblx0ICAgICc2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjU4J1xuXHQgIF1cblx0fSk7XG5cblx0dmFyIHByZTtcblx0dHJ5IHtcblx0ICBwcmUgPSBzZWNwMjU2azE7XG5cdH0gY2F0Y2ggKGUpIHtcblx0ICBwcmUgPSB1bmRlZmluZWQ7XG5cdH1cblxuXHRkZWZpbmVDdXJ2ZSgnc2VjcDI1NmsxJywge1xuXHQgIHR5cGU6ICdzaG9ydCcsXG5cdCAgcHJpbWU6ICdrMjU2Jyxcblx0ICBwOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZjMmYnLFxuXHQgIGE6ICcwJyxcblx0ICBiOiAnNycsXG5cdCAgbjogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGJhYWVkY2U2IGFmNDhhMDNiIGJmZDI1ZThjIGQwMzY0MTQxJyxcblx0ICBoOiAnMScsXG5cdCAgaGFzaDogaGFzaF8xLnNoYTI1NixcblxuXHQgIC8vIFByZWNvbXB1dGVkIGVuZG9tb3JwaGlzbVxuXHQgIGJldGE6ICc3YWU5NmEyYjY1N2MwNzEwNmU2NDQ3OWVhYzM0MzRlOTljZjA0OTc1MTJmNTg5OTVjMTM5NmMyODcxOTUwMWVlJyxcblx0ICBsYW1iZGE6ICc1MzYzYWQ0Y2MwNWMzMGUwYTUyNjFjMDI4ODEyNjQ1YTEyMmUyMmVhMjA4MTY2NzhkZjAyOTY3YzFiMjNiZDcyJyxcblx0ICBiYXNpczogW1xuXHQgICAge1xuXHQgICAgICBhOiAnMzA4NmQyMjFhN2Q0NmJjZGU4NmM5MGU0OTI4NGViMTUnLFxuXHQgICAgICBiOiAnLWU0NDM3ZWQ2MDEwZTg4Mjg2ZjU0N2ZhOTBhYmZlNGMzJ1xuXHQgICAgfSxcblx0ICAgIHtcblx0ICAgICAgYTogJzExNGNhNTBmN2E4ZTJmM2Y2NTdjMTEwOGQ5ZDQ0Y2ZkOCcsXG5cdCAgICAgIGI6ICczMDg2ZDIyMWE3ZDQ2YmNkZTg2YzkwZTQ5Mjg0ZWIxNSdcblx0ICAgIH1cblx0ICBdLFxuXG5cdCAgZ1JlZDogZmFsc2UsXG5cdCAgZzogW1xuXHQgICAgJzc5YmU2NjdlZjlkY2JiYWM1NWEwNjI5NWNlODcwYjA3MDI5YmZjZGIyZGNlMjhkOTU5ZjI4MTViMTZmODE3OTgnLFxuXHQgICAgJzQ4M2FkYTc3MjZhM2M0NjU1ZGE0ZmJmYzBlMTEwOGE4ZmQxN2I0NDhhNjg1NTQxOTljNDdkMDhmZmIxMGQ0YjgnLFxuXHQgICAgcHJlXG5cdCAgXVxuXHR9KTtcblx0fSk7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cblxuXG5cblx0ZnVuY3Rpb24gSG1hY0RSQkcob3B0aW9ucykge1xuXHQgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBIbWFjRFJCRykpXG5cdCAgICByZXR1cm4gbmV3IEhtYWNEUkJHKG9wdGlvbnMpO1xuXHQgIHRoaXMuaGFzaCA9IG9wdGlvbnMuaGFzaDtcblx0ICB0aGlzLnByZWRSZXNpc3QgPSAhIW9wdGlvbnMucHJlZFJlc2lzdDtcblxuXHQgIHRoaXMub3V0TGVuID0gdGhpcy5oYXNoLm91dFNpemU7XG5cdCAgdGhpcy5taW5FbnRyb3B5ID0gb3B0aW9ucy5taW5FbnRyb3B5IHx8IHRoaXMuaGFzaC5obWFjU3RyZW5ndGg7XG5cblx0ICB0aGlzLl9yZXNlZWQgPSBudWxsO1xuXHQgIHRoaXMucmVzZWVkSW50ZXJ2YWwgPSBudWxsO1xuXHQgIHRoaXMuSyA9IG51bGw7XG5cdCAgdGhpcy5WID0gbnVsbDtcblxuXHQgIHZhciBlbnRyb3B5ID0gdXRpbHNfMS50b0FycmF5KG9wdGlvbnMuZW50cm9weSwgb3B0aW9ucy5lbnRyb3B5RW5jIHx8ICdoZXgnKTtcblx0ICB2YXIgbm9uY2UgPSB1dGlsc18xLnRvQXJyYXkob3B0aW9ucy5ub25jZSwgb3B0aW9ucy5ub25jZUVuYyB8fCAnaGV4Jyk7XG5cdCAgdmFyIHBlcnMgPSB1dGlsc18xLnRvQXJyYXkob3B0aW9ucy5wZXJzLCBvcHRpb25zLnBlcnNFbmMgfHwgJ2hleCcpO1xuXHQgIG1pbmltYWxpc3RpY0Fzc2VydChlbnRyb3B5Lmxlbmd0aCA+PSAodGhpcy5taW5FbnRyb3B5IC8gOCksXG5cdCAgICAgICAgICdOb3QgZW5vdWdoIGVudHJvcHkuIE1pbmltdW0gaXM6ICcgKyB0aGlzLm1pbkVudHJvcHkgKyAnIGJpdHMnKTtcblx0ICB0aGlzLl9pbml0KGVudHJvcHksIG5vbmNlLCBwZXJzKTtcblx0fVxuXHR2YXIgaG1hY0RyYmcgPSBIbWFjRFJCRztcblxuXHRIbWFjRFJCRy5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiBpbml0KGVudHJvcHksIG5vbmNlLCBwZXJzKSB7XG5cdCAgdmFyIHNlZWQgPSBlbnRyb3B5LmNvbmNhdChub25jZSkuY29uY2F0KHBlcnMpO1xuXG5cdCAgdGhpcy5LID0gbmV3IEFycmF5KHRoaXMub3V0TGVuIC8gOCk7XG5cdCAgdGhpcy5WID0gbmV3IEFycmF5KHRoaXMub3V0TGVuIC8gOCk7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLlYubGVuZ3RoOyBpKyspIHtcblx0ICAgIHRoaXMuS1tpXSA9IDB4MDA7XG5cdCAgICB0aGlzLlZbaV0gPSAweDAxO1xuXHQgIH1cblxuXHQgIHRoaXMuX3VwZGF0ZShzZWVkKTtcblx0ICB0aGlzLl9yZXNlZWQgPSAxO1xuXHQgIHRoaXMucmVzZWVkSW50ZXJ2YWwgPSAweDEwMDAwMDAwMDAwMDA7ICAvLyAyXjQ4XG5cdH07XG5cblx0SG1hY0RSQkcucHJvdG90eXBlLl9obWFjID0gZnVuY3Rpb24gaG1hYygpIHtcblx0ICByZXR1cm4gbmV3IGhhc2hfMS5obWFjKHRoaXMuaGFzaCwgdGhpcy5LKTtcblx0fTtcblxuXHRIbWFjRFJCRy5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShzZWVkKSB7XG5cdCAgdmFyIGttYWMgPSB0aGlzLl9obWFjKClcblx0ICAgICAgICAgICAgICAgICAudXBkYXRlKHRoaXMuVilcblx0ICAgICAgICAgICAgICAgICAudXBkYXRlKFsgMHgwMCBdKTtcblx0ICBpZiAoc2VlZClcblx0ICAgIGttYWMgPSBrbWFjLnVwZGF0ZShzZWVkKTtcblx0ICB0aGlzLksgPSBrbWFjLmRpZ2VzdCgpO1xuXHQgIHRoaXMuViA9IHRoaXMuX2htYWMoKS51cGRhdGUodGhpcy5WKS5kaWdlc3QoKTtcblx0ICBpZiAoIXNlZWQpXG5cdCAgICByZXR1cm47XG5cblx0ICB0aGlzLksgPSB0aGlzLl9obWFjKClcblx0ICAgICAgICAgICAgICAgLnVwZGF0ZSh0aGlzLlYpXG5cdCAgICAgICAgICAgICAgIC51cGRhdGUoWyAweDAxIF0pXG5cdCAgICAgICAgICAgICAgIC51cGRhdGUoc2VlZClcblx0ICAgICAgICAgICAgICAgLmRpZ2VzdCgpO1xuXHQgIHRoaXMuViA9IHRoaXMuX2htYWMoKS51cGRhdGUodGhpcy5WKS5kaWdlc3QoKTtcblx0fTtcblxuXHRIbWFjRFJCRy5wcm90b3R5cGUucmVzZWVkID0gZnVuY3Rpb24gcmVzZWVkKGVudHJvcHksIGVudHJvcHlFbmMsIGFkZCwgYWRkRW5jKSB7XG5cdCAgLy8gT3B0aW9uYWwgZW50cm9weSBlbmNcblx0ICBpZiAodHlwZW9mIGVudHJvcHlFbmMgIT09ICdzdHJpbmcnKSB7XG5cdCAgICBhZGRFbmMgPSBhZGQ7XG5cdCAgICBhZGQgPSBlbnRyb3B5RW5jO1xuXHQgICAgZW50cm9weUVuYyA9IG51bGw7XG5cdCAgfVxuXG5cdCAgZW50cm9weSA9IHV0aWxzXzEudG9BcnJheShlbnRyb3B5LCBlbnRyb3B5RW5jKTtcblx0ICBhZGQgPSB1dGlsc18xLnRvQXJyYXkoYWRkLCBhZGRFbmMpO1xuXG5cdCAgbWluaW1hbGlzdGljQXNzZXJ0KGVudHJvcHkubGVuZ3RoID49ICh0aGlzLm1pbkVudHJvcHkgLyA4KSxcblx0ICAgICAgICAgJ05vdCBlbm91Z2ggZW50cm9weS4gTWluaW11bSBpczogJyArIHRoaXMubWluRW50cm9weSArICcgYml0cycpO1xuXG5cdCAgdGhpcy5fdXBkYXRlKGVudHJvcHkuY29uY2F0KGFkZCB8fCBbXSkpO1xuXHQgIHRoaXMuX3Jlc2VlZCA9IDE7XG5cdH07XG5cblx0SG1hY0RSQkcucHJvdG90eXBlLmdlbmVyYXRlID0gZnVuY3Rpb24gZ2VuZXJhdGUobGVuLCBlbmMsIGFkZCwgYWRkRW5jKSB7XG5cdCAgaWYgKHRoaXMuX3Jlc2VlZCA+IHRoaXMucmVzZWVkSW50ZXJ2YWwpXG5cdCAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc2VlZCBpcyByZXF1aXJlZCcpO1xuXG5cdCAgLy8gT3B0aW9uYWwgZW5jb2Rpbmdcblx0ICBpZiAodHlwZW9mIGVuYyAhPT0gJ3N0cmluZycpIHtcblx0ICAgIGFkZEVuYyA9IGFkZDtcblx0ICAgIGFkZCA9IGVuYztcblx0ICAgIGVuYyA9IG51bGw7XG5cdCAgfVxuXG5cdCAgLy8gT3B0aW9uYWwgYWRkaXRpb25hbCBkYXRhXG5cdCAgaWYgKGFkZCkge1xuXHQgICAgYWRkID0gdXRpbHNfMS50b0FycmF5KGFkZCwgYWRkRW5jIHx8ICdoZXgnKTtcblx0ICAgIHRoaXMuX3VwZGF0ZShhZGQpO1xuXHQgIH1cblxuXHQgIHZhciB0ZW1wID0gW107XG5cdCAgd2hpbGUgKHRlbXAubGVuZ3RoIDwgbGVuKSB7XG5cdCAgICB0aGlzLlYgPSB0aGlzLl9obWFjKCkudXBkYXRlKHRoaXMuVikuZGlnZXN0KCk7XG5cdCAgICB0ZW1wID0gdGVtcC5jb25jYXQodGhpcy5WKTtcblx0ICB9XG5cblx0ICB2YXIgcmVzID0gdGVtcC5zbGljZSgwLCBsZW4pO1xuXHQgIHRoaXMuX3VwZGF0ZShhZGQpO1xuXHQgIHRoaXMuX3Jlc2VlZCsrO1xuXHQgIHJldHVybiB1dGlsc18xLmVuY29kZShyZXMsIGVuYyk7XG5cdH07XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cblxuXHR2YXIgYXNzZXJ0JDMgPSB1dGlsc18xJDEuYXNzZXJ0O1xuXG5cdGZ1bmN0aW9uIEtleVBhaXIoZWMsIG9wdGlvbnMpIHtcblx0ICB0aGlzLmVjID0gZWM7XG5cdCAgdGhpcy5wcml2ID0gbnVsbDtcblx0ICB0aGlzLnB1YiA9IG51bGw7XG5cblx0ICAvLyBLZXlQYWlyKGVjLCB7IHByaXY6IC4uLiwgcHViOiAuLi4gfSlcblx0ICBpZiAob3B0aW9ucy5wcml2KVxuXHQgICAgdGhpcy5faW1wb3J0UHJpdmF0ZShvcHRpb25zLnByaXYsIG9wdGlvbnMucHJpdkVuYyk7XG5cdCAgaWYgKG9wdGlvbnMucHViKVxuXHQgICAgdGhpcy5faW1wb3J0UHVibGljKG9wdGlvbnMucHViLCBvcHRpb25zLnB1YkVuYyk7XG5cdH1cblx0dmFyIGtleSA9IEtleVBhaXI7XG5cblx0S2V5UGFpci5mcm9tUHVibGljID0gZnVuY3Rpb24gZnJvbVB1YmxpYyhlYywgcHViLCBlbmMpIHtcblx0ICBpZiAocHViIGluc3RhbmNlb2YgS2V5UGFpcilcblx0ICAgIHJldHVybiBwdWI7XG5cblx0ICByZXR1cm4gbmV3IEtleVBhaXIoZWMsIHtcblx0ICAgIHB1YjogcHViLFxuXHQgICAgcHViRW5jOiBlbmNcblx0ICB9KTtcblx0fTtcblxuXHRLZXlQYWlyLmZyb21Qcml2YXRlID0gZnVuY3Rpb24gZnJvbVByaXZhdGUoZWMsIHByaXYsIGVuYykge1xuXHQgIGlmIChwcml2IGluc3RhbmNlb2YgS2V5UGFpcilcblx0ICAgIHJldHVybiBwcml2O1xuXG5cdCAgcmV0dXJuIG5ldyBLZXlQYWlyKGVjLCB7XG5cdCAgICBwcml2OiBwcml2LFxuXHQgICAgcHJpdkVuYzogZW5jXG5cdCAgfSk7XG5cdH07XG5cblx0S2V5UGFpci5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZSgpIHtcblx0ICB2YXIgcHViID0gdGhpcy5nZXRQdWJsaWMoKTtcblxuXHQgIGlmIChwdWIuaXNJbmZpbml0eSgpKVxuXHQgICAgcmV0dXJuIHsgcmVzdWx0OiBmYWxzZSwgcmVhc29uOiAnSW52YWxpZCBwdWJsaWMga2V5JyB9O1xuXHQgIGlmICghcHViLnZhbGlkYXRlKCkpXG5cdCAgICByZXR1cm4geyByZXN1bHQ6IGZhbHNlLCByZWFzb246ICdQdWJsaWMga2V5IGlzIG5vdCBhIHBvaW50JyB9O1xuXHQgIGlmICghcHViLm11bCh0aGlzLmVjLmN1cnZlLm4pLmlzSW5maW5pdHkoKSlcblx0ICAgIHJldHVybiB7IHJlc3VsdDogZmFsc2UsIHJlYXNvbjogJ1B1YmxpYyBrZXkgKiBOICE9IE8nIH07XG5cblx0ICByZXR1cm4geyByZXN1bHQ6IHRydWUsIHJlYXNvbjogbnVsbCB9O1xuXHR9O1xuXG5cdEtleVBhaXIucHJvdG90eXBlLmdldFB1YmxpYyA9IGZ1bmN0aW9uIGdldFB1YmxpYyhjb21wYWN0LCBlbmMpIHtcblx0ICAvLyBjb21wYWN0IGlzIG9wdGlvbmFsIGFyZ3VtZW50XG5cdCAgaWYgKHR5cGVvZiBjb21wYWN0ID09PSAnc3RyaW5nJykge1xuXHQgICAgZW5jID0gY29tcGFjdDtcblx0ICAgIGNvbXBhY3QgPSBudWxsO1xuXHQgIH1cblxuXHQgIGlmICghdGhpcy5wdWIpXG5cdCAgICB0aGlzLnB1YiA9IHRoaXMuZWMuZy5tdWwodGhpcy5wcml2KTtcblxuXHQgIGlmICghZW5jKVxuXHQgICAgcmV0dXJuIHRoaXMucHViO1xuXG5cdCAgcmV0dXJuIHRoaXMucHViLmVuY29kZShlbmMsIGNvbXBhY3QpO1xuXHR9O1xuXG5cdEtleVBhaXIucHJvdG90eXBlLmdldFByaXZhdGUgPSBmdW5jdGlvbiBnZXRQcml2YXRlKGVuYykge1xuXHQgIGlmIChlbmMgPT09ICdoZXgnKVxuXHQgICAgcmV0dXJuIHRoaXMucHJpdi50b1N0cmluZygxNiwgMik7XG5cdCAgZWxzZVxuXHQgICAgcmV0dXJuIHRoaXMucHJpdjtcblx0fTtcblxuXHRLZXlQYWlyLnByb3RvdHlwZS5faW1wb3J0UHJpdmF0ZSA9IGZ1bmN0aW9uIF9pbXBvcnRQcml2YXRlKGtleSwgZW5jKSB7XG5cdCAgdGhpcy5wcml2ID0gbmV3IGJuJDEoa2V5LCBlbmMgfHwgMTYpO1xuXG5cdCAgLy8gRW5zdXJlIHRoYXQgdGhlIHByaXYgd29uJ3QgYmUgYmlnZ2VyIHRoYW4gbiwgb3RoZXJ3aXNlIHdlIG1heSBmYWlsXG5cdCAgLy8gaW4gZml4ZWQgbXVsdGlwbGljYXRpb24gbWV0aG9kXG5cdCAgdGhpcy5wcml2ID0gdGhpcy5wcml2LnVtb2QodGhpcy5lYy5jdXJ2ZS5uKTtcblx0fTtcblxuXHRLZXlQYWlyLnByb3RvdHlwZS5faW1wb3J0UHVibGljID0gZnVuY3Rpb24gX2ltcG9ydFB1YmxpYyhrZXksIGVuYykge1xuXHQgIGlmIChrZXkueCB8fCBrZXkueSkge1xuXHQgICAgLy8gTW9udGdvbWVyeSBwb2ludHMgb25seSBoYXZlIGFuIGB4YCBjb29yZGluYXRlLlxuXHQgICAgLy8gV2VpZXJzdHJhc3MvRWR3YXJkcyBwb2ludHMgb24gdGhlIG90aGVyIGhhbmQgaGF2ZSBib3RoIGB4YCBhbmRcblx0ICAgIC8vIGB5YCBjb29yZGluYXRlcy5cblx0ICAgIGlmICh0aGlzLmVjLmN1cnZlLnR5cGUgPT09ICdtb250Jykge1xuXHQgICAgICBhc3NlcnQkMyhrZXkueCwgJ05lZWQgeCBjb29yZGluYXRlJyk7XG5cdCAgICB9IGVsc2UgaWYgKHRoaXMuZWMuY3VydmUudHlwZSA9PT0gJ3Nob3J0JyB8fFxuXHQgICAgICAgICAgICAgICB0aGlzLmVjLmN1cnZlLnR5cGUgPT09ICdlZHdhcmRzJykge1xuXHQgICAgICBhc3NlcnQkMyhrZXkueCAmJiBrZXkueSwgJ05lZWQgYm90aCB4IGFuZCB5IGNvb3JkaW5hdGUnKTtcblx0ICAgIH1cblx0ICAgIHRoaXMucHViID0gdGhpcy5lYy5jdXJ2ZS5wb2ludChrZXkueCwga2V5LnkpO1xuXHQgICAgcmV0dXJuO1xuXHQgIH1cblx0ICB0aGlzLnB1YiA9IHRoaXMuZWMuY3VydmUuZGVjb2RlUG9pbnQoa2V5LCBlbmMpO1xuXHR9O1xuXG5cdC8vIEVDREhcblx0S2V5UGFpci5wcm90b3R5cGUuZGVyaXZlID0gZnVuY3Rpb24gZGVyaXZlKHB1Yikge1xuXHQgIHJldHVybiBwdWIubXVsKHRoaXMucHJpdikuZ2V0WCgpO1xuXHR9O1xuXG5cdC8vIEVDRFNBXG5cdEtleVBhaXIucHJvdG90eXBlLnNpZ24gPSBmdW5jdGlvbiBzaWduKG1zZywgZW5jLCBvcHRpb25zKSB7XG5cdCAgcmV0dXJuIHRoaXMuZWMuc2lnbihtc2csIHRoaXMsIGVuYywgb3B0aW9ucyk7XG5cdH07XG5cblx0S2V5UGFpci5wcm90b3R5cGUudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1zZywgc2lnbmF0dXJlKSB7XG5cdCAgcmV0dXJuIHRoaXMuZWMudmVyaWZ5KG1zZywgc2lnbmF0dXJlLCB0aGlzKTtcblx0fTtcblxuXHRLZXlQYWlyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCgpIHtcblx0ICByZXR1cm4gJzxLZXkgcHJpdjogJyArICh0aGlzLnByaXYgJiYgdGhpcy5wcml2LnRvU3RyaW5nKDE2LCAyKSkgK1xuXHQgICAgICAgICAnIHB1YjogJyArICh0aGlzLnB1YiAmJiB0aGlzLnB1Yi5pbnNwZWN0KCkpICsgJyA+Jztcblx0fTtcblxuXHQndXNlIHN0cmljdCc7XG5cblxuXG5cblx0dmFyIGFzc2VydCQ0ID0gdXRpbHNfMSQxLmFzc2VydDtcblxuXHRmdW5jdGlvbiBTaWduYXR1cmUob3B0aW9ucywgZW5jKSB7XG5cdCAgaWYgKG9wdGlvbnMgaW5zdGFuY2VvZiBTaWduYXR1cmUpXG5cdCAgICByZXR1cm4gb3B0aW9ucztcblxuXHQgIGlmICh0aGlzLl9pbXBvcnRERVIob3B0aW9ucywgZW5jKSlcblx0ICAgIHJldHVybjtcblxuXHQgIGFzc2VydCQ0KG9wdGlvbnMuciAmJiBvcHRpb25zLnMsICdTaWduYXR1cmUgd2l0aG91dCByIG9yIHMnKTtcblx0ICB0aGlzLnIgPSBuZXcgYm4kMShvcHRpb25zLnIsIDE2KTtcblx0ICB0aGlzLnMgPSBuZXcgYm4kMShvcHRpb25zLnMsIDE2KTtcblx0ICBpZiAob3B0aW9ucy5yZWNvdmVyeVBhcmFtID09PSB1bmRlZmluZWQpXG5cdCAgICB0aGlzLnJlY292ZXJ5UGFyYW0gPSBudWxsO1xuXHQgIGVsc2Vcblx0ICAgIHRoaXMucmVjb3ZlcnlQYXJhbSA9IG9wdGlvbnMucmVjb3ZlcnlQYXJhbTtcblx0fVxuXHR2YXIgc2lnbmF0dXJlID0gU2lnbmF0dXJlO1xuXG5cdGZ1bmN0aW9uIFBvc2l0aW9uKCkge1xuXHQgIHRoaXMucGxhY2UgPSAwO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0TGVuZ3RoKGJ1ZiwgcCkge1xuXHQgIHZhciBpbml0aWFsID0gYnVmW3AucGxhY2UrK107XG5cdCAgaWYgKCEoaW5pdGlhbCAmIDB4ODApKSB7XG5cdCAgICByZXR1cm4gaW5pdGlhbDtcblx0ICB9XG5cdCAgdmFyIG9jdGV0TGVuID0gaW5pdGlhbCAmIDB4ZjtcblxuXHQgIC8vIEluZGVmaW5pdGUgbGVuZ3RoIG9yIG92ZXJmbG93XG5cdCAgaWYgKG9jdGV0TGVuID09PSAwIHx8IG9jdGV0TGVuID4gNCkge1xuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH1cblxuXHQgIHZhciB2YWwgPSAwO1xuXHQgIGZvciAodmFyIGkgPSAwLCBvZmYgPSBwLnBsYWNlOyBpIDwgb2N0ZXRMZW47IGkrKywgb2ZmKyspIHtcblx0ICAgIHZhbCA8PD0gODtcblx0ICAgIHZhbCB8PSBidWZbb2ZmXTtcblx0ICAgIHZhbCA+Pj49IDA7XG5cdCAgfVxuXG5cdCAgLy8gTGVhZGluZyB6ZXJvZXNcblx0ICBpZiAodmFsIDw9IDB4N2YpIHtcblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICB9XG5cblx0ICBwLnBsYWNlID0gb2ZmO1xuXHQgIHJldHVybiB2YWw7XG5cdH1cblxuXHRmdW5jdGlvbiBybVBhZGRpbmcoYnVmKSB7XG5cdCAgdmFyIGkgPSAwO1xuXHQgIHZhciBsZW4gPSBidWYubGVuZ3RoIC0gMTtcblx0ICB3aGlsZSAoIWJ1ZltpXSAmJiAhKGJ1ZltpICsgMV0gJiAweDgwKSAmJiBpIDwgbGVuKSB7XG5cdCAgICBpKys7XG5cdCAgfVxuXHQgIGlmIChpID09PSAwKSB7XG5cdCAgICByZXR1cm4gYnVmO1xuXHQgIH1cblx0ICByZXR1cm4gYnVmLnNsaWNlKGkpO1xuXHR9XG5cblx0U2lnbmF0dXJlLnByb3RvdHlwZS5faW1wb3J0REVSID0gZnVuY3Rpb24gX2ltcG9ydERFUihkYXRhLCBlbmMpIHtcblx0ICBkYXRhID0gdXRpbHNfMSQxLnRvQXJyYXkoZGF0YSwgZW5jKTtcblx0ICB2YXIgcCA9IG5ldyBQb3NpdGlvbigpO1xuXHQgIGlmIChkYXRhW3AucGxhY2UrK10gIT09IDB4MzApIHtcblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICB9XG5cdCAgdmFyIGxlbiA9IGdldExlbmd0aChkYXRhLCBwKTtcblx0ICBpZiAobGVuID09PSBmYWxzZSkge1xuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH1cblx0ICBpZiAoKGxlbiArIHAucGxhY2UpICE9PSBkYXRhLmxlbmd0aCkge1xuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH1cblx0ICBpZiAoZGF0YVtwLnBsYWNlKytdICE9PSAweDAyKSB7XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfVxuXHQgIHZhciBybGVuID0gZ2V0TGVuZ3RoKGRhdGEsIHApO1xuXHQgIGlmIChybGVuID09PSBmYWxzZSkge1xuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH1cblx0ICB2YXIgciA9IGRhdGEuc2xpY2UocC5wbGFjZSwgcmxlbiArIHAucGxhY2UpO1xuXHQgIHAucGxhY2UgKz0gcmxlbjtcblx0ICBpZiAoZGF0YVtwLnBsYWNlKytdICE9PSAweDAyKSB7XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfVxuXHQgIHZhciBzbGVuID0gZ2V0TGVuZ3RoKGRhdGEsIHApO1xuXHQgIGlmIChzbGVuID09PSBmYWxzZSkge1xuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH1cblx0ICBpZiAoZGF0YS5sZW5ndGggIT09IHNsZW4gKyBwLnBsYWNlKSB7XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfVxuXHQgIHZhciBzID0gZGF0YS5zbGljZShwLnBsYWNlLCBzbGVuICsgcC5wbGFjZSk7XG5cdCAgaWYgKHJbMF0gPT09IDApIHtcblx0ICAgIGlmIChyWzFdICYgMHg4MCkge1xuXHQgICAgICByID0gci5zbGljZSgxKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIC8vIExlYWRpbmcgemVyb2VzXG5cdCAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIH1cblx0ICB9XG5cdCAgaWYgKHNbMF0gPT09IDApIHtcblx0ICAgIGlmIChzWzFdICYgMHg4MCkge1xuXHQgICAgICBzID0gcy5zbGljZSgxKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIC8vIExlYWRpbmcgemVyb2VzXG5cdCAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICB0aGlzLnIgPSBuZXcgYm4kMShyKTtcblx0ICB0aGlzLnMgPSBuZXcgYm4kMShzKTtcblx0ICB0aGlzLnJlY292ZXJ5UGFyYW0gPSBudWxsO1xuXG5cdCAgcmV0dXJuIHRydWU7XG5cdH07XG5cblx0ZnVuY3Rpb24gY29uc3RydWN0TGVuZ3RoKGFyciwgbGVuKSB7XG5cdCAgaWYgKGxlbiA8IDB4ODApIHtcblx0ICAgIGFyci5wdXNoKGxlbik7XG5cdCAgICByZXR1cm47XG5cdCAgfVxuXHQgIHZhciBvY3RldHMgPSAxICsgKE1hdGgubG9nKGxlbikgLyBNYXRoLkxOMiA+Pj4gMyk7XG5cdCAgYXJyLnB1c2gob2N0ZXRzIHwgMHg4MCk7XG5cdCAgd2hpbGUgKC0tb2N0ZXRzKSB7XG5cdCAgICBhcnIucHVzaCgobGVuID4+PiAob2N0ZXRzIDw8IDMpKSAmIDB4ZmYpO1xuXHQgIH1cblx0ICBhcnIucHVzaChsZW4pO1xuXHR9XG5cblx0U2lnbmF0dXJlLnByb3RvdHlwZS50b0RFUiA9IGZ1bmN0aW9uIHRvREVSKGVuYykge1xuXHQgIHZhciByID0gdGhpcy5yLnRvQXJyYXkoKTtcblx0ICB2YXIgcyA9IHRoaXMucy50b0FycmF5KCk7XG5cblx0ICAvLyBQYWQgdmFsdWVzXG5cdCAgaWYgKHJbMF0gJiAweDgwKVxuXHQgICAgciA9IFsgMCBdLmNvbmNhdChyKTtcblx0ICAvLyBQYWQgdmFsdWVzXG5cdCAgaWYgKHNbMF0gJiAweDgwKVxuXHQgICAgcyA9IFsgMCBdLmNvbmNhdChzKTtcblxuXHQgIHIgPSBybVBhZGRpbmcocik7XG5cdCAgcyA9IHJtUGFkZGluZyhzKTtcblxuXHQgIHdoaWxlICghc1swXSAmJiAhKHNbMV0gJiAweDgwKSkge1xuXHQgICAgcyA9IHMuc2xpY2UoMSk7XG5cdCAgfVxuXHQgIHZhciBhcnIgPSBbIDB4MDIgXTtcblx0ICBjb25zdHJ1Y3RMZW5ndGgoYXJyLCByLmxlbmd0aCk7XG5cdCAgYXJyID0gYXJyLmNvbmNhdChyKTtcblx0ICBhcnIucHVzaCgweDAyKTtcblx0ICBjb25zdHJ1Y3RMZW5ndGgoYXJyLCBzLmxlbmd0aCk7XG5cdCAgdmFyIGJhY2tIYWxmID0gYXJyLmNvbmNhdChzKTtcblx0ICB2YXIgcmVzID0gWyAweDMwIF07XG5cdCAgY29uc3RydWN0TGVuZ3RoKHJlcywgYmFja0hhbGYubGVuZ3RoKTtcblx0ICByZXMgPSByZXMuY29uY2F0KGJhY2tIYWxmKTtcblx0ICByZXR1cm4gdXRpbHNfMSQxLmVuY29kZShyZXMsIGVuYyk7XG5cdH07XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cblxuXG5cblxuXHR2YXIgYXNzZXJ0JDUgPSB1dGlsc18xJDEuYXNzZXJ0O1xuXG5cblxuXG5cdGZ1bmN0aW9uIEVDKG9wdGlvbnMpIHtcblx0ICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRUMpKVxuXHQgICAgcmV0dXJuIG5ldyBFQyhvcHRpb25zKTtcblxuXHQgIC8vIFNob3J0Y3V0IGBlbGxpcHRpYy5lYyhjdXJ2ZS1uYW1lKWBcblx0ICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG5cdCAgICBhc3NlcnQkNShjdXJ2ZXNfMS5oYXNPd25Qcm9wZXJ0eShvcHRpb25zKSwgJ1Vua25vd24gY3VydmUgJyArIG9wdGlvbnMpO1xuXG5cdCAgICBvcHRpb25zID0gY3VydmVzXzFbb3B0aW9uc107XG5cdCAgfVxuXG5cdCAgLy8gU2hvcnRjdXQgZm9yIGBlbGxpcHRpYy5lYyhlbGxpcHRpYy5jdXJ2ZXMuY3VydmVOYW1lKWBcblx0ICBpZiAob3B0aW9ucyBpbnN0YW5jZW9mIGN1cnZlc18xLlByZXNldEN1cnZlKVxuXHQgICAgb3B0aW9ucyA9IHsgY3VydmU6IG9wdGlvbnMgfTtcblxuXHQgIHRoaXMuY3VydmUgPSBvcHRpb25zLmN1cnZlLmN1cnZlO1xuXHQgIHRoaXMubiA9IHRoaXMuY3VydmUubjtcblx0ICB0aGlzLm5oID0gdGhpcy5uLnVzaHJuKDEpO1xuXHQgIHRoaXMuZyA9IHRoaXMuY3VydmUuZztcblxuXHQgIC8vIFBvaW50IG9uIGN1cnZlXG5cdCAgdGhpcy5nID0gb3B0aW9ucy5jdXJ2ZS5nO1xuXHQgIHRoaXMuZy5wcmVjb21wdXRlKG9wdGlvbnMuY3VydmUubi5iaXRMZW5ndGgoKSArIDEpO1xuXG5cdCAgLy8gSGFzaCBmb3IgZnVuY3Rpb24gZm9yIERSQkdcblx0ICB0aGlzLmhhc2ggPSBvcHRpb25zLmhhc2ggfHwgb3B0aW9ucy5jdXJ2ZS5oYXNoO1xuXHR9XG5cdHZhciBlYyA9IEVDO1xuXG5cdEVDLnByb3RvdHlwZS5rZXlQYWlyID0gZnVuY3Rpb24ga2V5UGFpcihvcHRpb25zKSB7XG5cdCAgcmV0dXJuIG5ldyBrZXkodGhpcywgb3B0aW9ucyk7XG5cdH07XG5cblx0RUMucHJvdG90eXBlLmtleUZyb21Qcml2YXRlID0gZnVuY3Rpb24ga2V5RnJvbVByaXZhdGUocHJpdiwgZW5jKSB7XG5cdCAgcmV0dXJuIGtleS5mcm9tUHJpdmF0ZSh0aGlzLCBwcml2LCBlbmMpO1xuXHR9O1xuXG5cdEVDLnByb3RvdHlwZS5rZXlGcm9tUHVibGljID0gZnVuY3Rpb24ga2V5RnJvbVB1YmxpYyhwdWIsIGVuYykge1xuXHQgIHJldHVybiBrZXkuZnJvbVB1YmxpYyh0aGlzLCBwdWIsIGVuYyk7XG5cdH07XG5cblx0RUMucHJvdG90eXBlLmdlbktleVBhaXIgPSBmdW5jdGlvbiBnZW5LZXlQYWlyKG9wdGlvbnMpIHtcblx0ICBpZiAoIW9wdGlvbnMpXG5cdCAgICBvcHRpb25zID0ge307XG5cblx0ICAvLyBJbnN0YW50aWF0ZSBIbWFjX0RSQkdcblx0ICB2YXIgZHJiZyA9IG5ldyBobWFjRHJiZyh7XG5cdCAgICBoYXNoOiB0aGlzLmhhc2gsXG5cdCAgICBwZXJzOiBvcHRpb25zLnBlcnMsXG5cdCAgICBwZXJzRW5jOiBvcHRpb25zLnBlcnNFbmMgfHwgJ3V0ZjgnLFxuXHQgICAgZW50cm9weTogb3B0aW9ucy5lbnRyb3B5IHx8IGJyb3JhbmQodGhpcy5oYXNoLmhtYWNTdHJlbmd0aCksXG5cdCAgICBlbnRyb3B5RW5jOiBvcHRpb25zLmVudHJvcHkgJiYgb3B0aW9ucy5lbnRyb3B5RW5jIHx8ICd1dGY4Jyxcblx0ICAgIG5vbmNlOiB0aGlzLm4udG9BcnJheSgpXG5cdCAgfSk7XG5cblx0ICB2YXIgYnl0ZXMgPSB0aGlzLm4uYnl0ZUxlbmd0aCgpO1xuXHQgIHZhciBuczIgPSB0aGlzLm4uc3ViKG5ldyBibiQxKDIpKTtcblx0ICBkbyB7XG5cdCAgICB2YXIgcHJpdiA9IG5ldyBibiQxKGRyYmcuZ2VuZXJhdGUoYnl0ZXMpKTtcblx0ICAgIGlmIChwcml2LmNtcChuczIpID4gMClcblx0ICAgICAgY29udGludWU7XG5cblx0ICAgIHByaXYuaWFkZG4oMSk7XG5cdCAgICByZXR1cm4gdGhpcy5rZXlGcm9tUHJpdmF0ZShwcml2KTtcblx0ICB9IHdoaWxlICh0cnVlKTtcblx0fTtcblxuXHRFQy5wcm90b3R5cGUuX3RydW5jYXRlVG9OID0gZnVuY3Rpb24gdHJ1bmNhdGVUb04obXNnLCB0cnVuY09ubHkpIHtcblx0ICB2YXIgZGVsdGEgPSBtc2cuYnl0ZUxlbmd0aCgpICogOCAtIHRoaXMubi5iaXRMZW5ndGgoKTtcblx0ICBpZiAoZGVsdGEgPiAwKVxuXHQgICAgbXNnID0gbXNnLnVzaHJuKGRlbHRhKTtcblx0ICBpZiAoIXRydW5jT25seSAmJiBtc2cuY21wKHRoaXMubikgPj0gMClcblx0ICAgIHJldHVybiBtc2cuc3ViKHRoaXMubik7XG5cdCAgZWxzZVxuXHQgICAgcmV0dXJuIG1zZztcblx0fTtcblxuXHRFQy5wcm90b3R5cGUuc2lnbiA9IGZ1bmN0aW9uIHNpZ24obXNnLCBrZXksIGVuYywgb3B0aW9ucykge1xuXHQgIGlmICh0eXBlb2YgZW5jID09PSAnb2JqZWN0Jykge1xuXHQgICAgb3B0aW9ucyA9IGVuYztcblx0ICAgIGVuYyA9IG51bGw7XG5cdCAgfVxuXHQgIGlmICghb3B0aW9ucylcblx0ICAgIG9wdGlvbnMgPSB7fTtcblxuXHQgIGtleSA9IHRoaXMua2V5RnJvbVByaXZhdGUoa2V5LCBlbmMpO1xuXHQgIG1zZyA9IHRoaXMuX3RydW5jYXRlVG9OKG5ldyBibiQxKG1zZywgMTYpKTtcblxuXHQgIC8vIFplcm8tZXh0ZW5kIGtleSB0byBwcm92aWRlIGVub3VnaCBlbnRyb3B5XG5cdCAgdmFyIGJ5dGVzID0gdGhpcy5uLmJ5dGVMZW5ndGgoKTtcblx0ICB2YXIgYmtleSA9IGtleS5nZXRQcml2YXRlKCkudG9BcnJheSgnYmUnLCBieXRlcyk7XG5cblx0ICAvLyBaZXJvLWV4dGVuZCBub25jZSB0byBoYXZlIHRoZSBzYW1lIGJ5dGUgc2l6ZSBhcyBOXG5cdCAgdmFyIG5vbmNlID0gbXNnLnRvQXJyYXkoJ2JlJywgYnl0ZXMpO1xuXG5cdCAgLy8gSW5zdGFudGlhdGUgSG1hY19EUkJHXG5cdCAgdmFyIGRyYmcgPSBuZXcgaG1hY0RyYmcoe1xuXHQgICAgaGFzaDogdGhpcy5oYXNoLFxuXHQgICAgZW50cm9weTogYmtleSxcblx0ICAgIG5vbmNlOiBub25jZSxcblx0ICAgIHBlcnM6IG9wdGlvbnMucGVycyxcblx0ICAgIHBlcnNFbmM6IG9wdGlvbnMucGVyc0VuYyB8fCAndXRmOCdcblx0ICB9KTtcblxuXHQgIC8vIE51bWJlciBvZiBieXRlcyB0byBnZW5lcmF0ZVxuXHQgIHZhciBuczEgPSB0aGlzLm4uc3ViKG5ldyBibiQxKDEpKTtcblxuXHQgIGZvciAodmFyIGl0ZXIgPSAwOyB0cnVlOyBpdGVyKyspIHtcblx0ICAgIHZhciBrID0gb3B0aW9ucy5rID9cblx0ICAgICAgICBvcHRpb25zLmsoaXRlcikgOlxuXHQgICAgICAgIG5ldyBibiQxKGRyYmcuZ2VuZXJhdGUodGhpcy5uLmJ5dGVMZW5ndGgoKSkpO1xuXHQgICAgayA9IHRoaXMuX3RydW5jYXRlVG9OKGssIHRydWUpO1xuXHQgICAgaWYgKGsuY21wbigxKSA8PSAwIHx8IGsuY21wKG5zMSkgPj0gMClcblx0ICAgICAgY29udGludWU7XG5cblx0ICAgIHZhciBrcCA9IHRoaXMuZy5tdWwoayk7XG5cdCAgICBpZiAoa3AuaXNJbmZpbml0eSgpKVxuXHQgICAgICBjb250aW51ZTtcblxuXHQgICAgdmFyIGtwWCA9IGtwLmdldFgoKTtcblx0ICAgIHZhciByID0ga3BYLnVtb2QodGhpcy5uKTtcblx0ICAgIGlmIChyLmNtcG4oMCkgPT09IDApXG5cdCAgICAgIGNvbnRpbnVlO1xuXG5cdCAgICB2YXIgcyA9IGsuaW52bSh0aGlzLm4pLm11bChyLm11bChrZXkuZ2V0UHJpdmF0ZSgpKS5pYWRkKG1zZykpO1xuXHQgICAgcyA9IHMudW1vZCh0aGlzLm4pO1xuXHQgICAgaWYgKHMuY21wbigwKSA9PT0gMClcblx0ICAgICAgY29udGludWU7XG5cblx0ICAgIHZhciByZWNvdmVyeVBhcmFtID0gKGtwLmdldFkoKS5pc09kZCgpID8gMSA6IDApIHxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgKGtwWC5jbXAocikgIT09IDAgPyAyIDogMCk7XG5cblx0ICAgIC8vIFVzZSBjb21wbGVtZW50IG9mIGBzYCwgaWYgaXQgaXMgPiBgbiAvIDJgXG5cdCAgICBpZiAob3B0aW9ucy5jYW5vbmljYWwgJiYgcy5jbXAodGhpcy5uaCkgPiAwKSB7XG5cdCAgICAgIHMgPSB0aGlzLm4uc3ViKHMpO1xuXHQgICAgICByZWNvdmVyeVBhcmFtIF49IDE7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBuZXcgc2lnbmF0dXJlKHsgcjogciwgczogcywgcmVjb3ZlcnlQYXJhbTogcmVjb3ZlcnlQYXJhbSB9KTtcblx0ICB9XG5cdH07XG5cblx0RUMucHJvdG90eXBlLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtc2csIHNpZ25hdHVyZSQxLCBrZXksIGVuYykge1xuXHQgIG1zZyA9IHRoaXMuX3RydW5jYXRlVG9OKG5ldyBibiQxKG1zZywgMTYpKTtcblx0ICBrZXkgPSB0aGlzLmtleUZyb21QdWJsaWMoa2V5LCBlbmMpO1xuXHQgIHNpZ25hdHVyZSQxID0gbmV3IHNpZ25hdHVyZShzaWduYXR1cmUkMSwgJ2hleCcpO1xuXG5cdCAgLy8gUGVyZm9ybSBwcmltaXRpdmUgdmFsdWVzIHZhbGlkYXRpb25cblx0ICB2YXIgciA9IHNpZ25hdHVyZSQxLnI7XG5cdCAgdmFyIHMgPSBzaWduYXR1cmUkMS5zO1xuXHQgIGlmIChyLmNtcG4oMSkgPCAwIHx8IHIuY21wKHRoaXMubikgPj0gMClcblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICBpZiAocy5jbXBuKDEpIDwgMCB8fCBzLmNtcCh0aGlzLm4pID49IDApXG5cdCAgICByZXR1cm4gZmFsc2U7XG5cblx0ICAvLyBWYWxpZGF0ZSBzaWduYXR1cmVcblx0ICB2YXIgc2ludiA9IHMuaW52bSh0aGlzLm4pO1xuXHQgIHZhciB1MSA9IHNpbnYubXVsKG1zZykudW1vZCh0aGlzLm4pO1xuXHQgIHZhciB1MiA9IHNpbnYubXVsKHIpLnVtb2QodGhpcy5uKTtcblxuXHQgIGlmICghdGhpcy5jdXJ2ZS5fbWF4d2VsbFRyaWNrKSB7XG5cdCAgICB2YXIgcCA9IHRoaXMuZy5tdWxBZGQodTEsIGtleS5nZXRQdWJsaWMoKSwgdTIpO1xuXHQgICAgaWYgKHAuaXNJbmZpbml0eSgpKVxuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cblx0ICAgIHJldHVybiBwLmdldFgoKS51bW9kKHRoaXMubikuY21wKHIpID09PSAwO1xuXHQgIH1cblxuXHQgIC8vIE5PVEU6IEdyZWcgTWF4d2VsbCdzIHRyaWNrLCBpbnNwaXJlZCBieTpcblx0ICAvLyBodHRwczovL2dpdC5pby92YWQzS1xuXG5cdCAgdmFyIHAgPSB0aGlzLmcuam11bEFkZCh1MSwga2V5LmdldFB1YmxpYygpLCB1Mik7XG5cdCAgaWYgKHAuaXNJbmZpbml0eSgpKVxuXHQgICAgcmV0dXJuIGZhbHNlO1xuXG5cdCAgLy8gQ29tcGFyZSBgcC54YCBvZiBKYWNvYmlhbiBwb2ludCB3aXRoIGByYCxcblx0ICAvLyB0aGlzIHdpbGwgZG8gYHAueCA9PSByICogcC56XjJgIGluc3RlYWQgb2YgbXVsdGlwbHlpbmcgYHAueGAgYnkgdGhlXG5cdCAgLy8gaW52ZXJzZSBvZiBgcC56XjJgXG5cdCAgcmV0dXJuIHAuZXFYVG9QKHIpO1xuXHR9O1xuXG5cdEVDLnByb3RvdHlwZS5yZWNvdmVyUHViS2V5ID0gZnVuY3Rpb24obXNnLCBzaWduYXR1cmUkMSwgaiwgZW5jKSB7XG5cdCAgYXNzZXJ0JDUoKDMgJiBqKSA9PT0gaiwgJ1RoZSByZWNvdmVyeSBwYXJhbSBpcyBtb3JlIHRoYW4gdHdvIGJpdHMnKTtcblx0ICBzaWduYXR1cmUkMSA9IG5ldyBzaWduYXR1cmUoc2lnbmF0dXJlJDEsIGVuYyk7XG5cblx0ICB2YXIgbiA9IHRoaXMubjtcblx0ICB2YXIgZSA9IG5ldyBibiQxKG1zZyk7XG5cdCAgdmFyIHIgPSBzaWduYXR1cmUkMS5yO1xuXHQgIHZhciBzID0gc2lnbmF0dXJlJDEucztcblxuXHQgIC8vIEEgc2V0IExTQiBzaWduaWZpZXMgdGhhdCB0aGUgeS1jb29yZGluYXRlIGlzIG9kZFxuXHQgIHZhciBpc1lPZGQgPSBqICYgMTtcblx0ICB2YXIgaXNTZWNvbmRLZXkgPSBqID4+IDE7XG5cdCAgaWYgKHIuY21wKHRoaXMuY3VydmUucC51bW9kKHRoaXMuY3VydmUubikpID49IDAgJiYgaXNTZWNvbmRLZXkpXG5cdCAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIHNlbmNvbmQga2V5IGNhbmRpbmF0ZScpO1xuXG5cdCAgLy8gMS4xLiBMZXQgeCA9IHIgKyBqbi5cblx0ICBpZiAoaXNTZWNvbmRLZXkpXG5cdCAgICByID0gdGhpcy5jdXJ2ZS5wb2ludEZyb21YKHIuYWRkKHRoaXMuY3VydmUubiksIGlzWU9kZCk7XG5cdCAgZWxzZVxuXHQgICAgciA9IHRoaXMuY3VydmUucG9pbnRGcm9tWChyLCBpc1lPZGQpO1xuXG5cdCAgdmFyIHJJbnYgPSBzaWduYXR1cmUkMS5yLmludm0obik7XG5cdCAgdmFyIHMxID0gbi5zdWIoZSkubXVsKHJJbnYpLnVtb2Qobik7XG5cdCAgdmFyIHMyID0gcy5tdWwockludikudW1vZChuKTtcblxuXHQgIC8vIDEuNi4xIENvbXB1dGUgUSA9IHJeLTEgKHNSIC0gIGVHKVxuXHQgIC8vICAgICAgICAgICAgICAgUSA9IHJeLTEgKHNSICsgLWVHKVxuXHQgIHJldHVybiB0aGlzLmcubXVsQWRkKHMxLCByLCBzMik7XG5cdH07XG5cblx0RUMucHJvdG90eXBlLmdldEtleVJlY292ZXJ5UGFyYW0gPSBmdW5jdGlvbihlLCBzaWduYXR1cmUkMSwgUSwgZW5jKSB7XG5cdCAgc2lnbmF0dXJlJDEgPSBuZXcgc2lnbmF0dXJlKHNpZ25hdHVyZSQxLCBlbmMpO1xuXHQgIGlmIChzaWduYXR1cmUkMS5yZWNvdmVyeVBhcmFtICE9PSBudWxsKVxuXHQgICAgcmV0dXJuIHNpZ25hdHVyZSQxLnJlY292ZXJ5UGFyYW07XG5cblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuXHQgICAgdmFyIFFwcmltZTtcblx0ICAgIHRyeSB7XG5cdCAgICAgIFFwcmltZSA9IHRoaXMucmVjb3ZlclB1YktleShlLCBzaWduYXR1cmUkMSwgaSk7XG5cdCAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgIGNvbnRpbnVlO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoUXByaW1lLmVxKFEpKVxuXHQgICAgICByZXR1cm4gaTtcblx0ICB9XG5cdCAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCB2YWxpZCByZWNvdmVyeSBmYWN0b3InKTtcblx0fTtcblxuXHR2YXIgZWRkc2EgPSB7fTtcblxuXHR2YXIgcmVxdWlyZSQkMCQxID0gZ2V0Q2pzRXhwb3J0RnJvbU5hbWVzcGFjZShfcGFja2FnZSQxKTtcblxuXHR2YXIgZWxsaXB0aWNfMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBlbGxpcHRpYyA9IGV4cG9ydHM7XG5cblx0ZWxsaXB0aWMudmVyc2lvbiA9IHJlcXVpcmUkJDAkMS52ZXJzaW9uO1xuXHRlbGxpcHRpYy51dGlscyA9IHV0aWxzXzEkMTtcblx0ZWxsaXB0aWMucmFuZCA9IGJyb3JhbmQ7XG5cdGVsbGlwdGljLmN1cnZlID0gY3VydmVfMTtcblx0ZWxsaXB0aWMuY3VydmVzID0gY3VydmVzXzE7XG5cblx0Ly8gUHJvdG9jb2xzXG5cdGVsbGlwdGljLmVjID0gZWM7XG5cdGVsbGlwdGljLmVkZHNhID0gZWRkc2E7XG5cdH0pO1xuXHR2YXIgZWxsaXB0aWNfMiA9IGVsbGlwdGljXzEuZWM7XG5cblx0dmFyIF92ZXJzaW9uJHEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMudmVyc2lvbiA9IFwic2lnbmluZy1rZXkvNS4wLjNcIjtcblxuXHR9KTtcblxuXHR2YXIgX3ZlcnNpb24kciA9IHVud3JhcEV4cG9ydHMoX3ZlcnNpb24kcSk7XG5cdHZhciBfdmVyc2lvbl8xJGQgPSBfdmVyc2lvbiRxLnZlcnNpb247XG5cblx0dmFyIGxpYiRmID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5cblxuXG5cblx0dmFyIGxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJHEudmVyc2lvbik7XG5cdHZhciBfY3VydmUgPSBudWxsO1xuXHRmdW5jdGlvbiBnZXRDdXJ2ZSgpIHtcblx0ICAgIGlmICghX2N1cnZlKSB7XG5cdCAgICAgICAgX2N1cnZlID0gbmV3IGVsbGlwdGljXzEuZWMoXCJzZWNwMjU2azFcIik7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gX2N1cnZlO1xuXHR9XG5cdHZhciBTaWduaW5nS2V5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gU2lnbmluZ0tleShwcml2YXRlS2V5KSB7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJjdXJ2ZVwiLCBcInNlY3AyNTZrMVwiKTtcblx0ICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcInByaXZhdGVLZXlcIiwgbGliJDEuaGV4bGlmeShwcml2YXRlS2V5KSk7XG5cdCAgICAgICAgdmFyIGtleVBhaXIgPSBnZXRDdXJ2ZSgpLmtleUZyb21Qcml2YXRlKGxpYiQxLmFycmF5aWZ5KHRoaXMucHJpdmF0ZUtleSkpO1xuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KHRoaXMsIFwicHVibGljS2V5XCIsIFwiMHhcIiArIGtleVBhaXIuZ2V0UHVibGljKGZhbHNlLCBcImhleFwiKSk7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJjb21wcmVzc2VkUHVibGljS2V5XCIsIFwiMHhcIiArIGtleVBhaXIuZ2V0UHVibGljKHRydWUsIFwiaGV4XCIpKTtcblx0ICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcIl9pc1NpZ25pbmdLZXlcIiwgdHJ1ZSk7XG5cdCAgICB9XG5cdCAgICBTaWduaW5nS2V5LnByb3RvdHlwZS5fYWRkUG9pbnQgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0ICAgICAgICB2YXIgcDAgPSBnZXRDdXJ2ZSgpLmtleUZyb21QdWJsaWMobGliJDEuYXJyYXlpZnkodGhpcy5wdWJsaWNLZXkpKTtcblx0ICAgICAgICB2YXIgcDEgPSBnZXRDdXJ2ZSgpLmtleUZyb21QdWJsaWMobGliJDEuYXJyYXlpZnkob3RoZXIpKTtcblx0ICAgICAgICByZXR1cm4gXCIweFwiICsgcDAucHViLmFkZChwMS5wdWIpLmVuY29kZUNvbXByZXNzZWQoXCJoZXhcIik7XG5cdCAgICB9O1xuXHQgICAgU2lnbmluZ0tleS5wcm90b3R5cGUuc2lnbkRpZ2VzdCA9IGZ1bmN0aW9uIChkaWdlc3QpIHtcblx0ICAgICAgICB2YXIga2V5UGFpciA9IGdldEN1cnZlKCkua2V5RnJvbVByaXZhdGUobGliJDEuYXJyYXlpZnkodGhpcy5wcml2YXRlS2V5KSk7XG5cdCAgICAgICAgdmFyIHNpZ25hdHVyZSA9IGtleVBhaXIuc2lnbihsaWIkMS5hcnJheWlmeShkaWdlc3QpLCB7IGNhbm9uaWNhbDogdHJ1ZSB9KTtcblx0ICAgICAgICByZXR1cm4gbGliJDEuc3BsaXRTaWduYXR1cmUoe1xuXHQgICAgICAgICAgICByZWNvdmVyeVBhcmFtOiBzaWduYXR1cmUucmVjb3ZlcnlQYXJhbSxcblx0ICAgICAgICAgICAgcjogbGliJDEuaGV4WmVyb1BhZChcIjB4XCIgKyBzaWduYXR1cmUuci50b1N0cmluZygxNiksIDMyKSxcblx0ICAgICAgICAgICAgczogbGliJDEuaGV4WmVyb1BhZChcIjB4XCIgKyBzaWduYXR1cmUucy50b1N0cmluZygxNiksIDMyKSxcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBTaWduaW5nS2V5LnByb3RvdHlwZS5jb21wdXRlU2hhcmVkU2VjcmV0ID0gZnVuY3Rpb24gKG90aGVyS2V5KSB7XG5cdCAgICAgICAgdmFyIGtleVBhaXIgPSBnZXRDdXJ2ZSgpLmtleUZyb21Qcml2YXRlKGxpYiQxLmFycmF5aWZ5KHRoaXMucHJpdmF0ZUtleSkpO1xuXHQgICAgICAgIHZhciBvdGhlcktleVBhaXIgPSBnZXRDdXJ2ZSgpLmtleUZyb21QdWJsaWMobGliJDEuYXJyYXlpZnkoY29tcHV0ZVB1YmxpY0tleShvdGhlcktleSkpKTtcblx0ICAgICAgICByZXR1cm4gbGliJDEuaGV4WmVyb1BhZChcIjB4XCIgKyBrZXlQYWlyLmRlcml2ZShvdGhlcktleVBhaXIuZ2V0UHVibGljKCkpLnRvU3RyaW5nKDE2KSwgMzIpO1xuXHQgICAgfTtcblx0ICAgIFNpZ25pbmdLZXkuaXNTaWduaW5nS2V5ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9pc1NpZ25pbmdLZXkpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBTaWduaW5nS2V5O1xuXHR9KCkpO1xuXHRleHBvcnRzLlNpZ25pbmdLZXkgPSBTaWduaW5nS2V5O1xuXHRmdW5jdGlvbiByZWNvdmVyUHVibGljS2V5KGRpZ2VzdCwgc2lnbmF0dXJlKSB7XG5cdCAgICB2YXIgc2lnID0gbGliJDEuc3BsaXRTaWduYXR1cmUoc2lnbmF0dXJlKTtcblx0ICAgIHZhciBycyA9IHsgcjogbGliJDEuYXJyYXlpZnkoc2lnLnIpLCBzOiBsaWIkMS5hcnJheWlmeShzaWcucykgfTtcblx0ICAgIHJldHVybiBcIjB4XCIgKyBnZXRDdXJ2ZSgpLnJlY292ZXJQdWJLZXkobGliJDEuYXJyYXlpZnkoZGlnZXN0KSwgcnMsIHNpZy5yZWNvdmVyeVBhcmFtKS5lbmNvZGUoXCJoZXhcIiwgZmFsc2UpO1xuXHR9XG5cdGV4cG9ydHMucmVjb3ZlclB1YmxpY0tleSA9IHJlY292ZXJQdWJsaWNLZXk7XG5cdGZ1bmN0aW9uIGNvbXB1dGVQdWJsaWNLZXkoa2V5LCBjb21wcmVzc2VkKSB7XG5cdCAgICB2YXIgYnl0ZXMgPSBsaWIkMS5hcnJheWlmeShrZXkpO1xuXHQgICAgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gMzIpIHtcblx0ICAgICAgICB2YXIgc2lnbmluZ0tleSA9IG5ldyBTaWduaW5nS2V5KGJ5dGVzKTtcblx0ICAgICAgICBpZiAoY29tcHJlc3NlZCkge1xuXHQgICAgICAgICAgICByZXR1cm4gXCIweFwiICsgZ2V0Q3VydmUoKS5rZXlGcm9tUHJpdmF0ZShieXRlcykuZ2V0UHVibGljKHRydWUsIFwiaGV4XCIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gc2lnbmluZ0tleS5wdWJsaWNLZXk7XG5cdCAgICB9XG5cdCAgICBlbHNlIGlmIChieXRlcy5sZW5ndGggPT09IDMzKSB7XG5cdCAgICAgICAgaWYgKGNvbXByZXNzZWQpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGxpYiQxLmhleGxpZnkoYnl0ZXMpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gXCIweFwiICsgZ2V0Q3VydmUoKS5rZXlGcm9tUHVibGljKGJ5dGVzKS5nZXRQdWJsaWMoZmFsc2UsIFwiaGV4XCIpO1xuXHQgICAgfVxuXHQgICAgZWxzZSBpZiAoYnl0ZXMubGVuZ3RoID09PSA2NSkge1xuXHQgICAgICAgIGlmICghY29tcHJlc3NlZCkge1xuXHQgICAgICAgICAgICByZXR1cm4gbGliJDEuaGV4bGlmeShieXRlcyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBcIjB4XCIgKyBnZXRDdXJ2ZSgpLmtleUZyb21QdWJsaWMoYnl0ZXMpLmdldFB1YmxpYyh0cnVlLCBcImhleFwiKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBwdWJsaWMgb3IgcHJpdmF0ZSBrZXlcIiwgXCJrZXlcIiwgXCJbUkVEQUNURURdXCIpO1xuXHR9XG5cdGV4cG9ydHMuY29tcHV0ZVB1YmxpY0tleSA9IGNvbXB1dGVQdWJsaWNLZXk7XG5cblx0fSk7XG5cblx0dmFyIGluZGV4JGYgPSB1bndyYXBFeHBvcnRzKGxpYiRmKTtcblx0dmFyIGxpYl8xJGYgPSBsaWIkZi5TaWduaW5nS2V5O1xuXHR2YXIgbGliXzIkZSA9IGxpYiRmLnJlY292ZXJQdWJsaWNLZXk7XG5cdHZhciBsaWJfMyRiID0gbGliJGYuY29tcHV0ZVB1YmxpY0tleTtcblxuXHR2YXIgX3ZlcnNpb24kcyA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy52ZXJzaW9uID0gXCJ0cmFuc2FjdGlvbnMvNS4wLjJcIjtcblxuXHR9KTtcblxuXHR2YXIgX3ZlcnNpb24kdCA9IHVud3JhcEV4cG9ydHMoX3ZlcnNpb24kcyk7XG5cdHZhciBfdmVyc2lvbl8xJGUgPSBfdmVyc2lvbiRzLnZlcnNpb247XG5cblx0dmFyIGxpYiRnID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0dmFyIF9faW1wb3J0U3RhciA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcblx0ICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG5cdCAgICB2YXIgcmVzdWx0ID0ge307XG5cdCAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuXHQgICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdH07XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXG5cblxuXG5cblx0dmFyIFJMUCA9IF9faW1wb3J0U3RhcihsaWIkNSk7XG5cblxuXG5cdHZhciBsb2dnZXIgPSBuZXcgbGliLkxvZ2dlcihfdmVyc2lvbiRzLnZlcnNpb24pO1xuXHQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdGZ1bmN0aW9uIGhhbmRsZUFkZHJlc3ModmFsdWUpIHtcblx0ICAgIGlmICh2YWx1ZSA9PT0gXCIweFwiKSB7XG5cdCAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbGliJDYuZ2V0QWRkcmVzcyh2YWx1ZSk7XG5cdH1cblx0ZnVuY3Rpb24gaGFuZGxlTnVtYmVyKHZhbHVlKSB7XG5cdCAgICBpZiAodmFsdWUgPT09IFwiMHhcIikge1xuXHQgICAgICAgIHJldHVybiBsaWIkNy5aZXJvO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGxpYiQyLkJpZ051bWJlci5mcm9tKHZhbHVlKTtcblx0fVxuXHR2YXIgdHJhbnNhY3Rpb25GaWVsZHMgPSBbXG5cdCAgICB7IG5hbWU6IFwibm9uY2VcIiwgbWF4TGVuZ3RoOiAzMiwgbnVtZXJpYzogdHJ1ZSB9LFxuXHQgICAgeyBuYW1lOiBcImdhc1ByaWNlXCIsIG1heExlbmd0aDogMzIsIG51bWVyaWM6IHRydWUgfSxcblx0ICAgIHsgbmFtZTogXCJnYXNMaW1pdFwiLCBtYXhMZW5ndGg6IDMyLCBudW1lcmljOiB0cnVlIH0sXG5cdCAgICB7IG5hbWU6IFwidG9cIiwgbGVuZ3RoOiAyMCB9LFxuXHQgICAgeyBuYW1lOiBcInZhbHVlXCIsIG1heExlbmd0aDogMzIsIG51bWVyaWM6IHRydWUgfSxcblx0ICAgIHsgbmFtZTogXCJkYXRhXCIgfSxcblx0XTtcblx0dmFyIGFsbG93ZWRUcmFuc2FjdGlvbktleXMgPSB7XG5cdCAgICBjaGFpbklkOiB0cnVlLCBkYXRhOiB0cnVlLCBnYXNMaW1pdDogdHJ1ZSwgZ2FzUHJpY2U6IHRydWUsIG5vbmNlOiB0cnVlLCB0bzogdHJ1ZSwgdmFsdWU6IHRydWVcblx0fTtcblx0ZnVuY3Rpb24gY29tcHV0ZUFkZHJlc3Moa2V5KSB7XG5cdCAgICB2YXIgcHVibGljS2V5ID0gbGliJGYuY29tcHV0ZVB1YmxpY0tleShrZXkpO1xuXHQgICAgcmV0dXJuIGxpYiQ2LmdldEFkZHJlc3MobGliJDEuaGV4RGF0YVNsaWNlKGxpYiQ0LmtlY2NhazI1NihsaWIkMS5oZXhEYXRhU2xpY2UocHVibGljS2V5LCAxKSksIDEyKSk7XG5cdH1cblx0ZXhwb3J0cy5jb21wdXRlQWRkcmVzcyA9IGNvbXB1dGVBZGRyZXNzO1xuXHRmdW5jdGlvbiByZWNvdmVyQWRkcmVzcyhkaWdlc3QsIHNpZ25hdHVyZSkge1xuXHQgICAgcmV0dXJuIGNvbXB1dGVBZGRyZXNzKGxpYiRmLnJlY292ZXJQdWJsaWNLZXkobGliJDEuYXJyYXlpZnkoZGlnZXN0KSwgc2lnbmF0dXJlKSk7XG5cdH1cblx0ZXhwb3J0cy5yZWNvdmVyQWRkcmVzcyA9IHJlY292ZXJBZGRyZXNzO1xuXHRmdW5jdGlvbiBzZXJpYWxpemUodHJhbnNhY3Rpb24sIHNpZ25hdHVyZSkge1xuXHQgICAgbGliJDMuY2hlY2tQcm9wZXJ0aWVzKHRyYW5zYWN0aW9uLCBhbGxvd2VkVHJhbnNhY3Rpb25LZXlzKTtcblx0ICAgIHZhciByYXcgPSBbXTtcblx0ICAgIHRyYW5zYWN0aW9uRmllbGRzLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkSW5mbykge1xuXHQgICAgICAgIHZhciB2YWx1ZSA9IHRyYW5zYWN0aW9uW2ZpZWxkSW5mby5uYW1lXSB8fCAoW10pO1xuXHQgICAgICAgIHZhciBvcHRpb25zID0ge307XG5cdCAgICAgICAgaWYgKGZpZWxkSW5mby5udW1lcmljKSB7XG5cdCAgICAgICAgICAgIG9wdGlvbnMuaGV4UGFkID0gXCJsZWZ0XCI7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhbHVlID0gbGliJDEuYXJyYXlpZnkobGliJDEuaGV4bGlmeSh2YWx1ZSwgb3B0aW9ucykpO1xuXHQgICAgICAgIC8vIEZpeGVkLXdpZHRoIGZpZWxkXG5cdCAgICAgICAgaWYgKGZpZWxkSW5mby5sZW5ndGggJiYgdmFsdWUubGVuZ3RoICE9PSBmaWVsZEluZm8ubGVuZ3RoICYmIHZhbHVlLmxlbmd0aCA+IDApIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgbGVuZ3RoIGZvciBcIiArIGZpZWxkSW5mby5uYW1lLCAoXCJ0cmFuc2FjdGlvbjpcIiArIGZpZWxkSW5mby5uYW1lKSwgdmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBWYXJpYWJsZS13aWR0aCAod2l0aCBhIG1heGltdW0pXG5cdCAgICAgICAgaWYgKGZpZWxkSW5mby5tYXhMZW5ndGgpIHtcblx0ICAgICAgICAgICAgdmFsdWUgPSBsaWIkMS5zdHJpcFplcm9zKHZhbHVlKTtcblx0ICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IGZpZWxkSW5mby5tYXhMZW5ndGgpIHtcblx0ICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGxlbmd0aCBmb3IgXCIgKyBmaWVsZEluZm8ubmFtZSwgKFwidHJhbnNhY3Rpb246XCIgKyBmaWVsZEluZm8ubmFtZSksIHZhbHVlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByYXcucHVzaChsaWIkMS5oZXhsaWZ5KHZhbHVlKSk7XG5cdCAgICB9KTtcblx0ICAgIHZhciBjaGFpbklkID0gMDtcblx0ICAgIGlmICh0cmFuc2FjdGlvbi5jaGFpbklkICE9IG51bGwpIHtcblx0ICAgICAgICAvLyBBIGNoYWluSWQgd2FzIHByb3ZpZGVkOyBpZiBub24temVybyB3ZSdsbCB1c2UgRUlQLTE1NVxuXHQgICAgICAgIGNoYWluSWQgPSB0cmFuc2FjdGlvbi5jaGFpbklkO1xuXHQgICAgICAgIGlmICh0eXBlb2YgKGNoYWluSWQpICE9PSBcIm51bWJlclwiKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHRyYW5zYWN0aW9uLmNoYWluSWRcIiwgXCJ0cmFuc2FjdGlvblwiLCB0cmFuc2FjdGlvbik7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgZWxzZSBpZiAoc2lnbmF0dXJlICYmICFsaWIkMS5pc0J5dGVzTGlrZShzaWduYXR1cmUpICYmIHNpZ25hdHVyZS52ID4gMjgpIHtcblx0ICAgICAgICAvLyBObyBjaGFpbklkIHByb3ZpZGVkLCBidXQgdGhlIHNpZ25hdHVyZSBpcyBzaWduaW5nIHdpdGggRUlQLTE1NTsgZGVyaXZlIGNoYWluSWRcblx0ICAgICAgICBjaGFpbklkID0gTWF0aC5mbG9vcigoc2lnbmF0dXJlLnYgLSAzNSkgLyAyKTtcblx0ICAgIH1cblx0ICAgIC8vIFdlIGhhdmUgYW4gRUlQLTE1NSB0cmFuc2FjdGlvbiAoY2hhaW5JZCB3YXMgc3BlY2lmaWVkIGFuZCBub24temVybylcblx0ICAgIGlmIChjaGFpbklkICE9PSAwKSB7XG5cdCAgICAgICAgcmF3LnB1c2gobGliJDEuaGV4bGlmeShjaGFpbklkKSk7XG5cdCAgICAgICAgcmF3LnB1c2goXCIweFwiKTtcblx0ICAgICAgICByYXcucHVzaChcIjB4XCIpO1xuXHQgICAgfVxuXHQgICAgLy8gUmVxdWVzdGluZyBhbiB1bnNpZ25lZCB0cmFuc2F0aW9uXG5cdCAgICBpZiAoIXNpZ25hdHVyZSkge1xuXHQgICAgICAgIHJldHVybiBSTFAuZW5jb2RlKHJhdyk7XG5cdCAgICB9XG5cdCAgICAvLyBUaGUgc3BsaXRTaWduYXR1cmUgd2lsbCBlbnN1cmUgdGhlIHRyYW5zYWN0aW9uIGhhcyBhIHJlY292ZXJ5UGFyYW0gaW4gdGhlXG5cdCAgICAvLyBjYXNlIHRoYXQgdGhlIHNpZ25UcmFuc2FjdGlvbiBmdW5jdGlvbiBvbmx5IGFkZHMgYSB2LlxuXHQgICAgdmFyIHNpZyA9IGxpYiQxLnNwbGl0U2lnbmF0dXJlKHNpZ25hdHVyZSk7XG5cdCAgICAvLyBXZSBwdXNoZWQgYSBjaGFpbklkIGFuZCBudWxsIHIsIHMgb24gZm9yIGhhc2hpbmcgb25seTsgcmVtb3ZlIHRob3NlXG5cdCAgICB2YXIgdiA9IDI3ICsgc2lnLnJlY292ZXJ5UGFyYW07XG5cdCAgICBpZiAoY2hhaW5JZCAhPT0gMCkge1xuXHQgICAgICAgIHJhdy5wb3AoKTtcblx0ICAgICAgICByYXcucG9wKCk7XG5cdCAgICAgICAgcmF3LnBvcCgpO1xuXHQgICAgICAgIHYgKz0gY2hhaW5JZCAqIDIgKyA4O1xuXHQgICAgICAgIC8vIElmIGFuIEVJUC0xNTUgdiAoZGlyZWN0bHkgb3IgaW5kaXJlY3RseTsgbWF5YmUgX3ZzKSB3YXMgcHJvdmlkZWQsIGNoZWNrIGl0IVxuXHQgICAgICAgIGlmIChzaWcudiA+IDI4ICYmIHNpZy52ICE9PSB2KSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ0cmFuc2FjdGlvbi5jaGFpbklkL3NpZ25hdHVyZS52IG1pc21hdGNoXCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgZWxzZSBpZiAoc2lnLnYgIT09IHYpIHtcblx0ICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidHJhbnNhY3Rpb24uY2hhaW5JZC9zaWduYXR1cmUudiBtaXNtYXRjaFwiLCBcInNpZ25hdHVyZVwiLCBzaWduYXR1cmUpO1xuXHQgICAgfVxuXHQgICAgcmF3LnB1c2gobGliJDEuaGV4bGlmeSh2KSk7XG5cdCAgICByYXcucHVzaChsaWIkMS5zdHJpcFplcm9zKGxpYiQxLmFycmF5aWZ5KHNpZy5yKSkpO1xuXHQgICAgcmF3LnB1c2gobGliJDEuc3RyaXBaZXJvcyhsaWIkMS5hcnJheWlmeShzaWcucykpKTtcblx0ICAgIHJldHVybiBSTFAuZW5jb2RlKHJhdyk7XG5cdH1cblx0ZXhwb3J0cy5zZXJpYWxpemUgPSBzZXJpYWxpemU7XG5cdGZ1bmN0aW9uIHBhcnNlKHJhd1RyYW5zYWN0aW9uKSB7XG5cdCAgICB2YXIgdHJhbnNhY3Rpb24gPSBSTFAuZGVjb2RlKHJhd1RyYW5zYWN0aW9uKTtcblx0ICAgIGlmICh0cmFuc2FjdGlvbi5sZW5ndGggIT09IDkgJiYgdHJhbnNhY3Rpb24ubGVuZ3RoICE9PSA2KSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgcmF3IHRyYW5zYWN0aW9uXCIsIFwicmF3VHJhbnNhY3Rpb25cIiwgcmF3VHJhbnNhY3Rpb24pO1xuXHQgICAgfVxuXHQgICAgdmFyIHR4ID0ge1xuXHQgICAgICAgIG5vbmNlOiBoYW5kbGVOdW1iZXIodHJhbnNhY3Rpb25bMF0pLnRvTnVtYmVyKCksXG5cdCAgICAgICAgZ2FzUHJpY2U6IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvblsxXSksXG5cdCAgICAgICAgZ2FzTGltaXQ6IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvblsyXSksXG5cdCAgICAgICAgdG86IGhhbmRsZUFkZHJlc3ModHJhbnNhY3Rpb25bM10pLFxuXHQgICAgICAgIHZhbHVlOiBoYW5kbGVOdW1iZXIodHJhbnNhY3Rpb25bNF0pLFxuXHQgICAgICAgIGRhdGE6IHRyYW5zYWN0aW9uWzVdLFxuXHQgICAgICAgIGNoYWluSWQ6IDBcblx0ICAgIH07XG5cdCAgICAvLyBMZWdhY3kgdW5zaWduZWQgdHJhbnNhY3Rpb25cblx0ICAgIGlmICh0cmFuc2FjdGlvbi5sZW5ndGggPT09IDYpIHtcblx0ICAgICAgICByZXR1cm4gdHg7XG5cdCAgICB9XG5cdCAgICB0cnkge1xuXHQgICAgICAgIHR4LnYgPSBsaWIkMi5CaWdOdW1iZXIuZnJvbSh0cmFuc2FjdGlvbls2XSkudG9OdW1iZXIoKTtcblx0ICAgIH1cblx0ICAgIGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgIGNvbnNvbGUubG9nKGVycm9yKTtcblx0ICAgICAgICByZXR1cm4gdHg7XG5cdCAgICB9XG5cdCAgICB0eC5yID0gbGliJDEuaGV4WmVyb1BhZCh0cmFuc2FjdGlvbls3XSwgMzIpO1xuXHQgICAgdHgucyA9IGxpYiQxLmhleFplcm9QYWQodHJhbnNhY3Rpb25bOF0sIDMyKTtcblx0ICAgIGlmIChsaWIkMi5CaWdOdW1iZXIuZnJvbSh0eC5yKS5pc1plcm8oKSAmJiBsaWIkMi5CaWdOdW1iZXIuZnJvbSh0eC5zKS5pc1plcm8oKSkge1xuXHQgICAgICAgIC8vIEVJUC0xNTUgdW5zaWduZWQgdHJhbnNhY3Rpb25cblx0ICAgICAgICB0eC5jaGFpbklkID0gdHgudjtcblx0ICAgICAgICB0eC52ID0gMDtcblx0ICAgIH1cblx0ICAgIGVsc2Uge1xuXHQgICAgICAgIC8vIFNpZ25lZCBUcmFuYXNhY3Rpb25cblx0ICAgICAgICB0eC5jaGFpbklkID0gTWF0aC5mbG9vcigodHgudiAtIDM1KSAvIDIpO1xuXHQgICAgICAgIGlmICh0eC5jaGFpbklkIDwgMCkge1xuXHQgICAgICAgICAgICB0eC5jaGFpbklkID0gMDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHJlY292ZXJ5UGFyYW0gPSB0eC52IC0gMjc7XG5cdCAgICAgICAgdmFyIHJhdyA9IHRyYW5zYWN0aW9uLnNsaWNlKDAsIDYpO1xuXHQgICAgICAgIGlmICh0eC5jaGFpbklkICE9PSAwKSB7XG5cdCAgICAgICAgICAgIHJhdy5wdXNoKGxpYiQxLmhleGxpZnkodHguY2hhaW5JZCkpO1xuXHQgICAgICAgICAgICByYXcucHVzaChcIjB4XCIpO1xuXHQgICAgICAgICAgICByYXcucHVzaChcIjB4XCIpO1xuXHQgICAgICAgICAgICByZWNvdmVyeVBhcmFtIC09IHR4LmNoYWluSWQgKiAyICsgODtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGRpZ2VzdCA9IGxpYiQ0LmtlY2NhazI1NihSTFAuZW5jb2RlKHJhdykpO1xuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgIHR4LmZyb20gPSByZWNvdmVyQWRkcmVzcyhkaWdlc3QsIHsgcjogbGliJDEuaGV4bGlmeSh0eC5yKSwgczogbGliJDEuaGV4bGlmeSh0eC5zKSwgcmVjb3ZlcnlQYXJhbTogcmVjb3ZlcnlQYXJhbSB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG5cdCAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycm9yKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdHguaGFzaCA9IGxpYiQ0LmtlY2NhazI1NihyYXdUcmFuc2FjdGlvbik7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdHg7XG5cdH1cblx0ZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuXG5cdH0pO1xuXG5cdHZhciBpbmRleCRnID0gdW53cmFwRXhwb3J0cyhsaWIkZyk7XG5cdHZhciBsaWJfMSRnID0gbGliJGcuY29tcHV0ZUFkZHJlc3M7XG5cdHZhciBsaWJfMiRmID0gbGliJGcucmVjb3ZlckFkZHJlc3M7XG5cdHZhciBsaWJfMyRjID0gbGliJGcuc2VyaWFsaXplO1xuXHR2YXIgbGliXzQkOSA9IGxpYiRnLnBhcnNlO1xuXG5cdHZhciBfdmVyc2lvbiR1ID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLnZlcnNpb24gPSBcIndvcmRsaXN0cy81LjAuMlwiO1xuXG5cdH0pO1xuXG5cdHZhciBfdmVyc2lvbiR2ID0gdW53cmFwRXhwb3J0cyhfdmVyc2lvbiR1KTtcblx0dmFyIF92ZXJzaW9uXzEkZiA9IF92ZXJzaW9uJHUudmVyc2lvbjtcblxuXHR2YXIgd29yZGxpc3QgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdC8vIFRoaXMgZ2V0cyBvdmVycmlkZGVuIGJ5IHJvbGx1cFxuXHR2YXIgZXhwb3J0V29yZGxpc3QgPSBmYWxzZTtcblxuXG5cblxuXHRleHBvcnRzLmxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJHUudmVyc2lvbik7XG5cdHZhciBXb3JkbGlzdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIFdvcmRsaXN0KGxvY2FsZSkge1xuXHQgICAgICAgIHZhciBfbmV3VGFyZ2V0ID0gdGhpcy5jb25zdHJ1Y3Rvcjtcblx0ICAgICAgICBleHBvcnRzLmxvZ2dlci5jaGVja0Fic3RyYWN0KF9uZXdUYXJnZXQsIFdvcmRsaXN0KTtcblx0ICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcImxvY2FsZVwiLCBsb2NhbGUpO1xuXHQgICAgfVxuXHQgICAgLy8gU3ViY2xhc3NlcyBtYXkgb3ZlcnJpZGUgdGhpc1xuXHQgICAgV29yZGxpc3QucHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gKG1uZW1vbmljKSB7XG5cdCAgICAgICAgcmV0dXJuIG1uZW1vbmljLnRvTG93ZXJDYXNlKCkuc3BsaXQoLyArL2cpO1xuXHQgICAgfTtcblx0ICAgIC8vIFN1YmNsYXNzZXMgbWF5IG92ZXJyaWRlIHRoaXNcblx0ICAgIFdvcmRsaXN0LnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gKHdvcmRzKSB7XG5cdCAgICAgICAgcmV0dXJuIHdvcmRzLmpvaW4oXCIgXCIpO1xuXHQgICAgfTtcblx0ICAgIFdvcmRsaXN0LmNoZWNrID0gZnVuY3Rpb24gKHdvcmRsaXN0KSB7XG5cdCAgICAgICAgdmFyIHdvcmRzID0gW107XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyMDQ4OyBpKyspIHtcblx0ICAgICAgICAgICAgdmFyIHdvcmQgPSB3b3JkbGlzdC5nZXRXb3JkKGkpO1xuXHQgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0ICAgICAgICAgICAgaWYgKGkgIT09IHdvcmRsaXN0LmdldFdvcmRJbmRleCh3b3JkKSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFwiMHhcIjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB3b3Jkcy5wdXNoKHdvcmQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gbGliJDkuaWQod29yZHMuam9pbihcIlxcblwiKSArIFwiXFxuXCIpO1xuXHQgICAgfTtcblx0ICAgIFdvcmRsaXN0LnJlZ2lzdGVyID0gZnVuY3Rpb24gKGxhbmcsIG5hbWUpIHtcblx0ICAgICAgICBpZiAoIW5hbWUpIHtcblx0ICAgICAgICAgICAgbmFtZSA9IGxhbmcubG9jYWxlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0ICAgICAgICBpZiAoZXhwb3J0V29yZGxpc3QpIHtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIHZhciBhbnlHbG9iYWwgPSB3aW5kb3c7XG5cdCAgICAgICAgICAgICAgICBpZiAoYW55R2xvYmFsLl9ldGhlcnMgJiYgYW55R2xvYmFsLl9ldGhlcnMud29yZGxpc3RzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFhbnlHbG9iYWwuX2V0aGVycy53b3JkbGlzdHNbbmFtZV0pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkoYW55R2xvYmFsLl9ldGhlcnMud29yZGxpc3RzLCBuYW1lLCBsYW5nKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFdvcmRsaXN0O1xuXHR9KCkpO1xuXHRleHBvcnRzLldvcmRsaXN0ID0gV29yZGxpc3Q7XG5cblx0fSk7XG5cblx0dmFyIHdvcmRsaXN0JDEgPSB1bndyYXBFeHBvcnRzKHdvcmRsaXN0KTtcblx0dmFyIHdvcmRsaXN0XzEgPSB3b3JkbGlzdC5sb2dnZXI7XG5cdHZhciB3b3JkbGlzdF8yID0gd29yZGxpc3QuV29yZGxpc3Q7XG5cblx0dmFyIGxhbmdFbl8xID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0dmFyIF9fZXh0ZW5kcyA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuXHQgICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuXHQgICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG5cdCAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuXHQgICAgfTtcblx0fSkoKTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5cdHZhciB3b3JkcyA9IFwiQWJhbmRvbkFiaWxpdHlBYmxlQWJvdXRBYm92ZUFic2VudEFic29yYkFic3RyYWN0QWJzdXJkQWJ1c2VBY2Nlc3NBY2NpZGVudEFjY291bnRBY2N1c2VBY2hpZXZlQWNpZEFjb3VzdGljQWNxdWlyZUFjcm9zc0FjdEFjdGlvbkFjdG9yQWN0cmVzc0FjdHVhbEFkYXB0QWRkQWRkaWN0QWRkcmVzc0FkanVzdEFkbWl0QWR1bHRBZHZhbmNlQWR2aWNlQWVyb2JpY0FmZmFpckFmZm9yZEFmcmFpZEFnYWluQWdlQWdlbnRBZ3JlZUFoZWFkQWltQWlyQWlycG9ydEFpc2xlQWxhcm1BbGJ1bUFsY29ob2xBbGVydEFsaWVuQWxsQWxsZXlBbGxvd0FsbW9zdEFsb25lQWxwaGFBbHJlYWR5QWxzb0FsdGVyQWx3YXlzQW1hdGV1ckFtYXppbmdBbW9uZ0Ftb3VudEFtdXNlZEFuYWx5c3RBbmNob3JBbmNpZW50QW5nZXJBbmdsZUFuZ3J5QW5pbWFsQW5rbGVBbm5vdW5jZUFubnVhbEFub3RoZXJBbnN3ZXJBbnRlbm5hQW50aXF1ZUFueGlldHlBbnlBcGFydEFwb2xvZ3lBcHBlYXJBcHBsZUFwcHJvdmVBcHJpbEFyY2hBcmN0aWNBcmVhQXJlbmFBcmd1ZUFybUFybWVkQXJtb3JBcm15QXJvdW5kQXJyYW5nZUFycmVzdEFycml2ZUFycm93QXJ0QXJ0ZWZhY3RBcnRpc3RBcnR3b3JrQXNrQXNwZWN0QXNzYXVsdEFzc2V0QXNzaXN0QXNzdW1lQXN0aG1hQXRobGV0ZUF0b21BdHRhY2tBdHRlbmRBdHRpdHVkZUF0dHJhY3RBdWN0aW9uQXVkaXRBdWd1c3RBdW50QXV0aG9yQXV0b0F1dHVtbkF2ZXJhZ2VBdm9jYWRvQXZvaWRBd2FrZUF3YXJlQXdheUF3ZXNvbWVBd2Z1bEF3a3dhcmRBeGlzQmFieUJhY2hlbG9yQmFjb25CYWRnZUJhZ0JhbGFuY2VCYWxjb255QmFsbEJhbWJvb0JhbmFuYUJhbm5lckJhckJhcmVseUJhcmdhaW5CYXJyZWxCYXNlQmFzaWNCYXNrZXRCYXR0bGVCZWFjaEJlYW5CZWF1dHlCZWNhdXNlQmVjb21lQmVlZkJlZm9yZUJlZ2luQmVoYXZlQmVoaW5kQmVsaWV2ZUJlbG93QmVsdEJlbmNoQmVuZWZpdEJlc3RCZXRyYXlCZXR0ZXJCZXR3ZWVuQmV5b25kQmljeWNsZUJpZEJpa2VCaW5kQmlvbG9neUJpcmRCaXJ0aEJpdHRlckJsYWNrQmxhZGVCbGFtZUJsYW5rZXRCbGFzdEJsZWFrQmxlc3NCbGluZEJsb29kQmxvc3NvbUJsb3VzZUJsdWVCbHVyQmx1c2hCb2FyZEJvYXRCb2R5Qm9pbEJvbWJCb25lQm9udXNCb29rQm9vc3RCb3JkZXJCb3JpbmdCb3Jyb3dCb3NzQm90dG9tQm91bmNlQm94Qm95QnJhY2tldEJyYWluQnJhbmRCcmFzc0JyYXZlQnJlYWRCcmVlemVCcmlja0JyaWRnZUJyaWVmQnJpZ2h0QnJpbmdCcmlza0Jyb2Njb2xpQnJva2VuQnJvbnplQnJvb21Ccm90aGVyQnJvd25CcnVzaEJ1YmJsZUJ1ZGR5QnVkZ2V0QnVmZmFsb0J1aWxkQnVsYkJ1bGtCdWxsZXRCdW5kbGVCdW5rZXJCdXJkZW5CdXJnZXJCdXJzdEJ1c0J1c2luZXNzQnVzeUJ1dHRlckJ1eWVyQnV6ekNhYmJhZ2VDYWJpbkNhYmxlQ2FjdHVzQ2FnZUNha2VDYWxsQ2FsbUNhbWVyYUNhbXBDYW5DYW5hbENhbmNlbENhbmR5Q2Fubm9uQ2Fub2VDYW52YXNDYW55b25DYXBhYmxlQ2FwaXRhbENhcHRhaW5DYXJDYXJib25DYXJkQ2FyZ29DYXJwZXRDYXJyeUNhcnRDYXNlQ2FzaENhc2lub0Nhc3RsZUNhc3VhbENhdENhdGFsb2dDYXRjaENhdGVnb3J5Q2F0dGxlQ2F1Z2h0Q2F1c2VDYXV0aW9uQ2F2ZUNlaWxpbmdDZWxlcnlDZW1lbnRDZW5zdXNDZW50dXJ5Q2VyZWFsQ2VydGFpbkNoYWlyQ2hhbGtDaGFtcGlvbkNoYW5nZUNoYW9zQ2hhcHRlckNoYXJnZUNoYXNlQ2hhdENoZWFwQ2hlY2tDaGVlc2VDaGVmQ2hlcnJ5Q2hlc3RDaGlja2VuQ2hpZWZDaGlsZENoaW1uZXlDaG9pY2VDaG9vc2VDaHJvbmljQ2h1Y2tsZUNodW5rQ2h1cm5DaWdhckNpbm5hbW9uQ2lyY2xlQ2l0aXplbkNpdHlDaXZpbENsYWltQ2xhcENsYXJpZnlDbGF3Q2xheUNsZWFuQ2xlcmtDbGV2ZXJDbGlja0NsaWVudENsaWZmQ2xpbWJDbGluaWNDbGlwQ2xvY2tDbG9nQ2xvc2VDbG90aENsb3VkQ2xvd25DbHViQ2x1bXBDbHVzdGVyQ2x1dGNoQ29hY2hDb2FzdENvY29udXRDb2RlQ29mZmVlQ29pbENvaW5Db2xsZWN0Q29sb3JDb2x1bW5Db21iaW5lQ29tZUNvbWZvcnRDb21pY0NvbW1vbkNvbXBhbnlDb25jZXJ0Q29uZHVjdENvbmZpcm1Db25ncmVzc0Nvbm5lY3RDb25zaWRlckNvbnRyb2xDb252aW5jZUNvb2tDb29sQ29wcGVyQ29weUNvcmFsQ29yZUNvcm5Db3JyZWN0Q29zdENvdHRvbkNvdWNoQ291bnRyeUNvdXBsZUNvdXJzZUNvdXNpbkNvdmVyQ295b3RlQ3JhY2tDcmFkbGVDcmFmdENyYW1DcmFuZUNyYXNoQ3JhdGVyQ3Jhd2xDcmF6eUNyZWFtQ3JlZGl0Q3JlZWtDcmV3Q3JpY2tldENyaW1lQ3Jpc3BDcml0aWNDcm9wQ3Jvc3NDcm91Y2hDcm93ZENydWNpYWxDcnVlbENydWlzZUNydW1ibGVDcnVuY2hDcnVzaENyeUNyeXN0YWxDdWJlQ3VsdHVyZUN1cEN1cGJvYXJkQ3VyaW91c0N1cnJlbnRDdXJ0YWluQ3VydmVDdXNoaW9uQ3VzdG9tQ3V0ZUN5Y2xlRGFkRGFtYWdlRGFtcERhbmNlRGFuZ2VyRGFyaW5nRGFzaERhdWdodGVyRGF3bkRheURlYWxEZWJhdGVEZWJyaXNEZWNhZGVEZWNlbWJlckRlY2lkZURlY2xpbmVEZWNvcmF0ZURlY3JlYXNlRGVlckRlZmVuc2VEZWZpbmVEZWZ5RGVncmVlRGVsYXlEZWxpdmVyRGVtYW5kRGVtaXNlRGVuaWFsRGVudGlzdERlbnlEZXBhcnREZXBlbmREZXBvc2l0RGVwdGhEZXB1dHlEZXJpdmVEZXNjcmliZURlc2VydERlc2lnbkRlc2tEZXNwYWlyRGVzdHJveURldGFpbERldGVjdERldmVsb3BEZXZpY2VEZXZvdGVEaWFncmFtRGlhbERpYW1vbmREaWFyeURpY2VEaWVzZWxEaWV0RGlmZmVyRGlnaXRhbERpZ25pdHlEaWxlbW1hRGlubmVyRGlub3NhdXJEaXJlY3REaXJ0RGlzYWdyZWVEaXNjb3ZlckRpc2Vhc2VEaXNoRGlzbWlzc0Rpc29yZGVyRGlzcGxheURpc3RhbmNlRGl2ZXJ0RGl2aWRlRGl2b3JjZURpenp5RG9jdG9yRG9jdW1lbnREb2dEb2xsRG9scGhpbkRvbWFpbkRvbmF0ZURvbmtleURvbm9yRG9vckRvc2VEb3VibGVEb3ZlRHJhZnREcmFnb25EcmFtYURyYXN0aWNEcmF3RHJlYW1EcmVzc0RyaWZ0RHJpbGxEcmlua0RyaXBEcml2ZURyb3BEcnVtRHJ5RHVja0R1bWJEdW5lRHVyaW5nRHVzdER1dGNoRHV0eUR3YXJmRHluYW1pY0VhZ2VyRWFnbGVFYXJseUVhcm5FYXJ0aEVhc2lseUVhc3RFYXN5RWNob0Vjb2xvZ3lFY29ub215RWRnZUVkaXRFZHVjYXRlRWZmb3J0RWdnRWlnaHRFaXRoZXJFbGJvd0VsZGVyRWxlY3RyaWNFbGVnYW50RWxlbWVudEVsZXBoYW50RWxldmF0b3JFbGl0ZUVsc2VFbWJhcmtFbWJvZHlFbWJyYWNlRW1lcmdlRW1vdGlvbkVtcGxveUVtcG93ZXJFbXB0eUVuYWJsZUVuYWN0RW5kRW5kbGVzc0VuZG9yc2VFbmVteUVuZXJneUVuZm9yY2VFbmdhZ2VFbmdpbmVFbmhhbmNlRW5qb3lFbmxpc3RFbm91Z2hFbnJpY2hFbnJvbGxFbnN1cmVFbnRlckVudGlyZUVudHJ5RW52ZWxvcGVFcGlzb2RlRXF1YWxFcXVpcEVyYUVyYXNlRXJvZGVFcm9zaW9uRXJyb3JFcnVwdEVzY2FwZUVzc2F5RXNzZW5jZUVzdGF0ZUV0ZXJuYWxFdGhpY3NFdmlkZW5jZUV2aWxFdm9rZUV2b2x2ZUV4YWN0RXhhbXBsZUV4Y2Vzc0V4Y2hhbmdlRXhjaXRlRXhjbHVkZUV4Y3VzZUV4ZWN1dGVFeGVyY2lzZUV4aGF1c3RFeGhpYml0RXhpbGVFeGlzdEV4aXRFeG90aWNFeHBhbmRFeHBlY3RFeHBpcmVFeHBsYWluRXhwb3NlRXhwcmVzc0V4dGVuZEV4dHJhRXllRXllYnJvd0ZhYnJpY0ZhY2VGYWN1bHR5RmFkZUZhaW50RmFpdGhGYWxsRmFsc2VGYW1lRmFtaWx5RmFtb3VzRmFuRmFuY3lGYW50YXN5RmFybUZhc2hpb25GYXRGYXRhbEZhdGhlckZhdGlndWVGYXVsdEZhdm9yaXRlRmVhdHVyZUZlYnJ1YXJ5RmVkZXJhbEZlZUZlZWRGZWVsRmVtYWxlRmVuY2VGZXN0aXZhbEZldGNoRmV2ZXJGZXdGaWJlckZpY3Rpb25GaWVsZEZpZ3VyZUZpbGVGaWxtRmlsdGVyRmluYWxGaW5kRmluZUZpbmdlckZpbmlzaEZpcmVGaXJtRmlyc3RGaXNjYWxGaXNoRml0Rml0bmVzc0ZpeEZsYWdGbGFtZUZsYXNoRmxhdEZsYXZvckZsZWVGbGlnaHRGbGlwRmxvYXRGbG9ja0Zsb29yRmxvd2VyRmx1aWRGbHVzaEZseUZvYW1Gb2N1c0ZvZ0ZvaWxGb2xkRm9sbG93Rm9vZEZvb3RGb3JjZUZvcmVzdEZvcmdldEZvcmtGb3J0dW5lRm9ydW1Gb3J3YXJkRm9zc2lsRm9zdGVyRm91bmRGb3hGcmFnaWxlRnJhbWVGcmVxdWVudEZyZXNoRnJpZW5kRnJpbmdlRnJvZ0Zyb250RnJvc3RGcm93bkZyb3plbkZydWl0RnVlbEZ1bkZ1bm55RnVybmFjZUZ1cnlGdXR1cmVHYWRnZXRHYWluR2FsYXh5R2FsbGVyeUdhbWVHYXBHYXJhZ2VHYXJiYWdlR2FyZGVuR2FybGljR2FybWVudEdhc0dhc3BHYXRlR2F0aGVyR2F1Z2VHYXplR2VuZXJhbEdlbml1c0dlbnJlR2VudGxlR2VudWluZUdlc3R1cmVHaG9zdEdpYW50R2lmdEdpZ2dsZUdpbmdlckdpcmFmZmVHaXJsR2l2ZUdsYWRHbGFuY2VHbGFyZUdsYXNzR2xpZGVHbGltcHNlR2xvYmVHbG9vbUdsb3J5R2xvdmVHbG93R2x1ZUdvYXRHb2RkZXNzR29sZEdvb2RHb29zZUdvcmlsbGFHb3NwZWxHb3NzaXBHb3Zlcm5Hb3duR3JhYkdyYWNlR3JhaW5HcmFudEdyYXBlR3Jhc3NHcmF2aXR5R3JlYXRHcmVlbkdyaWRHcmllZkdyaXRHcm9jZXJ5R3JvdXBHcm93R3J1bnRHdWFyZEd1ZXNzR3VpZGVHdWlsdEd1aXRhckd1bkd5bUhhYml0SGFpckhhbGZIYW1tZXJIYW1zdGVySGFuZEhhcHB5SGFyYm9ySGFyZEhhcnNoSGFydmVzdEhhdEhhdmVIYXdrSGF6YXJkSGVhZEhlYWx0aEhlYXJ0SGVhdnlIZWRnZWhvZ0hlaWdodEhlbGxvSGVsbWV0SGVscEhlbkhlcm9IaWRkZW5IaWdoSGlsbEhpbnRIaXBIaXJlSGlzdG9yeUhvYmJ5SG9ja2V5SG9sZEhvbGVIb2xpZGF5SG9sbG93SG9tZUhvbmV5SG9vZEhvcGVIb3JuSG9ycm9ySG9yc2VIb3NwaXRhbEhvc3RIb3RlbEhvdXJIb3Zlckh1Ykh1Z2VIdW1hbkh1bWJsZUh1bW9ySHVuZHJlZEh1bmdyeUh1bnRIdXJkbGVIdXJyeUh1cnRIdXNiYW5kSHlicmlkSWNlSWNvbklkZWFJZGVudGlmeUlkbGVJZ25vcmVJbGxJbGxlZ2FsSWxsbmVzc0ltYWdlSW1pdGF0ZUltbWVuc2VJbW11bmVJbXBhY3RJbXBvc2VJbXByb3ZlSW1wdWxzZUluY2hJbmNsdWRlSW5jb21lSW5jcmVhc2VJbmRleEluZGljYXRlSW5kb29ySW5kdXN0cnlJbmZhbnRJbmZsaWN0SW5mb3JtSW5oYWxlSW5oZXJpdEluaXRpYWxJbmplY3RJbmp1cnlJbm1hdGVJbm5lcklubm9jZW50SW5wdXRJbnF1aXJ5SW5zYW5lSW5zZWN0SW5zaWRlSW5zcGlyZUluc3RhbGxJbnRhY3RJbnRlcmVzdEludG9JbnZlc3RJbnZpdGVJbnZvbHZlSXJvbklzbGFuZElzb2xhdGVJc3N1ZUl0ZW1Jdm9yeUphY2tldEphZ3VhckphckphenpKZWFsb3VzSmVhbnNKZWxseUpld2VsSm9iSm9pbkpva2VKb3VybmV5Sm95SnVkZ2VKdWljZUp1bXBKdW5nbGVKdW5pb3JKdW5rSnVzdEthbmdhcm9vS2VlbktlZXBLZXRjaHVwS2V5S2lja0tpZEtpZG5leUtpbmRLaW5nZG9tS2lzc0tpdEtpdGNoZW5LaXRlS2l0dGVuS2l3aUtuZWVLbmlmZUtub2NrS25vd0xhYkxhYmVsTGFib3JMYWRkZXJMYWR5TGFrZUxhbXBMYW5ndWFnZUxhcHRvcExhcmdlTGF0ZXJMYXRpbkxhdWdoTGF1bmRyeUxhdmFMYXdMYXduTGF3c3VpdExheWVyTGF6eUxlYWRlckxlYWZMZWFybkxlYXZlTGVjdHVyZUxlZnRMZWdMZWdhbExlZ2VuZExlaXN1cmVMZW1vbkxlbmRMZW5ndGhMZW5zTGVvcGFyZExlc3NvbkxldHRlckxldmVsTGlhckxpYmVydHlMaWJyYXJ5TGljZW5zZUxpZmVMaWZ0TGlnaHRMaWtlTGltYkxpbWl0TGlua0xpb25MaXF1aWRMaXN0TGl0dGxlTGl2ZUxpemFyZExvYWRMb2FuTG9ic3RlckxvY2FsTG9ja0xvZ2ljTG9uZWx5TG9uZ0xvb3BMb3R0ZXJ5TG91ZExvdW5nZUxvdmVMb3lhbEx1Y2t5THVnZ2FnZUx1bWJlckx1bmFyTHVuY2hMdXh1cnlMeXJpY3NNYWNoaW5lTWFkTWFnaWNNYWduZXRNYWlkTWFpbE1haW5NYWpvck1ha2VNYW1tYWxNYW5NYW5hZ2VNYW5kYXRlTWFuZ29NYW5zaW9uTWFudWFsTWFwbGVNYXJibGVNYXJjaE1hcmdpbk1hcmluZU1hcmtldE1hcnJpYWdlTWFza01hc3NNYXN0ZXJNYXRjaE1hdGVyaWFsTWF0aE1hdHJpeE1hdHRlck1heGltdW1NYXplTWVhZG93TWVhbk1lYXN1cmVNZWF0TWVjaGFuaWNNZWRhbE1lZGlhTWVsb2R5TWVsdE1lbWJlck1lbW9yeU1lbnRpb25NZW51TWVyY3lNZXJnZU1lcml0TWVycnlNZXNoTWVzc2FnZU1ldGFsTWV0aG9kTWlkZGxlTWlkbmlnaHRNaWxrTWlsbGlvbk1pbWljTWluZE1pbmltdW1NaW5vck1pbnV0ZU1pcmFjbGVNaXJyb3JNaXNlcnlNaXNzTWlzdGFrZU1peE1peGVkTWl4dHVyZU1vYmlsZU1vZGVsTW9kaWZ5TW9tTW9tZW50TW9uaXRvck1vbmtleU1vbnN0ZXJNb250aE1vb25Nb3JhbE1vcmVNb3JuaW5nTW9zcXVpdG9Nb3RoZXJNb3Rpb25Nb3Rvck1vdW50YWluTW91c2VNb3ZlTW92aWVNdWNoTXVmZmluTXVsZU11bHRpcGx5TXVzY2xlTXVzZXVtTXVzaHJvb21NdXNpY011c3RNdXR1YWxNeXNlbGZNeXN0ZXJ5TXl0aE5haXZlTmFtZU5hcGtpbk5hcnJvd05hc3R5TmF0aW9uTmF0dXJlTmVhck5lY2tOZWVkTmVnYXRpdmVOZWdsZWN0TmVpdGhlck5lcGhld05lcnZlTmVzdE5ldE5ldHdvcmtOZXV0cmFsTmV2ZXJOZXdzTmV4dE5pY2VOaWdodE5vYmxlTm9pc2VOb21pbmVlTm9vZGxlTm9ybWFsTm9ydGhOb3NlTm90YWJsZU5vdGVOb3RoaW5nTm90aWNlTm92ZWxOb3dOdWNsZWFyTnVtYmVyTnVyc2VOdXRPYWtPYmV5T2JqZWN0T2JsaWdlT2JzY3VyZU9ic2VydmVPYnRhaW5PYnZpb3VzT2NjdXJPY2Vhbk9jdG9iZXJPZG9yT2ZmT2ZmZXJPZmZpY2VPZnRlbk9pbE9rYXlPbGRPbGl2ZU9seW1waWNPbWl0T25jZU9uZU9uaW9uT25saW5lT25seU9wZW5PcGVyYU9waW5pb25PcHBvc2VPcHRpb25PcmFuZ2VPcmJpdE9yY2hhcmRPcmRlck9yZGluYXJ5T3JnYW5PcmllbnRPcmlnaW5hbE9ycGhhbk9zdHJpY2hPdGhlck91dGRvb3JPdXRlck91dHB1dE91dHNpZGVPdmFsT3Zlbk92ZXJPd25Pd25lck94eWdlbk95c3Rlck96b25lUGFjdFBhZGRsZVBhZ2VQYWlyUGFsYWNlUGFsbVBhbmRhUGFuZWxQYW5pY1BhbnRoZXJQYXBlclBhcmFkZVBhcmVudFBhcmtQYXJyb3RQYXJ0eVBhc3NQYXRjaFBhdGhQYXRpZW50UGF0cm9sUGF0dGVyblBhdXNlUGF2ZVBheW1lbnRQZWFjZVBlYW51dFBlYXJQZWFzYW50UGVsaWNhblBlblBlbmFsdHlQZW5jaWxQZW9wbGVQZXBwZXJQZXJmZWN0UGVybWl0UGVyc29uUGV0UGhvbmVQaG90b1BocmFzZVBoeXNpY2FsUGlhbm9QaWNuaWNQaWN0dXJlUGllY2VQaWdQaWdlb25QaWxsUGlsb3RQaW5rUGlvbmVlclBpcGVQaXN0b2xQaXRjaFBpenphUGxhY2VQbGFuZXRQbGFzdGljUGxhdGVQbGF5UGxlYXNlUGxlZGdlUGx1Y2tQbHVnUGx1bmdlUG9lbVBvZXRQb2ludFBvbGFyUG9sZVBvbGljZVBvbmRQb255UG9vbFBvcHVsYXJQb3J0aW9uUG9zaXRpb25Qb3NzaWJsZVBvc3RQb3RhdG9Qb3R0ZXJ5UG92ZXJ0eVBvd2RlclBvd2VyUHJhY3RpY2VQcmFpc2VQcmVkaWN0UHJlZmVyUHJlcGFyZVByZXNlbnRQcmV0dHlQcmV2ZW50UHJpY2VQcmlkZVByaW1hcnlQcmludFByaW9yaXR5UHJpc29uUHJpdmF0ZVByaXplUHJvYmxlbVByb2Nlc3NQcm9kdWNlUHJvZml0UHJvZ3JhbVByb2plY3RQcm9tb3RlUHJvb2ZQcm9wZXJ0eVByb3NwZXJQcm90ZWN0UHJvdWRQcm92aWRlUHVibGljUHVkZGluZ1B1bGxQdWxwUHVsc2VQdW1wa2luUHVuY2hQdXBpbFB1cHB5UHVyY2hhc2VQdXJpdHlQdXJwb3NlUHVyc2VQdXNoUHV0UHV6emxlUHlyYW1pZFF1YWxpdHlRdWFudHVtUXVhcnRlclF1ZXN0aW9uUXVpY2tRdWl0UXVpelF1b3RlUmFiYml0UmFjY29vblJhY2VSYWNrUmFkYXJSYWRpb1JhaWxSYWluUmFpc2VSYWxseVJhbXBSYW5jaFJhbmRvbVJhbmdlUmFwaWRSYXJlUmF0ZVJhdGhlclJhdmVuUmF3UmF6b3JSZWFkeVJlYWxSZWFzb25SZWJlbFJlYnVpbGRSZWNhbGxSZWNlaXZlUmVjaXBlUmVjb3JkUmVjeWNsZVJlZHVjZVJlZmxlY3RSZWZvcm1SZWZ1c2VSZWdpb25SZWdyZXRSZWd1bGFyUmVqZWN0UmVsYXhSZWxlYXNlUmVsaWVmUmVseVJlbWFpblJlbWVtYmVyUmVtaW5kUmVtb3ZlUmVuZGVyUmVuZXdSZW50UmVvcGVuUmVwYWlyUmVwZWF0UmVwbGFjZVJlcG9ydFJlcXVpcmVSZXNjdWVSZXNlbWJsZVJlc2lzdFJlc291cmNlUmVzcG9uc2VSZXN1bHRSZXRpcmVSZXRyZWF0UmV0dXJuUmV1bmlvblJldmVhbFJldmlld1Jld2FyZFJoeXRobVJpYlJpYmJvblJpY2VSaWNoUmlkZVJpZGdlUmlmbGVSaWdodFJpZ2lkUmluZ1Jpb3RSaXBwbGVSaXNrUml0dWFsUml2YWxSaXZlclJvYWRSb2FzdFJvYm90Um9idXN0Um9ja2V0Um9tYW5jZVJvb2ZSb29raWVSb29tUm9zZVJvdGF0ZVJvdWdoUm91bmRSb3V0ZVJveWFsUnViYmVyUnVkZVJ1Z1J1bGVSdW5SdW53YXlSdXJhbFNhZFNhZGRsZVNhZG5lc3NTYWZlU2FpbFNhbGFkU2FsbW9uU2Fsb25TYWx0U2FsdXRlU2FtZVNhbXBsZVNhbmRTYXRpc2Z5U2F0b3NoaVNhdWNlU2F1c2FnZVNhdmVTYXlTY2FsZVNjYW5TY2FyZVNjYXR0ZXJTY2VuZVNjaGVtZVNjaG9vbFNjaWVuY2VTY2lzc29yc1Njb3JwaW9uU2NvdXRTY3JhcFNjcmVlblNjcmlwdFNjcnViU2VhU2VhcmNoU2Vhc29uU2VhdFNlY29uZFNlY3JldFNlY3Rpb25TZWN1cml0eVNlZWRTZWVrU2VnbWVudFNlbGVjdFNlbGxTZW1pbmFyU2VuaW9yU2Vuc2VTZW50ZW5jZVNlcmllc1NlcnZpY2VTZXNzaW9uU2V0dGxlU2V0dXBTZXZlblNoYWRvd1NoYWZ0U2hhbGxvd1NoYXJlU2hlZFNoZWxsU2hlcmlmZlNoaWVsZFNoaWZ0U2hpbmVTaGlwU2hpdmVyU2hvY2tTaG9lU2hvb3RTaG9wU2hvcnRTaG91bGRlclNob3ZlU2hyaW1wU2hydWdTaHVmZmxlU2h5U2libGluZ1NpY2tTaWRlU2llZ2VTaWdodFNpZ25TaWxlbnRTaWxrU2lsbHlTaWx2ZXJTaW1pbGFyU2ltcGxlU2luY2VTaW5nU2lyZW5TaXN0ZXJTaXR1YXRlU2l4U2l6ZVNrYXRlU2tldGNoU2tpU2tpbGxTa2luU2tpcnRTa3VsbFNsYWJTbGFtU2xlZXBTbGVuZGVyU2xpY2VTbGlkZVNsaWdodFNsaW1TbG9nYW5TbG90U2xvd1NsdXNoU21hbGxTbWFydFNtaWxlU21va2VTbW9vdGhTbmFja1NuYWtlU25hcFNuaWZmU25vd1NvYXBTb2NjZXJTb2NpYWxTb2NrU29kYVNvZnRTb2xhclNvbGRpZXJTb2xpZFNvbHV0aW9uU29sdmVTb21lb25lU29uZ1Nvb25Tb3JyeVNvcnRTb3VsU291bmRTb3VwU291cmNlU291dGhTcGFjZVNwYXJlU3BhdGlhbFNwYXduU3BlYWtTcGVjaWFsU3BlZWRTcGVsbFNwZW5kU3BoZXJlU3BpY2VTcGlkZXJTcGlrZVNwaW5TcGlyaXRTcGxpdFNwb2lsU3BvbnNvclNwb29uU3BvcnRTcG90U3ByYXlTcHJlYWRTcHJpbmdTcHlTcXVhcmVTcXVlZXplU3F1aXJyZWxTdGFibGVTdGFkaXVtU3RhZmZTdGFnZVN0YWlyc1N0YW1wU3RhbmRTdGFydFN0YXRlU3RheVN0ZWFrU3RlZWxTdGVtU3RlcFN0ZXJlb1N0aWNrU3RpbGxTdGluZ1N0b2NrU3RvbWFjaFN0b25lU3Rvb2xTdG9yeVN0b3ZlU3RyYXRlZ3lTdHJlZXRTdHJpa2VTdHJvbmdTdHJ1Z2dsZVN0dWRlbnRTdHVmZlN0dW1ibGVTdHlsZVN1YmplY3RTdWJtaXRTdWJ3YXlTdWNjZXNzU3VjaFN1ZGRlblN1ZmZlclN1Z2FyU3VnZ2VzdFN1aXRTdW1tZXJTdW5TdW5ueVN1bnNldFN1cGVyU3VwcGx5U3VwcmVtZVN1cmVTdXJmYWNlU3VyZ2VTdXJwcmlzZVN1cnJvdW5kU3VydmV5U3VzcGVjdFN1c3RhaW5Td2FsbG93U3dhbXBTd2FwU3dhcm1Td2VhclN3ZWV0U3dpZnRTd2ltU3dpbmdTd2l0Y2hTd29yZFN5bWJvbFN5bXB0b21TeXJ1cFN5c3RlbVRhYmxlVGFja2xlVGFnVGFpbFRhbGVudFRhbGtUYW5rVGFwZVRhcmdldFRhc2tUYXN0ZVRhdHRvb1RheGlUZWFjaFRlYW1UZWxsVGVuVGVuYW50VGVubmlzVGVudFRlcm1UZXN0VGV4dFRoYW5rVGhhdFRoZW1lVGhlblRoZW9yeVRoZXJlVGhleVRoaW5nVGhpc1Rob3VnaHRUaHJlZVRocml2ZVRocm93VGh1bWJUaHVuZGVyVGlja2V0VGlkZVRpZ2VyVGlsdFRpbWJlclRpbWVUaW55VGlwVGlyZWRUaXNzdWVUaXRsZVRvYXN0VG9iYWNjb1RvZGF5VG9kZGxlclRvZVRvZ2V0aGVyVG9pbGV0VG9rZW5Ub21hdG9Ub21vcnJvd1RvbmVUb25ndWVUb25pZ2h0VG9vbFRvb3RoVG9wVG9waWNUb3BwbGVUb3JjaFRvcm5hZG9Ub3J0b2lzZVRvc3NUb3RhbFRvdXJpc3RUb3dhcmRUb3dlclRvd25Ub3lUcmFja1RyYWRlVHJhZmZpY1RyYWdpY1RyYWluVHJhbnNmZXJUcmFwVHJhc2hUcmF2ZWxUcmF5VHJlYXRUcmVlVHJlbmRUcmlhbFRyaWJlVHJpY2tUcmlnZ2VyVHJpbVRyaXBUcm9waHlUcm91YmxlVHJ1Y2tUcnVlVHJ1bHlUcnVtcGV0VHJ1c3RUcnV0aFRyeVR1YmVUdWl0aW9uVHVtYmxlVHVuYVR1bm5lbFR1cmtleVR1cm5UdXJ0bGVUd2VsdmVUd2VudHlUd2ljZVR3aW5Ud2lzdFR3b1R5cGVUeXBpY2FsVWdseVVtYnJlbGxhVW5hYmxlVW5hd2FyZVVuY2xlVW5jb3ZlclVuZGVyVW5kb1VuZmFpclVuZm9sZFVuaGFwcHlVbmlmb3JtVW5pcXVlVW5pdFVuaXZlcnNlVW5rbm93blVubG9ja1VudGlsVW51c3VhbFVudmVpbFVwZGF0ZVVwZ3JhZGVVcGhvbGRVcG9uVXBwZXJVcHNldFVyYmFuVXJnZVVzYWdlVXNlVXNlZFVzZWZ1bFVzZWxlc3NVc3VhbFV0aWxpdHlWYWNhbnRWYWN1dW1WYWd1ZVZhbGlkVmFsbGV5VmFsdmVWYW5WYW5pc2hWYXBvclZhcmlvdXNWYXN0VmF1bHRWZWhpY2xlVmVsdmV0VmVuZG9yVmVudHVyZVZlbnVlVmVyYlZlcmlmeVZlcnNpb25WZXJ5VmVzc2VsVmV0ZXJhblZpYWJsZVZpYnJhbnRWaWNpb3VzVmljdG9yeVZpZGVvVmlld1ZpbGxhZ2VWaW50YWdlVmlvbGluVmlydHVhbFZpcnVzVmlzYVZpc2l0VmlzdWFsVml0YWxWaXZpZFZvY2FsVm9pY2VWb2lkVm9sY2Fub1ZvbHVtZVZvdGVWb3lhZ2VXYWdlV2Fnb25XYWl0V2Fsa1dhbGxXYWxudXRXYW50V2FyZmFyZVdhcm1XYXJyaW9yV2FzaFdhc3BXYXN0ZVdhdGVyV2F2ZVdheVdlYWx0aFdlYXBvbldlYXJXZWFzZWxXZWF0aGVyV2ViV2VkZGluZ1dlZWtlbmRXZWlyZFdlbGNvbWVXZXN0V2V0V2hhbGVXaGF0V2hlYXRXaGVlbFdoZW5XaGVyZVdoaXBXaGlzcGVyV2lkZVdpZHRoV2lmZVdpbGRXaWxsV2luV2luZG93V2luZVdpbmdXaW5rV2lubmVyV2ludGVyV2lyZVdpc2RvbVdpc2VXaXNoV2l0bmVzc1dvbGZXb21hbldvbmRlcldvb2RXb29sV29yZFdvcmtXb3JsZFdvcnJ5V29ydGhXcmFwV3JlY2tXcmVzdGxlV3Jpc3RXcml0ZVdyb25nWWFyZFllYXJZZWxsb3dZb3VZb3VuZ1lvdXRoWmVicmFaZXJvWm9uZVpvb1wiO1xuXHR2YXIgd29yZGxpc3QkMSA9IG51bGw7XG5cdGZ1bmN0aW9uIGxvYWRXb3JkcyhsYW5nKSB7XG5cdCAgICBpZiAod29yZGxpc3QkMSAhPSBudWxsKSB7XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHQgICAgd29yZGxpc3QkMSA9IHdvcmRzLnJlcGxhY2UoLyhbQS1aXSkvZywgXCIgJDFcIikudG9Mb3dlckNhc2UoKS5zdWJzdHJpbmcoMSkuc3BsaXQoXCIgXCIpO1xuXHQgICAgLy8gVmVyaWZ5IHRoZSBjb21wdXRlZCBsaXN0IG1hdGNoZXMgdGhlIG9mZmljaWFsIGxpc3Rcblx0ICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuXHQgICAgaWYgKHdvcmRsaXN0LldvcmRsaXN0LmNoZWNrKGxhbmcpICE9PSBcIjB4M2M4YWNjMWU3YjA4ZDhlNzZmOWZkYTAxNWVmNDhkYzhjNzEwYTczY2I3ZTBmNzdiMmMxOGE5YjVhN2FkZGU2MFwiKSB7XG5cdCAgICAgICAgd29yZGxpc3QkMSA9IG51bGw7XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQklQMzkgV29yZGxpc3QgZm9yIGVuIChFbmdsaXNoKSBGQUlMRURcIik7XG5cdCAgICB9XG5cdH1cblx0dmFyIExhbmdFbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0ICAgIF9fZXh0ZW5kcyhMYW5nRW4sIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBMYW5nRW4oKSB7XG5cdCAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIFwiZW5cIikgfHwgdGhpcztcblx0ICAgIH1cblx0ICAgIExhbmdFbi5wcm90b3R5cGUuZ2V0V29yZCA9IGZ1bmN0aW9uIChpbmRleCkge1xuXHQgICAgICAgIGxvYWRXb3Jkcyh0aGlzKTtcblx0ICAgICAgICByZXR1cm4gd29yZGxpc3QkMVtpbmRleF07XG5cdCAgICB9O1xuXHQgICAgTGFuZ0VuLnByb3RvdHlwZS5nZXRXb3JkSW5kZXggPSBmdW5jdGlvbiAod29yZCkge1xuXHQgICAgICAgIGxvYWRXb3Jkcyh0aGlzKTtcblx0ICAgICAgICByZXR1cm4gd29yZGxpc3QkMS5pbmRleE9mKHdvcmQpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBMYW5nRW47XG5cdH0od29yZGxpc3QuV29yZGxpc3QpKTtcblx0dmFyIGxhbmdFbiA9IG5ldyBMYW5nRW4oKTtcblx0ZXhwb3J0cy5sYW5nRW4gPSBsYW5nRW47XG5cdHdvcmRsaXN0LldvcmRsaXN0LnJlZ2lzdGVyKGxhbmdFbik7XG5cblx0fSk7XG5cblx0dmFyIGxhbmdFbiA9IHVud3JhcEV4cG9ydHMobGFuZ0VuXzEpO1xuXHR2YXIgbGFuZ0VuXzIgPSBsYW5nRW5fMS5sYW5nRW47XG5cblx0dmFyIGJyb3dzZXIkNCA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0Ly8gV29yZGxpc3RzXG5cdC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDAzOS9iaXAtMDAzOS13b3JkbGlzdHMubWRcblxuXHRleHBvcnRzLldvcmRsaXN0ID0gd29yZGxpc3QuV29yZGxpc3Q7XG5cblx0dmFyIHdvcmRsaXN0cyA9IHsgZW46IGxhbmdFbl8xLmxhbmdFbiB9O1xuXHRleHBvcnRzLndvcmRsaXN0cyA9IHdvcmRsaXN0cztcblxuXHR9KTtcblxuXHR2YXIgYnJvd3NlciQ1ID0gdW53cmFwRXhwb3J0cyhicm93c2VyJDQpO1xuXHR2YXIgYnJvd3Nlcl8xJDIgPSBicm93c2VyJDQuV29yZGxpc3Q7XG5cdHZhciBicm93c2VyXzIkMSA9IGJyb3dzZXIkNC53b3JkbGlzdHM7XG5cblx0dmFyIF92ZXJzaW9uJHcgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMudmVyc2lvbiA9IFwiaGRub2RlLzUuMC4yXCI7XG5cblx0fSk7XG5cblx0dmFyIF92ZXJzaW9uJHggPSB1bndyYXBFeHBvcnRzKF92ZXJzaW9uJHcpO1xuXHR2YXIgX3ZlcnNpb25fMSRnID0gX3ZlcnNpb24kdy52ZXJzaW9uO1xuXG5cdHZhciBsaWIkaCA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblx0dmFyIGxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJHcudmVyc2lvbik7XG5cdHZhciBOID0gbGliJDIuQmlnTnVtYmVyLmZyb20oXCIweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlYmFhZWRjZTZhZjQ4YTAzYmJmZDI1ZThjZDAzNjQxNDFcIik7XG5cdC8vIFwiQml0Y29pbiBzZWVkXCJcblx0dmFyIE1hc3RlclNlY3JldCA9IGxpYiQ4LnRvVXRmOEJ5dGVzKFwiQml0Y29pbiBzZWVkXCIpO1xuXHR2YXIgSGFyZGVuZWRCaXQgPSAweDgwMDAwMDAwO1xuXHQvLyBSZXR1cm5zIGEgYnl0ZSB3aXRoIHRoZSBNU0IgYml0cyBzZXRcblx0ZnVuY3Rpb24gZ2V0VXBwZXJNYXNrKGJpdHMpIHtcblx0ICAgIHJldHVybiAoKDEgPDwgYml0cykgLSAxKSA8PCAoOCAtIGJpdHMpO1xuXHR9XG5cdC8vIFJldHVybnMgYSBieXRlIHdpdGggdGhlIExTQiBiaXRzIHNldFxuXHRmdW5jdGlvbiBnZXRMb3dlck1hc2soYml0cykge1xuXHQgICAgcmV0dXJuICgxIDw8IGJpdHMpIC0gMTtcblx0fVxuXHRmdW5jdGlvbiBieXRlczMyKHZhbHVlKSB7XG5cdCAgICByZXR1cm4gbGliJDEuaGV4WmVyb1BhZChsaWIkMS5oZXhsaWZ5KHZhbHVlKSwgMzIpO1xuXHR9XG5cdGZ1bmN0aW9uIGJhc2U1OGNoZWNrKGRhdGEpIHtcblx0ICAgIHJldHVybiBsaWIkZS5CYXNlNTguZW5jb2RlKGxpYiQxLmNvbmNhdChbZGF0YSwgbGliJDEuaGV4RGF0YVNsaWNlKGJyb3dzZXIuc2hhMjU2KGJyb3dzZXIuc2hhMjU2KGRhdGEpKSwgMCwgNCldKSk7XG5cdH1cblx0ZnVuY3Rpb24gZ2V0V29yZGxpc3Qod29yZGxpc3QpIHtcblx0ICAgIGlmICh3b3JkbGlzdCA9PSBudWxsKSB7XG5cdCAgICAgICAgcmV0dXJuIGJyb3dzZXIkNC53b3JkbGlzdHNbXCJlblwiXTtcblx0ICAgIH1cblx0ICAgIGlmICh0eXBlb2YgKHdvcmRsaXN0KSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgIHZhciB3b3JkcyA9IGJyb3dzZXIkNC53b3JkbGlzdHNbd29yZGxpc3RdO1xuXHQgICAgICAgIGlmICh3b3JkcyA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bmtub3duIGxvY2FsZVwiLCBcIndvcmRsaXN0XCIsIHdvcmRsaXN0KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHdvcmRzO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHdvcmRsaXN0O1xuXHR9XG5cdHZhciBfY29uc3RydWN0b3JHdWFyZCA9IHt9O1xuXHRleHBvcnRzLmRlZmF1bHRQYXRoID0gXCJtLzQ0Jy82MCcvMCcvMC8wXCI7XG5cdDtcblx0dmFyIEhETm9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcblx0ICAgIC8qKlxuXHQgICAgICogIFRoaXMgY29uc3RydWN0b3Igc2hvdWxkIG5vdCBiZSBjYWxsZWQgZGlyZWN0bHkuXG5cdCAgICAgKlxuXHQgICAgICogIFBsZWFzZSB1c2U6XG5cdCAgICAgKiAgIC0gZnJvbU1uZW1vbmljXG5cdCAgICAgKiAgIC0gZnJvbVNlZWRcblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gSEROb2RlKGNvbnN0cnVjdG9yR3VhcmQsIHByaXZhdGVLZXksIHB1YmxpY0tleSwgcGFyZW50RmluZ2VycHJpbnQsIGNoYWluQ29kZSwgaW5kZXgsIGRlcHRoLCBtbmVtb25pY09yUGF0aCkge1xuXHQgICAgICAgIHZhciBfbmV3VGFyZ2V0ID0gdGhpcy5jb25zdHJ1Y3Rvcjtcblx0ICAgICAgICBsb2dnZXIuY2hlY2tOZXcoX25ld1RhcmdldCwgSEROb2RlKTtcblx0ICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0ICAgICAgICBpZiAoY29uc3RydWN0b3JHdWFyZCAhPT0gX2NvbnN0cnVjdG9yR3VhcmQpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSEROb2RlIGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgZGlyZWN0bHlcIik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChwcml2YXRlS2V5KSB7XG5cdCAgICAgICAgICAgIHZhciBzaWduaW5nS2V5ID0gbmV3IGxpYiRmLlNpZ25pbmdLZXkocHJpdmF0ZUtleSk7XG5cdCAgICAgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KHRoaXMsIFwicHJpdmF0ZUtleVwiLCBzaWduaW5nS2V5LnByaXZhdGVLZXkpO1xuXHQgICAgICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcInB1YmxpY0tleVwiLCBzaWduaW5nS2V5LmNvbXByZXNzZWRQdWJsaWNLZXkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJwcml2YXRlS2V5XCIsIG51bGwpO1xuXHQgICAgICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcInB1YmxpY0tleVwiLCBsaWIkMS5oZXhsaWZ5KHB1YmxpY0tleSkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcInBhcmVudEZpbmdlcnByaW50XCIsIHBhcmVudEZpbmdlcnByaW50KTtcblx0ICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcImZpbmdlcnByaW50XCIsIGxpYiQxLmhleERhdGFTbGljZShicm93c2VyLnJpcGVtZDE2MChicm93c2VyLnNoYTI1Nih0aGlzLnB1YmxpY0tleSkpLCAwLCA0KSk7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJhZGRyZXNzXCIsIGxpYiRnLmNvbXB1dGVBZGRyZXNzKHRoaXMucHVibGljS2V5KSk7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJjaGFpbkNvZGVcIiwgY2hhaW5Db2RlKTtcblx0ICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcImluZGV4XCIsIGluZGV4KTtcblx0ICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcImRlcHRoXCIsIGRlcHRoKTtcblx0ICAgICAgICBpZiAobW5lbW9uaWNPclBhdGggPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAvLyBGcm9tIGEgc291cmNlIHRoYXQgZG9lcyBub3QgcHJlc2VydmUgdGhlIHBhdGggKGUuZy4gZXh0ZW5kZWQga2V5cylcblx0ICAgICAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJtbmVtb25pY1wiLCBudWxsKTtcblx0ICAgICAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJwYXRoXCIsIG51bGwpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIGlmICh0eXBlb2YgKG1uZW1vbmljT3JQYXRoKSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgICAgICAvLyBGcm9tIGEgc291cmNlIHRoYXQgZG9lcyBub3QgcHJlc2VydmUgdGhlIG1uZW1vbmljIChlLmcuIG5ldXRlcmVkKVxuXHQgICAgICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcIm1uZW1vbmljXCIsIG51bGwpO1xuXHQgICAgICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcInBhdGhcIiwgbW5lbW9uaWNPclBhdGgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgLy8gRnJvbSBhIGZ1bGx5IHF1YWxpZmllZCBzb3VyY2Vcblx0ICAgICAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJtbmVtb25pY1wiLCBtbmVtb25pY09yUGF0aCk7XG5cdCAgICAgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KHRoaXMsIFwicGF0aFwiLCBtbmVtb25pY09yUGF0aC5wYXRoKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSEROb2RlLnByb3RvdHlwZSwgXCJleHRlbmRlZEtleVwiLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFdlIG9ubHkgc3VwcG9ydCB0aGUgbWFpbm5ldCB2YWx1ZXMgZm9yIG5vdywgYnV0IGlmIGFueW9uZSBuZWVkc1xuXHQgICAgICAgICAgICAvLyB0ZXN0bmV0IHZhbHVlcywgbGV0IG1lIGtub3cuIEkgYmVsaWV2ZSBjdXJyZW50IHNlbml0bWVudCBpcyB0aGF0XG5cdCAgICAgICAgICAgIC8vIHdlIHNob3VsZCBhbHdheXMgdXNlIG1haW5uZXQsIGFuZCB1c2UgQklQLTQ0IHRvIGRlcml2ZSB0aGUgbmV0d29ya1xuXHQgICAgICAgICAgICAvLyAgIC0gTWFpbm5ldDogcHVibGljPTB4MDQ4OEIyMUUsIHByaXZhdGU9MHgwNDg4QURFNFxuXHQgICAgICAgICAgICAvLyAgIC0gVGVzdG5ldDogcHVibGljPTB4MDQzNTg3Q0YsIHByaXZhdGU9MHgwNDM1ODM5NFxuXHQgICAgICAgICAgICBpZiAodGhpcy5kZXB0aCA+PSAyNTYpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRlcHRoIHRvbyBsYXJnZSFcIik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIGJhc2U1OGNoZWNrKGxpYiQxLmNvbmNhdChbXG5cdCAgICAgICAgICAgICAgICAoKHRoaXMucHJpdmF0ZUtleSAhPSBudWxsKSA/IFwiMHgwNDg4QURFNFwiIDogXCIweDA0ODhCMjFFXCIpLFxuXHQgICAgICAgICAgICAgICAgbGliJDEuaGV4bGlmeSh0aGlzLmRlcHRoKSxcblx0ICAgICAgICAgICAgICAgIHRoaXMucGFyZW50RmluZ2VycHJpbnQsXG5cdCAgICAgICAgICAgICAgICBsaWIkMS5oZXhaZXJvUGFkKGxpYiQxLmhleGxpZnkodGhpcy5pbmRleCksIDQpLFxuXHQgICAgICAgICAgICAgICAgdGhpcy5jaGFpbkNvZGUsXG5cdCAgICAgICAgICAgICAgICAoKHRoaXMucHJpdmF0ZUtleSAhPSBudWxsKSA/IGxpYiQxLmNvbmNhdChbXCIweDAwXCIsIHRoaXMucHJpdmF0ZUtleV0pIDogdGhpcy5wdWJsaWNLZXkpLFxuXHQgICAgICAgICAgICBdKSk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXHQgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHQgICAgfSk7XG5cdCAgICBIRE5vZGUucHJvdG90eXBlLm5ldXRlciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gbmV3IEhETm9kZShfY29uc3RydWN0b3JHdWFyZCwgbnVsbCwgdGhpcy5wdWJsaWNLZXksIHRoaXMucGFyZW50RmluZ2VycHJpbnQsIHRoaXMuY2hhaW5Db2RlLCB0aGlzLmluZGV4LCB0aGlzLmRlcHRoLCB0aGlzLnBhdGgpO1xuXHQgICAgfTtcblx0ICAgIEhETm9kZS5wcm90b3R5cGUuX2Rlcml2ZSA9IGZ1bmN0aW9uIChpbmRleCkge1xuXHQgICAgICAgIGlmIChpbmRleCA+IDB4ZmZmZmZmZmYpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbmRleCAtIFwiICsgU3RyaW5nKGluZGV4KSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIEJhc2UgcGF0aFxuXHQgICAgICAgIHZhciBwYXRoID0gdGhpcy5wYXRoO1xuXHQgICAgICAgIGlmIChwYXRoKSB7XG5cdCAgICAgICAgICAgIHBhdGggKz0gXCIvXCIgKyAoaW5kZXggJiB+SGFyZGVuZWRCaXQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgZGF0YSA9IG5ldyBVaW50OEFycmF5KDM3KTtcblx0ICAgICAgICBpZiAoaW5kZXggJiBIYXJkZW5lZEJpdCkge1xuXHQgICAgICAgICAgICBpZiAoIXRoaXMucHJpdmF0ZUtleSkge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGRlcml2ZSBjaGlsZCBvZiBuZXV0ZXJlZCBub2RlXCIpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIC8vIERhdGEgPSAweDAwIHx8IHNlcl8yNTYoa19wYXIpXG5cdCAgICAgICAgICAgIGRhdGEuc2V0KGxpYiQxLmFycmF5aWZ5KHRoaXMucHJpdmF0ZUtleSksIDEpO1xuXHQgICAgICAgICAgICAvLyBIYXJkZW5lZCBwYXRoXG5cdCAgICAgICAgICAgIGlmIChwYXRoKSB7XG5cdCAgICAgICAgICAgICAgICBwYXRoICs9IFwiJ1wiO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAvLyBEYXRhID0gc2VyX3AocG9pbnQoa19wYXIpKVxuXHQgICAgICAgICAgICBkYXRhLnNldChsaWIkMS5hcnJheWlmeSh0aGlzLnB1YmxpY0tleSkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBEYXRhICs9IHNlcl8zMihpKVxuXHQgICAgICAgIGZvciAodmFyIGkgPSAyNDsgaSA+PSAwOyBpIC09IDgpIHtcblx0ICAgICAgICAgICAgZGF0YVszMyArIChpID4+IDMpXSA9ICgoaW5kZXggPj4gKDI0IC0gaSkpICYgMHhmZik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBJID0gbGliJDEuYXJyYXlpZnkoYnJvd3Nlci5jb21wdXRlSG1hYyhicm93c2VyLlN1cHBvcnRlZEFsZ29yaXRobS5zaGE1MTIsIHRoaXMuY2hhaW5Db2RlLCBkYXRhKSk7XG5cdCAgICAgICAgdmFyIElMID0gSS5zbGljZSgwLCAzMik7XG5cdCAgICAgICAgdmFyIElSID0gSS5zbGljZSgzMik7XG5cdCAgICAgICAgLy8gVGhlIHByaXZhdGUga2V5XG5cdCAgICAgICAgdmFyIGtpID0gbnVsbDtcblx0ICAgICAgICAvLyBUaGUgcHVibGljIGtleVxuXHQgICAgICAgIHZhciBLaSA9IG51bGw7XG5cdCAgICAgICAgaWYgKHRoaXMucHJpdmF0ZUtleSkge1xuXHQgICAgICAgICAgICBraSA9IGJ5dGVzMzIobGliJDIuQmlnTnVtYmVyLmZyb20oSUwpLmFkZCh0aGlzLnByaXZhdGVLZXkpLm1vZChOKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICB2YXIgZWsgPSBuZXcgbGliJGYuU2lnbmluZ0tleShsaWIkMS5oZXhsaWZ5KElMKSk7XG5cdCAgICAgICAgICAgIEtpID0gZWsuX2FkZFBvaW50KHRoaXMucHVibGljS2V5KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIG1uZW1vbmljT3JQYXRoID0gcGF0aDtcblx0ICAgICAgICB2YXIgc3JjTW5lbW9uaWMgPSB0aGlzLm1uZW1vbmljO1xuXHQgICAgICAgIGlmIChzcmNNbmVtb25pYykge1xuXHQgICAgICAgICAgICBtbmVtb25pY09yUGF0aCA9IE9iamVjdC5mcmVlemUoe1xuXHQgICAgICAgICAgICAgICAgcGhyYXNlOiBzcmNNbmVtb25pYy5waHJhc2UsXG5cdCAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuXHQgICAgICAgICAgICAgICAgbG9jYWxlOiAoc3JjTW5lbW9uaWMubG9jYWxlIHx8IFwiZW5cIilcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBuZXcgSEROb2RlKF9jb25zdHJ1Y3Rvckd1YXJkLCBraSwgS2ksIHRoaXMuZmluZ2VycHJpbnQsIGJ5dGVzMzIoSVIpLCBpbmRleCwgdGhpcy5kZXB0aCArIDEsIG1uZW1vbmljT3JQYXRoKTtcblx0ICAgIH07XG5cdCAgICBIRE5vZGUucHJvdG90eXBlLmRlcml2ZVBhdGggPSBmdW5jdGlvbiAocGF0aCkge1xuXHQgICAgICAgIHZhciBjb21wb25lbnRzID0gcGF0aC5zcGxpdChcIi9cIik7XG5cdCAgICAgICAgaWYgKGNvbXBvbmVudHMubGVuZ3RoID09PSAwIHx8IChjb21wb25lbnRzWzBdID09PSBcIm1cIiAmJiB0aGlzLmRlcHRoICE9PSAwKSkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBhdGggLSBcIiArIHBhdGgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoY29tcG9uZW50c1swXSA9PT0gXCJtXCIpIHtcblx0ICAgICAgICAgICAgY29tcG9uZW50cy5zaGlmdCgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcztcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbXBvbmVudHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgdmFyIGNvbXBvbmVudCA9IGNvbXBvbmVudHNbaV07XG5cdCAgICAgICAgICAgIGlmIChjb21wb25lbnQubWF0Y2goL15bMC05XSsnJC8pKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBwYXJzZUludChjb21wb25lbnQuc3Vic3RyaW5nKDAsIGNvbXBvbmVudC5sZW5ndGggLSAxKSk7XG5cdCAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gSGFyZGVuZWRCaXQpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBhdGggaW5kZXggLSBcIiArIGNvbXBvbmVudCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuX2Rlcml2ZShIYXJkZW5lZEJpdCArIGluZGV4KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIGlmIChjb21wb25lbnQubWF0Y2goL15bMC05XSskLykpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHBhcnNlSW50KGNvbXBvbmVudCk7XG5cdCAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gSGFyZGVuZWRCaXQpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBhdGggaW5kZXggLSBcIiArIGNvbXBvbmVudCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuX2Rlcml2ZShpbmRleCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBhdGggY29tcG9uZW50IC0gXCIgKyBjb21wb25lbnQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9O1xuXHQgICAgSEROb2RlLl9mcm9tU2VlZCA9IGZ1bmN0aW9uIChzZWVkLCBtbmVtb25pYykge1xuXHQgICAgICAgIHZhciBzZWVkQXJyYXkgPSBsaWIkMS5hcnJheWlmeShzZWVkKTtcblx0ICAgICAgICBpZiAoc2VlZEFycmF5Lmxlbmd0aCA8IDE2IHx8IHNlZWRBcnJheS5sZW5ndGggPiA2NCkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHNlZWRcIik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBJID0gbGliJDEuYXJyYXlpZnkoYnJvd3Nlci5jb21wdXRlSG1hYyhicm93c2VyLlN1cHBvcnRlZEFsZ29yaXRobS5zaGE1MTIsIE1hc3RlclNlY3JldCwgc2VlZEFycmF5KSk7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBIRE5vZGUoX2NvbnN0cnVjdG9yR3VhcmQsIGJ5dGVzMzIoSS5zbGljZSgwLCAzMikpLCBudWxsLCBcIjB4MDAwMDAwMDBcIiwgYnl0ZXMzMihJLnNsaWNlKDMyKSksIDAsIDAsIG1uZW1vbmljKTtcblx0ICAgIH07XG5cdCAgICBIRE5vZGUuZnJvbU1uZW1vbmljID0gZnVuY3Rpb24gKG1uZW1vbmljLCBwYXNzd29yZCwgd29yZGxpc3QpIHtcblx0ICAgICAgICAvLyBJZiBhIGxvY2FsZSBuYW1lIHdhcyBwYXNzZWQgaW4sIGZpbmQgdGhlIGFzc29jaWF0ZWQgd29yZGxpc3Rcblx0ICAgICAgICB3b3JkbGlzdCA9IGdldFdvcmRsaXN0KHdvcmRsaXN0KTtcblx0ICAgICAgICAvLyBOb3JtYWxpemUgdGhlIGNhc2UgYW5kIHNwYWNpbmcgaW4gdGhlIG1uZW1vbmljICh0aHJvd3MgaWYgdGhlIG1uZW1vbmljIGlzIGludmFsaWQpXG5cdCAgICAgICAgbW5lbW9uaWMgPSBlbnRyb3B5VG9NbmVtb25pYyhtbmVtb25pY1RvRW50cm9weShtbmVtb25pYywgd29yZGxpc3QpLCB3b3JkbGlzdCk7XG5cdCAgICAgICAgcmV0dXJuIEhETm9kZS5fZnJvbVNlZWQobW5lbW9uaWNUb1NlZWQobW5lbW9uaWMsIHBhc3N3b3JkKSwge1xuXHQgICAgICAgICAgICBwaHJhc2U6IG1uZW1vbmljLFxuXHQgICAgICAgICAgICBwYXRoOiBcIm1cIixcblx0ICAgICAgICAgICAgbG9jYWxlOiB3b3JkbGlzdC5sb2NhbGVcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBIRE5vZGUuZnJvbVNlZWQgPSBmdW5jdGlvbiAoc2VlZCkge1xuXHQgICAgICAgIHJldHVybiBIRE5vZGUuX2Zyb21TZWVkKHNlZWQsIG51bGwpO1xuXHQgICAgfTtcblx0ICAgIEhETm9kZS5mcm9tRXh0ZW5kZWRLZXkgPSBmdW5jdGlvbiAoZXh0ZW5kZWRLZXkpIHtcblx0ICAgICAgICB2YXIgYnl0ZXMgPSBsaWIkZS5CYXNlNTguZGVjb2RlKGV4dGVuZGVkS2V5KTtcblx0ICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoICE9PSA4MiB8fCBiYXNlNThjaGVjayhieXRlcy5zbGljZSgwLCA3OCkpICE9PSBleHRlbmRlZEtleSkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBleHRlbmRlZCBrZXlcIiwgXCJleHRlbmRlZEtleVwiLCBcIltSRURBQ1RFRF1cIik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBkZXB0aCA9IGJ5dGVzWzRdO1xuXHQgICAgICAgIHZhciBwYXJlbnRGaW5nZXJwcmludCA9IGxpYiQxLmhleGxpZnkoYnl0ZXMuc2xpY2UoNSwgOSkpO1xuXHQgICAgICAgIHZhciBpbmRleCA9IHBhcnNlSW50KGxpYiQxLmhleGxpZnkoYnl0ZXMuc2xpY2UoOSwgMTMpKS5zdWJzdHJpbmcoMiksIDE2KTtcblx0ICAgICAgICB2YXIgY2hhaW5Db2RlID0gbGliJDEuaGV4bGlmeShieXRlcy5zbGljZSgxMywgNDUpKTtcblx0ICAgICAgICB2YXIga2V5ID0gYnl0ZXMuc2xpY2UoNDUsIDc4KTtcblx0ICAgICAgICBzd2l0Y2ggKGxpYiQxLmhleGxpZnkoYnl0ZXMuc2xpY2UoMCwgNCkpKSB7XG5cdCAgICAgICAgICAgIC8vIFB1YmxpYyBLZXlcblx0ICAgICAgICAgICAgY2FzZSBcIjB4MDQ4OGIyMWVcIjpcblx0ICAgICAgICAgICAgY2FzZSBcIjB4MDQzNTg3Y2ZcIjpcblx0ICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSEROb2RlKF9jb25zdHJ1Y3Rvckd1YXJkLCBudWxsLCBsaWIkMS5oZXhsaWZ5KGtleSksIHBhcmVudEZpbmdlcnByaW50LCBjaGFpbkNvZGUsIGluZGV4LCBkZXB0aCwgbnVsbCk7XG5cdCAgICAgICAgICAgIC8vIFByaXZhdGUgS2V5XG5cdCAgICAgICAgICAgIGNhc2UgXCIweDA0ODhhZGU0XCI6XG5cdCAgICAgICAgICAgIGNhc2UgXCIweDA0MzU4Mzk0IFwiOlxuXHQgICAgICAgICAgICAgICAgaWYgKGtleVswXSAhPT0gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBIRE5vZGUoX2NvbnN0cnVjdG9yR3VhcmQsIGxpYiQxLmhleGxpZnkoa2V5LnNsaWNlKDEpKSwgbnVsbCwgcGFyZW50RmluZ2VycHJpbnQsIGNoYWluQ29kZSwgaW5kZXgsIGRlcHRoLCBudWxsKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGV4dGVuZGVkIGtleVwiLCBcImV4dGVuZGVkS2V5XCIsIFwiW1JFREFDVEVEXVwiKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gSEROb2RlO1xuXHR9KCkpO1xuXHRleHBvcnRzLkhETm9kZSA9IEhETm9kZTtcblx0ZnVuY3Rpb24gbW5lbW9uaWNUb1NlZWQobW5lbW9uaWMsIHBhc3N3b3JkKSB7XG5cdCAgICBpZiAoIXBhc3N3b3JkKSB7XG5cdCAgICAgICAgcGFzc3dvcmQgPSBcIlwiO1xuXHQgICAgfVxuXHQgICAgdmFyIHNhbHQgPSBsaWIkOC50b1V0ZjhCeXRlcyhcIm1uZW1vbmljXCIgKyBwYXNzd29yZCwgbGliJDguVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtLk5GS0QpO1xuXHQgICAgcmV0dXJuIGJyb3dzZXIkMi5wYmtkZjIobGliJDgudG9VdGY4Qnl0ZXMobW5lbW9uaWMsIGxpYiQ4LlVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybS5ORktEKSwgc2FsdCwgMjA0OCwgNjQsIFwic2hhNTEyXCIpO1xuXHR9XG5cdGV4cG9ydHMubW5lbW9uaWNUb1NlZWQgPSBtbmVtb25pY1RvU2VlZDtcblx0ZnVuY3Rpb24gbW5lbW9uaWNUb0VudHJvcHkobW5lbW9uaWMsIHdvcmRsaXN0KSB7XG5cdCAgICB3b3JkbGlzdCA9IGdldFdvcmRsaXN0KHdvcmRsaXN0KTtcblx0ICAgIGxvZ2dlci5jaGVja05vcm1hbGl6ZSgpO1xuXHQgICAgdmFyIHdvcmRzID0gd29yZGxpc3Quc3BsaXQobW5lbW9uaWMpO1xuXHQgICAgaWYgKCh3b3Jkcy5sZW5ndGggJSAzKSAhPT0gMCkge1xuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgbW5lbW9uaWNcIik7XG5cdCAgICB9XG5cdCAgICB2YXIgZW50cm9weSA9IGxpYiQxLmFycmF5aWZ5KG5ldyBVaW50OEFycmF5KE1hdGguY2VpbCgxMSAqIHdvcmRzLmxlbmd0aCAvIDgpKSk7XG5cdCAgICB2YXIgb2Zmc2V0ID0gMDtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd29yZHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICB2YXIgaW5kZXggPSB3b3JkbGlzdC5nZXRXb3JkSW5kZXgod29yZHNbaV0ubm9ybWFsaXplKFwiTkZLRFwiKSk7XG5cdCAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIG1uZW1vbmljXCIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmb3IgKHZhciBiaXQgPSAwOyBiaXQgPCAxMTsgYml0KyspIHtcblx0ICAgICAgICAgICAgaWYgKGluZGV4ICYgKDEgPDwgKDEwIC0gYml0KSkpIHtcblx0ICAgICAgICAgICAgICAgIGVudHJvcHlbb2Zmc2V0ID4+IDNdIHw9ICgxIDw8ICg3IC0gKG9mZnNldCAlIDgpKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgb2Zmc2V0Kys7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgdmFyIGVudHJvcHlCaXRzID0gMzIgKiB3b3Jkcy5sZW5ndGggLyAzO1xuXHQgICAgdmFyIGNoZWNrc3VtQml0cyA9IHdvcmRzLmxlbmd0aCAvIDM7XG5cdCAgICB2YXIgY2hlY2tzdW1NYXNrID0gZ2V0VXBwZXJNYXNrKGNoZWNrc3VtQml0cyk7XG5cdCAgICB2YXIgY2hlY2tzdW0gPSBsaWIkMS5hcnJheWlmeShicm93c2VyLnNoYTI1NihlbnRyb3B5LnNsaWNlKDAsIGVudHJvcHlCaXRzIC8gOCkpKVswXSAmIGNoZWNrc3VtTWFzaztcblx0ICAgIGlmIChjaGVja3N1bSAhPT0gKGVudHJvcHlbZW50cm9weS5sZW5ndGggLSAxXSAmIGNoZWNrc3VtTWFzaykpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGNoZWNrc3VtXCIpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGxpYiQxLmhleGxpZnkoZW50cm9weS5zbGljZSgwLCBlbnRyb3B5Qml0cyAvIDgpKTtcblx0fVxuXHRleHBvcnRzLm1uZW1vbmljVG9FbnRyb3B5ID0gbW5lbW9uaWNUb0VudHJvcHk7XG5cdGZ1bmN0aW9uIGVudHJvcHlUb01uZW1vbmljKGVudHJvcHksIHdvcmRsaXN0KSB7XG5cdCAgICB3b3JkbGlzdCA9IGdldFdvcmRsaXN0KHdvcmRsaXN0KTtcblx0ICAgIGVudHJvcHkgPSBsaWIkMS5hcnJheWlmeShlbnRyb3B5KTtcblx0ICAgIGlmICgoZW50cm9weS5sZW5ndGggJSA0KSAhPT0gMCB8fCBlbnRyb3B5Lmxlbmd0aCA8IDE2IHx8IGVudHJvcHkubGVuZ3RoID4gMzIpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGVudHJvcHlcIik7XG5cdCAgICB9XG5cdCAgICB2YXIgaW5kaWNlcyA9IFswXTtcblx0ICAgIHZhciByZW1haW5pbmdCaXRzID0gMTE7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVudHJvcHkubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAvLyBDb25zdW1lIHRoZSB3aG9sZSBieXRlICh3aXRoIHN0aWxsIG1vcmUgdG8gZ28pXG5cdCAgICAgICAgaWYgKHJlbWFpbmluZ0JpdHMgPiA4KSB7XG5cdCAgICAgICAgICAgIGluZGljZXNbaW5kaWNlcy5sZW5ndGggLSAxXSA8PD0gODtcblx0ICAgICAgICAgICAgaW5kaWNlc1tpbmRpY2VzLmxlbmd0aCAtIDFdIHw9IGVudHJvcHlbaV07XG5cdCAgICAgICAgICAgIHJlbWFpbmluZ0JpdHMgLT0gODtcblx0ICAgICAgICAgICAgLy8gVGhpcyBieXRlIHdpbGwgY29tcGxldGUgYW4gMTEtYml0IGluZGV4XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICBpbmRpY2VzW2luZGljZXMubGVuZ3RoIC0gMV0gPDw9IHJlbWFpbmluZ0JpdHM7XG5cdCAgICAgICAgICAgIGluZGljZXNbaW5kaWNlcy5sZW5ndGggLSAxXSB8PSBlbnRyb3B5W2ldID4+ICg4IC0gcmVtYWluaW5nQml0cyk7XG5cdCAgICAgICAgICAgIC8vIFN0YXJ0IHRoZSBuZXh0IHdvcmRcblx0ICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGVudHJvcHlbaV0gJiBnZXRMb3dlck1hc2soOCAtIHJlbWFpbmluZ0JpdHMpKTtcblx0ICAgICAgICAgICAgcmVtYWluaW5nQml0cyArPSAzO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIC8vIENvbXB1dGUgdGhlIGNoZWNrc3VtIGJpdHNcblx0ICAgIHZhciBjaGVja3N1bUJpdHMgPSBlbnRyb3B5Lmxlbmd0aCAvIDQ7XG5cdCAgICB2YXIgY2hlY2tzdW0gPSBsaWIkMS5hcnJheWlmeShicm93c2VyLnNoYTI1NihlbnRyb3B5KSlbMF0gJiBnZXRVcHBlck1hc2soY2hlY2tzdW1CaXRzKTtcblx0ICAgIC8vIFNoaWZ0IHRoZSBjaGVja3N1bSBpbnRvIHRoZSB3b3JkIGluZGljZXNcblx0ICAgIGluZGljZXNbaW5kaWNlcy5sZW5ndGggLSAxXSA8PD0gY2hlY2tzdW1CaXRzO1xuXHQgICAgaW5kaWNlc1tpbmRpY2VzLmxlbmd0aCAtIDFdIHw9IChjaGVja3N1bSA+PiAoOCAtIGNoZWNrc3VtQml0cykpO1xuXHQgICAgcmV0dXJuIHdvcmRsaXN0LmpvaW4oaW5kaWNlcy5tYXAoZnVuY3Rpb24gKGluZGV4KSB7IHJldHVybiB3b3JkbGlzdC5nZXRXb3JkKGluZGV4KTsgfSkpO1xuXHR9XG5cdGV4cG9ydHMuZW50cm9weVRvTW5lbW9uaWMgPSBlbnRyb3B5VG9NbmVtb25pYztcblx0ZnVuY3Rpb24gaXNWYWxpZE1uZW1vbmljKG1uZW1vbmljLCB3b3JkbGlzdCkge1xuXHQgICAgdHJ5IHtcblx0ICAgICAgICBtbmVtb25pY1RvRW50cm9weShtbmVtb25pYywgd29yZGxpc3QpO1xuXHQgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfVxuXHQgICAgY2F0Y2ggKGVycm9yKSB7IH1cblx0ICAgIHJldHVybiBmYWxzZTtcblx0fVxuXHRleHBvcnRzLmlzVmFsaWRNbmVtb25pYyA9IGlzVmFsaWRNbmVtb25pYztcblxuXHR9KTtcblxuXHR2YXIgaW5kZXgkaCA9IHVud3JhcEV4cG9ydHMobGliJGgpO1xuXHR2YXIgbGliXzEkaCA9IGxpYiRoLmRlZmF1bHRQYXRoO1xuXHR2YXIgbGliXzIkZyA9IGxpYiRoLkhETm9kZTtcblx0dmFyIGxpYl8zJGQgPSBsaWIkaC5tbmVtb25pY1RvU2VlZDtcblx0dmFyIGxpYl80JGEgPSBsaWIkaC5tbmVtb25pY1RvRW50cm9weTtcblx0dmFyIGxpYl81JDkgPSBsaWIkaC5lbnRyb3B5VG9NbmVtb25pYztcblx0dmFyIGxpYl82JDUgPSBsaWIkaC5pc1ZhbGlkTW5lbW9uaWM7XG5cblx0dmFyIF92ZXJzaW9uJHkgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMudmVyc2lvbiA9IFwicmFuZG9tLzUuMC4yXCI7XG5cblx0fSk7XG5cblx0dmFyIF92ZXJzaW9uJHogPSB1bndyYXBFeHBvcnRzKF92ZXJzaW9uJHkpO1xuXHR2YXIgX3ZlcnNpb25fMSRoID0gX3ZlcnNpb24keS52ZXJzaW9uO1xuXG5cdHZhciBzaHVmZmxlID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRmdW5jdGlvbiBzaHVmZmxlZChhcnJheSkge1xuXHQgICAgYXJyYXkgPSBhcnJheS5zbGljZSgpO1xuXHQgICAgZm9yICh2YXIgaSA9IGFycmF5Lmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pIHtcblx0ICAgICAgICB2YXIgaiA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChpICsgMSkpO1xuXHQgICAgICAgIHZhciB0bXAgPSBhcnJheVtpXTtcblx0ICAgICAgICBhcnJheVtpXSA9IGFycmF5W2pdO1xuXHQgICAgICAgIGFycmF5W2pdID0gdG1wO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGFycmF5O1xuXHR9XG5cdGV4cG9ydHMuc2h1ZmZsZWQgPSBzaHVmZmxlZDtcblxuXHR9KTtcblxuXHR2YXIgc2h1ZmZsZSQxID0gdW53cmFwRXhwb3J0cyhzaHVmZmxlKTtcblx0dmFyIHNodWZmbGVfMSA9IHNodWZmbGUuc2h1ZmZsZWQ7XG5cblx0dmFyIGJyb3dzZXIkNiA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXG5cblx0dmFyIGxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJHkudmVyc2lvbik7XG5cblx0ZXhwb3J0cy5zaHVmZmxlZCA9IHNodWZmbGUuc2h1ZmZsZWQ7XG5cdHZhciBhbnlHbG9iYWwgPSBudWxsO1xuXHR0cnkge1xuXHQgICAgYW55R2xvYmFsID0gd2luZG93O1xuXHQgICAgaWYgKGFueUdsb2JhbCA9PSBudWxsKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IG5leHRcIik7XG5cdCAgICB9XG5cdH1cblx0Y2F0Y2ggKGVycm9yKSB7XG5cdCAgICB0cnkge1xuXHQgICAgICAgIGFueUdsb2JhbCA9IGNvbW1vbmpzR2xvYmFsO1xuXHQgICAgICAgIGlmIChhbnlHbG9iYWwgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgbmV4dFwiKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgICBhbnlHbG9iYWwgPSB7fTtcblx0ICAgIH1cblx0fVxuXHR2YXIgY3J5cHRvID0gYW55R2xvYmFsLmNyeXB0byB8fCBhbnlHbG9iYWwubXNDcnlwdG87XG5cdGlmICghY3J5cHRvIHx8ICFjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG5cdCAgICBsb2dnZXIud2FybihcIldBUk5JTkc6IE1pc3Npbmcgc3Ryb25nIHJhbmRvbSBudW1iZXIgc291cmNlXCIpO1xuXHQgICAgY3J5cHRvID0ge1xuXHQgICAgICAgIGdldFJhbmRvbVZhbHVlczogZnVuY3Rpb24gKGJ1ZmZlcikge1xuXHQgICAgICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoXCJubyBzZWN1cmUgcmFuZG9tIHNvdXJjZSBhdmFpYWxibGVcIiwgbGliLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG5cdCAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiY3J5cHRvLmdldFJhbmRvbVZhbHVlc1wiXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdH1cblx0ZnVuY3Rpb24gcmFuZG9tQnl0ZXMobGVuZ3RoKSB7XG5cdCAgICBpZiAobGVuZ3RoIDw9IDAgfHwgbGVuZ3RoID4gMTAyNCB8fCAobGVuZ3RoICUgMSkpIHtcblx0ICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBsZW5ndGhcIiwgXCJsZW5ndGhcIiwgbGVuZ3RoKTtcblx0ICAgIH1cblx0ICAgIHZhciByZXN1bHQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuXHQgICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhyZXN1bHQpO1xuXHQgICAgcmV0dXJuIGxpYiQxLmFycmF5aWZ5KHJlc3VsdCk7XG5cdH1cblx0ZXhwb3J0cy5yYW5kb21CeXRlcyA9IHJhbmRvbUJ5dGVzO1xuXHQ7XG5cblx0fSk7XG5cblx0dmFyIGJyb3dzZXIkNyA9IHVud3JhcEV4cG9ydHMoYnJvd3NlciQ2KTtcblx0dmFyIGJyb3dzZXJfMSQzID0gYnJvd3NlciQ2LnNodWZmbGVkO1xuXHR2YXIgYnJvd3Nlcl8yJDIgPSBicm93c2VyJDYucmFuZG9tQnl0ZXM7XG5cblx0dmFyIGFlc0pzID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQoZnVuY3Rpb24ocm9vdCkge1xuXG5cdCAgICBmdW5jdGlvbiBjaGVja0ludCh2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiAocGFyc2VJbnQodmFsdWUpID09PSB2YWx1ZSk7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGNoZWNrSW50cyhhcnJheWlzaCkge1xuXHQgICAgICAgIGlmICghY2hlY2tJbnQoYXJyYXlpc2gubGVuZ3RoKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlpc2gubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgaWYgKCFjaGVja0ludChhcnJheWlzaFtpXSkgfHwgYXJyYXlpc2hbaV0gPCAwIHx8IGFycmF5aXNoW2ldID4gMjU1KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gY29lcmNlQXJyYXkoYXJnLCBjb3B5KSB7XG5cblx0ICAgICAgICAvLyBBcnJheUJ1ZmZlciB2aWV3XG5cdCAgICAgICAgaWYgKGFyZy5idWZmZXIgJiYgQXJyYXlCdWZmZXIuaXNWaWV3KGFyZykgJiYgYXJnLm5hbWUgPT09ICdVaW50OEFycmF5Jykge1xuXG5cdCAgICAgICAgICAgIGlmIChjb3B5KSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoYXJnLnNsaWNlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYXJnID0gYXJnLnNsaWNlKCk7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIGFyZyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZyk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gYXJnO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIEl0J3MgYW4gYXJyYXk7IGNoZWNrIGl0IGlzIGEgdmFsaWQgcmVwcmVzZW50YXRpb24gb2YgYSBieXRlXG5cdCAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuXHQgICAgICAgICAgICBpZiAoIWNoZWNrSW50cyhhcmcpKSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FycmF5IGNvbnRhaW5zIGludmFsaWQgdmFsdWU6ICcgKyBhcmcpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGFyZyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gU29tZXRoaW5nIGVsc2UsIGJ1dCBiZWhhdmVzIGxpa2UgYW4gYXJyYXkgKG1heWJlIGEgQnVmZmVyPyBBcmd1bWVudHM/KVxuXHQgICAgICAgIGlmIChjaGVja0ludChhcmcubGVuZ3RoKSAmJiBjaGVja0ludHMoYXJnKSkge1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXJnKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc3VwcG9ydGVkIGFycmF5LWxpa2Ugb2JqZWN0Jyk7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGNyZWF0ZUFycmF5KGxlbmd0aCkge1xuXHQgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlQXJyYXksIHRhcmdldEFycmF5LCB0YXJnZXRTdGFydCwgc291cmNlU3RhcnQsIHNvdXJjZUVuZCkge1xuXHQgICAgICAgIGlmIChzb3VyY2VTdGFydCAhPSBudWxsIHx8IHNvdXJjZUVuZCAhPSBudWxsKSB7XG5cdCAgICAgICAgICAgIGlmIChzb3VyY2VBcnJheS5zbGljZSkge1xuXHQgICAgICAgICAgICAgICAgc291cmNlQXJyYXkgPSBzb3VyY2VBcnJheS5zbGljZShzb3VyY2VTdGFydCwgc291cmNlRW5kKTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHNvdXJjZUFycmF5ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoc291cmNlQXJyYXksIHNvdXJjZVN0YXJ0LCBzb3VyY2VFbmQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRhcmdldEFycmF5LnNldChzb3VyY2VBcnJheSwgdGFyZ2V0U3RhcnQpO1xuXHQgICAgfVxuXG5cblxuXHQgICAgdmFyIGNvbnZlcnRVdGY4ID0gKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgIGZ1bmN0aW9uIHRvQnl0ZXModGV4dCkge1xuXHQgICAgICAgICAgICB2YXIgcmVzdWx0ID0gW10sIGkgPSAwO1xuXHQgICAgICAgICAgICB0ZXh0ID0gZW5jb2RlVVJJKHRleHQpO1xuXHQgICAgICAgICAgICB3aGlsZSAoaSA8IHRleHQubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgYyA9IHRleHQuY2hhckNvZGVBdChpKyspO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBpZiBpdCBpcyBhICUgc2lnbiwgZW5jb2RlIHRoZSBmb2xsb3dpbmcgMiBieXRlcyBhcyBhIGhleCB2YWx1ZVxuXHQgICAgICAgICAgICAgICAgaWYgKGMgPT09IDM3KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gocGFyc2VJbnQodGV4dC5zdWJzdHIoaSwgMiksIDE2KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgaSArPSAyO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UsIGp1c3QgdGhlIGFjdHVhbCBieXRlXG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGMpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGNvZXJjZUFycmF5KHJlc3VsdCk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgZnVuY3Rpb24gZnJvbUJ5dGVzKGJ5dGVzKSB7XG5cdCAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXSwgaSA9IDA7XG5cblx0ICAgICAgICAgICAgd2hpbGUgKGkgPCBieXRlcy5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBjID0gYnl0ZXNbaV07XG5cblx0ICAgICAgICAgICAgICAgIGlmIChjIDwgMTI4KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShjKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgaSsrO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjID4gMTkxICYmIGMgPCAyMjQpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYyAmIDB4MWYpIDw8IDYpIHwgKGJ5dGVzW2kgKyAxXSAmIDB4M2YpKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgaSArPSAyO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYyAmIDB4MGYpIDw8IDEyKSB8ICgoYnl0ZXNbaSArIDFdICYgMHgzZikgPDwgNikgfCAoYnl0ZXNbaSArIDJdICYgMHgzZikpKTtcblx0ICAgICAgICAgICAgICAgICAgICBpICs9IDM7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oJycpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgIHRvQnl0ZXM6IHRvQnl0ZXMsXG5cdCAgICAgICAgICAgIGZyb21CeXRlczogZnJvbUJ5dGVzLFxuXHQgICAgICAgIH1cblx0ICAgIH0pKCk7XG5cblx0ICAgIHZhciBjb252ZXJ0SGV4ID0gKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgIGZ1bmN0aW9uIHRvQnl0ZXModGV4dCkge1xuXHQgICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkgKz0gMikge1xuXHQgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gocGFyc2VJbnQodGV4dC5zdWJzdHIoaSwgMiksIDE2KSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIGh0dHA6Ly9peHRpLm5ldC9kZXZlbG9wbWVudC9qYXZhc2NyaXB0LzIwMTEvMTEvMTEvYmFzZTY0LWVuY29kZWRlY29kZS1vZi11dGY4LWluLWJyb3dzZXItd2l0aC1qcy5odG1sXG5cdCAgICAgICAgdmFyIEhleCA9ICcwMTIzNDU2Nzg5YWJjZGVmJztcblxuXHQgICAgICAgIGZ1bmN0aW9uIGZyb21CeXRlcyhieXRlcykge1xuXHQgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB2ID0gYnl0ZXNbaV07XG5cdCAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goSGV4Wyh2ICYgMHhmMCkgPj4gNF0gKyBIZXhbdiAmIDB4MGZdKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQuam9pbignJyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgdG9CeXRlczogdG9CeXRlcyxcblx0ICAgICAgICAgICAgZnJvbUJ5dGVzOiBmcm9tQnl0ZXMsXG5cdCAgICAgICAgfVxuXHQgICAgfSkoKTtcblxuXG5cdCAgICAvLyBOdW1iZXIgb2Ygcm91bmRzIGJ5IGtleXNpemVcblx0ICAgIHZhciBudW1iZXJPZlJvdW5kcyA9IHsxNjogMTAsIDI0OiAxMiwgMzI6IDE0fTtcblxuXHQgICAgLy8gUm91bmQgY29uc3RhbnQgd29yZHNcblx0ICAgIHZhciByY29uID0gWzB4MDEsIDB4MDIsIDB4MDQsIDB4MDgsIDB4MTAsIDB4MjAsIDB4NDAsIDB4ODAsIDB4MWIsIDB4MzYsIDB4NmMsIDB4ZDgsIDB4YWIsIDB4NGQsIDB4OWEsIDB4MmYsIDB4NWUsIDB4YmMsIDB4NjMsIDB4YzYsIDB4OTcsIDB4MzUsIDB4NmEsIDB4ZDQsIDB4YjMsIDB4N2QsIDB4ZmEsIDB4ZWYsIDB4YzUsIDB4OTFdO1xuXG5cdCAgICAvLyBTLWJveCBhbmQgSW52ZXJzZSBTLWJveCAoUyBpcyBmb3IgU3Vic3RpdHV0aW9uKVxuXHQgICAgdmFyIFMgPSBbMHg2MywgMHg3YywgMHg3NywgMHg3YiwgMHhmMiwgMHg2YiwgMHg2ZiwgMHhjNSwgMHgzMCwgMHgwMSwgMHg2NywgMHgyYiwgMHhmZSwgMHhkNywgMHhhYiwgMHg3NiwgMHhjYSwgMHg4MiwgMHhjOSwgMHg3ZCwgMHhmYSwgMHg1OSwgMHg0NywgMHhmMCwgMHhhZCwgMHhkNCwgMHhhMiwgMHhhZiwgMHg5YywgMHhhNCwgMHg3MiwgMHhjMCwgMHhiNywgMHhmZCwgMHg5MywgMHgyNiwgMHgzNiwgMHgzZiwgMHhmNywgMHhjYywgMHgzNCwgMHhhNSwgMHhlNSwgMHhmMSwgMHg3MSwgMHhkOCwgMHgzMSwgMHgxNSwgMHgwNCwgMHhjNywgMHgyMywgMHhjMywgMHgxOCwgMHg5NiwgMHgwNSwgMHg5YSwgMHgwNywgMHgxMiwgMHg4MCwgMHhlMiwgMHhlYiwgMHgyNywgMHhiMiwgMHg3NSwgMHgwOSwgMHg4MywgMHgyYywgMHgxYSwgMHgxYiwgMHg2ZSwgMHg1YSwgMHhhMCwgMHg1MiwgMHgzYiwgMHhkNiwgMHhiMywgMHgyOSwgMHhlMywgMHgyZiwgMHg4NCwgMHg1MywgMHhkMSwgMHgwMCwgMHhlZCwgMHgyMCwgMHhmYywgMHhiMSwgMHg1YiwgMHg2YSwgMHhjYiwgMHhiZSwgMHgzOSwgMHg0YSwgMHg0YywgMHg1OCwgMHhjZiwgMHhkMCwgMHhlZiwgMHhhYSwgMHhmYiwgMHg0MywgMHg0ZCwgMHgzMywgMHg4NSwgMHg0NSwgMHhmOSwgMHgwMiwgMHg3ZiwgMHg1MCwgMHgzYywgMHg5ZiwgMHhhOCwgMHg1MSwgMHhhMywgMHg0MCwgMHg4ZiwgMHg5MiwgMHg5ZCwgMHgzOCwgMHhmNSwgMHhiYywgMHhiNiwgMHhkYSwgMHgyMSwgMHgxMCwgMHhmZiwgMHhmMywgMHhkMiwgMHhjZCwgMHgwYywgMHgxMywgMHhlYywgMHg1ZiwgMHg5NywgMHg0NCwgMHgxNywgMHhjNCwgMHhhNywgMHg3ZSwgMHgzZCwgMHg2NCwgMHg1ZCwgMHgxOSwgMHg3MywgMHg2MCwgMHg4MSwgMHg0ZiwgMHhkYywgMHgyMiwgMHgyYSwgMHg5MCwgMHg4OCwgMHg0NiwgMHhlZSwgMHhiOCwgMHgxNCwgMHhkZSwgMHg1ZSwgMHgwYiwgMHhkYiwgMHhlMCwgMHgzMiwgMHgzYSwgMHgwYSwgMHg0OSwgMHgwNiwgMHgyNCwgMHg1YywgMHhjMiwgMHhkMywgMHhhYywgMHg2MiwgMHg5MSwgMHg5NSwgMHhlNCwgMHg3OSwgMHhlNywgMHhjOCwgMHgzNywgMHg2ZCwgMHg4ZCwgMHhkNSwgMHg0ZSwgMHhhOSwgMHg2YywgMHg1NiwgMHhmNCwgMHhlYSwgMHg2NSwgMHg3YSwgMHhhZSwgMHgwOCwgMHhiYSwgMHg3OCwgMHgyNSwgMHgyZSwgMHgxYywgMHhhNiwgMHhiNCwgMHhjNiwgMHhlOCwgMHhkZCwgMHg3NCwgMHgxZiwgMHg0YiwgMHhiZCwgMHg4YiwgMHg4YSwgMHg3MCwgMHgzZSwgMHhiNSwgMHg2NiwgMHg0OCwgMHgwMywgMHhmNiwgMHgwZSwgMHg2MSwgMHgzNSwgMHg1NywgMHhiOSwgMHg4NiwgMHhjMSwgMHgxZCwgMHg5ZSwgMHhlMSwgMHhmOCwgMHg5OCwgMHgxMSwgMHg2OSwgMHhkOSwgMHg4ZSwgMHg5NCwgMHg5YiwgMHgxZSwgMHg4NywgMHhlOSwgMHhjZSwgMHg1NSwgMHgyOCwgMHhkZiwgMHg4YywgMHhhMSwgMHg4OSwgMHgwZCwgMHhiZiwgMHhlNiwgMHg0MiwgMHg2OCwgMHg0MSwgMHg5OSwgMHgyZCwgMHgwZiwgMHhiMCwgMHg1NCwgMHhiYiwgMHgxNl07XG5cdCAgICB2YXIgU2kgPVsweDUyLCAweDA5LCAweDZhLCAweGQ1LCAweDMwLCAweDM2LCAweGE1LCAweDM4LCAweGJmLCAweDQwLCAweGEzLCAweDllLCAweDgxLCAweGYzLCAweGQ3LCAweGZiLCAweDdjLCAweGUzLCAweDM5LCAweDgyLCAweDliLCAweDJmLCAweGZmLCAweDg3LCAweDM0LCAweDhlLCAweDQzLCAweDQ0LCAweGM0LCAweGRlLCAweGU5LCAweGNiLCAweDU0LCAweDdiLCAweDk0LCAweDMyLCAweGE2LCAweGMyLCAweDIzLCAweDNkLCAweGVlLCAweDRjLCAweDk1LCAweDBiLCAweDQyLCAweGZhLCAweGMzLCAweDRlLCAweDA4LCAweDJlLCAweGExLCAweDY2LCAweDI4LCAweGQ5LCAweDI0LCAweGIyLCAweDc2LCAweDViLCAweGEyLCAweDQ5LCAweDZkLCAweDhiLCAweGQxLCAweDI1LCAweDcyLCAweGY4LCAweGY2LCAweDY0LCAweDg2LCAweDY4LCAweDk4LCAweDE2LCAweGQ0LCAweGE0LCAweDVjLCAweGNjLCAweDVkLCAweDY1LCAweGI2LCAweDkyLCAweDZjLCAweDcwLCAweDQ4LCAweDUwLCAweGZkLCAweGVkLCAweGI5LCAweGRhLCAweDVlLCAweDE1LCAweDQ2LCAweDU3LCAweGE3LCAweDhkLCAweDlkLCAweDg0LCAweDkwLCAweGQ4LCAweGFiLCAweDAwLCAweDhjLCAweGJjLCAweGQzLCAweDBhLCAweGY3LCAweGU0LCAweDU4LCAweDA1LCAweGI4LCAweGIzLCAweDQ1LCAweDA2LCAweGQwLCAweDJjLCAweDFlLCAweDhmLCAweGNhLCAweDNmLCAweDBmLCAweDAyLCAweGMxLCAweGFmLCAweGJkLCAweDAzLCAweDAxLCAweDEzLCAweDhhLCAweDZiLCAweDNhLCAweDkxLCAweDExLCAweDQxLCAweDRmLCAweDY3LCAweGRjLCAweGVhLCAweDk3LCAweGYyLCAweGNmLCAweGNlLCAweGYwLCAweGI0LCAweGU2LCAweDczLCAweDk2LCAweGFjLCAweDc0LCAweDIyLCAweGU3LCAweGFkLCAweDM1LCAweDg1LCAweGUyLCAweGY5LCAweDM3LCAweGU4LCAweDFjLCAweDc1LCAweGRmLCAweDZlLCAweDQ3LCAweGYxLCAweDFhLCAweDcxLCAweDFkLCAweDI5LCAweGM1LCAweDg5LCAweDZmLCAweGI3LCAweDYyLCAweDBlLCAweGFhLCAweDE4LCAweGJlLCAweDFiLCAweGZjLCAweDU2LCAweDNlLCAweDRiLCAweGM2LCAweGQyLCAweDc5LCAweDIwLCAweDlhLCAweGRiLCAweGMwLCAweGZlLCAweDc4LCAweGNkLCAweDVhLCAweGY0LCAweDFmLCAweGRkLCAweGE4LCAweDMzLCAweDg4LCAweDA3LCAweGM3LCAweDMxLCAweGIxLCAweDEyLCAweDEwLCAweDU5LCAweDI3LCAweDgwLCAweGVjLCAweDVmLCAweDYwLCAweDUxLCAweDdmLCAweGE5LCAweDE5LCAweGI1LCAweDRhLCAweDBkLCAweDJkLCAweGU1LCAweDdhLCAweDlmLCAweDkzLCAweGM5LCAweDljLCAweGVmLCAweGEwLCAweGUwLCAweDNiLCAweDRkLCAweGFlLCAweDJhLCAweGY1LCAweGIwLCAweGM4LCAweGViLCAweGJiLCAweDNjLCAweDgzLCAweDUzLCAweDk5LCAweDYxLCAweDE3LCAweDJiLCAweDA0LCAweDdlLCAweGJhLCAweDc3LCAweGQ2LCAweDI2LCAweGUxLCAweDY5LCAweDE0LCAweDYzLCAweDU1LCAweDIxLCAweDBjLCAweDdkXTtcblxuXHQgICAgLy8gVHJhbnNmb3JtYXRpb25zIGZvciBlbmNyeXB0aW9uXG5cdCAgICB2YXIgVDEgPSBbMHhjNjYzNjNhNSwgMHhmODdjN2M4NCwgMHhlZTc3Nzc5OSwgMHhmNjdiN2I4ZCwgMHhmZmYyZjIwZCwgMHhkNjZiNmJiZCwgMHhkZTZmNmZiMSwgMHg5MWM1YzU1NCwgMHg2MDMwMzA1MCwgMHgwMjAxMDEwMywgMHhjZTY3NjdhOSwgMHg1NjJiMmI3ZCwgMHhlN2ZlZmUxOSwgMHhiNWQ3ZDc2MiwgMHg0ZGFiYWJlNiwgMHhlYzc2NzY5YSwgMHg4ZmNhY2E0NSwgMHgxZjgyODI5ZCwgMHg4OWM5Yzk0MCwgMHhmYTdkN2Q4NywgMHhlZmZhZmExNSwgMHhiMjU5NTllYiwgMHg4ZTQ3NDdjOSwgMHhmYmYwZjAwYiwgMHg0MWFkYWRlYywgMHhiM2Q0ZDQ2NywgMHg1ZmEyYTJmZCwgMHg0NWFmYWZlYSwgMHgyMzljOWNiZiwgMHg1M2E0YTRmNywgMHhlNDcyNzI5NiwgMHg5YmMwYzA1YiwgMHg3NWI3YjdjMiwgMHhlMWZkZmQxYywgMHgzZDkzOTNhZSwgMHg0YzI2MjY2YSwgMHg2YzM2MzY1YSwgMHg3ZTNmM2Y0MSwgMHhmNWY3ZjcwMiwgMHg4M2NjY2M0ZiwgMHg2ODM0MzQ1YywgMHg1MWE1YTVmNCwgMHhkMWU1ZTUzNCwgMHhmOWYxZjEwOCwgMHhlMjcxNzE5MywgMHhhYmQ4ZDg3MywgMHg2MjMxMzE1MywgMHgyYTE1MTUzZiwgMHgwODA0MDQwYywgMHg5NWM3Yzc1MiwgMHg0NjIzMjM2NSwgMHg5ZGMzYzM1ZSwgMHgzMDE4MTgyOCwgMHgzNzk2OTZhMSwgMHgwYTA1MDUwZiwgMHgyZjlhOWFiNSwgMHgwZTA3MDcwOSwgMHgyNDEyMTIzNiwgMHgxYjgwODA5YiwgMHhkZmUyZTIzZCwgMHhjZGViZWIyNiwgMHg0ZTI3Mjc2OSwgMHg3ZmIyYjJjZCwgMHhlYTc1NzU5ZiwgMHgxMjA5MDkxYiwgMHgxZDgzODM5ZSwgMHg1ODJjMmM3NCwgMHgzNDFhMWEyZSwgMHgzNjFiMWIyZCwgMHhkYzZlNmViMiwgMHhiNDVhNWFlZSwgMHg1YmEwYTBmYiwgMHhhNDUyNTJmNiwgMHg3NjNiM2I0ZCwgMHhiN2Q2ZDY2MSwgMHg3ZGIzYjNjZSwgMHg1MjI5Mjk3YiwgMHhkZGUzZTMzZSwgMHg1ZTJmMmY3MSwgMHgxMzg0ODQ5NywgMHhhNjUzNTNmNSwgMHhiOWQxZDE2OCwgMHgwMDAwMDAwMCwgMHhjMWVkZWQyYywgMHg0MDIwMjA2MCwgMHhlM2ZjZmMxZiwgMHg3OWIxYjFjOCwgMHhiNjViNWJlZCwgMHhkNDZhNmFiZSwgMHg4ZGNiY2I0NiwgMHg2N2JlYmVkOSwgMHg3MjM5Mzk0YiwgMHg5NDRhNGFkZSwgMHg5ODRjNGNkNCwgMHhiMDU4NThlOCwgMHg4NWNmY2Y0YSwgMHhiYmQwZDA2YiwgMHhjNWVmZWYyYSwgMHg0ZmFhYWFlNSwgMHhlZGZiZmIxNiwgMHg4NjQzNDNjNSwgMHg5YTRkNGRkNywgMHg2NjMzMzM1NSwgMHgxMTg1ODU5NCwgMHg4YTQ1NDVjZiwgMHhlOWY5ZjkxMCwgMHgwNDAyMDIwNiwgMHhmZTdmN2Y4MSwgMHhhMDUwNTBmMCwgMHg3ODNjM2M0NCwgMHgyNTlmOWZiYSwgMHg0YmE4YThlMywgMHhhMjUxNTFmMywgMHg1ZGEzYTNmZSwgMHg4MDQwNDBjMCwgMHgwNThmOGY4YSwgMHgzZjkyOTJhZCwgMHgyMTlkOWRiYywgMHg3MDM4Mzg0OCwgMHhmMWY1ZjUwNCwgMHg2M2JjYmNkZiwgMHg3N2I2YjZjMSwgMHhhZmRhZGE3NSwgMHg0MjIxMjE2MywgMHgyMDEwMTAzMCwgMHhlNWZmZmYxYSwgMHhmZGYzZjMwZSwgMHhiZmQyZDI2ZCwgMHg4MWNkY2Q0YywgMHgxODBjMGMxNCwgMHgyNjEzMTMzNSwgMHhjM2VjZWMyZiwgMHhiZTVmNWZlMSwgMHgzNTk3OTdhMiwgMHg4ODQ0NDRjYywgMHgyZTE3MTczOSwgMHg5M2M0YzQ1NywgMHg1NWE3YTdmMiwgMHhmYzdlN2U4MiwgMHg3YTNkM2Q0NywgMHhjODY0NjRhYywgMHhiYTVkNWRlNywgMHgzMjE5MTkyYiwgMHhlNjczNzM5NSwgMHhjMDYwNjBhMCwgMHgxOTgxODE5OCwgMHg5ZTRmNGZkMSwgMHhhM2RjZGM3ZiwgMHg0NDIyMjI2NiwgMHg1NDJhMmE3ZSwgMHgzYjkwOTBhYiwgMHgwYjg4ODg4MywgMHg4YzQ2NDZjYSwgMHhjN2VlZWUyOSwgMHg2YmI4YjhkMywgMHgyODE0MTQzYywgMHhhN2RlZGU3OSwgMHhiYzVlNWVlMiwgMHgxNjBiMGIxZCwgMHhhZGRiZGI3NiwgMHhkYmUwZTAzYiwgMHg2NDMyMzI1NiwgMHg3NDNhM2E0ZSwgMHgxNDBhMGExZSwgMHg5MjQ5NDlkYiwgMHgwYzA2MDYwYSwgMHg0ODI0MjQ2YywgMHhiODVjNWNlNCwgMHg5ZmMyYzI1ZCwgMHhiZGQzZDM2ZSwgMHg0M2FjYWNlZiwgMHhjNDYyNjJhNiwgMHgzOTkxOTFhOCwgMHgzMTk1OTVhNCwgMHhkM2U0ZTQzNywgMHhmMjc5Nzk4YiwgMHhkNWU3ZTczMiwgMHg4YmM4Yzg0MywgMHg2ZTM3Mzc1OSwgMHhkYTZkNmRiNywgMHgwMThkOGQ4YywgMHhiMWQ1ZDU2NCwgMHg5YzRlNGVkMiwgMHg0OWE5YTllMCwgMHhkODZjNmNiNCwgMHhhYzU2NTZmYSwgMHhmM2Y0ZjQwNywgMHhjZmVhZWEyNSwgMHhjYTY1NjVhZiwgMHhmNDdhN2E4ZSwgMHg0N2FlYWVlOSwgMHgxMDA4MDgxOCwgMHg2ZmJhYmFkNSwgMHhmMDc4Nzg4OCwgMHg0YTI1MjU2ZiwgMHg1YzJlMmU3MiwgMHgzODFjMWMyNCwgMHg1N2E2YTZmMSwgMHg3M2I0YjRjNywgMHg5N2M2YzY1MSwgMHhjYmU4ZTgyMywgMHhhMWRkZGQ3YywgMHhlODc0NzQ5YywgMHgzZTFmMWYyMSwgMHg5NjRiNGJkZCwgMHg2MWJkYmRkYywgMHgwZDhiOGI4NiwgMHgwZjhhOGE4NSwgMHhlMDcwNzA5MCwgMHg3YzNlM2U0MiwgMHg3MWI1YjVjNCwgMHhjYzY2NjZhYSwgMHg5MDQ4NDhkOCwgMHgwNjAzMDMwNSwgMHhmN2Y2ZjYwMSwgMHgxYzBlMGUxMiwgMHhjMjYxNjFhMywgMHg2YTM1MzU1ZiwgMHhhZTU3NTdmOSwgMHg2OWI5YjlkMCwgMHgxNzg2ODY5MSwgMHg5OWMxYzE1OCwgMHgzYTFkMWQyNywgMHgyNzllOWViOSwgMHhkOWUxZTEzOCwgMHhlYmY4ZjgxMywgMHgyYjk4OThiMywgMHgyMjExMTEzMywgMHhkMjY5NjliYiwgMHhhOWQ5ZDk3MCwgMHgwNzhlOGU4OSwgMHgzMzk0OTRhNywgMHgyZDliOWJiNiwgMHgzYzFlMWUyMiwgMHgxNTg3ODc5MiwgMHhjOWU5ZTkyMCwgMHg4N2NlY2U0OSwgMHhhYTU1NTVmZiwgMHg1MDI4Mjg3OCwgMHhhNWRmZGY3YSwgMHgwMzhjOGM4ZiwgMHg1OWExYTFmOCwgMHgwOTg5ODk4MCwgMHgxYTBkMGQxNywgMHg2NWJmYmZkYSwgMHhkN2U2ZTYzMSwgMHg4NDQyNDJjNiwgMHhkMDY4NjhiOCwgMHg4MjQxNDFjMywgMHgyOTk5OTliMCwgMHg1YTJkMmQ3NywgMHgxZTBmMGYxMSwgMHg3YmIwYjBjYiwgMHhhODU0NTRmYywgMHg2ZGJiYmJkNiwgMHgyYzE2MTYzYV07XG5cdCAgICB2YXIgVDIgPSBbMHhhNWM2NjM2MywgMHg4NGY4N2M3YywgMHg5OWVlNzc3NywgMHg4ZGY2N2I3YiwgMHgwZGZmZjJmMiwgMHhiZGQ2NmI2YiwgMHhiMWRlNmY2ZiwgMHg1NDkxYzVjNSwgMHg1MDYwMzAzMCwgMHgwMzAyMDEwMSwgMHhhOWNlNjc2NywgMHg3ZDU2MmIyYiwgMHgxOWU3ZmVmZSwgMHg2MmI1ZDdkNywgMHhlNjRkYWJhYiwgMHg5YWVjNzY3NiwgMHg0NThmY2FjYSwgMHg5ZDFmODI4MiwgMHg0MDg5YzljOSwgMHg4N2ZhN2Q3ZCwgMHgxNWVmZmFmYSwgMHhlYmIyNTk1OSwgMHhjOThlNDc0NywgMHgwYmZiZjBmMCwgMHhlYzQxYWRhZCwgMHg2N2IzZDRkNCwgMHhmZDVmYTJhMiwgMHhlYTQ1YWZhZiwgMHhiZjIzOWM5YywgMHhmNzUzYTRhNCwgMHg5NmU0NzI3MiwgMHg1YjliYzBjMCwgMHhjMjc1YjdiNywgMHgxY2UxZmRmZCwgMHhhZTNkOTM5MywgMHg2YTRjMjYyNiwgMHg1YTZjMzYzNiwgMHg0MTdlM2YzZiwgMHgwMmY1ZjdmNywgMHg0ZjgzY2NjYywgMHg1YzY4MzQzNCwgMHhmNDUxYTVhNSwgMHgzNGQxZTVlNSwgMHgwOGY5ZjFmMSwgMHg5M2UyNzE3MSwgMHg3M2FiZDhkOCwgMHg1MzYyMzEzMSwgMHgzZjJhMTUxNSwgMHgwYzA4MDQwNCwgMHg1Mjk1YzdjNywgMHg2NTQ2MjMyMywgMHg1ZTlkYzNjMywgMHgyODMwMTgxOCwgMHhhMTM3OTY5NiwgMHgwZjBhMDUwNSwgMHhiNTJmOWE5YSwgMHgwOTBlMDcwNywgMHgzNjI0MTIxMiwgMHg5YjFiODA4MCwgMHgzZGRmZTJlMiwgMHgyNmNkZWJlYiwgMHg2OTRlMjcyNywgMHhjZDdmYjJiMiwgMHg5ZmVhNzU3NSwgMHgxYjEyMDkwOSwgMHg5ZTFkODM4MywgMHg3NDU4MmMyYywgMHgyZTM0MWExYSwgMHgyZDM2MWIxYiwgMHhiMmRjNmU2ZSwgMHhlZWI0NWE1YSwgMHhmYjViYTBhMCwgMHhmNmE0NTI1MiwgMHg0ZDc2M2IzYiwgMHg2MWI3ZDZkNiwgMHhjZTdkYjNiMywgMHg3YjUyMjkyOSwgMHgzZWRkZTNlMywgMHg3MTVlMmYyZiwgMHg5NzEzODQ4NCwgMHhmNWE2NTM1MywgMHg2OGI5ZDFkMSwgMHgwMDAwMDAwMCwgMHgyY2MxZWRlZCwgMHg2MDQwMjAyMCwgMHgxZmUzZmNmYywgMHhjODc5YjFiMSwgMHhlZGI2NWI1YiwgMHhiZWQ0NmE2YSwgMHg0NjhkY2JjYiwgMHhkOTY3YmViZSwgMHg0YjcyMzkzOSwgMHhkZTk0NGE0YSwgMHhkNDk4NGM0YywgMHhlOGIwNTg1OCwgMHg0YTg1Y2ZjZiwgMHg2YmJiZDBkMCwgMHgyYWM1ZWZlZiwgMHhlNTRmYWFhYSwgMHgxNmVkZmJmYiwgMHhjNTg2NDM0MywgMHhkNzlhNGQ0ZCwgMHg1NTY2MzMzMywgMHg5NDExODU4NSwgMHhjZjhhNDU0NSwgMHgxMGU5ZjlmOSwgMHgwNjA0MDIwMiwgMHg4MWZlN2Y3ZiwgMHhmMGEwNTA1MCwgMHg0NDc4M2MzYywgMHhiYTI1OWY5ZiwgMHhlMzRiYThhOCwgMHhmM2EyNTE1MSwgMHhmZTVkYTNhMywgMHhjMDgwNDA0MCwgMHg4YTA1OGY4ZiwgMHhhZDNmOTI5MiwgMHhiYzIxOWQ5ZCwgMHg0ODcwMzgzOCwgMHgwNGYxZjVmNSwgMHhkZjYzYmNiYywgMHhjMTc3YjZiNiwgMHg3NWFmZGFkYSwgMHg2MzQyMjEyMSwgMHgzMDIwMTAxMCwgMHgxYWU1ZmZmZiwgMHgwZWZkZjNmMywgMHg2ZGJmZDJkMiwgMHg0YzgxY2RjZCwgMHgxNDE4MGMwYywgMHgzNTI2MTMxMywgMHgyZmMzZWNlYywgMHhlMWJlNWY1ZiwgMHhhMjM1OTc5NywgMHhjYzg4NDQ0NCwgMHgzOTJlMTcxNywgMHg1NzkzYzRjNCwgMHhmMjU1YTdhNywgMHg4MmZjN2U3ZSwgMHg0NzdhM2QzZCwgMHhhY2M4NjQ2NCwgMHhlN2JhNWQ1ZCwgMHgyYjMyMTkxOSwgMHg5NWU2NzM3MywgMHhhMGMwNjA2MCwgMHg5ODE5ODE4MSwgMHhkMTllNGY0ZiwgMHg3ZmEzZGNkYywgMHg2NjQ0MjIyMiwgMHg3ZTU0MmEyYSwgMHhhYjNiOTA5MCwgMHg4MzBiODg4OCwgMHhjYThjNDY0NiwgMHgyOWM3ZWVlZSwgMHhkMzZiYjhiOCwgMHgzYzI4MTQxNCwgMHg3OWE3ZGVkZSwgMHhlMmJjNWU1ZSwgMHgxZDE2MGIwYiwgMHg3NmFkZGJkYiwgMHgzYmRiZTBlMCwgMHg1NjY0MzIzMiwgMHg0ZTc0M2EzYSwgMHgxZTE0MGEwYSwgMHhkYjkyNDk0OSwgMHgwYTBjMDYwNiwgMHg2YzQ4MjQyNCwgMHhlNGI4NWM1YywgMHg1ZDlmYzJjMiwgMHg2ZWJkZDNkMywgMHhlZjQzYWNhYywgMHhhNmM0NjI2MiwgMHhhODM5OTE5MSwgMHhhNDMxOTU5NSwgMHgzN2QzZTRlNCwgMHg4YmYyNzk3OSwgMHgzMmQ1ZTdlNywgMHg0MzhiYzhjOCwgMHg1OTZlMzczNywgMHhiN2RhNmQ2ZCwgMHg4YzAxOGQ4ZCwgMHg2NGIxZDVkNSwgMHhkMjljNGU0ZSwgMHhlMDQ5YTlhOSwgMHhiNGQ4NmM2YywgMHhmYWFjNTY1NiwgMHgwN2YzZjRmNCwgMHgyNWNmZWFlYSwgMHhhZmNhNjU2NSwgMHg4ZWY0N2E3YSwgMHhlOTQ3YWVhZSwgMHgxODEwMDgwOCwgMHhkNTZmYmFiYSwgMHg4OGYwNzg3OCwgMHg2ZjRhMjUyNSwgMHg3MjVjMmUyZSwgMHgyNDM4MWMxYywgMHhmMTU3YTZhNiwgMHhjNzczYjRiNCwgMHg1MTk3YzZjNiwgMHgyM2NiZThlOCwgMHg3Y2ExZGRkZCwgMHg5Y2U4NzQ3NCwgMHgyMTNlMWYxZiwgMHhkZDk2NGI0YiwgMHhkYzYxYmRiZCwgMHg4NjBkOGI4YiwgMHg4NTBmOGE4YSwgMHg5MGUwNzA3MCwgMHg0MjdjM2UzZSwgMHhjNDcxYjViNSwgMHhhYWNjNjY2NiwgMHhkODkwNDg0OCwgMHgwNTA2MDMwMywgMHgwMWY3ZjZmNiwgMHgxMjFjMGUwZSwgMHhhM2MyNjE2MSwgMHg1ZjZhMzUzNSwgMHhmOWFlNTc1NywgMHhkMDY5YjliOSwgMHg5MTE3ODY4NiwgMHg1ODk5YzFjMSwgMHgyNzNhMWQxZCwgMHhiOTI3OWU5ZSwgMHgzOGQ5ZTFlMSwgMHgxM2ViZjhmOCwgMHhiMzJiOTg5OCwgMHgzMzIyMTExMSwgMHhiYmQyNjk2OSwgMHg3MGE5ZDlkOSwgMHg4OTA3OGU4ZSwgMHhhNzMzOTQ5NCwgMHhiNjJkOWI5YiwgMHgyMjNjMWUxZSwgMHg5MjE1ODc4NywgMHgyMGM5ZTllOSwgMHg0OTg3Y2VjZSwgMHhmZmFhNTU1NSwgMHg3ODUwMjgyOCwgMHg3YWE1ZGZkZiwgMHg4ZjAzOGM4YywgMHhmODU5YTFhMSwgMHg4MDA5ODk4OSwgMHgxNzFhMGQwZCwgMHhkYTY1YmZiZiwgMHgzMWQ3ZTZlNiwgMHhjNjg0NDI0MiwgMHhiOGQwNjg2OCwgMHhjMzgyNDE0MSwgMHhiMDI5OTk5OSwgMHg3NzVhMmQyZCwgMHgxMTFlMGYwZiwgMHhjYjdiYjBiMCwgMHhmY2E4NTQ1NCwgMHhkNjZkYmJiYiwgMHgzYTJjMTYxNl07XG5cdCAgICB2YXIgVDMgPSBbMHg2M2E1YzY2MywgMHg3Yzg0Zjg3YywgMHg3Nzk5ZWU3NywgMHg3YjhkZjY3YiwgMHhmMjBkZmZmMiwgMHg2YmJkZDY2YiwgMHg2ZmIxZGU2ZiwgMHhjNTU0OTFjNSwgMHgzMDUwNjAzMCwgMHgwMTAzMDIwMSwgMHg2N2E5Y2U2NywgMHgyYjdkNTYyYiwgMHhmZTE5ZTdmZSwgMHhkNzYyYjVkNywgMHhhYmU2NGRhYiwgMHg3NjlhZWM3NiwgMHhjYTQ1OGZjYSwgMHg4MjlkMWY4MiwgMHhjOTQwODljOSwgMHg3ZDg3ZmE3ZCwgMHhmYTE1ZWZmYSwgMHg1OWViYjI1OSwgMHg0N2M5OGU0NywgMHhmMDBiZmJmMCwgMHhhZGVjNDFhZCwgMHhkNDY3YjNkNCwgMHhhMmZkNWZhMiwgMHhhZmVhNDVhZiwgMHg5Y2JmMjM5YywgMHhhNGY3NTNhNCwgMHg3Mjk2ZTQ3MiwgMHhjMDViOWJjMCwgMHhiN2MyNzViNywgMHhmZDFjZTFmZCwgMHg5M2FlM2Q5MywgMHgyNjZhNGMyNiwgMHgzNjVhNmMzNiwgMHgzZjQxN2UzZiwgMHhmNzAyZjVmNywgMHhjYzRmODNjYywgMHgzNDVjNjgzNCwgMHhhNWY0NTFhNSwgMHhlNTM0ZDFlNSwgMHhmMTA4ZjlmMSwgMHg3MTkzZTI3MSwgMHhkODczYWJkOCwgMHgzMTUzNjIzMSwgMHgxNTNmMmExNSwgMHgwNDBjMDgwNCwgMHhjNzUyOTVjNywgMHgyMzY1NDYyMywgMHhjMzVlOWRjMywgMHgxODI4MzAxOCwgMHg5NmExMzc5NiwgMHgwNTBmMGEwNSwgMHg5YWI1MmY5YSwgMHgwNzA5MGUwNywgMHgxMjM2MjQxMiwgMHg4MDliMWI4MCwgMHhlMjNkZGZlMiwgMHhlYjI2Y2RlYiwgMHgyNzY5NGUyNywgMHhiMmNkN2ZiMiwgMHg3NTlmZWE3NSwgMHgwOTFiMTIwOSwgMHg4MzllMWQ4MywgMHgyYzc0NTgyYywgMHgxYTJlMzQxYSwgMHgxYjJkMzYxYiwgMHg2ZWIyZGM2ZSwgMHg1YWVlYjQ1YSwgMHhhMGZiNWJhMCwgMHg1MmY2YTQ1MiwgMHgzYjRkNzYzYiwgMHhkNjYxYjdkNiwgMHhiM2NlN2RiMywgMHgyOTdiNTIyOSwgMHhlMzNlZGRlMywgMHgyZjcxNWUyZiwgMHg4NDk3MTM4NCwgMHg1M2Y1YTY1MywgMHhkMTY4YjlkMSwgMHgwMDAwMDAwMCwgMHhlZDJjYzFlZCwgMHgyMDYwNDAyMCwgMHhmYzFmZTNmYywgMHhiMWM4NzliMSwgMHg1YmVkYjY1YiwgMHg2YWJlZDQ2YSwgMHhjYjQ2OGRjYiwgMHhiZWQ5NjdiZSwgMHgzOTRiNzIzOSwgMHg0YWRlOTQ0YSwgMHg0Y2Q0OTg0YywgMHg1OGU4YjA1OCwgMHhjZjRhODVjZiwgMHhkMDZiYmJkMCwgMHhlZjJhYzVlZiwgMHhhYWU1NGZhYSwgMHhmYjE2ZWRmYiwgMHg0M2M1ODY0MywgMHg0ZGQ3OWE0ZCwgMHgzMzU1NjYzMywgMHg4NTk0MTE4NSwgMHg0NWNmOGE0NSwgMHhmOTEwZTlmOSwgMHgwMjA2MDQwMiwgMHg3ZjgxZmU3ZiwgMHg1MGYwYTA1MCwgMHgzYzQ0NzgzYywgMHg5ZmJhMjU5ZiwgMHhhOGUzNGJhOCwgMHg1MWYzYTI1MSwgMHhhM2ZlNWRhMywgMHg0MGMwODA0MCwgMHg4ZjhhMDU4ZiwgMHg5MmFkM2Y5MiwgMHg5ZGJjMjE5ZCwgMHgzODQ4NzAzOCwgMHhmNTA0ZjFmNSwgMHhiY2RmNjNiYywgMHhiNmMxNzdiNiwgMHhkYTc1YWZkYSwgMHgyMTYzNDIyMSwgMHgxMDMwMjAxMCwgMHhmZjFhZTVmZiwgMHhmMzBlZmRmMywgMHhkMjZkYmZkMiwgMHhjZDRjODFjZCwgMHgwYzE0MTgwYywgMHgxMzM1MjYxMywgMHhlYzJmYzNlYywgMHg1ZmUxYmU1ZiwgMHg5N2EyMzU5NywgMHg0NGNjODg0NCwgMHgxNzM5MmUxNywgMHhjNDU3OTNjNCwgMHhhN2YyNTVhNywgMHg3ZTgyZmM3ZSwgMHgzZDQ3N2EzZCwgMHg2NGFjYzg2NCwgMHg1ZGU3YmE1ZCwgMHgxOTJiMzIxOSwgMHg3Mzk1ZTY3MywgMHg2MGEwYzA2MCwgMHg4MTk4MTk4MSwgMHg0ZmQxOWU0ZiwgMHhkYzdmYTNkYywgMHgyMjY2NDQyMiwgMHgyYTdlNTQyYSwgMHg5MGFiM2I5MCwgMHg4ODgzMGI4OCwgMHg0NmNhOGM0NiwgMHhlZTI5YzdlZSwgMHhiOGQzNmJiOCwgMHgxNDNjMjgxNCwgMHhkZTc5YTdkZSwgMHg1ZWUyYmM1ZSwgMHgwYjFkMTYwYiwgMHhkYjc2YWRkYiwgMHhlMDNiZGJlMCwgMHgzMjU2NjQzMiwgMHgzYTRlNzQzYSwgMHgwYTFlMTQwYSwgMHg0OWRiOTI0OSwgMHgwNjBhMGMwNiwgMHgyNDZjNDgyNCwgMHg1Y2U0Yjg1YywgMHhjMjVkOWZjMiwgMHhkMzZlYmRkMywgMHhhY2VmNDNhYywgMHg2MmE2YzQ2MiwgMHg5MWE4Mzk5MSwgMHg5NWE0MzE5NSwgMHhlNDM3ZDNlNCwgMHg3OThiZjI3OSwgMHhlNzMyZDVlNywgMHhjODQzOGJjOCwgMHgzNzU5NmUzNywgMHg2ZGI3ZGE2ZCwgMHg4ZDhjMDE4ZCwgMHhkNTY0YjFkNSwgMHg0ZWQyOWM0ZSwgMHhhOWUwNDlhOSwgMHg2Y2I0ZDg2YywgMHg1NmZhYWM1NiwgMHhmNDA3ZjNmNCwgMHhlYTI1Y2ZlYSwgMHg2NWFmY2E2NSwgMHg3YThlZjQ3YSwgMHhhZWU5NDdhZSwgMHgwODE4MTAwOCwgMHhiYWQ1NmZiYSwgMHg3ODg4ZjA3OCwgMHgyNTZmNGEyNSwgMHgyZTcyNWMyZSwgMHgxYzI0MzgxYywgMHhhNmYxNTdhNiwgMHhiNGM3NzNiNCwgMHhjNjUxOTdjNiwgMHhlODIzY2JlOCwgMHhkZDdjYTFkZCwgMHg3NDljZTg3NCwgMHgxZjIxM2UxZiwgMHg0YmRkOTY0YiwgMHhiZGRjNjFiZCwgMHg4Yjg2MGQ4YiwgMHg4YTg1MGY4YSwgMHg3MDkwZTA3MCwgMHgzZTQyN2MzZSwgMHhiNWM0NzFiNSwgMHg2NmFhY2M2NiwgMHg0OGQ4OTA0OCwgMHgwMzA1MDYwMywgMHhmNjAxZjdmNiwgMHgwZTEyMWMwZSwgMHg2MWEzYzI2MSwgMHgzNTVmNmEzNSwgMHg1N2Y5YWU1NywgMHhiOWQwNjliOSwgMHg4NjkxMTc4NiwgMHhjMTU4OTljMSwgMHgxZDI3M2ExZCwgMHg5ZWI5Mjc5ZSwgMHhlMTM4ZDllMSwgMHhmODEzZWJmOCwgMHg5OGIzMmI5OCwgMHgxMTMzMjIxMSwgMHg2OWJiZDI2OSwgMHhkOTcwYTlkOSwgMHg4ZTg5MDc4ZSwgMHg5NGE3MzM5NCwgMHg5YmI2MmQ5YiwgMHgxZTIyM2MxZSwgMHg4NzkyMTU4NywgMHhlOTIwYzllOSwgMHhjZTQ5ODdjZSwgMHg1NWZmYWE1NSwgMHgyODc4NTAyOCwgMHhkZjdhYTVkZiwgMHg4YzhmMDM4YywgMHhhMWY4NTlhMSwgMHg4OTgwMDk4OSwgMHgwZDE3MWEwZCwgMHhiZmRhNjViZiwgMHhlNjMxZDdlNiwgMHg0MmM2ODQ0MiwgMHg2OGI4ZDA2OCwgMHg0MWMzODI0MSwgMHg5OWIwMjk5OSwgMHgyZDc3NWEyZCwgMHgwZjExMWUwZiwgMHhiMGNiN2JiMCwgMHg1NGZjYTg1NCwgMHhiYmQ2NmRiYiwgMHgxNjNhMmMxNl07XG5cdCAgICB2YXIgVDQgPSBbMHg2MzYzYTVjNiwgMHg3YzdjODRmOCwgMHg3Nzc3OTllZSwgMHg3YjdiOGRmNiwgMHhmMmYyMGRmZiwgMHg2YjZiYmRkNiwgMHg2ZjZmYjFkZSwgMHhjNWM1NTQ5MSwgMHgzMDMwNTA2MCwgMHgwMTAxMDMwMiwgMHg2NzY3YTljZSwgMHgyYjJiN2Q1NiwgMHhmZWZlMTllNywgMHhkN2Q3NjJiNSwgMHhhYmFiZTY0ZCwgMHg3Njc2OWFlYywgMHhjYWNhNDU4ZiwgMHg4MjgyOWQxZiwgMHhjOWM5NDA4OSwgMHg3ZDdkODdmYSwgMHhmYWZhMTVlZiwgMHg1OTU5ZWJiMiwgMHg0NzQ3Yzk4ZSwgMHhmMGYwMGJmYiwgMHhhZGFkZWM0MSwgMHhkNGQ0NjdiMywgMHhhMmEyZmQ1ZiwgMHhhZmFmZWE0NSwgMHg5YzljYmYyMywgMHhhNGE0Zjc1MywgMHg3MjcyOTZlNCwgMHhjMGMwNWI5YiwgMHhiN2I3YzI3NSwgMHhmZGZkMWNlMSwgMHg5MzkzYWUzZCwgMHgyNjI2NmE0YywgMHgzNjM2NWE2YywgMHgzZjNmNDE3ZSwgMHhmN2Y3MDJmNSwgMHhjY2NjNGY4MywgMHgzNDM0NWM2OCwgMHhhNWE1ZjQ1MSwgMHhlNWU1MzRkMSwgMHhmMWYxMDhmOSwgMHg3MTcxOTNlMiwgMHhkOGQ4NzNhYiwgMHgzMTMxNTM2MiwgMHgxNTE1M2YyYSwgMHgwNDA0MGMwOCwgMHhjN2M3NTI5NSwgMHgyMzIzNjU0NiwgMHhjM2MzNWU5ZCwgMHgxODE4MjgzMCwgMHg5Njk2YTEzNywgMHgwNTA1MGYwYSwgMHg5YTlhYjUyZiwgMHgwNzA3MDkwZSwgMHgxMjEyMzYyNCwgMHg4MDgwOWIxYiwgMHhlMmUyM2RkZiwgMHhlYmViMjZjZCwgMHgyNzI3Njk0ZSwgMHhiMmIyY2Q3ZiwgMHg3NTc1OWZlYSwgMHgwOTA5MWIxMiwgMHg4MzgzOWUxZCwgMHgyYzJjNzQ1OCwgMHgxYTFhMmUzNCwgMHgxYjFiMmQzNiwgMHg2ZTZlYjJkYywgMHg1YTVhZWViNCwgMHhhMGEwZmI1YiwgMHg1MjUyZjZhNCwgMHgzYjNiNGQ3NiwgMHhkNmQ2NjFiNywgMHhiM2IzY2U3ZCwgMHgyOTI5N2I1MiwgMHhlM2UzM2VkZCwgMHgyZjJmNzE1ZSwgMHg4NDg0OTcxMywgMHg1MzUzZjVhNiwgMHhkMWQxNjhiOSwgMHgwMDAwMDAwMCwgMHhlZGVkMmNjMSwgMHgyMDIwNjA0MCwgMHhmY2ZjMWZlMywgMHhiMWIxYzg3OSwgMHg1YjViZWRiNiwgMHg2YTZhYmVkNCwgMHhjYmNiNDY4ZCwgMHhiZWJlZDk2NywgMHgzOTM5NGI3MiwgMHg0YTRhZGU5NCwgMHg0YzRjZDQ5OCwgMHg1ODU4ZThiMCwgMHhjZmNmNGE4NSwgMHhkMGQwNmJiYiwgMHhlZmVmMmFjNSwgMHhhYWFhZTU0ZiwgMHhmYmZiMTZlZCwgMHg0MzQzYzU4NiwgMHg0ZDRkZDc5YSwgMHgzMzMzNTU2NiwgMHg4NTg1OTQxMSwgMHg0NTQ1Y2Y4YSwgMHhmOWY5MTBlOSwgMHgwMjAyMDYwNCwgMHg3ZjdmODFmZSwgMHg1MDUwZjBhMCwgMHgzYzNjNDQ3OCwgMHg5ZjlmYmEyNSwgMHhhOGE4ZTM0YiwgMHg1MTUxZjNhMiwgMHhhM2EzZmU1ZCwgMHg0MDQwYzA4MCwgMHg4ZjhmOGEwNSwgMHg5MjkyYWQzZiwgMHg5ZDlkYmMyMSwgMHgzODM4NDg3MCwgMHhmNWY1MDRmMSwgMHhiY2JjZGY2MywgMHhiNmI2YzE3NywgMHhkYWRhNzVhZiwgMHgyMTIxNjM0MiwgMHgxMDEwMzAyMCwgMHhmZmZmMWFlNSwgMHhmM2YzMGVmZCwgMHhkMmQyNmRiZiwgMHhjZGNkNGM4MSwgMHgwYzBjMTQxOCwgMHgxMzEzMzUyNiwgMHhlY2VjMmZjMywgMHg1ZjVmZTFiZSwgMHg5Nzk3YTIzNSwgMHg0NDQ0Y2M4OCwgMHgxNzE3MzkyZSwgMHhjNGM0NTc5MywgMHhhN2E3ZjI1NSwgMHg3ZTdlODJmYywgMHgzZDNkNDc3YSwgMHg2NDY0YWNjOCwgMHg1ZDVkZTdiYSwgMHgxOTE5MmIzMiwgMHg3MzczOTVlNiwgMHg2MDYwYTBjMCwgMHg4MTgxOTgxOSwgMHg0ZjRmZDE5ZSwgMHhkY2RjN2ZhMywgMHgyMjIyNjY0NCwgMHgyYTJhN2U1NCwgMHg5MDkwYWIzYiwgMHg4ODg4ODMwYiwgMHg0NjQ2Y2E4YywgMHhlZWVlMjljNywgMHhiOGI4ZDM2YiwgMHgxNDE0M2MyOCwgMHhkZWRlNzlhNywgMHg1ZTVlZTJiYywgMHgwYjBiMWQxNiwgMHhkYmRiNzZhZCwgMHhlMGUwM2JkYiwgMHgzMjMyNTY2NCwgMHgzYTNhNGU3NCwgMHgwYTBhMWUxNCwgMHg0OTQ5ZGI5MiwgMHgwNjA2MGEwYywgMHgyNDI0NmM0OCwgMHg1YzVjZTRiOCwgMHhjMmMyNWQ5ZiwgMHhkM2QzNmViZCwgMHhhY2FjZWY0MywgMHg2MjYyYTZjNCwgMHg5MTkxYTgzOSwgMHg5NTk1YTQzMSwgMHhlNGU0MzdkMywgMHg3OTc5OGJmMiwgMHhlN2U3MzJkNSwgMHhjOGM4NDM4YiwgMHgzNzM3NTk2ZSwgMHg2ZDZkYjdkYSwgMHg4ZDhkOGMwMSwgMHhkNWQ1NjRiMSwgMHg0ZTRlZDI5YywgMHhhOWE5ZTA0OSwgMHg2YzZjYjRkOCwgMHg1NjU2ZmFhYywgMHhmNGY0MDdmMywgMHhlYWVhMjVjZiwgMHg2NTY1YWZjYSwgMHg3YTdhOGVmNCwgMHhhZWFlZTk0NywgMHgwODA4MTgxMCwgMHhiYWJhZDU2ZiwgMHg3ODc4ODhmMCwgMHgyNTI1NmY0YSwgMHgyZTJlNzI1YywgMHgxYzFjMjQzOCwgMHhhNmE2ZjE1NywgMHhiNGI0Yzc3MywgMHhjNmM2NTE5NywgMHhlOGU4MjNjYiwgMHhkZGRkN2NhMSwgMHg3NDc0OWNlOCwgMHgxZjFmMjEzZSwgMHg0YjRiZGQ5NiwgMHhiZGJkZGM2MSwgMHg4YjhiODYwZCwgMHg4YThhODUwZiwgMHg3MDcwOTBlMCwgMHgzZTNlNDI3YywgMHhiNWI1YzQ3MSwgMHg2NjY2YWFjYywgMHg0ODQ4ZDg5MCwgMHgwMzAzMDUwNiwgMHhmNmY2MDFmNywgMHgwZTBlMTIxYywgMHg2MTYxYTNjMiwgMHgzNTM1NWY2YSwgMHg1NzU3ZjlhZSwgMHhiOWI5ZDA2OSwgMHg4Njg2OTExNywgMHhjMWMxNTg5OSwgMHgxZDFkMjczYSwgMHg5ZTllYjkyNywgMHhlMWUxMzhkOSwgMHhmOGY4MTNlYiwgMHg5ODk4YjMyYiwgMHgxMTExMzMyMiwgMHg2OTY5YmJkMiwgMHhkOWQ5NzBhOSwgMHg4ZThlODkwNywgMHg5NDk0YTczMywgMHg5YjliYjYyZCwgMHgxZTFlMjIzYywgMHg4Nzg3OTIxNSwgMHhlOWU5MjBjOSwgMHhjZWNlNDk4NywgMHg1NTU1ZmZhYSwgMHgyODI4Nzg1MCwgMHhkZmRmN2FhNSwgMHg4YzhjOGYwMywgMHhhMWExZjg1OSwgMHg4OTg5ODAwOSwgMHgwZDBkMTcxYSwgMHhiZmJmZGE2NSwgMHhlNmU2MzFkNywgMHg0MjQyYzY4NCwgMHg2ODY4YjhkMCwgMHg0MTQxYzM4MiwgMHg5OTk5YjAyOSwgMHgyZDJkNzc1YSwgMHgwZjBmMTExZSwgMHhiMGIwY2I3YiwgMHg1NDU0ZmNhOCwgMHhiYmJiZDY2ZCwgMHgxNjE2M2EyY107XG5cblx0ICAgIC8vIFRyYW5zZm9ybWF0aW9ucyBmb3IgZGVjcnlwdGlvblxuXHQgICAgdmFyIFQ1ID0gWzB4NTFmNGE3NTAsIDB4N2U0MTY1NTMsIDB4MWExN2E0YzMsIDB4M2EyNzVlOTYsIDB4M2JhYjZiY2IsIDB4MWY5ZDQ1ZjEsIDB4YWNmYTU4YWIsIDB4NGJlMzAzOTMsIDB4MjAzMGZhNTUsIDB4YWQ3NjZkZjYsIDB4ODhjYzc2OTEsIDB4ZjUwMjRjMjUsIDB4NGZlNWQ3ZmMsIDB4YzUyYWNiZDcsIDB4MjYzNTQ0ODAsIDB4YjU2MmEzOGYsIDB4ZGViMTVhNDksIDB4MjViYTFiNjcsIDB4NDVlYTBlOTgsIDB4NWRmZWMwZTEsIDB4YzMyZjc1MDIsIDB4ODE0Y2YwMTIsIDB4OGQ0Njk3YTMsIDB4NmJkM2Y5YzYsIDB4MDM4ZjVmZTcsIDB4MTU5MjljOTUsIDB4YmY2ZDdhZWIsIDB4OTU1MjU5ZGEsIDB4ZDRiZTgzMmQsIDB4NTg3NDIxZDMsIDB4NDllMDY5MjksIDB4OGVjOWM4NDQsIDB4NzVjMjg5NmEsIDB4ZjQ4ZTc5NzgsIDB4OTk1ODNlNmIsIDB4MjdiOTcxZGQsIDB4YmVlMTRmYjYsIDB4ZjA4OGFkMTcsIDB4YzkyMGFjNjYsIDB4N2RjZTNhYjQsIDB4NjNkZjRhMTgsIDB4ZTUxYTMxODIsIDB4OTc1MTMzNjAsIDB4NjI1MzdmNDUsIDB4YjE2NDc3ZTAsIDB4YmI2YmFlODQsIDB4ZmU4MWEwMWMsIDB4ZjkwODJiOTQsIDB4NzA0ODY4NTgsIDB4OGY0NWZkMTksIDB4OTRkZTZjODcsIDB4NTI3YmY4YjcsIDB4YWI3M2QzMjMsIDB4NzI0YjAyZTIsIDB4ZTMxZjhmNTcsIDB4NjY1NWFiMmEsIDB4YjJlYjI4MDcsIDB4MmZiNWMyMDMsIDB4ODZjNTdiOWEsIDB4ZDMzNzA4YTUsIDB4MzAyODg3ZjIsIDB4MjNiZmE1YjIsIDB4MDIwMzZhYmEsIDB4ZWQxNjgyNWMsIDB4OGFjZjFjMmIsIDB4YTc3OWI0OTIsIDB4ZjMwN2YyZjAsIDB4NGU2OWUyYTEsIDB4NjVkYWY0Y2QsIDB4MDYwNWJlZDUsIDB4ZDEzNDYyMWYsIDB4YzRhNmZlOGEsIDB4MzQyZTUzOWQsIDB4YTJmMzU1YTAsIDB4MDU4YWUxMzIsIDB4YTRmNmViNzUsIDB4MGI4M2VjMzksIDB4NDA2MGVmYWEsIDB4NWU3MTlmMDYsIDB4YmQ2ZTEwNTEsIDB4M2UyMThhZjksIDB4OTZkZDA2M2QsIDB4ZGQzZTA1YWUsIDB4NGRlNmJkNDYsIDB4OTE1NDhkYjUsIDB4NzFjNDVkMDUsIDB4MDQwNmQ0NmYsIDB4NjA1MDE1ZmYsIDB4MTk5OGZiMjQsIDB4ZDZiZGU5OTcsIDB4ODk0MDQzY2MsIDB4NjdkOTllNzcsIDB4YjBlODQyYmQsIDB4MDc4OThiODgsIDB4ZTcxOTViMzgsIDB4NzljOGVlZGIsIDB4YTE3YzBhNDcsIDB4N2M0MjBmZTksIDB4Zjg4NDFlYzksIDB4MDAwMDAwMDAsIDB4MDk4MDg2ODMsIDB4MzIyYmVkNDgsIDB4MWUxMTcwYWMsIDB4NmM1YTcyNGUsIDB4ZmQwZWZmZmIsIDB4MGY4NTM4NTYsIDB4M2RhZWQ1MWUsIDB4MzYyZDM5MjcsIDB4MGEwZmQ5NjQsIDB4Njg1Y2E2MjEsIDB4OWI1YjU0ZDEsIDB4MjQzNjJlM2EsIDB4MGMwYTY3YjEsIDB4OTM1N2U3MGYsIDB4YjRlZTk2ZDIsIDB4MWI5YjkxOWUsIDB4ODBjMGM1NGYsIDB4NjFkYzIwYTIsIDB4NWE3NzRiNjksIDB4MWMxMjFhMTYsIDB4ZTI5M2JhMGEsIDB4YzBhMDJhZTUsIDB4M2MyMmUwNDMsIDB4MTIxYjE3MWQsIDB4MGUwOTBkMGIsIDB4ZjI4YmM3YWQsIDB4MmRiNmE4YjksIDB4MTQxZWE5YzgsIDB4NTdmMTE5ODUsIDB4YWY3NTA3NGMsIDB4ZWU5OWRkYmIsIDB4YTM3ZjYwZmQsIDB4ZjcwMTI2OWYsIDB4NWM3MmY1YmMsIDB4NDQ2NjNiYzUsIDB4NWJmYjdlMzQsIDB4OGI0MzI5NzYsIDB4Y2IyM2M2ZGMsIDB4YjZlZGZjNjgsIDB4YjhlNGYxNjMsIDB4ZDczMWRjY2EsIDB4NDI2Mzg1MTAsIDB4MTM5NzIyNDAsIDB4ODRjNjExMjAsIDB4ODU0YTI0N2QsIDB4ZDJiYjNkZjgsIDB4YWVmOTMyMTEsIDB4YzcyOWExNmQsIDB4MWQ5ZTJmNGIsIDB4ZGNiMjMwZjMsIDB4MGQ4NjUyZWMsIDB4NzdjMWUzZDAsIDB4MmJiMzE2NmMsIDB4YTk3MGI5OTksIDB4MTE5NDQ4ZmEsIDB4NDdlOTY0MjIsIDB4YThmYzhjYzQsIDB4YTBmMDNmMWEsIDB4NTY3ZDJjZDgsIDB4MjIzMzkwZWYsIDB4ODc0OTRlYzcsIDB4ZDkzOGQxYzEsIDB4OGNjYWEyZmUsIDB4OThkNDBiMzYsIDB4YTZmNTgxY2YsIDB4YTU3YWRlMjgsIDB4ZGFiNzhlMjYsIDB4M2ZhZGJmYTQsIDB4MmMzYTlkZTQsIDB4NTA3ODkyMGQsIDB4NmE1ZmNjOWIsIDB4NTQ3ZTQ2NjIsIDB4ZjY4ZDEzYzIsIDB4OTBkOGI4ZTgsIDB4MmUzOWY3NWUsIDB4ODJjM2FmZjUsIDB4OWY1ZDgwYmUsIDB4NjlkMDkzN2MsIDB4NmZkNTJkYTksIDB4Y2YyNTEyYjMsIDB4YzhhYzk5M2IsIDB4MTAxODdkYTcsIDB4ZTg5YzYzNmUsIDB4ZGIzYmJiN2IsIDB4Y2QyNjc4MDksIDB4NmU1OTE4ZjQsIDB4ZWM5YWI3MDEsIDB4ODM0ZjlhYTgsIDB4ZTY5NTZlNjUsIDB4YWFmZmU2N2UsIDB4MjFiY2NmMDgsIDB4ZWYxNWU4ZTYsIDB4YmFlNzliZDksIDB4NGE2ZjM2Y2UsIDB4ZWE5ZjA5ZDQsIDB4MjliMDdjZDYsIDB4MzFhNGIyYWYsIDB4MmEzZjIzMzEsIDB4YzZhNTk0MzAsIDB4MzVhMjY2YzAsIDB4NzQ0ZWJjMzcsIDB4ZmM4MmNhYTYsIDB4ZTA5MGQwYjAsIDB4MzNhN2Q4MTUsIDB4ZjEwNDk4NGEsIDB4NDFlY2RhZjcsIDB4N2ZjZDUwMGUsIDB4MTc5MWY2MmYsIDB4NzY0ZGQ2OGQsIDB4NDNlZmIwNGQsIDB4Y2NhYTRkNTQsIDB4ZTQ5NjA0ZGYsIDB4OWVkMWI1ZTMsIDB4NGM2YTg4MWIsIDB4YzEyYzFmYjgsIDB4NDY2NTUxN2YsIDB4OWQ1ZWVhMDQsIDB4MDE4YzM1NWQsIDB4ZmE4Nzc0NzMsIDB4ZmIwYjQxMmUsIDB4YjM2NzFkNWEsIDB4OTJkYmQyNTIsIDB4ZTkxMDU2MzMsIDB4NmRkNjQ3MTMsIDB4OWFkNzYxOGMsIDB4MzdhMTBjN2EsIDB4NTlmODE0OGUsIDB4ZWIxMzNjODksIDB4Y2VhOTI3ZWUsIDB4Yjc2MWM5MzUsIDB4ZTExY2U1ZWQsIDB4N2E0N2IxM2MsIDB4OWNkMmRmNTksIDB4NTVmMjczM2YsIDB4MTgxNGNlNzksIDB4NzNjNzM3YmYsIDB4NTNmN2NkZWEsIDB4NWZmZGFhNWIsIDB4ZGYzZDZmMTQsIDB4Nzg0NGRiODYsIDB4Y2FhZmYzODEsIDB4Yjk2OGM0M2UsIDB4MzgyNDM0MmMsIDB4YzJhMzQwNWYsIDB4MTYxZGMzNzIsIDB4YmNlMjI1MGMsIDB4MjgzYzQ5OGIsIDB4ZmYwZDk1NDEsIDB4MzlhODAxNzEsIDB4MDgwY2IzZGUsIDB4ZDhiNGU0OWMsIDB4NjQ1NmMxOTAsIDB4N2JjYjg0NjEsIDB4ZDUzMmI2NzAsIDB4NDg2YzVjNzQsIDB4ZDBiODU3NDJdO1xuXHQgICAgdmFyIFQ2ID0gWzB4NTA1MWY0YTcsIDB4NTM3ZTQxNjUsIDB4YzMxYTE3YTQsIDB4OTYzYTI3NWUsIDB4Y2IzYmFiNmIsIDB4ZjExZjlkNDUsIDB4YWJhY2ZhNTgsIDB4OTM0YmUzMDMsIDB4NTUyMDMwZmEsIDB4ZjZhZDc2NmQsIDB4OTE4OGNjNzYsIDB4MjVmNTAyNGMsIDB4ZmM0ZmU1ZDcsIDB4ZDdjNTJhY2IsIDB4ODAyNjM1NDQsIDB4OGZiNTYyYTMsIDB4NDlkZWIxNWEsIDB4NjcyNWJhMWIsIDB4OTg0NWVhMGUsIDB4ZTE1ZGZlYzAsIDB4MDJjMzJmNzUsIDB4MTI4MTRjZjAsIDB4YTM4ZDQ2OTcsIDB4YzY2YmQzZjksIDB4ZTcwMzhmNWYsIDB4OTUxNTkyOWMsIDB4ZWJiZjZkN2EsIDB4ZGE5NTUyNTksIDB4MmRkNGJlODMsIDB4ZDM1ODc0MjEsIDB4Mjk0OWUwNjksIDB4NDQ4ZWM5YzgsIDB4NmE3NWMyODksIDB4NzhmNDhlNzksIDB4NmI5OTU4M2UsIDB4ZGQyN2I5NzEsIDB4YjZiZWUxNGYsIDB4MTdmMDg4YWQsIDB4NjZjOTIwYWMsIDB4YjQ3ZGNlM2EsIDB4MTg2M2RmNGEsIDB4ODJlNTFhMzEsIDB4NjA5NzUxMzMsIDB4NDU2MjUzN2YsIDB4ZTBiMTY0NzcsIDB4ODRiYjZiYWUsIDB4MWNmZTgxYTAsIDB4OTRmOTA4MmIsIDB4NTg3MDQ4NjgsIDB4MTk4ZjQ1ZmQsIDB4ODc5NGRlNmMsIDB4Yjc1MjdiZjgsIDB4MjNhYjczZDMsIDB4ZTI3MjRiMDIsIDB4NTdlMzFmOGYsIDB4MmE2NjU1YWIsIDB4MDdiMmViMjgsIDB4MDMyZmI1YzIsIDB4OWE4NmM1N2IsIDB4YTVkMzM3MDgsIDB4ZjIzMDI4ODcsIDB4YjIyM2JmYTUsIDB4YmEwMjAzNmEsIDB4NWNlZDE2ODIsIDB4MmI4YWNmMWMsIDB4OTJhNzc5YjQsIDB4ZjBmMzA3ZjIsIDB4YTE0ZTY5ZTIsIDB4Y2Q2NWRhZjQsIDB4ZDUwNjA1YmUsIDB4MWZkMTM0NjIsIDB4OGFjNGE2ZmUsIDB4OWQzNDJlNTMsIDB4YTBhMmYzNTUsIDB4MzIwNThhZTEsIDB4NzVhNGY2ZWIsIDB4MzkwYjgzZWMsIDB4YWE0MDYwZWYsIDB4MDY1ZTcxOWYsIDB4NTFiZDZlMTAsIDB4ZjkzZTIxOGEsIDB4M2Q5NmRkMDYsIDB4YWVkZDNlMDUsIDB4NDY0ZGU2YmQsIDB4YjU5MTU0OGQsIDB4MDU3MWM0NWQsIDB4NmYwNDA2ZDQsIDB4ZmY2MDUwMTUsIDB4MjQxOTk4ZmIsIDB4OTdkNmJkZTksIDB4Y2M4OTQwNDMsIDB4Nzc2N2Q5OWUsIDB4YmRiMGU4NDIsIDB4ODgwNzg5OGIsIDB4MzhlNzE5NWIsIDB4ZGI3OWM4ZWUsIDB4NDdhMTdjMGEsIDB4ZTk3YzQyMGYsIDB4YzlmODg0MWUsIDB4MDAwMDAwMDAsIDB4ODMwOTgwODYsIDB4NDgzMjJiZWQsIDB4YWMxZTExNzAsIDB4NGU2YzVhNzIsIDB4ZmJmZDBlZmYsIDB4NTYwZjg1MzgsIDB4MWUzZGFlZDUsIDB4MjczNjJkMzksIDB4NjQwYTBmZDksIDB4MjE2ODVjYTYsIDB4ZDE5YjViNTQsIDB4M2EyNDM2MmUsIDB4YjEwYzBhNjcsIDB4MGY5MzU3ZTcsIDB4ZDJiNGVlOTYsIDB4OWUxYjliOTEsIDB4NGY4MGMwYzUsIDB4YTI2MWRjMjAsIDB4Njk1YTc3NGIsIDB4MTYxYzEyMWEsIDB4MGFlMjkzYmEsIDB4ZTVjMGEwMmEsIDB4NDMzYzIyZTAsIDB4MWQxMjFiMTcsIDB4MGIwZTA5MGQsIDB4YWRmMjhiYzcsIDB4YjkyZGI2YTgsIDB4YzgxNDFlYTksIDB4ODU1N2YxMTksIDB4NGNhZjc1MDcsIDB4YmJlZTk5ZGQsIDB4ZmRhMzdmNjAsIDB4OWZmNzAxMjYsIDB4YmM1YzcyZjUsIDB4YzU0NDY2M2IsIDB4MzQ1YmZiN2UsIDB4NzY4YjQzMjksIDB4ZGNjYjIzYzYsIDB4NjhiNmVkZmMsIDB4NjNiOGU0ZjEsIDB4Y2FkNzMxZGMsIDB4MTA0MjYzODUsIDB4NDAxMzk3MjIsIDB4MjA4NGM2MTEsIDB4N2Q4NTRhMjQsIDB4ZjhkMmJiM2QsIDB4MTFhZWY5MzIsIDB4NmRjNzI5YTEsIDB4NGIxZDllMmYsIDB4ZjNkY2IyMzAsIDB4ZWMwZDg2NTIsIDB4ZDA3N2MxZTMsIDB4NmMyYmIzMTYsIDB4OTlhOTcwYjksIDB4ZmExMTk0NDgsIDB4MjI0N2U5NjQsIDB4YzRhOGZjOGMsIDB4MWFhMGYwM2YsIDB4ZDg1NjdkMmMsIDB4ZWYyMjMzOTAsIDB4Yzc4NzQ5NGUsIDB4YzFkOTM4ZDEsIDB4ZmU4Y2NhYTIsIDB4MzY5OGQ0MGIsIDB4Y2ZhNmY1ODEsIDB4MjhhNTdhZGUsIDB4MjZkYWI3OGUsIDB4YTQzZmFkYmYsIDB4ZTQyYzNhOWQsIDB4MGQ1MDc4OTIsIDB4OWI2YTVmY2MsIDB4NjI1NDdlNDYsIDB4YzJmNjhkMTMsIDB4ZTg5MGQ4YjgsIDB4NWUyZTM5ZjcsIDB4ZjU4MmMzYWYsIDB4YmU5ZjVkODAsIDB4N2M2OWQwOTMsIDB4YTk2ZmQ1MmQsIDB4YjNjZjI1MTIsIDB4M2JjOGFjOTksIDB4YTcxMDE4N2QsIDB4NmVlODljNjMsIDB4N2JkYjNiYmIsIDB4MDljZDI2NzgsIDB4ZjQ2ZTU5MTgsIDB4MDFlYzlhYjcsIDB4YTg4MzRmOWEsIDB4NjVlNjk1NmUsIDB4N2VhYWZmZTYsIDB4MDgyMWJjY2YsIDB4ZTZlZjE1ZTgsIDB4ZDliYWU3OWIsIDB4Y2U0YTZmMzYsIDB4ZDRlYTlmMDksIDB4ZDYyOWIwN2MsIDB4YWYzMWE0YjIsIDB4MzEyYTNmMjMsIDB4MzBjNmE1OTQsIDB4YzAzNWEyNjYsIDB4Mzc3NDRlYmMsIDB4YTZmYzgyY2EsIDB4YjBlMDkwZDAsIDB4MTUzM2E3ZDgsIDB4NGFmMTA0OTgsIDB4Zjc0MWVjZGEsIDB4MGU3ZmNkNTAsIDB4MmYxNzkxZjYsIDB4OGQ3NjRkZDYsIDB4NGQ0M2VmYjAsIDB4NTRjY2FhNGQsIDB4ZGZlNDk2MDQsIDB4ZTM5ZWQxYjUsIDB4MWI0YzZhODgsIDB4YjhjMTJjMWYsIDB4N2Y0NjY1NTEsIDB4MDQ5ZDVlZWEsIDB4NWQwMThjMzUsIDB4NzNmYTg3NzQsIDB4MmVmYjBiNDEsIDB4NWFiMzY3MWQsIDB4NTI5MmRiZDIsIDB4MzNlOTEwNTYsIDB4MTM2ZGQ2NDcsIDB4OGM5YWQ3NjEsIDB4N2EzN2ExMGMsIDB4OGU1OWY4MTQsIDB4ODllYjEzM2MsIDB4ZWVjZWE5MjcsIDB4MzViNzYxYzksIDB4ZWRlMTFjZTUsIDB4M2M3YTQ3YjEsIDB4NTk5Y2QyZGYsIDB4M2Y1NWYyNzMsIDB4NzkxODE0Y2UsIDB4YmY3M2M3MzcsIDB4ZWE1M2Y3Y2QsIDB4NWI1ZmZkYWEsIDB4MTRkZjNkNmYsIDB4ODY3ODQ0ZGIsIDB4ODFjYWFmZjMsIDB4M2ViOTY4YzQsIDB4MmMzODI0MzQsIDB4NWZjMmEzNDAsIDB4NzIxNjFkYzMsIDB4MGNiY2UyMjUsIDB4OGIyODNjNDksIDB4NDFmZjBkOTUsIDB4NzEzOWE4MDEsIDB4ZGUwODBjYjMsIDB4OWNkOGI0ZTQsIDB4OTA2NDU2YzEsIDB4NjE3YmNiODQsIDB4NzBkNTMyYjYsIDB4NzQ0ODZjNWMsIDB4NDJkMGI4NTddO1xuXHQgICAgdmFyIFQ3ID0gWzB4YTc1MDUxZjQsIDB4NjU1MzdlNDEsIDB4YTRjMzFhMTcsIDB4NWU5NjNhMjcsIDB4NmJjYjNiYWIsIDB4NDVmMTFmOWQsIDB4NThhYmFjZmEsIDB4MDM5MzRiZTMsIDB4ZmE1NTIwMzAsIDB4NmRmNmFkNzYsIDB4NzY5MTg4Y2MsIDB4NGMyNWY1MDIsIDB4ZDdmYzRmZTUsIDB4Y2JkN2M1MmEsIDB4NDQ4MDI2MzUsIDB4YTM4ZmI1NjIsIDB4NWE0OWRlYjEsIDB4MWI2NzI1YmEsIDB4MGU5ODQ1ZWEsIDB4YzBlMTVkZmUsIDB4NzUwMmMzMmYsIDB4ZjAxMjgxNGMsIDB4OTdhMzhkNDYsIDB4ZjljNjZiZDMsIDB4NWZlNzAzOGYsIDB4OWM5NTE1OTIsIDB4N2FlYmJmNmQsIDB4NTlkYTk1NTIsIDB4ODMyZGQ0YmUsIDB4MjFkMzU4NzQsIDB4NjkyOTQ5ZTAsIDB4Yzg0NDhlYzksIDB4ODk2YTc1YzIsIDB4Nzk3OGY0OGUsIDB4M2U2Yjk5NTgsIDB4NzFkZDI3YjksIDB4NGZiNmJlZTEsIDB4YWQxN2YwODgsIDB4YWM2NmM5MjAsIDB4M2FiNDdkY2UsIDB4NGExODYzZGYsIDB4MzE4MmU1MWEsIDB4MzM2MDk3NTEsIDB4N2Y0NTYyNTMsIDB4NzdlMGIxNjQsIDB4YWU4NGJiNmIsIDB4YTAxY2ZlODEsIDB4MmI5NGY5MDgsIDB4Njg1ODcwNDgsIDB4ZmQxOThmNDUsIDB4NmM4Nzk0ZGUsIDB4ZjhiNzUyN2IsIDB4ZDMyM2FiNzMsIDB4MDJlMjcyNGIsIDB4OGY1N2UzMWYsIDB4YWIyYTY2NTUsIDB4MjgwN2IyZWIsIDB4YzIwMzJmYjUsIDB4N2I5YTg2YzUsIDB4MDhhNWQzMzcsIDB4ODdmMjMwMjgsIDB4YTViMjIzYmYsIDB4NmFiYTAyMDMsIDB4ODI1Y2VkMTYsIDB4MWMyYjhhY2YsIDB4YjQ5MmE3NzksIDB4ZjJmMGYzMDcsIDB4ZTJhMTRlNjksIDB4ZjRjZDY1ZGEsIDB4YmVkNTA2MDUsIDB4NjIxZmQxMzQsIDB4ZmU4YWM0YTYsIDB4NTM5ZDM0MmUsIDB4NTVhMGEyZjMsIDB4ZTEzMjA1OGEsIDB4ZWI3NWE0ZjYsIDB4ZWMzOTBiODMsIDB4ZWZhYTQwNjAsIDB4OWYwNjVlNzEsIDB4MTA1MWJkNmUsIDB4OGFmOTNlMjEsIDB4MDYzZDk2ZGQsIDB4MDVhZWRkM2UsIDB4YmQ0NjRkZTYsIDB4OGRiNTkxNTQsIDB4NWQwNTcxYzQsIDB4ZDQ2ZjA0MDYsIDB4MTVmZjYwNTAsIDB4ZmIyNDE5OTgsIDB4ZTk5N2Q2YmQsIDB4NDNjYzg5NDAsIDB4OWU3NzY3ZDksIDB4NDJiZGIwZTgsIDB4OGI4ODA3ODksIDB4NWIzOGU3MTksIDB4ZWVkYjc5YzgsIDB4MGE0N2ExN2MsIDB4MGZlOTdjNDIsIDB4MWVjOWY4ODQsIDB4MDAwMDAwMDAsIDB4ODY4MzA5ODAsIDB4ZWQ0ODMyMmIsIDB4NzBhYzFlMTEsIDB4NzI0ZTZjNWEsIDB4ZmZmYmZkMGUsIDB4Mzg1NjBmODUsIDB4ZDUxZTNkYWUsIDB4MzkyNzM2MmQsIDB4ZDk2NDBhMGYsIDB4YTYyMTY4NWMsIDB4NTRkMTliNWIsIDB4MmUzYTI0MzYsIDB4NjdiMTBjMGEsIDB4ZTcwZjkzNTcsIDB4OTZkMmI0ZWUsIDB4OTE5ZTFiOWIsIDB4YzU0ZjgwYzAsIDB4MjBhMjYxZGMsIDB4NGI2OTVhNzcsIDB4MWExNjFjMTIsIDB4YmEwYWUyOTMsIDB4MmFlNWMwYTAsIDB4ZTA0MzNjMjIsIDB4MTcxZDEyMWIsIDB4MGQwYjBlMDksIDB4YzdhZGYyOGIsIDB4YThiOTJkYjYsIDB4YTljODE0MWUsIDB4MTk4NTU3ZjEsIDB4MDc0Y2FmNzUsIDB4ZGRiYmVlOTksIDB4NjBmZGEzN2YsIDB4MjY5ZmY3MDEsIDB4ZjViYzVjNzIsIDB4M2JjNTQ0NjYsIDB4N2UzNDViZmIsIDB4Mjk3NjhiNDMsIDB4YzZkY2NiMjMsIDB4ZmM2OGI2ZWQsIDB4ZjE2M2I4ZTQsIDB4ZGNjYWQ3MzEsIDB4ODUxMDQyNjMsIDB4MjI0MDEzOTcsIDB4MTEyMDg0YzYsIDB4MjQ3ZDg1NGEsIDB4M2RmOGQyYmIsIDB4MzIxMWFlZjksIDB4YTE2ZGM3MjksIDB4MmY0YjFkOWUsIDB4MzBmM2RjYjIsIDB4NTJlYzBkODYsIDB4ZTNkMDc3YzEsIDB4MTY2YzJiYjMsIDB4Yjk5OWE5NzAsIDB4NDhmYTExOTQsIDB4NjQyMjQ3ZTksIDB4OGNjNGE4ZmMsIDB4M2YxYWEwZjAsIDB4MmNkODU2N2QsIDB4OTBlZjIyMzMsIDB4NGVjNzg3NDksIDB4ZDFjMWQ5MzgsIDB4YTJmZThjY2EsIDB4MGIzNjk4ZDQsIDB4ODFjZmE2ZjUsIDB4ZGUyOGE1N2EsIDB4OGUyNmRhYjcsIDB4YmZhNDNmYWQsIDB4OWRlNDJjM2EsIDB4OTIwZDUwNzgsIDB4Y2M5YjZhNWYsIDB4NDY2MjU0N2UsIDB4MTNjMmY2OGQsIDB4YjhlODkwZDgsIDB4Zjc1ZTJlMzksIDB4YWZmNTgyYzMsIDB4ODBiZTlmNWQsIDB4OTM3YzY5ZDAsIDB4MmRhOTZmZDUsIDB4MTJiM2NmMjUsIDB4OTkzYmM4YWMsIDB4N2RhNzEwMTgsIDB4NjM2ZWU4OWMsIDB4YmI3YmRiM2IsIDB4NzgwOWNkMjYsIDB4MThmNDZlNTksIDB4YjcwMWVjOWEsIDB4OWFhODgzNGYsIDB4NmU2NWU2OTUsIDB4ZTY3ZWFhZmYsIDB4Y2YwODIxYmMsIDB4ZThlNmVmMTUsIDB4OWJkOWJhZTcsIDB4MzZjZTRhNmYsIDB4MDlkNGVhOWYsIDB4N2NkNjI5YjAsIDB4YjJhZjMxYTQsIDB4MjMzMTJhM2YsIDB4OTQzMGM2YTUsIDB4NjZjMDM1YTIsIDB4YmMzNzc0NGUsIDB4Y2FhNmZjODIsIDB4ZDBiMGUwOTAsIDB4ZDgxNTMzYTcsIDB4OTg0YWYxMDQsIDB4ZGFmNzQxZWMsIDB4NTAwZTdmY2QsIDB4ZjYyZjE3OTEsIDB4ZDY4ZDc2NGQsIDB4YjA0ZDQzZWYsIDB4NGQ1NGNjYWEsIDB4MDRkZmU0OTYsIDB4YjVlMzllZDEsIDB4ODgxYjRjNmEsIDB4MWZiOGMxMmMsIDB4NTE3ZjQ2NjUsIDB4ZWEwNDlkNWUsIDB4MzU1ZDAxOGMsIDB4NzQ3M2ZhODcsIDB4NDEyZWZiMGIsIDB4MWQ1YWIzNjcsIDB4ZDI1MjkyZGIsIDB4NTYzM2U5MTAsIDB4NDcxMzZkZDYsIDB4NjE4YzlhZDcsIDB4MGM3YTM3YTEsIDB4MTQ4ZTU5ZjgsIDB4M2M4OWViMTMsIDB4MjdlZWNlYTksIDB4YzkzNWI3NjEsIDB4ZTVlZGUxMWMsIDB4YjEzYzdhNDcsIDB4ZGY1OTljZDIsIDB4NzMzZjU1ZjIsIDB4Y2U3OTE4MTQsIDB4MzdiZjczYzcsIDB4Y2RlYTUzZjcsIDB4YWE1YjVmZmQsIDB4NmYxNGRmM2QsIDB4ZGI4Njc4NDQsIDB4ZjM4MWNhYWYsIDB4YzQzZWI5NjgsIDB4MzQyYzM4MjQsIDB4NDA1ZmMyYTMsIDB4YzM3MjE2MWQsIDB4MjUwY2JjZTIsIDB4NDk4YjI4M2MsIDB4OTU0MWZmMGQsIDB4MDE3MTM5YTgsIDB4YjNkZTA4MGMsIDB4ZTQ5Y2Q4YjQsIDB4YzE5MDY0NTYsIDB4ODQ2MTdiY2IsIDB4YjY3MGQ1MzIsIDB4NWM3NDQ4NmMsIDB4NTc0MmQwYjhdO1xuXHQgICAgdmFyIFQ4ID0gWzB4ZjRhNzUwNTEsIDB4NDE2NTUzN2UsIDB4MTdhNGMzMWEsIDB4Mjc1ZTk2M2EsIDB4YWI2YmNiM2IsIDB4OWQ0NWYxMWYsIDB4ZmE1OGFiYWMsIDB4ZTMwMzkzNGIsIDB4MzBmYTU1MjAsIDB4NzY2ZGY2YWQsIDB4Y2M3NjkxODgsIDB4MDI0YzI1ZjUsIDB4ZTVkN2ZjNGYsIDB4MmFjYmQ3YzUsIDB4MzU0NDgwMjYsIDB4NjJhMzhmYjUsIDB4YjE1YTQ5ZGUsIDB4YmExYjY3MjUsIDB4ZWEwZTk4NDUsIDB4ZmVjMGUxNWQsIDB4MmY3NTAyYzMsIDB4NGNmMDEyODEsIDB4NDY5N2EzOGQsIDB4ZDNmOWM2NmIsIDB4OGY1ZmU3MDMsIDB4OTI5Yzk1MTUsIDB4NmQ3YWViYmYsIDB4NTI1OWRhOTUsIDB4YmU4MzJkZDQsIDB4NzQyMWQzNTgsIDB4ZTA2OTI5NDksIDB4YzljODQ0OGUsIDB4YzI4OTZhNzUsIDB4OGU3OTc4ZjQsIDB4NTgzZTZiOTksIDB4Yjk3MWRkMjcsIDB4ZTE0ZmI2YmUsIDB4ODhhZDE3ZjAsIDB4MjBhYzY2YzksIDB4Y2UzYWI0N2QsIDB4ZGY0YTE4NjMsIDB4MWEzMTgyZTUsIDB4NTEzMzYwOTcsIDB4NTM3ZjQ1NjIsIDB4NjQ3N2UwYjEsIDB4NmJhZTg0YmIsIDB4ODFhMDFjZmUsIDB4MDgyYjk0ZjksIDB4NDg2ODU4NzAsIDB4NDVmZDE5OGYsIDB4ZGU2Yzg3OTQsIDB4N2JmOGI3NTIsIDB4NzNkMzIzYWIsIDB4NGIwMmUyNzIsIDB4MWY4ZjU3ZTMsIDB4NTVhYjJhNjYsIDB4ZWIyODA3YjIsIDB4YjVjMjAzMmYsIDB4YzU3YjlhODYsIDB4MzcwOGE1ZDMsIDB4Mjg4N2YyMzAsIDB4YmZhNWIyMjMsIDB4MDM2YWJhMDIsIDB4MTY4MjVjZWQsIDB4Y2YxYzJiOGEsIDB4NzliNDkyYTcsIDB4MDdmMmYwZjMsIDB4NjllMmExNGUsIDB4ZGFmNGNkNjUsIDB4MDViZWQ1MDYsIDB4MzQ2MjFmZDEsIDB4YTZmZThhYzQsIDB4MmU1MzlkMzQsIDB4ZjM1NWEwYTIsIDB4OGFlMTMyMDUsIDB4ZjZlYjc1YTQsIDB4ODNlYzM5MGIsIDB4NjBlZmFhNDAsIDB4NzE5ZjA2NWUsIDB4NmUxMDUxYmQsIDB4MjE4YWY5M2UsIDB4ZGQwNjNkOTYsIDB4M2UwNWFlZGQsIDB4ZTZiZDQ2NGQsIDB4NTQ4ZGI1OTEsIDB4YzQ1ZDA1NzEsIDB4MDZkNDZmMDQsIDB4NTAxNWZmNjAsIDB4OThmYjI0MTksIDB4YmRlOTk3ZDYsIDB4NDA0M2NjODksIDB4ZDk5ZTc3NjcsIDB4ZTg0MmJkYjAsIDB4ODk4Yjg4MDcsIDB4MTk1YjM4ZTcsIDB4YzhlZWRiNzksIDB4N2MwYTQ3YTEsIDB4NDIwZmU5N2MsIDB4ODQxZWM5ZjgsIDB4MDAwMDAwMDAsIDB4ODA4NjgzMDksIDB4MmJlZDQ4MzIsIDB4MTE3MGFjMWUsIDB4NWE3MjRlNmMsIDB4MGVmZmZiZmQsIDB4ODUzODU2MGYsIDB4YWVkNTFlM2QsIDB4MmQzOTI3MzYsIDB4MGZkOTY0MGEsIDB4NWNhNjIxNjgsIDB4NWI1NGQxOWIsIDB4MzYyZTNhMjQsIDB4MGE2N2IxMGMsIDB4NTdlNzBmOTMsIDB4ZWU5NmQyYjQsIDB4OWI5MTllMWIsIDB4YzBjNTRmODAsIDB4ZGMyMGEyNjEsIDB4Nzc0YjY5NWEsIDB4MTIxYTE2MWMsIDB4OTNiYTBhZTIsIDB4YTAyYWU1YzAsIDB4MjJlMDQzM2MsIDB4MWIxNzFkMTIsIDB4MDkwZDBiMGUsIDB4OGJjN2FkZjIsIDB4YjZhOGI5MmQsIDB4MWVhOWM4MTQsIDB4ZjExOTg1NTcsIDB4NzUwNzRjYWYsIDB4OTlkZGJiZWUsIDB4N2Y2MGZkYTMsIDB4MDEyNjlmZjcsIDB4NzJmNWJjNWMsIDB4NjYzYmM1NDQsIDB4ZmI3ZTM0NWIsIDB4NDMyOTc2OGIsIDB4MjNjNmRjY2IsIDB4ZWRmYzY4YjYsIDB4ZTRmMTYzYjgsIDB4MzFkY2NhZDcsIDB4NjM4NTEwNDIsIDB4OTcyMjQwMTMsIDB4YzYxMTIwODQsIDB4NGEyNDdkODUsIDB4YmIzZGY4ZDIsIDB4ZjkzMjExYWUsIDB4MjlhMTZkYzcsIDB4OWUyZjRiMWQsIDB4YjIzMGYzZGMsIDB4ODY1MmVjMGQsIDB4YzFlM2QwNzcsIDB4YjMxNjZjMmIsIDB4NzBiOTk5YTksIDB4OTQ0OGZhMTEsIDB4ZTk2NDIyNDcsIDB4ZmM4Y2M0YTgsIDB4ZjAzZjFhYTAsIDB4N2QyY2Q4NTYsIDB4MzM5MGVmMjIsIDB4NDk0ZWM3ODcsIDB4MzhkMWMxZDksIDB4Y2FhMmZlOGMsIDB4ZDQwYjM2OTgsIDB4ZjU4MWNmYTYsIDB4N2FkZTI4YTUsIDB4Yjc4ZTI2ZGEsIDB4YWRiZmE0M2YsIDB4M2E5ZGU0MmMsIDB4Nzg5MjBkNTAsIDB4NWZjYzliNmEsIDB4N2U0NjYyNTQsIDB4OGQxM2MyZjYsIDB4ZDhiOGU4OTAsIDB4MzlmNzVlMmUsIDB4YzNhZmY1ODIsIDB4NWQ4MGJlOWYsIDB4ZDA5MzdjNjksIDB4ZDUyZGE5NmYsIDB4MjUxMmIzY2YsIDB4YWM5OTNiYzgsIDB4MTg3ZGE3MTAsIDB4OWM2MzZlZTgsIDB4M2JiYjdiZGIsIDB4MjY3ODA5Y2QsIDB4NTkxOGY0NmUsIDB4OWFiNzAxZWMsIDB4NGY5YWE4ODMsIDB4OTU2ZTY1ZTYsIDB4ZmZlNjdlYWEsIDB4YmNjZjA4MjEsIDB4MTVlOGU2ZWYsIDB4ZTc5YmQ5YmEsIDB4NmYzNmNlNGEsIDB4OWYwOWQ0ZWEsIDB4YjA3Y2Q2MjksIDB4YTRiMmFmMzEsIDB4M2YyMzMxMmEsIDB4YTU5NDMwYzYsIDB4YTI2NmMwMzUsIDB4NGViYzM3NzQsIDB4ODJjYWE2ZmMsIDB4OTBkMGIwZTAsIDB4YTdkODE1MzMsIDB4MDQ5ODRhZjEsIDB4ZWNkYWY3NDEsIDB4Y2Q1MDBlN2YsIDB4OTFmNjJmMTcsIDB4NGRkNjhkNzYsIDB4ZWZiMDRkNDMsIDB4YWE0ZDU0Y2MsIDB4OTYwNGRmZTQsIDB4ZDFiNWUzOWUsIDB4NmE4ODFiNGMsIDB4MmMxZmI4YzEsIDB4NjU1MTdmNDYsIDB4NWVlYTA0OWQsIDB4OGMzNTVkMDEsIDB4ODc3NDczZmEsIDB4MGI0MTJlZmIsIDB4NjcxZDVhYjMsIDB4ZGJkMjUyOTIsIDB4MTA1NjMzZTksIDB4ZDY0NzEzNmQsIDB4ZDc2MThjOWEsIDB4YTEwYzdhMzcsIDB4ZjgxNDhlNTksIDB4MTMzYzg5ZWIsIDB4YTkyN2VlY2UsIDB4NjFjOTM1YjcsIDB4MWNlNWVkZTEsIDB4NDdiMTNjN2EsIDB4ZDJkZjU5OWMsIDB4ZjI3MzNmNTUsIDB4MTRjZTc5MTgsIDB4YzczN2JmNzMsIDB4ZjdjZGVhNTMsIDB4ZmRhYTViNWYsIDB4M2Q2ZjE0ZGYsIDB4NDRkYjg2NzgsIDB4YWZmMzgxY2EsIDB4NjhjNDNlYjksIDB4MjQzNDJjMzgsIDB4YTM0MDVmYzIsIDB4MWRjMzcyMTYsIDB4ZTIyNTBjYmMsIDB4M2M0OThiMjgsIDB4MGQ5NTQxZmYsIDB4YTgwMTcxMzksIDB4MGNiM2RlMDgsIDB4YjRlNDljZDgsIDB4NTZjMTkwNjQsIDB4Y2I4NDYxN2IsIDB4MzJiNjcwZDUsIDB4NmM1Yzc0NDgsIDB4Yjg1NzQyZDBdO1xuXG5cdCAgICAvLyBUcmFuc2Zvcm1hdGlvbnMgZm9yIGRlY3J5cHRpb24ga2V5IGV4cGFuc2lvblxuXHQgICAgdmFyIFUxID0gWzB4MDAwMDAwMDAsIDB4MGUwOTBkMGIsIDB4MWMxMjFhMTYsIDB4MTIxYjE3MWQsIDB4MzgyNDM0MmMsIDB4MzYyZDM5MjcsIDB4MjQzNjJlM2EsIDB4MmEzZjIzMzEsIDB4NzA0ODY4NTgsIDB4N2U0MTY1NTMsIDB4NmM1YTcyNGUsIDB4NjI1MzdmNDUsIDB4NDg2YzVjNzQsIDB4NDY2NTUxN2YsIDB4NTQ3ZTQ2NjIsIDB4NWE3NzRiNjksIDB4ZTA5MGQwYjAsIDB4ZWU5OWRkYmIsIDB4ZmM4MmNhYTYsIDB4ZjI4YmM3YWQsIDB4ZDhiNGU0OWMsIDB4ZDZiZGU5OTcsIDB4YzRhNmZlOGEsIDB4Y2FhZmYzODEsIDB4OTBkOGI4ZTgsIDB4OWVkMWI1ZTMsIDB4OGNjYWEyZmUsIDB4ODJjM2FmZjUsIDB4YThmYzhjYzQsIDB4YTZmNTgxY2YsIDB4YjRlZTk2ZDIsIDB4YmFlNzliZDksIDB4ZGIzYmJiN2IsIDB4ZDUzMmI2NzAsIDB4YzcyOWExNmQsIDB4YzkyMGFjNjYsIDB4ZTMxZjhmNTcsIDB4ZWQxNjgyNWMsIDB4ZmYwZDk1NDEsIDB4ZjEwNDk4NGEsIDB4YWI3M2QzMjMsIDB4YTU3YWRlMjgsIDB4Yjc2MWM5MzUsIDB4Yjk2OGM0M2UsIDB4OTM1N2U3MGYsIDB4OWQ1ZWVhMDQsIDB4OGY0NWZkMTksIDB4ODE0Y2YwMTIsIDB4M2JhYjZiY2IsIDB4MzVhMjY2YzAsIDB4MjdiOTcxZGQsIDB4MjliMDdjZDYsIDB4MDM4ZjVmZTcsIDB4MGQ4NjUyZWMsIDB4MWY5ZDQ1ZjEsIDB4MTE5NDQ4ZmEsIDB4NGJlMzAzOTMsIDB4NDVlYTBlOTgsIDB4NTdmMTE5ODUsIDB4NTlmODE0OGUsIDB4NzNjNzM3YmYsIDB4N2RjZTNhYjQsIDB4NmZkNTJkYTksIDB4NjFkYzIwYTIsIDB4YWQ3NjZkZjYsIDB4YTM3ZjYwZmQsIDB4YjE2NDc3ZTAsIDB4YmY2ZDdhZWIsIDB4OTU1MjU5ZGEsIDB4OWI1YjU0ZDEsIDB4ODk0MDQzY2MsIDB4ODc0OTRlYzcsIDB4ZGQzZTA1YWUsIDB4ZDMzNzA4YTUsIDB4YzEyYzFmYjgsIDB4Y2YyNTEyYjMsIDB4ZTUxYTMxODIsIDB4ZWIxMzNjODksIDB4ZjkwODJiOTQsIDB4ZjcwMTI2OWYsIDB4NGRlNmJkNDYsIDB4NDNlZmIwNGQsIDB4NTFmNGE3NTAsIDB4NWZmZGFhNWIsIDB4NzVjMjg5NmEsIDB4N2JjYjg0NjEsIDB4NjlkMDkzN2MsIDB4NjdkOTllNzcsIDB4M2RhZWQ1MWUsIDB4MzNhN2Q4MTUsIDB4MjFiY2NmMDgsIDB4MmZiNWMyMDMsIDB4MDU4YWUxMzIsIDB4MGI4M2VjMzksIDB4MTk5OGZiMjQsIDB4MTc5MWY2MmYsIDB4NzY0ZGQ2OGQsIDB4Nzg0NGRiODYsIDB4NmE1ZmNjOWIsIDB4NjQ1NmMxOTAsIDB4NGU2OWUyYTEsIDB4NDA2MGVmYWEsIDB4NTI3YmY4YjcsIDB4NWM3MmY1YmMsIDB4MDYwNWJlZDUsIDB4MDgwY2IzZGUsIDB4MWExN2E0YzMsIDB4MTQxZWE5YzgsIDB4M2UyMThhZjksIDB4MzAyODg3ZjIsIDB4MjIzMzkwZWYsIDB4MmMzYTlkZTQsIDB4OTZkZDA2M2QsIDB4OThkNDBiMzYsIDB4OGFjZjFjMmIsIDB4ODRjNjExMjAsIDB4YWVmOTMyMTEsIDB4YTBmMDNmMWEsIDB4YjJlYjI4MDcsIDB4YmNlMjI1MGMsIDB4ZTY5NTZlNjUsIDB4ZTg5YzYzNmUsIDB4ZmE4Nzc0NzMsIDB4ZjQ4ZTc5NzgsIDB4ZGViMTVhNDksIDB4ZDBiODU3NDIsIDB4YzJhMzQwNWYsIDB4Y2NhYTRkNTQsIDB4NDFlY2RhZjcsIDB4NGZlNWQ3ZmMsIDB4NWRmZWMwZTEsIDB4NTNmN2NkZWEsIDB4NzljOGVlZGIsIDB4NzdjMWUzZDAsIDB4NjVkYWY0Y2QsIDB4NmJkM2Y5YzYsIDB4MzFhNGIyYWYsIDB4M2ZhZGJmYTQsIDB4MmRiNmE4YjksIDB4MjNiZmE1YjIsIDB4MDk4MDg2ODMsIDB4MDc4OThiODgsIDB4MTU5MjljOTUsIDB4MWI5YjkxOWUsIDB4YTE3YzBhNDcsIDB4YWY3NTA3NGMsIDB4YmQ2ZTEwNTEsIDB4YjM2NzFkNWEsIDB4OTk1ODNlNmIsIDB4OTc1MTMzNjAsIDB4ODU0YTI0N2QsIDB4OGI0MzI5NzYsIDB4ZDEzNDYyMWYsIDB4ZGYzZDZmMTQsIDB4Y2QyNjc4MDksIDB4YzMyZjc1MDIsIDB4ZTkxMDU2MzMsIDB4ZTcxOTViMzgsIDB4ZjUwMjRjMjUsIDB4ZmIwYjQxMmUsIDB4OWFkNzYxOGMsIDB4OTRkZTZjODcsIDB4ODZjNTdiOWEsIDB4ODhjYzc2OTEsIDB4YTJmMzU1YTAsIDB4YWNmYTU4YWIsIDB4YmVlMTRmYjYsIDB4YjBlODQyYmQsIDB4ZWE5ZjA5ZDQsIDB4ZTQ5NjA0ZGYsIDB4ZjY4ZDEzYzIsIDB4Zjg4NDFlYzksIDB4ZDJiYjNkZjgsIDB4ZGNiMjMwZjMsIDB4Y2VhOTI3ZWUsIDB4YzBhMDJhZTUsIDB4N2E0N2IxM2MsIDB4NzQ0ZWJjMzcsIDB4NjY1NWFiMmEsIDB4Njg1Y2E2MjEsIDB4NDI2Mzg1MTAsIDB4NGM2YTg4MWIsIDB4NWU3MTlmMDYsIDB4NTA3ODkyMGQsIDB4MGEwZmQ5NjQsIDB4MDQwNmQ0NmYsIDB4MTYxZGMzNzIsIDB4MTgxNGNlNzksIDB4MzIyYmVkNDgsIDB4M2MyMmUwNDMsIDB4MmUzOWY3NWUsIDB4MjAzMGZhNTUsIDB4ZWM5YWI3MDEsIDB4ZTI5M2JhMGEsIDB4ZjA4OGFkMTcsIDB4ZmU4MWEwMWMsIDB4ZDRiZTgzMmQsIDB4ZGFiNzhlMjYsIDB4YzhhYzk5M2IsIDB4YzZhNTk0MzAsIDB4OWNkMmRmNTksIDB4OTJkYmQyNTIsIDB4ODBjMGM1NGYsIDB4OGVjOWM4NDQsIDB4YTRmNmViNzUsIDB4YWFmZmU2N2UsIDB4YjhlNGYxNjMsIDB4YjZlZGZjNjgsIDB4MGMwYTY3YjEsIDB4MDIwMzZhYmEsIDB4MTAxODdkYTcsIDB4MWUxMTcwYWMsIDB4MzQyZTUzOWQsIDB4M2EyNzVlOTYsIDB4MjgzYzQ5OGIsIDB4MjYzNTQ0ODAsIDB4N2M0MjBmZTksIDB4NzI0YjAyZTIsIDB4NjA1MDE1ZmYsIDB4NmU1OTE4ZjQsIDB4NDQ2NjNiYzUsIDB4NGE2ZjM2Y2UsIDB4NTg3NDIxZDMsIDB4NTY3ZDJjZDgsIDB4MzdhMTBjN2EsIDB4MzlhODAxNzEsIDB4MmJiMzE2NmMsIDB4MjViYTFiNjcsIDB4MGY4NTM4NTYsIDB4MDE4YzM1NWQsIDB4MTM5NzIyNDAsIDB4MWQ5ZTJmNGIsIDB4NDdlOTY0MjIsIDB4NDllMDY5MjksIDB4NWJmYjdlMzQsIDB4NTVmMjczM2YsIDB4N2ZjZDUwMGUsIDB4NzFjNDVkMDUsIDB4NjNkZjRhMTgsIDB4NmRkNjQ3MTMsIDB4ZDczMWRjY2EsIDB4ZDkzOGQxYzEsIDB4Y2IyM2M2ZGMsIDB4YzUyYWNiZDcsIDB4ZWYxNWU4ZTYsIDB4ZTExY2U1ZWQsIDB4ZjMwN2YyZjAsIDB4ZmQwZWZmZmIsIDB4YTc3OWI0OTIsIDB4YTk3MGI5OTksIDB4YmI2YmFlODQsIDB4YjU2MmEzOGYsIDB4OWY1ZDgwYmUsIDB4OTE1NDhkYjUsIDB4ODM0ZjlhYTgsIDB4OGQ0Njk3YTNdO1xuXHQgICAgdmFyIFUyID0gWzB4MDAwMDAwMDAsIDB4MGIwZTA5MGQsIDB4MTYxYzEyMWEsIDB4MWQxMjFiMTcsIDB4MmMzODI0MzQsIDB4MjczNjJkMzksIDB4M2EyNDM2MmUsIDB4MzEyYTNmMjMsIDB4NTg3MDQ4NjgsIDB4NTM3ZTQxNjUsIDB4NGU2YzVhNzIsIDB4NDU2MjUzN2YsIDB4NzQ0ODZjNWMsIDB4N2Y0NjY1NTEsIDB4NjI1NDdlNDYsIDB4Njk1YTc3NGIsIDB4YjBlMDkwZDAsIDB4YmJlZTk5ZGQsIDB4YTZmYzgyY2EsIDB4YWRmMjhiYzcsIDB4OWNkOGI0ZTQsIDB4OTdkNmJkZTksIDB4OGFjNGE2ZmUsIDB4ODFjYWFmZjMsIDB4ZTg5MGQ4YjgsIDB4ZTM5ZWQxYjUsIDB4ZmU4Y2NhYTIsIDB4ZjU4MmMzYWYsIDB4YzRhOGZjOGMsIDB4Y2ZhNmY1ODEsIDB4ZDJiNGVlOTYsIDB4ZDliYWU3OWIsIDB4N2JkYjNiYmIsIDB4NzBkNTMyYjYsIDB4NmRjNzI5YTEsIDB4NjZjOTIwYWMsIDB4NTdlMzFmOGYsIDB4NWNlZDE2ODIsIDB4NDFmZjBkOTUsIDB4NGFmMTA0OTgsIDB4MjNhYjczZDMsIDB4MjhhNTdhZGUsIDB4MzViNzYxYzksIDB4M2ViOTY4YzQsIDB4MGY5MzU3ZTcsIDB4MDQ5ZDVlZWEsIDB4MTk4ZjQ1ZmQsIDB4MTI4MTRjZjAsIDB4Y2IzYmFiNmIsIDB4YzAzNWEyNjYsIDB4ZGQyN2I5NzEsIDB4ZDYyOWIwN2MsIDB4ZTcwMzhmNWYsIDB4ZWMwZDg2NTIsIDB4ZjExZjlkNDUsIDB4ZmExMTk0NDgsIDB4OTM0YmUzMDMsIDB4OTg0NWVhMGUsIDB4ODU1N2YxMTksIDB4OGU1OWY4MTQsIDB4YmY3M2M3MzcsIDB4YjQ3ZGNlM2EsIDB4YTk2ZmQ1MmQsIDB4YTI2MWRjMjAsIDB4ZjZhZDc2NmQsIDB4ZmRhMzdmNjAsIDB4ZTBiMTY0NzcsIDB4ZWJiZjZkN2EsIDB4ZGE5NTUyNTksIDB4ZDE5YjViNTQsIDB4Y2M4OTQwNDMsIDB4Yzc4NzQ5NGUsIDB4YWVkZDNlMDUsIDB4YTVkMzM3MDgsIDB4YjhjMTJjMWYsIDB4YjNjZjI1MTIsIDB4ODJlNTFhMzEsIDB4ODllYjEzM2MsIDB4OTRmOTA4MmIsIDB4OWZmNzAxMjYsIDB4NDY0ZGU2YmQsIDB4NGQ0M2VmYjAsIDB4NTA1MWY0YTcsIDB4NWI1ZmZkYWEsIDB4NmE3NWMyODksIDB4NjE3YmNiODQsIDB4N2M2OWQwOTMsIDB4Nzc2N2Q5OWUsIDB4MWUzZGFlZDUsIDB4MTUzM2E3ZDgsIDB4MDgyMWJjY2YsIDB4MDMyZmI1YzIsIDB4MzIwNThhZTEsIDB4MzkwYjgzZWMsIDB4MjQxOTk4ZmIsIDB4MmYxNzkxZjYsIDB4OGQ3NjRkZDYsIDB4ODY3ODQ0ZGIsIDB4OWI2YTVmY2MsIDB4OTA2NDU2YzEsIDB4YTE0ZTY5ZTIsIDB4YWE0MDYwZWYsIDB4Yjc1MjdiZjgsIDB4YmM1YzcyZjUsIDB4ZDUwNjA1YmUsIDB4ZGUwODBjYjMsIDB4YzMxYTE3YTQsIDB4YzgxNDFlYTksIDB4ZjkzZTIxOGEsIDB4ZjIzMDI4ODcsIDB4ZWYyMjMzOTAsIDB4ZTQyYzNhOWQsIDB4M2Q5NmRkMDYsIDB4MzY5OGQ0MGIsIDB4MmI4YWNmMWMsIDB4MjA4NGM2MTEsIDB4MTFhZWY5MzIsIDB4MWFhMGYwM2YsIDB4MDdiMmViMjgsIDB4MGNiY2UyMjUsIDB4NjVlNjk1NmUsIDB4NmVlODljNjMsIDB4NzNmYTg3NzQsIDB4NzhmNDhlNzksIDB4NDlkZWIxNWEsIDB4NDJkMGI4NTcsIDB4NWZjMmEzNDAsIDB4NTRjY2FhNGQsIDB4Zjc0MWVjZGEsIDB4ZmM0ZmU1ZDcsIDB4ZTE1ZGZlYzAsIDB4ZWE1M2Y3Y2QsIDB4ZGI3OWM4ZWUsIDB4ZDA3N2MxZTMsIDB4Y2Q2NWRhZjQsIDB4YzY2YmQzZjksIDB4YWYzMWE0YjIsIDB4YTQzZmFkYmYsIDB4YjkyZGI2YTgsIDB4YjIyM2JmYTUsIDB4ODMwOTgwODYsIDB4ODgwNzg5OGIsIDB4OTUxNTkyOWMsIDB4OWUxYjliOTEsIDB4NDdhMTdjMGEsIDB4NGNhZjc1MDcsIDB4NTFiZDZlMTAsIDB4NWFiMzY3MWQsIDB4NmI5OTU4M2UsIDB4NjA5NzUxMzMsIDB4N2Q4NTRhMjQsIDB4NzY4YjQzMjksIDB4MWZkMTM0NjIsIDB4MTRkZjNkNmYsIDB4MDljZDI2NzgsIDB4MDJjMzJmNzUsIDB4MzNlOTEwNTYsIDB4MzhlNzE5NWIsIDB4MjVmNTAyNGMsIDB4MmVmYjBiNDEsIDB4OGM5YWQ3NjEsIDB4ODc5NGRlNmMsIDB4OWE4NmM1N2IsIDB4OTE4OGNjNzYsIDB4YTBhMmYzNTUsIDB4YWJhY2ZhNTgsIDB4YjZiZWUxNGYsIDB4YmRiMGU4NDIsIDB4ZDRlYTlmMDksIDB4ZGZlNDk2MDQsIDB4YzJmNjhkMTMsIDB4YzlmODg0MWUsIDB4ZjhkMmJiM2QsIDB4ZjNkY2IyMzAsIDB4ZWVjZWE5MjcsIDB4ZTVjMGEwMmEsIDB4M2M3YTQ3YjEsIDB4Mzc3NDRlYmMsIDB4MmE2NjU1YWIsIDB4MjE2ODVjYTYsIDB4MTA0MjYzODUsIDB4MWI0YzZhODgsIDB4MDY1ZTcxOWYsIDB4MGQ1MDc4OTIsIDB4NjQwYTBmZDksIDB4NmYwNDA2ZDQsIDB4NzIxNjFkYzMsIDB4NzkxODE0Y2UsIDB4NDgzMjJiZWQsIDB4NDMzYzIyZTAsIDB4NWUyZTM5ZjcsIDB4NTUyMDMwZmEsIDB4MDFlYzlhYjcsIDB4MGFlMjkzYmEsIDB4MTdmMDg4YWQsIDB4MWNmZTgxYTAsIDB4MmRkNGJlODMsIDB4MjZkYWI3OGUsIDB4M2JjOGFjOTksIDB4MzBjNmE1OTQsIDB4NTk5Y2QyZGYsIDB4NTI5MmRiZDIsIDB4NGY4MGMwYzUsIDB4NDQ4ZWM5YzgsIDB4NzVhNGY2ZWIsIDB4N2VhYWZmZTYsIDB4NjNiOGU0ZjEsIDB4NjhiNmVkZmMsIDB4YjEwYzBhNjcsIDB4YmEwMjAzNmEsIDB4YTcxMDE4N2QsIDB4YWMxZTExNzAsIDB4OWQzNDJlNTMsIDB4OTYzYTI3NWUsIDB4OGIyODNjNDksIDB4ODAyNjM1NDQsIDB4ZTk3YzQyMGYsIDB4ZTI3MjRiMDIsIDB4ZmY2MDUwMTUsIDB4ZjQ2ZTU5MTgsIDB4YzU0NDY2M2IsIDB4Y2U0YTZmMzYsIDB4ZDM1ODc0MjEsIDB4ZDg1NjdkMmMsIDB4N2EzN2ExMGMsIDB4NzEzOWE4MDEsIDB4NmMyYmIzMTYsIDB4NjcyNWJhMWIsIDB4NTYwZjg1MzgsIDB4NWQwMThjMzUsIDB4NDAxMzk3MjIsIDB4NGIxZDllMmYsIDB4MjI0N2U5NjQsIDB4Mjk0OWUwNjksIDB4MzQ1YmZiN2UsIDB4M2Y1NWYyNzMsIDB4MGU3ZmNkNTAsIDB4MDU3MWM0NWQsIDB4MTg2M2RmNGEsIDB4MTM2ZGQ2NDcsIDB4Y2FkNzMxZGMsIDB4YzFkOTM4ZDEsIDB4ZGNjYjIzYzYsIDB4ZDdjNTJhY2IsIDB4ZTZlZjE1ZTgsIDB4ZWRlMTFjZTUsIDB4ZjBmMzA3ZjIsIDB4ZmJmZDBlZmYsIDB4OTJhNzc5YjQsIDB4OTlhOTcwYjksIDB4ODRiYjZiYWUsIDB4OGZiNTYyYTMsIDB4YmU5ZjVkODAsIDB4YjU5MTU0OGQsIDB4YTg4MzRmOWEsIDB4YTM4ZDQ2OTddO1xuXHQgICAgdmFyIFUzID0gWzB4MDAwMDAwMDAsIDB4MGQwYjBlMDksIDB4MWExNjFjMTIsIDB4MTcxZDEyMWIsIDB4MzQyYzM4MjQsIDB4MzkyNzM2MmQsIDB4MmUzYTI0MzYsIDB4MjMzMTJhM2YsIDB4Njg1ODcwNDgsIDB4NjU1MzdlNDEsIDB4NzI0ZTZjNWEsIDB4N2Y0NTYyNTMsIDB4NWM3NDQ4NmMsIDB4NTE3ZjQ2NjUsIDB4NDY2MjU0N2UsIDB4NGI2OTVhNzcsIDB4ZDBiMGUwOTAsIDB4ZGRiYmVlOTksIDB4Y2FhNmZjODIsIDB4YzdhZGYyOGIsIDB4ZTQ5Y2Q4YjQsIDB4ZTk5N2Q2YmQsIDB4ZmU4YWM0YTYsIDB4ZjM4MWNhYWYsIDB4YjhlODkwZDgsIDB4YjVlMzllZDEsIDB4YTJmZThjY2EsIDB4YWZmNTgyYzMsIDB4OGNjNGE4ZmMsIDB4ODFjZmE2ZjUsIDB4OTZkMmI0ZWUsIDB4OWJkOWJhZTcsIDB4YmI3YmRiM2IsIDB4YjY3MGQ1MzIsIDB4YTE2ZGM3MjksIDB4YWM2NmM5MjAsIDB4OGY1N2UzMWYsIDB4ODI1Y2VkMTYsIDB4OTU0MWZmMGQsIDB4OTg0YWYxMDQsIDB4ZDMyM2FiNzMsIDB4ZGUyOGE1N2EsIDB4YzkzNWI3NjEsIDB4YzQzZWI5NjgsIDB4ZTcwZjkzNTcsIDB4ZWEwNDlkNWUsIDB4ZmQxOThmNDUsIDB4ZjAxMjgxNGMsIDB4NmJjYjNiYWIsIDB4NjZjMDM1YTIsIDB4NzFkZDI3YjksIDB4N2NkNjI5YjAsIDB4NWZlNzAzOGYsIDB4NTJlYzBkODYsIDB4NDVmMTFmOWQsIDB4NDhmYTExOTQsIDB4MDM5MzRiZTMsIDB4MGU5ODQ1ZWEsIDB4MTk4NTU3ZjEsIDB4MTQ4ZTU5ZjgsIDB4MzdiZjczYzcsIDB4M2FiNDdkY2UsIDB4MmRhOTZmZDUsIDB4MjBhMjYxZGMsIDB4NmRmNmFkNzYsIDB4NjBmZGEzN2YsIDB4NzdlMGIxNjQsIDB4N2FlYmJmNmQsIDB4NTlkYTk1NTIsIDB4NTRkMTliNWIsIDB4NDNjYzg5NDAsIDB4NGVjNzg3NDksIDB4MDVhZWRkM2UsIDB4MDhhNWQzMzcsIDB4MWZiOGMxMmMsIDB4MTJiM2NmMjUsIDB4MzE4MmU1MWEsIDB4M2M4OWViMTMsIDB4MmI5NGY5MDgsIDB4MjY5ZmY3MDEsIDB4YmQ0NjRkZTYsIDB4YjA0ZDQzZWYsIDB4YTc1MDUxZjQsIDB4YWE1YjVmZmQsIDB4ODk2YTc1YzIsIDB4ODQ2MTdiY2IsIDB4OTM3YzY5ZDAsIDB4OWU3NzY3ZDksIDB4ZDUxZTNkYWUsIDB4ZDgxNTMzYTcsIDB4Y2YwODIxYmMsIDB4YzIwMzJmYjUsIDB4ZTEzMjA1OGEsIDB4ZWMzOTBiODMsIDB4ZmIyNDE5OTgsIDB4ZjYyZjE3OTEsIDB4ZDY4ZDc2NGQsIDB4ZGI4Njc4NDQsIDB4Y2M5YjZhNWYsIDB4YzE5MDY0NTYsIDB4ZTJhMTRlNjksIDB4ZWZhYTQwNjAsIDB4ZjhiNzUyN2IsIDB4ZjViYzVjNzIsIDB4YmVkNTA2MDUsIDB4YjNkZTA4MGMsIDB4YTRjMzFhMTcsIDB4YTljODE0MWUsIDB4OGFmOTNlMjEsIDB4ODdmMjMwMjgsIDB4OTBlZjIyMzMsIDB4OWRlNDJjM2EsIDB4MDYzZDk2ZGQsIDB4MGIzNjk4ZDQsIDB4MWMyYjhhY2YsIDB4MTEyMDg0YzYsIDB4MzIxMWFlZjksIDB4M2YxYWEwZjAsIDB4MjgwN2IyZWIsIDB4MjUwY2JjZTIsIDB4NmU2NWU2OTUsIDB4NjM2ZWU4OWMsIDB4NzQ3M2ZhODcsIDB4Nzk3OGY0OGUsIDB4NWE0OWRlYjEsIDB4NTc0MmQwYjgsIDB4NDA1ZmMyYTMsIDB4NGQ1NGNjYWEsIDB4ZGFmNzQxZWMsIDB4ZDdmYzRmZTUsIDB4YzBlMTVkZmUsIDB4Y2RlYTUzZjcsIDB4ZWVkYjc5YzgsIDB4ZTNkMDc3YzEsIDB4ZjRjZDY1ZGEsIDB4ZjljNjZiZDMsIDB4YjJhZjMxYTQsIDB4YmZhNDNmYWQsIDB4YThiOTJkYjYsIDB4YTViMjIzYmYsIDB4ODY4MzA5ODAsIDB4OGI4ODA3ODksIDB4OWM5NTE1OTIsIDB4OTE5ZTFiOWIsIDB4MGE0N2ExN2MsIDB4MDc0Y2FmNzUsIDB4MTA1MWJkNmUsIDB4MWQ1YWIzNjcsIDB4M2U2Yjk5NTgsIDB4MzM2MDk3NTEsIDB4MjQ3ZDg1NGEsIDB4Mjk3NjhiNDMsIDB4NjIxZmQxMzQsIDB4NmYxNGRmM2QsIDB4NzgwOWNkMjYsIDB4NzUwMmMzMmYsIDB4NTYzM2U5MTAsIDB4NWIzOGU3MTksIDB4NGMyNWY1MDIsIDB4NDEyZWZiMGIsIDB4NjE4YzlhZDcsIDB4NmM4Nzk0ZGUsIDB4N2I5YTg2YzUsIDB4NzY5MTg4Y2MsIDB4NTVhMGEyZjMsIDB4NThhYmFjZmEsIDB4NGZiNmJlZTEsIDB4NDJiZGIwZTgsIDB4MDlkNGVhOWYsIDB4MDRkZmU0OTYsIDB4MTNjMmY2OGQsIDB4MWVjOWY4ODQsIDB4M2RmOGQyYmIsIDB4MzBmM2RjYjIsIDB4MjdlZWNlYTksIDB4MmFlNWMwYTAsIDB4YjEzYzdhNDcsIDB4YmMzNzc0NGUsIDB4YWIyYTY2NTUsIDB4YTYyMTY4NWMsIDB4ODUxMDQyNjMsIDB4ODgxYjRjNmEsIDB4OWYwNjVlNzEsIDB4OTIwZDUwNzgsIDB4ZDk2NDBhMGYsIDB4ZDQ2ZjA0MDYsIDB4YzM3MjE2MWQsIDB4Y2U3OTE4MTQsIDB4ZWQ0ODMyMmIsIDB4ZTA0MzNjMjIsIDB4Zjc1ZTJlMzksIDB4ZmE1NTIwMzAsIDB4YjcwMWVjOWEsIDB4YmEwYWUyOTMsIDB4YWQxN2YwODgsIDB4YTAxY2ZlODEsIDB4ODMyZGQ0YmUsIDB4OGUyNmRhYjcsIDB4OTkzYmM4YWMsIDB4OTQzMGM2YTUsIDB4ZGY1OTljZDIsIDB4ZDI1MjkyZGIsIDB4YzU0ZjgwYzAsIDB4Yzg0NDhlYzksIDB4ZWI3NWE0ZjYsIDB4ZTY3ZWFhZmYsIDB4ZjE2M2I4ZTQsIDB4ZmM2OGI2ZWQsIDB4NjdiMTBjMGEsIDB4NmFiYTAyMDMsIDB4N2RhNzEwMTgsIDB4NzBhYzFlMTEsIDB4NTM5ZDM0MmUsIDB4NWU5NjNhMjcsIDB4NDk4YjI4M2MsIDB4NDQ4MDI2MzUsIDB4MGZlOTdjNDIsIDB4MDJlMjcyNGIsIDB4MTVmZjYwNTAsIDB4MThmNDZlNTksIDB4M2JjNTQ0NjYsIDB4MzZjZTRhNmYsIDB4MjFkMzU4NzQsIDB4MmNkODU2N2QsIDB4MGM3YTM3YTEsIDB4MDE3MTM5YTgsIDB4MTY2YzJiYjMsIDB4MWI2NzI1YmEsIDB4Mzg1NjBmODUsIDB4MzU1ZDAxOGMsIDB4MjI0MDEzOTcsIDB4MmY0YjFkOWUsIDB4NjQyMjQ3ZTksIDB4NjkyOTQ5ZTAsIDB4N2UzNDViZmIsIDB4NzMzZjU1ZjIsIDB4NTAwZTdmY2QsIDB4NWQwNTcxYzQsIDB4NGExODYzZGYsIDB4NDcxMzZkZDYsIDB4ZGNjYWQ3MzEsIDB4ZDFjMWQ5MzgsIDB4YzZkY2NiMjMsIDB4Y2JkN2M1MmEsIDB4ZThlNmVmMTUsIDB4ZTVlZGUxMWMsIDB4ZjJmMGYzMDcsIDB4ZmZmYmZkMGUsIDB4YjQ5MmE3NzksIDB4Yjk5OWE5NzAsIDB4YWU4NGJiNmIsIDB4YTM4ZmI1NjIsIDB4ODBiZTlmNWQsIDB4OGRiNTkxNTQsIDB4OWFhODgzNGYsIDB4OTdhMzhkNDZdO1xuXHQgICAgdmFyIFU0ID0gWzB4MDAwMDAwMDAsIDB4MDkwZDBiMGUsIDB4MTIxYTE2MWMsIDB4MWIxNzFkMTIsIDB4MjQzNDJjMzgsIDB4MmQzOTI3MzYsIDB4MzYyZTNhMjQsIDB4M2YyMzMxMmEsIDB4NDg2ODU4NzAsIDB4NDE2NTUzN2UsIDB4NWE3MjRlNmMsIDB4NTM3ZjQ1NjIsIDB4NmM1Yzc0NDgsIDB4NjU1MTdmNDYsIDB4N2U0NjYyNTQsIDB4Nzc0YjY5NWEsIDB4OTBkMGIwZTAsIDB4OTlkZGJiZWUsIDB4ODJjYWE2ZmMsIDB4OGJjN2FkZjIsIDB4YjRlNDljZDgsIDB4YmRlOTk3ZDYsIDB4YTZmZThhYzQsIDB4YWZmMzgxY2EsIDB4ZDhiOGU4OTAsIDB4ZDFiNWUzOWUsIDB4Y2FhMmZlOGMsIDB4YzNhZmY1ODIsIDB4ZmM4Y2M0YTgsIDB4ZjU4MWNmYTYsIDB4ZWU5NmQyYjQsIDB4ZTc5YmQ5YmEsIDB4M2JiYjdiZGIsIDB4MzJiNjcwZDUsIDB4MjlhMTZkYzcsIDB4MjBhYzY2YzksIDB4MWY4ZjU3ZTMsIDB4MTY4MjVjZWQsIDB4MGQ5NTQxZmYsIDB4MDQ5ODRhZjEsIDB4NzNkMzIzYWIsIDB4N2FkZTI4YTUsIDB4NjFjOTM1YjcsIDB4NjhjNDNlYjksIDB4NTdlNzBmOTMsIDB4NWVlYTA0OWQsIDB4NDVmZDE5OGYsIDB4NGNmMDEyODEsIDB4YWI2YmNiM2IsIDB4YTI2NmMwMzUsIDB4Yjk3MWRkMjcsIDB4YjA3Y2Q2MjksIDB4OGY1ZmU3MDMsIDB4ODY1MmVjMGQsIDB4OWQ0NWYxMWYsIDB4OTQ0OGZhMTEsIDB4ZTMwMzkzNGIsIDB4ZWEwZTk4NDUsIDB4ZjExOTg1NTcsIDB4ZjgxNDhlNTksIDB4YzczN2JmNzMsIDB4Y2UzYWI0N2QsIDB4ZDUyZGE5NmYsIDB4ZGMyMGEyNjEsIDB4NzY2ZGY2YWQsIDB4N2Y2MGZkYTMsIDB4NjQ3N2UwYjEsIDB4NmQ3YWViYmYsIDB4NTI1OWRhOTUsIDB4NWI1NGQxOWIsIDB4NDA0M2NjODksIDB4NDk0ZWM3ODcsIDB4M2UwNWFlZGQsIDB4MzcwOGE1ZDMsIDB4MmMxZmI4YzEsIDB4MjUxMmIzY2YsIDB4MWEzMTgyZTUsIDB4MTMzYzg5ZWIsIDB4MDgyYjk0ZjksIDB4MDEyNjlmZjcsIDB4ZTZiZDQ2NGQsIDB4ZWZiMDRkNDMsIDB4ZjRhNzUwNTEsIDB4ZmRhYTViNWYsIDB4YzI4OTZhNzUsIDB4Y2I4NDYxN2IsIDB4ZDA5MzdjNjksIDB4ZDk5ZTc3NjcsIDB4YWVkNTFlM2QsIDB4YTdkODE1MzMsIDB4YmNjZjA4MjEsIDB4YjVjMjAzMmYsIDB4OGFlMTMyMDUsIDB4ODNlYzM5MGIsIDB4OThmYjI0MTksIDB4OTFmNjJmMTcsIDB4NGRkNjhkNzYsIDB4NDRkYjg2NzgsIDB4NWZjYzliNmEsIDB4NTZjMTkwNjQsIDB4NjllMmExNGUsIDB4NjBlZmFhNDAsIDB4N2JmOGI3NTIsIDB4NzJmNWJjNWMsIDB4MDViZWQ1MDYsIDB4MGNiM2RlMDgsIDB4MTdhNGMzMWEsIDB4MWVhOWM4MTQsIDB4MjE4YWY5M2UsIDB4Mjg4N2YyMzAsIDB4MzM5MGVmMjIsIDB4M2E5ZGU0MmMsIDB4ZGQwNjNkOTYsIDB4ZDQwYjM2OTgsIDB4Y2YxYzJiOGEsIDB4YzYxMTIwODQsIDB4ZjkzMjExYWUsIDB4ZjAzZjFhYTAsIDB4ZWIyODA3YjIsIDB4ZTIyNTBjYmMsIDB4OTU2ZTY1ZTYsIDB4OWM2MzZlZTgsIDB4ODc3NDczZmEsIDB4OGU3OTc4ZjQsIDB4YjE1YTQ5ZGUsIDB4Yjg1NzQyZDAsIDB4YTM0MDVmYzIsIDB4YWE0ZDU0Y2MsIDB4ZWNkYWY3NDEsIDB4ZTVkN2ZjNGYsIDB4ZmVjMGUxNWQsIDB4ZjdjZGVhNTMsIDB4YzhlZWRiNzksIDB4YzFlM2QwNzcsIDB4ZGFmNGNkNjUsIDB4ZDNmOWM2NmIsIDB4YTRiMmFmMzEsIDB4YWRiZmE0M2YsIDB4YjZhOGI5MmQsIDB4YmZhNWIyMjMsIDB4ODA4NjgzMDksIDB4ODk4Yjg4MDcsIDB4OTI5Yzk1MTUsIDB4OWI5MTllMWIsIDB4N2MwYTQ3YTEsIDB4NzUwNzRjYWYsIDB4NmUxMDUxYmQsIDB4NjcxZDVhYjMsIDB4NTgzZTZiOTksIDB4NTEzMzYwOTcsIDB4NGEyNDdkODUsIDB4NDMyOTc2OGIsIDB4MzQ2MjFmZDEsIDB4M2Q2ZjE0ZGYsIDB4MjY3ODA5Y2QsIDB4MmY3NTAyYzMsIDB4MTA1NjMzZTksIDB4MTk1YjM4ZTcsIDB4MDI0YzI1ZjUsIDB4MGI0MTJlZmIsIDB4ZDc2MThjOWEsIDB4ZGU2Yzg3OTQsIDB4YzU3YjlhODYsIDB4Y2M3NjkxODgsIDB4ZjM1NWEwYTIsIDB4ZmE1OGFiYWMsIDB4ZTE0ZmI2YmUsIDB4ZTg0MmJkYjAsIDB4OWYwOWQ0ZWEsIDB4OTYwNGRmZTQsIDB4OGQxM2MyZjYsIDB4ODQxZWM5ZjgsIDB4YmIzZGY4ZDIsIDB4YjIzMGYzZGMsIDB4YTkyN2VlY2UsIDB4YTAyYWU1YzAsIDB4NDdiMTNjN2EsIDB4NGViYzM3NzQsIDB4NTVhYjJhNjYsIDB4NWNhNjIxNjgsIDB4NjM4NTEwNDIsIDB4NmE4ODFiNGMsIDB4NzE5ZjA2NWUsIDB4Nzg5MjBkNTAsIDB4MGZkOTY0MGEsIDB4MDZkNDZmMDQsIDB4MWRjMzcyMTYsIDB4MTRjZTc5MTgsIDB4MmJlZDQ4MzIsIDB4MjJlMDQzM2MsIDB4MzlmNzVlMmUsIDB4MzBmYTU1MjAsIDB4OWFiNzAxZWMsIDB4OTNiYTBhZTIsIDB4ODhhZDE3ZjAsIDB4ODFhMDFjZmUsIDB4YmU4MzJkZDQsIDB4Yjc4ZTI2ZGEsIDB4YWM5OTNiYzgsIDB4YTU5NDMwYzYsIDB4ZDJkZjU5OWMsIDB4ZGJkMjUyOTIsIDB4YzBjNTRmODAsIDB4YzljODQ0OGUsIDB4ZjZlYjc1YTQsIDB4ZmZlNjdlYWEsIDB4ZTRmMTYzYjgsIDB4ZWRmYzY4YjYsIDB4MGE2N2IxMGMsIDB4MDM2YWJhMDIsIDB4MTg3ZGE3MTAsIDB4MTE3MGFjMWUsIDB4MmU1MzlkMzQsIDB4Mjc1ZTk2M2EsIDB4M2M0OThiMjgsIDB4MzU0NDgwMjYsIDB4NDIwZmU5N2MsIDB4NGIwMmUyNzIsIDB4NTAxNWZmNjAsIDB4NTkxOGY0NmUsIDB4NjYzYmM1NDQsIDB4NmYzNmNlNGEsIDB4NzQyMWQzNTgsIDB4N2QyY2Q4NTYsIDB4YTEwYzdhMzcsIDB4YTgwMTcxMzksIDB4YjMxNjZjMmIsIDB4YmExYjY3MjUsIDB4ODUzODU2MGYsIDB4OGMzNTVkMDEsIDB4OTcyMjQwMTMsIDB4OWUyZjRiMWQsIDB4ZTk2NDIyNDcsIDB4ZTA2OTI5NDksIDB4ZmI3ZTM0NWIsIDB4ZjI3MzNmNTUsIDB4Y2Q1MDBlN2YsIDB4YzQ1ZDA1NzEsIDB4ZGY0YTE4NjMsIDB4ZDY0NzEzNmQsIDB4MzFkY2NhZDcsIDB4MzhkMWMxZDksIDB4MjNjNmRjY2IsIDB4MmFjYmQ3YzUsIDB4MTVlOGU2ZWYsIDB4MWNlNWVkZTEsIDB4MDdmMmYwZjMsIDB4MGVmZmZiZmQsIDB4NzliNDkyYTcsIDB4NzBiOTk5YTksIDB4NmJhZTg0YmIsIDB4NjJhMzhmYjUsIDB4NWQ4MGJlOWYsIDB4NTQ4ZGI1OTEsIDB4NGY5YWE4ODMsIDB4NDY5N2EzOGRdO1xuXG5cdCAgICBmdW5jdGlvbiBjb252ZXJ0VG9JbnQzMihieXRlcykge1xuXHQgICAgICAgIHZhciByZXN1bHQgPSBbXTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSA0KSB7XG5cdCAgICAgICAgICAgIHJlc3VsdC5wdXNoKFxuXHQgICAgICAgICAgICAgICAgKGJ5dGVzW2kgICAgXSA8PCAyNCkgfFxuXHQgICAgICAgICAgICAgICAgKGJ5dGVzW2kgKyAxXSA8PCAxNikgfFxuXHQgICAgICAgICAgICAgICAgKGJ5dGVzW2kgKyAyXSA8PCAgOCkgfFxuXHQgICAgICAgICAgICAgICAgIGJ5dGVzW2kgKyAzXVxuXHQgICAgICAgICAgICApO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfVxuXG5cdCAgICB2YXIgQUVTID0gZnVuY3Rpb24oa2V5KSB7XG5cdCAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEFFUykpIHtcblx0ICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0FFUyBtdXN0IGJlIGluc3Rhbml0YXRlZCB3aXRoIGBuZXdgJyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdrZXknLCB7XG5cdCAgICAgICAgICAgIHZhbHVlOiBjb2VyY2VBcnJheShrZXksIHRydWUpXG5cdCAgICAgICAgfSk7XG5cblx0ICAgICAgICB0aGlzLl9wcmVwYXJlKCk7XG5cdCAgICB9O1xuXG5cblx0ICAgIEFFUy5wcm90b3R5cGUuX3ByZXBhcmUgPSBmdW5jdGlvbigpIHtcblxuXHQgICAgICAgIHZhciByb3VuZHMgPSBudW1iZXJPZlJvdW5kc1t0aGlzLmtleS5sZW5ndGhdO1xuXHQgICAgICAgIGlmIChyb3VuZHMgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQga2V5IHNpemUgKG11c3QgYmUgMTYsIDI0IG9yIDMyIGJ5dGVzKScpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIGVuY3J5cHRpb24gcm91bmQga2V5c1xuXHQgICAgICAgIHRoaXMuX0tlID0gW107XG5cblx0ICAgICAgICAvLyBkZWNyeXB0aW9uIHJvdW5kIGtleXNcblx0ICAgICAgICB0aGlzLl9LZCA9IFtdO1xuXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gcm91bmRzOyBpKyspIHtcblx0ICAgICAgICAgICAgdGhpcy5fS2UucHVzaChbMCwgMCwgMCwgMF0pO1xuXHQgICAgICAgICAgICB0aGlzLl9LZC5wdXNoKFswLCAwLCAwLCAwXSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdmFyIHJvdW5kS2V5Q291bnQgPSAocm91bmRzICsgMSkgKiA0O1xuXHQgICAgICAgIHZhciBLQyA9IHRoaXMua2V5Lmxlbmd0aCAvIDQ7XG5cblx0ICAgICAgICAvLyBjb252ZXJ0IHRoZSBrZXkgaW50byBpbnRzXG5cdCAgICAgICAgdmFyIHRrID0gY29udmVydFRvSW50MzIodGhpcy5rZXkpO1xuXG5cdCAgICAgICAgLy8gY29weSB2YWx1ZXMgaW50byByb3VuZCBrZXkgYXJyYXlzXG5cdCAgICAgICAgdmFyIGluZGV4O1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgS0M7IGkrKykge1xuXHQgICAgICAgICAgICBpbmRleCA9IGkgPj4gMjtcblx0ICAgICAgICAgICAgdGhpcy5fS2VbaW5kZXhdW2kgJSA0XSA9IHRrW2ldO1xuXHQgICAgICAgICAgICB0aGlzLl9LZFtyb3VuZHMgLSBpbmRleF1baSAlIDRdID0gdGtbaV07XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8ga2V5IGV4cGFuc2lvbiAoZmlwcy0xOTcgc2VjdGlvbiA1LjIpXG5cdCAgICAgICAgdmFyIHJjb25wb2ludGVyID0gMDtcblx0ICAgICAgICB2YXIgdCA9IEtDLCB0dDtcblx0ICAgICAgICB3aGlsZSAodCA8IHJvdW5kS2V5Q291bnQpIHtcblx0ICAgICAgICAgICAgdHQgPSB0a1tLQyAtIDFdO1xuXHQgICAgICAgICAgICB0a1swXSBePSAoKFNbKHR0ID4+IDE2KSAmIDB4RkZdIDw8IDI0KSBeXG5cdCAgICAgICAgICAgICAgICAgICAgICAoU1sodHQgPj4gIDgpICYgMHhGRl0gPDwgMTYpIF5cblx0ICAgICAgICAgICAgICAgICAgICAgIChTWyB0dCAgICAgICAgJiAweEZGXSA8PCAgOCkgXlxuXHQgICAgICAgICAgICAgICAgICAgICAgIFNbKHR0ID4+IDI0KSAmIDB4RkZdICAgICAgICBeXG5cdCAgICAgICAgICAgICAgICAgICAgICAocmNvbltyY29ucG9pbnRlcl0gPDwgMjQpKTtcblx0ICAgICAgICAgICAgcmNvbnBvaW50ZXIgKz0gMTtcblxuXHQgICAgICAgICAgICAvLyBrZXkgZXhwYW5zaW9uIChmb3Igbm9uLTI1NiBiaXQpXG5cdCAgICAgICAgICAgIGlmIChLQyAhPSA4KSB7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IEtDOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICB0a1tpXSBePSB0a1tpIC0gMV07XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8ga2V5IGV4cGFuc2lvbiBmb3IgMjU2LWJpdCBrZXlzIGlzIFwic2xpZ2h0bHkgZGlmZmVyZW50XCIgKGZpcHMtMTk3KVxuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCAoS0MgLyAyKTsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGtbaV0gXj0gdGtbaSAtIDFdO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdHQgPSB0a1soS0MgLyAyKSAtIDFdO1xuXG5cdCAgICAgICAgICAgICAgICB0a1tLQyAvIDJdIF49IChTWyB0dCAgICAgICAgJiAweEZGXSAgICAgICAgXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoU1sodHQgPj4gIDgpICYgMHhGRl0gPDwgIDgpIF5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKFNbKHR0ID4+IDE2KSAmIDB4RkZdIDw8IDE2KSBeXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChTWyh0dCA+PiAyNCkgJiAweEZGXSA8PCAyNCkpO1xuXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gKEtDIC8gMikgKyAxOyBpIDwgS0M7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHRrW2ldIF49IHRrW2kgLSAxXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIGNvcHkgdmFsdWVzIGludG8gcm91bmQga2V5IGFycmF5c1xuXHQgICAgICAgICAgICB2YXIgaSA9IDAsIHIsIGM7XG5cdCAgICAgICAgICAgIHdoaWxlIChpIDwgS0MgJiYgdCA8IHJvdW5kS2V5Q291bnQpIHtcblx0ICAgICAgICAgICAgICAgIHIgPSB0ID4+IDI7XG5cdCAgICAgICAgICAgICAgICBjID0gdCAlIDQ7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9LZVtyXVtjXSA9IHRrW2ldO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fS2Rbcm91bmRzIC0gcl1bY10gPSB0a1tpKytdO1xuXHQgICAgICAgICAgICAgICAgdCsrO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gaW52ZXJzZS1jaXBoZXItaWZ5IHRoZSBkZWNyeXB0aW9uIHJvdW5kIGtleSAoZmlwcy0xOTcgc2VjdGlvbiA1LjMpXG5cdCAgICAgICAgZm9yICh2YXIgciA9IDE7IHIgPCByb3VuZHM7IHIrKykge1xuXHQgICAgICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IDQ7IGMrKykge1xuXHQgICAgICAgICAgICAgICAgdHQgPSB0aGlzLl9LZFtyXVtjXTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX0tkW3JdW2NdID0gKFUxWyh0dCA+PiAyNCkgJiAweEZGXSBeXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBVMlsodHQgPj4gMTYpICYgMHhGRl0gXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVTNbKHR0ID4+ICA4KSAmIDB4RkZdIF5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFU0WyB0dCAgICAgICAgJiAweEZGXSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICBBRVMucHJvdG90eXBlLmVuY3J5cHQgPSBmdW5jdGlvbihwbGFpbnRleHQpIHtcblx0ICAgICAgICBpZiAocGxhaW50ZXh0Lmxlbmd0aCAhPSAxNikge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcGxhaW50ZXh0IHNpemUgKG11c3QgYmUgMTYgYnl0ZXMpJyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdmFyIHJvdW5kcyA9IHRoaXMuX0tlLmxlbmd0aCAtIDE7XG5cdCAgICAgICAgdmFyIGEgPSBbMCwgMCwgMCwgMF07XG5cblx0ICAgICAgICAvLyBjb252ZXJ0IHBsYWludGV4dCB0byAoaW50cyBeIGtleSlcblx0ICAgICAgICB2YXIgdCA9IGNvbnZlcnRUb0ludDMyKHBsYWludGV4dCk7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0ICAgICAgICAgICAgdFtpXSBePSB0aGlzLl9LZVswXVtpXTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBhcHBseSByb3VuZCB0cmFuc2Zvcm1zXG5cdCAgICAgICAgZm9yICh2YXIgciA9IDE7IHIgPCByb3VuZHM7IHIrKykge1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgYVtpXSA9IChUMVsodFsgaSAgICAgICAgIF0gPj4gMjQpICYgMHhmZl0gXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBUMlsodFsoaSArIDEpICUgNF0gPj4gMTYpICYgMHhmZl0gXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBUM1sodFsoaSArIDIpICUgNF0gPj4gIDgpICYgMHhmZl0gXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBUNFsgdFsoaSArIDMpICUgNF0gICAgICAgICYgMHhmZl0gXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9LZVtyXVtpXSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdCA9IGEuc2xpY2UoKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyB0aGUgbGFzdCByb3VuZCBpcyBzcGVjaWFsXG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IGNyZWF0ZUFycmF5KDE2KSwgdHQ7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0ICAgICAgICAgICAgdHQgPSB0aGlzLl9LZVtyb3VuZHNdW2ldO1xuXHQgICAgICAgICAgICByZXN1bHRbNCAqIGkgICAgXSA9IChTWyh0WyBpICAgICAgICAgXSA+PiAyNCkgJiAweGZmXSBeICh0dCA+PiAyNCkpICYgMHhmZjtcblx0ICAgICAgICAgICAgcmVzdWx0WzQgKiBpICsgMV0gPSAoU1sodFsoaSArIDEpICUgNF0gPj4gMTYpICYgMHhmZl0gXiAodHQgPj4gMTYpKSAmIDB4ZmY7XG5cdCAgICAgICAgICAgIHJlc3VsdFs0ICogaSArIDJdID0gKFNbKHRbKGkgKyAyKSAlIDRdID4+ICA4KSAmIDB4ZmZdIF4gKHR0ID4+ICA4KSkgJiAweGZmO1xuXHQgICAgICAgICAgICByZXN1bHRbNCAqIGkgKyAzXSA9IChTWyB0WyhpICsgMykgJSA0XSAgICAgICAgJiAweGZmXSBeICB0dCAgICAgICApICYgMHhmZjtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfTtcblxuXHQgICAgQUVTLnByb3RvdHlwZS5kZWNyeXB0ID0gZnVuY3Rpb24oY2lwaGVydGV4dCkge1xuXHQgICAgICAgIGlmIChjaXBoZXJ0ZXh0Lmxlbmd0aCAhPSAxNikge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgY2lwaGVydGV4dCBzaXplIChtdXN0IGJlIDE2IGJ5dGVzKScpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHZhciByb3VuZHMgPSB0aGlzLl9LZC5sZW5ndGggLSAxO1xuXHQgICAgICAgIHZhciBhID0gWzAsIDAsIDAsIDBdO1xuXG5cdCAgICAgICAgLy8gY29udmVydCBwbGFpbnRleHQgdG8gKGludHMgXiBrZXkpXG5cdCAgICAgICAgdmFyIHQgPSBjb252ZXJ0VG9JbnQzMihjaXBoZXJ0ZXh0KTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuXHQgICAgICAgICAgICB0W2ldIF49IHRoaXMuX0tkWzBdW2ldO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIGFwcGx5IHJvdW5kIHRyYW5zZm9ybXNcblx0ICAgICAgICBmb3IgKHZhciByID0gMTsgciA8IHJvdW5kczsgcisrKSB7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBhW2ldID0gKFQ1Wyh0WyBpICAgICAgICAgIF0gPj4gMjQpICYgMHhmZl0gXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBUNlsodFsoaSArIDMpICUgNF0gPj4gMTYpICYgMHhmZl0gXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBUN1sodFsoaSArIDIpICUgNF0gPj4gIDgpICYgMHhmZl0gXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBUOFsgdFsoaSArIDEpICUgNF0gICAgICAgICYgMHhmZl0gXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9LZFtyXVtpXSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdCA9IGEuc2xpY2UoKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyB0aGUgbGFzdCByb3VuZCBpcyBzcGVjaWFsXG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IGNyZWF0ZUFycmF5KDE2KSwgdHQ7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0ICAgICAgICAgICAgdHQgPSB0aGlzLl9LZFtyb3VuZHNdW2ldO1xuXHQgICAgICAgICAgICByZXN1bHRbNCAqIGkgICAgXSA9IChTaVsodFsgaSAgICAgICAgIF0gPj4gMjQpICYgMHhmZl0gXiAodHQgPj4gMjQpKSAmIDB4ZmY7XG5cdCAgICAgICAgICAgIHJlc3VsdFs0ICogaSArIDFdID0gKFNpWyh0WyhpICsgMykgJSA0XSA+PiAxNikgJiAweGZmXSBeICh0dCA+PiAxNikpICYgMHhmZjtcblx0ICAgICAgICAgICAgcmVzdWx0WzQgKiBpICsgMl0gPSAoU2lbKHRbKGkgKyAyKSAlIDRdID4+ICA4KSAmIDB4ZmZdIF4gKHR0ID4+ICA4KSkgJiAweGZmO1xuXHQgICAgICAgICAgICByZXN1bHRbNCAqIGkgKyAzXSA9IChTaVsgdFsoaSArIDEpICUgNF0gICAgICAgICYgMHhmZl0gXiAgdHQgICAgICAgKSAmIDB4ZmY7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgIH07XG5cblxuXHQgICAgLyoqXG5cdCAgICAgKiAgTW9kZSBPZiBPcGVyYXRpb24gLSBFbGVjdG9uaWMgQ29kZWJvb2sgKEVDQilcblx0ICAgICAqL1xuXHQgICAgdmFyIE1vZGVPZk9wZXJhdGlvbkVDQiA9IGZ1bmN0aW9uKGtleSkge1xuXHQgICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBNb2RlT2ZPcGVyYXRpb25FQ0IpKSB7XG5cdCAgICAgICAgICAgIHRocm93IEVycm9yKCdBRVMgbXVzdCBiZSBpbnN0YW5pdGF0ZWQgd2l0aCBgbmV3YCcpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSBcIkVsZWN0cm9uaWMgQ29kZSBCbG9ja1wiO1xuXHQgICAgICAgIHRoaXMubmFtZSA9IFwiZWNiXCI7XG5cblx0ICAgICAgICB0aGlzLl9hZXMgPSBuZXcgQUVTKGtleSk7XG5cdCAgICB9O1xuXG5cdCAgICBNb2RlT2ZPcGVyYXRpb25FQ0IucHJvdG90eXBlLmVuY3J5cHQgPSBmdW5jdGlvbihwbGFpbnRleHQpIHtcblx0ICAgICAgICBwbGFpbnRleHQgPSBjb2VyY2VBcnJheShwbGFpbnRleHQpO1xuXG5cdCAgICAgICAgaWYgKChwbGFpbnRleHQubGVuZ3RoICUgMTYpICE9PSAwKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwbGFpbnRleHQgc2l6ZSAobXVzdCBiZSBtdWx0aXBsZSBvZiAxNiBieXRlcyknKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB2YXIgY2lwaGVydGV4dCA9IGNyZWF0ZUFycmF5KHBsYWludGV4dC5sZW5ndGgpO1xuXHQgICAgICAgIHZhciBibG9jayA9IGNyZWF0ZUFycmF5KDE2KTtcblxuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGxhaW50ZXh0Lmxlbmd0aDsgaSArPSAxNikge1xuXHQgICAgICAgICAgICBjb3B5QXJyYXkocGxhaW50ZXh0LCBibG9jaywgMCwgaSwgaSArIDE2KTtcblx0ICAgICAgICAgICAgYmxvY2sgPSB0aGlzLl9hZXMuZW5jcnlwdChibG9jayk7XG5cdCAgICAgICAgICAgIGNvcHlBcnJheShibG9jaywgY2lwaGVydGV4dCwgaSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIGNpcGhlcnRleHQ7XG5cdCAgICB9O1xuXG5cdCAgICBNb2RlT2ZPcGVyYXRpb25FQ0IucHJvdG90eXBlLmRlY3J5cHQgPSBmdW5jdGlvbihjaXBoZXJ0ZXh0KSB7XG5cdCAgICAgICAgY2lwaGVydGV4dCA9IGNvZXJjZUFycmF5KGNpcGhlcnRleHQpO1xuXG5cdCAgICAgICAgaWYgKChjaXBoZXJ0ZXh0Lmxlbmd0aCAlIDE2KSAhPT0gMCkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgY2lwaGVydGV4dCBzaXplIChtdXN0IGJlIG11bHRpcGxlIG9mIDE2IGJ5dGVzKScpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHZhciBwbGFpbnRleHQgPSBjcmVhdGVBcnJheShjaXBoZXJ0ZXh0Lmxlbmd0aCk7XG5cdCAgICAgICAgdmFyIGJsb2NrID0gY3JlYXRlQXJyYXkoMTYpO1xuXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaXBoZXJ0ZXh0Lmxlbmd0aDsgaSArPSAxNikge1xuXHQgICAgICAgICAgICBjb3B5QXJyYXkoY2lwaGVydGV4dCwgYmxvY2ssIDAsIGksIGkgKyAxNik7XG5cdCAgICAgICAgICAgIGJsb2NrID0gdGhpcy5fYWVzLmRlY3J5cHQoYmxvY2spO1xuXHQgICAgICAgICAgICBjb3B5QXJyYXkoYmxvY2ssIHBsYWludGV4dCwgaSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIHBsYWludGV4dDtcblx0ICAgIH07XG5cblxuXHQgICAgLyoqXG5cdCAgICAgKiAgTW9kZSBPZiBPcGVyYXRpb24gLSBDaXBoZXIgQmxvY2sgQ2hhaW5pbmcgKENCQylcblx0ICAgICAqL1xuXHQgICAgdmFyIE1vZGVPZk9wZXJhdGlvbkNCQyA9IGZ1bmN0aW9uKGtleSwgaXYpIHtcblx0ICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTW9kZU9mT3BlcmF0aW9uQ0JDKSkge1xuXHQgICAgICAgICAgICB0aHJvdyBFcnJvcignQUVTIG11c3QgYmUgaW5zdGFuaXRhdGVkIHdpdGggYG5ld2AnKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gXCJDaXBoZXIgQmxvY2sgQ2hhaW5pbmdcIjtcblx0ICAgICAgICB0aGlzLm5hbWUgPSBcImNiY1wiO1xuXG5cdCAgICAgICAgaWYgKCFpdikge1xuXHQgICAgICAgICAgICBpdiA9IGNyZWF0ZUFycmF5KDE2KTtcblxuXHQgICAgICAgIH0gZWxzZSBpZiAoaXYubGVuZ3RoICE9IDE2KSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbml0aWFsYXRpb24gdmVjdG9yIHNpemUgKG11c3QgYmUgMTYgYnl0ZXMpJyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdGhpcy5fbGFzdENpcGhlcmJsb2NrID0gY29lcmNlQXJyYXkoaXYsIHRydWUpO1xuXG5cdCAgICAgICAgdGhpcy5fYWVzID0gbmV3IEFFUyhrZXkpO1xuXHQgICAgfTtcblxuXHQgICAgTW9kZU9mT3BlcmF0aW9uQ0JDLnByb3RvdHlwZS5lbmNyeXB0ID0gZnVuY3Rpb24ocGxhaW50ZXh0KSB7XG5cdCAgICAgICAgcGxhaW50ZXh0ID0gY29lcmNlQXJyYXkocGxhaW50ZXh0KTtcblxuXHQgICAgICAgIGlmICgocGxhaW50ZXh0Lmxlbmd0aCAlIDE2KSAhPT0gMCkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcGxhaW50ZXh0IHNpemUgKG11c3QgYmUgbXVsdGlwbGUgb2YgMTYgYnl0ZXMpJyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdmFyIGNpcGhlcnRleHQgPSBjcmVhdGVBcnJheShwbGFpbnRleHQubGVuZ3RoKTtcblx0ICAgICAgICB2YXIgYmxvY2sgPSBjcmVhdGVBcnJheSgxNik7XG5cblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBsYWludGV4dC5sZW5ndGg7IGkgKz0gMTYpIHtcblx0ICAgICAgICAgICAgY29weUFycmF5KHBsYWludGV4dCwgYmxvY2ssIDAsIGksIGkgKyAxNik7XG5cblx0ICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCAxNjsgaisrKSB7XG5cdCAgICAgICAgICAgICAgICBibG9ja1tqXSBePSB0aGlzLl9sYXN0Q2lwaGVyYmxvY2tbal07XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICB0aGlzLl9sYXN0Q2lwaGVyYmxvY2sgPSB0aGlzLl9hZXMuZW5jcnlwdChibG9jayk7XG5cdCAgICAgICAgICAgIGNvcHlBcnJheSh0aGlzLl9sYXN0Q2lwaGVyYmxvY2ssIGNpcGhlcnRleHQsIGkpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiBjaXBoZXJ0ZXh0O1xuXHQgICAgfTtcblxuXHQgICAgTW9kZU9mT3BlcmF0aW9uQ0JDLnByb3RvdHlwZS5kZWNyeXB0ID0gZnVuY3Rpb24oY2lwaGVydGV4dCkge1xuXHQgICAgICAgIGNpcGhlcnRleHQgPSBjb2VyY2VBcnJheShjaXBoZXJ0ZXh0KTtcblxuXHQgICAgICAgIGlmICgoY2lwaGVydGV4dC5sZW5ndGggJSAxNikgIT09IDApIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGNpcGhlcnRleHQgc2l6ZSAobXVzdCBiZSBtdWx0aXBsZSBvZiAxNiBieXRlcyknKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB2YXIgcGxhaW50ZXh0ID0gY3JlYXRlQXJyYXkoY2lwaGVydGV4dC5sZW5ndGgpO1xuXHQgICAgICAgIHZhciBibG9jayA9IGNyZWF0ZUFycmF5KDE2KTtcblxuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2lwaGVydGV4dC5sZW5ndGg7IGkgKz0gMTYpIHtcblx0ICAgICAgICAgICAgY29weUFycmF5KGNpcGhlcnRleHQsIGJsb2NrLCAwLCBpLCBpICsgMTYpO1xuXHQgICAgICAgICAgICBibG9jayA9IHRoaXMuX2Flcy5kZWNyeXB0KGJsb2NrKTtcblxuXHQgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDE2OyBqKyspIHtcblx0ICAgICAgICAgICAgICAgIHBsYWludGV4dFtpICsgal0gPSBibG9ja1tqXSBeIHRoaXMuX2xhc3RDaXBoZXJibG9ja1tqXTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGNvcHlBcnJheShjaXBoZXJ0ZXh0LCB0aGlzLl9sYXN0Q2lwaGVyYmxvY2ssIDAsIGksIGkgKyAxNik7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIHBsYWludGV4dDtcblx0ICAgIH07XG5cblxuXHQgICAgLyoqXG5cdCAgICAgKiAgTW9kZSBPZiBPcGVyYXRpb24gLSBDaXBoZXIgRmVlZGJhY2sgKENGQilcblx0ICAgICAqL1xuXHQgICAgdmFyIE1vZGVPZk9wZXJhdGlvbkNGQiA9IGZ1bmN0aW9uKGtleSwgaXYsIHNlZ21lbnRTaXplKSB7XG5cdCAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1vZGVPZk9wZXJhdGlvbkNGQikpIHtcblx0ICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0FFUyBtdXN0IGJlIGluc3Rhbml0YXRlZCB3aXRoIGBuZXdgJyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IFwiQ2lwaGVyIEZlZWRiYWNrXCI7XG5cdCAgICAgICAgdGhpcy5uYW1lID0gXCJjZmJcIjtcblxuXHQgICAgICAgIGlmICghaXYpIHtcblx0ICAgICAgICAgICAgaXYgPSBjcmVhdGVBcnJheSgxNik7XG5cblx0ICAgICAgICB9IGVsc2UgaWYgKGl2Lmxlbmd0aCAhPSAxNikge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5pdGlhbGF0aW9uIHZlY3RvciBzaXplIChtdXN0IGJlIDE2IHNpemUpJyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKCFzZWdtZW50U2l6ZSkgeyBzZWdtZW50U2l6ZSA9IDE7IH1cblxuXHQgICAgICAgIHRoaXMuc2VnbWVudFNpemUgPSBzZWdtZW50U2l6ZTtcblxuXHQgICAgICAgIHRoaXMuX3NoaWZ0UmVnaXN0ZXIgPSBjb2VyY2VBcnJheShpdiwgdHJ1ZSk7XG5cblx0ICAgICAgICB0aGlzLl9hZXMgPSBuZXcgQUVTKGtleSk7XG5cdCAgICB9O1xuXG5cdCAgICBNb2RlT2ZPcGVyYXRpb25DRkIucHJvdG90eXBlLmVuY3J5cHQgPSBmdW5jdGlvbihwbGFpbnRleHQpIHtcblx0ICAgICAgICBpZiAoKHBsYWludGV4dC5sZW5ndGggJSB0aGlzLnNlZ21lbnRTaXplKSAhPSAwKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwbGFpbnRleHQgc2l6ZSAobXVzdCBiZSBzZWdtZW50U2l6ZSBieXRlcyknKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB2YXIgZW5jcnlwdGVkID0gY29lcmNlQXJyYXkocGxhaW50ZXh0LCB0cnVlKTtcblxuXHQgICAgICAgIHZhciB4b3JTZWdtZW50O1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5jcnlwdGVkLmxlbmd0aDsgaSArPSB0aGlzLnNlZ21lbnRTaXplKSB7XG5cdCAgICAgICAgICAgIHhvclNlZ21lbnQgPSB0aGlzLl9hZXMuZW5jcnlwdCh0aGlzLl9zaGlmdFJlZ2lzdGVyKTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLnNlZ21lbnRTaXplOyBqKyspIHtcblx0ICAgICAgICAgICAgICAgIGVuY3J5cHRlZFtpICsgal0gXj0geG9yU2VnbWVudFtqXTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFNoaWZ0IHRoZSByZWdpc3RlclxuXHQgICAgICAgICAgICBjb3B5QXJyYXkodGhpcy5fc2hpZnRSZWdpc3RlciwgdGhpcy5fc2hpZnRSZWdpc3RlciwgMCwgdGhpcy5zZWdtZW50U2l6ZSk7XG5cdCAgICAgICAgICAgIGNvcHlBcnJheShlbmNyeXB0ZWQsIHRoaXMuX3NoaWZ0UmVnaXN0ZXIsIDE2IC0gdGhpcy5zZWdtZW50U2l6ZSwgaSwgaSArIHRoaXMuc2VnbWVudFNpemUpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiBlbmNyeXB0ZWQ7XG5cdCAgICB9O1xuXG5cdCAgICBNb2RlT2ZPcGVyYXRpb25DRkIucHJvdG90eXBlLmRlY3J5cHQgPSBmdW5jdGlvbihjaXBoZXJ0ZXh0KSB7XG5cdCAgICAgICAgaWYgKChjaXBoZXJ0ZXh0Lmxlbmd0aCAlIHRoaXMuc2VnbWVudFNpemUpICE9IDApIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGNpcGhlcnRleHQgc2l6ZSAobXVzdCBiZSBzZWdtZW50U2l6ZSBieXRlcyknKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB2YXIgcGxhaW50ZXh0ID0gY29lcmNlQXJyYXkoY2lwaGVydGV4dCwgdHJ1ZSk7XG5cblx0ICAgICAgICB2YXIgeG9yU2VnbWVudDtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBsYWludGV4dC5sZW5ndGg7IGkgKz0gdGhpcy5zZWdtZW50U2l6ZSkge1xuXHQgICAgICAgICAgICB4b3JTZWdtZW50ID0gdGhpcy5fYWVzLmVuY3J5cHQodGhpcy5fc2hpZnRSZWdpc3Rlcik7XG5cblx0ICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLnNlZ21lbnRTaXplOyBqKyspIHtcblx0ICAgICAgICAgICAgICAgIHBsYWludGV4dFtpICsgal0gXj0geG9yU2VnbWVudFtqXTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFNoaWZ0IHRoZSByZWdpc3RlclxuXHQgICAgICAgICAgICBjb3B5QXJyYXkodGhpcy5fc2hpZnRSZWdpc3RlciwgdGhpcy5fc2hpZnRSZWdpc3RlciwgMCwgdGhpcy5zZWdtZW50U2l6ZSk7XG5cdCAgICAgICAgICAgIGNvcHlBcnJheShjaXBoZXJ0ZXh0LCB0aGlzLl9zaGlmdFJlZ2lzdGVyLCAxNiAtIHRoaXMuc2VnbWVudFNpemUsIGksIGkgKyB0aGlzLnNlZ21lbnRTaXplKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gcGxhaW50ZXh0O1xuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiAgTW9kZSBPZiBPcGVyYXRpb24gLSBPdXRwdXQgRmVlZGJhY2sgKE9GQilcblx0ICAgICAqL1xuXHQgICAgdmFyIE1vZGVPZk9wZXJhdGlvbk9GQiA9IGZ1bmN0aW9uKGtleSwgaXYpIHtcblx0ICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTW9kZU9mT3BlcmF0aW9uT0ZCKSkge1xuXHQgICAgICAgICAgICB0aHJvdyBFcnJvcignQUVTIG11c3QgYmUgaW5zdGFuaXRhdGVkIHdpdGggYG5ld2AnKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gXCJPdXRwdXQgRmVlZGJhY2tcIjtcblx0ICAgICAgICB0aGlzLm5hbWUgPSBcIm9mYlwiO1xuXG5cdCAgICAgICAgaWYgKCFpdikge1xuXHQgICAgICAgICAgICBpdiA9IGNyZWF0ZUFycmF5KDE2KTtcblxuXHQgICAgICAgIH0gZWxzZSBpZiAoaXYubGVuZ3RoICE9IDE2KSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbml0aWFsYXRpb24gdmVjdG9yIHNpemUgKG11c3QgYmUgMTYgYnl0ZXMpJyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdGhpcy5fbGFzdFByZWNpcGhlciA9IGNvZXJjZUFycmF5KGl2LCB0cnVlKTtcblx0ICAgICAgICB0aGlzLl9sYXN0UHJlY2lwaGVySW5kZXggPSAxNjtcblxuXHQgICAgICAgIHRoaXMuX2FlcyA9IG5ldyBBRVMoa2V5KTtcblx0ICAgIH07XG5cblx0ICAgIE1vZGVPZk9wZXJhdGlvbk9GQi5wcm90b3R5cGUuZW5jcnlwdCA9IGZ1bmN0aW9uKHBsYWludGV4dCkge1xuXHQgICAgICAgIHZhciBlbmNyeXB0ZWQgPSBjb2VyY2VBcnJheShwbGFpbnRleHQsIHRydWUpO1xuXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmNyeXB0ZWQubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX2xhc3RQcmVjaXBoZXJJbmRleCA9PT0gMTYpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RQcmVjaXBoZXIgPSB0aGlzLl9hZXMuZW5jcnlwdCh0aGlzLl9sYXN0UHJlY2lwaGVyKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RQcmVjaXBoZXJJbmRleCA9IDA7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZW5jcnlwdGVkW2ldIF49IHRoaXMuX2xhc3RQcmVjaXBoZXJbdGhpcy5fbGFzdFByZWNpcGhlckluZGV4KytdO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiBlbmNyeXB0ZWQ7XG5cdCAgICB9O1xuXG5cdCAgICAvLyBEZWNyeXB0aW9uIGlzIHN5bWV0cmljXG5cdCAgICBNb2RlT2ZPcGVyYXRpb25PRkIucHJvdG90eXBlLmRlY3J5cHQgPSBNb2RlT2ZPcGVyYXRpb25PRkIucHJvdG90eXBlLmVuY3J5cHQ7XG5cblxuXHQgICAgLyoqXG5cdCAgICAgKiAgQ291bnRlciBvYmplY3QgZm9yIENUUiBjb21tb24gbW9kZSBvZiBvcGVyYXRpb25cblx0ICAgICAqL1xuXHQgICAgdmFyIENvdW50ZXIgPSBmdW5jdGlvbihpbml0aWFsVmFsdWUpIHtcblx0ICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ291bnRlcikpIHtcblx0ICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0NvdW50ZXIgbXVzdCBiZSBpbnN0YW5pdGF0ZWQgd2l0aCBgbmV3YCcpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIFdlIGFsbG93IDAsIGJ1dCBhbnl0aGluZyBmYWxzZS1pc2ggdXNlcyB0aGUgZGVmYXVsdCAxXG5cdCAgICAgICAgaWYgKGluaXRpYWxWYWx1ZSAhPT0gMCAmJiAhaW5pdGlhbFZhbHVlKSB7IGluaXRpYWxWYWx1ZSA9IDE7IH1cblxuXHQgICAgICAgIGlmICh0eXBlb2YoaW5pdGlhbFZhbHVlKSA9PT0gJ251bWJlcicpIHtcblx0ICAgICAgICAgICAgdGhpcy5fY291bnRlciA9IGNyZWF0ZUFycmF5KDE2KTtcblx0ICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZShpbml0aWFsVmFsdWUpO1xuXG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdGhpcy5zZXRCeXRlcyhpbml0aWFsVmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIENvdW50ZXIucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24odmFsdWUpIHtcblx0ICAgICAgICBpZiAodHlwZW9mKHZhbHVlKSAhPT0gJ251bWJlcicgfHwgcGFyc2VJbnQodmFsdWUpICE9IHZhbHVlKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBjb3VudGVyIHZhbHVlIChtdXN0IGJlIGFuIGludGVnZXIpJyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgZm9yICh2YXIgaW5kZXggPSAxNTsgaW5kZXggPj0gMDsgLS1pbmRleCkge1xuXHQgICAgICAgICAgICB0aGlzLl9jb3VudGVyW2luZGV4XSA9IHZhbHVlICUgMjU2O1xuXHQgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlID4+IDg7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgQ291bnRlci5wcm90b3R5cGUuc2V0Qnl0ZXMgPSBmdW5jdGlvbihieXRlcykge1xuXHQgICAgICAgIGJ5dGVzID0gY29lcmNlQXJyYXkoYnl0ZXMsIHRydWUpO1xuXG5cdCAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCAhPSAxNikge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgY291bnRlciBieXRlcyBzaXplIChtdXN0IGJlIDE2IGJ5dGVzKScpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHRoaXMuX2NvdW50ZXIgPSBieXRlcztcblx0ICAgIH07XG5cblx0ICAgIENvdW50ZXIucHJvdG90eXBlLmluY3JlbWVudCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAxNTsgaSA+PSAwOyBpLS0pIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX2NvdW50ZXJbaV0gPT09IDI1NSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fY291bnRlcltpXSA9IDA7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9jb3VudGVyW2ldKys7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblxuXHQgICAgLyoqXG5cdCAgICAgKiAgTW9kZSBPZiBPcGVyYXRpb24gLSBDb3VudGVyIChDVFIpXG5cdCAgICAgKi9cblx0ICAgIHZhciBNb2RlT2ZPcGVyYXRpb25DVFIgPSBmdW5jdGlvbihrZXksIGNvdW50ZXIpIHtcblx0ICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTW9kZU9mT3BlcmF0aW9uQ1RSKSkge1xuXHQgICAgICAgICAgICB0aHJvdyBFcnJvcignQUVTIG11c3QgYmUgaW5zdGFuaXRhdGVkIHdpdGggYG5ld2AnKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gXCJDb3VudGVyXCI7XG5cdCAgICAgICAgdGhpcy5uYW1lID0gXCJjdHJcIjtcblxuXHQgICAgICAgIGlmICghKGNvdW50ZXIgaW5zdGFuY2VvZiBDb3VudGVyKSkge1xuXHQgICAgICAgICAgICBjb3VudGVyID0gbmV3IENvdW50ZXIoY291bnRlcik7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdGhpcy5fY291bnRlciA9IGNvdW50ZXI7XG5cblx0ICAgICAgICB0aGlzLl9yZW1haW5pbmdDb3VudGVyID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9yZW1haW5pbmdDb3VudGVySW5kZXggPSAxNjtcblxuXHQgICAgICAgIHRoaXMuX2FlcyA9IG5ldyBBRVMoa2V5KTtcblx0ICAgIH07XG5cblx0ICAgIE1vZGVPZk9wZXJhdGlvbkNUUi5wcm90b3R5cGUuZW5jcnlwdCA9IGZ1bmN0aW9uKHBsYWludGV4dCkge1xuXHQgICAgICAgIHZhciBlbmNyeXB0ZWQgPSBjb2VyY2VBcnJheShwbGFpbnRleHQsIHRydWUpO1xuXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmNyeXB0ZWQubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3JlbWFpbmluZ0NvdW50ZXJJbmRleCA9PT0gMTYpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3JlbWFpbmluZ0NvdW50ZXIgPSB0aGlzLl9hZXMuZW5jcnlwdCh0aGlzLl9jb3VudGVyLl9jb3VudGVyKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3JlbWFpbmluZ0NvdW50ZXJJbmRleCA9IDA7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9jb3VudGVyLmluY3JlbWVudCgpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVuY3J5cHRlZFtpXSBePSB0aGlzLl9yZW1haW5pbmdDb3VudGVyW3RoaXMuX3JlbWFpbmluZ0NvdW50ZXJJbmRleCsrXTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gZW5jcnlwdGVkO1xuXHQgICAgfTtcblxuXHQgICAgLy8gRGVjcnlwdGlvbiBpcyBzeW1ldHJpY1xuXHQgICAgTW9kZU9mT3BlcmF0aW9uQ1RSLnByb3RvdHlwZS5kZWNyeXB0ID0gTW9kZU9mT3BlcmF0aW9uQ1RSLnByb3RvdHlwZS5lbmNyeXB0O1xuXG5cblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvLyBQYWRkaW5nXG5cblx0ICAgIC8vIFNlZTpodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMjMxNVxuXHQgICAgZnVuY3Rpb24gcGtjczdwYWQoZGF0YSkge1xuXHQgICAgICAgIGRhdGEgPSBjb2VyY2VBcnJheShkYXRhLCB0cnVlKTtcblx0ICAgICAgICB2YXIgcGFkZGVyID0gMTYgLSAoZGF0YS5sZW5ndGggJSAxNik7XG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IGNyZWF0ZUFycmF5KGRhdGEubGVuZ3RoICsgcGFkZGVyKTtcblx0ICAgICAgICBjb3B5QXJyYXkoZGF0YSwgcmVzdWx0KTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gZGF0YS5sZW5ndGg7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgcmVzdWx0W2ldID0gcGFkZGVyO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBwa2NzN3N0cmlwKGRhdGEpIHtcblx0ICAgICAgICBkYXRhID0gY29lcmNlQXJyYXkoZGF0YSwgdHJ1ZSk7XG5cdCAgICAgICAgaWYgKGRhdGEubGVuZ3RoIDwgMTYpIHsgdGhyb3cgbmV3IEVycm9yKCdQS0NTIzcgaW52YWxpZCBsZW5ndGgnKTsgfVxuXG5cdCAgICAgICAgdmFyIHBhZGRlciA9IGRhdGFbZGF0YS5sZW5ndGggLSAxXTtcblx0ICAgICAgICBpZiAocGFkZGVyID4gMTYpIHsgdGhyb3cgbmV3IEVycm9yKCdQS0NTIzcgcGFkZGluZyBieXRlIG91dCBvZiByYW5nZScpOyB9XG5cblx0ICAgICAgICB2YXIgbGVuZ3RoID0gZGF0YS5sZW5ndGggLSBwYWRkZXI7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWRkZXI7IGkrKykge1xuXHQgICAgICAgICAgICBpZiAoZGF0YVtsZW5ndGggKyBpXSAhPT0gcGFkZGVyKSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BLQ1MjNyBpbnZhbGlkIHBhZGRpbmcgYnl0ZScpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IGNyZWF0ZUFycmF5KGxlbmd0aCk7XG5cdCAgICAgICAgY29weUFycmF5KGRhdGEsIHJlc3VsdCwgMCwgMCwgbGVuZ3RoKTtcblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfVxuXG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy8gRXhwb3J0aW5nXG5cblxuXHQgICAgLy8gVGhlIGJsb2NrIGNpcGhlclxuXHQgICAgdmFyIGFlc2pzID0ge1xuXHQgICAgICAgIEFFUzogQUVTLFxuXHQgICAgICAgIENvdW50ZXI6IENvdW50ZXIsXG5cblx0ICAgICAgICBNb2RlT2ZPcGVyYXRpb246IHtcblx0ICAgICAgICAgICAgZWNiOiBNb2RlT2ZPcGVyYXRpb25FQ0IsXG5cdCAgICAgICAgICAgIGNiYzogTW9kZU9mT3BlcmF0aW9uQ0JDLFxuXHQgICAgICAgICAgICBjZmI6IE1vZGVPZk9wZXJhdGlvbkNGQixcblx0ICAgICAgICAgICAgb2ZiOiBNb2RlT2ZPcGVyYXRpb25PRkIsXG5cdCAgICAgICAgICAgIGN0cjogTW9kZU9mT3BlcmF0aW9uQ1RSXG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIHV0aWxzOiB7XG5cdCAgICAgICAgICAgIGhleDogY29udmVydEhleCxcblx0ICAgICAgICAgICAgdXRmODogY29udmVydFV0Zjhcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgcGFkZGluZzoge1xuXHQgICAgICAgICAgICBwa2NzNzoge1xuXHQgICAgICAgICAgICAgICAgcGFkOiBwa2NzN3BhZCxcblx0ICAgICAgICAgICAgICAgIHN0cmlwOiBwa2NzN3N0cmlwXG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2FycmF5VGVzdDoge1xuXHQgICAgICAgICAgICBjb2VyY2VBcnJheTogY29lcmNlQXJyYXksXG5cdCAgICAgICAgICAgIGNyZWF0ZUFycmF5OiBjcmVhdGVBcnJheSxcblx0ICAgICAgICAgICAgY29weUFycmF5OiBjb3B5QXJyYXksXG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXG5cdCAgICAvLyBub2RlLmpzXG5cdCAgICBpZiAoJ29iamVjdCcgIT09ICd1bmRlZmluZWQnKSB7XG5cdCAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBhZXNqcztcblxuXHQgICAgLy8gUmVxdWlyZUpTL0FNRFxuXHQgICAgLy8gaHR0cDovL3d3dy5yZXF1aXJlanMub3JnL2RvY3MvYXBpLmh0bWxcblx0ICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbWRqcy9hbWRqcy1hcGkvd2lraS9BTURcblx0ICAgIH0gZWxzZSBpZiAodHlwZW9mKHVuZGVmaW5lZCkgPT09ICdmdW5jdGlvbicgJiYgdW5kZWZpbmVkLmFtZCkge1xuXHQgICAgICAgIHVuZGVmaW5lZChhZXNqcyk7XG5cblx0ICAgIC8vIFdlYiBCcm93c2Vyc1xuXHQgICAgfSBlbHNlIHtcblxuXHQgICAgICAgIC8vIElmIHRoZXJlIHdhcyBhbiBleGlzdGluZyBsaWJyYXJ5IGF0IFwiYWVzanNcIiBtYWtlIHN1cmUgaXQncyBzdGlsbCBhdmFpbGFibGVcblx0ICAgICAgICBpZiAocm9vdC5hZXNqcykge1xuXHQgICAgICAgICAgICBhZXNqcy5fYWVzanMgPSByb290LmFlc2pzO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJvb3QuYWVzanMgPSBhZXNqcztcblx0ICAgIH1cblxuXG5cdH0pKGNvbW1vbmpzR2xvYmFsKTtcblx0fSk7XG5cblx0dmFyIF92ZXJzaW9uJEEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMudmVyc2lvbiA9IFwianNvbi13YWxsZXRzLzUuMC40XCI7XG5cblx0fSk7XG5cblx0dmFyIF92ZXJzaW9uJEIgPSB1bndyYXBFeHBvcnRzKF92ZXJzaW9uJEEpO1xuXHR2YXIgX3ZlcnNpb25fMSRpID0gX3ZlcnNpb24kQS52ZXJzaW9uO1xuXG5cdHZhciB1dGlscyQxID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5cblx0ZnVuY3Rpb24gbG9vc2VBcnJheWlmeShoZXhTdHJpbmcpIHtcblx0ICAgIGlmICh0eXBlb2YgKGhleFN0cmluZykgPT09ICdzdHJpbmcnICYmIGhleFN0cmluZy5zdWJzdHJpbmcoMCwgMikgIT09ICcweCcpIHtcblx0ICAgICAgICBoZXhTdHJpbmcgPSAnMHgnICsgaGV4U3RyaW5nO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGxpYiQxLmFycmF5aWZ5KGhleFN0cmluZyk7XG5cdH1cblx0ZXhwb3J0cy5sb29zZUFycmF5aWZ5ID0gbG9vc2VBcnJheWlmeTtcblx0ZnVuY3Rpb24genBhZCh2YWx1ZSwgbGVuZ3RoKSB7XG5cdCAgICB2YWx1ZSA9IFN0cmluZyh2YWx1ZSk7XG5cdCAgICB3aGlsZSAodmFsdWUubGVuZ3RoIDwgbGVuZ3RoKSB7XG5cdCAgICAgICAgdmFsdWUgPSAnMCcgKyB2YWx1ZTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB2YWx1ZTtcblx0fVxuXHRleHBvcnRzLnpwYWQgPSB6cGFkO1xuXHRmdW5jdGlvbiBnZXRQYXNzd29yZChwYXNzd29yZCkge1xuXHQgICAgaWYgKHR5cGVvZiAocGFzc3dvcmQpID09PSAnc3RyaW5nJykge1xuXHQgICAgICAgIHJldHVybiBsaWIkOC50b1V0ZjhCeXRlcyhwYXNzd29yZCwgbGliJDguVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtLk5GS0MpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGxpYiQxLmFycmF5aWZ5KHBhc3N3b3JkKTtcblx0fVxuXHRleHBvcnRzLmdldFBhc3N3b3JkID0gZ2V0UGFzc3dvcmQ7XG5cdGZ1bmN0aW9uIHNlYXJjaFBhdGgob2JqZWN0LCBwYXRoKSB7XG5cdCAgICB2YXIgY3VycmVudENoaWxkID0gb2JqZWN0O1xuXHQgICAgdmFyIGNvbXBzID0gcGF0aC50b0xvd2VyQ2FzZSgpLnNwbGl0KCcvJyk7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbXBzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgLy8gU2VhcmNoIGZvciBhIGNoaWxkIG9iamVjdCB3aXRoIGEgY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaGluZyBrZXlcblx0ICAgICAgICB2YXIgbWF0Y2hpbmdDaGlsZCA9IG51bGw7XG5cdCAgICAgICAgZm9yICh2YXIga2V5IGluIGN1cnJlbnRDaGlsZCkge1xuXHQgICAgICAgICAgICBpZiAoa2V5LnRvTG93ZXJDYXNlKCkgPT09IGNvbXBzW2ldKSB7XG5cdCAgICAgICAgICAgICAgICBtYXRjaGluZ0NoaWxkID0gY3VycmVudENoaWxkW2tleV07XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBEaWRuJ3QgZmluZCBvbmUuIDonKFxuXHQgICAgICAgIGlmIChtYXRjaGluZ0NoaWxkID09PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBOb3cgY2hlY2sgdGhpcyBjaGlsZC4uLlxuXHQgICAgICAgIGN1cnJlbnRDaGlsZCA9IG1hdGNoaW5nQ2hpbGQ7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gY3VycmVudENoaWxkO1xuXHR9XG5cdGV4cG9ydHMuc2VhcmNoUGF0aCA9IHNlYXJjaFBhdGg7XG5cdC8vIFNlZTogaHR0cHM6Ly93d3cuaWV0Zi5vcmcvcmZjL3JmYzQxMjIudHh0IChTZWN0aW9uIDQuNClcblx0ZnVuY3Rpb24gdXVpZFY0KHJhbmRvbUJ5dGVzKSB7XG5cdCAgICB2YXIgYnl0ZXMgPSBsaWIkMS5hcnJheWlmeShyYW5kb21CeXRlcyk7XG5cdCAgICAvLyBTZWN0aW9uOiA0LjEuMzpcblx0ICAgIC8vIC0gdGltZV9oaV9hbmRfdmVyc2lvblsxMjoxNl0gPSAwYjAxMDBcblx0ICAgIGJ5dGVzWzZdID0gKGJ5dGVzWzZdICYgMHgwZikgfCAweDQwO1xuXHQgICAgLy8gU2VjdGlvbiA0LjRcblx0ICAgIC8vIC0gY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZFs2XSA9IDBiMFxuXHQgICAgLy8gLSBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkWzddID0gMGIxXG5cdCAgICBieXRlc1s4XSA9IChieXRlc1s4XSAmIDB4M2YpIHwgMHg4MDtcblx0ICAgIHZhciB2YWx1ZSA9IGxpYiQxLmhleGxpZnkoYnl0ZXMpO1xuXHQgICAgcmV0dXJuIFtcblx0ICAgICAgICB2YWx1ZS5zdWJzdHJpbmcoMiwgMTApLFxuXHQgICAgICAgIHZhbHVlLnN1YnN0cmluZygxMCwgMTQpLFxuXHQgICAgICAgIHZhbHVlLnN1YnN0cmluZygxNCwgMTgpLFxuXHQgICAgICAgIHZhbHVlLnN1YnN0cmluZygxOCwgMjIpLFxuXHQgICAgICAgIHZhbHVlLnN1YnN0cmluZygyMiwgMzQpLFxuXHQgICAgXS5qb2luKFwiLVwiKTtcblx0fVxuXHRleHBvcnRzLnV1aWRWNCA9IHV1aWRWNDtcblxuXHR9KTtcblxuXHR2YXIgdXRpbHMkMiA9IHVud3JhcEV4cG9ydHModXRpbHMkMSk7XG5cdHZhciB1dGlsc18xJDIgPSB1dGlscyQxLmxvb3NlQXJyYXlpZnk7XG5cdHZhciB1dGlsc18yID0gdXRpbHMkMS56cGFkO1xuXHR2YXIgdXRpbHNfMyA9IHV0aWxzJDEuZ2V0UGFzc3dvcmQ7XG5cdHZhciB1dGlsc180ID0gdXRpbHMkMS5zZWFyY2hQYXRoO1xuXHR2YXIgdXRpbHNfNSA9IHV0aWxzJDEudXVpZFY0O1xuXG5cdHZhciBjcm93ZHNhbGUgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19leHRlbmRzID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG5cdCAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcblx0ICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG5cdCAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cblx0ICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG5cdCAgICB9O1xuXHR9KSgpO1xuXHR2YXIgX19pbXBvcnREZWZhdWx0ID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuXHQgICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG5cdH07XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0dmFyIGFlc19qc18xID0gX19pbXBvcnREZWZhdWx0KGFlc0pzKTtcblxuXG5cblxuXG5cblxuXG5cdHZhciBsb2dnZXIgPSBuZXcgbGliLkxvZ2dlcihfdmVyc2lvbiRBLnZlcnNpb24pO1xuXG5cdHZhciBDcm93ZHNhbGVBY2NvdW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHQgICAgX19leHRlbmRzKENyb3dkc2FsZUFjY291bnQsIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBDcm93ZHNhbGVBY2NvdW50KCkge1xuXHQgICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblx0ICAgIH1cblx0ICAgIENyb3dkc2FsZUFjY291bnQucHJvdG90eXBlLmlzQ3Jvd2RzYWxlQWNjb3VudCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5faXNDcm93ZHNhbGVBY2NvdW50KTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gQ3Jvd2RzYWxlQWNjb3VudDtcblx0fShsaWIkMy5EZXNjcmlwdGlvbikpO1xuXHRleHBvcnRzLkNyb3dkc2FsZUFjY291bnQgPSBDcm93ZHNhbGVBY2NvdW50O1xuXHQvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9weWV0aHNhbGV0b29sXG5cdGZ1bmN0aW9uIGRlY3J5cHQoanNvbiwgcGFzc3dvcmQpIHtcblx0ICAgIHZhciBkYXRhID0gSlNPTi5wYXJzZShqc29uKTtcblx0ICAgIHBhc3N3b3JkID0gdXRpbHMkMS5nZXRQYXNzd29yZChwYXNzd29yZCk7XG5cdCAgICAvLyBFdGhlcmV1bSBBZGRyZXNzXG5cdCAgICB2YXIgZXRoYWRkciA9IGxpYiQ2LmdldEFkZHJlc3ModXRpbHMkMS5zZWFyY2hQYXRoKGRhdGEsIFwiZXRoYWRkclwiKSk7XG5cdCAgICAvLyBFbmNyeXB0ZWQgU2VlZFxuXHQgICAgdmFyIGVuY3NlZWQgPSB1dGlscyQxLmxvb3NlQXJyYXlpZnkodXRpbHMkMS5zZWFyY2hQYXRoKGRhdGEsIFwiZW5jc2VlZFwiKSk7XG5cdCAgICBpZiAoIWVuY3NlZWQgfHwgKGVuY3NlZWQubGVuZ3RoICUgMTYpICE9PSAwKSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZW5jc2VlZFwiLCBcImpzb25cIiwganNvbik7XG5cdCAgICB9XG5cdCAgICB2YXIga2V5ID0gbGliJDEuYXJyYXlpZnkoYnJvd3NlciQyLnBia2RmMihwYXNzd29yZCwgcGFzc3dvcmQsIDIwMDAsIDMyLCBcInNoYTI1NlwiKSkuc2xpY2UoMCwgMTYpO1xuXHQgICAgdmFyIGl2ID0gZW5jc2VlZC5zbGljZSgwLCAxNik7XG5cdCAgICB2YXIgZW5jcnlwdGVkU2VlZCA9IGVuY3NlZWQuc2xpY2UoMTYpO1xuXHQgICAgLy8gRGVjcnlwdCB0aGUgc2VlZFxuXHQgICAgdmFyIGFlc0NiYyA9IG5ldyBhZXNfanNfMS5kZWZhdWx0Lk1vZGVPZk9wZXJhdGlvbi5jYmMoa2V5LCBpdik7XG5cdCAgICB2YXIgc2VlZCA9IGFlc19qc18xLmRlZmF1bHQucGFkZGluZy5wa2NzNy5zdHJpcChsaWIkMS5hcnJheWlmeShhZXNDYmMuZGVjcnlwdChlbmNyeXB0ZWRTZWVkKSkpO1xuXHQgICAgLy8gVGhpcyB3YWxsZXQgZm9ybWF0IGlzIHdlaXJkLi4uIENvbnZlcnQgdGhlIGJpbmFyeSBlbmNvZGVkIGhleCB0byBhIHN0cmluZy5cblx0ICAgIHZhciBzZWVkSGV4ID0gXCJcIjtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VlZC5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHNlZWRIZXggKz0gU3RyaW5nLmZyb21DaGFyQ29kZShzZWVkW2ldKTtcblx0ICAgIH1cblx0ICAgIHZhciBzZWVkSGV4Qnl0ZXMgPSBsaWIkOC50b1V0ZjhCeXRlcyhzZWVkSGV4KTtcblx0ICAgIHZhciBwcml2YXRlS2V5ID0gbGliJDQua2VjY2FrMjU2KHNlZWRIZXhCeXRlcyk7XG5cdCAgICByZXR1cm4gbmV3IENyb3dkc2FsZUFjY291bnQoe1xuXHQgICAgICAgIF9pc0Nyb3dkc2FsZUFjY291bnQ6IHRydWUsXG5cdCAgICAgICAgYWRkcmVzczogZXRoYWRkcixcblx0ICAgICAgICBwcml2YXRlS2V5OiBwcml2YXRlS2V5XG5cdCAgICB9KTtcblx0fVxuXHRleHBvcnRzLmRlY3J5cHQgPSBkZWNyeXB0O1xuXG5cdH0pO1xuXG5cdHZhciBjcm93ZHNhbGUkMSA9IHVud3JhcEV4cG9ydHMoY3Jvd2RzYWxlKTtcblx0dmFyIGNyb3dkc2FsZV8xID0gY3Jvd2RzYWxlLkNyb3dkc2FsZUFjY291bnQ7XG5cdHZhciBjcm93ZHNhbGVfMiA9IGNyb3dkc2FsZS5kZWNyeXB0O1xuXG5cdHZhciBpbnNwZWN0ID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5cdGZ1bmN0aW9uIGlzQ3Jvd2RzYWxlV2FsbGV0KGpzb24pIHtcblx0ICAgIHZhciBkYXRhID0gbnVsbDtcblx0ICAgIHRyeSB7XG5cdCAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoanNvbik7XG5cdCAgICB9XG5cdCAgICBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gKGRhdGEuZW5jc2VlZCAmJiBkYXRhLmV0aGFkZHIpO1xuXHR9XG5cdGV4cG9ydHMuaXNDcm93ZHNhbGVXYWxsZXQgPSBpc0Nyb3dkc2FsZVdhbGxldDtcblx0ZnVuY3Rpb24gaXNLZXlzdG9yZVdhbGxldChqc29uKSB7XG5cdCAgICB2YXIgZGF0YSA9IG51bGw7XG5cdCAgICB0cnkge1xuXHQgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGpzb24pO1xuXHQgICAgfVxuXHQgICAgY2F0Y2ggKGVycm9yKSB7XG5cdCAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXHQgICAgaWYgKCFkYXRhLnZlcnNpb24gfHwgcGFyc2VJbnQoZGF0YS52ZXJzaW9uKSAhPT0gZGF0YS52ZXJzaW9uIHx8IHBhcnNlSW50KGRhdGEudmVyc2lvbikgIT09IDMpIHtcblx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cdCAgICAvLyBAVE9ETzogUHV0IG1vcmUgY2hlY2tzIHRvIG1ha2Ugc3VyZSBpdCBoYXMga2RmLCBpdiBhbmQgYWxsIHRoYXQgZ29vZCBzdHVmZlxuXHQgICAgcmV0dXJuIHRydWU7XG5cdH1cblx0ZXhwb3J0cy5pc0tleXN0b3JlV2FsbGV0ID0gaXNLZXlzdG9yZVdhbGxldDtcblx0Ly9leHBvcnQgZnVuY3Rpb24gaXNKc29uV2FsbGV0KGpzb246IHN0cmluZyk6IGJvb2xlYW4ge1xuXHQvLyAgICByZXR1cm4gKGlzU2VjcmV0U3RvcmFnZVdhbGxldChqc29uKSB8fCBpc0Nyb3dkc2FsZVdhbGxldChqc29uKSk7XG5cdC8vfVxuXHRmdW5jdGlvbiBnZXRKc29uV2FsbGV0QWRkcmVzcyhqc29uKSB7XG5cdCAgICBpZiAoaXNDcm93ZHNhbGVXYWxsZXQoanNvbikpIHtcblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICByZXR1cm4gbGliJDYuZ2V0QWRkcmVzcyhKU09OLnBhcnNlKGpzb24pLmV0aGFkZHIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgaWYgKGlzS2V5c3RvcmVXYWxsZXQoanNvbikpIHtcblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICByZXR1cm4gbGliJDYuZ2V0QWRkcmVzcyhKU09OLnBhcnNlKGpzb24pLmFkZHJlc3MpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIG51bGw7XG5cdH1cblx0ZXhwb3J0cy5nZXRKc29uV2FsbGV0QWRkcmVzcyA9IGdldEpzb25XYWxsZXRBZGRyZXNzO1xuXG5cdH0pO1xuXG5cdHZhciBpbnNwZWN0JDEgPSB1bndyYXBFeHBvcnRzKGluc3BlY3QpO1xuXHR2YXIgaW5zcGVjdF8xID0gaW5zcGVjdC5pc0Nyb3dkc2FsZVdhbGxldDtcblx0dmFyIGluc3BlY3RfMiA9IGluc3BlY3QuaXNLZXlzdG9yZVdhbGxldDtcblx0dmFyIGluc3BlY3RfMyA9IGluc3BlY3QuZ2V0SnNvbldhbGxldEFkZHJlc3M7XG5cblx0dmFyIHNjcnlwdCA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0KGZ1bmN0aW9uKHJvb3QpIHtcblx0ICAgIGNvbnN0IE1BWF9WQUxVRSA9IDB4N2ZmZmZmZmY7XG5cblx0ICAgIC8vIFRoZSBTSEEyNTYgYW5kIFBCS0RGMiBpbXBsZW1lbnRhdGlvbiBhcmUgZnJvbSBzY3J5cHQtYXN5bmMtanM6XG5cdCAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kY2hlc3Qvc2NyeXB0LWFzeW5jLWpzXG5cdCAgICBmdW5jdGlvbiBTSEEyNTYobSkge1xuXHQgICAgICAgIGNvbnN0IEsgPSBuZXcgVWludDMyQXJyYXkoW1xuXHQgICAgICAgICAgIDB4NDI4YTJmOTgsIDB4NzEzNzQ0OTEsIDB4YjVjMGZiY2YsIDB4ZTliNWRiYTUsIDB4Mzk1NmMyNWIsXG5cdCAgICAgICAgICAgMHg1OWYxMTFmMSwgMHg5MjNmODJhNCwgMHhhYjFjNWVkNSwgMHhkODA3YWE5OCwgMHgxMjgzNWIwMSxcblx0ICAgICAgICAgICAweDI0MzE4NWJlLCAweDU1MGM3ZGMzLCAweDcyYmU1ZDc0LCAweDgwZGViMWZlLCAweDliZGMwNmE3LFxuXHQgICAgICAgICAgIDB4YzE5YmYxNzQsIDB4ZTQ5YjY5YzEsIDB4ZWZiZTQ3ODYsIDB4MGZjMTlkYzYsIDB4MjQwY2ExY2MsXG5cdCAgICAgICAgICAgMHgyZGU5MmM2ZiwgMHg0YTc0ODRhYSwgMHg1Y2IwYTlkYywgMHg3NmY5ODhkYSwgMHg5ODNlNTE1Mixcblx0ICAgICAgICAgICAweGE4MzFjNjZkLCAweGIwMDMyN2M4LCAweGJmNTk3ZmM3LCAweGM2ZTAwYmYzLCAweGQ1YTc5MTQ3LFxuXHQgICAgICAgICAgIDB4MDZjYTYzNTEsIDB4MTQyOTI5NjcsIDB4MjdiNzBhODUsIDB4MmUxYjIxMzgsIDB4NGQyYzZkZmMsXG5cdCAgICAgICAgICAgMHg1MzM4MGQxMywgMHg2NTBhNzM1NCwgMHg3NjZhMGFiYiwgMHg4MWMyYzkyZSwgMHg5MjcyMmM4NSxcblx0ICAgICAgICAgICAweGEyYmZlOGExLCAweGE4MWE2NjRiLCAweGMyNGI4YjcwLCAweGM3NmM1MWEzLCAweGQxOTJlODE5LFxuXHQgICAgICAgICAgIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsIDB4MTlhNGMxMTYsIDB4MWUzNzZjMDgsXG5cdCAgICAgICAgICAgMHgyNzQ4Nzc0YywgMHgzNGIwYmNiNSwgMHgzOTFjMGNiMywgMHg0ZWQ4YWE0YSwgMHg1YjljY2E0Zixcblx0ICAgICAgICAgICAweDY4MmU2ZmYzLCAweDc0OGY4MmVlLCAweDc4YTU2MzZmLCAweDg0Yzg3ODE0LCAweDhjYzcwMjA4LFxuXHQgICAgICAgICAgIDB4OTBiZWZmZmEsIDB4YTQ1MDZjZWIsIDB4YmVmOWEzZjcsIDB4YzY3MTc4ZjJcblx0ICAgICAgIF0pO1xuXG5cdCAgICAgICAgbGV0IGgwID0gMHg2YTA5ZTY2NywgaDEgPSAweGJiNjdhZTg1LCBoMiA9IDB4M2M2ZWYzNzIsIGgzID0gMHhhNTRmZjUzYTtcblx0ICAgICAgICBsZXQgaDQgPSAweDUxMGU1MjdmLCBoNSA9IDB4OWIwNTY4OGMsIGg2ID0gMHgxZjgzZDlhYiwgaDcgPSAweDViZTBjZDE5O1xuXHQgICAgICAgIGNvbnN0IHcgPSBuZXcgVWludDMyQXJyYXkoNjQpO1xuXG5cdCAgICAgICAgZnVuY3Rpb24gYmxvY2tzKHApIHtcblx0ICAgICAgICAgICAgbGV0IG9mZiA9IDAsIGxlbiA9IHAubGVuZ3RoO1xuXHQgICAgICAgICAgICB3aGlsZSAobGVuID49IDY0KSB7XG5cdCAgICAgICAgICAgICAgICBsZXQgYSA9IGgwLCBiID0gaDEsIGMgPSBoMiwgZCA9IGgzLCBlID0gaDQsIGYgPSBoNSwgZyA9IGg2LCBoID0gaDcsIHUsIGksIGosIHQxLCB0MjtcblxuXHQgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBqID0gb2ZmICsgaSo0O1xuXHQgICAgICAgICAgICAgICAgICAgIHdbaV0gPSAoKHBbal0gJiAweGZmKTw8MjQpIHwgKChwW2orMV0gJiAweGZmKTw8MTYpIHxcblx0ICAgICAgICAgICAgICAgICAgICAoKHBbaisyXSAmIDB4ZmYpPDw4KSB8IChwW2orM10gJiAweGZmKTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgZm9yIChpID0gMTY7IGkgPCA2NDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdSA9IHdbaS0yXTtcblx0ICAgICAgICAgICAgICAgICAgICB0MSA9ICgodT4+PjE3KSB8ICh1PDwoMzItMTcpKSkgXiAoKHU+Pj4xOSkgfCAodTw8KDMyLTE5KSkpIF4gKHU+Pj4xMCk7XG5cblx0ICAgICAgICAgICAgICAgICAgICB1ID0gd1tpLTE1XTtcblx0ICAgICAgICAgICAgICAgICAgICB0MiA9ICgodT4+PjcpIHwgKHU8PCgzMi03KSkpIF4gKCh1Pj4+MTgpIHwgKHU8PCgzMi0xOCkpKSBeICh1Pj4+Myk7XG5cblx0ICAgICAgICAgICAgICAgICAgICB3W2ldID0gKCgodDEgKyB3W2ktN10pIHwgMCkgKyAoKHQyICsgd1tpLTE2XSkgfCAwKSkgfCAwO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHQxID0gKCgoKCgoZT4+PjYpIHwgKGU8PCgzMi02KSkpIF4gKChlPj4+MTEpIHwgKGU8PCgzMi0xMSkpKSBeXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKChlPj4+MjUpIHwgKGU8PCgzMi0yNSkpKSkgKyAoKGUgJiBmKSBeICh+ZSAmIGcpKSkgfCAwKSArXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgKChoICsgKChLW2ldICsgd1tpXSkgfCAwKSkgfCAwKSkgfCAwO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgdDIgPSAoKCgoYT4+PjIpIHwgKGE8PCgzMi0yKSkpIF4gKChhPj4+MTMpIHwgKGE8PCgzMi0xMykpKSBeXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICgoYT4+PjIyKSB8IChhPDwoMzItMjIpKSkpICsgKChhICYgYikgXiAoYSAmIGMpIF4gKGIgJiBjKSkpIHwgMDtcblxuXHQgICAgICAgICAgICAgICAgICAgIGggPSBnO1xuXHQgICAgICAgICAgICAgICAgICAgIGcgPSBmO1xuXHQgICAgICAgICAgICAgICAgICAgIGYgPSBlO1xuXHQgICAgICAgICAgICAgICAgICAgIGUgPSAoZCArIHQxKSB8IDA7XG5cdCAgICAgICAgICAgICAgICAgICAgZCA9IGM7XG5cdCAgICAgICAgICAgICAgICAgICAgYyA9IGI7XG5cdCAgICAgICAgICAgICAgICAgICAgYiA9IGE7XG5cdCAgICAgICAgICAgICAgICAgICAgYSA9ICh0MSArIHQyKSB8IDA7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIGgwID0gKGgwICsgYSkgfCAwO1xuXHQgICAgICAgICAgICAgICAgaDEgPSAoaDEgKyBiKSB8IDA7XG5cdCAgICAgICAgICAgICAgICBoMiA9IChoMiArIGMpIHwgMDtcblx0ICAgICAgICAgICAgICAgIGgzID0gKGgzICsgZCkgfCAwO1xuXHQgICAgICAgICAgICAgICAgaDQgPSAoaDQgKyBlKSB8IDA7XG5cdCAgICAgICAgICAgICAgICBoNSA9IChoNSArIGYpIHwgMDtcblx0ICAgICAgICAgICAgICAgIGg2ID0gKGg2ICsgZykgfCAwO1xuXHQgICAgICAgICAgICAgICAgaDcgPSAoaDcgKyBoKSB8IDA7XG5cblx0ICAgICAgICAgICAgICAgIG9mZiArPSA2NDtcblx0ICAgICAgICAgICAgICAgIGxlbiAtPSA2NDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGJsb2NrcyhtKTtcblxuXHQgICAgICAgIGxldCBpLCBieXRlc0xlZnQgPSBtLmxlbmd0aCAlIDY0LFxuXHQgICAgICAgIGJpdExlbkhpID0gKG0ubGVuZ3RoIC8gMHgyMDAwMDAwMCkgfCAwLFxuXHQgICAgICAgIGJpdExlbkxvID0gbS5sZW5ndGggPDwgMyxcblx0ICAgICAgICBudW1aZXJvcyA9IChieXRlc0xlZnQgPCA1NikgPyA1NiA6IDEyMCxcblx0ICAgICAgICBwID0gbS5zbGljZShtLmxlbmd0aCAtIGJ5dGVzTGVmdCwgbS5sZW5ndGgpO1xuXG5cdCAgICAgICAgcC5wdXNoKDB4ODApO1xuXHQgICAgICAgIGZvciAoaSA9IGJ5dGVzTGVmdCArIDE7IGkgPCBudW1aZXJvczsgaSsrKSB7IHAucHVzaCgwKTsgfVxuXHQgICAgICAgIHAucHVzaCgoYml0TGVuSGkgPj4+IDI0KSAmIDB4ZmYpO1xuXHQgICAgICAgIHAucHVzaCgoYml0TGVuSGkgPj4+IDE2KSAmIDB4ZmYpO1xuXHQgICAgICAgIHAucHVzaCgoYml0TGVuSGkgPj4+IDgpICAmIDB4ZmYpO1xuXHQgICAgICAgIHAucHVzaCgoYml0TGVuSGkgPj4+IDApICAmIDB4ZmYpO1xuXHQgICAgICAgIHAucHVzaCgoYml0TGVuTG8gPj4+IDI0KSAmIDB4ZmYpO1xuXHQgICAgICAgIHAucHVzaCgoYml0TGVuTG8gPj4+IDE2KSAmIDB4ZmYpO1xuXHQgICAgICAgIHAucHVzaCgoYml0TGVuTG8gPj4+IDgpICAmIDB4ZmYpO1xuXHQgICAgICAgIHAucHVzaCgoYml0TGVuTG8gPj4+IDApICAmIDB4ZmYpO1xuXG5cdCAgICAgICAgYmxvY2tzKHApO1xuXG5cdCAgICAgICAgcmV0dXJuIFtcblx0ICAgICAgICAgICAgKGgwID4+PiAyNCkgJiAweGZmLCAoaDAgPj4+IDE2KSAmIDB4ZmYsIChoMCA+Pj4gOCkgJiAweGZmLCAoaDAgPj4+IDApICYgMHhmZixcblx0ICAgICAgICAgICAgKGgxID4+PiAyNCkgJiAweGZmLCAoaDEgPj4+IDE2KSAmIDB4ZmYsIChoMSA+Pj4gOCkgJiAweGZmLCAoaDEgPj4+IDApICYgMHhmZixcblx0ICAgICAgICAgICAgKGgyID4+PiAyNCkgJiAweGZmLCAoaDIgPj4+IDE2KSAmIDB4ZmYsIChoMiA+Pj4gOCkgJiAweGZmLCAoaDIgPj4+IDApICYgMHhmZixcblx0ICAgICAgICAgICAgKGgzID4+PiAyNCkgJiAweGZmLCAoaDMgPj4+IDE2KSAmIDB4ZmYsIChoMyA+Pj4gOCkgJiAweGZmLCAoaDMgPj4+IDApICYgMHhmZixcblx0ICAgICAgICAgICAgKGg0ID4+PiAyNCkgJiAweGZmLCAoaDQgPj4+IDE2KSAmIDB4ZmYsIChoNCA+Pj4gOCkgJiAweGZmLCAoaDQgPj4+IDApICYgMHhmZixcblx0ICAgICAgICAgICAgKGg1ID4+PiAyNCkgJiAweGZmLCAoaDUgPj4+IDE2KSAmIDB4ZmYsIChoNSA+Pj4gOCkgJiAweGZmLCAoaDUgPj4+IDApICYgMHhmZixcblx0ICAgICAgICAgICAgKGg2ID4+PiAyNCkgJiAweGZmLCAoaDYgPj4+IDE2KSAmIDB4ZmYsIChoNiA+Pj4gOCkgJiAweGZmLCAoaDYgPj4+IDApICYgMHhmZixcblx0ICAgICAgICAgICAgKGg3ID4+PiAyNCkgJiAweGZmLCAoaDcgPj4+IDE2KSAmIDB4ZmYsIChoNyA+Pj4gOCkgJiAweGZmLCAoaDcgPj4+IDApICYgMHhmZlxuXHQgICAgICAgIF07XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIFBCS0RGMl9ITUFDX1NIQTI1Nl9PbmVJdGVyKHBhc3N3b3JkLCBzYWx0LCBka0xlbikge1xuXHQgICAgICAgIC8vIGNvbXByZXNzIHBhc3N3b3JkIGlmIGl0J3MgbG9uZ2VyIHRoYW4gaGFzaCBibG9jayBsZW5ndGhcblx0ICAgICAgICBwYXNzd29yZCA9IChwYXNzd29yZC5sZW5ndGggPD0gNjQpID8gcGFzc3dvcmQgOiBTSEEyNTYocGFzc3dvcmQpO1xuXG5cdCAgICAgICAgY29uc3QgaW5uZXJMZW4gPSA2NCArIHNhbHQubGVuZ3RoICsgNDtcblx0ICAgICAgICBjb25zdCBpbm5lciA9IG5ldyBBcnJheShpbm5lckxlbik7XG5cdCAgICAgICAgY29uc3Qgb3V0ZXJLZXkgPSBuZXcgQXJyYXkoNjQpO1xuXG5cdCAgICAgICAgbGV0IGk7XG5cdCAgICAgICAgbGV0IGRrID0gW107XG5cblx0ICAgICAgICAvLyBpbm5lciA9IChwYXNzd29yZCBeIGlwYWQpIHx8IHNhbHQgfHwgY291bnRlclxuXHQgICAgICAgIGZvciAoaSA9IDA7IGkgPCA2NDsgaSsrKSB7IGlubmVyW2ldID0gMHgzNjsgfVxuXHQgICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYXNzd29yZC5sZW5ndGg7IGkrKykgeyBpbm5lcltpXSBePSBwYXNzd29yZFtpXTsgfVxuXHQgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzYWx0Lmxlbmd0aDsgaSsrKSB7IGlubmVyWzY0ICsgaV0gPSBzYWx0W2ldOyB9XG5cdCAgICAgICAgZm9yIChpID0gaW5uZXJMZW4gLSA0OyBpIDwgaW5uZXJMZW47IGkrKykgeyBpbm5lcltpXSA9IDA7IH1cblxuXHQgICAgICAgIC8vIG91dGVyS2V5ID0gcGFzc3dvcmQgXiBvcGFkXG5cdCAgICAgICAgZm9yIChpID0gMDsgaSA8IDY0OyBpKyspIG91dGVyS2V5W2ldID0gMHg1Yztcblx0ICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFzc3dvcmQubGVuZ3RoOyBpKyspIG91dGVyS2V5W2ldIF49IHBhc3N3b3JkW2ldO1xuXG5cdCAgICAgICAgLy8gaW5jcmVtZW50cyBjb3VudGVyIGluc2lkZSBpbm5lclxuXHQgICAgICAgIGZ1bmN0aW9uIGluY3JlbWVudENvdW50ZXIoKSB7XG5cdCAgICAgICAgICAgIGZvciAobGV0IGkgPSBpbm5lckxlbiAtIDE7IGkgPj0gaW5uZXJMZW4gLSA0OyBpLS0pIHtcblx0ICAgICAgICAgICAgICAgIGlubmVyW2ldKys7XG5cdCAgICAgICAgICAgICAgICBpZiAoaW5uZXJbaV0gPD0gMHhmZikgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgaW5uZXJbaV0gPSAwO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gb3V0cHV0IGJsb2NrcyA9IFNIQTI1NihvdXRlcktleSB8fCBTSEEyNTYoaW5uZXIpKSAuLi5cblx0ICAgICAgICB3aGlsZSAoZGtMZW4gPj0gMzIpIHtcblx0ICAgICAgICAgICAgaW5jcmVtZW50Q291bnRlcigpO1xuXHQgICAgICAgICAgICBkayA9IGRrLmNvbmNhdChTSEEyNTYob3V0ZXJLZXkuY29uY2F0KFNIQTI1Nihpbm5lcikpKSk7XG5cdCAgICAgICAgICAgIGRrTGVuIC09IDMyO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoZGtMZW4gPiAwKSB7XG5cdCAgICAgICAgICAgIGluY3JlbWVudENvdW50ZXIoKTtcblx0ICAgICAgICAgICAgZGsgPSBkay5jb25jYXQoU0hBMjU2KG91dGVyS2V5LmNvbmNhdChTSEEyNTYoaW5uZXIpKSkuc2xpY2UoMCwgZGtMZW4pKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gZGs7XG5cdCAgICB9XG5cblx0ICAgIC8vIFRoZSBmb2xsb3dpbmcgaXMgYW4gYWRhcHRhdGlvbiBvZiBzY3J5cHRzeVxuXHQgICAgLy8gU2VlOiBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9zY3J5cHRzeVxuXHQgICAgZnVuY3Rpb24gYmxvY2ttaXhfc2Fsc2E4KEJZLCBZaSwgciwgeCwgX1gpIHtcblx0ICAgICAgICBsZXQgaTtcblxuXHQgICAgICAgIGFycmF5Y29weShCWSwgKDIgKiByIC0gMSkgKiAxNiwgX1gsIDAsIDE2KTtcblx0ICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMiAqIHI7IGkrKykge1xuXHQgICAgICAgICAgICBibG9ja3hvcihCWSwgaSAqIDE2LCBfWCwgMTYpO1xuXHQgICAgICAgICAgICBzYWxzYTIwXzgoX1gsIHgpO1xuXHQgICAgICAgICAgICBhcnJheWNvcHkoX1gsIDAsIEJZLCBZaSArIChpICogMTYpLCAxNik7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgZm9yIChpID0gMDsgaSA8IHI7IGkrKykge1xuXHQgICAgICAgICAgICBhcnJheWNvcHkoQlksIFlpICsgKGkgKiAyKSAqIDE2LCBCWSwgKGkgKiAxNiksIDE2KTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcjsgaSsrKSB7XG5cdCAgICAgICAgICAgIGFycmF5Y29weShCWSwgWWkgKyAoaSAqIDIgKyAxKSAqIDE2LCBCWSwgKGkgKyByKSAqIDE2LCAxNik7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBSKGEsIGIpIHtcblx0ICAgICAgICByZXR1cm4gKGEgPDwgYikgfCAoYSA+Pj4gKDMyIC0gYikpO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBzYWxzYTIwXzgoQiwgeCkge1xuXHQgICAgICAgIGFycmF5Y29weShCLCAwLCB4LCAwLCAxNik7XG5cblx0ICAgICAgICBmb3IgKGxldCBpID0gODsgaSA+IDA7IGkgLT0gMikge1xuXHQgICAgICAgICAgICB4WyA0XSBePSBSKHhbIDBdICsgeFsxMl0sIDcpO1xuXHQgICAgICAgICAgICB4WyA4XSBePSBSKHhbIDRdICsgeFsgMF0sIDkpO1xuXHQgICAgICAgICAgICB4WzEyXSBePSBSKHhbIDhdICsgeFsgNF0sIDEzKTtcblx0ICAgICAgICAgICAgeFsgMF0gXj0gUih4WzEyXSArIHhbIDhdLCAxOCk7XG5cdCAgICAgICAgICAgIHhbIDldIF49IFIoeFsgNV0gKyB4WyAxXSwgNyk7XG5cdCAgICAgICAgICAgIHhbMTNdIF49IFIoeFsgOV0gKyB4WyA1XSwgOSk7XG5cdCAgICAgICAgICAgIHhbIDFdIF49IFIoeFsxM10gKyB4WyA5XSwgMTMpO1xuXHQgICAgICAgICAgICB4WyA1XSBePSBSKHhbIDFdICsgeFsxM10sIDE4KTtcblx0ICAgICAgICAgICAgeFsxNF0gXj0gUih4WzEwXSArIHhbIDZdLCA3KTtcblx0ICAgICAgICAgICAgeFsgMl0gXj0gUih4WzE0XSArIHhbMTBdLCA5KTtcblx0ICAgICAgICAgICAgeFsgNl0gXj0gUih4WyAyXSArIHhbMTRdLCAxMyk7XG5cdCAgICAgICAgICAgIHhbMTBdIF49IFIoeFsgNl0gKyB4WyAyXSwgMTgpO1xuXHQgICAgICAgICAgICB4WyAzXSBePSBSKHhbMTVdICsgeFsxMV0sIDcpO1xuXHQgICAgICAgICAgICB4WyA3XSBePSBSKHhbIDNdICsgeFsxNV0sIDkpO1xuXHQgICAgICAgICAgICB4WzExXSBePSBSKHhbIDddICsgeFsgM10sIDEzKTtcblx0ICAgICAgICAgICAgeFsxNV0gXj0gUih4WzExXSArIHhbIDddLCAxOCk7XG5cdCAgICAgICAgICAgIHhbIDFdIF49IFIoeFsgMF0gKyB4WyAzXSwgNyk7XG5cdCAgICAgICAgICAgIHhbIDJdIF49IFIoeFsgMV0gKyB4WyAwXSwgOSk7XG5cdCAgICAgICAgICAgIHhbIDNdIF49IFIoeFsgMl0gKyB4WyAxXSwgMTMpO1xuXHQgICAgICAgICAgICB4WyAwXSBePSBSKHhbIDNdICsgeFsgMl0sIDE4KTtcblx0ICAgICAgICAgICAgeFsgNl0gXj0gUih4WyA1XSArIHhbIDRdLCA3KTtcblx0ICAgICAgICAgICAgeFsgN10gXj0gUih4WyA2XSArIHhbIDVdLCA5KTtcblx0ICAgICAgICAgICAgeFsgNF0gXj0gUih4WyA3XSArIHhbIDZdLCAxMyk7XG5cdCAgICAgICAgICAgIHhbIDVdIF49IFIoeFsgNF0gKyB4WyA3XSwgMTgpO1xuXHQgICAgICAgICAgICB4WzExXSBePSBSKHhbMTBdICsgeFsgOV0sIDcpO1xuXHQgICAgICAgICAgICB4WyA4XSBePSBSKHhbMTFdICsgeFsxMF0sIDkpO1xuXHQgICAgICAgICAgICB4WyA5XSBePSBSKHhbIDhdICsgeFsxMV0sIDEzKTtcblx0ICAgICAgICAgICAgeFsxMF0gXj0gUih4WyA5XSArIHhbIDhdLCAxOCk7XG5cdCAgICAgICAgICAgIHhbMTJdIF49IFIoeFsxNV0gKyB4WzE0XSwgNyk7XG5cdCAgICAgICAgICAgIHhbMTNdIF49IFIoeFsxMl0gKyB4WzE1XSwgOSk7XG5cdCAgICAgICAgICAgIHhbMTRdIF49IFIoeFsxM10gKyB4WzEyXSwgMTMpO1xuXHQgICAgICAgICAgICB4WzE1XSBePSBSKHhbMTRdICsgeFsxM10sIDE4KTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyArK2kpIHtcblx0ICAgICAgICAgICAgQltpXSArPSB4W2ldO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgLy8gbmFpdmUgYXBwcm9hY2guLi4gZ29pbmcgYmFjayB0byBsb29wIHVucm9sbGluZyBtYXkgeWllbGQgYWRkaXRpb25hbCBwZXJmb3JtYW5jZVxuXHQgICAgZnVuY3Rpb24gYmxvY2t4b3IoUywgU2ksIEQsIGxlbikge1xuXHQgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0ICAgICAgICAgICAgRFtpXSBePSBTW1NpICsgaV07XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBhcnJheWNvcHkoc3JjLCBzcmNQb3MsIGRlc3QsIGRlc3RQb3MsIGxlbmd0aCkge1xuXHQgICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuXHQgICAgICAgICAgICBkZXN0W2Rlc3RQb3MrK10gPSBzcmNbc3JjUG9zKytdO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gY2hlY2tCdWZmZXJpc2gobykge1xuXHQgICAgICAgIGlmICghbyB8fCB0eXBlb2Yoby5sZW5ndGgpICE9PSAnbnVtYmVyJykgeyByZXR1cm4gZmFsc2U7IH1cblxuXHQgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgby5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICBjb25zdCB2ID0gb1tpXTtcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZih2KSAhPT0gJ251bWJlcicgfHwgdiAlIDEgfHwgdiA8IDAgfHwgdiA+PSAyNTYpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBlbnN1cmVJbnRlZ2VyKHZhbHVlLCBuYW1lKSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZih2YWx1ZSkgIT09IFwibnVtYmVyXCIgfHwgKHZhbHVlICUgMSkpIHsgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkICcgKyBuYW1lKTsgfVxuXHQgICAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgIH1cblxuXHQgICAgLy8gTiA9IENwdSBjb3N0LCByID0gTWVtb3J5IGNvc3QsIHAgPSBwYXJhbGxlbGl6YXRpb24gY29zdFxuXHQgICAgLy8gY2FsbGJhY2soZXJyb3IsIHByb2dyZXNzLCBrZXkpXG5cdCAgICBmdW5jdGlvbiBfc2NyeXB0KHBhc3N3b3JkLCBzYWx0LCBOLCByLCBwLCBka0xlbiwgY2FsbGJhY2spIHtcblxuXHQgICAgICAgIE4gPSBlbnN1cmVJbnRlZ2VyKE4sICdOJyk7XG5cdCAgICAgICAgciA9IGVuc3VyZUludGVnZXIociwgJ3InKTtcblx0ICAgICAgICBwID0gZW5zdXJlSW50ZWdlcihwLCAncCcpO1xuXG5cdCAgICAgICAgZGtMZW4gPSBlbnN1cmVJbnRlZ2VyKGRrTGVuLCAnZGtMZW4nKTtcblxuXHQgICAgICAgIGlmIChOID09PSAwIHx8IChOICYgKE4gLSAxKSkgIT09IDApIHsgdGhyb3cgbmV3IEVycm9yKCdOIG11c3QgYmUgcG93ZXIgb2YgMicpOyB9XG5cblx0ICAgICAgICBpZiAoTiA+IE1BWF9WQUxVRSAvIDEyOCAvIHIpIHsgdGhyb3cgbmV3IEVycm9yKCdOIHRvbyBsYXJnZScpOyB9XG5cdCAgICAgICAgaWYgKHIgPiBNQVhfVkFMVUUgLyAxMjggLyBwKSB7IHRocm93IG5ldyBFcnJvcignciB0b28gbGFyZ2UnKTsgfVxuXG5cdCAgICAgICAgaWYgKCFjaGVja0J1ZmZlcmlzaChwYXNzd29yZCkpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYXNzd29yZCBtdXN0IGJlIGFuIGFycmF5IG9yIGJ1ZmZlcicpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBwYXNzd29yZCA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHBhc3N3b3JkKTtcblxuXHQgICAgICAgIGlmICghY2hlY2tCdWZmZXJpc2goc2FsdCkpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzYWx0IG11c3QgYmUgYW4gYXJyYXkgb3IgYnVmZmVyJyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHNhbHQgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChzYWx0KTtcblxuXHQgICAgICAgIGxldCBiID0gUEJLREYyX0hNQUNfU0hBMjU2X09uZUl0ZXIocGFzc3dvcmQsIHNhbHQsIHAgKiAxMjggKiByKTtcblx0ICAgICAgICBjb25zdCBCID0gbmV3IFVpbnQzMkFycmF5KHAgKiAzMiAqIHIpO1xuXHQgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgQi5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICBjb25zdCBqID0gaSAqIDQ7XG5cdCAgICAgICAgICAgIEJbaV0gPSAoKGJbaiArIDNdICYgMHhmZikgPDwgMjQpIHxcblx0ICAgICAgICAgICAgICAgICAgICgoYltqICsgMl0gJiAweGZmKSA8PCAxNikgfFxuXHQgICAgICAgICAgICAgICAgICAgKChiW2ogKyAxXSAmIDB4ZmYpIDw8IDgpIHxcblx0ICAgICAgICAgICAgICAgICAgICgoYltqICsgMF0gJiAweGZmKSA8PCAwKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBjb25zdCBYWSA9IG5ldyBVaW50MzJBcnJheSg2NCAqIHIpO1xuXHQgICAgICAgIGNvbnN0IFYgPSBuZXcgVWludDMyQXJyYXkoMzIgKiByICogTik7XG5cblx0ICAgICAgICBjb25zdCBZaSA9IDMyICogcjtcblxuXHQgICAgICAgIC8vIHNjcmF0Y2ggc3BhY2Vcblx0ICAgICAgICBjb25zdCB4ID0gbmV3IFVpbnQzMkFycmF5KDE2KTsgICAgICAgLy8gc2Fsc2EyMF84XG5cdCAgICAgICAgY29uc3QgX1ggPSBuZXcgVWludDMyQXJyYXkoMTYpOyAgICAgIC8vIGJsb2NrbWl4X3NhbHNhOFxuXG5cdCAgICAgICAgY29uc3QgdG90YWxPcHMgPSBwICogTiAqIDI7XG5cdCAgICAgICAgbGV0IGN1cnJlbnRPcCA9IDA7XG5cdCAgICAgICAgbGV0IGxhc3RQZXJjZW50MTAgPSBudWxsO1xuXG5cdCAgICAgICAgLy8gU2V0IHRoaXMgdG8gdHJ1ZSB0byBhYmFuZG9uIHRoZSBzY3J5cHQgb24gdGhlIG5leHQgc3RlcFxuXHQgICAgICAgIGxldCBzdG9wID0gZmFsc2U7XG5cblx0ICAgICAgICAvLyBTdGF0ZSBpbmZvcm1hdGlvblxuXHQgICAgICAgIGxldCBzdGF0ZSA9IDA7XG5cdCAgICAgICAgbGV0IGkwID0gMCwgaTE7XG5cdCAgICAgICAgbGV0IEJpO1xuXG5cdCAgICAgICAgLy8gSG93IG1hbnkgYmxvY2ttaXhfc2Fsc2E4IGNhbiB3ZSBkbyBwZXIgc3RlcD9cblx0ICAgICAgICBjb25zdCBsaW1pdCA9IGNhbGxiYWNrID8gcGFyc2VJbnQoMTAwMCAvIHIpOiAweGZmZmZmZmZmO1xuXG5cdCAgICAgICAgLy8gVHJpY2sgZnJvbSBzY3J5cHQtYXN5bmM7IGlmIHRoZXJlIGlzIGEgc2V0SW1tZWRpYXRlIHNoaW0gaW4gcGxhY2UsIHVzZSBpdFxuXHQgICAgICAgIGNvbnN0IG5leHRUaWNrID0gKHR5cGVvZihzZXRJbW1lZGlhdGUpICE9PSAndW5kZWZpbmVkJykgPyBzZXRJbW1lZGlhdGUgOiBzZXRUaW1lb3V0O1xuXG5cdCAgICAgICAgLy8gVGhpcyBpcyByZWFsbHkgYWxsIEkgY2hhbmdlZDsgbWFraW5nIHNjcnlwdHN5IGEgc3RhdGUgbWFjaGluZSBzbyB3ZSBvY2Nhc2lvbmFsbHlcblx0ICAgICAgICAvLyBzdG9wIGFuZCBnaXZlIG90aGVyIGV2bnRzIG9uIHRoZSBldm50IGxvb3AgYSBjaGFuY2UgdG8gcnVuLiB+UmljTW9vXG5cdCAgICAgICAgY29uc3QgaW5jcmVtZW50YWxTTWl4ID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIGlmIChzdG9wKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKCdjYW5jZWxsZWQnKSwgY3VycmVudE9wIC8gdG90YWxPcHMpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgbGV0IHN0ZXBzO1xuXG5cdCAgICAgICAgICAgIHN3aXRjaCAoc3RhdGUpIHtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMDpcblx0ICAgICAgICAgICAgICAgICAgICAvLyBmb3IgKHZhciBpID0gMDsgaSA8IHA7IGkrKykuLi5cblx0ICAgICAgICAgICAgICAgICAgICBCaSA9IGkwICogMzIgKiByO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgYXJyYXljb3B5KEIsIEJpLCBYWSwgMCwgWWkpOyAgICAgICAgICAgICAgICAgICAgICAgLy8gUk9NaXggLSAxXG5cblx0ICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IDE7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNb3ZlIHRvIFJPTWl4IDJcblx0ICAgICAgICAgICAgICAgICAgICBpMSA9IDA7XG5cblx0ICAgICAgICAgICAgICAgICAgICAvLyBGYWxsIHRocm91Z2hcblxuXHQgICAgICAgICAgICAgICAgY2FzZSAxOlxuXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gUnVuIHVwIHRvIDEwMDAgc3RlcHMgb2YgdGhlIGZpcnN0IGlubmVyIHNtaXggbG9vcFxuXHQgICAgICAgICAgICAgICAgICAgIHN0ZXBzID0gTiAtIGkxO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChzdGVwcyA+IGxpbWl0KSB7IHN0ZXBzID0gbGltaXQ7IH1cblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ZXBzOyBpKyspIHsgICAgICAgICAgICAgICAgICAvLyBST01peCAtIDJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXljb3B5KFhZLCAwLCBWLCAoaTEgKyBpKSAqIFlpLCBZaSk7ICAgICAgICAgLy8gUk9NaXggLSAzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrbWl4X3NhbHNhOChYWSwgWWksIHIsIHgsIF9YKTsgICAgICAgICAgICAgLy8gUk9NaXggLSA0XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspXG5cdCAgICAgICAgICAgICAgICAgICAgaTEgKz0gc3RlcHM7XG5cdCAgICAgICAgICAgICAgICAgICAgY3VycmVudE9wICs9IHN0ZXBzO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbGwgdGhlIGNhbGxiYWNrIHdpdGggdGhlIHByb2dyZXNzIChvcHRpb25hbGx5IHN0b3BwaW5nIHVzKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwZXJjZW50MTAgPSBwYXJzZUludCgxMDAwICogY3VycmVudE9wIC8gdG90YWxPcHMpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGVyY2VudDEwICE9PSBsYXN0UGVyY2VudDEwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9wID0gY2FsbGJhY2sobnVsbCwgY3VycmVudE9wIC8gdG90YWxPcHMpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0b3ApIHsgYnJlYWs7IH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RQZXJjZW50MTAgPSBwZXJjZW50MTA7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICBpZiAoaTEgPCBOKSB7IGJyZWFrOyB9XG5cblx0ICAgICAgICAgICAgICAgICAgICBpMSA9IDA7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTW92ZSB0byBST01peCA2XG5cdCAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAyO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gRmFsbCB0aHJvdWdoXG5cblx0ICAgICAgICAgICAgICAgIGNhc2UgMjpcblxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFJ1biB1cCB0byAxMDAwIHN0ZXBzIG9mIHRoZSBzZWNvbmQgaW5uZXIgc21peCBsb29wXG5cdCAgICAgICAgICAgICAgICAgICAgc3RlcHMgPSBOIC0gaTE7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHN0ZXBzID4gbGltaXQpIHsgc3RlcHMgPSBsaW1pdDsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RlcHM7IGkrKykgeyAgICAgICAgICAgICAgICAvLyBST01peCAtIDZcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gKDIgKiByIC0gMSkgKiAxNjsgICAgICAgICAgICAgLy8gUk9NaXggLSA3XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGogPSBYWVtvZmZzZXRdICYgKE4gLSAxKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2t4b3IoViwgaiAqIFlpLCBYWSwgWWkpOyAgICAgICAgICAgICAgICAgLy8gUk9NaXggLSA4IChpbm5lcilcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2ttaXhfc2Fsc2E4KFhZLCBZaSwgciwgeCwgX1gpOyAgICAgICAgICAgLy8gUk9NaXggLSA5IChvdXRlcilcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICAvLyBmb3IgKHZhciBpID0gMDsgaSA8IE47IGkrKykuLi5cblx0ICAgICAgICAgICAgICAgICAgICBpMSArPSBzdGVwcztcblx0ICAgICAgICAgICAgICAgICAgICBjdXJyZW50T3AgKz0gc3RlcHM7XG5cblx0ICAgICAgICAgICAgICAgICAgICAvLyBDYWxsIHRoZSBjYWxsYmFjayB3aXRoIHRoZSBwcm9ncmVzcyAob3B0aW9uYWxseSBzdG9wcGluZyB1cylcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGVyY2VudDEwID0gcGFyc2VJbnQoMTAwMCAqIGN1cnJlbnRPcCAvIHRvdGFsT3BzKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBlcmNlbnQxMCAhPT0gbGFzdFBlcmNlbnQxMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcCA9IGNhbGxiYWNrKG51bGwsIGN1cnJlbnRPcCAvIHRvdGFsT3BzKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdG9wKSB7IGJyZWFrOyB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0UGVyY2VudDEwID0gcGVyY2VudDEwO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGkxIDwgTikgeyBicmVhazsgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgYXJyYXljb3B5KFhZLCAwLCBCLCBCaSwgWWkpOyAgICAgICAgICAgICAgICAgICAgIC8vIFJPTWl4IC0gMTBcblxuXHQgICAgICAgICAgICAgICAgICAgIC8vIGZvciAodmFyIGkgPSAwOyBpIDwgcDsgaSsrKS4uLlxuXHQgICAgICAgICAgICAgICAgICAgIGkwKys7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGkwIDwgcCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IDA7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgIGIgPSBbXTtcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEIubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYi5wdXNoKChCW2ldID4+ICAwKSAmIDB4ZmYpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBiLnB1c2goKEJbaV0gPj4gIDgpICYgMHhmZik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGIucHVzaCgoQltpXSA+PiAxNikgJiAweGZmKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYi5wdXNoKChCW2ldID4+IDI0KSAmIDB4ZmYpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlcml2ZWRLZXkgPSBQQktERjJfSE1BQ19TSEEyNTZfT25lSXRlcihwYXNzd29yZCwgYiwgZGtMZW4pO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gU2VuZCB0aGUgcmVzdWx0IHRvIHRoZSBjYWxsYmFja1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhudWxsLCAxLjAsIGRlcml2ZWRLZXkpOyB9XG5cblx0ICAgICAgICAgICAgICAgICAgICAvLyBEb25lOyBkb24ndCBicmVhayAod2hpY2ggd291bGQgcmVzY2hlZHVsZSlcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVyaXZlZEtleTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFNjaGVkdWxlIHRoZSBuZXh0IHN0ZXBzXG5cdCAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBuZXh0VGljayhpbmNyZW1lbnRhbFNNaXgpOyB9XG5cdCAgICAgICAgfTtcblxuXHQgICAgICAgIC8vIFJ1biB0aGUgc21peCBzdGF0ZSBtYWNoaW5lIHVudGlsIGNvbXBsZXRpb25cblx0ICAgICAgICBpZiAoIWNhbGxiYWNrKSB7XG5cdCAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG5cdCAgICAgICAgICAgICAgICBjb25zdCBkZXJpdmVkS2V5ID0gaW5jcmVtZW50YWxTTWl4KCk7XG5cdCAgICAgICAgICAgICAgICBpZiAoZGVyaXZlZEtleSAhPSB1bmRlZmluZWQpIHsgcmV0dXJuIGRlcml2ZWRLZXk7IH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIEJvb3RzdHJhcCB0aGUgYXN5bmMgaW5jcmVtZW50YWwgc21peFxuXHQgICAgICAgIGluY3JlbWVudGFsU01peCgpO1xuXHQgICAgfVxuXG5cdCAgICBjb25zdCBsaWIgPSB7XG5cdCAgICAgICAgc2NyeXB0OiBmdW5jdGlvbihwYXNzd29yZCwgc2FsdCwgTiwgciwgcCwgZGtMZW4sIHByb2dyZXNzQ2FsbGJhY2spIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICAgICAgICAgICAgbGV0IGxhc3RQcm9ncmVzcyA9IDA7XG5cdCAgICAgICAgICAgICAgICBpZiAocHJvZ3Jlc3NDYWxsYmFjaykgeyBwcm9ncmVzc0NhbGxiYWNrKDApOyB9XG5cdCAgICAgICAgICAgICAgICBfc2NyeXB0KHBhc3N3b3JkLCBzYWx0LCBOLCByLCBwLCBka0xlbiwgZnVuY3Rpb24oZXJyb3IsIHByb2dyZXNzLCBrZXkpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcblx0ICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtleSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvZ3Jlc3NDYWxsYmFjayAmJiBsYXN0UHJvZ3Jlc3MgIT09IDEpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzQ2FsbGJhY2soMSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShuZXcgVWludDhBcnJheShrZXkpKTtcblx0ICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByb2dyZXNzQ2FsbGJhY2sgJiYgcHJvZ3Jlc3MgIT09IGxhc3RQcm9ncmVzcykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBsYXN0UHJvZ3Jlc3MgPSBwcm9ncmVzcztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb2dyZXNzQ2FsbGJhY2socHJvZ3Jlc3MpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHN5bmNTY3J5cHQ6IGZ1bmN0aW9uKHBhc3N3b3JkLCBzYWx0LCBOLCByLCBwLCBka0xlbikge1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoX3NjcnlwdChwYXNzd29yZCwgc2FsdCwgTiwgciwgcCwgZGtMZW4pKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICAvLyBub2RlLmpzXG5cdCAgICBpZiAoJ29iamVjdCcgIT09ICd1bmRlZmluZWQnKSB7XG5cdCAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGxpYjtcblxuXHQgICAgLy8gUmVxdWlyZUpTL0FNRFxuXHQgICAgLy8gaHR0cDovL3d3dy5yZXF1aXJlanMub3JnL2RvY3MvYXBpLmh0bWxcblx0ICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbWRqcy9hbWRqcy1hcGkvd2lraS9BTURcblx0ICAgIH0gZWxzZSBpZiAodHlwZW9mKHVuZGVmaW5lZCkgPT09ICdmdW5jdGlvbicgJiYgdW5kZWZpbmVkLmFtZCkge1xuXHQgICAgICAgIHVuZGVmaW5lZChsaWIpO1xuXG5cdCAgICAvLyBXZWIgQnJvd3NlcnNcblx0ICAgIH0gZWxzZSBpZiAocm9vdCkge1xuXG5cdCAgICAgICAgLy8gSWYgdGhlcmUgd2FzIGFuIGV4aXN0aW5nIGxpYnJhcnkgXCJzY3J5cHRcIiwgbWFrZSBzdXJlIGl0IGlzIHN0aWxsIGF2YWlsYWJsZVxuXHQgICAgICAgIGlmIChyb290LnNjcnlwdCkge1xuXHQgICAgICAgICAgICByb290Ll9zY3J5cHQgPSByb290LnNjcnlwdDtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByb290LnNjcnlwdCA9IGxpYjtcblx0ICAgIH1cblxuXHR9KShjb21tb25qc0dsb2JhbCk7XG5cdH0pO1xuXHR2YXIgc2NyeXB0XzEgPSBzY3J5cHQuc2NyeXB0O1xuXHR2YXIgc2NyeXB0XzIgPSBzY3J5cHQuc3luY1NjcnlwdDtcblxuXHR2YXIga2V5c3RvcmUgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19leHRlbmRzID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG5cdCAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcblx0ICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG5cdCAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cblx0ICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG5cdCAgICB9O1xuXHR9KSgpO1xuXHR2YXIgX19hd2FpdGVyID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuXHQgICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG5cdCAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG5cdCAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG5cdCAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cblx0ICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG5cdCAgICB9KTtcblx0fTtcblx0dmFyIF9fZ2VuZXJhdG9yID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuXHQgICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcblx0ICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuXHQgICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG5cdCAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG5cdCAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuXHQgICAgICAgIHdoaWxlIChfKSB0cnkge1xuXHQgICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG5cdCAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcblx0ICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuXHQgICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuXHQgICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcblx0ICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG5cdCAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG5cdCAgICB9XG5cdH07XG5cdHZhciBfX2ltcG9ydERlZmF1bHQgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG5cdCAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcblx0fTtcblx0dmFyIF9faW1wb3J0U3RhciA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcblx0ICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG5cdCAgICB2YXIgcmVzdWx0ID0ge307XG5cdCAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuXHQgICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdH07XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0dmFyIGFlc19qc18xID0gX19pbXBvcnREZWZhdWx0KGFlc0pzKTtcblx0dmFyIHNjcnlwdCQxID0gX19pbXBvcnRTdGFyKHNjcnlwdCk7XG5cblxuXG5cblxuXG5cblxuXG5cblxuXHR2YXIgbG9nZ2VyID0gbmV3IGxpYi5Mb2dnZXIoX3ZlcnNpb24kQS52ZXJzaW9uKTtcblx0Ly8gRXhwb3J0ZWQgVHlwZXNcblx0ZnVuY3Rpb24gaGFzTW5lbW9uaWModmFsdWUpIHtcblx0ICAgIHJldHVybiAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZS5tbmVtb25pYyAmJiB2YWx1ZS5tbmVtb25pYy5waHJhc2UpO1xuXHR9XG5cdHZhciBLZXlzdG9yZUFjY291bnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoS2V5c3RvcmVBY2NvdW50LCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gS2V5c3RvcmVBY2NvdW50KCkge1xuXHQgICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblx0ICAgIH1cblx0ICAgIEtleXN0b3JlQWNjb3VudC5wcm90b3R5cGUuaXNLZXlzdG9yZUFjY291bnQgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX2lzS2V5c3RvcmVBY2NvdW50KTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gS2V5c3RvcmVBY2NvdW50O1xuXHR9KGxpYiQzLkRlc2NyaXB0aW9uKSk7XG5cdGV4cG9ydHMuS2V5c3RvcmVBY2NvdW50ID0gS2V5c3RvcmVBY2NvdW50O1xuXHRmdW5jdGlvbiBfZGVjcnlwdChkYXRhLCBrZXksIGNpcGhlcnRleHQpIHtcblx0ICAgIHZhciBjaXBoZXIgPSB1dGlscyQxLnNlYXJjaFBhdGgoZGF0YSwgXCJjcnlwdG8vY2lwaGVyXCIpO1xuXHQgICAgaWYgKGNpcGhlciA9PT0gXCJhZXMtMTI4LWN0clwiKSB7XG5cdCAgICAgICAgdmFyIGl2ID0gdXRpbHMkMS5sb29zZUFycmF5aWZ5KHV0aWxzJDEuc2VhcmNoUGF0aChkYXRhLCBcImNyeXB0by9jaXBoZXJwYXJhbXMvaXZcIikpO1xuXHQgICAgICAgIHZhciBjb3VudGVyID0gbmV3IGFlc19qc18xLmRlZmF1bHQuQ291bnRlcihpdik7XG5cdCAgICAgICAgdmFyIGFlc0N0ciA9IG5ldyBhZXNfanNfMS5kZWZhdWx0Lk1vZGVPZk9wZXJhdGlvbi5jdHIoa2V5LCBjb3VudGVyKTtcblx0ICAgICAgICByZXR1cm4gbGliJDEuYXJyYXlpZnkoYWVzQ3RyLmRlY3J5cHQoY2lwaGVydGV4dCkpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIG51bGw7XG5cdH1cblx0ZnVuY3Rpb24gX2dldEFjY291bnQoZGF0YSwga2V5KSB7XG5cdCAgICB2YXIgY2lwaGVydGV4dCA9IHV0aWxzJDEubG9vc2VBcnJheWlmeSh1dGlscyQxLnNlYXJjaFBhdGgoZGF0YSwgXCJjcnlwdG8vY2lwaGVydGV4dFwiKSk7XG5cdCAgICB2YXIgY29tcHV0ZWRNQUMgPSBsaWIkMS5oZXhsaWZ5KGxpYiQ0LmtlY2NhazI1NihsaWIkMS5jb25jYXQoW2tleS5zbGljZSgxNiwgMzIpLCBjaXBoZXJ0ZXh0XSkpKS5zdWJzdHJpbmcoMik7XG5cdCAgICBpZiAoY29tcHV0ZWRNQUMgIT09IHV0aWxzJDEuc2VhcmNoUGF0aChkYXRhLCBcImNyeXB0by9tYWNcIikudG9Mb3dlckNhc2UoKSkge1xuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcGFzc3dvcmRcIik7XG5cdCAgICB9XG5cdCAgICB2YXIgcHJpdmF0ZUtleSA9IF9kZWNyeXB0KGRhdGEsIGtleS5zbGljZSgwLCAxNiksIGNpcGhlcnRleHQpO1xuXHQgICAgaWYgKCFwcml2YXRlS2V5KSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJ1bnN1cHBvcnRlZCBjaXBoZXJcIiwgbGliLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG5cdCAgICAgICAgICAgIG9wZXJhdGlvbjogXCJkZWNyeXB0XCJcblx0ICAgICAgICB9KTtcblx0ICAgIH1cblx0ICAgIHZhciBtbmVtb25pY0tleSA9IGtleS5zbGljZSgzMiwgNjQpO1xuXHQgICAgdmFyIGFkZHJlc3MgPSBsaWIkZy5jb21wdXRlQWRkcmVzcyhwcml2YXRlS2V5KTtcblx0ICAgIGlmIChkYXRhLmFkZHJlc3MpIHtcblx0ICAgICAgICB2YXIgY2hlY2sgPSBkYXRhLmFkZHJlc3MudG9Mb3dlckNhc2UoKTtcblx0ICAgICAgICBpZiAoY2hlY2suc3Vic3RyaW5nKDAsIDIpICE9PSBcIjB4XCIpIHtcblx0ICAgICAgICAgICAgY2hlY2sgPSBcIjB4XCIgKyBjaGVjaztcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGxpYiQ2LmdldEFkZHJlc3MoY2hlY2spICE9PSBhZGRyZXNzKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFkZHJlc3MgbWlzbWF0Y2hcIik7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgdmFyIGFjY291bnQgPSB7XG5cdCAgICAgICAgX2lzS2V5c3RvcmVBY2NvdW50OiB0cnVlLFxuXHQgICAgICAgIGFkZHJlc3M6IGFkZHJlc3MsXG5cdCAgICAgICAgcHJpdmF0ZUtleTogbGliJDEuaGV4bGlmeShwcml2YXRlS2V5KVxuXHQgICAgfTtcblx0ICAgIC8vIFZlcnNpb24gMC4xIHgtZXRoZXJzIG1ldGFkYXRhIG11c3QgY29udGFpbiBhbiBlbmNyeXB0ZWQgbW5lbW9uaWMgcGhyYXNlXG5cdCAgICBpZiAodXRpbHMkMS5zZWFyY2hQYXRoKGRhdGEsIFwieC1ldGhlcnMvdmVyc2lvblwiKSA9PT0gXCIwLjFcIikge1xuXHQgICAgICAgIHZhciBtbmVtb25pY0NpcGhlcnRleHQgPSB1dGlscyQxLmxvb3NlQXJyYXlpZnkodXRpbHMkMS5zZWFyY2hQYXRoKGRhdGEsIFwieC1ldGhlcnMvbW5lbW9uaWNDaXBoZXJ0ZXh0XCIpKTtcblx0ICAgICAgICB2YXIgbW5lbW9uaWNJdiA9IHV0aWxzJDEubG9vc2VBcnJheWlmeSh1dGlscyQxLnNlYXJjaFBhdGgoZGF0YSwgXCJ4LWV0aGVycy9tbmVtb25pY0NvdW50ZXJcIikpO1xuXHQgICAgICAgIHZhciBtbmVtb25pY0NvdW50ZXIgPSBuZXcgYWVzX2pzXzEuZGVmYXVsdC5Db3VudGVyKG1uZW1vbmljSXYpO1xuXHQgICAgICAgIHZhciBtbmVtb25pY0Flc0N0ciA9IG5ldyBhZXNfanNfMS5kZWZhdWx0Lk1vZGVPZk9wZXJhdGlvbi5jdHIobW5lbW9uaWNLZXksIG1uZW1vbmljQ291bnRlcik7XG5cdCAgICAgICAgdmFyIHBhdGggPSB1dGlscyQxLnNlYXJjaFBhdGgoZGF0YSwgXCJ4LWV0aGVycy9wYXRoXCIpIHx8IGxpYiRoLmRlZmF1bHRQYXRoO1xuXHQgICAgICAgIHZhciBsb2NhbGUgPSB1dGlscyQxLnNlYXJjaFBhdGgoZGF0YSwgXCJ4LWV0aGVycy9sb2NhbGVcIikgfHwgXCJlblwiO1xuXHQgICAgICAgIHZhciBlbnRyb3B5ID0gbGliJDEuYXJyYXlpZnkobW5lbW9uaWNBZXNDdHIuZGVjcnlwdChtbmVtb25pY0NpcGhlcnRleHQpKTtcblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICB2YXIgbW5lbW9uaWMgPSBsaWIkaC5lbnRyb3B5VG9NbmVtb25pYyhlbnRyb3B5LCBsb2NhbGUpO1xuXHQgICAgICAgICAgICB2YXIgbm9kZSA9IGxpYiRoLkhETm9kZS5mcm9tTW5lbW9uaWMobW5lbW9uaWMsIG51bGwsIGxvY2FsZSkuZGVyaXZlUGF0aChwYXRoKTtcblx0ICAgICAgICAgICAgaWYgKG5vZGUucHJpdmF0ZUtleSAhPSBhY2NvdW50LnByaXZhdGVLZXkpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1uZW1vbmljIG1pc21hdGNoXCIpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGFjY291bnQubW5lbW9uaWMgPSBub2RlLm1uZW1vbmljO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSB0aGUgbG9jYWxlIHdvcmRsaXN0IGluc3RhbGxlZCB0b1xuXHQgICAgICAgICAgICAvLyByZWFkIHRoaXMgbW5lbW9uaWMsIGp1c3QgYmFpbCBhbmQgZG9uJ3Qgc2V0IHRoZVxuXHQgICAgICAgICAgICAvLyBtbmVtb25pY1xuXHQgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSAhPT0gbGliLkxvZ2dlci5lcnJvcnMuSU5WQUxJRF9BUkdVTUVOVCB8fCBlcnJvci5hcmd1bWVudCAhPT0gXCJ3b3JkbGlzdFwiKSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiBuZXcgS2V5c3RvcmVBY2NvdW50KGFjY291bnQpO1xuXHR9XG5cdGZ1bmN0aW9uIHBia2RmMlN5bmMocGFzc3dvcmRCeXRlcywgc2FsdCwgY291bnQsIGRrTGVuLCBwcmZGdW5jKSB7XG5cdCAgICByZXR1cm4gbGliJDEuYXJyYXlpZnkoYnJvd3NlciQyLnBia2RmMihwYXNzd29yZEJ5dGVzLCBzYWx0LCBjb3VudCwgZGtMZW4sIHByZkZ1bmMpKTtcblx0fVxuXHRmdW5jdGlvbiBwYmtkZjIocGFzc3dvcmRCeXRlcywgc2FsdCwgY291bnQsIGRrTGVuLCBwcmZGdW5jKSB7XG5cdCAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHBia2RmMlN5bmMocGFzc3dvcmRCeXRlcywgc2FsdCwgY291bnQsIGRrTGVuLCBwcmZGdW5jKSk7XG5cdH1cblx0ZnVuY3Rpb24gX2NvbXB1dGVLZGZLZXkoZGF0YSwgcGFzc3dvcmQsIHBia2RmMkZ1bmMsIHNjcnlwdEZ1bmMsIHByb2dyZXNzQ2FsbGJhY2spIHtcblx0ICAgIHZhciBwYXNzd29yZEJ5dGVzID0gdXRpbHMkMS5nZXRQYXNzd29yZChwYXNzd29yZCk7XG5cdCAgICB2YXIga2RmID0gdXRpbHMkMS5zZWFyY2hQYXRoKGRhdGEsIFwiY3J5cHRvL2tkZlwiKTtcblx0ICAgIGlmIChrZGYgJiYgdHlwZW9mIChrZGYpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgdmFyIHRocm93RXJyb3IgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGtleS1kZXJpdmF0aW9uIGZ1bmN0aW9uIHBhcmFtZXRlcnNcIiwgbmFtZSwgdmFsdWUpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgaWYgKGtkZi50b0xvd2VyQ2FzZSgpID09PSBcInNjcnlwdFwiKSB7XG5cdCAgICAgICAgICAgIHZhciBzYWx0ID0gdXRpbHMkMS5sb29zZUFycmF5aWZ5KHV0aWxzJDEuc2VhcmNoUGF0aChkYXRhLCBcImNyeXB0by9rZGZwYXJhbXMvc2FsdFwiKSk7XG5cdCAgICAgICAgICAgIHZhciBOID0gcGFyc2VJbnQodXRpbHMkMS5zZWFyY2hQYXRoKGRhdGEsIFwiY3J5cHRvL2tkZnBhcmFtcy9uXCIpKTtcblx0ICAgICAgICAgICAgdmFyIHIgPSBwYXJzZUludCh1dGlscyQxLnNlYXJjaFBhdGgoZGF0YSwgXCJjcnlwdG8va2RmcGFyYW1zL3JcIikpO1xuXHQgICAgICAgICAgICB2YXIgcCA9IHBhcnNlSW50KHV0aWxzJDEuc2VhcmNoUGF0aChkYXRhLCBcImNyeXB0by9rZGZwYXJhbXMvcFwiKSk7XG5cdCAgICAgICAgICAgIC8vIENoZWNrIGZvciBhbGwgcmVxdWlyZWQgcGFyYW1ldGVyc1xuXHQgICAgICAgICAgICBpZiAoIU4gfHwgIXIgfHwgIXApIHtcblx0ICAgICAgICAgICAgICAgIHRocm93RXJyb3IoXCJrZGZcIiwga2RmKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAvLyBNYWtlIHN1cmUgTiBpcyBhIHBvd2VyIG9mIDJcblx0ICAgICAgICAgICAgaWYgKChOICYgKE4gLSAxKSkgIT09IDApIHtcblx0ICAgICAgICAgICAgICAgIHRocm93RXJyb3IoXCJOXCIsIE4pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBka0xlbiA9IHBhcnNlSW50KHV0aWxzJDEuc2VhcmNoUGF0aChkYXRhLCBcImNyeXB0by9rZGZwYXJhbXMvZGtsZW5cIikpO1xuXHQgICAgICAgICAgICBpZiAoZGtMZW4gIT09IDMyKSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKFwiZGtsZW5cIiwgZGtMZW4pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBzY3J5cHRGdW5jKHBhc3N3b3JkQnl0ZXMsIHNhbHQsIE4sIHIsIHAsIDY0LCBwcm9ncmVzc0NhbGxiYWNrKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAoa2RmLnRvTG93ZXJDYXNlKCkgPT09IFwicGJrZGYyXCIpIHtcblx0ICAgICAgICAgICAgdmFyIHNhbHQgPSB1dGlscyQxLmxvb3NlQXJyYXlpZnkodXRpbHMkMS5zZWFyY2hQYXRoKGRhdGEsIFwiY3J5cHRvL2tkZnBhcmFtcy9zYWx0XCIpKTtcblx0ICAgICAgICAgICAgdmFyIHByZkZ1bmMgPSBudWxsO1xuXHQgICAgICAgICAgICB2YXIgcHJmID0gdXRpbHMkMS5zZWFyY2hQYXRoKGRhdGEsIFwiY3J5cHRvL2tkZnBhcmFtcy9wcmZcIik7XG5cdCAgICAgICAgICAgIGlmIChwcmYgPT09IFwiaG1hYy1zaGEyNTZcIikge1xuXHQgICAgICAgICAgICAgICAgcHJmRnVuYyA9IFwic2hhMjU2XCI7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSBpZiAocHJmID09PSBcImhtYWMtc2hhNTEyXCIpIHtcblx0ICAgICAgICAgICAgICAgIHByZkZ1bmMgPSBcInNoYTUxMlwiO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihcInByZlwiLCBwcmYpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBjb3VudCA9IHBhcnNlSW50KHV0aWxzJDEuc2VhcmNoUGF0aChkYXRhLCBcImNyeXB0by9rZGZwYXJhbXMvY1wiKSk7XG5cdCAgICAgICAgICAgIHZhciBka0xlbiA9IHBhcnNlSW50KHV0aWxzJDEuc2VhcmNoUGF0aChkYXRhLCBcImNyeXB0by9rZGZwYXJhbXMvZGtsZW5cIikpO1xuXHQgICAgICAgICAgICBpZiAoZGtMZW4gIT09IDMyKSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKFwiZGtsZW5cIiwgZGtMZW4pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBwYmtkZjJGdW5jKHBhc3N3b3JkQnl0ZXMsIHNhbHQsIGNvdW50LCBka0xlbiwgcHJmRnVuYyk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bnN1cHBvcnRlZCBrZXktZGVyaXZhdGlvbiBmdW5jdGlvblwiLCBcImtkZlwiLCBrZGYpO1xuXHR9XG5cdGZ1bmN0aW9uIGRlY3J5cHRTeW5jKGpzb24sIHBhc3N3b3JkKSB7XG5cdCAgICB2YXIgZGF0YSA9IEpTT04ucGFyc2UoanNvbik7XG5cdCAgICB2YXIga2V5ID0gX2NvbXB1dGVLZGZLZXkoZGF0YSwgcGFzc3dvcmQsIHBia2RmMlN5bmMsIHNjcnlwdCQxLnN5bmNTY3J5cHQpO1xuXHQgICAgcmV0dXJuIF9nZXRBY2NvdW50KGRhdGEsIGtleSk7XG5cdH1cblx0ZXhwb3J0cy5kZWNyeXB0U3luYyA9IGRlY3J5cHRTeW5jO1xuXHRmdW5jdGlvbiBkZWNyeXB0KGpzb24sIHBhc3N3b3JkLCBwcm9ncmVzc0NhbGxiYWNrKSB7XG5cdCAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIGRhdGEsIGtleTtcblx0ICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMDpcblx0ICAgICAgICAgICAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShqc29uKTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfY29tcHV0ZUtkZktleShkYXRhLCBwYXNzd29yZCwgcGJrZGYyLCBzY3J5cHQkMS5zY3J5cHQsIHByb2dyZXNzQ2FsbGJhY2spXTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICBrZXkgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9nZXRBY2NvdW50KGRhdGEsIGtleSldO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdCAgICB9KTtcblx0fVxuXHRleHBvcnRzLmRlY3J5cHQgPSBkZWNyeXB0O1xuXHRmdW5jdGlvbiBlbmNyeXB0KGFjY291bnQsIHBhc3N3b3JkLCBvcHRpb25zLCBwcm9ncmVzc0NhbGxiYWNrKSB7XG5cdCAgICB0cnkge1xuXHQgICAgICAgIC8vIENoZWNrIHRoZSBhZGRyZXNzIG1hdGNoZXMgdGhlIHByaXZhdGUga2V5XG5cdCAgICAgICAgaWYgKGxpYiQ2LmdldEFkZHJlc3MoYWNjb3VudC5hZGRyZXNzKSAhPT0gbGliJGcuY29tcHV0ZUFkZHJlc3MoYWNjb3VudC5wcml2YXRlS2V5KSkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhZGRyZXNzL3ByaXZhdGVLZXkgbWlzbWF0Y2hcIik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIENoZWNrIHRoZSBtbmVtb25pYyAoaWYgYW55KSBtYXRjaGVzIHRoZSBwcml2YXRlIGtleVxuXHQgICAgICAgIGlmIChoYXNNbmVtb25pYyhhY2NvdW50KSkge1xuXHQgICAgICAgICAgICB2YXIgbW5lbW9uaWMgPSBhY2NvdW50Lm1uZW1vbmljO1xuXHQgICAgICAgICAgICB2YXIgbm9kZSA9IGxpYiRoLkhETm9kZS5mcm9tTW5lbW9uaWMobW5lbW9uaWMucGhyYXNlLCBudWxsLCBtbmVtb25pYy5sb2NhbGUpLmRlcml2ZVBhdGgobW5lbW9uaWMucGF0aCB8fCBsaWIkaC5kZWZhdWx0UGF0aCk7XG5cdCAgICAgICAgICAgIGlmIChub2RlLnByaXZhdGVLZXkgIT0gYWNjb3VudC5wcml2YXRlS2V5KSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtbmVtb25pYyBtaXNtYXRjaFwiKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIGNhdGNoIChlKSB7XG5cdCAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuXHQgICAgfVxuXHQgICAgLy8gVGhlIG9wdGlvbnMgYXJlIG9wdGlvbmFsLCBzbyBhZGp1c3QgdGhlIGNhbGwgYXMgbmVlZGVkXG5cdCAgICBpZiAodHlwZW9mIChvcHRpb25zKSA9PT0gXCJmdW5jdGlvblwiICYmICFwcm9ncmVzc0NhbGxiYWNrKSB7XG5cdCAgICAgICAgcHJvZ3Jlc3NDYWxsYmFjayA9IG9wdGlvbnM7XG5cdCAgICAgICAgb3B0aW9ucyA9IHt9O1xuXHQgICAgfVxuXHQgICAgaWYgKCFvcHRpb25zKSB7XG5cdCAgICAgICAgb3B0aW9ucyA9IHt9O1xuXHQgICAgfVxuXHQgICAgdmFyIHByaXZhdGVLZXkgPSBsaWIkMS5hcnJheWlmeShhY2NvdW50LnByaXZhdGVLZXkpO1xuXHQgICAgdmFyIHBhc3N3b3JkQnl0ZXMgPSB1dGlscyQxLmdldFBhc3N3b3JkKHBhc3N3b3JkKTtcblx0ICAgIHZhciBlbnRyb3B5ID0gbnVsbDtcblx0ICAgIHZhciBwYXRoID0gbnVsbDtcblx0ICAgIHZhciBsb2NhbGUgPSBudWxsO1xuXHQgICAgaWYgKGhhc01uZW1vbmljKGFjY291bnQpKSB7XG5cdCAgICAgICAgdmFyIHNyY01uZW1vbmljID0gYWNjb3VudC5tbmVtb25pYztcblx0ICAgICAgICBlbnRyb3B5ID0gbGliJDEuYXJyYXlpZnkobGliJGgubW5lbW9uaWNUb0VudHJvcHkoc3JjTW5lbW9uaWMucGhyYXNlLCBzcmNNbmVtb25pYy5sb2NhbGUgfHwgXCJlblwiKSk7XG5cdCAgICAgICAgcGF0aCA9IHNyY01uZW1vbmljLnBhdGggfHwgbGliJGguZGVmYXVsdFBhdGg7XG5cdCAgICAgICAgbG9jYWxlID0gc3JjTW5lbW9uaWMubG9jYWxlIHx8IFwiZW5cIjtcblx0ICAgIH1cblx0ICAgIHZhciBjbGllbnQgPSBvcHRpb25zLmNsaWVudDtcblx0ICAgIGlmICghY2xpZW50KSB7XG5cdCAgICAgICAgY2xpZW50ID0gXCJldGhlcnMuanNcIjtcblx0ICAgIH1cblx0ICAgIC8vIENoZWNrL2dlbmVyYXRlIHRoZSBzYWx0XG5cdCAgICB2YXIgc2FsdCA9IG51bGw7XG5cdCAgICBpZiAob3B0aW9ucy5zYWx0KSB7XG5cdCAgICAgICAgc2FsdCA9IGxpYiQxLmFycmF5aWZ5KG9wdGlvbnMuc2FsdCk7XG5cdCAgICB9XG5cdCAgICBlbHNlIHtcblx0ICAgICAgICBzYWx0ID0gYnJvd3NlciQ2LnJhbmRvbUJ5dGVzKDMyKTtcblx0ICAgICAgICA7XG5cdCAgICB9XG5cdCAgICAvLyBPdmVycmlkZSBpbml0aWFsaXphdGlvbiB2ZWN0b3Jcblx0ICAgIHZhciBpdiA9IG51bGw7XG5cdCAgICBpZiAob3B0aW9ucy5pdikge1xuXHQgICAgICAgIGl2ID0gbGliJDEuYXJyYXlpZnkob3B0aW9ucy5pdik7XG5cdCAgICAgICAgaWYgKGl2Lmxlbmd0aCAhPT0gMTYpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpdlwiKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBlbHNlIHtcblx0ICAgICAgICBpdiA9IGJyb3dzZXIkNi5yYW5kb21CeXRlcygxNik7XG5cdCAgICB9XG5cdCAgICAvLyBPdmVycmlkZSB0aGUgdXVpZFxuXHQgICAgdmFyIHV1aWRSYW5kb20gPSBudWxsO1xuXHQgICAgaWYgKG9wdGlvbnMudXVpZCkge1xuXHQgICAgICAgIHV1aWRSYW5kb20gPSBsaWIkMS5hcnJheWlmeShvcHRpb25zLnV1aWQpO1xuXHQgICAgICAgIGlmICh1dWlkUmFuZG9tLmxlbmd0aCAhPT0gMTYpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB1dWlkXCIpO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIGVsc2Uge1xuXHQgICAgICAgIHV1aWRSYW5kb20gPSBicm93c2VyJDYucmFuZG9tQnl0ZXMoMTYpO1xuXHQgICAgfVxuXHQgICAgLy8gT3ZlcnJpZGUgdGhlIHNjcnlwdCBwYXNzd29yZC1iYXNlZCBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbiBwYXJhbWV0ZXJzXG5cdCAgICB2YXIgTiA9ICgxIDw8IDE3KSwgciA9IDgsIHAgPSAxO1xuXHQgICAgaWYgKG9wdGlvbnMuc2NyeXB0KSB7XG5cdCAgICAgICAgaWYgKG9wdGlvbnMuc2NyeXB0Lk4pIHtcblx0ICAgICAgICAgICAgTiA9IG9wdGlvbnMuc2NyeXB0Lk47XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChvcHRpb25zLnNjcnlwdC5yKSB7XG5cdCAgICAgICAgICAgIHIgPSBvcHRpb25zLnNjcnlwdC5yO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAob3B0aW9ucy5zY3J5cHQucCkge1xuXHQgICAgICAgICAgICBwID0gb3B0aW9ucy5zY3J5cHQucDtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICAvLyBXZSB0YWtlIDY0IGJ5dGVzOlxuXHQgICAgLy8gICAtIDMyIGJ5dGVzICAgQXMgbm9ybWFsIGZvciB0aGUgV2ViMyBzZWNyZXQgc3RvcmFnZSAoZGVyaXZlZEtleSwgbWFjUHJlZml4KVxuXHQgICAgLy8gICAtIDMyIGJ5dGVzICAgQUVTIGtleSB0byBlbmNyeXB0IG1uZW1vbmljIHdpdGggKHJlcXVpcmVkIGhlcmUgdG8gYmUgRXRoZXJzIFdhbGxldClcblx0ICAgIHJldHVybiBzY3J5cHQkMS5zY3J5cHQocGFzc3dvcmRCeXRlcywgc2FsdCwgTiwgciwgcCwgNjQsIHByb2dyZXNzQ2FsbGJhY2spLnRoZW4oZnVuY3Rpb24gKGtleSkge1xuXHQgICAgICAgIGtleSA9IGxpYiQxLmFycmF5aWZ5KGtleSk7XG5cdCAgICAgICAgLy8gVGhpcyB3aWxsIGJlIHVzZWQgdG8gZW5jcnlwdCB0aGUgd2FsbGV0IChhcyBwZXIgV2ViMyBzZWNyZXQgc3RvcmFnZSlcblx0ICAgICAgICB2YXIgZGVyaXZlZEtleSA9IGtleS5zbGljZSgwLCAxNik7XG5cdCAgICAgICAgdmFyIG1hY1ByZWZpeCA9IGtleS5zbGljZSgxNiwgMzIpO1xuXHQgICAgICAgIC8vIFRoaXMgd2lsbCBiZSB1c2VkIHRvIGVuY3J5cHQgdGhlIG1uZW1vbmljIHBocmFzZSAoaWYgYW55KVxuXHQgICAgICAgIHZhciBtbmVtb25pY0tleSA9IGtleS5zbGljZSgzMiwgNjQpO1xuXHQgICAgICAgIC8vIEVuY3J5cHQgdGhlIHByaXZhdGUga2V5XG5cdCAgICAgICAgdmFyIGNvdW50ZXIgPSBuZXcgYWVzX2pzXzEuZGVmYXVsdC5Db3VudGVyKGl2KTtcblx0ICAgICAgICB2YXIgYWVzQ3RyID0gbmV3IGFlc19qc18xLmRlZmF1bHQuTW9kZU9mT3BlcmF0aW9uLmN0cihkZXJpdmVkS2V5LCBjb3VudGVyKTtcblx0ICAgICAgICB2YXIgY2lwaGVydGV4dCA9IGxpYiQxLmFycmF5aWZ5KGFlc0N0ci5lbmNyeXB0KHByaXZhdGVLZXkpKTtcblx0ICAgICAgICAvLyBDb21wdXRlIHRoZSBtZXNzYWdlIGF1dGhlbnRpY2F0aW9uIGNvZGUsIHVzZWQgdG8gY2hlY2sgdGhlIHBhc3N3b3JkXG5cdCAgICAgICAgdmFyIG1hYyA9IGxpYiQ0LmtlY2NhazI1NihsaWIkMS5jb25jYXQoW21hY1ByZWZpeCwgY2lwaGVydGV4dF0pKTtcblx0ICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS93aWtpL3dpa2kvV2ViMy1TZWNyZXQtU3RvcmFnZS1EZWZpbml0aW9uXG5cdCAgICAgICAgdmFyIGRhdGEgPSB7XG5cdCAgICAgICAgICAgIGFkZHJlc3M6IGFjY291bnQuYWRkcmVzcy5zdWJzdHJpbmcoMikudG9Mb3dlckNhc2UoKSxcblx0ICAgICAgICAgICAgaWQ6IHV0aWxzJDEudXVpZFY0KHV1aWRSYW5kb20pLFxuXHQgICAgICAgICAgICB2ZXJzaW9uOiAzLFxuXHQgICAgICAgICAgICBDcnlwdG86IHtcblx0ICAgICAgICAgICAgICAgIGNpcGhlcjogXCJhZXMtMTI4LWN0clwiLFxuXHQgICAgICAgICAgICAgICAgY2lwaGVycGFyYW1zOiB7XG5cdCAgICAgICAgICAgICAgICAgICAgaXY6IGxpYiQxLmhleGxpZnkoaXYpLnN1YnN0cmluZygyKSxcblx0ICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICBjaXBoZXJ0ZXh0OiBsaWIkMS5oZXhsaWZ5KGNpcGhlcnRleHQpLnN1YnN0cmluZygyKSxcblx0ICAgICAgICAgICAgICAgIGtkZjogXCJzY3J5cHRcIixcblx0ICAgICAgICAgICAgICAgIGtkZnBhcmFtczoge1xuXHQgICAgICAgICAgICAgICAgICAgIHNhbHQ6IGxpYiQxLmhleGxpZnkoc2FsdCkuc3Vic3RyaW5nKDIpLFxuXHQgICAgICAgICAgICAgICAgICAgIG46IE4sXG5cdCAgICAgICAgICAgICAgICAgICAgZGtsZW46IDMyLFxuXHQgICAgICAgICAgICAgICAgICAgIHA6IHAsXG5cdCAgICAgICAgICAgICAgICAgICAgcjogclxuXHQgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgIG1hYzogbWFjLnN1YnN0cmluZygyKVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfTtcblx0ICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgbW5lbW9uaWMsIGVuY3J5cHQgaXQgaW50byB0aGUgSlNPTiB3YWxsZXRcblx0ICAgICAgICBpZiAoZW50cm9weSkge1xuXHQgICAgICAgICAgICB2YXIgbW5lbW9uaWNJdiA9IGJyb3dzZXIkNi5yYW5kb21CeXRlcygxNik7XG5cdCAgICAgICAgICAgIHZhciBtbmVtb25pY0NvdW50ZXIgPSBuZXcgYWVzX2pzXzEuZGVmYXVsdC5Db3VudGVyKG1uZW1vbmljSXYpO1xuXHQgICAgICAgICAgICB2YXIgbW5lbW9uaWNBZXNDdHIgPSBuZXcgYWVzX2pzXzEuZGVmYXVsdC5Nb2RlT2ZPcGVyYXRpb24uY3RyKG1uZW1vbmljS2V5LCBtbmVtb25pY0NvdW50ZXIpO1xuXHQgICAgICAgICAgICB2YXIgbW5lbW9uaWNDaXBoZXJ0ZXh0ID0gbGliJDEuYXJyYXlpZnkobW5lbW9uaWNBZXNDdHIuZW5jcnlwdChlbnRyb3B5KSk7XG5cdCAgICAgICAgICAgIHZhciBub3cgPSBuZXcgRGF0ZSgpO1xuXHQgICAgICAgICAgICB2YXIgdGltZXN0YW1wID0gKG5vdy5nZXRVVENGdWxsWWVhcigpICsgXCItXCIgK1xuXHQgICAgICAgICAgICAgICAgdXRpbHMkMS56cGFkKG5vdy5nZXRVVENNb250aCgpICsgMSwgMikgKyBcIi1cIiArXG5cdCAgICAgICAgICAgICAgICB1dGlscyQxLnpwYWQobm93LmdldFVUQ0RhdGUoKSwgMikgKyBcIlRcIiArXG5cdCAgICAgICAgICAgICAgICB1dGlscyQxLnpwYWQobm93LmdldFVUQ0hvdXJzKCksIDIpICsgXCItXCIgK1xuXHQgICAgICAgICAgICAgICAgdXRpbHMkMS56cGFkKG5vdy5nZXRVVENNaW51dGVzKCksIDIpICsgXCItXCIgK1xuXHQgICAgICAgICAgICAgICAgdXRpbHMkMS56cGFkKG5vdy5nZXRVVENTZWNvbmRzKCksIDIpICsgXCIuMFpcIik7XG5cdCAgICAgICAgICAgIGRhdGFbXCJ4LWV0aGVyc1wiXSA9IHtcblx0ICAgICAgICAgICAgICAgIGNsaWVudDogY2xpZW50LFxuXHQgICAgICAgICAgICAgICAgZ2V0aEZpbGVuYW1lOiAoXCJVVEMtLVwiICsgdGltZXN0YW1wICsgXCItLVwiICsgZGF0YS5hZGRyZXNzKSxcblx0ICAgICAgICAgICAgICAgIG1uZW1vbmljQ291bnRlcjogbGliJDEuaGV4bGlmeShtbmVtb25pY0l2KS5zdWJzdHJpbmcoMiksXG5cdCAgICAgICAgICAgICAgICBtbmVtb25pY0NpcGhlcnRleHQ6IGxpYiQxLmhleGxpZnkobW5lbW9uaWNDaXBoZXJ0ZXh0KS5zdWJzdHJpbmcoMiksXG5cdCAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuXHQgICAgICAgICAgICAgICAgbG9jYWxlOiBsb2NhbGUsXG5cdCAgICAgICAgICAgICAgICB2ZXJzaW9uOiBcIjAuMVwiXG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShkYXRhKTtcblx0ICAgIH0pO1xuXHR9XG5cdGV4cG9ydHMuZW5jcnlwdCA9IGVuY3J5cHQ7XG5cblx0fSk7XG5cblx0dmFyIGtleXN0b3JlJDEgPSB1bndyYXBFeHBvcnRzKGtleXN0b3JlKTtcblx0dmFyIGtleXN0b3JlXzEgPSBrZXlzdG9yZS5LZXlzdG9yZUFjY291bnQ7XG5cdHZhciBrZXlzdG9yZV8yID0ga2V5c3RvcmUuZGVjcnlwdFN5bmM7XG5cdHZhciBrZXlzdG9yZV8zID0ga2V5c3RvcmUuZGVjcnlwdDtcblx0dmFyIGtleXN0b3JlXzQgPSBrZXlzdG9yZS5lbmNyeXB0O1xuXG5cdHZhciBsaWIkaSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXHRleHBvcnRzLmRlY3J5cHRDcm93ZHNhbGUgPSBjcm93ZHNhbGUuZGVjcnlwdDtcblxuXHRleHBvcnRzLmdldEpzb25XYWxsZXRBZGRyZXNzID0gaW5zcGVjdC5nZXRKc29uV2FsbGV0QWRkcmVzcztcblx0ZXhwb3J0cy5pc0Nyb3dkc2FsZVdhbGxldCA9IGluc3BlY3QuaXNDcm93ZHNhbGVXYWxsZXQ7XG5cdGV4cG9ydHMuaXNLZXlzdG9yZVdhbGxldCA9IGluc3BlY3QuaXNLZXlzdG9yZVdhbGxldDtcblxuXHRleHBvcnRzLmRlY3J5cHRLZXlzdG9yZSA9IGtleXN0b3JlLmRlY3J5cHQ7XG5cdGV4cG9ydHMuZGVjcnlwdEtleXN0b3JlU3luYyA9IGtleXN0b3JlLmRlY3J5cHRTeW5jO1xuXHRleHBvcnRzLmVuY3J5cHRLZXlzdG9yZSA9IGtleXN0b3JlLmVuY3J5cHQ7XG5cdGZ1bmN0aW9uIGRlY3J5cHRKc29uV2FsbGV0KGpzb24sIHBhc3N3b3JkLCBwcm9ncmVzc0NhbGxiYWNrKSB7XG5cdCAgICBpZiAoaW5zcGVjdC5pc0Nyb3dkc2FsZVdhbGxldChqc29uKSkge1xuXHQgICAgICAgIGlmIChwcm9ncmVzc0NhbGxiYWNrKSB7XG5cdCAgICAgICAgICAgIHByb2dyZXNzQ2FsbGJhY2soMCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBhY2NvdW50ID0gY3Jvd2RzYWxlLmRlY3J5cHQoanNvbiwgcGFzc3dvcmQpO1xuXHQgICAgICAgIGlmIChwcm9ncmVzc0NhbGxiYWNrKSB7XG5cdCAgICAgICAgICAgIHByb2dyZXNzQ2FsbGJhY2soMSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoYWNjb3VudCk7XG5cdCAgICB9XG5cdCAgICBpZiAoaW5zcGVjdC5pc0tleXN0b3JlV2FsbGV0KGpzb24pKSB7XG5cdCAgICAgICAgcmV0dXJuIGtleXN0b3JlLmRlY3J5cHQoanNvbiwgcGFzc3dvcmQsIHByb2dyZXNzQ2FsbGJhY2spO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcImludmFsaWQgSlNPTiB3YWxsZXRcIikpO1xuXHR9XG5cdGV4cG9ydHMuZGVjcnlwdEpzb25XYWxsZXQgPSBkZWNyeXB0SnNvbldhbGxldDtcblx0ZnVuY3Rpb24gZGVjcnlwdEpzb25XYWxsZXRTeW5jKGpzb24sIHBhc3N3b3JkKSB7XG5cdCAgICBpZiAoaW5zcGVjdC5pc0Nyb3dkc2FsZVdhbGxldChqc29uKSkge1xuXHQgICAgICAgIHJldHVybiBjcm93ZHNhbGUuZGVjcnlwdChqc29uLCBwYXNzd29yZCk7XG5cdCAgICB9XG5cdCAgICBpZiAoaW5zcGVjdC5pc0tleXN0b3JlV2FsbGV0KGpzb24pKSB7XG5cdCAgICAgICAgcmV0dXJuIGtleXN0b3JlLmRlY3J5cHRTeW5jKGpzb24sIHBhc3N3b3JkKTtcblx0ICAgIH1cblx0ICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgSlNPTiB3YWxsZXRcIik7XG5cdH1cblx0ZXhwb3J0cy5kZWNyeXB0SnNvbldhbGxldFN5bmMgPSBkZWNyeXB0SnNvbldhbGxldFN5bmM7XG5cblx0fSk7XG5cblx0dmFyIGluZGV4JGkgPSB1bndyYXBFeHBvcnRzKGxpYiRpKTtcblx0dmFyIGxpYl8xJGkgPSBsaWIkaS5kZWNyeXB0Q3Jvd2RzYWxlO1xuXHR2YXIgbGliXzIkaCA9IGxpYiRpLmdldEpzb25XYWxsZXRBZGRyZXNzO1xuXHR2YXIgbGliXzMkZSA9IGxpYiRpLmlzQ3Jvd2RzYWxlV2FsbGV0O1xuXHR2YXIgbGliXzQkYiA9IGxpYiRpLmlzS2V5c3RvcmVXYWxsZXQ7XG5cdHZhciBsaWJfNSRhID0gbGliJGkuZGVjcnlwdEtleXN0b3JlO1xuXHR2YXIgbGliXzYkNiA9IGxpYiRpLmRlY3J5cHRLZXlzdG9yZVN5bmM7XG5cdHZhciBsaWJfNyQ1ID0gbGliJGkuZW5jcnlwdEtleXN0b3JlO1xuXHR2YXIgbGliXzgkNCA9IGxpYiRpLmRlY3J5cHRKc29uV2FsbGV0O1xuXHR2YXIgbGliXzkkNCA9IGxpYiRpLmRlY3J5cHRKc29uV2FsbGV0U3luYztcblxuXHR2YXIgX3ZlcnNpb24kQyA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy52ZXJzaW9uID0gXCJ3YWxsZXQvNS4wLjJcIjtcblxuXHR9KTtcblxuXHR2YXIgX3ZlcnNpb24kRCA9IHVud3JhcEV4cG9ydHMoX3ZlcnNpb24kQyk7XG5cdHZhciBfdmVyc2lvbl8xJGogPSBfdmVyc2lvbiRDLnZlcnNpb247XG5cblx0dmFyIGxpYiRqID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0dmFyIF9fZXh0ZW5kcyA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuXHQgICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuXHQgICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG5cdCAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuXHQgICAgfTtcblx0fSkoKTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblx0dmFyIGxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJEMudmVyc2lvbik7XG5cdGZ1bmN0aW9uIGlzQWNjb3VudCh2YWx1ZSkge1xuXHQgICAgcmV0dXJuICh2YWx1ZSAhPSBudWxsICYmIGxpYiQxLmlzSGV4U3RyaW5nKHZhbHVlLnByaXZhdGVLZXksIDMyKSAmJiB2YWx1ZS5hZGRyZXNzICE9IG51bGwpO1xuXHR9XG5cdGZ1bmN0aW9uIGhhc01uZW1vbmljKHZhbHVlKSB7XG5cdCAgICB2YXIgbW5lbW9uaWMgPSB2YWx1ZS5tbmVtb25pYztcblx0ICAgIHJldHVybiAobW5lbW9uaWMgJiYgbW5lbW9uaWMucGhyYXNlKTtcblx0fVxuXHR2YXIgV2FsbGV0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHQgICAgX19leHRlbmRzKFdhbGxldCwgX3N1cGVyKTtcblx0ICAgIGZ1bmN0aW9uIFdhbGxldChwcml2YXRlS2V5LCBwcm92aWRlcikge1xuXHQgICAgICAgIHZhciBfbmV3VGFyZ2V0ID0gdGhpcy5jb25zdHJ1Y3Rvcjtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIGxvZ2dlci5jaGVja05ldyhfbmV3VGFyZ2V0LCBXYWxsZXQpO1xuXHQgICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcblx0ICAgICAgICBpZiAoaXNBY2NvdW50KHByaXZhdGVLZXkpKSB7XG5cdCAgICAgICAgICAgIHZhciBzaWduaW5nS2V5XzEgPSBuZXcgbGliJGYuU2lnbmluZ0tleShwcml2YXRlS2V5LnByaXZhdGVLZXkpO1xuXHQgICAgICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seShfdGhpcywgXCJfc2lnbmluZ0tleVwiLCBmdW5jdGlvbiAoKSB7IHJldHVybiBzaWduaW5nS2V5XzE7IH0pO1xuXHQgICAgICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seShfdGhpcywgXCJhZGRyZXNzXCIsIGxpYiRnLmNvbXB1dGVBZGRyZXNzKF90aGlzLnB1YmxpY0tleSkpO1xuXHQgICAgICAgICAgICBpZiAoX3RoaXMuYWRkcmVzcyAhPT0gbGliJDYuZ2V0QWRkcmVzcyhwcml2YXRlS2V5LmFkZHJlc3MpKSB7XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwicHJpdmF0ZUtleS9hZGRyZXNzIG1pc21hdGNoXCIsIFwicHJpdmF0ZUtleVwiLCBcIltSRURBQ1RFRF1cIik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKGhhc01uZW1vbmljKHByaXZhdGVLZXkpKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgc3JjTW5lbW9uaWNfMSA9IHByaXZhdGVLZXkubW5lbW9uaWM7XG5cdCAgICAgICAgICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seShfdGhpcywgXCJfbW5lbW9uaWNcIiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gKHtcblx0ICAgICAgICAgICAgICAgICAgICBwaHJhc2U6IHNyY01uZW1vbmljXzEucGhyYXNlLFxuXHQgICAgICAgICAgICAgICAgICAgIHBhdGg6IHNyY01uZW1vbmljXzEucGF0aCB8fCBsaWIkaC5kZWZhdWx0UGF0aCxcblx0ICAgICAgICAgICAgICAgICAgICBsb2NhbGU6IHNyY01uZW1vbmljXzEubG9jYWxlIHx8IFwiZW5cIlxuXHQgICAgICAgICAgICAgICAgfSk7IH0pO1xuXHQgICAgICAgICAgICAgICAgdmFyIG1uZW1vbmljID0gX3RoaXMubW5lbW9uaWM7XG5cdCAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IGxpYiRoLkhETm9kZS5mcm9tTW5lbW9uaWMobW5lbW9uaWMucGhyYXNlLCBudWxsLCBtbmVtb25pYy5sb2NhbGUpLmRlcml2ZVBhdGgobW5lbW9uaWMucGF0aCk7XG5cdCAgICAgICAgICAgICAgICBpZiAobGliJGcuY29tcHV0ZUFkZHJlc3Mobm9kZS5wcml2YXRlS2V5KSAhPT0gX3RoaXMuYWRkcmVzcykge1xuXHQgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJtbmVtb25pYy9hZGRyZXNzIG1pc21hdGNoXCIsIFwicHJpdmF0ZUtleVwiLCBcIltSRURBQ1RFRF1cIik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seShfdGhpcywgXCJfbW5lbW9uaWNcIiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIGlmIChsaWIkZi5TaWduaW5nS2V5LmlzU2lnbmluZ0tleShwcml2YXRlS2V5KSkge1xuXHQgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5cdCAgICAgICAgICAgICAgICBpZiAocHJpdmF0ZUtleS5jdXJ2ZSAhPT0gXCJzZWNwMjU2azFcIikge1xuXHQgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bnN1cHBvcnRlZCBjdXJ2ZTsgbXVzdCBiZSBzZWNwMjU2azFcIiwgXCJwcml2YXRlS2V5XCIsIFwiW1JFREFDVEVEXVwiKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KF90aGlzLCBcIl9zaWduaW5nS2V5XCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByaXZhdGVLZXk7IH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdmFyIHNpZ25pbmdLZXlfMiA9IG5ldyBsaWIkZi5TaWduaW5nS2V5KHByaXZhdGVLZXkpO1xuXHQgICAgICAgICAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkoX3RoaXMsIFwiX3NpZ25pbmdLZXlcIiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gc2lnbmluZ0tleV8yOyB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seShfdGhpcywgXCJfbW5lbW9uaWNcIiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfSk7XG5cdCAgICAgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KF90aGlzLCBcImFkZHJlc3NcIiwgbGliJGcuY29tcHV0ZUFkZHJlc3MoX3RoaXMucHVibGljS2V5KSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuXHQgICAgICAgIGlmIChwcm92aWRlciAmJiAhbGliJGIuUHJvdmlkZXIuaXNQcm92aWRlcihwcm92aWRlcikpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgcHJvdmlkZXJcIiwgXCJwcm92aWRlclwiLCBwcm92aWRlcik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KF90aGlzLCBcInByb3ZpZGVyXCIsIHByb3ZpZGVyIHx8IG51bGwpO1xuXHQgICAgICAgIHJldHVybiBfdGhpcztcblx0ICAgIH1cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXYWxsZXQucHJvdG90eXBlLCBcIm1uZW1vbmljXCIsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX21uZW1vbmljKCk7IH0sXG5cdCAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblx0ICAgICAgICBjb25maWd1cmFibGU6IHRydWVcblx0ICAgIH0pO1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdhbGxldC5wcm90b3R5cGUsIFwicHJpdmF0ZUtleVwiLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zaWduaW5nS2V5KCkucHJpdmF0ZUtleTsgfSxcblx0ICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXHQgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHQgICAgfSk7XG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2FsbGV0LnByb3RvdHlwZSwgXCJwdWJsaWNLZXlcIiwge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc2lnbmluZ0tleSgpLnB1YmxpY0tleTsgfSxcblx0ICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXHQgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHQgICAgfSk7XG5cdCAgICBXYWxsZXQucHJvdG90eXBlLmdldEFkZHJlc3MgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLmFkZHJlc3MpO1xuXHQgICAgfTtcblx0ICAgIFdhbGxldC5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uIChwcm92aWRlcikge1xuXHQgICAgICAgIHJldHVybiBuZXcgV2FsbGV0KHRoaXMsIHByb3ZpZGVyKTtcblx0ICAgIH07XG5cdCAgICBXYWxsZXQucHJvdG90eXBlLnNpZ25UcmFuc2FjdGlvbiA9IGZ1bmN0aW9uICh0cmFuc2FjdGlvbikge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgcmV0dXJuIGxpYiQzLnJlc29sdmVQcm9wZXJ0aWVzKHRyYW5zYWN0aW9uKS50aGVuKGZ1bmN0aW9uICh0eCkge1xuXHQgICAgICAgICAgICBpZiAodHguZnJvbSAhPSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAobGliJDYuZ2V0QWRkcmVzcyh0eC5mcm9tKSAhPT0gX3RoaXMuYWRkcmVzcykge1xuXHQgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ0cmFuc2FjdGlvbiBmcm9tIGFkZHJlc3MgbWlzbWF0Y2hcIiwgXCJ0cmFuc2FjdGlvbi5mcm9tXCIsIHRyYW5zYWN0aW9uLmZyb20pO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZGVsZXRlIHR4LmZyb207XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIHNpZ25hdHVyZSA9IF90aGlzLl9zaWduaW5nS2V5KCkuc2lnbkRpZ2VzdChsaWIkNC5rZWNjYWsyNTYobGliJGcuc2VyaWFsaXplKHR4KSkpO1xuXHQgICAgICAgICAgICByZXR1cm4gbGliJGcuc2VyaWFsaXplKHR4LCBzaWduYXR1cmUpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIFdhbGxldC5wcm90b3R5cGUuc2lnbk1lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuXHQgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobGliJDEuam9pblNpZ25hdHVyZSh0aGlzLl9zaWduaW5nS2V5KCkuc2lnbkRpZ2VzdChsaWIkOS5oYXNoTWVzc2FnZShtZXNzYWdlKSkpKTtcblx0ICAgIH07XG5cdCAgICBXYWxsZXQucHJvdG90eXBlLmVuY3J5cHQgPSBmdW5jdGlvbiAocGFzc3dvcmQsIG9wdGlvbnMsIHByb2dyZXNzQ2FsbGJhY2spIHtcblx0ICAgICAgICBpZiAodHlwZW9mIChvcHRpb25zKSA9PT0gXCJmdW5jdGlvblwiICYmICFwcm9ncmVzc0NhbGxiYWNrKSB7XG5cdCAgICAgICAgICAgIHByb2dyZXNzQ2FsbGJhY2sgPSBvcHRpb25zO1xuXHQgICAgICAgICAgICBvcHRpb25zID0ge307XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChwcm9ncmVzc0NhbGxiYWNrICYmIHR5cGVvZiAocHJvZ3Jlc3NDYWxsYmFjaykgIT09IFwiZnVuY3Rpb25cIikge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGNhbGxiYWNrXCIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoIW9wdGlvbnMpIHtcblx0ICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gbGliJGkuZW5jcnlwdEtleXN0b3JlKHRoaXMsIHBhc3N3b3JkLCBvcHRpb25zLCBwcm9ncmVzc0NhbGxiYWNrKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0ICAgICAqICBTdGF0aWMgbWV0aG9kcyB0byBjcmVhdGUgV2FsbGV0IGluc3RhbmNlcy5cblx0ICAgICAqL1xuXHQgICAgV2FsbGV0LmNyZWF0ZVJhbmRvbSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdCAgICAgICAgdmFyIGVudHJvcHkgPSBicm93c2VyJDYucmFuZG9tQnl0ZXMoMTYpO1xuXHQgICAgICAgIGlmICghb3B0aW9ucykge1xuXHQgICAgICAgICAgICBvcHRpb25zID0ge307XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChvcHRpb25zLmV4dHJhRW50cm9weSkge1xuXHQgICAgICAgICAgICBlbnRyb3B5ID0gbGliJDEuYXJyYXlpZnkobGliJDEuaGV4RGF0YVNsaWNlKGxpYiQ0LmtlY2NhazI1NihsaWIkMS5jb25jYXQoW2VudHJvcHksIG9wdGlvbnMuZXh0cmFFbnRyb3B5XSkpLCAwLCAxNikpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgbW5lbW9uaWMgPSBsaWIkaC5lbnRyb3B5VG9NbmVtb25pYyhlbnRyb3B5LCBvcHRpb25zLmxvY2FsZSk7XG5cdCAgICAgICAgcmV0dXJuIFdhbGxldC5mcm9tTW5lbW9uaWMobW5lbW9uaWMsIG9wdGlvbnMucGF0aCwgb3B0aW9ucy5sb2NhbGUpO1xuXHQgICAgfTtcblx0ICAgIFdhbGxldC5mcm9tRW5jcnlwdGVkSnNvbiA9IGZ1bmN0aW9uIChqc29uLCBwYXNzd29yZCwgcHJvZ3Jlc3NDYWxsYmFjaykge1xuXHQgICAgICAgIHJldHVybiBsaWIkaS5kZWNyeXB0SnNvbldhbGxldChqc29uLCBwYXNzd29yZCwgcHJvZ3Jlc3NDYWxsYmFjaykudGhlbihmdW5jdGlvbiAoYWNjb3VudCkge1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFdhbGxldChhY2NvdW50KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBXYWxsZXQuZnJvbUVuY3J5cHRlZEpzb25TeW5jID0gZnVuY3Rpb24gKGpzb24sIHBhc3N3b3JkKSB7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBXYWxsZXQobGliJGkuZGVjcnlwdEpzb25XYWxsZXRTeW5jKGpzb24sIHBhc3N3b3JkKSk7XG5cdCAgICB9O1xuXHQgICAgV2FsbGV0LmZyb21NbmVtb25pYyA9IGZ1bmN0aW9uIChtbmVtb25pYywgcGF0aCwgd29yZGxpc3QpIHtcblx0ICAgICAgICBpZiAoIXBhdGgpIHtcblx0ICAgICAgICAgICAgcGF0aCA9IGxpYiRoLmRlZmF1bHRQYXRoO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gbmV3IFdhbGxldChsaWIkaC5IRE5vZGUuZnJvbU1uZW1vbmljKG1uZW1vbmljLCBudWxsLCB3b3JkbGlzdCkuZGVyaXZlUGF0aChwYXRoKSk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFdhbGxldDtcblx0fShsaWIkYy5TaWduZXIpKTtcblx0ZXhwb3J0cy5XYWxsZXQgPSBXYWxsZXQ7XG5cdGZ1bmN0aW9uIHZlcmlmeU1lc3NhZ2UobWVzc2FnZSwgc2lnbmF0dXJlKSB7XG5cdCAgICByZXR1cm4gbGliJGcucmVjb3ZlckFkZHJlc3MobGliJDkuaGFzaE1lc3NhZ2UobWVzc2FnZSksIHNpZ25hdHVyZSk7XG5cdH1cblx0ZXhwb3J0cy52ZXJpZnlNZXNzYWdlID0gdmVyaWZ5TWVzc2FnZTtcblxuXHR9KTtcblxuXHR2YXIgaW5kZXgkaiA9IHVud3JhcEV4cG9ydHMobGliJGopO1xuXHR2YXIgbGliXzEkaiA9IGxpYiRqLldhbGxldDtcblx0dmFyIGxpYl8yJGkgPSBsaWIkai52ZXJpZnlNZXNzYWdlO1xuXG5cdHZhciBfdmVyc2lvbiRFID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLnZlcnNpb24gPSBcIm5ldHdvcmtzLzUuMC4yXCI7XG5cblx0fSk7XG5cblx0dmFyIF92ZXJzaW9uJEYgPSB1bndyYXBFeHBvcnRzKF92ZXJzaW9uJEUpO1xuXHR2YXIgX3ZlcnNpb25fMSRrID0gX3ZlcnNpb24kRS52ZXJzaW9uO1xuXG5cdHZhciBsaWIkayA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXG5cdHZhciBsb2dnZXIgPSBuZXcgbGliLkxvZ2dlcihfdmVyc2lvbiRFLnZlcnNpb24pO1xuXHQ7XG5cdGZ1bmN0aW9uIGlzUmVuZXR3b3JrYWJsZSh2YWx1ZSkge1xuXHQgICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlLnJlbmV0d29yaykgPT09IFwiZnVuY3Rpb25cIik7XG5cdH1cblx0ZnVuY3Rpb24gZXRoRGVmYXVsdFByb3ZpZGVyKG5ldHdvcmspIHtcblx0ICAgIHZhciBmdW5jID0gZnVuY3Rpb24gKHByb3ZpZGVycywgb3B0aW9ucykge1xuXHQgICAgICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcblx0ICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgcHJvdmlkZXJMaXN0ID0gW107XG5cdCAgICAgICAgaWYgKHByb3ZpZGVycy5JbmZ1cmFQcm92aWRlcikge1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgcHJvdmlkZXJMaXN0LnB1c2gobmV3IHByb3ZpZGVycy5JbmZ1cmFQcm92aWRlcihuZXR3b3JrLCBvcHRpb25zLmluZnVyYSkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChwcm92aWRlcnMuRXRoZXJzY2FuUHJvdmlkZXIpIHtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIHByb3ZpZGVyTGlzdC5wdXNoKG5ldyBwcm92aWRlcnMuRXRoZXJzY2FuUHJvdmlkZXIobmV0d29yaywgb3B0aW9ucy5ldGhlcnNjYW4pKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAocHJvdmlkZXJzLkFsY2hlbXlQcm92aWRlcikge1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgcHJvdmlkZXJMaXN0LnB1c2gobmV3IHByb3ZpZGVycy5BbGNoZW15UHJvdmlkZXIobmV0d29yaywgb3B0aW9ucy5hbGNoZW15KSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHByb3ZpZGVycy5DbG91ZGZsYXJlUHJvdmlkZXIpIHtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIHByb3ZpZGVyTGlzdC5wdXNoKG5ldyBwcm92aWRlcnMuQ2xvdWRmbGFyZVByb3ZpZGVyKG5ldHdvcmspKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAocHJvdmlkZXJMaXN0Lmxlbmd0aCA9PT0gMCkge1xuXHQgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHByb3ZpZGVycy5GYWxsYmFja1Byb3ZpZGVyKSB7XG5cdCAgICAgICAgICAgIHZhciBxdW9ydW0gPSAxO1xuXHQgICAgICAgICAgICBpZiAob3B0aW9ucy5xdW9ydW0gIT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgcXVvcnVtID0gb3B0aW9ucy5xdW9ydW07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSBpZiAobmV0d29yayA9PT0gXCJob21lc3RlYWRcIikge1xuXHQgICAgICAgICAgICAgICAgcXVvcnVtID0gMjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gbmV3IHByb3ZpZGVycy5GYWxsYmFja1Byb3ZpZGVyKHByb3ZpZGVyTGlzdCwgcXVvcnVtKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHByb3ZpZGVyTGlzdFswXTtcblx0ICAgIH07XG5cdCAgICBmdW5jLnJlbmV0d29yayA9IGZ1bmN0aW9uIChuZXR3b3JrKSB7XG5cdCAgICAgICAgcmV0dXJuIGV0aERlZmF1bHRQcm92aWRlcihuZXR3b3JrKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gZnVuYztcblx0fVxuXHRmdW5jdGlvbiBldGNEZWZhdWx0UHJvdmlkZXIodXJsLCBuZXR3b3JrKSB7XG5cdCAgICB2YXIgZnVuYyA9IGZ1bmN0aW9uIChwcm92aWRlcnMsIG9wdGlvbnMpIHtcblx0ICAgICAgICBpZiAocHJvdmlkZXJzLkpzb25ScGNQcm92aWRlcikge1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IHByb3ZpZGVycy5Kc29uUnBjUHJvdmlkZXIodXJsLCBuZXR3b3JrKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICB9O1xuXHQgICAgZnVuYy5yZW5ldHdvcmsgPSBmdW5jdGlvbiAobmV0d29yaykge1xuXHQgICAgICAgIHJldHVybiBldGNEZWZhdWx0UHJvdmlkZXIodXJsLCBuZXR3b3JrKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gZnVuYztcblx0fVxuXHR2YXIgaG9tZXN0ZWFkID0ge1xuXHQgICAgY2hhaW5JZDogMSxcblx0ICAgIGVuc0FkZHJlc3M6IFwiMHgwMDAwMDAwMDAwMEMyRTA3NGVDNjlBMGRGYjI5OTdCQTZDN2QyZTFlXCIsXG5cdCAgICBuYW1lOiBcImhvbWVzdGVhZFwiLFxuXHQgICAgX2RlZmF1bHRQcm92aWRlcjogZXRoRGVmYXVsdFByb3ZpZGVyKFwiaG9tZXN0ZWFkXCIpXG5cdH07XG5cdHZhciByb3BzdGVuID0ge1xuXHQgICAgY2hhaW5JZDogMyxcblx0ICAgIGVuc0FkZHJlc3M6IFwiMHgwMDAwMDAwMDAwMEMyRTA3NGVDNjlBMGRGYjI5OTdCQTZDN2QyZTFlXCIsXG5cdCAgICBuYW1lOiBcInJvcHN0ZW5cIixcblx0ICAgIF9kZWZhdWx0UHJvdmlkZXI6IGV0aERlZmF1bHRQcm92aWRlcihcInJvcHN0ZW5cIilcblx0fTtcblx0dmFyIGNsYXNzaWNNb3Jkb3IgPSB7XG5cdCAgICBjaGFpbklkOiA2Myxcblx0ICAgIG5hbWU6IFwiY2xhc3NpY01vcmRvclwiLFxuXHQgICAgX2RlZmF1bHRQcm92aWRlcjogZXRjRGVmYXVsdFByb3ZpZGVyKFwiaHR0cHM6Ly93d3cuZXRoZXJjbHVzdGVyLmNvbS9tb3Jkb3JcIiwgXCJjbGFzc2ljTW9yZG9yXCIpXG5cdH07XG5cdHZhciBuZXR3b3JrcyA9IHtcblx0ICAgIHVuc3BlY2lmaWVkOiB7XG5cdCAgICAgICAgY2hhaW5JZDogMCxcblx0ICAgICAgICBuYW1lOiBcInVuc3BlY2lmaWVkXCJcblx0ICAgIH0sXG5cdCAgICBob21lc3RlYWQ6IGhvbWVzdGVhZCxcblx0ICAgIG1haW5uZXQ6IGhvbWVzdGVhZCxcblx0ICAgIG1vcmRlbjoge1xuXHQgICAgICAgIGNoYWluSWQ6IDIsXG5cdCAgICAgICAgbmFtZTogXCJtb3JkZW5cIlxuXHQgICAgfSxcblx0ICAgIHJvcHN0ZW46IHJvcHN0ZW4sXG5cdCAgICB0ZXN0bmV0OiByb3BzdGVuLFxuXHQgICAgcmlua2VieToge1xuXHQgICAgICAgIGNoYWluSWQ6IDQsXG5cdCAgICAgICAgZW5zQWRkcmVzczogXCIweDAwMDAwMDAwMDAwQzJFMDc0ZUM2OUEwZEZiMjk5N0JBNkM3ZDJlMWVcIixcblx0ICAgICAgICBuYW1lOiBcInJpbmtlYnlcIixcblx0ICAgICAgICBfZGVmYXVsdFByb3ZpZGVyOiBldGhEZWZhdWx0UHJvdmlkZXIoXCJyaW5rZWJ5XCIpXG5cdCAgICB9LFxuXHQgICAga292YW46IHtcblx0ICAgICAgICBjaGFpbklkOiA0Mixcblx0ICAgICAgICBuYW1lOiBcImtvdmFuXCIsXG5cdCAgICAgICAgX2RlZmF1bHRQcm92aWRlcjogZXRoRGVmYXVsdFByb3ZpZGVyKFwia292YW5cIilcblx0ICAgIH0sXG5cdCAgICBnb2VybGk6IHtcblx0ICAgICAgICBjaGFpbklkOiA1LFxuXHQgICAgICAgIGVuc0FkZHJlc3M6IFwiMHgwMDAwMDAwMDAwMEMyRTA3NGVDNjlBMGRGYjI5OTdCQTZDN2QyZTFlXCIsXG5cdCAgICAgICAgbmFtZTogXCJnb2VybGlcIixcblx0ICAgICAgICBfZGVmYXVsdFByb3ZpZGVyOiBldGhEZWZhdWx0UHJvdmlkZXIoXCJnb2VybGlcIilcblx0ICAgIH0sXG5cdCAgICAvLyBFVEMgKFNlZTogIzM1MSlcblx0ICAgIGNsYXNzaWM6IHtcblx0ICAgICAgICBjaGFpbklkOiA2MSxcblx0ICAgICAgICBuYW1lOiBcImNsYXNzaWNcIixcblx0ICAgICAgICBfZGVmYXVsdFByb3ZpZGVyOiBldGNEZWZhdWx0UHJvdmlkZXIoXCJodHRwczovL3d3dy5ldGhlcmNsdXN0ZXIuY29tL2V0Y1wiLCBcImNsYXNzaWNcIilcblx0ICAgIH0sXG5cdCAgICBjbGFzc2ljTW9yZGVuOiB7XG5cdCAgICAgICAgY2hhaW5JZDogNjIsXG5cdCAgICAgICAgbmFtZTogXCJjbGFzc2ljTW9yZGVuXCIsXG5cdCAgICB9LFxuXHQgICAgY2xhc3NpY01vcmRvcjogY2xhc3NpY01vcmRvcixcblx0ICAgIGNsYXNzaWNUZXN0bmV0OiBjbGFzc2ljTW9yZG9yLFxuXHQgICAgY2xhc3NpY0tvdHRpOiB7XG5cdCAgICAgICAgY2hhaW5JZDogNixcblx0ICAgICAgICBuYW1lOiBcImNsYXNzaWNLb3R0aVwiLFxuXHQgICAgICAgIF9kZWZhdWx0UHJvdmlkZXI6IGV0Y0RlZmF1bHRQcm92aWRlcihcImh0dHBzOi8vd3d3LmV0aGVyY2x1c3Rlci5jb20va290dGlcIiwgXCJjbGFzc2ljS290dGlcIilcblx0ICAgIH0sXG5cdH07XG5cdC8qKlxuXHQgKiAgZ2V0TmV0d29ya1xuXHQgKlxuXHQgKiAgQ29udmVydHMgYSBuYW1lZCBjb21tb24gbmV0d29ya3Mgb3IgY2hhaW4gSUQgKG5ldHdvcmsgSUQpIHRvIGEgTmV0d29ya1xuXHQgKiAgYW5kIHZlcmlmaWVzIGEgbmV0d29yayBpcyBhIHZhbGlkIE5ldHdvcmsuLlxuXHQgKi9cblx0ZnVuY3Rpb24gZ2V0TmV0d29yayhuZXR3b3JrKSB7XG5cdCAgICAvLyBObyBuZXR3b3JrIChudWxsKVxuXHQgICAgaWYgKG5ldHdvcmsgPT0gbnVsbCkge1xuXHQgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgfVxuXHQgICAgaWYgKHR5cGVvZiAobmV0d29yaykgPT09IFwibnVtYmVyXCIpIHtcblx0ICAgICAgICBmb3IgKHZhciBuYW1lXzEgaW4gbmV0d29ya3MpIHtcblx0ICAgICAgICAgICAgdmFyIHN0YW5kYXJkXzEgPSBuZXR3b3Jrc1tuYW1lXzFdO1xuXHQgICAgICAgICAgICBpZiAoc3RhbmRhcmRfMS5jaGFpbklkID09PSBuZXR3b3JrKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgIG5hbWU6IHN0YW5kYXJkXzEubmFtZSxcblx0ICAgICAgICAgICAgICAgICAgICBjaGFpbklkOiBzdGFuZGFyZF8xLmNoYWluSWQsXG5cdCAgICAgICAgICAgICAgICAgICAgZW5zQWRkcmVzczogKHN0YW5kYXJkXzEuZW5zQWRkcmVzcyB8fCBudWxsKSxcblx0ICAgICAgICAgICAgICAgICAgICBfZGVmYXVsdFByb3ZpZGVyOiAoc3RhbmRhcmRfMS5fZGVmYXVsdFByb3ZpZGVyIHx8IG51bGwpXG5cdCAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgIGNoYWluSWQ6IG5ldHdvcmssXG5cdCAgICAgICAgICAgIG5hbWU6IFwidW5rbm93blwiXG5cdCAgICAgICAgfTtcblx0ICAgIH1cblx0ICAgIGlmICh0eXBlb2YgKG5ldHdvcmspID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgdmFyIHN0YW5kYXJkXzIgPSBuZXR3b3Jrc1tuZXR3b3JrXTtcblx0ICAgICAgICBpZiAoc3RhbmRhcmRfMiA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICBuYW1lOiBzdGFuZGFyZF8yLm5hbWUsXG5cdCAgICAgICAgICAgIGNoYWluSWQ6IHN0YW5kYXJkXzIuY2hhaW5JZCxcblx0ICAgICAgICAgICAgZW5zQWRkcmVzczogc3RhbmRhcmRfMi5lbnNBZGRyZXNzLFxuXHQgICAgICAgICAgICBfZGVmYXVsdFByb3ZpZGVyOiAoc3RhbmRhcmRfMi5fZGVmYXVsdFByb3ZpZGVyIHx8IG51bGwpXG5cdCAgICAgICAgfTtcblx0ICAgIH1cblx0ICAgIHZhciBzdGFuZGFyZCA9IG5ldHdvcmtzW25ldHdvcmsubmFtZV07XG5cdCAgICAvLyBOb3QgYSBzdGFuZGFyZCBuZXR3b3JrOyBjaGVjayB0aGF0IGl0IGlzIGEgdmFsaWQgbmV0d29yayBpbiBnZW5lcmFsXG5cdCAgICBpZiAoIXN0YW5kYXJkKSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiAobmV0d29yay5jaGFpbklkKSAhPT0gXCJudW1iZXJcIikge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBuZXR3b3JrIGNoYWluSWRcIiwgXCJuZXR3b3JrXCIsIG5ldHdvcmspO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gbmV0d29yaztcblx0ICAgIH1cblx0ICAgIC8vIE1ha2Ugc3VyZSB0aGUgY2hhaW5JZCBtYXRjaGVzIHRoZSBleHBlY3RlZCBuZXR3b3JrIGNoYWluSWQgKG9yIGlzIDA7IGRpc2FibGUgRUlQLTE1NSlcblx0ICAgIGlmIChuZXR3b3JrLmNoYWluSWQgIT09IDAgJiYgbmV0d29yay5jaGFpbklkICE9PSBzdGFuZGFyZC5jaGFpbklkKSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm5ldHdvcmsgY2hhaW5JZCBtaXNtYXRjaFwiLCBcIm5ldHdvcmtcIiwgbmV0d29yayk7XG5cdCAgICB9XG5cdCAgICAvLyBAVE9ETzogSW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBhZGQgYW4gYXR0YWNoIGZ1bmN0aW9uIHRvIGEgZGVmYXVsdFByb3ZpZGVyXG5cdCAgICAvLyBjbGFzcyBhbmQgbW92ZSB0aGUgX2RlZmF1bHRQcm92aWRlciBpbnRlcm5hbCB0byB0aGlzIGZpbGUgKGV4dGVuZCBOZXR3b3JrKVxuXHQgICAgdmFyIGRlZmF1bHRQcm92aWRlciA9IG5ldHdvcmsuX2RlZmF1bHRQcm92aWRlciB8fCBudWxsO1xuXHQgICAgaWYgKGRlZmF1bHRQcm92aWRlciA9PSBudWxsICYmIHN0YW5kYXJkLl9kZWZhdWx0UHJvdmlkZXIpIHtcblx0ICAgICAgICBpZiAoaXNSZW5ldHdvcmthYmxlKHN0YW5kYXJkLl9kZWZhdWx0UHJvdmlkZXIpKSB7XG5cdCAgICAgICAgICAgIGRlZmF1bHRQcm92aWRlciA9IHN0YW5kYXJkLl9kZWZhdWx0UHJvdmlkZXIucmVuZXR3b3JrKG5ldHdvcmspO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgZGVmYXVsdFByb3ZpZGVyID0gc3RhbmRhcmQuX2RlZmF1bHRQcm92aWRlcjtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICAvLyBTdGFuZGFyZCBOZXR3b3JrIChhbGxvdyBvdmVycmlkaW5nIHRoZSBFTlMgYWRkcmVzcylcblx0ICAgIHJldHVybiB7XG5cdCAgICAgICAgbmFtZTogbmV0d29yay5uYW1lLFxuXHQgICAgICAgIGNoYWluSWQ6IHN0YW5kYXJkLmNoYWluSWQsXG5cdCAgICAgICAgZW5zQWRkcmVzczogKG5ldHdvcmsuZW5zQWRkcmVzcyB8fCBzdGFuZGFyZC5lbnNBZGRyZXNzIHx8IG51bGwpLFxuXHQgICAgICAgIF9kZWZhdWx0UHJvdmlkZXI6IGRlZmF1bHRQcm92aWRlclxuXHQgICAgfTtcblx0fVxuXHRleHBvcnRzLmdldE5ldHdvcmsgPSBnZXROZXR3b3JrO1xuXG5cdH0pO1xuXG5cdHZhciBpbmRleCRrID0gdW53cmFwRXhwb3J0cyhsaWIkayk7XG5cdHZhciBsaWJfMSRrID0gbGliJGsuZ2V0TmV0d29yaztcblxuXHR2YXIgYnJvd3NlciQ4ID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5cdGZ1bmN0aW9uIGRlY29kZSh0ZXh0RGF0YSkge1xuXHQgICAgdGV4dERhdGEgPSBhdG9iKHRleHREYXRhKTtcblx0ICAgIHZhciBkYXRhID0gW107XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHREYXRhLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgZGF0YS5wdXNoKHRleHREYXRhLmNoYXJDb2RlQXQoaSkpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGxpYiQxLmFycmF5aWZ5KGRhdGEpO1xuXHR9XG5cdGV4cG9ydHMuZGVjb2RlID0gZGVjb2RlO1xuXHRmdW5jdGlvbiBlbmNvZGUoZGF0YSkge1xuXHQgICAgZGF0YSA9IGxpYiQxLmFycmF5aWZ5KGRhdGEpO1xuXHQgICAgdmFyIHRleHREYXRhID0gXCJcIjtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHRleHREYXRhICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoZGF0YVtpXSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gYnRvYSh0ZXh0RGF0YSk7XG5cdH1cblx0ZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG5cblx0fSk7XG5cblx0dmFyIGJyb3dzZXIkOSA9IHVud3JhcEV4cG9ydHMoYnJvd3NlciQ4KTtcblx0dmFyIGJyb3dzZXJfMSQ0ID0gYnJvd3NlciQ4LmRlY29kZTtcblx0dmFyIGJyb3dzZXJfMiQzID0gYnJvd3NlciQ4LmVuY29kZTtcblxuXHR2YXIgX3ZlcnNpb24kRyA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy52ZXJzaW9uID0gXCJ3ZWIvNS4wLjNcIjtcblxuXHR9KTtcblxuXHR2YXIgX3ZlcnNpb24kSCA9IHVud3JhcEV4cG9ydHMoX3ZlcnNpb24kRyk7XG5cdHZhciBfdmVyc2lvbl8xJGwgPSBfdmVyc2lvbiRHLnZlcnNpb247XG5cblx0dmFyIGJyb3dzZXJHZXR1cmwgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19hd2FpdGVyID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuXHQgICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG5cdCAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG5cdCAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG5cdCAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cblx0ICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG5cdCAgICB9KTtcblx0fTtcblx0dmFyIF9fZ2VuZXJhdG9yID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuXHQgICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcblx0ICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuXHQgICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG5cdCAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG5cdCAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuXHQgICAgICAgIHdoaWxlIChfKSB0cnkge1xuXHQgICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG5cdCAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcblx0ICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuXHQgICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuXHQgICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcblx0ICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG5cdCAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG5cdCAgICB9XG5cdH07XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXHRmdW5jdGlvbiBnZXRVcmwoaHJlZiwgb3B0aW9ucykge1xuXHQgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciByZXF1ZXN0LCByZXNwb25zZSwgYm9keSwgaGVhZGVycztcblx0ICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMDpcblx0ICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCA9IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAob3B0aW9ucy5tZXRob2QgfHwgXCJHRVRcIiksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IChvcHRpb25zLmhlYWRlcnMgfHwge30pLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiAob3B0aW9ucy5ib2R5IHx8IHVuZGVmaW5lZCksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG1vZGU6IFwiY29yc1wiLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZTogXCJuby1jYWNoZVwiLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjcmVkZW50aWFsczogXCJzYW1lLW9yaWdpblwiLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZWRpcmVjdDogXCJmb2xsb3dcIixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJyZXI6IFwiY2xpZW50XCIsXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBmZXRjaChocmVmLCByZXF1ZXN0KV07XG5cdCAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKV07XG5cdCAgICAgICAgICAgICAgICBjYXNlIDI6XG5cdCAgICAgICAgICAgICAgICAgICAgYm9keSA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICBoZWFkZXJzID0ge307XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmhlYWRlcnMuZm9yRWFjaCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5oZWFkZXJzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldID0gdmFsdWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgKChyZXNwb25zZS5oZWFkZXJzKS5rZXlzKSgpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1trZXkudG9Mb3dlckNhc2UoKV0gPSByZXNwb25zZS5oZWFkZXJzLmdldChrZXkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXMsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXNNZXNzYWdlOiByZXNwb25zZS5zdGF0dXNUZXh0LFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogbGliJDEuYXJyYXlpZnkobmV3IFVpbnQ4QXJyYXkoYm9keSkpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgfSk7XG5cdH1cblx0ZXhwb3J0cy5nZXRVcmwgPSBnZXRVcmw7XG5cblx0fSk7XG5cblx0dmFyIGJyb3dzZXJHZXR1cmwkMSA9IHVud3JhcEV4cG9ydHMoYnJvd3NlckdldHVybCk7XG5cdHZhciBicm93c2VyR2V0dXJsXzEgPSBicm93c2VyR2V0dXJsLmdldFVybDtcblxuXHR2YXIgbGliJGwgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19hd2FpdGVyID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuXHQgICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG5cdCAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG5cdCAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG5cdCAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cblx0ICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG5cdCAgICB9KTtcblx0fTtcblx0dmFyIF9fZ2VuZXJhdG9yID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuXHQgICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcblx0ICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuXHQgICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG5cdCAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG5cdCAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuXHQgICAgICAgIHdoaWxlIChfKSB0cnkge1xuXHQgICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG5cdCAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcblx0ICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuXHQgICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuXHQgICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcblx0ICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG5cdCAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG5cdCAgICB9XG5cdH07XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXG5cblxuXG5cdHZhciBsb2dnZXIgPSBuZXcgbGliLkxvZ2dlcihfdmVyc2lvbiRHLnZlcnNpb24pO1xuXG5cdGZ1bmN0aW9uIHN0YWxsZXIoZHVyYXRpb24pIHtcblx0ICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuXHQgICAgICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgZHVyYXRpb24pO1xuXHQgICAgfSk7XG5cdH1cblx0Ly8gVGhpcyBBUEkgaXMgc3RpbGwgYSB3b3JrIGluIHByb2dyZXNzOyB0aGUgZnV0dXJlIGNoYW5nZXMgd2lsbCBsaWtlbHkgYmU6XG5cdC8vIC0gQ29ubmVjdGlvbkluZm8gPT4gRmV0Y2hEYXRhUmVxdWVzdDxUID0gYW55PlxuXHQvLyAtIEZldGNoRGF0YVJlcXVlc3QuYm9keT8gPSBzdHJpbmcgfCBVaW50OEFycmF5IHwgeyBjb250ZW50VHlwZTogc3RyaW5nLCBkYXRhOiBzdHJpbmcgfCBVaW50OEFycmF5IH1cblx0Ly8gICAtIElmIHN0cmluZyA9PiB0ZXh0L3BsYWluLCBVaW50OEFycmF5ID0+IGFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSAoaWYgY29udGVudC10eXBlIHVuc3BlY2lmaWVkKVxuXHQvLyAtIEZldGNoRGF0YVJlcXVlc3QucHJvY2Vzc0Z1bmMgPSAoYm9keTogVWludDhBcnJheSwgcmVzcG9uc2U6IEZldGNoRGF0YVJlc3BvbnNlKSA9PiBUXG5cdC8vIEZvciB0aGlzIHJlYXNvbiwgaXQgc2hvdWxkIGJlIGNvbnNpZGVyZWQgaW50ZXJuYWwgdW50aWwgdGhlIEFQSSBpcyBmaW5hbGl6ZWRcblx0ZnVuY3Rpb24gX2ZldGNoRGF0YShjb25uZWN0aW9uLCBib2R5LCBwcm9jZXNzRnVuYykge1xuXHQgICAgLy8gSG93IG1hbnkgdGltZXMgdG8gcmV0cnkgaW4gdGhlIGV2ZW50IG9mIGEgdGhyb3R0bGVcblx0ICAgIHZhciBhdHRlbXB0TGltaXQgPSAodHlwZW9mIChjb25uZWN0aW9uKSA9PT0gXCJvYmplY3RcIiAmJiBjb25uZWN0aW9uLnRocm90dGxlTGltaXQgIT0gbnVsbCkgPyBjb25uZWN0aW9uLnRocm90dGxlTGltaXQgOiAxMjtcblx0ICAgIGxvZ2dlci5hc3NlcnRBcmd1bWVudCgoYXR0ZW1wdExpbWl0ID4gMCAmJiAoYXR0ZW1wdExpbWl0ICUgMSkgPT09IDApLCBcImludmFsaWQgY29ubmVjdGlvbiB0aHJvdHRsZSBsaW1pdFwiLCBcImNvbm5lY3Rpb24udGhyb3R0bGVMaW1pdFwiLCBhdHRlbXB0TGltaXQpO1xuXHQgICAgdmFyIHRocm90dGxlQ2FsbGJhY2sgPSAoKHR5cGVvZiAoY29ubmVjdGlvbikgPT09IFwib2JqZWN0XCIpID8gY29ubmVjdGlvbi50aHJvdHRsZUNhbGxiYWNrIDogbnVsbCk7XG5cdCAgICB2YXIgdGhyb3R0bGVTbG90SW50ZXJ2YWwgPSAoKHR5cGVvZiAoY29ubmVjdGlvbikgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIChjb25uZWN0aW9uLnRocm90dGxlU2xvdEludGVydmFsKSA9PT0gXCJudW1iZXJcIikgPyBjb25uZWN0aW9uLnRocm90dGxlU2xvdEludGVydmFsIDogMTAwKTtcblx0ICAgIGxvZ2dlci5hc3NlcnRBcmd1bWVudCgodGhyb3R0bGVTbG90SW50ZXJ2YWwgPiAwICYmICh0aHJvdHRsZVNsb3RJbnRlcnZhbCAlIDEpID09PSAwKSwgXCJpbnZhbGlkIGNvbm5lY3Rpb24gdGhyb3R0bGUgc2xvdCBpbnRlcnZhbFwiLCBcImNvbm5lY3Rpb24udGhyb3R0bGVTbG90SW50ZXJ2YWxcIiwgdGhyb3R0bGVTbG90SW50ZXJ2YWwpO1xuXHQgICAgdmFyIGhlYWRlcnMgPSB7fTtcblx0ICAgIHZhciB1cmwgPSBudWxsO1xuXHQgICAgLy8gQFRPRE86IEFsbG93IENvbm5lY3Rpb25JbmZvIHRvIG92ZXJyaWRlIHNvbWUgb2YgdGhlc2UgdmFsdWVzXG5cdCAgICB2YXIgb3B0aW9ucyA9IHtcblx0ICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG5cdCAgICB9O1xuXHQgICAgdmFyIGFsbG93MzA0ID0gZmFsc2U7XG5cdCAgICB2YXIgdGltZW91dCA9IDIgKiA2MCAqIDEwMDA7XG5cdCAgICBpZiAodHlwZW9mIChjb25uZWN0aW9uKSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgIHVybCA9IGNvbm5lY3Rpb247XG5cdCAgICB9XG5cdCAgICBlbHNlIGlmICh0eXBlb2YgKGNvbm5lY3Rpb24pID09PSBcIm9iamVjdFwiKSB7XG5cdCAgICAgICAgaWYgKGNvbm5lY3Rpb24gPT0gbnVsbCB8fCBjb25uZWN0aW9uLnVybCA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJtaXNzaW5nIFVSTFwiLCBcImNvbm5lY3Rpb24udXJsXCIsIGNvbm5lY3Rpb24pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB1cmwgPSBjb25uZWN0aW9uLnVybDtcblx0ICAgICAgICBpZiAodHlwZW9mIChjb25uZWN0aW9uLnRpbWVvdXQpID09PSBcIm51bWJlclwiICYmIGNvbm5lY3Rpb24udGltZW91dCA+IDApIHtcblx0ICAgICAgICAgICAgdGltZW91dCA9IGNvbm5lY3Rpb24udGltZW91dDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGNvbm5lY3Rpb24uaGVhZGVycykge1xuXHQgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gY29ubmVjdGlvbi5oZWFkZXJzKSB7XG5cdCAgICAgICAgICAgICAgICBoZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXSA9IHsga2V5OiBrZXksIHZhbHVlOiBTdHJpbmcoY29ubmVjdGlvbi5oZWFkZXJzW2tleV0pIH07XG5cdCAgICAgICAgICAgICAgICBpZiAoW1wiaWYtbm9uZS1tYXRjaFwiLCBcImlmLW1vZGlmaWVkLXNpbmNlXCJdLmluZGV4T2Yoa2V5LnRvTG93ZXJDYXNlKCkpID49IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICBhbGxvdzMwNCA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGNvbm5lY3Rpb24udXNlciAhPSBudWxsICYmIGNvbm5lY3Rpb24ucGFzc3dvcmQgIT0gbnVsbCkge1xuXHQgICAgICAgICAgICBpZiAodXJsLnN1YnN0cmluZygwLCA2KSAhPT0gXCJodHRwczpcIiAmJiBjb25uZWN0aW9uLmFsbG93SW5zZWN1cmVBdXRoZW50aWNhdGlvbiAhPT0gdHJ1ZSkge1xuXHQgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJiYXNpYyBhdXRoZW50aWNhdGlvbiByZXF1aXJlcyBhIHNlY3VyZSBodHRwcyB1cmxcIiwgbGliLkxvZ2dlci5lcnJvcnMuSU5WQUxJRF9BUkdVTUVOVCwgeyBhcmd1bWVudDogXCJ1cmxcIiwgdXJsOiB1cmwsIHVzZXI6IGNvbm5lY3Rpb24udXNlciwgcGFzc3dvcmQ6IFwiW1JFREFDVEVEXVwiIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBhdXRob3JpemF0aW9uID0gY29ubmVjdGlvbi51c2VyICsgXCI6XCIgKyBjb25uZWN0aW9uLnBhc3N3b3JkO1xuXHQgICAgICAgICAgICBoZWFkZXJzW1wiYXV0aG9yaXphdGlvblwiXSA9IHtcblx0ICAgICAgICAgICAgICAgIGtleTogXCJBdXRob3JpemF0aW9uXCIsXG5cdCAgICAgICAgICAgICAgICB2YWx1ZTogXCJCYXNpYyBcIiArIGJyb3dzZXIkOC5lbmNvZGUobGliJDgudG9VdGY4Qnl0ZXMoYXV0aG9yaXphdGlvbikpXG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgaWYgKGJvZHkpIHtcblx0ICAgICAgICBvcHRpb25zLm1ldGhvZCA9IFwiUE9TVFwiO1xuXHQgICAgICAgIG9wdGlvbnMuYm9keSA9IGJvZHk7XG5cdCAgICAgICAgaWYgKGhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0gPT0gbnVsbCkge1xuXHQgICAgICAgICAgICBoZWFkZXJzW1wiY29udGVudC10eXBlXCJdID0geyBrZXk6IFwiQ29udGVudC1UeXBlXCIsIHZhbHVlOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiIH07XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgdmFyIGZsYXRIZWFkZXJzID0ge307XG5cdCAgICBPYmplY3Qua2V5cyhoZWFkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0ICAgICAgICB2YXIgaGVhZGVyID0gaGVhZGVyc1trZXldO1xuXHQgICAgICAgIGZsYXRIZWFkZXJzW2hlYWRlci5rZXldID0gaGVhZGVyLnZhbHVlO1xuXHQgICAgfSk7XG5cdCAgICBvcHRpb25zLmhlYWRlcnMgPSBmbGF0SGVhZGVycztcblx0ICAgIHZhciBydW5uaW5nVGltZW91dCA9IChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIHRpbWVyID0gbnVsbDtcblx0ICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICAgICAgaWYgKHRpbWVvdXQpIHtcblx0ICAgICAgICAgICAgICAgIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVyID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB0aW1lciA9IG51bGw7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGxvZ2dlci5tYWtlRXJyb3IoXCJ0aW1lb3V0XCIsIGxpYi5Mb2dnZXIuZXJyb3JzLlRJTUVPVVQsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEJvZHk6IChvcHRpb25zLmJvZHkgfHwgbnVsbCksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RNZXRob2Q6IG9wdGlvbnMubWV0aG9kLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0OiB0aW1lb3V0LFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHVybFxuXHQgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgdmFyIGNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgaWYgKHRpbWVyID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuXHQgICAgICAgICAgICB0aW1lciA9IG51bGw7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICByZXR1cm4geyBwcm9taXNlOiBwcm9taXNlLCBjYW5jZWw6IGNhbmNlbCB9O1xuXHQgICAgfSkoKTtcblx0ICAgIHZhciBydW5uaW5nRmV0Y2ggPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGF0dGVtcHQsIHJlc3BvbnNlLCB0cnlBZ2Fpbiwgc3RhbGwsIHJldHJ5QWZ0ZXIsIGVycm9yXzEsIGJvZHlfMSwgcmVzdWx0LCBlcnJvcl8yLCB0cnlBZ2FpbiwgdGltZW91dF8xO1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBhdHRlbXB0ID0gMDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAxO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoYXR0ZW1wdCA8IGF0dGVtcHRMaW1pdCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDE5XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBudWxsO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDI7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzIsIDgsICwgOV0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBicm93c2VyR2V0dXJsLmdldFVybCh1cmwsIG9wdGlvbnMpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShyZXNwb25zZS5zdGF0dXNDb2RlID09PSA0MjkgJiYgYXR0ZW1wdCA8IGF0dGVtcHRMaW1pdCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDddO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0cnlBZ2FpbiA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhyb3R0bGVDYWxsYmFjaykgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRocm90dGxlQ2FsbGJhY2soYXR0ZW1wdCwgdXJsKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0cnlBZ2FpbiA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSA1O1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0cnlBZ2FpbikgcmV0dXJuIFszIC8qYnJlYWsqLywgN107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YWxsID0gMDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0cnlBZnRlciA9IHJlc3BvbnNlLmhlYWRlcnNbXCJyZXRyeS1hZnRlclwiXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAocmV0cnlBZnRlcikgPT09IFwic3RyaW5nXCIgJiYgcmV0cnlBZnRlci5tYXRjaCgvXlsxLTldWzAtOV0qJC8pKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFsbCA9IHBhcnNlSW50KHJldHJ5QWZ0ZXIpICogMTAwMDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWxsID0gdGhyb3R0bGVTbG90SW50ZXJ2YWwgKiBwYXJzZUludChTdHJpbmcoTWF0aC5yYW5kb20oKSAqIE1hdGgucG93KDIsIGF0dGVtcHQpKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIlN0YWxsaW5nIDQyOVwiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgc3RhbGxlcihzdGFsbCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIlN0YWxsaW5nIDQyOVwiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxOF07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSA3OiByZXR1cm4gWzMgLypicmVhayovLCA5XTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDg6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yXzEgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gZXJyb3JfMS5yZXNwb25zZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5pbmdUaW1lb3V0LmNhbmNlbCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJtaXNzaW5nIHJlc3BvbnNlXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RCb2R5OiAob3B0aW9ucy5ib2R5IHx8IG51bGwpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RNZXRob2Q6IG9wdGlvbnMubWV0aG9kLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZlckVycm9yOiBlcnJvcl8xLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogdXJsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA5XTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDk6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlfMSA9IHJlc3BvbnNlLmJvZHk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbGxvdzMwNCAmJiByZXNwb25zZS5zdGF0dXNDb2RlID09PSAzMDQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlfMSA9IG51bGw7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA8IDIwMCB8fCByZXNwb25zZS5zdGF0dXNDb2RlID49IDMwMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVubmluZ1RpbWVvdXQuY2FuY2VsKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImJhZCByZXNwb25zZVwiLCBsaWIuTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1c0NvZGUsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogcmVzcG9uc2UuaGVhZGVycyxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBib2R5XzEsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEJvZHk6IChvcHRpb25zLmJvZHkgfHwgbnVsbCksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdE1ldGhvZDogb3B0aW9ucy5tZXRob2QsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB1cmxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcHJvY2Vzc0Z1bmMpIHJldHVybiBbMyAvKmJyZWFrKi8sIDE3XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAxMDtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDEwOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzEwLCAxMiwgLCAxN10pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBwcm9jZXNzRnVuYyhib2R5XzEsIHJlc3BvbnNlKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBydW5uaW5nVGltZW91dC5jYW5jZWwoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3VsdF07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxMjpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JfMiA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoZXJyb3JfMi50aHJvdHRsZVJldHJ5ICYmIGF0dGVtcHQgPCBhdHRlbXB0TGltaXQpKSByZXR1cm4gWzMgLypicmVhayovLCAxNl07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRyeUFnYWluID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aHJvdHRsZUNhbGxiYWNrKSByZXR1cm4gWzMgLypicmVhayovLCAxNF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRocm90dGxlQ2FsbGJhY2soYXR0ZW1wdCwgdXJsKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxMzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHJ5QWdhaW4gPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMTQ7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxNDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0cnlBZ2FpbikgcmV0dXJuIFszIC8qYnJlYWsqLywgMTZdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0XzEgPSB0aHJvdHRsZVNsb3RJbnRlcnZhbCAqIHBhcnNlSW50KFN0cmluZyhNYXRoLnJhbmRvbSgpICogTWF0aC5wb3coMiwgYXR0ZW1wdCkpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIlN0YWxsaW5nIGNhbGxiYWNrXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBzdGFsbGVyKHRpbWVvdXRfMSldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTU6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJTdGFsbGluZyBjYWxsYmFja1wiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxOF07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxNjpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcnVubmluZ1RpbWVvdXQuY2FuY2VsKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwicHJvY2Vzc2luZyByZXNwb25zZSBlcnJvclwiLCBsaWIuTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGJvZHlfMSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcl8yLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEJvZHk6IChvcHRpb25zLmJvZHkgfHwgbnVsbCksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0TWV0aG9kOiBvcHRpb25zLm1ldGhvZCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogdXJsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxN107XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxNzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcnVubmluZ1RpbWVvdXQuY2FuY2VsKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhZCBhIHByb2Nlc3NGdW5jLCBpdCBlaXRlaHIgcmV0dXJuZWQgYSBUIG9yIHRocmV3IGFib3ZlLlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgXCJib2R5XCIgaXMgbm93IGEgVWludDhBcnJheS5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGJvZHlfMV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxODpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYXR0ZW1wdCsrO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE5OiByZXR1cm4gWzIgLypyZXR1cm4qLywgbG9nZ2VyLnRocm93RXJyb3IoXCJmYWlsZWQgcmVzcG9uc2VcIiwgbGliLkxvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0Qm9keTogKG9wdGlvbnMuYm9keSB8fCBudWxsKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RNZXRob2Q6IG9wdGlvbnMubWV0aG9kLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB1cmxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH0pKCk7XG5cdCAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtydW5uaW5nVGltZW91dC5wcm9taXNlLCBydW5uaW5nRmV0Y2hdKTtcblx0fVxuXHRleHBvcnRzLl9mZXRjaERhdGEgPSBfZmV0Y2hEYXRhO1xuXHRmdW5jdGlvbiBmZXRjaEpzb24oY29ubmVjdGlvbiwganNvbiwgcHJvY2Vzc0Z1bmMpIHtcblx0ICAgIHZhciBwcm9jZXNzSnNvbkZ1bmMgPSBmdW5jdGlvbiAodmFsdWUsIHJlc3BvbnNlKSB7XG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IG51bGw7XG5cdCAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIHJlc3VsdCA9IEpTT04ucGFyc2UobGliJDgudG9VdGY4U3RyaW5nKHZhbHVlKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImludmFsaWQgSlNPTlwiLCBsaWIuTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHtcblx0ICAgICAgICAgICAgICAgICAgICBib2R5OiB2YWx1ZSxcblx0ICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3Jcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChwcm9jZXNzRnVuYykge1xuXHQgICAgICAgICAgICByZXN1bHQgPSBwcm9jZXNzRnVuYyhyZXN1bHQsIHJlc3BvbnNlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgIH07XG5cdCAgICAvLyBJZiB3ZSBoYXZlIGpzb24gdG8gc2VuZCwgd2UgbXVzdFxuXHQgICAgLy8gLSBhZGQgY29udGVudC10eXBlIG9mIGFwcGxpY2F0aW9uL2pzb24gKHVubGVzcyBhbHJlYWR5IG92ZXJyaWRkZW4pXG5cdCAgICAvLyAtIGNvbnZlcnQgdGhlIGpzb24gdG8gYnl0ZXNcblx0ICAgIHZhciBib2R5ID0gbnVsbDtcblx0ICAgIGlmIChqc29uICE9IG51bGwpIHtcblx0ICAgICAgICBib2R5ID0gbGliJDgudG9VdGY4Qnl0ZXMoanNvbik7XG5cdCAgICAgICAgLy8gQ3JlYXRlIGEgY29ubmVjdGlvbiB3aXRoIHRoZSBjb250ZW50LXR5cGUgc2V0IGZvciBKU09OXG5cdCAgICAgICAgdmFyIHVwZGF0ZWQgPSAodHlwZW9mIChjb25uZWN0aW9uKSA9PT0gXCJzdHJpbmdcIikgPyAoeyB1cmw6IGNvbm5lY3Rpb24gfSkgOiBsaWIkMy5zaGFsbG93Q29weShjb25uZWN0aW9uKTtcblx0ICAgICAgICBpZiAodXBkYXRlZC5oZWFkZXJzKSB7XG5cdCAgICAgICAgICAgIHZhciBoYXNDb250ZW50VHlwZSA9IChPYmplY3Qua2V5cyh1cGRhdGVkLmhlYWRlcnMpLmZpbHRlcihmdW5jdGlvbiAoaykgeyByZXR1cm4gKGsudG9Mb3dlckNhc2UoKSA9PT0gXCJjb250ZW50LXR5cGVcIik7IH0pLmxlbmd0aCkgIT09IDA7XG5cdCAgICAgICAgICAgIGlmICghaGFzQ29udGVudFR5cGUpIHtcblx0ICAgICAgICAgICAgICAgIHVwZGF0ZWQuaGVhZGVycyA9IGxpYiQzLnNoYWxsb3dDb3B5KHVwZGF0ZWQuaGVhZGVycyk7XG5cdCAgICAgICAgICAgICAgICB1cGRhdGVkLmhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0gPSBcImFwcGxpY2F0aW9uL2pzb25cIjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgdXBkYXRlZC5oZWFkZXJzID0geyBcImNvbnRlbnQtdHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9O1xuXHQgICAgICAgIH1cblx0ICAgICAgICBjb25uZWN0aW9uID0gdXBkYXRlZDtcblx0ICAgIH1cblx0ICAgIHJldHVybiBfZmV0Y2hEYXRhKGNvbm5lY3Rpb24sIGJvZHksIHByb2Nlc3NKc29uRnVuYyk7XG5cdH1cblx0ZXhwb3J0cy5mZXRjaEpzb24gPSBmZXRjaEpzb247XG5cdGZ1bmN0aW9uIHBvbGwoZnVuYywgb3B0aW9ucykge1xuXHQgICAgaWYgKCFvcHRpb25zKSB7XG5cdCAgICAgICAgb3B0aW9ucyA9IHt9O1xuXHQgICAgfVxuXHQgICAgb3B0aW9ucyA9IGxpYiQzLnNoYWxsb3dDb3B5KG9wdGlvbnMpO1xuXHQgICAgaWYgKG9wdGlvbnMuZmxvb3IgPT0gbnVsbCkge1xuXHQgICAgICAgIG9wdGlvbnMuZmxvb3IgPSAwO1xuXHQgICAgfVxuXHQgICAgaWYgKG9wdGlvbnMuY2VpbGluZyA9PSBudWxsKSB7XG5cdCAgICAgICAgb3B0aW9ucy5jZWlsaW5nID0gMTAwMDA7XG5cdCAgICB9XG5cdCAgICBpZiAob3B0aW9ucy5pbnRlcnZhbCA9PSBudWxsKSB7XG5cdCAgICAgICAgb3B0aW9ucy5pbnRlcnZhbCA9IDI1MDtcblx0ICAgIH1cblx0ICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdCAgICAgICAgdmFyIHRpbWVyID0gbnVsbDtcblx0ICAgICAgICB2YXIgZG9uZSA9IGZhbHNlO1xuXHQgICAgICAgIC8vIFJldHVybnMgdHJ1ZSBpZiBjYW5jZWwgd2FzIHN1Y2Nlc3NmdWwuIFVuc3VjY2Vzc2Z1bCBjYW5jZWwgbWVhbnMgd2UncmUgYWxyZWFkeSBkb25lLlxuXHQgICAgICAgIHZhciBjYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGlmIChkb25lKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZG9uZSA9IHRydWU7XG5cdCAgICAgICAgICAgIGlmICh0aW1lcikge1xuXHQgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIGlmIChvcHRpb25zLnRpbWVvdXQpIHtcblx0ICAgICAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChjYW5jZWwoKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJ0aW1lb3V0XCIpKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSwgb3B0aW9ucy50aW1lb3V0KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHJldHJ5TGltaXQgPSBvcHRpb25zLnJldHJ5TGltaXQ7XG5cdCAgICAgICAgdmFyIGF0dGVtcHQgPSAwO1xuXHQgICAgICAgIGZ1bmN0aW9uIGNoZWNrKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gZnVuYygpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuXHQgICAgICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIHJlc3VsdCwgb3IgYXJlIGFsbG93ZWQgbnVsbCB0aGVuIHdlJ3JlIGRvbmVcblx0ICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChjYW5jZWwoKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5vbmNlUG9sbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMub25jZVBvbGwub25jZShcInBvbGxcIiwgY2hlY2spO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5vbmNlQmxvY2spIHtcblx0ICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm9uY2VCbG9jay5vbmNlKFwiYmxvY2tcIiwgY2hlY2spO1xuXHQgICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgZXhwb25lbnRpYWwgYmFjay1vZmYgKHVwIHRvIDEwcykgb3VyIG5leHQgcmVxdWVzdFxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWRvbmUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBhdHRlbXB0Kys7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGF0dGVtcHQgPiByZXRyeUxpbWl0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYW5jZWwoKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcInJldHJ5IGxpbWl0IHJlYWNoZWRcIikpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVvdXQgPSBvcHRpb25zLmludGVydmFsICogcGFyc2VJbnQoU3RyaW5nKE1hdGgucmFuZG9tKCkgKiBNYXRoLnBvdygyLCBhdHRlbXB0KSkpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0IDwgb3B0aW9ucy5mbG9vcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0ID0gb3B0aW9ucy5mbG9vcjtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVvdXQgPiBvcHRpb25zLmNlaWxpbmcpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dCA9IG9wdGlvbnMuY2VpbGluZztcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChjaGVjaywgdGltZW91dCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoY2FuY2VsKCkpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgY2hlY2soKTtcblx0ICAgIH0pO1xuXHR9XG5cdGV4cG9ydHMucG9sbCA9IHBvbGw7XG5cblx0fSk7XG5cblx0dmFyIGluZGV4JGwgPSB1bndyYXBFeHBvcnRzKGxpYiRsKTtcblx0dmFyIGxpYl8xJGwgPSBsaWIkbC5fZmV0Y2hEYXRhO1xuXHR2YXIgbGliXzIkaiA9IGxpYiRsLmZldGNoSnNvbjtcblx0dmFyIGxpYl8zJGYgPSBsaWIkbC5wb2xsO1xuXG5cdHZhciBfdmVyc2lvbiRJID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLnZlcnNpb24gPSBcInByb3ZpZGVycy81LjAuNVwiO1xuXG5cdH0pO1xuXG5cdHZhciBfdmVyc2lvbiRKID0gdW53cmFwRXhwb3J0cyhfdmVyc2lvbiRJKTtcblx0dmFyIF92ZXJzaW9uXzEkbSA9IF92ZXJzaW9uJEkudmVyc2lvbjtcblxuXHR2YXIgZm9ybWF0dGVyID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5cblxuXG5cblxuXG5cblx0dmFyIGxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJEkudmVyc2lvbik7XG5cdHZhciBGb3JtYXR0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBGb3JtYXR0ZXIoKSB7XG5cdCAgICAgICAgdmFyIF9uZXdUYXJnZXQgPSB0aGlzLmNvbnN0cnVjdG9yO1xuXHQgICAgICAgIGxvZ2dlci5jaGVja05ldyhfbmV3VGFyZ2V0LCBGb3JtYXR0ZXIpO1xuXHQgICAgICAgIHRoaXMuZm9ybWF0cyA9IHRoaXMuZ2V0RGVmYXVsdEZvcm1hdHMoKTtcblx0ICAgIH1cblx0ICAgIEZvcm1hdHRlci5wcm90b3R5cGUuZ2V0RGVmYXVsdEZvcm1hdHMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICB2YXIgZm9ybWF0cyA9ICh7fSk7XG5cdCAgICAgICAgdmFyIGFkZHJlc3MgPSB0aGlzLmFkZHJlc3MuYmluZCh0aGlzKTtcblx0ICAgICAgICB2YXIgYmlnTnVtYmVyID0gdGhpcy5iaWdOdW1iZXIuYmluZCh0aGlzKTtcblx0ICAgICAgICB2YXIgYmxvY2tUYWcgPSB0aGlzLmJsb2NrVGFnLmJpbmQodGhpcyk7XG5cdCAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGEuYmluZCh0aGlzKTtcblx0ICAgICAgICB2YXIgaGFzaCA9IHRoaXMuaGFzaC5iaW5kKHRoaXMpO1xuXHQgICAgICAgIHZhciBoZXggPSB0aGlzLmhleC5iaW5kKHRoaXMpO1xuXHQgICAgICAgIHZhciBudW1iZXIgPSB0aGlzLm51bWJlci5iaW5kKHRoaXMpO1xuXHQgICAgICAgIHZhciBzdHJpY3REYXRhID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIF90aGlzLmRhdGEodiwgdHJ1ZSk7IH07XG5cdCAgICAgICAgZm9ybWF0cy50cmFuc2FjdGlvbiA9IHtcblx0ICAgICAgICAgICAgaGFzaDogaGFzaCxcblx0ICAgICAgICAgICAgYmxvY2tIYXNoOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGhhc2gsIG51bGwpLFxuXHQgICAgICAgICAgICBibG9ja051bWJlcjogRm9ybWF0dGVyLmFsbG93TnVsbChudW1iZXIsIG51bGwpLFxuXHQgICAgICAgICAgICB0cmFuc2FjdGlvbkluZGV4OiBGb3JtYXR0ZXIuYWxsb3dOdWxsKG51bWJlciwgbnVsbCksXG5cdCAgICAgICAgICAgIGNvbmZpcm1hdGlvbnM6IEZvcm1hdHRlci5hbGxvd051bGwobnVtYmVyLCBudWxsKSxcblx0ICAgICAgICAgICAgZnJvbTogYWRkcmVzcyxcblx0ICAgICAgICAgICAgZ2FzUHJpY2U6IGJpZ051bWJlcixcblx0ICAgICAgICAgICAgZ2FzTGltaXQ6IGJpZ051bWJlcixcblx0ICAgICAgICAgICAgdG86IEZvcm1hdHRlci5hbGxvd051bGwoYWRkcmVzcywgbnVsbCksXG5cdCAgICAgICAgICAgIHZhbHVlOiBiaWdOdW1iZXIsXG5cdCAgICAgICAgICAgIG5vbmNlOiBudW1iZXIsXG5cdCAgICAgICAgICAgIGRhdGE6IGRhdGEsXG5cdCAgICAgICAgICAgIHI6IEZvcm1hdHRlci5hbGxvd051bGwodGhpcy51aW50MjU2KSxcblx0ICAgICAgICAgICAgczogRm9ybWF0dGVyLmFsbG93TnVsbCh0aGlzLnVpbnQyNTYpLFxuXHQgICAgICAgICAgICB2OiBGb3JtYXR0ZXIuYWxsb3dOdWxsKG51bWJlciksXG5cdCAgICAgICAgICAgIGNyZWF0ZXM6IEZvcm1hdHRlci5hbGxvd051bGwoYWRkcmVzcywgbnVsbCksXG5cdCAgICAgICAgICAgIHJhdzogRm9ybWF0dGVyLmFsbG93TnVsbChkYXRhKSxcblx0ICAgICAgICB9O1xuXHQgICAgICAgIGZvcm1hdHMudHJhbnNhY3Rpb25SZXF1ZXN0ID0ge1xuXHQgICAgICAgICAgICBmcm9tOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGFkZHJlc3MpLFxuXHQgICAgICAgICAgICBub25jZTogRm9ybWF0dGVyLmFsbG93TnVsbChudW1iZXIpLFxuXHQgICAgICAgICAgICBnYXNMaW1pdDogRm9ybWF0dGVyLmFsbG93TnVsbChiaWdOdW1iZXIpLFxuXHQgICAgICAgICAgICBnYXNQcmljZTogRm9ybWF0dGVyLmFsbG93TnVsbChiaWdOdW1iZXIpLFxuXHQgICAgICAgICAgICB0bzogRm9ybWF0dGVyLmFsbG93TnVsbChhZGRyZXNzKSxcblx0ICAgICAgICAgICAgdmFsdWU6IEZvcm1hdHRlci5hbGxvd051bGwoYmlnTnVtYmVyKSxcblx0ICAgICAgICAgICAgZGF0YTogRm9ybWF0dGVyLmFsbG93TnVsbChzdHJpY3REYXRhKSxcblx0ICAgICAgICB9O1xuXHQgICAgICAgIGZvcm1hdHMucmVjZWlwdExvZyA9IHtcblx0ICAgICAgICAgICAgdHJhbnNhY3Rpb25JbmRleDogbnVtYmVyLFxuXHQgICAgICAgICAgICBibG9ja051bWJlcjogbnVtYmVyLFxuXHQgICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2g6IGhhc2gsXG5cdCAgICAgICAgICAgIGFkZHJlc3M6IGFkZHJlc3MsXG5cdCAgICAgICAgICAgIHRvcGljczogRm9ybWF0dGVyLmFycmF5T2YoaGFzaCksXG5cdCAgICAgICAgICAgIGRhdGE6IGRhdGEsXG5cdCAgICAgICAgICAgIGxvZ0luZGV4OiBudW1iZXIsXG5cdCAgICAgICAgICAgIGJsb2NrSGFzaDogaGFzaCxcblx0ICAgICAgICB9O1xuXHQgICAgICAgIGZvcm1hdHMucmVjZWlwdCA9IHtcblx0ICAgICAgICAgICAgdG86IEZvcm1hdHRlci5hbGxvd051bGwodGhpcy5hZGRyZXNzLCBudWxsKSxcblx0ICAgICAgICAgICAgZnJvbTogRm9ybWF0dGVyLmFsbG93TnVsbCh0aGlzLmFkZHJlc3MsIG51bGwpLFxuXHQgICAgICAgICAgICBjb250cmFjdEFkZHJlc3M6IEZvcm1hdHRlci5hbGxvd051bGwoYWRkcmVzcywgbnVsbCksXG5cdCAgICAgICAgICAgIHRyYW5zYWN0aW9uSW5kZXg6IG51bWJlcixcblx0ICAgICAgICAgICAgcm9vdDogRm9ybWF0dGVyLmFsbG93TnVsbChoYXNoKSxcblx0ICAgICAgICAgICAgZ2FzVXNlZDogYmlnTnVtYmVyLFxuXHQgICAgICAgICAgICBsb2dzQmxvb206IEZvcm1hdHRlci5hbGxvd051bGwoZGF0YSksXG5cdCAgICAgICAgICAgIGJsb2NrSGFzaDogaGFzaCxcblx0ICAgICAgICAgICAgdHJhbnNhY3Rpb25IYXNoOiBoYXNoLFxuXHQgICAgICAgICAgICBsb2dzOiBGb3JtYXR0ZXIuYXJyYXlPZih0aGlzLnJlY2VpcHRMb2cuYmluZCh0aGlzKSksXG5cdCAgICAgICAgICAgIGJsb2NrTnVtYmVyOiBudW1iZXIsXG5cdCAgICAgICAgICAgIGNvbmZpcm1hdGlvbnM6IEZvcm1hdHRlci5hbGxvd051bGwobnVtYmVyLCBudWxsKSxcblx0ICAgICAgICAgICAgY3VtdWxhdGl2ZUdhc1VzZWQ6IGJpZ051bWJlcixcblx0ICAgICAgICAgICAgc3RhdHVzOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKG51bWJlcilcblx0ICAgICAgICB9O1xuXHQgICAgICAgIGZvcm1hdHMuYmxvY2sgPSB7XG5cdCAgICAgICAgICAgIGhhc2g6IGhhc2gsXG5cdCAgICAgICAgICAgIHBhcmVudEhhc2g6IGhhc2gsXG5cdCAgICAgICAgICAgIG51bWJlcjogbnVtYmVyLFxuXHQgICAgICAgICAgICB0aW1lc3RhbXA6IG51bWJlcixcblx0ICAgICAgICAgICAgbm9uY2U6IEZvcm1hdHRlci5hbGxvd051bGwoaGV4KSxcblx0ICAgICAgICAgICAgZGlmZmljdWx0eTogdGhpcy5kaWZmaWN1bHR5LmJpbmQodGhpcyksXG5cdCAgICAgICAgICAgIGdhc0xpbWl0OiBiaWdOdW1iZXIsXG5cdCAgICAgICAgICAgIGdhc1VzZWQ6IGJpZ051bWJlcixcblx0ICAgICAgICAgICAgbWluZXI6IGFkZHJlc3MsXG5cdCAgICAgICAgICAgIGV4dHJhRGF0YTogZGF0YSxcblx0ICAgICAgICAgICAgdHJhbnNhY3Rpb25zOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKEZvcm1hdHRlci5hcnJheU9mKGhhc2gpKSxcblx0ICAgICAgICB9O1xuXHQgICAgICAgIGZvcm1hdHMuYmxvY2tXaXRoVHJhbnNhY3Rpb25zID0gbGliJDMuc2hhbGxvd0NvcHkoZm9ybWF0cy5ibG9jayk7XG5cdCAgICAgICAgZm9ybWF0cy5ibG9ja1dpdGhUcmFuc2FjdGlvbnMudHJhbnNhY3Rpb25zID0gRm9ybWF0dGVyLmFsbG93TnVsbChGb3JtYXR0ZXIuYXJyYXlPZih0aGlzLnRyYW5zYWN0aW9uUmVzcG9uc2UuYmluZCh0aGlzKSkpO1xuXHQgICAgICAgIGZvcm1hdHMuZmlsdGVyID0ge1xuXHQgICAgICAgICAgICBmcm9tQmxvY2s6IEZvcm1hdHRlci5hbGxvd051bGwoYmxvY2tUYWcsIHVuZGVmaW5lZCksXG5cdCAgICAgICAgICAgIHRvQmxvY2s6IEZvcm1hdHRlci5hbGxvd051bGwoYmxvY2tUYWcsIHVuZGVmaW5lZCksXG5cdCAgICAgICAgICAgIGJsb2NrSGFzaDogRm9ybWF0dGVyLmFsbG93TnVsbChoYXNoLCB1bmRlZmluZWQpLFxuXHQgICAgICAgICAgICBhZGRyZXNzOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGFkZHJlc3MsIHVuZGVmaW5lZCksXG5cdCAgICAgICAgICAgIHRvcGljczogRm9ybWF0dGVyLmFsbG93TnVsbCh0aGlzLnRvcGljcy5iaW5kKHRoaXMpLCB1bmRlZmluZWQpLFxuXHQgICAgICAgIH07XG5cdCAgICAgICAgZm9ybWF0cy5maWx0ZXJMb2cgPSB7XG5cdCAgICAgICAgICAgIGJsb2NrTnVtYmVyOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKG51bWJlciksXG5cdCAgICAgICAgICAgIGJsb2NrSGFzaDogRm9ybWF0dGVyLmFsbG93TnVsbChoYXNoKSxcblx0ICAgICAgICAgICAgdHJhbnNhY3Rpb25JbmRleDogbnVtYmVyLFxuXHQgICAgICAgICAgICByZW1vdmVkOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKHRoaXMuYm9vbGVhbi5iaW5kKHRoaXMpKSxcblx0ICAgICAgICAgICAgYWRkcmVzczogYWRkcmVzcyxcblx0ICAgICAgICAgICAgZGF0YTogRm9ybWF0dGVyLmFsbG93RmFsc2lzaChkYXRhLCBcIjB4XCIpLFxuXHQgICAgICAgICAgICB0b3BpY3M6IEZvcm1hdHRlci5hcnJheU9mKGhhc2gpLFxuXHQgICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2g6IGhhc2gsXG5cdCAgICAgICAgICAgIGxvZ0luZGV4OiBudW1iZXIsXG5cdCAgICAgICAgfTtcblx0ICAgICAgICByZXR1cm4gZm9ybWF0cztcblx0ICAgIH07XG5cdCAgICAvLyBSZXF1aXJlcyBhIEJpZ051bWJlcmlzaCB0aGF0IGlzIHdpdGhpbiB0aGUgSUVFRTc1NCBzYWZlIGludGVnZXIgcmFuZ2U7IHJldHVybnMgYSBudW1iZXJcblx0ICAgIC8vIFN0cmljdCEgVXNlZCBvbiBpbnB1dC5cblx0ICAgIEZvcm1hdHRlci5wcm90b3R5cGUubnVtYmVyID0gZnVuY3Rpb24gKG51bWJlcikge1xuXHQgICAgICAgIHJldHVybiBsaWIkMi5CaWdOdW1iZXIuZnJvbShudW1iZXIpLnRvTnVtYmVyKCk7XG5cdCAgICB9O1xuXHQgICAgLy8gU3RyaWN0ISBVc2VkIG9uIGlucHV0LlxuXHQgICAgRm9ybWF0dGVyLnByb3RvdHlwZS5iaWdOdW1iZXIgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gbGliJDIuQmlnTnVtYmVyLmZyb20odmFsdWUpO1xuXHQgICAgfTtcblx0ICAgIC8vIFJlcXVpcmVzIGEgYm9vbGVhbiwgXCJ0cnVlXCIgb3IgIFwiZmFsc2VcIjsgcmV0dXJucyBhIGJvb2xlYW5cblx0ICAgIEZvcm1hdHRlci5wcm90b3R5cGUuYm9vbGVhbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJib29sZWFuXCIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuXHQgICAgICAgICAgICBpZiAodmFsdWUgPT09IFwidHJ1ZVwiKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAodmFsdWUgPT09IFwiZmFsc2VcIikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYm9vbGVhbiAtIFwiICsgdmFsdWUpO1xuXHQgICAgfTtcblx0ICAgIEZvcm1hdHRlci5wcm90b3R5cGUuaGV4ID0gZnVuY3Rpb24gKHZhbHVlLCBzdHJpY3QpIHtcblx0ICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgaWYgKCFzdHJpY3QgJiYgdmFsdWUuc3Vic3RyaW5nKDAsIDIpICE9PSBcIjB4XCIpIHtcblx0ICAgICAgICAgICAgICAgIHZhbHVlID0gXCIweFwiICsgdmFsdWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKGxpYiQxLmlzSGV4U3RyaW5nKHZhbHVlKSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGhhc2hcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG5cdCAgICB9O1xuXHQgICAgRm9ybWF0dGVyLnByb3RvdHlwZS5kYXRhID0gZnVuY3Rpb24gKHZhbHVlLCBzdHJpY3QpIHtcblx0ICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5oZXgodmFsdWUsIHN0cmljdCk7XG5cdCAgICAgICAgaWYgKChyZXN1bHQubGVuZ3RoICUgMikgIT09IDApIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBkYXRhOyBvZGQtbGVuZ3RoIC0gXCIgKyB2YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9O1xuXHQgICAgLy8gUmVxdWlyZXMgYW4gYWRkcmVzc1xuXHQgICAgLy8gU3RyaWN0ISBVc2VkIG9uIGlucHV0LlxuXHQgICAgRm9ybWF0dGVyLnByb3RvdHlwZS5hZGRyZXNzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuIGxpYiQ2LmdldEFkZHJlc3ModmFsdWUpO1xuXHQgICAgfTtcblx0ICAgIEZvcm1hdHRlci5wcm90b3R5cGUuY2FsbEFkZHJlc3MgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICBpZiAoIWxpYiQxLmlzSGV4U3RyaW5nKHZhbHVlLCAzMikpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBhZGRyZXNzID0gbGliJDYuZ2V0QWRkcmVzcyhsaWIkMS5oZXhEYXRhU2xpY2UodmFsdWUsIDEyKSk7XG5cdCAgICAgICAgcmV0dXJuIChhZGRyZXNzID09PSBsaWIkNy5BZGRyZXNzWmVybykgPyBudWxsIDogYWRkcmVzcztcblx0ICAgIH07XG5cdCAgICBGb3JtYXR0ZXIucHJvdG90eXBlLmNvbnRyYWN0QWRkcmVzcyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiBsaWIkNi5nZXRDb250cmFjdEFkZHJlc3ModmFsdWUpO1xuXHQgICAgfTtcblx0ICAgIC8vIFN0cmljdCEgVXNlZCBvbiBpbnB1dC5cblx0ICAgIEZvcm1hdHRlci5wcm90b3R5cGUuYmxvY2tUYWcgPSBmdW5jdGlvbiAoYmxvY2tUYWcpIHtcblx0ICAgICAgICBpZiAoYmxvY2tUYWcgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gXCJsYXRlc3RcIjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGJsb2NrVGFnID09PSBcImVhcmxpZXN0XCIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIFwiMHgwXCI7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChibG9ja1RhZyA9PT0gXCJsYXRlc3RcIiB8fCBibG9ja1RhZyA9PT0gXCJwZW5kaW5nXCIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGJsb2NrVGFnO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodHlwZW9mIChibG9ja1RhZykgPT09IFwibnVtYmVyXCIgfHwgbGliJDEuaXNIZXhTdHJpbmcoYmxvY2tUYWcpKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBsaWIkMS5oZXhWYWx1ZShibG9ja1RhZyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYmxvY2tUYWdcIik7XG5cdCAgICB9O1xuXHQgICAgLy8gUmVxdWlyZXMgYSBoYXNoLCBvcHRpb25hbGx5IHJlcXVpcmVzIDB4IHByZWZpeDsgcmV0dXJucyBwcmVmaXhlZCBsb3dlcmNhc2UgaGFzaC5cblx0ICAgIEZvcm1hdHRlci5wcm90b3R5cGUuaGFzaCA9IGZ1bmN0aW9uICh2YWx1ZSwgc3RyaWN0KSB7XG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuaGV4KHZhbHVlLCBzdHJpY3QpO1xuXHQgICAgICAgIGlmIChsaWIkMS5oZXhEYXRhTGVuZ3RoKHJlc3VsdCkgIT09IDMyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBoYXNoXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfTtcblx0ICAgIC8vIFJldHVybnMgdGhlIGRpZmZpY3VsdHkgYXMgYSBudW1iZXIsIG9yIGlmIHRvbyBsYXJnZSAoaS5lLiBQb0EgbmV0d29yaykgbnVsbFxuXHQgICAgRm9ybWF0dGVyLnByb3RvdHlwZS5kaWZmaWN1bHR5ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciB2ID0gbGliJDIuQmlnTnVtYmVyLmZyb20odmFsdWUpO1xuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2LnRvTnVtYmVyKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG5cdCAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICB9O1xuXHQgICAgRm9ybWF0dGVyLnByb3RvdHlwZS51aW50MjU2ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgaWYgKCFsaWIkMS5pc0hleFN0cmluZyh2YWx1ZSkpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB1aW50MjU2XCIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gbGliJDEuaGV4WmVyb1BhZCh2YWx1ZSwgMzIpO1xuXHQgICAgfTtcblx0ICAgIEZvcm1hdHRlci5wcm90b3R5cGUuX2Jsb2NrID0gZnVuY3Rpb24gKHZhbHVlLCBmb3JtYXQpIHtcblx0ICAgICAgICBpZiAodmFsdWUuYXV0aG9yICE9IG51bGwgJiYgdmFsdWUubWluZXIgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICB2YWx1ZS5taW5lciA9IHZhbHVlLmF1dGhvcjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIEZvcm1hdHRlci5jaGVjayhmb3JtYXQsIHZhbHVlKTtcblx0ICAgIH07XG5cdCAgICBGb3JtYXR0ZXIucHJvdG90eXBlLmJsb2NrID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX2Jsb2NrKHZhbHVlLCB0aGlzLmZvcm1hdHMuYmxvY2spO1xuXHQgICAgfTtcblx0ICAgIEZvcm1hdHRlci5wcm90b3R5cGUuYmxvY2tXaXRoVHJhbnNhY3Rpb25zID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX2Jsb2NrKHZhbHVlLCB0aGlzLmZvcm1hdHMuYmxvY2tXaXRoVHJhbnNhY3Rpb25zKTtcblx0ICAgIH07XG5cdCAgICAvLyBTdHJpY3QhIFVzZWQgb24gaW5wdXQuXG5cdCAgICBGb3JtYXR0ZXIucHJvdG90eXBlLnRyYW5zYWN0aW9uUmVxdWVzdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiBGb3JtYXR0ZXIuY2hlY2sodGhpcy5mb3JtYXRzLnRyYW5zYWN0aW9uUmVxdWVzdCwgdmFsdWUpO1xuXHQgICAgfTtcblx0ICAgIEZvcm1hdHRlci5wcm90b3R5cGUudHJhbnNhY3Rpb25SZXNwb25zZSA9IGZ1bmN0aW9uICh0cmFuc2FjdGlvbikge1xuXHQgICAgICAgIC8vIFJlbmFtZSBnYXMgdG8gZ2FzTGltaXRcblx0ICAgICAgICBpZiAodHJhbnNhY3Rpb24uZ2FzICE9IG51bGwgJiYgdHJhbnNhY3Rpb24uZ2FzTGltaXQgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICB0cmFuc2FjdGlvbi5nYXNMaW1pdCA9IHRyYW5zYWN0aW9uLmdhcztcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gU29tZSBjbGllbnRzIChUZXN0UlBDKSBkbyBzdHJhbmdlIHRoaW5ncyBsaWtlIHJldHVybiAweDAgZm9yIHRoZVxuXHQgICAgICAgIC8vIDAgYWRkcmVzczsgY29ycmVjdCB0aGlzIHRvIGJlIGEgcmVhbCBhZGRyZXNzXG5cdCAgICAgICAgaWYgKHRyYW5zYWN0aW9uLnRvICYmIGxpYiQyLkJpZ051bWJlci5mcm9tKHRyYW5zYWN0aW9uLnRvKS5pc1plcm8oKSkge1xuXHQgICAgICAgICAgICB0cmFuc2FjdGlvbi50byA9IFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCI7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIFJlbmFtZSBpbnB1dCB0byBkYXRhXG5cdCAgICAgICAgaWYgKHRyYW5zYWN0aW9uLmlucHV0ICE9IG51bGwgJiYgdHJhbnNhY3Rpb24uZGF0YSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHRyYW5zYWN0aW9uLmRhdGEgPSB0cmFuc2FjdGlvbi5pbnB1dDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gSWYgdG8gYW5kIGNyZWF0ZXMgYXJlIGVtcHR5LCBwb3B1bGF0ZSB0aGUgY3JlYXRlcyBmcm9tIHRoZSB0cmFuc2FjdGlvblxuXHQgICAgICAgIGlmICh0cmFuc2FjdGlvbi50byA9PSBudWxsICYmIHRyYW5zYWN0aW9uLmNyZWF0ZXMgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICB0cmFuc2FjdGlvbi5jcmVhdGVzID0gdGhpcy5jb250cmFjdEFkZHJlc3ModHJhbnNhY3Rpb24pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBAVE9ETzogdXNlIHRyYW5zYWN0aW9uLnNlcmlhbGl6ZT8gSGF2ZSB0byBhZGQgc3VwcG9ydCBmb3IgaW5jbHVkaW5nIHYsIHIsIGFuZCBzLi4uXG5cdCAgICAgICAgLypcblx0ICAgICAgICBpZiAoIXRyYW5zYWN0aW9uLnJhdykge1xuXHQgXG5cdCAgICAgICAgICAgICAvLyBWZXJ5IGxvb3NlIHByb3ZpZGVycyAoZS5nLiBUZXN0UlBDKSBkbyBub3QgcHJvdmlkZSBhIHNpZ25hdHVyZSBvciByYXdcblx0ICAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbi52ICYmIHRyYW5zYWN0aW9uLnIgJiYgdHJhbnNhY3Rpb24ucykge1xuXHQgICAgICAgICAgICAgICAgIGxldCByYXcgPSBbXG5cdCAgICAgICAgICAgICAgICAgICAgIHN0cmlwWmVyb3MoaGV4bGlmeSh0cmFuc2FjdGlvbi5ub25jZSkpLFxuXHQgICAgICAgICAgICAgICAgICAgICBzdHJpcFplcm9zKGhleGxpZnkodHJhbnNhY3Rpb24uZ2FzUHJpY2UpKSxcblx0ICAgICAgICAgICAgICAgICAgICAgc3RyaXBaZXJvcyhoZXhsaWZ5KHRyYW5zYWN0aW9uLmdhc0xpbWl0KSksXG5cdCAgICAgICAgICAgICAgICAgICAgICh0cmFuc2FjdGlvbi50byB8fCBcIjB4XCIpLFxuXHQgICAgICAgICAgICAgICAgICAgICBzdHJpcFplcm9zKGhleGxpZnkodHJhbnNhY3Rpb24udmFsdWUgfHwgXCIweFwiKSksXG5cdCAgICAgICAgICAgICAgICAgICAgIGhleGxpZnkodHJhbnNhY3Rpb24uZGF0YSB8fCBcIjB4XCIpLFxuXHQgICAgICAgICAgICAgICAgICAgICBzdHJpcFplcm9zKGhleGxpZnkodHJhbnNhY3Rpb24udiB8fCBcIjB4XCIpKSxcblx0ICAgICAgICAgICAgICAgICAgICAgc3RyaXBaZXJvcyhoZXhsaWZ5KHRyYW5zYWN0aW9uLnIpKSxcblx0ICAgICAgICAgICAgICAgICAgICAgc3RyaXBaZXJvcyhoZXhsaWZ5KHRyYW5zYWN0aW9uLnMpKSxcblx0ICAgICAgICAgICAgICAgICBdO1xuXHQgXG5cdCAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24ucmF3ID0gcmxwRW5jb2RlKHJhdyk7XG5cdCAgICAgICAgICAgICB9XG5cdCAgICAgICAgIH1cblx0ICAgICAgICAgKi9cblx0ICAgICAgICB2YXIgcmVzdWx0ID0gRm9ybWF0dGVyLmNoZWNrKHRoaXMuZm9ybWF0cy50cmFuc2FjdGlvbiwgdHJhbnNhY3Rpb24pO1xuXHQgICAgICAgIGlmICh0cmFuc2FjdGlvbi5jaGFpbklkICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgdmFyIGNoYWluSWQgPSB0cmFuc2FjdGlvbi5jaGFpbklkO1xuXHQgICAgICAgICAgICBpZiAobGliJDEuaXNIZXhTdHJpbmcoY2hhaW5JZCkpIHtcblx0ICAgICAgICAgICAgICAgIGNoYWluSWQgPSBsaWIkMi5CaWdOdW1iZXIuZnJvbShjaGFpbklkKS50b051bWJlcigpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJlc3VsdC5jaGFpbklkID0gY2hhaW5JZDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIHZhciBjaGFpbklkID0gdHJhbnNhY3Rpb24ubmV0d29ya0lkO1xuXHQgICAgICAgICAgICAvLyBnZXRoLWV0YyByZXR1cm5zIGNoYWluSWRcblx0ICAgICAgICAgICAgaWYgKGNoYWluSWQgPT0gbnVsbCAmJiByZXN1bHQudiA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICBjaGFpbklkID0gdHJhbnNhY3Rpb24uY2hhaW5JZDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAobGliJDEuaXNIZXhTdHJpbmcoY2hhaW5JZCkpIHtcblx0ICAgICAgICAgICAgICAgIGNoYWluSWQgPSBsaWIkMi5CaWdOdW1iZXIuZnJvbShjaGFpbklkKS50b051bWJlcigpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgKGNoYWluSWQpICE9PSBcIm51bWJlclwiICYmIHJlc3VsdC52ICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgIGNoYWluSWQgPSAocmVzdWx0LnYgLSAzNSkgLyAyO1xuXHQgICAgICAgICAgICAgICAgaWYgKGNoYWluSWQgPCAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2hhaW5JZCA9IDA7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBjaGFpbklkID0gcGFyc2VJbnQoY2hhaW5JZCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiAoY2hhaW5JZCkgIT09IFwibnVtYmVyXCIpIHtcblx0ICAgICAgICAgICAgICAgIGNoYWluSWQgPSAwO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJlc3VsdC5jaGFpbklkID0gY2hhaW5JZDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gMHgwMDAwLi4uIHNob3VsZCBhY3R1YWxseSBiZSBudWxsXG5cdCAgICAgICAgaWYgKHJlc3VsdC5ibG9ja0hhc2ggJiYgcmVzdWx0LmJsb2NrSGFzaC5yZXBsYWNlKC8wL2csIFwiXCIpID09PSBcInhcIikge1xuXHQgICAgICAgICAgICByZXN1bHQuYmxvY2tIYXNoID0gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgIH07XG5cdCAgICBGb3JtYXR0ZXIucHJvdG90eXBlLnRyYW5zYWN0aW9uID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuIGxpYiRnLnBhcnNlKHZhbHVlKTtcblx0ICAgIH07XG5cdCAgICBGb3JtYXR0ZXIucHJvdG90eXBlLnJlY2VpcHRMb2cgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gRm9ybWF0dGVyLmNoZWNrKHRoaXMuZm9ybWF0cy5yZWNlaXB0TG9nLCB2YWx1ZSk7XG5cdCAgICB9O1xuXHQgICAgRm9ybWF0dGVyLnByb3RvdHlwZS5yZWNlaXB0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IEZvcm1hdHRlci5jaGVjayh0aGlzLmZvcm1hdHMucmVjZWlwdCwgdmFsdWUpO1xuXHQgICAgICAgIGlmICh2YWx1ZS5zdGF0dXMgIT0gbnVsbCkge1xuXHQgICAgICAgICAgICByZXN1bHQuYnl6YW50aXVtID0gdHJ1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgIH07XG5cdCAgICBGb3JtYXR0ZXIucHJvdG90eXBlLnRvcGljcyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWx1ZS5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIF90aGlzLnRvcGljcyh2KTsgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2UgaWYgKHZhbHVlICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFzaCh2YWx1ZSwgdHJ1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgfTtcblx0ICAgIEZvcm1hdHRlci5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuIEZvcm1hdHRlci5jaGVjayh0aGlzLmZvcm1hdHMuZmlsdGVyLCB2YWx1ZSk7XG5cdCAgICB9O1xuXHQgICAgRm9ybWF0dGVyLnByb3RvdHlwZS5maWx0ZXJMb2cgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gRm9ybWF0dGVyLmNoZWNrKHRoaXMuZm9ybWF0cy5maWx0ZXJMb2csIHZhbHVlKTtcblx0ICAgIH07XG5cdCAgICBGb3JtYXR0ZXIuY2hlY2sgPSBmdW5jdGlvbiAoZm9ybWF0LCBvYmplY3QpIHtcblx0ICAgICAgICB2YXIgcmVzdWx0ID0ge307XG5cdCAgICAgICAgZm9yICh2YXIga2V5IGluIGZvcm1hdCkge1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gZm9ybWF0W2tleV0ob2JqZWN0W2tleV0pO1xuXHQgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgZXJyb3IuY2hlY2tLZXkgPSBrZXk7XG5cdCAgICAgICAgICAgICAgICBlcnJvci5jaGVja1ZhbHVlID0gb2JqZWN0W2tleV07XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfTtcblx0ICAgIC8vIGlmIHZhbHVlIGlzIG51bGwtaXNoLCBudWxsVmFsdWUgaXMgcmV0dXJuZWRcblx0ICAgIEZvcm1hdHRlci5hbGxvd051bGwgPSBmdW5jdGlvbiAoZm9ybWF0LCBudWxsVmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gKGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG51bGxWYWx1ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gZm9ybWF0KHZhbHVlKTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICAvLyBJZiB2YWx1ZSBpcyBmYWxzZS1pc2gsIHJlcGxhY2VWYWx1ZSBpcyByZXR1cm5lZFxuXHQgICAgRm9ybWF0dGVyLmFsbG93RmFsc2lzaCA9IGZ1bmN0aW9uIChmb3JtYXQsIHJlcGxhY2VWYWx1ZSkge1xuXHQgICAgICAgIHJldHVybiAoZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgICAgIGlmICghdmFsdWUpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiByZXBsYWNlVmFsdWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIGZvcm1hdCh2YWx1ZSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgLy8gUmVxdWlyZXMgYW4gQXJyYXkgc2F0aXNmeWluZyBjaGVja1xuXHQgICAgRm9ybWF0dGVyLmFycmF5T2YgPSBmdW5jdGlvbiAoZm9ybWF0KSB7XG5cdCAgICAgICAgcmV0dXJuIChmdW5jdGlvbiAoYXJyYXkpIHtcblx0ICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5KSkge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IGFuIGFycmF5XCIpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcblx0ICAgICAgICAgICAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZvcm1hdCh2YWx1ZSkpO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gRm9ybWF0dGVyO1xuXHR9KCkpO1xuXHRleHBvcnRzLkZvcm1hdHRlciA9IEZvcm1hdHRlcjtcblx0Ly8gU2hvdyB0aGUgdGhyb3R0bGUgbWVzc2FnZSBvbmx5IG9uY2Vcblx0dmFyIHRocm90dGxlTWVzc2FnZSA9IGZhbHNlO1xuXHRmdW5jdGlvbiBzaG93VGhyb3R0bGVNZXNzYWdlKCkge1xuXHQgICAgaWYgKHRocm90dGxlTWVzc2FnZSkge1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIHRocm90dGxlTWVzc2FnZSA9IHRydWU7XG5cdCAgICBjb25zb2xlLmxvZyhcIj09PT09PT09PSBOT1RJQ0UgPT09PT09PT09XCIpO1xuXHQgICAgY29uc29sZS5sb2coXCJSZXF1ZXN0LVJhdGUgRXhjZWVkZWQgICh0aGlzIG1lc3NhZ2Ugd2lsbCBub3QgYmUgcmVwZWF0ZWQpXCIpO1xuXHQgICAgY29uc29sZS5sb2coXCJcIik7XG5cdCAgICBjb25zb2xlLmxvZyhcIlRoZSBkZWZhdWx0IEFQSSBrZXlzIGZvciBlYWNoIHNlcnZpY2UgYXJlIHByb3ZpZGVkIGFzIGEgaGlnaGx5LXRocm90dGxlZCxcIik7XG5cdCAgICBjb25zb2xlLmxvZyhcImNvbW11bml0eSByZXNvdXJjZSBmb3IgbG93LXRyYWZmaWMgcHJvamVjdHMgYW5kIGVhcmx5IHByb3RvdHlwaW5nLlwiKTtcblx0ICAgIGNvbnNvbGUubG9nKFwiXCIpO1xuXHQgICAgY29uc29sZS5sb2coXCJXaGlsZSB5b3VyIGFwcGxpY2F0aW9uIHdpbGwgY29udGludWUgdG8gZnVuY3Rpb24sIHdlIGhpZ2hseSByZWNvbW1lbmRlZFwiKTtcblx0ICAgIGNvbnNvbGUubG9nKFwic2lnbmluZyB1cCBmb3IgeW91ciBvd24gQVBJIGtleXMgdG8gaW1wcm92ZSBwZXJmb3JtYW5jZSwgaW5jcmVhc2UgeW91clwiKTtcblx0ICAgIGNvbnNvbGUubG9nKFwicmVxdWVzdCByYXRlL2xpbWl0IGFuZCBlbmFibGUgb3RoZXIgcGVya3MsIHN1Y2ggYXMgbWV0cmljcyBhbmQgYWR2YW5jZWQgQVBJcy5cIik7XG5cdCAgICBjb25zb2xlLmxvZyhcIlwiKTtcblx0ICAgIGNvbnNvbGUubG9nKFwiRm9yIG1vcmUgZGV0YWlsczogaHR0cHM6L1xcL2RvY3MuZXRoZXJzLmlvL2FwaS1rZXlzL1wiKTtcblx0ICAgIGNvbnNvbGUubG9nKFwiPT09PT09PT09PT09PT09PT09PT09PT09PT1cIik7XG5cdH1cblx0ZXhwb3J0cy5zaG93VGhyb3R0bGVNZXNzYWdlID0gc2hvd1Rocm90dGxlTWVzc2FnZTtcblxuXHR9KTtcblxuXHR2YXIgZm9ybWF0dGVyJDEgPSB1bndyYXBFeHBvcnRzKGZvcm1hdHRlcik7XG5cdHZhciBmb3JtYXR0ZXJfMSA9IGZvcm1hdHRlci5Gb3JtYXR0ZXI7XG5cdHZhciBmb3JtYXR0ZXJfMiA9IGZvcm1hdHRlci5zaG93VGhyb3R0bGVNZXNzYWdlO1xuXG5cdHZhciBiYXNlUHJvdmlkZXIgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19leHRlbmRzID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG5cdCAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcblx0ICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG5cdCAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cblx0ICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG5cdCAgICB9O1xuXHR9KSgpO1xuXHR2YXIgX19hd2FpdGVyID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuXHQgICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG5cdCAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG5cdCAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG5cdCAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cblx0ICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG5cdCAgICB9KTtcblx0fTtcblx0dmFyIF9fZ2VuZXJhdG9yID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuXHQgICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcblx0ICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuXHQgICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG5cdCAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG5cdCAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuXHQgICAgICAgIHdoaWxlIChfKSB0cnkge1xuXHQgICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG5cdCAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcblx0ICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuXHQgICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuXHQgICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcblx0ICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG5cdCAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG5cdCAgICB9XG5cdH07XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXG5cblxuXG5cblxuXG5cblxuXHR2YXIgbG9nZ2VyID0gbmV3IGxpYi5Mb2dnZXIoX3ZlcnNpb24kSS52ZXJzaW9uKTtcblxuXHQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0Ly8gRXZlbnQgU2VyaWFsaXplaW5nXG5cdGZ1bmN0aW9uIGNoZWNrVG9waWModG9waWMpIHtcblx0ICAgIGlmICh0b3BpYyA9PSBudWxsKSB7XG5cdCAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuXHQgICAgfVxuXHQgICAgaWYgKGxpYiQxLmhleERhdGFMZW5ndGgodG9waWMpICE9PSAzMikge1xuXHQgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHRvcGljXCIsIFwidG9waWNcIiwgdG9waWMpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHRvcGljLnRvTG93ZXJDYXNlKCk7XG5cdH1cblx0ZnVuY3Rpb24gc2VyaWFsaXplVG9waWNzKHRvcGljcykge1xuXHQgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIG51bGwgQU5ELXRvcGljczsgdGhleSBhcmUgcmVkdW5kYW50XG5cdCAgICB0b3BpY3MgPSB0b3BpY3Muc2xpY2UoKTtcblx0ICAgIHdoaWxlICh0b3BpY3MubGVuZ3RoID4gMCAmJiB0b3BpY3NbdG9waWNzLmxlbmd0aCAtIDFdID09IG51bGwpIHtcblx0ICAgICAgICB0b3BpY3MucG9wKCk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdG9waWNzLm1hcChmdW5jdGlvbiAodG9waWMpIHtcblx0ICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0b3BpYykpIHtcblx0ICAgICAgICAgICAgLy8gT25seSB0cmFjayB1bmlxdWUgT1ItdG9waWNzXG5cdCAgICAgICAgICAgIHZhciB1bmlxdWVfMSA9IHt9O1xuXHQgICAgICAgICAgICB0b3BpYy5mb3JFYWNoKGZ1bmN0aW9uICh0b3BpYykge1xuXHQgICAgICAgICAgICAgICAgdW5pcXVlXzFbY2hlY2tUb3BpYyh0b3BpYyldID0gdHJ1ZTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIC8vIFRoZSBvcmRlciBvZiBPUi10b3BpY3MgZG9lcyBub3QgbWF0dGVyXG5cdCAgICAgICAgICAgIHZhciBzb3J0ZWQgPSBPYmplY3Qua2V5cyh1bmlxdWVfMSk7XG5cdCAgICAgICAgICAgIHNvcnRlZC5zb3J0KCk7XG5cdCAgICAgICAgICAgIHJldHVybiBzb3J0ZWQuam9pbihcInxcIik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICByZXR1cm4gY2hlY2tUb3BpYyh0b3BpYyk7XG5cdCAgICAgICAgfVxuXHQgICAgfSkuam9pbihcIiZcIik7XG5cdH1cblx0ZnVuY3Rpb24gZGVzZXJpYWxpemVUb3BpY3MoZGF0YSkge1xuXHQgICAgaWYgKGRhdGEgPT09IFwiXCIpIHtcblx0ICAgICAgICByZXR1cm4gW107XG5cdCAgICB9XG5cdCAgICByZXR1cm4gZGF0YS5zcGxpdCgvJi9nKS5tYXAoZnVuY3Rpb24gKHRvcGljKSB7XG5cdCAgICAgICAgaWYgKHRvcGljID09PSBcIlwiKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBbXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGNvbXBzID0gdG9waWMuc3BsaXQoXCJ8XCIpLm1hcChmdW5jdGlvbiAodG9waWMpIHtcblx0ICAgICAgICAgICAgcmV0dXJuICgodG9waWMgPT09IFwibnVsbFwiKSA/IG51bGwgOiB0b3BpYyk7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgcmV0dXJuICgoY29tcHMubGVuZ3RoID09PSAxKSA/IGNvbXBzWzBdIDogY29tcHMpO1xuXHQgICAgfSk7XG5cdH1cblx0ZnVuY3Rpb24gZ2V0RXZlbnRUYWcoZXZlbnROYW1lKSB7XG5cdCAgICBpZiAodHlwZW9mIChldmVudE5hbWUpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgZXZlbnROYW1lID0gZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XG5cdCAgICAgICAgaWYgKGxpYiQxLmhleERhdGFMZW5ndGgoZXZlbnROYW1lKSA9PT0gMzIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIFwidHg6XCIgKyBldmVudE5hbWU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChldmVudE5hbWUuaW5kZXhPZihcIjpcIikgPT09IC0xKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBldmVudE5hbWU7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShldmVudE5hbWUpKSB7XG5cdCAgICAgICAgcmV0dXJuIFwiZmlsdGVyOio6XCIgKyBzZXJpYWxpemVUb3BpY3MoZXZlbnROYW1lKTtcblx0ICAgIH1cblx0ICAgIGVsc2UgaWYgKGxpYiRiLkZvcmtFdmVudC5pc0ZvcmtFdmVudChldmVudE5hbWUpKSB7XG5cdCAgICAgICAgbG9nZ2VyLndhcm4oXCJub3QgaW1wbGVtZW50ZWRcIik7XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkXCIpO1xuXHQgICAgfVxuXHQgICAgZWxzZSBpZiAoZXZlbnROYW1lICYmIHR5cGVvZiAoZXZlbnROYW1lKSA9PT0gXCJvYmplY3RcIikge1xuXHQgICAgICAgIHJldHVybiBcImZpbHRlcjpcIiArIChldmVudE5hbWUuYWRkcmVzcyB8fCBcIipcIikgKyBcIjpcIiArIHNlcmlhbGl6ZVRvcGljcyhldmVudE5hbWUudG9waWNzIHx8IFtdKTtcblx0ICAgIH1cblx0ICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZXZlbnQgLSBcIiArIGV2ZW50TmFtZSk7XG5cdH1cblx0Ly8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdC8vIEhlbHBlciBPYmplY3Rcblx0ZnVuY3Rpb24gZ2V0VGltZSgpIHtcblx0ICAgIHJldHVybiAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuXHR9XG5cdGZ1bmN0aW9uIHN0YWxsKGR1cmF0aW9uKSB7XG5cdCAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcblx0ICAgICAgICBzZXRUaW1lb3V0KHJlc29sdmUsIGR1cmF0aW9uKTtcblx0ICAgIH0pO1xuXHR9XG5cdC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQvLyBQcm92aWRlciBPYmplY3Rcblx0LyoqXG5cdCAqICBFdmVudFR5cGVcblx0ICogICAtIFwiYmxvY2tcIlxuXHQgKiAgIC0gXCJwb2xsXCJcblx0ICogICAtIFwiZGlkUG9sbFwiXG5cdCAqICAgLSBcInBlbmRpbmdcIlxuXHQgKiAgIC0gXCJlcnJvclwiXG5cdCAqICAgLSBcIm5ldHdvcmtcIlxuXHQgKiAgIC0gZmlsdGVyXG5cdCAqICAgLSB0b3BpY3MgYXJyYXlcblx0ICogICAtIHRyYW5zYWN0aW9uIGhhc2hcblx0ICovXG5cdHZhciBQb2xsYWJsZUV2ZW50cyA9IFtcImJsb2NrXCIsIFwibmV0d29ya1wiLCBcInBlbmRpbmdcIiwgXCJwb2xsXCJdO1xuXHR2YXIgRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBFdmVudCh0YWcsIGxpc3RlbmVyLCBvbmNlKSB7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJ0YWdcIiwgdGFnKTtcblx0ICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcImxpc3RlbmVyXCIsIGxpc3RlbmVyKTtcblx0ICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcIm9uY2VcIiwgb25jZSk7XG5cdCAgICB9XG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnQucHJvdG90eXBlLCBcImV2ZW50XCIsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcblx0ICAgICAgICAgICAgICAgIGNhc2UgXCJ0eFwiOlxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhhc2g7XG5cdCAgICAgICAgICAgICAgICBjYXNlIFwiZmlsdGVyXCI6XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLnRhZztcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cdCAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG5cdCAgICB9KTtcblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudC5wcm90b3R5cGUsIFwidHlwZVwiLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLnRhZy5zcGxpdChcIjpcIilbMF07XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXHQgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHQgICAgfSk7XG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnQucHJvdG90eXBlLCBcImhhc2hcIiwge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgY29tcHMgPSB0aGlzLnRhZy5zcGxpdChcIjpcIik7XG5cdCAgICAgICAgICAgIGlmIChjb21wc1swXSAhPT0gXCJ0eFwiKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gY29tcHNbMV07XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXHQgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHQgICAgfSk7XG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnQucHJvdG90eXBlLCBcImZpbHRlclwiLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBjb21wcyA9IHRoaXMudGFnLnNwbGl0KFwiOlwiKTtcblx0ICAgICAgICAgICAgaWYgKGNvbXBzWzBdICE9PSBcImZpbHRlclwiKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgYWRkcmVzcyA9IGNvbXBzWzFdO1xuXHQgICAgICAgICAgICB2YXIgdG9waWNzID0gZGVzZXJpYWxpemVUb3BpY3MoY29tcHNbMl0pO1xuXHQgICAgICAgICAgICB2YXIgZmlsdGVyID0ge307XG5cdCAgICAgICAgICAgIGlmICh0b3BpY3MubGVuZ3RoID4gMCkge1xuXHQgICAgICAgICAgICAgICAgZmlsdGVyLnRvcGljcyA9IHRvcGljcztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAoYWRkcmVzcyAmJiBhZGRyZXNzICE9PSBcIipcIikge1xuXHQgICAgICAgICAgICAgICAgZmlsdGVyLmFkZHJlc3MgPSBhZGRyZXNzO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBmaWx0ZXI7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXHQgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHQgICAgfSk7XG5cdCAgICBFdmVudC5wcm90b3R5cGUucG9sbGFibGUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuICh0aGlzLnRhZy5pbmRleE9mKFwiOlwiKSA+PSAwIHx8IFBvbGxhYmxlRXZlbnRzLmluZGV4T2YodGhpcy50YWcpID49IDApO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBFdmVudDtcblx0fSgpKTtcblx0ZXhwb3J0cy5FdmVudCA9IEV2ZW50O1xuXHR2YXIgZGVmYXVsdEZvcm1hdHRlciA9IG51bGw7XG5cdHZhciBuZXh0UG9sbElkID0gMTtcblx0dmFyIEJhc2VQcm92aWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0ICAgIF9fZXh0ZW5kcyhCYXNlUHJvdmlkZXIsIF9zdXBlcik7XG5cdCAgICAvKipcblx0ICAgICAqICByZWFkeVxuXHQgICAgICpcblx0ICAgICAqICBBIFByb21pc2U8TmV0d29yaz4gdGhhdCByZXNvbHZlcyBvbmx5IG9uY2UgdGhlIHByb3ZpZGVyIGlzIHJlYWR5LlxuXHQgICAgICpcblx0ICAgICAqICBTdWItY2xhc3NlcyB0aGF0IGNhbGwgdGhlIHN1cGVyIHdpdGggYSBuZXR3b3JrIHdpdGhvdXQgYSBjaGFpbklkXG5cdCAgICAgKiAgTVVTVCBzZXQgdGhpcy4gU3RhbmRhcmQgbmFtZWQgbmV0d29ya3MgaGF2ZSBhIGtub3duIGNoYWluSWQuXG5cdCAgICAgKlxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBCYXNlUHJvdmlkZXIobmV0d29yaykge1xuXHQgICAgICAgIHZhciBfbmV3VGFyZ2V0ID0gdGhpcy5jb25zdHJ1Y3Rvcjtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIGxvZ2dlci5jaGVja05ldyhfbmV3VGFyZ2V0LCBsaWIkYi5Qcm92aWRlcik7XG5cdCAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuXHQgICAgICAgIC8vIEV2ZW50cyBiZWluZyBsaXN0ZW5lZCB0b1xuXHQgICAgICAgIF90aGlzLl9ldmVudHMgPSBbXTtcblx0ICAgICAgICBfdGhpcy5fZW1pdHRlZCA9IHsgYmxvY2s6IC0yIH07XG5cdCAgICAgICAgX3RoaXMuZm9ybWF0dGVyID0gX25ld1RhcmdldC5nZXRGb3JtYXR0ZXIoKTtcblx0ICAgICAgICAvLyBJZiBuZXR3b3JrIGlzIGFueSwgdGhpcyBQcm92aWRlciBhbGxvd3MgdGhlIHVuZGVybHlpbmdcblx0ICAgICAgICAvLyBuZXR3b3JrIHRvIGNoYW5nZSBkeW5hbWljYWxseSwgYW5kIHdlIGF1dG8tZGV0ZWN0IHRoZVxuXHQgICAgICAgIC8vIGN1cnJlbnQgbmV0d29ya1xuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KF90aGlzLCBcImFueU5ldHdvcmtcIiwgKG5ldHdvcmsgPT09IFwiYW55XCIpKTtcblx0ICAgICAgICBpZiAoX3RoaXMuYW55TmV0d29yaykge1xuXHQgICAgICAgICAgICBuZXR3b3JrID0gX3RoaXMuZGV0ZWN0TmV0d29yaygpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAobmV0d29yayBpbnN0YW5jZW9mIFByb21pc2UpIHtcblx0ICAgICAgICAgICAgX3RoaXMuX25ldHdvcmtQcm9taXNlID0gbmV0d29yaztcblx0ICAgICAgICAgICAgLy8gU3F1YXNoIGFueSBcInVuaGFuZGxlZCBwcm9taXNlXCIgZXJyb3JzOyB0aGF0IGRvIG5vdCBuZWVkIHRvIGJlIGhhbmRsZWRcblx0ICAgICAgICAgICAgbmV0d29yay5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHsgfSk7XG5cdCAgICAgICAgICAgIC8vIFRyaWdnZXIgaW5pdGlhbCBuZXR3b3JrIHNldHRpbmcgKGFzeW5jKVxuXHQgICAgICAgICAgICBfdGhpcy5fcmVhZHkoKS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHsgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICB2YXIga25vd25OZXR3b3JrID0gbGliJDMuZ2V0U3RhdGljKChfbmV3VGFyZ2V0KSwgXCJnZXROZXR3b3JrXCIpKG5ldHdvcmspO1xuXHQgICAgICAgICAgICBpZiAoa25vd25OZXR3b3JrKSB7XG5cdCAgICAgICAgICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seShfdGhpcywgXCJfbmV0d29ya1wiLCBrbm93bk5ldHdvcmspO1xuXHQgICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcIm5ldHdvcmtcIiwga25vd25OZXR3b3JrLCBudWxsKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIG5ldHdvcmtcIiwgXCJuZXR3b3JrXCIsIG5ldHdvcmspO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIF90aGlzLl9tYXhJbnRlcm5hbEJsb2NrTnVtYmVyID0gLTEwMjQ7XG5cdCAgICAgICAgX3RoaXMuX2xhc3RCbG9ja051bWJlciA9IC0yO1xuXHQgICAgICAgIF90aGlzLl9wb2xsaW5nSW50ZXJ2YWwgPSA0MDAwO1xuXHQgICAgICAgIF90aGlzLl9mYXN0UXVlcnlEYXRlID0gMDtcblx0ICAgICAgICByZXR1cm4gX3RoaXM7XG5cdCAgICB9XG5cdCAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLl9yZWFkeSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBuZXR3b3JrLCBlcnJvcl8xO1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh0aGlzLl9uZXR3b3JrID09IG51bGwpKSByZXR1cm4gWzMgLypicmVhayovLCA3XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbmV0d29yayA9IG51bGw7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fbmV0d29ya1Byb21pc2UpIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDE7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzEsIDMsICwgNF0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9uZXR3b3JrUHJvbWlzZV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBuZXR3b3JrID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA0XTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yXzEgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobmV0d29yayA9PSBudWxsKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZGV0ZWN0TmV0d29yaygpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5ldHdvcmsgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gNjtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbjsgZXZlcnkgUHJvdmlkZXIgc3ViLWNsYXNzIHNob3VsZCBoYXZlXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN1Z2dlc3RlZCBhIG5ldHdvcmsgYnkgaGVyZSAob3IgaGF2ZSB0aHJvd24pLlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5ldHdvcmspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwibm8gbmV0d29yayBkZXRlY3RlZFwiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTktOT1dOX0VSUk9SLCB7fSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gUG9zc2libGUgdGhpcyBjYWxsIHN0YWNrZWQgc28gZG8gbm90IGNhbGwgZGVmaW5lUmVhZE9ubHkgYWdhaW5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX25ldHdvcmsgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYW55TmV0d29yaykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX25ldHdvcmsgPSBuZXR3b3JrO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfbmV0d29ya1wiLCBuZXR3b3JrKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcIm5ldHdvcmtcIiwgbmV0d29yaywgbnVsbCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSA3O1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNzogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX25ldHdvcmtdO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZVByb3ZpZGVyLnByb3RvdHlwZSwgXCJyZWFkeVwiLCB7XG5cdCAgICAgICAgLy8gVGhpcyB3aWxsIGFsd2F5cyByZXR1cm4gdGhlIG1vc3QgcmVjZW50bHkgZXN0YWJsaXNoZWQgbmV0d29yay5cblx0ICAgICAgICAvLyBGb3IgXCJhbnlcIiwgdGhpcyBjYW4gY2hhbmdlIChhIFwibmV0d29ya1wiIGV2ZW50IGlzIGVtaXR0ZWQgYmVmb3JlXG5cdCAgICAgICAgLy8gYW55IGNoYW5nZSBpcyByZWZlbGN0ZWQpOyBvdGhlcndpc2UgdGhpcyBjYW5ub3QgY2hhbmdlXG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgIHJldHVybiBsaWIkbC5wb2xsKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fcmVhZHkoKS50aGVuKGZ1bmN0aW9uIChuZXR3b3JrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldHdvcms7XG5cdCAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgbmV0d29yayBpc24ndCBydW5uaW5nIHlldCwgd2Ugd2lsbCB3YWl0XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IGxpYi5Mb2dnZXIuZXJyb3JzLk5FVFdPUktfRVJST1IgJiYgZXJyb3IuZXZlbnQgPT09IFwibm9OZXR3b3JrXCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXHQgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHQgICAgfSk7XG5cdCAgICAvLyBAVE9ETzogUmVtb3ZlIHRoaXMgYW5kIGp1c3QgY3JlYXRlIGEgc2luZ2xldG9uIGZvcm1hdHRlclxuXHQgICAgQmFzZVByb3ZpZGVyLmdldEZvcm1hdHRlciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBpZiAoZGVmYXVsdEZvcm1hdHRlciA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIGRlZmF1bHRGb3JtYXR0ZXIgPSBuZXcgZm9ybWF0dGVyLkZvcm1hdHRlcigpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gZGVmYXVsdEZvcm1hdHRlcjtcblx0ICAgIH07XG5cdCAgICAvLyBAVE9ETzogUmVtb3ZlIHRoaXMgYW5kIGp1c3QgdXNlIGdldE5ldHdvcmtcblx0ICAgIEJhc2VQcm92aWRlci5nZXROZXR3b3JrID0gZnVuY3Rpb24gKG5ldHdvcmspIHtcblx0ICAgICAgICByZXR1cm4gbGliJGsuZ2V0TmV0d29yaygobmV0d29yayA9PSBudWxsKSA/IFwiaG9tZXN0ZWFkXCIgOiBuZXR3b3JrKTtcblx0ICAgIH07XG5cdCAgICAvLyBGZXRjaGVzIHRoZSBibG9ja051bWJlciwgYnV0IHdpbGwgcmV1c2UgYW55IHJlc3VsdCB0aGF0IGlzIGxlc3Ncblx0ICAgIC8vIHRoYW4gbWF4QWdlIG9sZCBvciBoYXMgYmVlbiByZXF1ZXN0ZWQgc2luY2UgdGhlIGxhc3QgcmVxdWVzdFxuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5fZ2V0SW50ZXJuYWxCbG9ja051bWJlciA9IGZ1bmN0aW9uIChtYXhBZ2UpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBpbnRlcm5hbEJsb2NrTnVtYmVyLCByZXN1bHQsIHJlcVRpbWUsIGNoZWNrSW50ZXJuYWxCbG9ja051bWJlcjtcblx0ICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fcmVhZHkoKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsQmxvY2tOdW1iZXIgPSB0aGlzLl9pbnRlcm5hbEJsb2NrTnVtYmVyO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtYXhBZ2UgPiAwICYmIHRoaXMuX2ludGVybmFsQmxvY2tOdW1iZXIpKSByZXR1cm4gWzMgLypicmVhayovLCAzXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgaW50ZXJuYWxCbG9ja051bWJlcl07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoZ2V0VGltZSgpIC0gcmVzdWx0LnJlc3BUaW1lKSA8PSBtYXhBZ2UpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCByZXN1bHQuYmxvY2tOdW1iZXJdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMztcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlcVRpbWUgPSBnZXRUaW1lKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrSW50ZXJuYWxCbG9ja051bWJlciA9IGxpYiQzLnJlc29sdmVQcm9wZXJ0aWVzKHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyOiB0aGlzLnBlcmZvcm0oXCJnZXRCbG9ja051bWJlclwiLCB7fSksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXR3b3JrRXJyb3I6IHRoaXMuZ2V0TmV0d29yaygpLnRoZW4oZnVuY3Rpb24gKG5ldHdvcmspIHsgcmV0dXJuIChudWxsKTsgfSwgZnVuY3Rpb24gKGVycm9yKSB7IHJldHVybiAoZXJyb3IpOyB9KVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJsb2NrTnVtYmVyID0gX2EuYmxvY2tOdW1iZXIsIG5ldHdvcmtFcnJvciA9IF9hLm5ldHdvcmtFcnJvcjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXR3b3JrRXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVbnJlbWVtYmVyIHRoaXMgYmFkIGludGVybmFsIGJsb2NrIG51bWJlclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5faW50ZXJuYWxCbG9ja051bWJlciA9PT0gY2hlY2tJbnRlcm5hbEJsb2NrTnVtYmVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9pbnRlcm5hbEJsb2NrTnVtYmVyID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV0d29ya0Vycm9yO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3BUaW1lID0gZ2V0VGltZSgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tOdW1iZXIgPSBsaWIkMi5CaWdOdW1iZXIuZnJvbShibG9ja051bWJlcikudG9OdW1iZXIoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChibG9ja051bWJlciA8IF90aGlzLl9tYXhJbnRlcm5hbEJsb2NrTnVtYmVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tOdW1iZXIgPSBfdGhpcy5fbWF4SW50ZXJuYWxCbG9ja051bWJlcjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9tYXhJbnRlcm5hbEJsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc2V0RmFzdEJsb2NrTnVtYmVyKGJsb2NrTnVtYmVyKTsgLy8gQFRPRE86IFN0aWxsIG5lZWQgdGhpcz9cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGJsb2NrTnVtYmVyOiBibG9ja051bWJlciwgcmVxVGltZTogcmVxVGltZSwgcmVzcFRpbWU6IHJlc3BUaW1lIH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbnRlcm5hbEJsb2NrTnVtYmVyID0gY2hlY2tJbnRlcm5hbEJsb2NrTnVtYmVyO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBjaGVja0ludGVybmFsQmxvY2tOdW1iZXJdO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIChfYS5zZW50KCkpLmJsb2NrTnVtYmVyXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5wb2xsID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIHBvbGxJZCwgcnVubmVycywgYmxvY2tOdW1iZXIsIGk7XG5cdCAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHBvbGxJZCA9IG5leHRQb2xsSWQrKztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcnVubmVycyA9IFtdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9nZXRJbnRlcm5hbEJsb2NrTnVtYmVyKDEwMCArIHRoaXMucG9sbGluZ0ludGVydmFsIC8gMildO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tOdW1iZXIgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldEZhc3RCbG9ja051bWJlcihibG9ja051bWJlcik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVtaXQgYSBwb2xsIGV2ZW50IGFmdGVyIHdlIGhhdmUgdGhlIGxhdGVzdCAoZmFzdCkgYmxvY2sgbnVtYmVyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcInBvbGxcIiwgcG9sbElkLCBibG9ja051bWJlcik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBibG9jayBoYXMgbm90IGNoYW5nZWQsIG1laC5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJsb2NrTnVtYmVyID09PSB0aGlzLl9sYXN0QmxvY2tOdW1iZXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRpZFBvbGxcIiwgcG9sbElkKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaXJzdCBwb2xsaW5nIGN5Y2xlLCB0cmlnZ2VyIGEgXCJibG9ja1wiIGV2ZW50c1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fZW1pdHRlZC5ibG9jayA9PT0gLTIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VtaXR0ZWQuYmxvY2sgPSBibG9ja051bWJlciAtIDE7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKCh0aGlzLl9lbWl0dGVkLmJsb2NrKSAtIGJsb2NrTnVtYmVyKSA+IDEwMDApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKFwibmV0d29yayBibG9jayBza2V3IGRldGVjdGVkOyBza2lwcGluZyBibG9jayBldmVudHNcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBsb2dnZXIubWFrZUVycm9yKFwibmV0d29yayBibG9jayBza2V3IGRldGVjdGVkXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLk5FVFdPUktfRVJST1IsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja051bWJlcjogYmxvY2tOdW1iZXIsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IFwiYmxvY2tTa2V3XCIsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNCbG9ja051bWJlcjogdGhpcy5fZW1pdHRlZC5ibG9ja1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiYmxvY2tcIiwgYmxvY2tOdW1iZXIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90aWZ5IGFsbCBsaXN0ZW5lciBmb3IgZWFjaCBibG9jayB0aGF0IGhhcyBwYXNzZWRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IHRoaXMuX2VtaXR0ZWQuYmxvY2sgKyAxOyBpIDw9IGJsb2NrTnVtYmVyOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJibG9ja1wiLCBpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZW1pdHRlZCBibG9jayB3YXMgdXBkYXRlZCwgY2hlY2sgZm9yIG9ic29sZXRlIGV2ZW50c1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fZW1pdHRlZC5ibG9jayAhPT0gYmxvY2tOdW1iZXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VtaXR0ZWQuYmxvY2sgPSBibG9ja051bWJlcjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX2VtaXR0ZWQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBibG9jayBldmVudCBkb2VzIG5vdCBleHBpcmVcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSBcImJsb2NrXCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgYmxvY2sgd2Ugd2VyZSBhdCB3aGVuIHdlIGVtaXR0ZWQgdGhpcyBldmVudFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBldmVudEJsb2NrTnVtYmVyID0gX3RoaXMuX2VtaXR0ZWRba2V5XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBjYW5ub3QgZ2FyYmFnZSBjb2xsZWN0IHBlbmRpbmcgdHJhbnNhY3Rpb25zIG9yIGJsb2NrcyBoZXJlXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhleSBzaG91bGQgYmUgZ2FyYmFnZSBjb2xsZWN0ZWQgYnkgdGhlIFByb3ZpZGVyIHdoZW4gc2V0dGluZ1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFwicGVuZGluZ1wiIGV2ZW50c1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudEJsb2NrTnVtYmVyID09PSBcInBlbmRpbmdcIikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV2aWN0IGFueSB0cmFuc2FjdGlvbiBoYXNoZXMgb3IgYmxvY2sgaGFzaGVzIG92ZXIgMTIgYmxvY2tzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2xkLCBzaW5jZSB0aGV5IHNob3VsZCBub3QgcmV0dXJuIG51bGwgYW55d2F5c1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChibG9ja051bWJlciAtIGV2ZW50QmxvY2tOdW1iZXIgPiAxMikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgX3RoaXMuX2VtaXR0ZWRba2V5XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaXJzdCBwb2xsaW5nIGN5Y2xlXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9sYXN0QmxvY2tOdW1iZXIgPT09IC0yKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXN0QmxvY2tOdW1iZXIgPSBibG9ja051bWJlciAtIDE7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmluZCBhbGwgdHJhbnNhY3Rpb24gaGFzaGVzIHdlIGFyZSB3YWl0aW5nIG9uXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInR4XCI6IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhhc2hfMiA9IGV2ZW50Lmhhc2g7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBydW5uZXIgPSBfdGhpcy5nZXRUcmFuc2FjdGlvblJlY2VpcHQoaGFzaF8yKS50aGVuKGZ1bmN0aW9uIChyZWNlaXB0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlY2VpcHQgfHwgcmVjZWlwdC5ibG9ja051bWJlciA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fZW1pdHRlZFtcInQ6XCIgKyBoYXNoXzJdID0gcmVjZWlwdC5ibG9ja051bWJlcjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoaGFzaF8yLCByZWNlaXB0KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHsgX3RoaXMuZW1pdChcImVycm9yXCIsIGVycm9yKTsgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5lcnMucHVzaChydW5uZXIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImZpbHRlclwiOiB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWx0ZXJfMSA9IGV2ZW50LmZpbHRlcjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyXzEuZnJvbUJsb2NrID0gX3RoaXMuX2xhc3RCbG9ja051bWJlciArIDE7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlcl8xLnRvQmxvY2sgPSBibG9ja051bWJlcjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJ1bm5lciA9IF90aGlzLmdldExvZ3MoZmlsdGVyXzEpLnRoZW4oZnVuY3Rpb24gKGxvZ3MpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2dzLmxlbmd0aCA9PT0gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ3MuZm9yRWFjaChmdW5jdGlvbiAobG9nKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2VtaXR0ZWRbXCJiOlwiICsgbG9nLmJsb2NrSGFzaF0gPSBsb2cuYmxvY2tOdW1iZXI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2VtaXR0ZWRbXCJ0OlwiICsgbG9nLnRyYW5zYWN0aW9uSGFzaF0gPSBsb2cuYmxvY2tOdW1iZXI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdChmaWx0ZXJfMSwgbG9nKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHsgX3RoaXMuZW1pdChcImVycm9yXCIsIGVycm9yKTsgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5lcnMucHVzaChydW5uZXIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXN0QmxvY2tOdW1iZXIgPSBibG9ja051bWJlcjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25jZSBhbGwgZXZlbnRzIGZvciB0aGlzIGxvb3AgaGF2ZSBiZWVuIHByb2Nlc3NlZCwgZW1pdCBcImRpZFBvbGxcIlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBQcm9taXNlLmFsbChydW5uZXJzKS50aGVuKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoXCJkaWRQb2xsXCIsIHBvbGxJZCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbnVsbF07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIC8vIERlcHJlY2F0ZWQ7IGRvIG5vdCB1c2UgdGhpc1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5yZXNldEV2ZW50c0Jsb2NrID0gZnVuY3Rpb24gKGJsb2NrTnVtYmVyKSB7XG5cdCAgICAgICAgdGhpcy5fbGFzdEJsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXIgLSAxO1xuXHQgICAgICAgIGlmICh0aGlzLnBvbGxpbmcpIHtcblx0ICAgICAgICAgICAgdGhpcy5wb2xsKCk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNlUHJvdmlkZXIucHJvdG90eXBlLCBcIm5ldHdvcmtcIiwge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fbmV0d29yaztcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cdCAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG5cdCAgICB9KTtcblx0ICAgIC8vIFRoaXMgbWV0aG9kIHNob3VsZCBxdWVyeSB0aGUgbmV0d29yayBpZiB0aGUgdW5kZXJseWluZyBuZXR3b3JrXG5cdCAgICAvLyBjYW4gY2hhbmdlLCBzdWNoIGFzIHdoZW4gY29ubmVjdGVkIHRvIGEgSlNPTi1SUEMgYmFja2VuZFxuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5kZXRlY3ROZXR3b3JrID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGxvZ2dlci50aHJvd0Vycm9yKFwicHJvdmlkZXIgZG9lcyBub3Qgc3VwcG9ydCBuZXR3b3JrIGRldGVjdGlvblwiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInByb3ZpZGVyLmRldGVjdE5ldHdvcmtcIlxuXHQgICAgICAgICAgICAgICAgICAgIH0pXTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5nZXROZXR3b3JrID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIG5ldHdvcmssIGN1cnJlbnROZXR3b3JrLCBlcnJvcjtcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fcmVhZHkoKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBuZXR3b3JrID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmRldGVjdE5ldHdvcmsoKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50TmV0d29yayA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobmV0d29yay5jaGFpbklkICE9PSBjdXJyZW50TmV0d29yay5jaGFpbklkKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5hbnlOZXR3b3JrKSByZXR1cm4gWzMgLypicmVhayovLCA0XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbmV0d29yayA9IGN1cnJlbnROZXR3b3JrO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXNldCBhbGwgaW50ZXJuYWwgYmxvY2sgbnVtYmVyIGd1YXJkcyBhbmQgY2FjaGVzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RCbG9ja051bWJlciA9IC0yO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9mYXN0QmxvY2tOdW1iZXIgPSBudWxsO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9mYXN0QmxvY2tOdW1iZXJQcm9taXNlID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmFzdFF1ZXJ5RGF0ZSA9IDA7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VtaXR0ZWQuYmxvY2sgPSAtMjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWF4SW50ZXJuYWxCbG9ja051bWJlciA9IC0xMDI0O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbnRlcm5hbEJsb2NrTnVtYmVyID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIFwibmV0d29ya1wiIGV2ZW50IE1VU1QgaGFwcGVuIGJlZm9yZSB0aGlzIG1ldGhvZCByZXNvbHZlc1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBzbyBhbnkgZXZlbnRzIGhhdmUgYSBjaGFuY2UgdG8gdW5yZWdpc3Rlciwgc28gd2Ugc3RhbGwgYW5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkaXRpb25hbCBldmVudCBsb29wIGJlZm9yZSByZXR1cm5pbmcgZnJvbSAvdGhpcy8gY2FsbFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJuZXR3b3JrXCIsIGN1cnJlbnROZXR3b3JrLCBuZXR3b3JrKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgc3RhbGwoMCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fbmV0d29ya107XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9IGxvZ2dlci5tYWtlRXJyb3IoXCJ1bmRlcmx5aW5nIG5ldHdvcmsgY2hhbmdlZFwiLCBsaWIuTG9nZ2VyLmVycm9ycy5ORVRXT1JLX0VSUk9SLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudDogXCJjaGFuZ2VkXCIsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXR3b3JrOiBuZXR3b3JrLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0ZWN0ZWROZXR3b3JrOiBjdXJyZW50TmV0d29ya1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgZXJyb3IpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbMiAvKnJldHVybiovLCBuZXR3b3JrXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2VQcm92aWRlci5wcm90b3R5cGUsIFwiYmxvY2tOdW1iZXJcIiwge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgICAgICB0aGlzLl9nZXRJbnRlcm5hbEJsb2NrTnVtYmVyKDEwMCArIHRoaXMucG9sbGluZ0ludGVydmFsIC8gMikudGhlbihmdW5jdGlvbiAoYmxvY2tOdW1iZXIpIHtcblx0ICAgICAgICAgICAgICAgIF90aGlzLl9zZXRGYXN0QmxvY2tOdW1iZXIoYmxvY2tOdW1iZXIpO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9mYXN0QmxvY2tOdW1iZXIgIT0gbnVsbCkgPyB0aGlzLl9mYXN0QmxvY2tOdW1iZXIgOiAtMTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cdCAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG5cdCAgICB9KTtcblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNlUHJvdmlkZXIucHJvdG90eXBlLCBcInBvbGxpbmdcIiwge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gKHRoaXMuX3BvbGxlciAhPSBudWxsKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgIGlmICh2YWx1ZSAmJiAhdGhpcy5fcG9sbGVyKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9wb2xsZXIgPSBzZXRJbnRlcnZhbCh0aGlzLnBvbGwuYmluZCh0aGlzKSwgdGhpcy5wb2xsaW5nSW50ZXJ2YWwpO1xuXHQgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9ib290c3RyYXBQb2xsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fYm9vdHN0cmFwUG9sbCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5wb2xsKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGJsb2NrIGFkZGl0aW9uYWwgcG9sbHMgdW50aWwgdGhlIHBvbGxpbmcgaW50ZXJ2YWxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXMgZG9uZSwgdG8gcHJldmVudCBvdmVyd2hlbG1pbmcgdGhlIHBvbGwgZnVuY3Rpb25cblx0ICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2Jvb3RzdHJhcFBvbGwgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHBvbGxpbmcgd2FzIGRpc2FibGVkLCBzb21ldGhpbmcgbWF5IHJlcXVpcmUgYSBwb2tlXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzaW5jZSBzdGFydGluZyB0aGUgYm9vdHN0cmFwIHBvbGwgYW5kIGl0IHdhcyBkaXNhYmxlZFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5fcG9sbGVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucG9sbCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2xlYXIgb3V0IHRoZSBib290c3RyYXAgc28gd2UgY2FuIGRvIGFub3RoZXJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9ib290c3RyYXBQb2xsID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSwgX3RoaXMucG9sbGluZ0ludGVydmFsKTtcblx0ICAgICAgICAgICAgICAgICAgICB9LCAwKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIGlmICghdmFsdWUgJiYgdGhpcy5fcG9sbGVyKSB7XG5cdCAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuX3BvbGxlcik7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9wb2xsZXIgPSBudWxsO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXHQgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHQgICAgfSk7XG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZVByb3ZpZGVyLnByb3RvdHlwZSwgXCJwb2xsaW5nSW50ZXJ2YWxcIiwge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fcG9sbGluZ0ludGVydmFsO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpICE9PSBcIm51bWJlclwiIHx8IHZhbHVlIDw9IDAgfHwgcGFyc2VJbnQoU3RyaW5nKHZhbHVlKSkgIT0gdmFsdWUpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcG9sbGluZyBpbnRlcnZhbFwiKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0aGlzLl9wb2xsaW5nSW50ZXJ2YWwgPSB2YWx1ZTtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3BvbGxlcikge1xuXHQgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9wb2xsZXIpO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fcG9sbGVyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkgeyBfdGhpcy5wb2xsKCk7IH0sIHRoaXMuX3BvbGxpbmdJbnRlcnZhbCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXHQgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cdCAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG5cdCAgICB9KTtcblx0ICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuX2dldEZhc3RCbG9ja051bWJlciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIHZhciBub3cgPSBnZXRUaW1lKCk7XG5cdCAgICAgICAgLy8gU3RhbGUgYmxvY2sgbnVtYmVyLCByZXF1ZXN0IGEgbmV3ZXIgdmFsdWVcblx0ICAgICAgICBpZiAoKG5vdyAtIHRoaXMuX2Zhc3RRdWVyeURhdGUpID4gMiAqIHRoaXMuX3BvbGxpbmdJbnRlcnZhbCkge1xuXHQgICAgICAgICAgICB0aGlzLl9mYXN0UXVlcnlEYXRlID0gbm93O1xuXHQgICAgICAgICAgICB0aGlzLl9mYXN0QmxvY2tOdW1iZXJQcm9taXNlID0gdGhpcy5nZXRCbG9ja051bWJlcigpLnRoZW4oZnVuY3Rpb24gKGJsb2NrTnVtYmVyKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX2Zhc3RCbG9ja051bWJlciA9PSBudWxsIHx8IGJsb2NrTnVtYmVyID4gX3RoaXMuX2Zhc3RCbG9ja051bWJlcikge1xuXHQgICAgICAgICAgICAgICAgICAgIF90aGlzLl9mYXN0QmxvY2tOdW1iZXIgPSBibG9ja051bWJlcjtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fZmFzdEJsb2NrTnVtYmVyO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX2Zhc3RCbG9ja051bWJlclByb21pc2U7XG5cdCAgICB9O1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5fc2V0RmFzdEJsb2NrTnVtYmVyID0gZnVuY3Rpb24gKGJsb2NrTnVtYmVyKSB7XG5cdCAgICAgICAgLy8gT2xkZXIgYmxvY2ssIG1heWJlIGEgc3RhbGUgcmVxdWVzdFxuXHQgICAgICAgIGlmICh0aGlzLl9mYXN0QmxvY2tOdW1iZXIgIT0gbnVsbCAmJiBibG9ja051bWJlciA8IHRoaXMuX2Zhc3RCbG9ja051bWJlcikge1xuXHQgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIFVwZGF0ZSB0aGUgdGltZSB3ZSB1cGRhdGVkIHRoZSBibG9ja251bWJlclxuXHQgICAgICAgIHRoaXMuX2Zhc3RRdWVyeURhdGUgPSBnZXRUaW1lKCk7XG5cdCAgICAgICAgLy8gTmV3ZXIgYmxvY2sgbnVtYmVyLCB1c2UgIGl0XG5cdCAgICAgICAgaWYgKHRoaXMuX2Zhc3RCbG9ja051bWJlciA9PSBudWxsIHx8IGJsb2NrTnVtYmVyID4gdGhpcy5fZmFzdEJsb2NrTnVtYmVyKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2Zhc3RCbG9ja051bWJlciA9IGJsb2NrTnVtYmVyO1xuXHQgICAgICAgICAgICB0aGlzLl9mYXN0QmxvY2tOdW1iZXJQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGJsb2NrTnVtYmVyKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS53YWl0Rm9yVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAodHJhbnNhY3Rpb25IYXNoLCBjb25maXJtYXRpb25zLCB0aW1lb3V0KSB7XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgcmVjZWlwdDtcblx0ICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpcm1hdGlvbnMgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlybWF0aW9ucyA9IDE7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5nZXRUcmFuc2FjdGlvblJlY2VpcHQodHJhbnNhY3Rpb25IYXNoKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZWNlaXB0ID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZWNlaXB0IGlzIGFscmVhZHkgZ29vZFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHJlY2VpcHQgPyByZWNlaXB0LmNvbmZpcm1hdGlvbnMgOiAwKSA+PSBjb25maXJtYXRpb25zKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVjZWlwdF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gUG9sbCB1bnRpbCB0aGUgcmVjZWlwdCBpcyBnb29kLi4uXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVyID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG9uZSA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24gKHJlY2VpcHQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlY2VpcHQuY29uZmlybWF0aW9ucyA8IGNvbmZpcm1hdGlvbnMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGltZXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVtb3ZlTGlzdGVuZXIodHJhbnNhY3Rpb25IYXNoLCBoYW5kbGVyKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZWNlaXB0KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm9uKHRyYW5zYWN0aW9uSGFzaCwgaGFuZGxlcik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAodGltZW91dCkgPT09IFwibnVtYmVyXCIgJiYgdGltZW91dCA+IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZXIgPSBudWxsO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZW1vdmVMaXN0ZW5lcih0cmFuc2FjdGlvbkhhc2gsIGhhbmRsZXIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGxvZ2dlci5tYWtlRXJyb3IoXCJ0aW1lb3V0IGV4Y2VlZGVkXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLlRJTUVPVVQsIHsgdGltZW91dDogdGltZW91dCB9KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGltZXIudW5yZWYpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVyLnVucmVmKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuZ2V0QmxvY2tOdW1iZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fZ2V0SW50ZXJuYWxCbG9ja051bWJlcigwKV07XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuZ2V0R2FzUHJpY2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgX2EsIF9iO1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldE5ldHdvcmsoKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYy5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9iID0gKF9hID0gbGliJDIuQmlnTnVtYmVyKS5mcm9tO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnBlcmZvcm0oXCJnZXRHYXNQcmljZVwiLCB7fSldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9iLmFwcGx5KF9hLCBbX2Muc2VudCgpXSldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLmdldEJhbGFuY2UgPSBmdW5jdGlvbiAoYWRkcmVzc09yTmFtZSwgYmxvY2tUYWcpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBwYXJhbXMsIF9hLCBfYjtcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYykge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5nZXROZXR3b3JrKCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2Muc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBsaWIkMy5yZXNvbHZlUHJvcGVydGllcyh7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogdGhpcy5fZ2V0QWRkcmVzcyhhZGRyZXNzT3JOYW1lKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja1RhZzogdGhpcy5fZ2V0QmxvY2tUYWcoYmxvY2tUYWcpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBfYy5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9iID0gKF9hID0gbGliJDIuQmlnTnVtYmVyKS5mcm9tO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnBlcmZvcm0oXCJnZXRCYWxhbmNlXCIsIHBhcmFtcyldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9iLmFwcGx5KF9hLCBbX2Muc2VudCgpXSldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLmdldFRyYW5zYWN0aW9uQ291bnQgPSBmdW5jdGlvbiAoYWRkcmVzc09yTmFtZSwgYmxvY2tUYWcpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBwYXJhbXMsIF9hLCBfYjtcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYykge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5nZXROZXR3b3JrKCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2Muc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBsaWIkMy5yZXNvbHZlUHJvcGVydGllcyh7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogdGhpcy5fZ2V0QWRkcmVzcyhhZGRyZXNzT3JOYW1lKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja1RhZzogdGhpcy5fZ2V0QmxvY2tUYWcoYmxvY2tUYWcpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBfYy5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9iID0gKF9hID0gbGliJDIuQmlnTnVtYmVyKS5mcm9tO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnBlcmZvcm0oXCJnZXRUcmFuc2FjdGlvbkNvdW50XCIsIHBhcmFtcyldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9iLmFwcGx5KF9hLCBbX2Muc2VudCgpXSkudG9OdW1iZXIoKV07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuZ2V0Q29kZSA9IGZ1bmN0aW9uIChhZGRyZXNzT3JOYW1lLCBibG9ja1RhZykge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIHBhcmFtcywgX2E7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0TmV0d29yaygpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgbGliJDMucmVzb2x2ZVByb3BlcnRpZXMoe1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IHRoaXMuX2dldEFkZHJlc3MoYWRkcmVzc09yTmFtZSksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tUYWc6IHRoaXMuX2dldEJsb2NrVGFnKGJsb2NrVGFnKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0gX2Iuc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYSA9IGxpYiQxLmhleGxpZnk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucGVyZm9ybShcImdldENvZGVcIiwgcGFyYW1zKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2EuYXBwbHkodm9pZCAwLCBbX2Iuc2VudCgpXSldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLmdldFN0b3JhZ2VBdCA9IGZ1bmN0aW9uIChhZGRyZXNzT3JOYW1lLCBwb3NpdGlvbiwgYmxvY2tUYWcpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBwYXJhbXMsIF9hO1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldE5ldHdvcmsoKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYi5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGxpYiQzLnJlc29sdmVQcm9wZXJ0aWVzKHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiB0aGlzLl9nZXRBZGRyZXNzKGFkZHJlc3NPck5hbWUpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrVGFnOiB0aGlzLl9nZXRCbG9ja1RhZyhibG9ja1RhZyksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IFByb21pc2UucmVzb2x2ZShwb3NpdGlvbikudGhlbihmdW5jdGlvbiAocCkgeyByZXR1cm4gbGliJDEuaGV4VmFsdWUocCk7IH0pXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBfYi5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gbGliJDEuaGV4bGlmeTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5wZXJmb3JtKFwiZ2V0U3RvcmFnZUF0XCIsIHBhcmFtcyldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLmFwcGx5KHZvaWQgMCwgW19iLnNlbnQoKV0pXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgLy8gVGhpcyBzaG91bGQgYmUgY2FsbGVkIGJ5IGFueSBzdWJjbGFzcyB3cmFwcGluZyBhIFRyYW5zYWN0aW9uUmVzcG9uc2Vcblx0ICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuX3dyYXBUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uICh0eCwgaGFzaCkge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgaWYgKGhhc2ggIT0gbnVsbCAmJiBsaWIkMS5oZXhEYXRhTGVuZ3RoKGhhc2gpICE9PSAzMikge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHJlc3BvbnNlIC0gc2VuZFRyYW5zYWN0aW9uXCIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgcmVzdWx0ID0gdHg7XG5cdCAgICAgICAgLy8gQ2hlY2sgdGhlIGhhc2ggd2UgZXhwZWN0IGlzIHRoZSBzYW1lIGFzIHRoZSBoYXNoIHRoZSBzZXJ2ZXIgcmVwb3J0ZWRcblx0ICAgICAgICBpZiAoaGFzaCAhPSBudWxsICYmIHR4Lmhhc2ggIT09IGhhc2gpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJUcmFuc2FjdGlvbiBoYXNoIG1pc21hdGNoIGZyb20gUHJvdmlkZXIuc2VuZFRyYW5zYWN0aW9uLlwiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTktOT1dOX0VSUk9SLCB7IGV4cGVjdGVkSGFzaDogdHguaGFzaCwgcmV0dXJuZWRIYXNoOiBoYXNoIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBAVE9ETzogKGNvbmZpcm1hdGlvbnM/IG51bWJlciwgdGltZW91dD8gbnVtYmVyKVxuXHQgICAgICAgIHJlc3VsdC53YWl0ID0gZnVuY3Rpb24gKGNvbmZpcm1hdGlvbnMpIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIHJlY2VpcHQ7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGtub3cgdGhpcyB0cmFuc2FjdGlvbiAqbXVzdCogZXhpc3QgKHdoZXRoZXIgaXQgZ2V0cyBtaW5lZCBpc1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbm90aGVyIHN0b3J5KSwgc28gc2V0dGluZyBhbiBlbWl0dGVkIHZhbHVlIGZvcmNlcyB1cyB0b1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyB3YWl0IGV2ZW4gaWYgdGhlIG5vZGUgcmV0dXJucyBudWxsIGZvciB0aGUgcmVjZWlwdFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlybWF0aW9ucyAhPT0gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW1pdHRlZFtcInQ6XCIgKyB0eC5oYXNoXSA9IFwicGVuZGluZ1wiO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMud2FpdEZvclRyYW5zYWN0aW9uKHR4Lmhhc2gsIGNvbmZpcm1hdGlvbnMpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpcHQgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWNlaXB0ID09IG51bGwgJiYgY29uZmlybWF0aW9ucyA9PT0gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG51bGxdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vIGxvbmdlciBwZW5kaW5nLCBhbGxvdyB0aGUgcG9sbGluZyBsb29wIHRvIGdhcmJhZ2UgY29sbGVjdCB0aGlzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VtaXR0ZWRbXCJ0OlwiICsgdHguaGFzaF0gPSByZWNlaXB0LmJsb2NrTnVtYmVyO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVjZWlwdC5zdGF0dXMgPT09IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidHJhbnNhY3Rpb24gZmFpbGVkXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLkNBTExfRVhDRVBUSU9OLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25IYXNoOiB0eC5oYXNoLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0eCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNlaXB0OiByZWNlaXB0XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVjZWlwdF07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pOyB9O1xuXHQgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9O1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5zZW5kVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAoc2lnbmVkVHJhbnNhY3Rpb24pIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBoZXhUeCwgdHgsIGhhc2gsIGVycm9yXzI7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0TmV0d29yaygpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgUHJvbWlzZS5yZXNvbHZlKHNpZ25lZFRyYW5zYWN0aW9uKS50aGVuKGZ1bmN0aW9uICh0KSB7IHJldHVybiBsaWIkMS5oZXhsaWZ5KHQpOyB9KV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBoZXhUeCA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHggPSB0aGlzLmZvcm1hdHRlci50cmFuc2FjdGlvbihzaWduZWRUcmFuc2FjdGlvbik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMztcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMywgNSwgLCA2XSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucGVyZm9ybShcInNlbmRUcmFuc2FjdGlvblwiLCB7IHNpZ25lZFRyYW5zYWN0aW9uOiBoZXhUeCB9KV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBoYXNoID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fd3JhcFRyYW5zYWN0aW9uKHR4LCBoYXNoKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl8yID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl8yLnRyYW5zYWN0aW9uID0gdHg7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yXzIudHJhbnNhY3Rpb25IYXNoID0gdHguaGFzaDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3JfMjtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDY6IHJldHVybiBbMiAvKnJldHVybiovXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5fZ2V0VHJhbnNhY3Rpb25SZXF1ZXN0ID0gZnVuY3Rpb24gKHRyYW5zYWN0aW9uKSB7XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgdmFsdWVzLCB0eCwgX2EsIF9iO1xuXHQgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0cmFuc2FjdGlvbl07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgPSBfYy5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR4ID0ge307XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFtcImZyb21cIiwgXCJ0b1wiXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZXNba2V5XSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHhba2V5XSA9IFByb21pc2UucmVzb2x2ZSh2YWx1ZXNba2V5XSkudGhlbihmdW5jdGlvbiAodikgeyByZXR1cm4gKHYgPyBfdGhpcy5fZ2V0QWRkcmVzcyh2KSA6IG51bGwpOyB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFtcImdhc0xpbWl0XCIsIFwiZ2FzUHJpY2VcIiwgXCJ2YWx1ZVwiXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZXNba2V5XSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHhba2V5XSA9IFByb21pc2UucmVzb2x2ZSh2YWx1ZXNba2V5XSkudGhlbihmdW5jdGlvbiAodikgeyByZXR1cm4gKHYgPyBsaWIkMi5CaWdOdW1iZXIuZnJvbSh2KSA6IG51bGwpOyB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFtcImRhdGFcIl0uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVzW2tleV0gPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4W2tleV0gPSBQcm9taXNlLnJlc29sdmUodmFsdWVzW2tleV0pLnRoZW4oZnVuY3Rpb24gKHYpIHsgcmV0dXJuICh2ID8gbGliJDEuaGV4bGlmeSh2KSA6IG51bGwpOyB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9iID0gKF9hID0gdGhpcy5mb3JtYXR0ZXIpLnRyYW5zYWN0aW9uUmVxdWVzdDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgbGliJDMucmVzb2x2ZVByb3BlcnRpZXModHgpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbMiAvKnJldHVybiovLCBfYi5hcHBseShfYSwgW19jLnNlbnQoKV0pXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5fZ2V0RmlsdGVyID0gZnVuY3Rpb24gKGZpbHRlcikge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIHJlc3VsdCwgX2EsIF9iO1xuXHQgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBmaWx0ZXJdO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyID0gX2Muc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB7fTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlci5hZGRyZXNzICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hZGRyZXNzID0gdGhpcy5fZ2V0QWRkcmVzcyhmaWx0ZXIuYWRkcmVzcyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgW1wiYmxvY2tIYXNoXCIsIFwidG9waWNzXCJdLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlcltrZXldID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IGZpbHRlcltrZXldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgW1wiZnJvbUJsb2NrXCIsIFwidG9CbG9ja1wiXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJba2V5XSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBfdGhpcy5fZ2V0QmxvY2tUYWcoZmlsdGVyW2tleV0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2IgPSAoX2EgPSB0aGlzLmZvcm1hdHRlcikuZmlsdGVyO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBsaWIkMy5yZXNvbHZlUHJvcGVydGllcyhyZXN1bHQpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbMiAvKnJldHVybiovLCBfYi5hcHBseShfYSwgW19jLnNlbnQoKV0pXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBibG9ja1RhZykge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIHBhcmFtcywgX2E7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0TmV0d29yaygpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgbGliJDMucmVzb2x2ZVByb3BlcnRpZXMoe1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0aGlzLl9nZXRUcmFuc2FjdGlvblJlcXVlc3QodHJhbnNhY3Rpb24pLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrVGFnOiB0aGlzLl9nZXRCbG9ja1RhZyhibG9ja1RhZylcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IF9iLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSBsaWIkMS5oZXhsaWZ5O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnBlcmZvcm0oXCJjYWxsXCIsIHBhcmFtcyldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLmFwcGx5KHZvaWQgMCwgW19iLnNlbnQoKV0pXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5lc3RpbWF0ZUdhcyA9IGZ1bmN0aW9uICh0cmFuc2FjdGlvbikge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIHBhcmFtcywgX2EsIF9iO1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldE5ldHdvcmsoKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYy5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGxpYiQzLnJlc29sdmVQcm9wZXJ0aWVzKHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogdGhpcy5fZ2V0VHJhbnNhY3Rpb25SZXF1ZXN0KHRyYW5zYWN0aW9uKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0gX2Muc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYiA9IChfYSA9IGxpYiQyLkJpZ051bWJlcikuZnJvbTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5wZXJmb3JtKFwiZXN0aW1hdGVHYXNcIiwgcGFyYW1zKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2IuYXBwbHkoX2EsIFtfYy5zZW50KCldKV07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuX2dldEFkZHJlc3MgPSBmdW5jdGlvbiAoYWRkcmVzc09yTmFtZSkge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGFkZHJlc3M7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucmVzb2x2ZU5hbWUoYWRkcmVzc09yTmFtZSldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzcyA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFkZHJlc3MgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJFTlMgbmFtZSBub3QgY29uZmlndXJlZFwiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwicmVzb2x2ZU5hbWUoXCIgKyBKU09OLnN0cmluZ2lmeShhZGRyZXNzT3JOYW1lKSArIFwiKVwiXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgYWRkcmVzc107XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuX2dldEJsb2NrID0gZnVuY3Rpb24gKGJsb2NrSGFzaE9yQmxvY2tUYWcsIGluY2x1ZGVUcmFuc2FjdGlvbnMpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBibG9ja051bWJlciwgcGFyYW1zLCBfYSwgX2IsIF9jLCBlcnJvcl8zO1xuXHQgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9kKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9kLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldE5ldHdvcmsoKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZC5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGJsb2NrSGFzaE9yQmxvY2tUYWddO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tIYXNoT3JCbG9ja1RhZyA9IF9kLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tOdW1iZXIgPSAtMTI4O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmNsdWRlVHJhbnNhY3Rpb25zOiAhIWluY2x1ZGVUcmFuc2FjdGlvbnNcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsaWIkMS5pc0hleFN0cmluZyhibG9ja0hhc2hPckJsb2NrVGFnLCAzMikpIHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMuYmxvY2tIYXNoID0gYmxvY2tIYXNoT3JCbG9ja1RhZztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZC50cnlzLnB1c2goWzMsIDUsICwgNl0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYSA9IHBhcmFtcztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2MgPSAoX2IgPSB0aGlzLmZvcm1hdHRlcikuYmxvY2tUYWc7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2dldEJsb2NrVGFnKGJsb2NrSGFzaE9yQmxvY2tUYWcpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLmJsb2NrVGFnID0gX2MuYXBwbHkoX2IsIFtfZC5zZW50KCldKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpYiQxLmlzSGV4U3RyaW5nKHBhcmFtcy5ibG9ja1RhZykpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyID0gcGFyc2VJbnQocGFyYW1zLmJsb2NrVGFnLnN1YnN0cmluZygyKSwgMTYpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDZdO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JfMyA9IF9kLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYmxvY2sgaGFzaCBvciBibG9jayB0YWdcIiwgXCJibG9ja0hhc2hPckJsb2NrVGFnXCIsIGJsb2NrSGFzaE9yQmxvY2tUYWcpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA2XTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDY6IHJldHVybiBbMiAvKnJldHVybiovLCBsaWIkbC5wb2xsKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBibG9jaywgYmxvY2tOdW1iZXJfMSwgaSwgdHgsIGNvbmZpcm1hdGlvbnM7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucGVyZm9ybShcImdldEJsb2NrXCIsIHBhcmFtcyldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9jayA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJsb2NrIHdhcyBub3QgZm91bmRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChibG9jayA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGJsb2NraGFzaGVzLCBpZiB3ZSBkaWRuJ3Qgc2F5IGl0IGV4aXN0ZWQsIHRoYXQgYmxvY2toYXNoIG1heVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdCBleGlzdC4gSWYgd2UgZGlkIHNlZSBpdCB0aG91Z2gsIHBlcmhhcHMgZnJvbSBhIGxvZywgd2Uga25vd1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0IGV4aXN0cywgYW5kIHRoaXMgbm9kZSBpcyBqdXN0IG5vdCBjYXVnaHQgdXAgeWV0LlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuYmxvY2tIYXNoICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2VtaXR0ZWRbXCJiOlwiICsgcGFyYW1zLmJsb2NrSGFzaF0gPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG51bGxdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvciBibG9jayB0YWdzLCBpZiB3ZSBhcmUgYXNraW5nIGZvciBhIGZ1dHVyZSBibG9jaywgd2UgcmV0dXJuIG51bGxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmJsb2NrVGFnICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJsb2NrTnVtYmVyID4gdGhpcy5fZW1pdHRlZC5ibG9jaykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG51bGxdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldHJ5IG9uIHRoZSBuZXh0IGJsb2NrXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHVuZGVmaW5lZF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWluY2x1ZGVUcmFuc2FjdGlvbnMpIHJldHVybiBbMyAvKmJyZWFrKi8sIDhdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tOdW1iZXJfMSA9IG51bGw7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gMDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoaSA8IGJsb2NrLnRyYW5zYWN0aW9ucy5sZW5ndGgpKSByZXR1cm4gWzMgLypicmVhayovLCA3XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4ID0gYmxvY2sudHJhbnNhY3Rpb25zW2ldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodHguYmxvY2tOdW1iZXIgPT0gbnVsbCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHguY29uZmlybWF0aW9ucyA9IDA7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA2XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodHguY29uZmlybWF0aW9ucyA9PSBudWxsKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShibG9ja051bWJlcl8xID09IG51bGwpKSByZXR1cm4gWzMgLypicmVhayovLCA1XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2dldEludGVybmFsQmxvY2tOdW1iZXIoMTAwICsgMiAqIHRoaXMucG9sbGluZ0ludGVydmFsKV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyXzEgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpcm1hdGlvbnMgPSAoYmxvY2tOdW1iZXJfMSAtIHR4LmJsb2NrTnVtYmVyKSArIDE7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlybWF0aW9ucyA8PSAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlybWF0aW9ucyA9IDE7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eC5jb25maXJtYXRpb25zID0gY29uZmlybWF0aW9ucztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gNjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNzogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuZm9ybWF0dGVyLmJsb2NrV2l0aFRyYW5zYWN0aW9ucyhibG9jayldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDg6IHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLmZvcm1hdHRlci5ibG9jayhibG9jayldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTsgfSwgeyBvbmNlUG9sbDogdGhpcyB9KV07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuZ2V0QmxvY2sgPSBmdW5jdGlvbiAoYmxvY2tIYXNoT3JCbG9ja1RhZykge1xuXHQgICAgICAgIHJldHVybiAodGhpcy5fZ2V0QmxvY2soYmxvY2tIYXNoT3JCbG9ja1RhZywgZmFsc2UpKTtcblx0ICAgIH07XG5cdCAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLmdldEJsb2NrV2l0aFRyYW5zYWN0aW9ucyA9IGZ1bmN0aW9uIChibG9ja0hhc2hPckJsb2NrVGFnKSB7XG5cdCAgICAgICAgcmV0dXJuICh0aGlzLl9nZXRCbG9jayhibG9ja0hhc2hPckJsb2NrVGFnLCB0cnVlKSk7XG5cdCAgICB9O1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5nZXRUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uICh0cmFuc2FjdGlvbkhhc2gpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBwYXJhbXM7XG5cdCAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0TmV0d29yaygpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdHJhbnNhY3Rpb25IYXNoXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uSGFzaCA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0geyB0cmFuc2FjdGlvbkhhc2g6IHRoaXMuZm9ybWF0dGVyLmhhc2godHJhbnNhY3Rpb25IYXNoLCB0cnVlKSB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbGliJGwucG9sbChmdW5jdGlvbiAoKSB7IHJldHVybiBfX2F3YWl0ZXIoX3RoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCwgdHgsIGJsb2NrTnVtYmVyLCBjb25maXJtYXRpb25zO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnBlcmZvcm0oXCJnZXRUcmFuc2FjdGlvblwiLCBwYXJhbXMpXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lbWl0dGVkW1widDpcIiArIHRyYW5zYWN0aW9uSGFzaF0gPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG51bGxdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB1bmRlZmluZWRdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eCA9IHRoaXMuZm9ybWF0dGVyLnRyYW5zYWN0aW9uUmVzcG9uc2UocmVzdWx0KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh0eC5ibG9ja051bWJlciA9PSBudWxsKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHguY29uZmlybWF0aW9ucyA9IDA7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodHguY29uZmlybWF0aW9ucyA9PSBudWxsKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fZ2V0SW50ZXJuYWxCbG9ja051bWJlcigxMDAgKyAyICogdGhpcy5wb2xsaW5nSW50ZXJ2YWwpXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja051bWJlciA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maXJtYXRpb25zID0gKGJsb2NrTnVtYmVyIC0gdHguYmxvY2tOdW1iZXIpICsgMTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlybWF0aW9ucyA8PSAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpcm1hdGlvbnMgPSAxO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eC5jb25maXJtYXRpb25zID0gY29uZmlybWF0aW9ucztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl93cmFwVHJhbnNhY3Rpb24odHgpXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7IH0sIHsgb25jZVBvbGw6IHRoaXMgfSldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLmdldFRyYW5zYWN0aW9uUmVjZWlwdCA9IGZ1bmN0aW9uICh0cmFuc2FjdGlvbkhhc2gpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBwYXJhbXM7XG5cdCAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0TmV0d29yaygpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdHJhbnNhY3Rpb25IYXNoXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uSGFzaCA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0geyB0cmFuc2FjdGlvbkhhc2g6IHRoaXMuZm9ybWF0dGVyLmhhc2godHJhbnNhY3Rpb25IYXNoLCB0cnVlKSB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbGliJGwucG9sbChmdW5jdGlvbiAoKSB7IHJldHVybiBfX2F3YWl0ZXIoX3RoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCwgcmVjZWlwdCwgYmxvY2tOdW1iZXIsIGNvbmZpcm1hdGlvbnM7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucGVyZm9ybShcImdldFRyYW5zYWN0aW9uUmVjZWlwdFwiLCBwYXJhbXMpXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lbWl0dGVkW1widDpcIiArIHRyYW5zYWN0aW9uSGFzaF0gPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG51bGxdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB1bmRlZmluZWRdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBcImdldGgtZXRjXCIgcmV0dXJucyByZWNlaXB0cyBiZWZvcmUgdGhleSBhcmUgcmVhZHlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmJsb2NrSGFzaCA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB1bmRlZmluZWRdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNlaXB0ID0gdGhpcy5mb3JtYXR0ZXIucmVjZWlwdChyZXN1bHQpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHJlY2VpcHQuYmxvY2tOdW1iZXIgPT0gbnVsbCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpcHQuY29uZmlybWF0aW9ucyA9IDA7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEocmVjZWlwdC5jb25maXJtYXRpb25zID09IG51bGwpKSByZXR1cm4gWzMgLypicmVhayovLCA0XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9nZXRJbnRlcm5hbEJsb2NrTnVtYmVyKDEwMCArIDIgKiB0aGlzLnBvbGxpbmdJbnRlcnZhbCldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpcm1hdGlvbnMgPSAoYmxvY2tOdW1iZXIgLSByZWNlaXB0LmJsb2NrTnVtYmVyKSArIDE7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpcm1hdGlvbnMgPD0gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maXJtYXRpb25zID0gMTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWlwdC5jb25maXJtYXRpb25zID0gY29uZmlybWF0aW9ucztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMiAvKnJldHVybiovLCByZWNlaXB0XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7IH0sIHsgb25jZVBvbGw6IHRoaXMgfSldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLmdldExvZ3MgPSBmdW5jdGlvbiAoZmlsdGVyKSB7XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgcGFyYW1zLCBsb2dzO1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldE5ldHdvcmsoKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGxpYiQzLnJlc29sdmVQcm9wZXJ0aWVzKHsgZmlsdGVyOiB0aGlzLl9nZXRGaWx0ZXIoZmlsdGVyKSB9KV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucGVyZm9ybShcImdldExvZ3NcIiwgcGFyYW1zKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBsb2dzID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBsb2dzLmZvckVhY2goZnVuY3Rpb24gKGxvZykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvZy5yZW1vdmVkID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2cucmVtb3ZlZCA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZvcm1hdHRlci5Gb3JtYXR0ZXIuYXJyYXlPZih0aGlzLmZvcm1hdHRlci5maWx0ZXJMb2cuYmluZCh0aGlzLmZvcm1hdHRlcikpKGxvZ3MpXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5nZXRFdGhlclByaWNlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5nZXROZXR3b3JrKCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5wZXJmb3JtKFwiZ2V0RXRoZXJQcmljZVwiLCB7fSldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLl9nZXRCbG9ja1RhZyA9IGZ1bmN0aW9uIChibG9ja1RhZykge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGJsb2NrTnVtYmVyO1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBibG9ja1RhZ107XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBibG9ja1RhZyA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodHlwZW9mIChibG9ja1RhZykgPT09IFwibnVtYmVyXCIgJiYgYmxvY2tUYWcgPCAwKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChibG9ja1RhZyAlIDEpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIEJsb2NrVGFnXCIsIFwiYmxvY2tUYWdcIiwgYmxvY2tUYWcpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2dldEludGVybmFsQmxvY2tOdW1iZXIoMTAwICsgMiAqIHRoaXMucG9sbGluZ0ludGVydmFsKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBibG9ja051bWJlciA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tOdW1iZXIgKz0gYmxvY2tUYWc7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChibG9ja051bWJlciA8IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyID0gMDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5mb3JtYXR0ZXIuYmxvY2tUYWcoYmxvY2tOdW1iZXIpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLmZvcm1hdHRlci5ibG9ja1RhZyhibG9ja1RhZyldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLl9nZXRSZXNvbHZlciA9IGZ1bmN0aW9uIChuYW1lKSB7XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgbmV0d29yaywgdHJhbnNhY3Rpb24sIF9hLCBfYjtcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYykge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5nZXROZXR3b3JrKCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbmV0d29yayA9IF9jLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm8gRU5TLi4uXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbmV0d29yay5lbnNBZGRyZXNzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIm5ldHdvcmsgZG9lcyBub3Qgc3VwcG9ydCBFTlNcIiwgbGliLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7IG9wZXJhdGlvbjogXCJFTlNcIiwgbmV0d29yazogbmV0d29yay5uYW1lIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uID0ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG86IG5ldHdvcmsuZW5zQWRkcmVzcyxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IChcIjB4MDE3OGI4YmZcIiArIGxpYiQ5Lm5hbWVoYXNoKG5hbWUpLnN1YnN0cmluZygyKSlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2IgPSAoX2EgPSB0aGlzLmZvcm1hdHRlcikuY2FsbEFkZHJlc3M7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuY2FsbCh0cmFuc2FjdGlvbildO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9iLmFwcGx5KF9hLCBbX2Muc2VudCgpXSldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLnJlc29sdmVOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciByZXNvbHZlckFkZHJlc3MsIHRyYW5zYWN0aW9uLCBfYSwgX2I7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2MubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIG5hbWVdO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IF9jLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgaXQgaXMgYWxyZWFkeSBhbiBhZGRyZXNzLCBub3RoaW5nIHRvIHJlc29sdmVcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBQcm9taXNlLnJlc29sdmUodGhpcy5mb3JtYXR0ZXIuYWRkcmVzcyhuYW1lKSldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgaXMgaXMgYSBoZXhzdHJpbmcsIHRoZSBhZGRyZXNzIGlzIGJhZCAoU2VlICM2OTQpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGliJDEuaXNIZXhTdHJpbmcobmFtZSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChuYW1lKSAhPT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgRU5TIG5hbWVcIiwgXCJuYW1lXCIsIG5hbWUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2dldFJlc29sdmVyKG5hbWUpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVyQWRkcmVzcyA9IF9jLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXNvbHZlckFkZHJlc3MpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBudWxsXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbiA9IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvOiByZXNvbHZlckFkZHJlc3MsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiAoXCIweDNiM2I1N2RlXCIgKyBsaWIkOS5uYW1laGFzaChuYW1lKS5zdWJzdHJpbmcoMikpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9iID0gKF9hID0gdGhpcy5mb3JtYXR0ZXIpLmNhbGxBZGRyZXNzO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmNhbGwodHJhbnNhY3Rpb24pXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbMiAvKnJldHVybiovLCBfYi5hcHBseShfYSwgW19jLnNlbnQoKV0pXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5sb29rdXBBZGRyZXNzID0gZnVuY3Rpb24gKGFkZHJlc3MpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciByZXZlcnNlTmFtZSwgcmVzb2x2ZXJBZGRyZXNzLCBieXRlcywgX2EsIGxlbmd0aCwgbmFtZSwgYWRkcjtcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgYWRkcmVzc107XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzID0gX2Iuc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzID0gdGhpcy5mb3JtYXR0ZXIuYWRkcmVzcyhhZGRyZXNzKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZU5hbWUgPSBhZGRyZXNzLnN1YnN0cmluZygyKS50b0xvd2VyQ2FzZSgpICsgXCIuYWRkci5yZXZlcnNlXCI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2dldFJlc29sdmVyKHJldmVyc2VOYW1lKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlckFkZHJlc3MgPSBfYi5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVzb2x2ZXJBZGRyZXNzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbnVsbF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSBsaWIkMS5hcnJheWlmeTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5jYWxsKHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bzogcmVzb2x2ZXJBZGRyZXNzLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IChcIjB4NjkxZjM0MzFcIiArIGxpYiQ5Lm5hbWVoYXNoKHJldmVyc2VOYW1lKS5zdWJzdHJpbmcoMikpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBieXRlcyA9IF9hLmFwcGx5KHZvaWQgMCwgW19iLnNlbnQoKV0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdHJpcCBvZmYgdGhlIGR5bmFtaWMgc3RyaW5nIHBvaW50ZXIgKDB4MjApXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggPCAzMiB8fCAhbGliJDIuQmlnTnVtYmVyLmZyb20oYnl0ZXMuc2xpY2UoMCwgMzIpKS5lcSgzMikpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBudWxsXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBieXRlcyA9IGJ5dGVzLnNsaWNlKDMyKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90IGEgbGVuZ3RoLXByZWZpeGVkIHN0cmluZ1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoIDwgMzIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBudWxsXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBsaWIkMi5CaWdOdW1iZXIuZnJvbShieXRlcy5zbGljZSgwLCAzMikpLnRvTnVtYmVyKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzID0gYnl0ZXMuc2xpY2UoMzIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBMZW5ndGggbG9uZ2VyIHRoYW4gYXZhaWxhYmxlIGRhdGFcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxlbmd0aCA+IGJ5dGVzLmxlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG51bGxdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBsaWIkOC50b1V0ZjhTdHJpbmcoYnl0ZXMuc2xpY2UoMCwgbGVuZ3RoKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucmVzb2x2ZU5hbWUobmFtZSldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYWRkciA9IF9iLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFkZHIgIT0gYWRkcmVzcykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG51bGxdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBuYW1lXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5wZXJmb3JtID0gZnVuY3Rpb24gKG1ldGhvZCwgcGFyYW1zKSB7XG5cdCAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKG1ldGhvZCArIFwiIG5vdCBpbXBsZW1lbnRlZFwiLCBsaWIuTG9nZ2VyLmVycm9ycy5OT1RfSU1QTEVNRU5URUQsIHsgb3BlcmF0aW9uOiBtZXRob2QgfSk7XG5cdCAgICB9O1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5fc3RhcnRFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgIHRoaXMucG9sbGluZyA9ICh0aGlzLl9ldmVudHMuZmlsdGVyKGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLnBvbGxhYmxlKCk7IH0pLmxlbmd0aCA+IDApO1xuXHQgICAgfTtcblx0ICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuX3N0b3BFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgIHRoaXMucG9sbGluZyA9ICh0aGlzLl9ldmVudHMuZmlsdGVyKGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLnBvbGxhYmxlKCk7IH0pLmxlbmd0aCA+IDApO1xuXHQgICAgfTtcblx0ICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuX2FkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBsaXN0ZW5lciwgb25jZSkge1xuXHQgICAgICAgIHZhciBldmVudCA9IG5ldyBFdmVudChnZXRFdmVudFRhZyhldmVudE5hbWUpLCBsaXN0ZW5lciwgb25jZSk7XG5cdCAgICAgICAgdGhpcy5fZXZlbnRzLnB1c2goZXZlbnQpO1xuXHQgICAgICAgIHRoaXMuX3N0YXJ0RXZlbnQoZXZlbnQpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIsIGZhbHNlKTtcblx0ICAgIH07XG5cdCAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIsIHRydWUpO1xuXHQgICAgfTtcblx0ICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIChldmVudE5hbWUpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIHZhciBhcmdzID0gW107XG5cdCAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcblx0ICAgICAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuXHQgICAgICAgIHZhciBzdG9wcGVkID0gW107XG5cdCAgICAgICAgdmFyIGV2ZW50VGFnID0gZ2V0RXZlbnRUYWcoZXZlbnROYW1lKTtcblx0ICAgICAgICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMuZmlsdGVyKGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgICAgICBpZiAoZXZlbnQudGFnICE9PSBldmVudFRhZykge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICBldmVudC5saXN0ZW5lci5hcHBseShfdGhpcywgYXJncyk7XG5cdCAgICAgICAgICAgIH0sIDApO1xuXHQgICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xuXHQgICAgICAgICAgICBpZiAoZXZlbnQub25jZSkge1xuXHQgICAgICAgICAgICAgICAgc3RvcHBlZC5wdXNoKGV2ZW50KTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgICBzdG9wcGVkLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7IF90aGlzLl9zdG9wRXZlbnQoZXZlbnQpOyB9KTtcblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfTtcblx0ICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIChldmVudE5hbWUpIHtcblx0ICAgICAgICBpZiAoIWV2ZW50TmFtZSkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRzLmxlbmd0aDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGV2ZW50VGFnID0gZ2V0RXZlbnRUYWcoZXZlbnROYW1lKTtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRzLmZpbHRlcihmdW5jdGlvbiAoZXZlbnQpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIChldmVudC50YWcgPT09IGV2ZW50VGFnKTtcblx0ICAgICAgICB9KS5sZW5ndGg7XG5cdCAgICB9O1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG5cdCAgICAgICAgaWYgKGV2ZW50TmFtZSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9ldmVudHMubWFwKGZ1bmN0aW9uIChldmVudCkgeyByZXR1cm4gZXZlbnQubGlzdGVuZXI7IH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgZXZlbnRUYWcgPSBnZXRFdmVudFRhZyhldmVudE5hbWUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9ldmVudHNcblx0ICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIChldmVudC50YWcgPT09IGV2ZW50VGFnKTsgfSlcblx0ICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIGV2ZW50Lmxpc3RlbmVyOyB9KTtcblx0ICAgIH07XG5cdCAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGxpc3RlbmVyKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICBpZiAobGlzdGVuZXIgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnROYW1lKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHN0b3BwZWQgPSBbXTtcblx0ICAgICAgICB2YXIgZm91bmQgPSBmYWxzZTtcblx0ICAgICAgICB2YXIgZXZlbnRUYWcgPSBnZXRFdmVudFRhZyhldmVudE5hbWUpO1xuXHQgICAgICAgIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cy5maWx0ZXIoZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgICAgIGlmIChldmVudC50YWcgIT09IGV2ZW50VGFnIHx8IGV2ZW50Lmxpc3RlbmVyICE9IGxpc3RlbmVyKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAoZm91bmQpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcblx0ICAgICAgICAgICAgc3RvcHBlZC5wdXNoKGV2ZW50KTtcblx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHN0b3BwZWQuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHsgX3RoaXMuX3N0b3BFdmVudChldmVudCk7IH0pO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgdmFyIHN0b3BwZWQgPSBbXTtcblx0ICAgICAgICBpZiAoZXZlbnROYW1lID09IG51bGwpIHtcblx0ICAgICAgICAgICAgc3RvcHBlZCA9IHRoaXMuX2V2ZW50cztcblx0ICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gW107XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICB2YXIgZXZlbnRUYWdfMSA9IGdldEV2ZW50VGFnKGV2ZW50TmFtZSk7XG5cdCAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cy5maWx0ZXIoZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoZXZlbnQudGFnICE9PSBldmVudFRhZ18xKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBzdG9wcGVkLnB1c2goZXZlbnQpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgc3RvcHBlZC5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkgeyBfdGhpcy5fc3RvcEV2ZW50KGV2ZW50KTsgfSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIEJhc2VQcm92aWRlcjtcblx0fShsaWIkYi5Qcm92aWRlcikpO1xuXHRleHBvcnRzLkJhc2VQcm92aWRlciA9IEJhc2VQcm92aWRlcjtcblxuXHR9KTtcblxuXHR2YXIgYmFzZVByb3ZpZGVyJDEgPSB1bndyYXBFeHBvcnRzKGJhc2VQcm92aWRlcik7XG5cdHZhciBiYXNlUHJvdmlkZXJfMSA9IGJhc2VQcm92aWRlci5FdmVudDtcblx0dmFyIGJhc2VQcm92aWRlcl8yID0gYmFzZVByb3ZpZGVyLkJhc2VQcm92aWRlcjtcblxuXHR2YXIgYnJvd3NlcldzID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5cblx0dmFyIFdTID0gbnVsbDtcblx0dHJ5IHtcblx0ICAgIFdTID0gV2ViU29ja2V0O1xuXHQgICAgaWYgKFdTID09IG51bGwpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbmplY3QgcGxlYXNlXCIpO1xuXHQgICAgfVxuXHR9XG5cdGNhdGNoIChlcnJvcikge1xuXHQgICAgdmFyIGxvZ2dlcl8yID0gbmV3IGxpYi5Mb2dnZXIoX3ZlcnNpb24kSS52ZXJzaW9uKTtcblx0ICAgIFdTID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGxvZ2dlcl8yLnRocm93RXJyb3IoXCJXZWJTb2NrZXRzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBlbnZpcm9ubWVudFwiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcblx0ICAgICAgICAgICAgb3BlcmF0aW9uOiBcIm5ldyBXZWJTb2NrZXQoKVwiXG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHR9XG5cdG1vZHVsZS5leHBvcnRzID0gV1M7XG5cblx0fSk7XG5cblx0dmFyIGJyb3dzZXJXcyQxID0gdW53cmFwRXhwb3J0cyhicm93c2VyV3MpO1xuXG5cdHZhciBqc29uUnBjUHJvdmlkZXIgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19leHRlbmRzID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG5cdCAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcblx0ICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG5cdCAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cblx0ICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG5cdCAgICB9O1xuXHR9KSgpO1xuXHR2YXIgX19hd2FpdGVyID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuXHQgICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG5cdCAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG5cdCAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG5cdCAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cblx0ICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG5cdCAgICB9KTtcblx0fTtcblx0dmFyIF9fZ2VuZXJhdG9yID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuXHQgICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcblx0ICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuXHQgICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG5cdCAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG5cdCAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuXHQgICAgICAgIHdoaWxlIChfKSB0cnkge1xuXHQgICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG5cdCAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcblx0ICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuXHQgICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuXHQgICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcblx0ICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG5cdCAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG5cdCAgICB9XG5cdH07XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXG5cblxuXG5cblxuXG5cdHZhciBsb2dnZXIgPSBuZXcgbGliLkxvZ2dlcihfdmVyc2lvbiRJLnZlcnNpb24pO1xuXG5cdGZ1bmN0aW9uIHRpbWVyKHRpbWVvdXQpIHtcblx0ICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuXHQgICAgICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgdGltZW91dCk7XG5cdCAgICB9KTtcblx0fVxuXHRmdW5jdGlvbiBnZXRSZXN1bHQocGF5bG9hZCkge1xuXHQgICAgaWYgKHBheWxvYWQuZXJyb3IpIHtcblx0ICAgICAgICAvLyBAVE9ETzogbm90IGFueVxuXHQgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihwYXlsb2FkLmVycm9yLm1lc3NhZ2UpO1xuXHQgICAgICAgIGVycm9yLmNvZGUgPSBwYXlsb2FkLmVycm9yLmNvZGU7XG5cdCAgICAgICAgZXJyb3IuZGF0YSA9IHBheWxvYWQuZXJyb3IuZGF0YTtcblx0ICAgICAgICB0aHJvdyBlcnJvcjtcblx0ICAgIH1cblx0ICAgIHJldHVybiBwYXlsb2FkLnJlc3VsdDtcblx0fVxuXHRmdW5jdGlvbiBnZXRMb3dlckNhc2UodmFsdWUpIHtcblx0ICAgIGlmICh2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHZhbHVlO1xuXHR9XG5cdHZhciBfY29uc3RydWN0b3JHdWFyZCA9IHt9O1xuXHR2YXIgSnNvblJwY1NpZ25lciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0ICAgIF9fZXh0ZW5kcyhKc29uUnBjU2lnbmVyLCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gSnNvblJwY1NpZ25lcihjb25zdHJ1Y3Rvckd1YXJkLCBwcm92aWRlciwgYWRkcmVzc09ySW5kZXgpIHtcblx0ICAgICAgICB2YXIgX25ld1RhcmdldCA9IHRoaXMuY29uc3RydWN0b3I7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICBsb2dnZXIuY2hlY2tOZXcoX25ld1RhcmdldCwgSnNvblJwY1NpZ25lcik7XG5cdCAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuXHQgICAgICAgIGlmIChjb25zdHJ1Y3Rvckd1YXJkICE9PSBfY29uc3RydWN0b3JHdWFyZCkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkbyBub3QgY2FsbCB0aGUgSnNvblJwY1NpZ25lciBjb25zdHJ1Y3RvciBkaXJlY3RseTsgdXNlIHByb3ZpZGVyLmdldFNpZ25lclwiKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkoX3RoaXMsIFwicHJvdmlkZXJcIiwgcHJvdmlkZXIpO1xuXHQgICAgICAgIGlmIChhZGRyZXNzT3JJbmRleCA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIGFkZHJlc3NPckluZGV4ID0gMDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHR5cGVvZiAoYWRkcmVzc09ySW5kZXgpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KF90aGlzLCBcIl9hZGRyZXNzXCIsIF90aGlzLnByb3ZpZGVyLmZvcm1hdHRlci5hZGRyZXNzKGFkZHJlc3NPckluZGV4KSk7XG5cdCAgICAgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KF90aGlzLCBcIl9pbmRleFwiLCBudWxsKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAodHlwZW9mIChhZGRyZXNzT3JJbmRleCkgPT09IFwibnVtYmVyXCIpIHtcblx0ICAgICAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkoX3RoaXMsIFwiX2luZGV4XCIsIGFkZHJlc3NPckluZGV4KTtcblx0ICAgICAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkoX3RoaXMsIFwiX2FkZHJlc3NcIiwgbnVsbCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBhZGRyZXNzIG9yIGluZGV4XCIsIFwiYWRkcmVzc09ySW5kZXhcIiwgYWRkcmVzc09ySW5kZXgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gX3RoaXM7XG5cdCAgICB9XG5cdCAgICBKc29uUnBjU2lnbmVyLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG5cdCAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IGFsdGVyIEpTT04tUlBDIFNpZ25lciBjb25uZWN0aW9uXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuXHQgICAgICAgICAgICBvcGVyYXRpb246IFwiY29ubmVjdFwiXG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgSnNvblJwY1NpZ25lci5wcm90b3R5cGUuY29ubmVjdFVuY2hlY2tlZCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gbmV3IFVuY2hlY2tlZEpzb25ScGNTaWduZXIoX2NvbnN0cnVjdG9yR3VhcmQsIHRoaXMucHJvdmlkZXIsIHRoaXMuX2FkZHJlc3MgfHwgdGhpcy5faW5kZXgpO1xuXHQgICAgfTtcblx0ICAgIEpzb25ScGNTaWduZXIucHJvdG90eXBlLmdldEFkZHJlc3MgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICBpZiAodGhpcy5fYWRkcmVzcykge1xuXHQgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2FkZHJlc3MpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5zZW5kKFwiZXRoX2FjY291bnRzXCIsIFtdKS50aGVuKGZ1bmN0aW9uIChhY2NvdW50cykge1xuXHQgICAgICAgICAgICBpZiAoYWNjb3VudHMubGVuZ3RoIDw9IF90aGlzLl9pbmRleCkge1xuXHQgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJ1bmtub3duIGFjY291bnQgI1wiICsgX3RoaXMuX2luZGV4LCBsaWIuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcblx0ICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiZ2V0QWRkcmVzc1wiXG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gX3RoaXMucHJvdmlkZXIuZm9ybWF0dGVyLmFkZHJlc3MoYWNjb3VudHNbX3RoaXMuX2luZGV4XSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgSnNvblJwY1NpZ25lci5wcm90b3R5cGUuc2VuZFVuY2hlY2tlZFRyYW5zYWN0aW9uID0gZnVuY3Rpb24gKHRyYW5zYWN0aW9uKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICB0cmFuc2FjdGlvbiA9IGxpYiQzLnNoYWxsb3dDb3B5KHRyYW5zYWN0aW9uKTtcblx0ICAgICAgICB2YXIgZnJvbUFkZHJlc3MgPSB0aGlzLmdldEFkZHJlc3MoKS50aGVuKGZ1bmN0aW9uIChhZGRyZXNzKSB7XG5cdCAgICAgICAgICAgIGlmIChhZGRyZXNzKSB7XG5cdCAgICAgICAgICAgICAgICBhZGRyZXNzID0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBhZGRyZXNzO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIC8vIFRoZSBKU09OLVJQQyBmb3IgZXRoX3NlbmRUcmFuc2FjdGlvbiB1c2VzIDkwMDAwIGdhczsgaWYgdGhlIHVzZXJcblx0ICAgICAgICAvLyB3aXNoZXMgdG8gdXNlIHRoaXMsIGl0IGlzIGVhc3kgdG8gc3BlY2lmeSBleHBsaWNpdGx5LCBvdGhlcndpc2Vcblx0ICAgICAgICAvLyB3ZSBsb29rIGl0IHVwIGZvciB0aGVtLlxuXHQgICAgICAgIGlmICh0cmFuc2FjdGlvbi5nYXNMaW1pdCA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHZhciBlc3RpbWF0ZSA9IGxpYiQzLnNoYWxsb3dDb3B5KHRyYW5zYWN0aW9uKTtcblx0ICAgICAgICAgICAgZXN0aW1hdGUuZnJvbSA9IGZyb21BZGRyZXNzO1xuXHQgICAgICAgICAgICB0cmFuc2FjdGlvbi5nYXNMaW1pdCA9IHRoaXMucHJvdmlkZXIuZXN0aW1hdGVHYXMoZXN0aW1hdGUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gbGliJDMucmVzb2x2ZVByb3BlcnRpZXMoe1xuXHQgICAgICAgICAgICB0eDogbGliJDMucmVzb2x2ZVByb3BlcnRpZXModHJhbnNhY3Rpb24pLFxuXHQgICAgICAgICAgICBzZW5kZXI6IGZyb21BZGRyZXNzXG5cdCAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgdmFyIHR4ID0gX2EudHgsIHNlbmRlciA9IF9hLnNlbmRlcjtcblx0ICAgICAgICAgICAgaWYgKHR4LmZyb20gIT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHR4LmZyb20udG9Mb3dlckNhc2UoKSAhPT0gc2VuZGVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImZyb20gYWRkcmVzcyBtaXNtYXRjaFwiLCBcInRyYW5zYWN0aW9uXCIsIHRyYW5zYWN0aW9uKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHR4LmZyb20gPSBzZW5kZXI7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIGhleFR4ID0gX3RoaXMucHJvdmlkZXIuY29uc3RydWN0b3IuaGV4bGlmeVRyYW5zYWN0aW9uKHR4LCB7IGZyb206IHRydWUgfSk7XG5cdCAgICAgICAgICAgIHJldHVybiBfdGhpcy5wcm92aWRlci5zZW5kKFwiZXRoX3NlbmRUcmFuc2FjdGlvblwiLCBbaGV4VHhdKS50aGVuKGZ1bmN0aW9uIChoYXNoKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gaGFzaDtcblx0ICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoZXJyb3IucmVzcG9uc2VUZXh0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gU2VlOiBKc29uUnBjUHJvdmlkZXIuc2VuZFRyYW5zYWN0aW9uIChAVE9ETzogRXhwb3NlIGEgLl90aHJvd0Vycm9yPz8pXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLnJlc3BvbnNlVGV4dC5pbmRleE9mKFwiaW5zdWZmaWNpZW50IGZ1bmRzXCIpID49IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJpbnN1ZmZpY2llbnQgZnVuZHNcIiwgbGliLkxvZ2dlci5lcnJvcnMuSU5TVUZGSUNJRU5UX0ZVTkRTLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogdHhcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5yZXNwb25zZVRleHQuaW5kZXhPZihcIm5vbmNlIHRvbyBsb3dcIikgPj0gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIm5vbmNlIGhhcyBhbHJlYWR5IGJlZW4gdXNlZFwiLCBsaWIuTG9nZ2VyLmVycm9ycy5OT05DRV9FWFBJUkVELCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogdHhcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5yZXNwb25zZVRleHQuaW5kZXhPZihcInJlcGxhY2VtZW50IHRyYW5zYWN0aW9uIHVuZGVycHJpY2VkXCIpID49IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJyZXBsYWNlbWVudCBmZWUgdG9vIGxvd1wiLCBsaWIuTG9nZ2VyLmVycm9ycy5SRVBMQUNFTUVOVF9VTkRFUlBSSUNFRCwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IHR4XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBKc29uUnBjU2lnbmVyLnByb3RvdHlwZS5zaWduVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAodHJhbnNhY3Rpb24pIHtcblx0ICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoXCJzaWduaW5nIHRyYW5zYWN0aW9ucyBpcyB1bnN1cHBvcnRlZFwiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcblx0ICAgICAgICAgICAgb3BlcmF0aW9uOiBcInNpZ25UcmFuc2FjdGlvblwiXG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgSnNvblJwY1NpZ25lci5wcm90b3R5cGUuc2VuZFRyYW5zYWN0aW9uID0gZnVuY3Rpb24gKHRyYW5zYWN0aW9uKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICByZXR1cm4gdGhpcy5zZW5kVW5jaGVja2VkVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pLnRoZW4oZnVuY3Rpb24gKGhhc2gpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGxpYiRsLnBvbGwoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uKGhhc2gpLnRoZW4oZnVuY3Rpb24gKHR4KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHR4ID09PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5wcm92aWRlci5fd3JhcFRyYW5zYWN0aW9uKHR4LCBoYXNoKTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9LCB7IG9uY2VCbG9jazogX3RoaXMucHJvdmlkZXIgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICBlcnJvci50cmFuc2FjdGlvbkhhc2ggPSBoYXNoO1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIEpzb25ScGNTaWduZXIucHJvdG90eXBlLnNpZ25NZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIHZhciBkYXRhID0gKCh0eXBlb2YgKG1lc3NhZ2UpID09PSBcInN0cmluZ1wiKSA/IGxpYiQ4LnRvVXRmOEJ5dGVzKG1lc3NhZ2UpIDogbWVzc2FnZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWRkcmVzcygpLnRoZW4oZnVuY3Rpb24gKGFkZHJlc3MpIHtcblx0ICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL3dpa2kvd2lraS9KU09OLVJQQyNldGhfc2lnblxuXHQgICAgICAgICAgICByZXR1cm4gX3RoaXMucHJvdmlkZXIuc2VuZChcImV0aF9zaWduXCIsIFthZGRyZXNzLnRvTG93ZXJDYXNlKCksIGxpYiQxLmhleGxpZnkoZGF0YSldKTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBKc29uUnBjU2lnbmVyLnByb3RvdHlwZS51bmxvY2sgPSBmdW5jdGlvbiAocGFzc3dvcmQpIHtcblx0ICAgICAgICB2YXIgcHJvdmlkZXIgPSB0aGlzLnByb3ZpZGVyO1xuXHQgICAgICAgIHJldHVybiB0aGlzLmdldEFkZHJlc3MoKS50aGVuKGZ1bmN0aW9uIChhZGRyZXNzKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBwcm92aWRlci5zZW5kKFwicGVyc29uYWxfdW5sb2NrQWNjb3VudFwiLCBbYWRkcmVzcy50b0xvd2VyQ2FzZSgpLCBwYXNzd29yZCwgbnVsbF0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBKc29uUnBjU2lnbmVyO1xuXHR9KGxpYiRjLlNpZ25lcikpO1xuXHRleHBvcnRzLkpzb25ScGNTaWduZXIgPSBKc29uUnBjU2lnbmVyO1xuXHR2YXIgVW5jaGVja2VkSnNvblJwY1NpZ25lciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0ICAgIF9fZXh0ZW5kcyhVbmNoZWNrZWRKc29uUnBjU2lnbmVyLCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gVW5jaGVja2VkSnNvblJwY1NpZ25lcigpIHtcblx0ICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cdCAgICB9XG5cdCAgICBVbmNoZWNrZWRKc29uUnBjU2lnbmVyLnByb3RvdHlwZS5zZW5kVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAodHJhbnNhY3Rpb24pIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIHJldHVybiB0aGlzLnNlbmRVbmNoZWNrZWRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikudGhlbihmdW5jdGlvbiAoaGFzaCkge1xuXHQgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgaGFzaDogaGFzaCxcblx0ICAgICAgICAgICAgICAgIG5vbmNlOiBudWxsLFxuXHQgICAgICAgICAgICAgICAgZ2FzTGltaXQ6IG51bGwsXG5cdCAgICAgICAgICAgICAgICBnYXNQcmljZTogbnVsbCxcblx0ICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXG5cdCAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcblx0ICAgICAgICAgICAgICAgIGNoYWluSWQ6IG51bGwsXG5cdCAgICAgICAgICAgICAgICBjb25maXJtYXRpb25zOiAwLFxuXHQgICAgICAgICAgICAgICAgZnJvbTogbnVsbCxcblx0ICAgICAgICAgICAgICAgIHdhaXQ6IGZ1bmN0aW9uIChjb25maXJtYXRpb25zKSB7IHJldHVybiBfdGhpcy5wcm92aWRlci53YWl0Rm9yVHJhbnNhY3Rpb24oaGFzaCwgY29uZmlybWF0aW9ucyk7IH1cblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVW5jaGVja2VkSnNvblJwY1NpZ25lcjtcblx0fShKc29uUnBjU2lnbmVyKSk7XG5cdHZhciBhbGxvd2VkVHJhbnNhY3Rpb25LZXlzID0ge1xuXHQgICAgY2hhaW5JZDogdHJ1ZSwgZGF0YTogdHJ1ZSwgZ2FzTGltaXQ6IHRydWUsIGdhc1ByaWNlOiB0cnVlLCBub25jZTogdHJ1ZSwgdG86IHRydWUsIHZhbHVlOiB0cnVlXG5cdH07XG5cdHZhciBKc29uUnBjUHJvdmlkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoSnNvblJwY1Byb3ZpZGVyLCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gSnNvblJwY1Byb3ZpZGVyKHVybCwgbmV0d29yaykge1xuXHQgICAgICAgIHZhciBfbmV3VGFyZ2V0ID0gdGhpcy5jb25zdHJ1Y3Rvcjtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIGxvZ2dlci5jaGVja05ldyhfbmV3VGFyZ2V0LCBKc29uUnBjUHJvdmlkZXIpO1xuXHQgICAgICAgIHZhciBuZXR3b3JrT3JSZWFkeSA9IG5ldHdvcms7XG5cdCAgICAgICAgLy8gVGhlIG5ldHdvcmsgaXMgdW5rbm93biwgcXVlcnkgdGhlIEpTT04tUlBDIGZvciBpdFxuXHQgICAgICAgIGlmIChuZXR3b3JrT3JSZWFkeSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIG5ldHdvcmtPclJlYWR5ID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgX3RoaXMuZGV0ZWN0TmV0d29yaygpLnRoZW4oZnVuY3Rpb24gKG5ldHdvcmspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShuZXR3b3JrKTtcblx0ICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIH0sIDApO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuZXR3b3JrT3JSZWFkeSkgfHwgdGhpcztcblx0ICAgICAgICAvLyBEZWZhdWx0IFVSTFxuXHQgICAgICAgIGlmICghdXJsKSB7XG5cdCAgICAgICAgICAgIHVybCA9IGxpYiQzLmdldFN0YXRpYyhfdGhpcy5jb25zdHJ1Y3RvciwgXCJkZWZhdWx0VXJsXCIpKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICh0eXBlb2YgKHVybCkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkoX3RoaXMsIFwiY29ubmVjdGlvblwiLCBPYmplY3QuZnJlZXplKHtcblx0ICAgICAgICAgICAgICAgIHVybDogdXJsXG5cdCAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KF90aGlzLCBcImNvbm5lY3Rpb25cIiwgT2JqZWN0LmZyZWV6ZShsaWIkMy5zaGFsbG93Q29weSh1cmwpKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIF90aGlzLl9uZXh0SWQgPSA0Mjtcblx0ICAgICAgICByZXR1cm4gX3RoaXM7XG5cdCAgICB9XG5cdCAgICBKc29uUnBjUHJvdmlkZXIuZGVmYXVsdFVybCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gXCJodHRwOi9cXC9sb2NhbGhvc3Q6ODU0NVwiO1xuXHQgICAgfTtcblx0ICAgIEpzb25ScGNQcm92aWRlci5wcm90b3R5cGUuZGV0ZWN0TmV0d29yayA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBjaGFpbklkLCBlcnJvcl8xLCBlcnJvcl8yLCBnZXROZXR3b3JrO1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aW1lcigwKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluSWQgPSBudWxsO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDI7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzIsIDQsICwgOV0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnNlbmQoXCJldGhfY2hhaW5JZFwiLCBbXSldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW5JZCA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgOV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl8xID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDU7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzUsIDcsICwgOF0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnNlbmQoXCJuZXRfdmVyc2lvblwiLCBbXSldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW5JZCA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgOF07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl8yID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA4XTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDg6IHJldHVybiBbMyAvKmJyZWFrKi8sIDldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgOTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoYWluSWQgIT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0TmV0d29yayA9IGxpYiQzLmdldFN0YXRpYyh0aGlzLmNvbnN0cnVjdG9yLCBcImdldE5ldHdvcmtcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBnZXROZXR3b3JrKGxpYiQyLkJpZ051bWJlci5mcm9tKGNoYWluSWQpLnRvTnVtYmVyKCkpXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBsb2dnZXIudGhyb3dFcnJvcihcImNvdWxkIG5vdCBkZXRlY3QgbmV0d29ya1wiLCBsaWIuTG9nZ2VyLmVycm9ycy5ORVRXT1JLX0VSUk9SLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFpbklkOiBjaGFpbklkLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IFwiaW52YWxpZE5ldHdvcmtcIixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZlckVycm9yOiBlcnJvclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGxvZ2dlci50aHJvd0Vycm9yKFwiY291bGQgbm90IGRldGVjdCBuZXR3b3JrXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLk5FVFdPUktfRVJST1IsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudDogXCJub05ldHdvcmtcIlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBKc29uUnBjUHJvdmlkZXIucHJvdG90eXBlLmdldFNpZ25lciA9IGZ1bmN0aW9uIChhZGRyZXNzT3JJbmRleCkge1xuXHQgICAgICAgIHJldHVybiBuZXcgSnNvblJwY1NpZ25lcihfY29uc3RydWN0b3JHdWFyZCwgdGhpcywgYWRkcmVzc09ySW5kZXgpO1xuXHQgICAgfTtcblx0ICAgIEpzb25ScGNQcm92aWRlci5wcm90b3R5cGUuZ2V0VW5jaGVja2VkU2lnbmVyID0gZnVuY3Rpb24gKGFkZHJlc3NPckluZGV4KSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2lnbmVyKGFkZHJlc3NPckluZGV4KS5jb25uZWN0VW5jaGVja2VkKCk7XG5cdCAgICB9O1xuXHQgICAgSnNvblJwY1Byb3ZpZGVyLnByb3RvdHlwZS5saXN0QWNjb3VudHMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICByZXR1cm4gdGhpcy5zZW5kKFwiZXRoX2FjY291bnRzXCIsIFtdKS50aGVuKGZ1bmN0aW9uIChhY2NvdW50cykge1xuXHQgICAgICAgICAgICByZXR1cm4gYWNjb3VudHMubWFwKGZ1bmN0aW9uIChhKSB7IHJldHVybiBfdGhpcy5mb3JtYXR0ZXIuYWRkcmVzcyhhKTsgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgSnNvblJwY1Byb3ZpZGVyLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKG1ldGhvZCwgcGFyYW1zKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICB2YXIgcmVxdWVzdCA9IHtcblx0ICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG5cdCAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxuXHQgICAgICAgICAgICBpZDogKHRoaXMuX25leHRJZCsrKSxcblx0ICAgICAgICAgICAganNvbnJwYzogXCIyLjBcIlxuXHQgICAgICAgIH07XG5cdCAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwge1xuXHQgICAgICAgICAgICBhY3Rpb246IFwicmVxdWVzdFwiLFxuXHQgICAgICAgICAgICByZXF1ZXN0OiBsaWIkMy5kZWVwQ29weShyZXF1ZXN0KSxcblx0ICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXNcblx0ICAgICAgICB9KTtcblx0ICAgICAgICByZXR1cm4gbGliJGwuZmV0Y2hKc29uKHRoaXMuY29ubmVjdGlvbiwgSlNPTi5zdHJpbmdpZnkocmVxdWVzdCksIGdldFJlc3VsdCkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG5cdCAgICAgICAgICAgIF90aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7XG5cdCAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVzcG9uc2VcIixcblx0ICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHJlcXVlc3QsXG5cdCAgICAgICAgICAgICAgICByZXNwb25zZTogcmVzdWx0LFxuXHQgICAgICAgICAgICAgICAgcHJvdmlkZXI6IF90aGlzXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuXHQgICAgICAgICAgICBfdGhpcy5lbWl0KFwiZGVidWdcIiwge1xuXHQgICAgICAgICAgICAgICAgYWN0aW9uOiBcInJlc3BvbnNlXCIsXG5cdCAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG5cdCAgICAgICAgICAgICAgICByZXF1ZXN0OiByZXF1ZXN0LFxuXHQgICAgICAgICAgICAgICAgcHJvdmlkZXI6IF90aGlzXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB0aHJvdyBlcnJvcjtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBKc29uUnBjUHJvdmlkZXIucHJvdG90eXBlLnByZXBhcmVSZXF1ZXN0ID0gZnVuY3Rpb24gKG1ldGhvZCwgcGFyYW1zKSB7XG5cdCAgICAgICAgc3dpdGNoIChtZXRob2QpIHtcblx0ICAgICAgICAgICAgY2FzZSBcImdldEJsb2NrTnVtYmVyXCI6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX2Jsb2NrTnVtYmVyXCIsIFtdXTtcblx0ICAgICAgICAgICAgY2FzZSBcImdldEdhc1ByaWNlXCI6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX2dhc1ByaWNlXCIsIFtdXTtcblx0ICAgICAgICAgICAgY2FzZSBcImdldEJhbGFuY2VcIjpcblx0ICAgICAgICAgICAgICAgIHJldHVybiBbXCJldGhfZ2V0QmFsYW5jZVwiLCBbZ2V0TG93ZXJDYXNlKHBhcmFtcy5hZGRyZXNzKSwgcGFyYW1zLmJsb2NrVGFnXV07XG5cdCAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvbkNvdW50XCI6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX2dldFRyYW5zYWN0aW9uQ291bnRcIiwgW2dldExvd2VyQ2FzZShwYXJhbXMuYWRkcmVzcyksIHBhcmFtcy5ibG9ja1RhZ11dO1xuXHQgICAgICAgICAgICBjYXNlIFwiZ2V0Q29kZVwiOlxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9nZXRDb2RlXCIsIFtnZXRMb3dlckNhc2UocGFyYW1zLmFkZHJlc3MpLCBwYXJhbXMuYmxvY2tUYWddXTtcblx0ICAgICAgICAgICAgY2FzZSBcImdldFN0b3JhZ2VBdFwiOlxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9nZXRTdG9yYWdlQXRcIiwgW2dldExvd2VyQ2FzZShwYXJhbXMuYWRkcmVzcyksIHBhcmFtcy5wb3NpdGlvbiwgcGFyYW1zLmJsb2NrVGFnXV07XG5cdCAgICAgICAgICAgIGNhc2UgXCJzZW5kVHJhbnNhY3Rpb25cIjpcblx0ICAgICAgICAgICAgICAgIHJldHVybiBbXCJldGhfc2VuZFJhd1RyYW5zYWN0aW9uXCIsIFtwYXJhbXMuc2lnbmVkVHJhbnNhY3Rpb25dXTtcblx0ICAgICAgICAgICAgY2FzZSBcImdldEJsb2NrXCI6XG5cdCAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmJsb2NrVGFnKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9nZXRCbG9ja0J5TnVtYmVyXCIsIFtwYXJhbXMuYmxvY2tUYWcsICEhcGFyYW1zLmluY2x1ZGVUcmFuc2FjdGlvbnNdXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtcy5ibG9ja0hhc2gpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX2dldEJsb2NrQnlIYXNoXCIsIFtwYXJhbXMuYmxvY2tIYXNoLCAhIXBhcmFtcy5pbmNsdWRlVHJhbnNhY3Rpb25zXV07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICAgICAgY2FzZSBcImdldFRyYW5zYWN0aW9uXCI6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX2dldFRyYW5zYWN0aW9uQnlIYXNoXCIsIFtwYXJhbXMudHJhbnNhY3Rpb25IYXNoXV07XG5cdCAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvblJlY2VpcHRcIjpcblx0ICAgICAgICAgICAgICAgIHJldHVybiBbXCJldGhfZ2V0VHJhbnNhY3Rpb25SZWNlaXB0XCIsIFtwYXJhbXMudHJhbnNhY3Rpb25IYXNoXV07XG5cdCAgICAgICAgICAgIGNhc2UgXCJjYWxsXCI6IHtcblx0ICAgICAgICAgICAgICAgIHZhciBoZXhsaWZ5VHJhbnNhY3Rpb24gPSBsaWIkMy5nZXRTdGF0aWModGhpcy5jb25zdHJ1Y3RvciwgXCJoZXhsaWZ5VHJhbnNhY3Rpb25cIik7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX2NhbGxcIiwgW2hleGxpZnlUcmFuc2FjdGlvbihwYXJhbXMudHJhbnNhY3Rpb24sIHsgZnJvbTogdHJ1ZSB9KSwgcGFyYW1zLmJsb2NrVGFnXV07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgY2FzZSBcImVzdGltYXRlR2FzXCI6IHtcblx0ICAgICAgICAgICAgICAgIHZhciBoZXhsaWZ5VHJhbnNhY3Rpb24gPSBsaWIkMy5nZXRTdGF0aWModGhpcy5jb25zdHJ1Y3RvciwgXCJoZXhsaWZ5VHJhbnNhY3Rpb25cIik7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX2VzdGltYXRlR2FzXCIsIFtoZXhsaWZ5VHJhbnNhY3Rpb24ocGFyYW1zLnRyYW5zYWN0aW9uLCB7IGZyb206IHRydWUgfSldXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBjYXNlIFwiZ2V0TG9nc1wiOlxuXHQgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5maWx0ZXIgJiYgcGFyYW1zLmZpbHRlci5hZGRyZXNzICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBwYXJhbXMuZmlsdGVyLmFkZHJlc3MgPSBnZXRMb3dlckNhc2UocGFyYW1zLmZpbHRlci5hZGRyZXNzKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHJldHVybiBbXCJldGhfZ2V0TG9nc1wiLCBbcGFyYW1zLmZpbHRlcl1dO1xuXHQgICAgICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgfTtcblx0ICAgIEpzb25ScGNQcm92aWRlci5wcm90b3R5cGUucGVyZm9ybSA9IGZ1bmN0aW9uIChtZXRob2QsIHBhcmFtcykge1xuXHQgICAgICAgIHZhciBhcmdzID0gdGhpcy5wcmVwYXJlUmVxdWVzdChtZXRob2QsIHBhcmFtcyk7XG5cdCAgICAgICAgaWYgKGFyZ3MgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihtZXRob2QgKyBcIiBub3QgaW1wbGVtZW50ZWRcIiwgbGliLkxvZ2dlci5lcnJvcnMuTk9UX0lNUExFTUVOVEVELCB7IG9wZXJhdGlvbjogbWV0aG9kIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBXZSBuZWVkIGEgbGl0dGxlIGV4dHJhIGxvZ2ljIHRvIHByb2Nlc3MgZXJyb3JzIGZyb20gc2VuZFRyYW5zYWN0aW9uXG5cdCAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJzZW5kVHJhbnNhY3Rpb25cIikge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5zZW5kKGFyZ3NbMF0sIGFyZ3NbMV0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgaWYgKGVycm9yLnJlc3BvbnNlVGV4dCkge1xuXHQgICAgICAgICAgICAgICAgICAgIC8vIFwiaW5zdWZmaWNpZW50IGZ1bmRzIGZvciBnYXMgKiBwcmljZSArIHZhbHVlXCJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IucmVzcG9uc2VUZXh0LmluZGV4T2YoXCJpbnN1ZmZpY2llbnQgZnVuZHNcIikgPiAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiaW5zdWZmaWNpZW50IGZ1bmRzXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLklOU1VGRklDSUVOVF9GVU5EUywge30pO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAvLyBcIm5vbmNlIHRvbyBsb3dcIlxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5yZXNwb25zZVRleHQuaW5kZXhPZihcIm5vbmNlIHRvbyBsb3dcIikgPiAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwibm9uY2UgaGFzIGFscmVhZHkgYmVlbiB1c2VkXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLk5PTkNFX0VYUElSRUQsIHt9KTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gXCJyZXBsYWNlbWVudCB0cmFuc2FjdGlvbiB1bmRlcnByaWNlZFwiXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLnJlc3BvbnNlVGV4dC5pbmRleE9mKFwicmVwbGFjZW1lbnQgdHJhbnNhY3Rpb24gdW5kZXJwcmljZWRcIikgPiAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwicmVwbGFjZW1lbnQgZmVlIHRvbyBsb3dcIiwgbGliLkxvZ2dlci5lcnJvcnMuUkVQTEFDRU1FTlRfVU5ERVJQUklDRUQsIHt9KTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzLnNlbmQoYXJnc1swXSwgYXJnc1sxXSk7XG5cdCAgICB9O1xuXHQgICAgSnNvblJwY1Byb3ZpZGVyLnByb3RvdHlwZS5fc3RhcnRFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgIGlmIChldmVudC50YWcgPT09IFwicGVuZGluZ1wiKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3N0YXJ0UGVuZGluZygpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9zdGFydEV2ZW50LmNhbGwodGhpcywgZXZlbnQpO1xuXHQgICAgfTtcblx0ICAgIEpzb25ScGNQcm92aWRlci5wcm90b3R5cGUuX3N0YXJ0UGVuZGluZyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBpZiAodGhpcy5fcGVuZGluZ0ZpbHRlciAhPSBudWxsKSB7XG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgICAgICAgIHZhciBwZW5kaW5nRmlsdGVyID0gdGhpcy5zZW5kKFwiZXRoX25ld1BlbmRpbmdUcmFuc2FjdGlvbkZpbHRlclwiLCBbXSk7XG5cdCAgICAgICAgdGhpcy5fcGVuZGluZ0ZpbHRlciA9IHBlbmRpbmdGaWx0ZXI7XG5cdCAgICAgICAgcGVuZGluZ0ZpbHRlci50aGVuKGZ1bmN0aW9uIChmaWx0ZXJJZCkge1xuXHQgICAgICAgICAgICBmdW5jdGlvbiBwb2xsKCkge1xuXHQgICAgICAgICAgICAgICAgc2VsZi5zZW5kKFwiZXRoX2dldEZpbHRlckNoYW5nZXNcIiwgW2ZpbHRlcklkXSkudGhlbihmdW5jdGlvbiAoaGFzaGVzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuX3BlbmRpbmdGaWx0ZXIgIT0gcGVuZGluZ0ZpbHRlcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHNlcSA9IFByb21pc2UucmVzb2x2ZSgpO1xuXHQgICAgICAgICAgICAgICAgICAgIGhhc2hlcy5mb3JFYWNoKGZ1bmN0aW9uIChoYXNoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEBUT0RPOiBUaGlzIHNob3VsZCBiZSBnYXJiYWdlIGNvbGxlY3RlZCBhdCBzb21lIHBvaW50Li4uIEhvdz8gV2hlbj9cblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fZW1pdHRlZFtcInQ6XCIgKyBoYXNoLnRvTG93ZXJDYXNlKCldID0gXCJwZW5kaW5nXCI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNlcSA9IHNlcS50aGVuKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmdldFRyYW5zYWN0aW9uKGhhc2gpLnRoZW4oZnVuY3Rpb24gKHR4KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5lbWl0KFwicGVuZGluZ1wiLCB0eCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlcS50aGVuKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRpbWVyKDEwMDApO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuX3BlbmRpbmdGaWx0ZXIgIT0gcGVuZGluZ0ZpbHRlcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNlbmQoXCJldGhfdW5pbnN0YWxsRmlsdGVyXCIsIFtmaWx0ZXJJZF0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyBwb2xsKCk7IH0sIDApO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7IH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHBvbGwoKTtcblx0ICAgICAgICAgICAgcmV0dXJuIGZpbHRlcklkO1xuXHQgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikgeyB9KTtcblx0ICAgIH07XG5cdCAgICBKc29uUnBjUHJvdmlkZXIucHJvdG90eXBlLl9zdG9wRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0ICAgICAgICBpZiAoZXZlbnQudGFnID09PSBcInBlbmRpbmdcIiAmJiB0aGlzLmxpc3RlbmVyQ291bnQoXCJwZW5kaW5nXCIpID09PSAwKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdGaWx0ZXIgPSBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9zdG9wRXZlbnQuY2FsbCh0aGlzLCBldmVudCk7XG5cdCAgICB9O1xuXHQgICAgLy8gQ29udmVydCBhbiBldGhlcnMuanMgdHJhbnNhY3Rpb24gaW50byBhIEpTT04tUlBDIHRyYW5zYWN0aW9uXG5cdCAgICAvLyAgLSBnYXNMaW1pdCA9PiBnYXNcblx0ICAgIC8vICAtIEFsbCB2YWx1ZXMgaGV4bGlmaWVkXG5cdCAgICAvLyAgLSBBbGwgbnVtZXJpYyB2YWx1ZXMgemVyby1zdHJpcGVkXG5cdCAgICAvLyAgLSBBbGwgYWRkcmVzc2VzIGFyZSBsb3dlcmNhc2VkXG5cdCAgICAvLyBOT1RFOiBUaGlzIGFsbG93cyBhIFRyYW5zYWN0aW9uUmVxdWVzdCwgYnV0IGFsbCB2YWx1ZXMgc2hvdWxkIGJlIHJlc29sdmVkXG5cdCAgICAvLyAgICAgICBiZWZvcmUgdGhpcyBpcyBjYWxsZWRcblx0ICAgIC8vIEBUT0RPOiBUaGlzIHdpbGwgbGlrZWx5IGJlIHJlbW92ZWQgaW4gZnV0dXJlIHZlcnNpb25zIGFuZCBwcmVwYXJlUmVxdWVzdFxuXHQgICAgLy8gICAgICAgIHdpbGwgYmUgdGhlIHByZWZlcnJlZCBtZXRob2QgZm9yIHRoaXMuXG5cdCAgICBKc29uUnBjUHJvdmlkZXIuaGV4bGlmeVRyYW5zYWN0aW9uID0gZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBhbGxvd0V4dHJhKSB7XG5cdCAgICAgICAgLy8gQ2hlY2sgb25seSBhbGxvd2VkIHByb3BlcnRpZXMgYXJlIGdpdmVuXG5cdCAgICAgICAgdmFyIGFsbG93ZWQgPSBsaWIkMy5zaGFsbG93Q29weShhbGxvd2VkVHJhbnNhY3Rpb25LZXlzKTtcblx0ICAgICAgICBpZiAoYWxsb3dFeHRyYSkge1xuXHQgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gYWxsb3dFeHRyYSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKGFsbG93RXh0cmFba2V5XSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGFsbG93ZWRba2V5XSA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgbGliJDMuY2hlY2tQcm9wZXJ0aWVzKHRyYW5zYWN0aW9uLCBhbGxvd2VkKTtcblx0ICAgICAgICB2YXIgcmVzdWx0ID0ge307XG5cdCAgICAgICAgLy8gU29tZSBub2RlcyAoSU5GVVJBIHJvcHN0ZW47IElORlVSQSBtYWlubmV0IGlzIGZpbmUpIGRvIG5vdCBsaWtlIGxlYWRpbmcgemVyb3MuXG5cdCAgICAgICAgW1wiZ2FzTGltaXRcIiwgXCJnYXNQcmljZVwiLCBcIm5vbmNlXCIsIFwidmFsdWVcIl0uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdCAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbltrZXldID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgdmFsdWUgPSBsaWIkMS5oZXhWYWx1ZSh0cmFuc2FjdGlvbltrZXldKTtcblx0ICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJnYXNMaW1pdFwiKSB7XG5cdCAgICAgICAgICAgICAgICBrZXkgPSBcImdhc1wiO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgW1wiZnJvbVwiLCBcInRvXCIsIFwiZGF0YVwiXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0ICAgICAgICAgICAgaWYgKHRyYW5zYWN0aW9uW2tleV0gPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJlc3VsdFtrZXldID0gbGliJDEuaGV4bGlmeSh0cmFuc2FjdGlvbltrZXldKTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBKc29uUnBjUHJvdmlkZXI7XG5cdH0oYmFzZVByb3ZpZGVyLkJhc2VQcm92aWRlcikpO1xuXHRleHBvcnRzLkpzb25ScGNQcm92aWRlciA9IEpzb25ScGNQcm92aWRlcjtcblxuXHR9KTtcblxuXHR2YXIganNvblJwY1Byb3ZpZGVyJDEgPSB1bndyYXBFeHBvcnRzKGpzb25ScGNQcm92aWRlcik7XG5cdHZhciBqc29uUnBjUHJvdmlkZXJfMSA9IGpzb25ScGNQcm92aWRlci5Kc29uUnBjU2lnbmVyO1xuXHR2YXIganNvblJwY1Byb3ZpZGVyXzIgPSBqc29uUnBjUHJvdmlkZXIuSnNvblJwY1Byb3ZpZGVyO1xuXG5cdHZhciB3ZWJzb2NrZXRQcm92aWRlciA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciBfX2V4dGVuZHMgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcblx0ICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuXHQgICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcblx0ICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuXHQgICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcblx0ICAgIH07XG5cdH0pKCk7XG5cdHZhciBfX2F3YWl0ZXIgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG5cdCAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cblx0ICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cblx0ICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cblx0ICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuXHQgICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcblx0ICAgIH0pO1xuXHR9O1xuXHR2YXIgX19nZW5lcmF0b3IgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG5cdCAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuXHQgICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG5cdCAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cblx0ICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcblx0ICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG5cdCAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG5cdCAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcblx0ICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuXHQgICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcblx0ICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG5cdCAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG5cdCAgICAgICAgICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcblx0ICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuXHQgICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cblx0ICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcblx0ICAgIH1cblx0fTtcblx0dmFyIF9faW1wb3J0RGVmYXVsdCA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcblx0ICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xuXHR9O1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdHZhciB3c18xID0gX19pbXBvcnREZWZhdWx0KGJyb3dzZXJXcyk7XG5cblxuXG5cblxuXHR2YXIgbG9nZ2VyID0gbmV3IGxpYi5Mb2dnZXIoX3ZlcnNpb24kSS52ZXJzaW9uKTtcblx0LyoqXG5cdCAqICBOb3Rlczpcblx0ICpcblx0ICogIFRoaXMgcHJvdmlkZXIgZGlmZmVycyBhIGJpdCBmcm9tIHRoZSBwb2xsaW5nIHByb3ZpZGVycy4gT25lIG1haW5cblx0ICogIGRpZmZlcmVuY2UgaXMgaG93IGl0IGhhbmRsZXMgY29uc2lzdGVuY3kuIFRoZSBwb2xsaW5nIHByb3ZpZGVyc1xuXHQgKiAgd2lsbCBzdGFsbCByZXNwb25zZXMgdG8gZW5zdXJlIGEgY29uc2lzdGVudCBzdGF0ZSwgd2hpbGUgdGhpc1xuXHQgKiAgV2ViU29ja2V0IHByb3ZpZGVyIGFzc3VtZXMgdGhlIGNvbm5lY3RlZCBiYWNrZW5kIHdpbGwgbWFuYWdlIHRoaXMuXG5cdCAqXG5cdCAqICBGb3IgZXhhbXBsZSwgaWYgYSBwb2xsaW5nIHByb3ZpZGVyIGVtaXRzIGFuIGV2ZW50IHdoaWNoIGluZGljYXRzXG5cdCAqICB0aGUgZXZlbnQgb2NjdXJyZWQgaW4gYmxvY2toYXNoIFhYWCwgYSBjYWxsIHRvIGZldGNoIHRoYXQgYmxvY2sgYnlcblx0ICogIGl0cyBoYXNoIFhYWCwgaWYgbm90IHByZXNlbnQgd2lsbCByZXRyeSB1bnRpbCBpdCBpcyBwcmVzZW50LiBUaGlzXG5cdCAqICBjYW4gb2NjdXIgd2hlbiBxdWVyeWluZyBhIHBvb2wgb2Ygbm9kZXMgdGhhdCBhcmUgbWlsZGx5IG91dCBvZiBzeW5jXG5cdCAqICB3aXRoIGVhY2ggb3RoZXIuXG5cdCAqL1xuXHR2YXIgTmV4dElkID0gMTtcblx0Ly8gRm9yIG1vcmUgaW5mbyBhYm91dCB0aGUgUmVhbC10aW1lIEV2ZW50IEFQSSBzZWU6XG5cdC8vICAgaHR0cHM6Ly9nZXRoLmV0aGVyZXVtLm9yZy9kb2NzL3JwYy9wdWJzdWJcblx0dmFyIFdlYlNvY2tldFByb3ZpZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHQgICAgX19leHRlbmRzKFdlYlNvY2tldFByb3ZpZGVyLCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gV2ViU29ja2V0UHJvdmlkZXIodXJsLCBuZXR3b3JrKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAvLyBUaGlzIHdpbGwgYmUgYWRkZWQgaW4gdGhlIGZ1dHVyZTsgcGxlYXNlIG9wZW4gYW4gaXNzdWUgdG8gZXhwZWRpdGVcblx0ICAgICAgICBpZiAobmV0d29yayA9PT0gXCJhbnlcIikge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIldlYlNvY2tldFByb3ZpZGVyIGRvZXMgbm90IHN1cHBvcnQgJ2FueScgbmV0d29yayB5ZXRcIiwgbGliLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG5cdCAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwibmV0d29yazphbnlcIlxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB1cmwsIG5ldHdvcmspIHx8IHRoaXM7XG5cdCAgICAgICAgX3RoaXMuX3BvbGxpbmdJbnRlcnZhbCA9IC0xO1xuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KF90aGlzLCBcIl93ZWJzb2NrZXRcIiwgbmV3IHdzXzEuZGVmYXVsdChfdGhpcy5jb25uZWN0aW9uLnVybCkpO1xuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KF90aGlzLCBcIl9yZXF1ZXN0c1wiLCB7fSk7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkoX3RoaXMsIFwiX3N1YnNcIiwge30pO1xuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KF90aGlzLCBcIl9zdWJJZHNcIiwge30pO1xuXHQgICAgICAgIC8vIFN0YWxsIHNlbmRpbmcgcmVxdWVzdHMgdW50aWwgdGhlIHNvY2tldCBpcyBvcGVuLi4uXG5cdCAgICAgICAgX3RoaXMuX3dzUmVhZHkgPSBmYWxzZTtcblx0ICAgICAgICBfdGhpcy5fd2Vic29ja2V0Lm9ub3BlbiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgX3RoaXMuX3dzUmVhZHkgPSB0cnVlO1xuXHQgICAgICAgICAgICBPYmplY3Qua2V5cyhfdGhpcy5fcmVxdWVzdHMpLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG5cdCAgICAgICAgICAgICAgICBfdGhpcy5fd2Vic29ja2V0LnNlbmQoX3RoaXMuX3JlcXVlc3RzW2lkXS5wYXlsb2FkKTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBfdGhpcy5fd2Vic29ja2V0Lm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChtZXNzYWdlRXZlbnQpIHtcblx0ICAgICAgICAgICAgdmFyIGRhdGEgPSBtZXNzYWdlRXZlbnQuZGF0YTtcblx0ICAgICAgICAgICAgdmFyIHJlc3VsdCA9IEpTT04ucGFyc2UoZGF0YSk7XG5cdCAgICAgICAgICAgIGlmIChyZXN1bHQuaWQgIT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGlkID0gU3RyaW5nKHJlc3VsdC5pZCk7XG5cdCAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdCA9IF90aGlzLl9yZXF1ZXN0c1tpZF07XG5cdCAgICAgICAgICAgICAgICBkZWxldGUgX3RoaXMuX3JlcXVlc3RzW2lkXTtcblx0ICAgICAgICAgICAgICAgIGlmIChyZXN1bHQucmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmNhbGxiYWNrKG51bGwsIHJlc3VsdC5yZXN1bHQpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5lcnJvcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IocmVzdWx0LmVycm9yLm1lc3NhZ2UgfHwgXCJ1bmtub3duIGVycm9yXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seShlcnJvciwgXCJjb2RlXCIsIHJlc3VsdC5lcnJvci5jb2RlIHx8IG51bGwpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seShlcnJvciwgXCJyZXNwb25zZVwiLCBkYXRhKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5jYWxsYmFjayhlcnJvciwgdW5kZWZpbmVkKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuY2FsbGJhY2sobmV3IEVycm9yKFwidW5rbm93biBlcnJvclwiKSwgdW5kZWZpbmVkKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0Lm1ldGhvZCA9PT0gXCJldGhfc3Vic2NyaXB0aW9uXCIpIHtcblx0ICAgICAgICAgICAgICAgIC8vIFN1YnNjcmlwdGlvbi4uLlxuXHQgICAgICAgICAgICAgICAgdmFyIHN1YiA9IF90aGlzLl9zdWJzW3Jlc3VsdC5wYXJhbXMuc3Vic2NyaXB0aW9uXTtcblx0ICAgICAgICAgICAgICAgIGlmIChzdWIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAvL3RoaXMuZW1pdC5hcHBseSh0aGlzLCAgICAgICAgICAgICAgICAgICk7XG5cdCAgICAgICAgICAgICAgICAgICAgc3ViLnByb2Nlc3NGdW5jKHJlc3VsdC5wYXJhbXMucmVzdWx0KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcInRoaXMgc2hvdWxkIG5vdCBoYXBwZW5cIik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9O1xuXHQgICAgICAgIC8vIFRoaXMgUHJvdmlkZXIgZG9lcyBub3QgYWN0dWFsbHkgcG9sbCwgYnV0IHdlIHdhbnQgdG8gdHJpZ2dlclxuXHQgICAgICAgIC8vIHBvbGwgZXZlbnRzIGZvciB0aGluZ3MgdGhhdCBkZXBlbmQgb24gdGhlbSAobGlrZSBzdGFsbGluZyBmb3Jcblx0ICAgICAgICAvLyBibG9jayBhbmQgdHJhbnNhY3Rpb24gbG9va3Vwcylcblx0ICAgICAgICB2YXIgZmF1eFBvbGwgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIF90aGlzLmVtaXQoXCJwb2xsXCIpO1xuXHQgICAgICAgIH0sIDEwMDApO1xuXHQgICAgICAgIGlmIChmYXV4UG9sbC51bnJlZikge1xuXHQgICAgICAgICAgICBmYXV4UG9sbC51bnJlZigpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gX3RoaXM7XG5cdCAgICB9XG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0UHJvdmlkZXIucHJvdG90eXBlLCBcInBvbGxpbmdJbnRlcnZhbFwiLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiAwO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJjYW5ub3Qgc2V0IHBvbGxpbmcgaW50ZXJ2YWwgb24gV2ViU29ja2V0UHJvdmlkZXJcIiwgbGliLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG5cdCAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwic2V0UG9sbGluZ0ludGVydmFsXCJcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXHQgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHQgICAgfSk7XG5cdCAgICBXZWJTb2NrZXRQcm92aWRlci5wcm90b3R5cGUucmVzZXRFdmVudHNCbG9jayA9IGZ1bmN0aW9uIChibG9ja051bWJlcikge1xuXHQgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IHJlc2V0IGV2ZW50cyBibG9jayBvbiBXZWJTb2NrZXRQcm92aWRlclwiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcblx0ICAgICAgICAgICAgb3BlcmF0aW9uOiBcInJlc2V0RXZlbnRCbG9ja1wiXG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgV2ViU29ja2V0UHJvdmlkZXIucHJvdG90eXBlLnBvbGwgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbnVsbF07XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXRQcm92aWRlci5wcm90b3R5cGUsIFwicG9sbGluZ1wiLCB7XG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IHNldCBwb2xsaW5nIG9uIFdlYlNvY2tldFByb3ZpZGVyXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuXHQgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInNldFBvbGxpbmdcIlxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cdCAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG5cdCAgICB9KTtcblx0ICAgIFdlYlNvY2tldFByb3ZpZGVyLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKG1ldGhvZCwgcGFyYW1zKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICB2YXIgcmlkID0gTmV4dElkKys7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICAgICAgZnVuY3Rpb24gY2FsbGJhY2soZXJyb3IsIHJlc3VsdCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnJvcik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShyZXN1bHQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBwYXlsb2FkID0gSlNPTi5zdHJpbmdpZnkoe1xuXHQgICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG5cdCAgICAgICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcblx0ICAgICAgICAgICAgICAgIGlkOiByaWQsXG5cdCAgICAgICAgICAgICAgICBqc29ucnBjOiBcIjIuMFwiXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICBfdGhpcy5fcmVxdWVzdHNbU3RyaW5nKHJpZCldID0geyBjYWxsYmFjazogY2FsbGJhY2ssIHBheWxvYWQ6IHBheWxvYWQgfTtcblx0ICAgICAgICAgICAgaWYgKF90aGlzLl93c1JlYWR5KSB7XG5cdCAgICAgICAgICAgICAgICBfdGhpcy5fd2Vic29ja2V0LnNlbmQocGF5bG9hZCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBXZWJTb2NrZXRQcm92aWRlci5kZWZhdWx0VXJsID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBcIndzOi9cXC9sb2NhbGhvc3Q6ODU0NlwiO1xuXHQgICAgfTtcblx0ICAgIFdlYlNvY2tldFByb3ZpZGVyLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHRhZywgcGFyYW0sIHByb2Nlc3NGdW5jKSB7XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgc3ViSWRQcm9taXNlLCBzdWJJZDtcblx0ICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3ViSWRQcm9taXNlID0gdGhpcy5fc3ViSWRzW3RhZ107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdWJJZFByb21pc2UgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViSWRQcm9taXNlID0gUHJvbWlzZS5hbGwocGFyYW0pLnRoZW4oZnVuY3Rpb24gKHBhcmFtKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNlbmQoXCJldGhfc3Vic2NyaWJlXCIsIHBhcmFtKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3ViSWRzW3RhZ10gPSBzdWJJZFByb21pc2U7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgc3ViSWRQcm9taXNlXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN1YklkID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdWJzW3N1YklkXSA9IHsgdGFnOiB0YWcsIHByb2Nlc3NGdW5jOiBwcm9jZXNzRnVuYyB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIFdlYlNvY2tldFByb3ZpZGVyLnByb3RvdHlwZS5fc3RhcnRFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XG5cdCAgICAgICAgICAgIGNhc2UgXCJibG9ja1wiOlxuXHQgICAgICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlKFwiYmxvY2tcIiwgW1wibmV3SGVhZHNcIl0sIGZ1bmN0aW9uIChyZXN1bHQpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgYmxvY2tOdW1iZXIgPSBsaWIkMi5CaWdOdW1iZXIuZnJvbShyZXN1bHQubnVtYmVyKS50b051bWJlcigpO1xuXHQgICAgICAgICAgICAgICAgICAgIF90aGlzLl9lbWl0dGVkLmJsb2NrID0gYmxvY2tOdW1iZXI7XG5cdCAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcImJsb2NrXCIsIGJsb2NrTnVtYmVyKTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgXCJwZW5kaW5nXCI6XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9zdWJzY3JpYmUoXCJwZW5kaW5nXCIsIFtcIm5ld1BlbmRpbmdUcmFuc2FjdGlvbnNcIl0sIGZ1bmN0aW9uIChyZXN1bHQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwicGVuZGluZ1wiLCByZXN1bHQpO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSBcImZpbHRlclwiOlxuXHQgICAgICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlKGV2ZW50LnRhZywgW1wibG9nc1wiLCB0aGlzLl9nZXRGaWx0ZXIoZXZlbnQuZmlsdGVyKV0sIGZ1bmN0aW9uIChyZXN1bHQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnJlbW92ZWQgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucmVtb3ZlZCA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KGV2ZW50LmZpbHRlciwgX3RoaXMuZm9ybWF0dGVyLmZpbHRlckxvZyhyZXN1bHQpKTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgXCJ0eFwiOiB7XG5cdCAgICAgICAgICAgICAgICB2YXIgZW1pdFJlY2VpcHRfMSA9IGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBoYXNoID0gZXZlbnQuaGFzaDtcblx0ICAgICAgICAgICAgICAgICAgICBfdGhpcy5nZXRUcmFuc2FjdGlvblJlY2VpcHQoaGFzaCkudGhlbihmdW5jdGlvbiAocmVjZWlwdCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlY2VpcHQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KGhhc2gsIHJlY2VpcHQpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIC8vIEluIGNhc2UgaXQgaXMgYWxyZWFkeSBtaW5lZFxuXHQgICAgICAgICAgICAgICAgZW1pdFJlY2VpcHRfMShldmVudCk7XG5cdCAgICAgICAgICAgICAgICAvLyBUbyBrZWVwIHRoaW5ncyBzaW1wbGUsIHdlIHN0YXJ0IHVwIGEgc2luZ2xlIG5ld0hlYWRzIHN1YnNjcmlwdGlvblxuXHQgICAgICAgICAgICAgICAgLy8gdG8ga2VlcCBhbiBleWUgb3V0IGZvciB0cmFuc2FjdGlvbnMgd2UgYXJlIHdhdGNoaW5nIGZvci5cblx0ICAgICAgICAgICAgICAgIC8vIFN0YXJ0aW5nIGEgc3Vic2NyaXB0aW9uIGZvciBhbiBldmVudCAoaS5lLiBcInR4XCIpIHRoYXQgaXMgYWxyZWFkeVxuXHQgICAgICAgICAgICAgICAgLy8gcnVubmluZyBpcyAoYmFzaWNhbGx5KSBhIG5vcC5cblx0ICAgICAgICAgICAgICAgIHRoaXMuX3N1YnNjcmliZShcInR4XCIsIFtcIm5ld0hlYWRzXCJdLCBmdW5jdGlvbiAocmVzdWx0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2V2ZW50cy5maWx0ZXIoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIChlLnR5cGUgPT09IFwidHhcIik7IH0pLmZvckVhY2goZW1pdFJlY2VpcHRfMSk7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIC8vIE5vdGhpbmcgaXMgbmVlZGVkXG5cdCAgICAgICAgICAgIGNhc2UgXCJkZWJ1Z1wiOlxuXHQgICAgICAgICAgICBjYXNlIFwicG9sbFwiOlxuXHQgICAgICAgICAgICBjYXNlIFwid2lsbFBvbGxcIjpcblx0ICAgICAgICAgICAgY2FzZSBcImRpZFBvbGxcIjpcblx0ICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidW5oYW5kbGVkOlwiLCBldmVudCk7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgV2ViU29ja2V0UHJvdmlkZXIucHJvdG90eXBlLl9zdG9wRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIHZhciB0YWcgPSBldmVudC50YWc7XG5cdCAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09IFwidHhcIikge1xuXHQgICAgICAgICAgICAvLyBUaGVyZSBhcmUgcmVtYWluaW5nIHRyYW5zYWN0aW9uIGV2ZW50IGxpc3RlbmVyc1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fZXZlbnRzLmZpbHRlcihmdW5jdGlvbiAoZSkgeyByZXR1cm4gKGUudHlwZSA9PT0gXCJ0eFwiKTsgfSkubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGFnID0gXCJ0eFwiO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIGlmICh0aGlzLmxpc3RlbmVyQ291bnQoZXZlbnQuZXZlbnQpKSB7XG5cdCAgICAgICAgICAgIC8vIFRoZXJlIGFyZSByZW1haW5pbmcgZXZlbnQgbGlzdGVuZXJzXG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHN1YklkID0gdGhpcy5fc3ViSWRzW3RhZ107XG5cdCAgICAgICAgaWYgKCFzdWJJZCkge1xuXHQgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGRlbGV0ZSB0aGlzLl9zdWJJZHNbdGFnXTtcblx0ICAgICAgICBzdWJJZC50aGVuKGZ1bmN0aW9uIChzdWJJZCkge1xuXHQgICAgICAgICAgICBpZiAoIV90aGlzLl9zdWJzW3N1YklkXSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGRlbGV0ZSBfdGhpcy5fc3Vic1tzdWJJZF07XG5cdCAgICAgICAgICAgIF90aGlzLnNlbmQoXCJldGhfdW5zdWJzY3JpYmVcIiwgW3N1YklkXSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgV2ViU29ja2V0UHJvdmlkZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh0aGlzLl93ZWJzb2NrZXQucmVhZHlTdGF0ZSA9PT0gd3NfMS5kZWZhdWx0LkNPTk5FQ1RJTkcpKSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgKG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3dlYnNvY2tldC5vbm9wZW4gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fd2Vic29ja2V0Lm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZmFsc2UpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDI7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBIYW5ndXBcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ2xvc2VFdmVudCNTdGF0dXNfY29kZXNcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fd2Vic29ja2V0LmNsb3NlKDEwMDApO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBXZWJTb2NrZXRQcm92aWRlcjtcblx0fShqc29uUnBjUHJvdmlkZXIuSnNvblJwY1Byb3ZpZGVyKSk7XG5cdGV4cG9ydHMuV2ViU29ja2V0UHJvdmlkZXIgPSBXZWJTb2NrZXRQcm92aWRlcjtcblxuXHR9KTtcblxuXHR2YXIgd2Vic29ja2V0UHJvdmlkZXIkMSA9IHVud3JhcEV4cG9ydHMod2Vic29ja2V0UHJvdmlkZXIpO1xuXHR2YXIgd2Vic29ja2V0UHJvdmlkZXJfMSA9IHdlYnNvY2tldFByb3ZpZGVyLldlYlNvY2tldFByb3ZpZGVyO1xuXG5cdHZhciB1cmxKc29uUnBjUHJvdmlkZXIgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19leHRlbmRzID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG5cdCAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcblx0ICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG5cdCAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cblx0ICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG5cdCAgICB9O1xuXHR9KSgpO1xuXHR2YXIgX19hd2FpdGVyID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuXHQgICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG5cdCAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG5cdCAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG5cdCAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cblx0ICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG5cdCAgICB9KTtcblx0fTtcblx0dmFyIF9fZ2VuZXJhdG9yID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuXHQgICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcblx0ICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuXHQgICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG5cdCAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG5cdCAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuXHQgICAgICAgIHdoaWxlIChfKSB0cnkge1xuXHQgICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG5cdCAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcblx0ICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuXHQgICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuXHQgICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcblx0ICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG5cdCAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG5cdCAgICB9XG5cdH07XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXG5cblx0dmFyIGxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJEkudmVyc2lvbik7XG5cblx0Ly8gQSBTdGF0aWNKc29uUnBjUHJvdmlkZXIgaXMgdXNlZnVsIHdoZW4geW91ICprbm93KiBmb3IgY2VydGFpbiB0aGF0XG5cdC8vIHRoZSBiYWNrZW5kIHdpbGwgbmV2ZXIgY2hhbmdlLCBhcyBpdCBuZXZlciBjYWxscyBldGhfY2hhaW5JZCB0b1xuXHQvLyB2ZXJpZnkgaXRzIGJhY2tlbmQuIEhvd2V2ZXIsIGlmIHRoZSBiYWNrZW5kIGRvZXMgY2hhbmdlLCB0aGUgZWZmZWN0c1xuXHQvLyBhcmUgdW5kZWZpbmVkIGFuZCBtYXkgaW5jbHVkZTpcblx0Ly8gLSBpbmNvbnNpc3RlbnQgcmVzdWx0c1xuXHQvLyAtIGxvY2tpbmcgdXAgdGhlIFVJXG5cdC8vIC0gYmxvY2sgc2tldyB3YXJuaW5nc1xuXHQvLyAtIHdyb25nIHJlc3VsdHNcblx0Ly8gSWYgdGhlIG5ldHdvcmsgaXMgbm90IGV4cGxpY2l0IChpLmUuIGF1dG8tZGV0ZWN0aW9uIGlzIGV4cGVjdGVkKSwgdGhlXG5cdC8vIG5vZGUgTVVTVCBiZSBydW5uaW5nIGFuZCBhdmFpbGFibGUgdG8gcmVzcG9uZCB0byByZXF1ZXN0cyBCRUZPUkUgdGhpc1xuXHQvLyBpcyBpbnN0YW50aWF0ZWQuXG5cdHZhciBTdGF0aWNKc29uUnBjUHJvdmlkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoU3RhdGljSnNvblJwY1Byb3ZpZGVyLCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gU3RhdGljSnNvblJwY1Byb3ZpZGVyKCkge1xuXHQgICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblx0ICAgIH1cblx0ICAgIFN0YXRpY0pzb25ScGNQcm92aWRlci5wcm90b3R5cGUuZGV0ZWN0TmV0d29yayA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBuZXR3b3JrO1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBuZXR3b3JrID0gdGhpcy5uZXR3b3JrO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShuZXR3b3JrID09IG51bGwpKSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgX3N1cGVyLnByb3RvdHlwZS5kZXRlY3ROZXR3b3JrLmNhbGwodGhpcyldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbmV0d29yayA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXR3b3JrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIm5vIG5ldHdvcmsgZGV0ZWN0ZWRcIiwgbGliLkxvZ2dlci5lcnJvcnMuVU5LTk9XTl9FUlJPUiwge30pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHN0aWxsIG5vdCBzZXQsIHNldCBpdFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fbmV0d29yayA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBIHN0YXRpYyBuZXR3b3JrIGRvZXMgbm90IHN1cHBvcnQgXCJhbnlcIlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfbmV0d29ya1wiLCBuZXR3b3JrKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcIm5ldHdvcmtcIiwgbmV0d29yaywgbnVsbCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAyO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldHdvcmtdO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gU3RhdGljSnNvblJwY1Byb3ZpZGVyO1xuXHR9KGpzb25ScGNQcm92aWRlci5Kc29uUnBjUHJvdmlkZXIpKTtcblx0ZXhwb3J0cy5TdGF0aWNKc29uUnBjUHJvdmlkZXIgPSBTdGF0aWNKc29uUnBjUHJvdmlkZXI7XG5cdHZhciBVcmxKc29uUnBjUHJvdmlkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoVXJsSnNvblJwY1Byb3ZpZGVyLCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gVXJsSnNvblJwY1Byb3ZpZGVyKG5ldHdvcmssIGFwaUtleSkge1xuXHQgICAgICAgIHZhciBfbmV3VGFyZ2V0ID0gdGhpcy5jb25zdHJ1Y3Rvcjtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIGxvZ2dlci5jaGVja0Fic3RyYWN0KF9uZXdUYXJnZXQsIFVybEpzb25ScGNQcm92aWRlcik7XG5cdCAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBOZXR3b3JrIGFuZCBBUEkgS2V5XG5cdCAgICAgICAgbmV0d29yayA9IGxpYiQzLmdldFN0YXRpYygoX25ld1RhcmdldCksIFwiZ2V0TmV0d29ya1wiKShuZXR3b3JrKTtcblx0ICAgICAgICBhcGlLZXkgPSBsaWIkMy5nZXRTdGF0aWMoKF9uZXdUYXJnZXQpLCBcImdldEFwaUtleVwiKShhcGlLZXkpO1xuXHQgICAgICAgIHZhciBjb25uZWN0aW9uID0gbGliJDMuZ2V0U3RhdGljKChfbmV3VGFyZ2V0KSwgXCJnZXRVcmxcIikobmV0d29yaywgYXBpS2V5KTtcblx0ICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbm5lY3Rpb24sIG5ldHdvcmspIHx8IHRoaXM7XG5cdCAgICAgICAgaWYgKHR5cGVvZiAoYXBpS2V5KSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seShfdGhpcywgXCJhcGlLZXlcIiwgYXBpS2V5KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAoYXBpS2V5ICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgT2JqZWN0LmtleXMoYXBpS2V5KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0ICAgICAgICAgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KF90aGlzLCBrZXksIGFwaUtleVtrZXldKTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBfdGhpcztcblx0ICAgIH1cblx0ICAgIFVybEpzb25ScGNQcm92aWRlci5wcm90b3R5cGUuX3N0YXJ0UGVuZGluZyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBsb2dnZXIud2FybihcIldBUk5JTkc6IEFQSSBwcm92aWRlciBkb2VzIG5vdCBzdXBwb3J0IHBlbmRpbmcgZmlsdGVyc1wiKTtcblx0ICAgIH07XG5cdCAgICBVcmxKc29uUnBjUHJvdmlkZXIucHJvdG90eXBlLmdldFNpZ25lciA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG5cdCAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwiQVBJIHByb3ZpZGVyIGRvZXMgbm90IHN1cHBvcnQgc2lnbmluZ1wiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHsgb3BlcmF0aW9uOiBcImdldFNpZ25lclwiIH0pO1xuXHQgICAgfTtcblx0ICAgIFVybEpzb25ScGNQcm92aWRlci5wcm90b3R5cGUubGlzdEFjY291bnRzID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoW10pO1xuXHQgICAgfTtcblx0ICAgIC8vIFJldHVybiBhIGRlZmF1bHRBcGlLZXkgaWYgbnVsbCwgb3RoZXJ3aXNlIHZhbGlkYXRlIHRoZSBBUEkga2V5XG5cdCAgICBVcmxKc29uUnBjUHJvdmlkZXIuZ2V0QXBpS2V5ID0gZnVuY3Rpb24gKGFwaUtleSkge1xuXHQgICAgICAgIHJldHVybiBhcGlLZXk7XG5cdCAgICB9O1xuXHQgICAgLy8gUmV0dXJucyB0aGUgdXJsIG9yIGNvbm5lY3Rpb24gZm9yIHRoZSBnaXZlbiBuZXR3b3JrIGFuZCBBUEkga2V5LiBUaGVcblx0ICAgIC8vIEFQSSBrZXkgd2lsbCBoYXZlIGJlZW4gc2FuaXRpemVkIGJ5IHRoZSBnZXRBcGlLZXkgZmlyc3QsIHNvIGFueSB2YWxpZGF0aW9uXG5cdCAgICAvLyBvciB0cmFuc2Zvcm1hdGlvbnMgY2FuIGJlIGRvbmUgdGhlcmUuXG5cdCAgICBVcmxKc29uUnBjUHJvdmlkZXIuZ2V0VXJsID0gZnVuY3Rpb24gKG5ldHdvcmssIGFwaUtleSkge1xuXHQgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihcIm5vdCBpbXBsZW1lbnRlZDsgc3ViLWNsYXNzZXMgbXVzdCBvdmVycmlkZSBnZXRVcmxcIiwgbGliLkxvZ2dlci5lcnJvcnMuTk9UX0lNUExFTUVOVEVELCB7XG5cdCAgICAgICAgICAgIG9wZXJhdGlvbjogXCJnZXRVcmxcIlxuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBVcmxKc29uUnBjUHJvdmlkZXI7XG5cdH0oU3RhdGljSnNvblJwY1Byb3ZpZGVyKSk7XG5cdGV4cG9ydHMuVXJsSnNvblJwY1Byb3ZpZGVyID0gVXJsSnNvblJwY1Byb3ZpZGVyO1xuXG5cdH0pO1xuXG5cdHZhciB1cmxKc29uUnBjUHJvdmlkZXIkMSA9IHVud3JhcEV4cG9ydHModXJsSnNvblJwY1Byb3ZpZGVyKTtcblx0dmFyIHVybEpzb25ScGNQcm92aWRlcl8xID0gdXJsSnNvblJwY1Byb3ZpZGVyLlN0YXRpY0pzb25ScGNQcm92aWRlcjtcblx0dmFyIHVybEpzb25ScGNQcm92aWRlcl8yID0gdXJsSnNvblJwY1Byb3ZpZGVyLlVybEpzb25ScGNQcm92aWRlcjtcblxuXHR2YXIgYWxjaGVteVByb3ZpZGVyID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0dmFyIF9fZXh0ZW5kcyA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuXHQgICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuXHQgICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG5cdCAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuXHQgICAgfTtcblx0fSkoKTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5cblxuXG5cdHZhciBsb2dnZXIgPSBuZXcgbGliLkxvZ2dlcihfdmVyc2lvbiRJLnZlcnNpb24pO1xuXG5cdC8vIFRoaXMga2V5IHdhcyBwcm92aWRlZCB0byBldGhlcnMuanMgYnkgQWxjaGVteSB0byBiZSB1c2VkIGJ5IHRoZVxuXHQvLyBkZWZhdWx0IHByb3ZpZGVyLCBidXQgaXQgaXMgcmVjb21tZW5kZWQgdGhhdCBmb3IgeW91ciBvd25cblx0Ly8gcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMsIHRoYXQgeW91IGFjcXVpcmUgeW91ciBvd24gQVBJIGtleSBhdDpcblx0Ly8gICBodHRwczovL2Rhc2hib2FyZC5hbGNoZW15YXBpLmlvXG5cdHZhciBkZWZhdWx0QXBpS2V5ID0gXCJfZ2c3d1NTaTBLTUJzZEtuR1ZmSER1ZXE2eE1COUVrQ1wiO1xuXHR2YXIgQWxjaGVteVByb3ZpZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHQgICAgX19leHRlbmRzKEFsY2hlbXlQcm92aWRlciwgX3N1cGVyKTtcblx0ICAgIGZ1bmN0aW9uIEFsY2hlbXlQcm92aWRlcigpIHtcblx0ICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cdCAgICB9XG5cdCAgICBBbGNoZW15UHJvdmlkZXIuZ2V0V2ViU29ja2V0UHJvdmlkZXIgPSBmdW5jdGlvbiAobmV0d29yaywgYXBpS2V5KSB7XG5cdCAgICAgICAgdmFyIHByb3ZpZGVyID0gbmV3IEFsY2hlbXlQcm92aWRlcihuZXR3b3JrLCBhcGlLZXkpO1xuXHQgICAgICAgIHZhciB1cmwgPSBwcm92aWRlci5jb25uZWN0aW9uLnVybC5yZXBsYWNlKC9eaHR0cC9pLCBcIndzXCIpXG5cdCAgICAgICAgICAgIC5yZXBsYWNlKFwiLmFsY2hlbXlhcGkuXCIsIFwiLndzLmFsY2hlbXlhcGkuXCIpO1xuXHQgICAgICAgIHJldHVybiBuZXcgd2Vic29ja2V0UHJvdmlkZXIuV2ViU29ja2V0UHJvdmlkZXIodXJsLCBwcm92aWRlci5uZXR3b3JrKTtcblx0ICAgIH07XG5cdCAgICBBbGNoZW15UHJvdmlkZXIuZ2V0QXBpS2V5ID0gZnVuY3Rpb24gKGFwaUtleSkge1xuXHQgICAgICAgIGlmIChhcGlLZXkgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gZGVmYXVsdEFwaUtleTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGFwaUtleSAmJiB0eXBlb2YgKGFwaUtleSkgIT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYXBpS2V5XCIsIFwiYXBpS2V5XCIsIGFwaUtleSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBhcGlLZXk7XG5cdCAgICB9O1xuXHQgICAgQWxjaGVteVByb3ZpZGVyLmdldFVybCA9IGZ1bmN0aW9uIChuZXR3b3JrLCBhcGlLZXkpIHtcblx0ICAgICAgICB2YXIgaG9zdCA9IG51bGw7XG5cdCAgICAgICAgc3dpdGNoIChuZXR3b3JrLm5hbWUpIHtcblx0ICAgICAgICAgICAgY2FzZSBcImhvbWVzdGVhZFwiOlxuXHQgICAgICAgICAgICAgICAgaG9zdCA9IFwiZXRoLW1haW5uZXQuYWxjaGVteWFwaS5pby92Mi9cIjtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlIFwicm9wc3RlblwiOlxuXHQgICAgICAgICAgICAgICAgaG9zdCA9IFwiZXRoLXJvcHN0ZW4uYWxjaGVteWFwaS5pby92Mi9cIjtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlIFwicmlua2VieVwiOlxuXHQgICAgICAgICAgICAgICAgaG9zdCA9IFwiZXRoLXJpbmtlYnkuYWxjaGVteWFwaS5pby92Mi9cIjtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlIFwiZ29lcmxpXCI6XG5cdCAgICAgICAgICAgICAgICBob3N0ID0gXCJldGgtZ29lcmxpLmFsY2hlbXlhcGkuaW8vdjIvXCI7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSBcImtvdmFuXCI6XG5cdCAgICAgICAgICAgICAgICBob3N0ID0gXCJldGgta292YW4uYWxjaGVteWFwaS5pby92Mi9cIjtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInVuc3VwcG9ydGVkIG5ldHdvcmtcIiwgXCJuZXR3b3JrXCIsIGFyZ3VtZW50c1swXSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgIHVybDogKFwiaHR0cHM6L1wiICsgXCIvXCIgKyBob3N0ICsgYXBpS2V5KSxcblx0ICAgICAgICAgICAgdGhyb3R0bGVDYWxsYmFjazogZnVuY3Rpb24gKGF0dGVtcHQsIHVybCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKGFwaUtleSA9PT0gZGVmYXVsdEFwaUtleSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlci5zaG93VGhyb3R0bGVNZXNzYWdlKCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gQWxjaGVteVByb3ZpZGVyO1xuXHR9KHVybEpzb25ScGNQcm92aWRlci5VcmxKc29uUnBjUHJvdmlkZXIpKTtcblx0ZXhwb3J0cy5BbGNoZW15UHJvdmlkZXIgPSBBbGNoZW15UHJvdmlkZXI7XG5cblx0fSk7XG5cblx0dmFyIGFsY2hlbXlQcm92aWRlciQxID0gdW53cmFwRXhwb3J0cyhhbGNoZW15UHJvdmlkZXIpO1xuXHR2YXIgYWxjaGVteVByb3ZpZGVyXzEgPSBhbGNoZW15UHJvdmlkZXIuQWxjaGVteVByb3ZpZGVyO1xuXG5cdHZhciBjbG91ZGZsYXJlUHJvdmlkZXIgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19leHRlbmRzID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG5cdCAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcblx0ICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG5cdCAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cblx0ICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG5cdCAgICB9O1xuXHR9KSgpO1xuXHR2YXIgX19hd2FpdGVyID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuXHQgICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG5cdCAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG5cdCAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG5cdCAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cblx0ICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG5cdCAgICB9KTtcblx0fTtcblx0dmFyIF9fZ2VuZXJhdG9yID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuXHQgICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcblx0ICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuXHQgICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG5cdCAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG5cdCAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuXHQgICAgICAgIHdoaWxlIChfKSB0cnkge1xuXHQgICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG5cdCAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcblx0ICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuXHQgICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuXHQgICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcblx0ICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG5cdCAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG5cdCAgICB9XG5cdH07XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXG5cblx0dmFyIGxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJEkudmVyc2lvbik7XG5cdHZhciBDbG91ZGZsYXJlUHJvdmlkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoQ2xvdWRmbGFyZVByb3ZpZGVyLCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gQ2xvdWRmbGFyZVByb3ZpZGVyKCkge1xuXHQgICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblx0ICAgIH1cblx0ICAgIENsb3VkZmxhcmVQcm92aWRlci5nZXRBcGlLZXkgPSBmdW5jdGlvbiAoYXBpS2V5KSB7XG5cdCAgICAgICAgaWYgKGFwaUtleSAhPSBudWxsKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJhcGlLZXkgbm90IHN1cHBvcnRlZCBmb3IgY2xvdWRmbGFyZVwiLCBcImFwaUtleVwiLCBhcGlLZXkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgIH07XG5cdCAgICBDbG91ZGZsYXJlUHJvdmlkZXIuZ2V0VXJsID0gZnVuY3Rpb24gKG5ldHdvcmssIGFwaUtleSkge1xuXHQgICAgICAgIHZhciBob3N0ID0gbnVsbDtcblx0ICAgICAgICBzd2l0Y2ggKG5ldHdvcmsubmFtZSkge1xuXHQgICAgICAgICAgICBjYXNlIFwiaG9tZXN0ZWFkXCI6XG5cdCAgICAgICAgICAgICAgICBob3N0ID0gXCJodHRwczovL2Nsb3VkZmxhcmUtZXRoLmNvbS9cIjtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInVuc3VwcG9ydGVkIG5ldHdvcmtcIiwgXCJuZXR3b3JrXCIsIGFyZ3VtZW50c1swXSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBob3N0O1xuXHQgICAgfTtcblx0ICAgIENsb3VkZmxhcmVQcm92aWRlci5wcm90b3R5cGUucGVyZm9ybSA9IGZ1bmN0aW9uIChtZXRob2QsIHBhcmFtcykge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGJsb2NrO1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXRob2QgPT09IFwiZ2V0QmxvY2tOdW1iZXJcIikpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfc3VwZXIucHJvdG90eXBlLnBlcmZvcm0uY2FsbCh0aGlzLCBcImdldEJsb2NrXCIsIHsgYmxvY2tUYWc6IFwibGF0ZXN0XCIgfSldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2sgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBibG9jay5udW1iZXJdO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9zdXBlci5wcm90b3R5cGUucGVyZm9ybS5jYWxsKHRoaXMsIG1ldGhvZCwgcGFyYW1zKV07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBDbG91ZGZsYXJlUHJvdmlkZXI7XG5cdH0odXJsSnNvblJwY1Byb3ZpZGVyLlVybEpzb25ScGNQcm92aWRlcikpO1xuXHRleHBvcnRzLkNsb3VkZmxhcmVQcm92aWRlciA9IENsb3VkZmxhcmVQcm92aWRlcjtcblxuXHR9KTtcblxuXHR2YXIgY2xvdWRmbGFyZVByb3ZpZGVyJDEgPSB1bndyYXBFeHBvcnRzKGNsb3VkZmxhcmVQcm92aWRlcik7XG5cdHZhciBjbG91ZGZsYXJlUHJvdmlkZXJfMSA9IGNsb3VkZmxhcmVQcm92aWRlci5DbG91ZGZsYXJlUHJvdmlkZXI7XG5cblx0dmFyIGV0aGVyc2NhblByb3ZpZGVyID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0dmFyIF9fZXh0ZW5kcyA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuXHQgICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuXHQgICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG5cdCAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuXHQgICAgfTtcblx0fSkoKTtcblx0dmFyIF9fYXdhaXRlciA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcblx0ICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuXHQgICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdCAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuXHQgICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuXHQgICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG5cdCAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuXHQgICAgfSk7XG5cdH07XG5cdHZhciBfX2dlbmVyYXRvciA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcblx0ICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG5cdCAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcblx0ICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuXHQgICAgZnVuY3Rpb24gc3RlcChvcCkge1xuXHQgICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcblx0ICAgICAgICB3aGlsZSAoXykgdHJ5IHtcblx0ICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuXHQgICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG5cdCAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcblx0ICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG5cdCAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuXHQgICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuXHQgICAgfVxuXHR9O1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cblxuXG5cblxuXG5cdHZhciBsb2dnZXIgPSBuZXcgbGliLkxvZ2dlcihfdmVyc2lvbiRJLnZlcnNpb24pO1xuXG5cdC8vIFRoZSB0cmFuc2FjdGlvbiBoYXMgYWxyZWFkeSBiZWVuIHNhbml0aXplZCBieSB0aGUgY2FsbHMgaW4gUHJvdmlkZXJcblx0ZnVuY3Rpb24gZ2V0VHJhbnNhY3Rpb25TdHJpbmcodHJhbnNhY3Rpb24pIHtcblx0ICAgIHZhciByZXN1bHQgPSBbXTtcblx0ICAgIGZvciAodmFyIGtleSBpbiB0cmFuc2FjdGlvbikge1xuXHQgICAgICAgIGlmICh0cmFuc2FjdGlvbltrZXldID09IG51bGwpIHtcblx0ICAgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciB2YWx1ZSA9IGxpYiQxLmhleGxpZnkodHJhbnNhY3Rpb25ba2V5XSk7XG5cdCAgICAgICAgaWYgKHsgZ2FzTGltaXQ6IHRydWUsIGdhc1ByaWNlOiB0cnVlLCBub25jZTogdHJ1ZSwgdmFsdWU6IHRydWUgfVtrZXldKSB7XG5cdCAgICAgICAgICAgIHZhbHVlID0gbGliJDEuaGV4VmFsdWUodmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXN1bHQucHVzaChrZXkgKyBcIj1cIiArIHZhbHVlKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiByZXN1bHQuam9pbihcIiZcIik7XG5cdH1cblx0ZnVuY3Rpb24gZ2V0UmVzdWx0KHJlc3VsdCkge1xuXHQgICAgLy8gZ2V0TG9ncywgZ2V0SGlzdG9yeSBoYXZlIHdlaXJkIHN1Y2Nlc3MgcmVzcG9uc2VzXG5cdCAgICBpZiAocmVzdWx0LnN0YXR1cyA9PSAwICYmIChyZXN1bHQubWVzc2FnZSA9PT0gXCJObyByZWNvcmRzIGZvdW5kXCIgfHwgcmVzdWx0Lm1lc3NhZ2UgPT09IFwiTm8gdHJhbnNhY3Rpb25zIGZvdW5kXCIpKSB7XG5cdCAgICAgICAgcmV0dXJuIHJlc3VsdC5yZXN1bHQ7XG5cdCAgICB9XG5cdCAgICBpZiAocmVzdWx0LnN0YXR1cyAhPSAxIHx8IHJlc3VsdC5tZXNzYWdlICE9IFwiT0tcIikge1xuXHQgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcImludmFsaWQgcmVzcG9uc2VcIik7XG5cdCAgICAgICAgZXJyb3IucmVzdWx0ID0gSlNPTi5zdHJpbmdpZnkocmVzdWx0KTtcblx0ICAgICAgICBpZiAoKHJlc3VsdC5yZXN1bHQgfHwgXCJcIikudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwicmF0ZSBsaW1pdFwiKSA+PSAwKSB7XG5cdCAgICAgICAgICAgIGVycm9yLnRocm90dGxlUmV0cnkgPSB0cnVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aHJvdyBlcnJvcjtcblx0ICAgIH1cblx0ICAgIHJldHVybiByZXN1bHQucmVzdWx0O1xuXHR9XG5cdGZ1bmN0aW9uIGdldEpzb25SZXN1bHQocmVzdWx0KSB7XG5cdCAgICAvLyBUaGlzIHJlc3BvbnNlIGluZGljYXRlcyB3ZSBhcmUgYmVpbmcgdGhyb3R0bGVkXG5cdCAgICBpZiAocmVzdWx0ICYmIHJlc3VsdC5zdGF0dXMgPT0gMCAmJiByZXN1bHQubWVzc2FnZSA9PSBcIk5PVE9LXCIgJiYgKHJlc3VsdC5yZXN1bHQgfHwgXCJcIikudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwicmF0ZSBsaW1pdFwiKSA+PSAwKSB7XG5cdCAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFwidGhyb3R0bGVkIHJlc3BvbnNlXCIpO1xuXHQgICAgICAgIGVycm9yLnJlc3VsdCA9IEpTT04uc3RyaW5naWZ5KHJlc3VsdCk7XG5cdCAgICAgICAgZXJyb3IudGhyb3R0bGVSZXRyeSA9IHRydWU7XG5cdCAgICAgICAgdGhyb3cgZXJyb3I7XG5cdCAgICB9XG5cdCAgICBpZiAocmVzdWx0Lmpzb25ycGMgIT0gXCIyLjBcIikge1xuXHQgICAgICAgIC8vIEBUT0RPOiBub3QgYW55XG5cdCAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFwiaW52YWxpZCByZXNwb25zZVwiKTtcblx0ICAgICAgICBlcnJvci5yZXN1bHQgPSBKU09OLnN0cmluZ2lmeShyZXN1bHQpO1xuXHQgICAgICAgIHRocm93IGVycm9yO1xuXHQgICAgfVxuXHQgICAgaWYgKHJlc3VsdC5lcnJvcikge1xuXHQgICAgICAgIC8vIEBUT0RPOiBub3QgYW55XG5cdCAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKHJlc3VsdC5lcnJvci5tZXNzYWdlIHx8IFwidW5rbm93biBlcnJvclwiKTtcblx0ICAgICAgICBpZiAocmVzdWx0LmVycm9yLmNvZGUpIHtcblx0ICAgICAgICAgICAgZXJyb3IuY29kZSA9IHJlc3VsdC5lcnJvci5jb2RlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAocmVzdWx0LmVycm9yLmRhdGEpIHtcblx0ICAgICAgICAgICAgZXJyb3IuZGF0YSA9IHJlc3VsdC5lcnJvci5kYXRhO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aHJvdyBlcnJvcjtcblx0ICAgIH1cblx0ICAgIHJldHVybiByZXN1bHQucmVzdWx0O1xuXHR9XG5cdC8vIFRoZSBibG9ja1RhZyB3YXMgbm9ybWFsaXplZCBhcyBhIHN0cmluZyBieSB0aGUgUHJvdmlkZXIgcHJlLXBlcmZvcm0gb3BlcmF0aW9uc1xuXHRmdW5jdGlvbiBjaGVja0xvZ1RhZyhibG9ja1RhZykge1xuXHQgICAgaWYgKGJsb2NrVGFnID09PSBcInBlbmRpbmdcIikge1xuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcihcInBlbmRpbmcgbm90IHN1cHBvcnRlZFwiKTtcblx0ICAgIH1cblx0ICAgIGlmIChibG9ja1RhZyA9PT0gXCJsYXRlc3RcIikge1xuXHQgICAgICAgIHJldHVybiBibG9ja1RhZztcblx0ICAgIH1cblx0ICAgIHJldHVybiBwYXJzZUludChibG9ja1RhZy5zdWJzdHJpbmcoMiksIDE2KTtcblx0fVxuXHR2YXIgZGVmYXVsdEFwaUtleSA9IFwiOUQxM1pFN1hTQlRKOTROOUJOSjJNQTMzVk1BWTJZUElSQlwiO1xuXHR2YXIgRXRoZXJzY2FuUHJvdmlkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoRXRoZXJzY2FuUHJvdmlkZXIsIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBFdGhlcnNjYW5Qcm92aWRlcihuZXR3b3JrLCBhcGlLZXkpIHtcblx0ICAgICAgICB2YXIgX25ld1RhcmdldCA9IHRoaXMuY29uc3RydWN0b3I7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICBsb2dnZXIuY2hlY2tOZXcoX25ld1RhcmdldCwgRXRoZXJzY2FuUHJvdmlkZXIpO1xuXHQgICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbmV0d29yaykgfHwgdGhpcztcblx0ICAgICAgICB2YXIgbmFtZSA9IFwiaW52YWxpZFwiO1xuXHQgICAgICAgIGlmIChfdGhpcy5uZXR3b3JrKSB7XG5cdCAgICAgICAgICAgIG5hbWUgPSBfdGhpcy5uZXR3b3JrLm5hbWU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBiYXNlVXJsID0gbnVsbDtcblx0ICAgICAgICBzd2l0Y2ggKG5hbWUpIHtcblx0ICAgICAgICAgICAgY2FzZSBcImhvbWVzdGVhZFwiOlxuXHQgICAgICAgICAgICAgICAgYmFzZVVybCA9IFwiaHR0cHM6Ly9hcGkuZXRoZXJzY2FuLmlvXCI7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSBcInJvcHN0ZW5cIjpcblx0ICAgICAgICAgICAgICAgIGJhc2VVcmwgPSBcImh0dHBzOi8vYXBpLXJvcHN0ZW4uZXRoZXJzY2FuLmlvXCI7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSBcInJpbmtlYnlcIjpcblx0ICAgICAgICAgICAgICAgIGJhc2VVcmwgPSBcImh0dHBzOi8vYXBpLXJpbmtlYnkuZXRoZXJzY2FuLmlvXCI7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSBcImtvdmFuXCI6XG5cdCAgICAgICAgICAgICAgICBiYXNlVXJsID0gXCJodHRwczovL2FwaS1rb3Zhbi5ldGhlcnNjYW4uaW9cIjtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlIFwiZ29lcmxpXCI6XG5cdCAgICAgICAgICAgICAgICBiYXNlVXJsID0gXCJodHRwczovL2FwaS1nb2VybGkuZXRoZXJzY2FuLmlvXCI7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIG5ldHdvcmtcIik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KF90aGlzLCBcImJhc2VVcmxcIiwgYmFzZVVybCk7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkoX3RoaXMsIFwiYXBpS2V5XCIsIGFwaUtleSB8fCBkZWZhdWx0QXBpS2V5KTtcblx0ICAgICAgICByZXR1cm4gX3RoaXM7XG5cdCAgICB9XG5cdCAgICBFdGhlcnNjYW5Qcm92aWRlci5wcm90b3R5cGUuZGV0ZWN0TmV0d29yayA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLm5ldHdvcmtdO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBFdGhlcnNjYW5Qcm92aWRlci5wcm90b3R5cGUucGVyZm9ybSA9IGZ1bmN0aW9uIChtZXRob2QsIHBhcmFtcykge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIHVybCwgYXBpS2V5LCBnZXQsIF9hLCB0cmFuc2FjdGlvbiwgdHJhbnNhY3Rpb24sIHRvcGljMCwgbG9ncywgdHhzLCBpLCBsb2csIHR4LCBfYjtcblx0ICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYykge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gdGhpcy5iYXNlVXJsO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBhcGlLZXkgPSBcIlwiO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hcGlLZXkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwaUtleSArPSBcIiZhcGlrZXk9XCIgKyB0aGlzLmFwaUtleTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBnZXQgPSBmdW5jdGlvbiAodXJsLCBwcm9jRnVuYykgeyByZXR1cm4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbm5lY3Rpb24sIHJlc3VsdDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcInJlcXVlc3RcIixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0OiB1cmwsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXNcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbiA9IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHVybCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdHRsZVNsb3RJbnRlcnZhbDogMTAwMCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdHRsZUNhbGxiYWNrOiBmdW5jdGlvbiAoYXR0ZW1wdCwgdXJsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5hcGlLZXkgPT09IGRlZmF1bHRBcGlLZXkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlci5zaG93VGhyb3R0bGVNZXNzYWdlKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgbGliJGwuZmV0Y2hKc29uKGNvbm5lY3Rpb24sIG51bGwsIHByb2NGdW5jIHx8IGdldEpzb25SZXN1bHQpXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJyZXNwb25zZVwiLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHVybCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZTogbGliJDMuZGVlcENvcHkocmVzdWx0KSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcjogdGhpc1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVzdWx0XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7IH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gbWV0aG9kO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0QmxvY2tOdW1iZXJcIjogcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0R2FzUHJpY2VcIjogcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0QmFsYW5jZVwiOiByZXR1cm4gWzMgLypicmVhayovLCAzXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvbkNvdW50XCI6IHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImdldENvZGVcIjogcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0U3RvcmFnZUF0XCI6IHJldHVybiBbMyAvKmJyZWFrKi8sIDZdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNlbmRUcmFuc2FjdGlvblwiOiByZXR1cm4gWzMgLypicmVhayovLCA3XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRCbG9ja1wiOiByZXR1cm4gWzMgLypicmVhayovLCA4XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvblwiOiByZXR1cm4gWzMgLypicmVhayovLCA5XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvblJlY2VpcHRcIjogcmV0dXJuIFszIC8qYnJlYWsqLywgMTBdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImNhbGxcIjogcmV0dXJuIFszIC8qYnJlYWsqLywgMTFdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVzdGltYXRlR2FzXCI6IHJldHVybiBbMyAvKmJyZWFrKi8sIDEyXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRMb2dzXCI6IHJldHVybiBbMyAvKmJyZWFrKi8sIDEzXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRFdGhlclByaWNlXCI6IHJldHVybiBbMyAvKmJyZWFrKi8sIDIwXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAyMl07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICB1cmwgKz0gXCIvYXBpP21vZHVsZT1wcm94eSZhY3Rpb249ZXRoX2Jsb2NrTnVtYmVyXCIgKyBhcGlLZXk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBnZXQodXJsKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICB1cmwgKz0gXCIvYXBpP21vZHVsZT1wcm94eSZhY3Rpb249ZXRoX2dhc1ByaWNlXCIgKyBhcGlLZXk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBnZXQodXJsKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm5zIGJhc2UtMTAgcmVzdWx0XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHVybCArPSBcIi9hcGk/bW9kdWxlPWFjY291bnQmYWN0aW9uPWJhbGFuY2UmYWRkcmVzcz1cIiArIHBhcmFtcy5hZGRyZXNzO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB1cmwgKz0gXCImdGFnPVwiICsgcGFyYW1zLmJsb2NrVGFnICsgYXBpS2V5O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZ2V0KHVybCwgZ2V0UmVzdWx0KV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICB1cmwgKz0gXCIvYXBpP21vZHVsZT1wcm94eSZhY3Rpb249ZXRoX2dldFRyYW5zYWN0aW9uQ291bnQmYWRkcmVzcz1cIiArIHBhcmFtcy5hZGRyZXNzO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB1cmwgKz0gXCImdGFnPVwiICsgcGFyYW1zLmJsb2NrVGFnICsgYXBpS2V5O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZ2V0KHVybCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdXJsICs9IFwiL2FwaT9tb2R1bGU9cHJveHkmYWN0aW9uPWV0aF9nZXRDb2RlJmFkZHJlc3M9XCIgKyBwYXJhbXMuYWRkcmVzcztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdXJsICs9IFwiJnRhZz1cIiArIHBhcmFtcy5ibG9ja1RhZyArIGFwaUtleTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGdldCh1cmwpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHVybCArPSBcIi9hcGk/bW9kdWxlPXByb3h5JmFjdGlvbj1ldGhfZ2V0U3RvcmFnZUF0JmFkZHJlc3M9XCIgKyBwYXJhbXMuYWRkcmVzcztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdXJsICs9IFwiJnBvc2l0aW9uPVwiICsgcGFyYW1zLnBvc2l0aW9uO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB1cmwgKz0gXCImdGFnPVwiICsgcGFyYW1zLmJsb2NrVGFnICsgYXBpS2V5O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZ2V0KHVybCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdXJsICs9IFwiL2FwaT9tb2R1bGU9cHJveHkmYWN0aW9uPWV0aF9zZW5kUmF3VHJhbnNhY3Rpb24maGV4PVwiICsgcGFyYW1zLnNpZ25lZFRyYW5zYWN0aW9uO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB1cmwgKz0gYXBpS2V5O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZ2V0KHVybCkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLnJlc3BvbnNlVGV4dCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBcIkluc3VmZmljaWVudCBmdW5kcy4gVGhlIGFjY291bnQgeW91IHRyaWVkIHRvIHNlbmQgdHJhbnNhY3Rpb24gZnJvbSBkb2VzIG5vdCBoYXZlIGVub3VnaCBmdW5kcy4gUmVxdWlyZWQgMjE0NjQwMDAwMDAwMDAgYW5kIGdvdDogMFwiXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5yZXNwb25zZVRleHQudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwiaW5zdWZmaWNpZW50IGZ1bmRzXCIpID49IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiaW5zdWZmaWNpZW50IGZ1bmRzXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLklOU1VGRklDSUVOVF9GVU5EUywge30pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFwiVHJhbnNhY3Rpb24gd2l0aCB0aGUgc2FtZSBoYXNoIHdhcyBhbHJlYWR5IGltcG9ydGVkLlwiXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5yZXNwb25zZVRleHQuaW5kZXhPZihcInNhbWUgaGFzaCB3YXMgYWxyZWFkeSBpbXBvcnRlZFwiKSA+PSAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIm5vbmNlIGhhcyBhbHJlYWR5IGJlZW4gdXNlZFwiLCBsaWIuTG9nZ2VyLmVycm9ycy5OT05DRV9FWFBJUkVELCB7fSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gXCJUcmFuc2FjdGlvbiBnYXMgcHJpY2UgaXMgdG9vIGxvdy4gVGhlcmUgaXMgYW5vdGhlciB0cmFuc2FjdGlvbiB3aXRoIHNhbWUgbm9uY2UgaW4gdGhlIHF1ZXVlLiBUcnkgaW5jcmVhc2luZyB0aGUgZ2FzIHByaWNlIG9yIGluY3JlbWVudGluZyB0aGUgbm9uY2UuXCJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLnJlc3BvbnNlVGV4dC5pbmRleE9mKFwiYW5vdGhlciB0cmFuc2FjdGlvbiB3aXRoIHNhbWUgbm9uY2VcIikgPj0gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJyZXBsYWNlbWVudCBmZWUgdG9vIGxvd1wiLCBsaWIuTG9nZ2VyLmVycm9ycy5SRVBMQUNFTUVOVF9VTkRFUlBSSUNFRCwge30pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgODpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5ibG9ja1RhZykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsICs9IFwiL2FwaT9tb2R1bGU9cHJveHkmYWN0aW9uPWV0aF9nZXRCbG9ja0J5TnVtYmVyJnRhZz1cIiArIHBhcmFtcy5ibG9ja1RhZztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuaW5jbHVkZVRyYW5zYWN0aW9ucykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybCArPSBcIiZib29sZWFuPXRydWVcIjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybCArPSBcIiZib29sZWFuPWZhbHNlXCI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmwgKz0gYXBpS2V5O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGdldCh1cmwpXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJnZXRCbG9jayBieSBibG9ja0hhc2ggbm90IGltcGxlbWVudGVkXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgOTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdXJsICs9IFwiL2FwaT9tb2R1bGU9cHJveHkmYWN0aW9uPWV0aF9nZXRUcmFuc2FjdGlvbkJ5SGFzaCZ0eGhhc2g9XCIgKyBwYXJhbXMudHJhbnNhY3Rpb25IYXNoO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB1cmwgKz0gYXBpS2V5O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZ2V0KHVybCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHVybCArPSBcIi9hcGk/bW9kdWxlPXByb3h5JmFjdGlvbj1ldGhfZ2V0VHJhbnNhY3Rpb25SZWNlaXB0JnR4aGFzaD1cIiArIHBhcmFtcy50cmFuc2FjdGlvbkhhc2g7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHVybCArPSBhcGlLZXk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBnZXQodXJsKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24gPSBnZXRUcmFuc2FjdGlvblN0cmluZyhwYXJhbXMudHJhbnNhY3Rpb24pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRyYW5zYWN0aW9uKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24gPSBcIiZcIiArIHRyYW5zYWN0aW9uO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsICs9IFwiL2FwaT9tb2R1bGU9cHJveHkmYWN0aW9uPWV0aF9jYWxsXCIgKyB0cmFuc2FjdGlvbjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdXJsICs9IFwiJnRhZz1cIiArIHBhcmFtcy5ibG9ja1RhZyArIGFwaUtleTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuYmxvY2tUYWcgIT09IFwibGF0ZXN0XCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFdGhlcnNjYW5Qcm92aWRlciBkb2VzIG5vdCBzdXBwb3J0IGJsb2NrVGFnIGZvciBjYWxsXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsICs9IGFwaUtleTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBnZXQodXJsKV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSAxMjtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDEyOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbiA9IGdldFRyYW5zYWN0aW9uU3RyaW5nKHBhcmFtcy50cmFuc2FjdGlvbik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJhbnNhY3Rpb24pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbiA9IFwiJlwiICsgdHJhbnNhY3Rpb247XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmwgKz0gXCIvYXBpP21vZHVsZT1wcm94eSZhY3Rpb249ZXRoX2VzdGltYXRlR2FzJlwiICsgdHJhbnNhY3Rpb247XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmwgKz0gYXBpS2V5O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGdldCh1cmwpXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDEzO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTM6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHVybCArPSBcIi9hcGk/bW9kdWxlPWxvZ3MmYWN0aW9uPWdldExvZ3NcIjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5maWx0ZXIuZnJvbUJsb2NrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmwgKz0gXCImZnJvbUJsb2NrPVwiICsgY2hlY2tMb2dUYWcocGFyYW1zLmZpbHRlci5mcm9tQmxvY2spO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuZmlsdGVyLnRvQmxvY2spIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybCArPSBcIiZ0b0Jsb2NrPVwiICsgY2hlY2tMb2dUYWcocGFyYW1zLmZpbHRlci50b0Jsb2NrKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmZpbHRlci5hZGRyZXNzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmwgKz0gXCImYWRkcmVzcz1cIiArIHBhcmFtcy5maWx0ZXIuYWRkcmVzcztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBAVE9ETzogV2UgY2FuIGhhbmRsZSBzbGlnaHRseSBtb3JlIGNvbXBsaWNhdGVkIGxvZ3MgdXNpbmcgdGhlIGxvZ3MgQVBJXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuZmlsdGVyLnRvcGljcyAmJiBwYXJhbXMuZmlsdGVyLnRvcGljcy5sZW5ndGggPiAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmZpbHRlci50b3BpY3MubGVuZ3RoID4gMSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidW5zdXBwb3J0ZWQgdG9waWMgY291bnRcIiwgbGliLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7IHRvcGljczogcGFyYW1zLmZpbHRlci50b3BpY3MgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmZpbHRlci50b3BpY3MubGVuZ3RoID09PSAxKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9waWMwID0gcGFyYW1zLmZpbHRlci50b3BpY3NbMF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAodG9waWMwKSAhPT0gXCJzdHJpbmdcIiB8fCB0b3BpYzAubGVuZ3RoICE9PSA2Nikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInVuc3VwcG9ydGVkIHRvcGljIGZvcm1hdFwiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHsgdG9waWMwOiB0b3BpYzAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybCArPSBcIiZ0b3BpYzA9XCIgKyB0b3BpYzA7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgdXJsICs9IGFwaUtleTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZ2V0KHVybCwgZ2V0UmVzdWx0KV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxNDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbG9ncyA9IF9jLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHhzID0ge307XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGkgPSAwO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDE1O1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTU6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGkgPCBsb2dzLmxlbmd0aCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDE5XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbG9nID0gbG9nc1tpXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvZy5ibG9ja0hhc2ggIT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMThdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHR4c1tsb2cudHJhbnNhY3Rpb25IYXNoXSA9PSBudWxsKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTddO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldFRyYW5zYWN0aW9uKGxvZy50cmFuc2FjdGlvbkhhc2gpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE2OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0eCA9IF9jLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR4KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eHNbbG9nLnRyYW5zYWN0aW9uSGFzaF0gPSB0eC5ibG9ja0hhc2g7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSAxNztcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE3OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBsb2cuYmxvY2tIYXNoID0gdHhzW2xvZy50cmFuc2FjdGlvbkhhc2hdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDE4O1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTg6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMTVdO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTk6IHJldHVybiBbMiAvKnJldHVybiovLCBsb2dzXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDIwOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5uZXR3b3JrLm5hbWUgIT09IFwiaG9tZXN0ZWFkXCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCAwLjBdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHVybCArPSBcIi9hcGk/bW9kdWxlPXN0YXRzJmFjdGlvbj1ldGhwcmljZVwiO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB1cmwgKz0gYXBpS2V5O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYiA9IHBhcnNlRmxvYXQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGdldCh1cmwsIGdldFJlc3VsdCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMjE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYi5hcHBseSh2b2lkIDAsIFsoX2Muc2VudCgpKS5ldGh1c2RdKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyMjogcmV0dXJuIFszIC8qYnJlYWsqLywgMjNdO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMjM6IHJldHVybiBbMiAvKnJldHVybiovLCBfc3VwZXIucHJvdG90eXBlLnBlcmZvcm0uY2FsbCh0aGlzLCBtZXRob2QsIHBhcmFtcyldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICAvLyBAVE9ETzogQWxsb3cgc3RhcnRCbG9jayBhbmQgZW5kQmxvY2sgdG8gYmUgUHJvbWlzZXNcblx0ICAgIEV0aGVyc2NhblByb3ZpZGVyLnByb3RvdHlwZS5nZXRIaXN0b3J5ID0gZnVuY3Rpb24gKGFkZHJlc3NPck5hbWUsIHN0YXJ0QmxvY2ssIGVuZEJsb2NrKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICB2YXIgdXJsID0gdGhpcy5iYXNlVXJsO1xuXHQgICAgICAgIHZhciBhcGlLZXkgPSBcIlwiO1xuXHQgICAgICAgIGlmICh0aGlzLmFwaUtleSkge1xuXHQgICAgICAgICAgICBhcGlLZXkgKz0gXCImYXBpa2V5PVwiICsgdGhpcy5hcGlLZXk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChzdGFydEJsb2NrID09IG51bGwpIHtcblx0ICAgICAgICAgICAgc3RhcnRCbG9jayA9IDA7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChlbmRCbG9jayA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIGVuZEJsb2NrID0gOTk5OTk5OTk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzLnJlc29sdmVOYW1lKGFkZHJlc3NPck5hbWUpLnRoZW4oZnVuY3Rpb24gKGFkZHJlc3MpIHtcblx0ICAgICAgICAgICAgdXJsICs9IFwiL2FwaT9tb2R1bGU9YWNjb3VudCZhY3Rpb249dHhsaXN0JmFkZHJlc3M9XCIgKyBhZGRyZXNzO1xuXHQgICAgICAgICAgICB1cmwgKz0gXCImc3RhcnRibG9jaz1cIiArIHN0YXJ0QmxvY2s7XG5cdCAgICAgICAgICAgIHVybCArPSBcIiZlbmRibG9jaz1cIiArIGVuZEJsb2NrO1xuXHQgICAgICAgICAgICB1cmwgKz0gXCImc29ydD1hc2NcIiArIGFwaUtleTtcblx0ICAgICAgICAgICAgX3RoaXMuZW1pdChcImRlYnVnXCIsIHtcblx0ICAgICAgICAgICAgICAgIGFjdGlvbjogXCJyZXF1ZXN0XCIsXG5cdCAgICAgICAgICAgICAgICByZXF1ZXN0OiB1cmwsXG5cdCAgICAgICAgICAgICAgICBwcm92aWRlcjogX3RoaXNcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIHZhciBjb25uZWN0aW9uID0ge1xuXHQgICAgICAgICAgICAgICAgdXJsOiB1cmwsXG5cdCAgICAgICAgICAgICAgICB0aHJvdHRsZVNsb3RJbnRlcnZhbDogMTAwMCxcblx0ICAgICAgICAgICAgICAgIHRocm90dGxlQ2FsbGJhY2s6IGZ1bmN0aW9uIChhdHRlbXB0LCB1cmwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuYXBpS2V5ID09PSBkZWZhdWx0QXBpS2V5KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlci5zaG93VGhyb3R0bGVNZXNzYWdlKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIHJldHVybiBsaWIkbC5mZXRjaEpzb24oY29ubmVjdGlvbiwgbnVsbCwgZ2V0UmVzdWx0KS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcblx0ICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcInJlc3BvbnNlXCIsXG5cdCAgICAgICAgICAgICAgICAgICAgcmVxdWVzdDogdXJsLFxuXHQgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiBsaWIkMy5kZWVwQ29weShyZXN1bHQpLFxuXHQgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyOiBfdGhpc1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB2YXIgb3V0cHV0ID0gW107XG5cdCAgICAgICAgICAgICAgICByZXN1bHQuZm9yRWFjaChmdW5jdGlvbiAodHgpIHtcblx0ICAgICAgICAgICAgICAgICAgICBbXCJjb250cmFjdEFkZHJlc3NcIiwgXCJ0b1wiXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR4W2tleV0gPT0gXCJcIikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHR4W2tleV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodHguY3JlYXRlcyA9PSBudWxsICYmIHR4LmNvbnRyYWN0QWRkcmVzcyAhPSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR4LmNyZWF0ZXMgPSB0eC5jb250cmFjdEFkZHJlc3M7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gX3RoaXMuZm9ybWF0dGVyLnRyYW5zYWN0aW9uUmVzcG9uc2UodHgpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0eC50aW1lU3RhbXApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS50aW1lc3RhbXAgPSBwYXJzZUludCh0eC50aW1lU3RhbXApO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChpdGVtKTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIEV0aGVyc2NhblByb3ZpZGVyO1xuXHR9KGJhc2VQcm92aWRlci5CYXNlUHJvdmlkZXIpKTtcblx0ZXhwb3J0cy5FdGhlcnNjYW5Qcm92aWRlciA9IEV0aGVyc2NhblByb3ZpZGVyO1xuXG5cdH0pO1xuXG5cdHZhciBldGhlcnNjYW5Qcm92aWRlciQxID0gdW53cmFwRXhwb3J0cyhldGhlcnNjYW5Qcm92aWRlcik7XG5cdHZhciBldGhlcnNjYW5Qcm92aWRlcl8xID0gZXRoZXJzY2FuUHJvdmlkZXIuRXRoZXJzY2FuUHJvdmlkZXI7XG5cblx0dmFyIGZhbGxiYWNrUHJvdmlkZXIgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19leHRlbmRzID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG5cdCAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcblx0ICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG5cdCAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cblx0ICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG5cdCAgICB9O1xuXHR9KSgpO1xuXHR2YXIgX19hd2FpdGVyID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuXHQgICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG5cdCAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG5cdCAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG5cdCAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cblx0ICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG5cdCAgICB9KTtcblx0fTtcblx0dmFyIF9fZ2VuZXJhdG9yID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuXHQgICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcblx0ICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuXHQgICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG5cdCAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG5cdCAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuXHQgICAgICAgIHdoaWxlIChfKSB0cnkge1xuXHQgICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG5cdCAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcblx0ICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuXHQgICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuXHQgICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcblx0ICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG5cdCAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG5cdCAgICB9XG5cdH07XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXG5cblxuXG5cblxuXG5cblx0dmFyIGxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJEkudmVyc2lvbik7XG5cdGZ1bmN0aW9uIG5vdygpIHsgcmV0dXJuIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7IH1cblx0Ly8gUmV0dXJucyB0byBuZXR3b3JrIGFzIGxvbmcgYXMgYWxsIGFncmVlLCBvciBudWxsIGlmIGFueSBpcyBudWxsLlxuXHQvLyBUaHJvd3MgYW4gZXJyb3IgaWYgYW55IHR3byBuZXR3b3JrcyBkbyBub3QgbWF0Y2guXG5cdGZ1bmN0aW9uIGNoZWNrTmV0d29ya3MobmV0d29ya3MpIHtcblx0ICAgIHZhciByZXN1bHQgPSBudWxsO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXR3b3Jrcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHZhciBuZXR3b3JrID0gbmV0d29ya3NbaV07XG5cdCAgICAgICAgLy8gTnVsbCEgV2UgZG8gbm90IGtub3cgb3VyIG5ldHdvcms7IGJhaWwuXG5cdCAgICAgICAgaWYgKG5ldHdvcmsgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHJlc3VsdCkge1xuXHQgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIG5ldHdvcmsgbWF0Y2hlcyB0aGUgcHJldmlvdXMgbmV0d29ya3Ncblx0ICAgICAgICAgICAgaWYgKCEocmVzdWx0Lm5hbWUgPT09IG5ldHdvcmsubmFtZSAmJiByZXN1bHQuY2hhaW5JZCA9PT0gbmV0d29yay5jaGFpbklkICYmXG5cdCAgICAgICAgICAgICAgICAoKHJlc3VsdC5lbnNBZGRyZXNzID09PSBuZXR3b3JrLmVuc0FkZHJlc3MpIHx8IChyZXN1bHQuZW5zQWRkcmVzcyA9PSBudWxsICYmIG5ldHdvcmsuZW5zQWRkcmVzcyA9PSBudWxsKSkpKSB7XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwicHJvdmlkZXIgbWlzbWF0Y2hcIiwgXCJuZXR3b3Jrc1wiLCBuZXR3b3Jrcyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIHJlc3VsdCA9IG5ldHdvcms7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0fVxuXHRmdW5jdGlvbiBtZWRpYW4odmFsdWVzLCBtYXhEZWx0YSkge1xuXHQgICAgdmFsdWVzID0gdmFsdWVzLnNsaWNlKCkuc29ydCgpO1xuXHQgICAgdmFyIG1pZGRsZSA9IE1hdGguZmxvb3IodmFsdWVzLmxlbmd0aCAvIDIpO1xuXHQgICAgLy8gT2RkIGxlbmd0aDsgdGFrZSB0aGUgbWlkZGxlXG5cdCAgICBpZiAodmFsdWVzLmxlbmd0aCAlIDIpIHtcblx0ICAgICAgICByZXR1cm4gdmFsdWVzW21pZGRsZV07XG5cdCAgICB9XG5cdCAgICAvLyBFdmVuIGxlbmd0aDsgdGFrZSB0aGUgYXZlcmFnZSBvZiB0aGUgdHdvIG1pZGRsZVxuXHQgICAgdmFyIGEgPSB2YWx1ZXNbbWlkZGxlIC0gMV0sIGIgPSB2YWx1ZXNbbWlkZGxlXTtcblx0ICAgIGlmIChtYXhEZWx0YSAhPSBudWxsICYmIE1hdGguYWJzKGEgLSBiKSA+IG1heERlbHRhKSB7XG5cdCAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gKGEgKyBiKSAvIDI7XG5cdH1cblx0ZnVuY3Rpb24gc2VyaWFsaXplKHZhbHVlKSB7XG5cdCAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcblx0ICAgICAgICByZXR1cm4gXCJudWxsXCI7XG5cdCAgICB9XG5cdCAgICBlbHNlIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgKHZhbHVlKSA9PT0gXCJib29sZWFuXCIpIHtcblx0ICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuXHQgICAgfVxuXHQgICAgZWxzZSBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICByZXR1cm4gdmFsdWU7XG5cdCAgICB9XG5cdCAgICBlbHNlIGlmIChsaWIkMi5CaWdOdW1iZXIuaXNCaWdOdW1iZXIodmFsdWUpKSB7XG5cdCAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG5cdCAgICB9XG5cdCAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuXHQgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZS5tYXAoZnVuY3Rpb24gKGkpIHsgcmV0dXJuIHNlcmlhbGl6ZShpKTsgfSkpO1xuXHQgICAgfVxuXHQgICAgZWxzZSBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwib2JqZWN0XCIpIHtcblx0ICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcblx0ICAgICAgICBrZXlzLnNvcnQoKTtcblx0ICAgICAgICByZXR1cm4gXCJ7XCIgKyBrZXlzLm1hcChmdW5jdGlvbiAoa2V5KSB7XG5cdCAgICAgICAgICAgIHZhciB2ID0gdmFsdWVba2V5XTtcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiAodikgPT09IFwiZnVuY3Rpb25cIikge1xuXHQgICAgICAgICAgICAgICAgdiA9IFwiW2Z1bmN0aW9uXVwiO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdiA9IHNlcmlhbGl6ZSh2KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoa2V5KSArIFwiOlwiICsgdjtcblx0ICAgICAgICB9KS5qb2luKFwiLFwiKSArIFwifVwiO1xuXHQgICAgfVxuXHQgICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB2YWx1ZSB0eXBlOiBcIiArIHR5cGVvZiAodmFsdWUpKTtcblx0fVxuXHQvLyBOZXh0IHJlcXVlc3QgSUQgdG8gdXNlIGZvciBlbWl0dGluZyBkZWJ1ZyBpbmZvXG5cdHZhciBuZXh0UmlkID0gMTtcblx0O1xuXHRmdW5jdGlvbiBzdGFsbChkdXJhdGlvbikge1xuXHQgICAgdmFyIGNhbmNlbCA9IG51bGw7XG5cdCAgICB2YXIgdGltZXIgPSBudWxsO1xuXHQgICAgdmFyIHByb21pc2UgPSAobmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcblx0ICAgICAgICBjYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGlmICh0aW1lcikge1xuXHQgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcblx0ICAgICAgICAgICAgICAgIHRpbWVyID0gbnVsbDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXNvbHZlKCk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoY2FuY2VsLCBkdXJhdGlvbik7XG5cdCAgICB9KSk7XG5cdCAgICB2YXIgd2FpdCA9IGZ1bmN0aW9uIChmdW5jKSB7XG5cdCAgICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jKTtcblx0ICAgICAgICByZXR1cm4gcHJvbWlzZTtcblx0ICAgIH07XG5cdCAgICBmdW5jdGlvbiBnZXRQcm9taXNlKCkge1xuXHQgICAgICAgIHJldHVybiBwcm9taXNlO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHsgY2FuY2VsOiBjYW5jZWwsIGdldFByb21pc2U6IGdldFByb21pc2UsIHdhaXQ6IHdhaXQgfTtcblx0fVxuXHQ7XG5cdGZ1bmN0aW9uIGV4cG9zZURlYnVnQ29uZmlnKGNvbmZpZywgbm93KSB7XG5cdCAgICB2YXIgcmVzdWx0ID0ge1xuXHQgICAgICAgIHByb3ZpZGVyOiBjb25maWcucHJvdmlkZXIsXG5cdCAgICAgICAgd2VpZ2h0OiBjb25maWcud2VpZ2h0XG5cdCAgICB9O1xuXHQgICAgaWYgKGNvbmZpZy5zdGFydCkge1xuXHQgICAgICAgIHJlc3VsdC5zdGFydCA9IGNvbmZpZy5zdGFydDtcblx0ICAgIH1cblx0ICAgIGlmIChub3cpIHtcblx0ICAgICAgICByZXN1bHQuZHVyYXRpb24gPSAobm93IC0gY29uZmlnLnN0YXJ0KTtcblx0ICAgIH1cblx0ICAgIGlmIChjb25maWcuZG9uZSkge1xuXHQgICAgICAgIGlmIChjb25maWcuZXJyb3IpIHtcblx0ICAgICAgICAgICAgcmVzdWx0LmVycm9yID0gY29uZmlnLmVycm9yO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgcmVzdWx0LnJlc3VsdCA9IGNvbmZpZy5yZXN1bHQgfHwgbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHR9XG5cdGZ1bmN0aW9uIG5vcm1hbGl6ZWRUYWxseShub3JtYWxpemUsIHF1b3J1bSkge1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIChjb25maWdzKSB7XG5cdCAgICAgICAgLy8gQ291bnQgdGhlIHZvdGVzIGZvciBlYWNoIHJlc3VsdFxuXHQgICAgICAgIHZhciB0YWxseSA9IHt9O1xuXHQgICAgICAgIGNvbmZpZ3MuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuXHQgICAgICAgICAgICB2YXIgdmFsdWUgPSBub3JtYWxpemUoYy5yZXN1bHQpO1xuXHQgICAgICAgICAgICBpZiAoIXRhbGx5W3ZhbHVlXSkge1xuXHQgICAgICAgICAgICAgICAgdGFsbHlbdmFsdWVdID0geyBjb3VudDogMCwgcmVzdWx0OiBjLnJlc3VsdCB9O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRhbGx5W3ZhbHVlXS5jb3VudCsrO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIC8vIENoZWNrIGZvciBhIHF1b3J1bSBvbiBhbnkgZ2l2ZW4gcmVzdWx0XG5cdCAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh0YWxseSk7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIHZhciBjaGVjayA9IHRhbGx5W2tleXNbaV1dO1xuXHQgICAgICAgICAgICBpZiAoY2hlY2suY291bnQgPj0gcXVvcnVtKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gY2hlY2sucmVzdWx0O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIE5vIHF1cm91bVxuXHQgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG5cdCAgICB9O1xuXHR9XG5cdGZ1bmN0aW9uIGdldFByb2Nlc3NGdW5jKHByb3ZpZGVyLCBtZXRob2QsIHBhcmFtcykge1xuXHQgICAgdmFyIG5vcm1hbGl6ZSA9IHNlcmlhbGl6ZTtcblx0ICAgIHN3aXRjaCAobWV0aG9kKSB7XG5cdCAgICAgICAgY2FzZSBcImdldEJsb2NrTnVtYmVyXCI6XG5cdCAgICAgICAgICAgIC8vIFJldHVybiB0aGUgbWVkaWFuIHZhbHVlLCB1bmxlc3MgdGhlcmUgaXMgKG1lZGlhbiArIDEpIGlzIGFsc29cblx0ICAgICAgICAgICAgLy8gcHJlc2VudCwgaW4gd2hpY2ggY2FzZSB0aGF0IGlzIHByb2JhYmx5IHRydWUgYW5kIHRoZSBtZWRpYW5cblx0ICAgICAgICAgICAgLy8gaXMgZ29pbmcgdG8gYmUgc3RhbGUgc29vbi4gSW4gdGhlIGV2ZW50IG9mIGEgbWFsaWNpb3VzIG5vZGUsXG5cdCAgICAgICAgICAgIC8vIHRoZSBsaWUgd2lsbCBiZSB0cnVlIHNvb24gZW5vdWdoLlxuXHQgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNvbmZpZ3MpIHtcblx0ICAgICAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBjb25maWdzLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gYy5yZXN1bHQ7IH0pO1xuXHQgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBtZWRpYW4gYmxvY2sgbnVtYmVyXG5cdCAgICAgICAgICAgICAgICB2YXIgYmxvY2tOdW1iZXIgPSBtZWRpYW4oY29uZmlncy5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMucmVzdWx0OyB9KSwgMik7XG5cdCAgICAgICAgICAgICAgICBpZiAoYmxvY2tOdW1iZXIgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBibG9ja051bWJlciA9IE1hdGguY2VpbChibG9ja051bWJlcik7XG5cdCAgICAgICAgICAgICAgICAvLyBJZiB0aGUgbmV4dCBibG9jayBoZWlnaHQgaXMgcHJlc2VudCwgaXRzIHByb2xseSBzYWZlIHRvIHVzZVxuXHQgICAgICAgICAgICAgICAgaWYgKHZhbHVlcy5pbmRleE9mKGJsb2NrTnVtYmVyICsgMSkgPj0gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyKys7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAvLyBEb24ndCBldmVyIHJvbGwgYmFjayB0aGUgYmxvY2tOdW1iZXJcblx0ICAgICAgICAgICAgICAgIGlmIChibG9ja051bWJlciA+PSBwcm92aWRlci5faGlnaGVzdEJsb2NrTnVtYmVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIuX2hpZ2hlc3RCbG9ja051bWJlciA9IGJsb2NrTnVtYmVyO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyLl9oaWdoZXN0QmxvY2tOdW1iZXI7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgY2FzZSBcImdldEdhc1ByaWNlXCI6XG5cdCAgICAgICAgICAgIC8vIFJldHVybiB0aGUgbWlkZGxlIChyb3VuZCBpbmRleCB1cCkgdmFsdWUsIHNpbWlsYXIgdG8gbWVkaWFuXG5cdCAgICAgICAgICAgIC8vIGJ1dCBkbyBub3QgYXZlcmFnZSBldmVuIGVudHJpZXMgYW5kIGNob29zZSB0aGUgaGlnaGVyLlxuXHQgICAgICAgICAgICAvLyBNYWxpY2lvdXMgYWN0b3JzIG11c3QgY29tcHJvbWlzZSA1MCUgb2YgdGhlIG5vZGVzIHRvIGxpZS5cblx0ICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjb25maWdzKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgdmFsdWVzID0gY29uZmlncy5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMucmVzdWx0OyB9KTtcblx0ICAgICAgICAgICAgICAgIHZhbHVlcy5zb3J0KCk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVzW01hdGguZmxvb3IodmFsdWVzLmxlbmd0aCAvIDIpXTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICBjYXNlIFwiZ2V0RXRoZXJQcmljZVwiOlxuXHQgICAgICAgICAgICAvLyBSZXR1cm5zIHRoZSBtZWRpYW4gcHJpY2UuIE1hbGljaW91cyBhY3RvcnMgbXVzdCBjb21wcm9taXNlIGF0XG5cdCAgICAgICAgICAgIC8vIGxlYXN0IDUwJSBvZiB0aGUgbm9kZXMgdG8gbGllIChpbiBhIG1lYW5pbmdmdWwgd2F5KS5cblx0ICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjb25maWdzKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbWVkaWFuKGNvbmZpZ3MubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnJlc3VsdDsgfSkpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIC8vIE5vIGFkZGl0aW9uYWwgbm9ybWFsaXppbmcgcmVxdWlyZWQ7IHNlcmlhbGl6ZSBpcyBlbm91Z2hcblx0ICAgICAgICBjYXNlIFwiZ2V0QmFsYW5jZVwiOlxuXHQgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvbkNvdW50XCI6XG5cdCAgICAgICAgY2FzZSBcImdldENvZGVcIjpcblx0ICAgICAgICBjYXNlIFwiZ2V0U3RvcmFnZUF0XCI6XG5cdCAgICAgICAgY2FzZSBcImNhbGxcIjpcblx0ICAgICAgICBjYXNlIFwiZXN0aW1hdGVHYXNcIjpcblx0ICAgICAgICBjYXNlIFwiZ2V0TG9nc1wiOlxuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAvLyBXZSBkcm9wIHRoZSBjb25maXJtYXRpb25zIGZyb20gdHJhbnNhY3Rpb25zIGFzIGl0IGlzIGFwcHJveGltYXRlXG5cdCAgICAgICAgY2FzZSBcImdldFRyYW5zYWN0aW9uXCI6XG5cdCAgICAgICAgY2FzZSBcImdldFRyYW5zYWN0aW9uUmVjZWlwdFwiOlxuXHQgICAgICAgICAgICBub3JtYWxpemUgPSBmdW5jdGlvbiAodHgpIHtcblx0ICAgICAgICAgICAgICAgIGlmICh0eCA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB0eCA9IGxpYiQzLnNoYWxsb3dDb3B5KHR4KTtcblx0ICAgICAgICAgICAgICAgIHR4LmNvbmZpcm1hdGlvbnMgPSAtMTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemUodHgpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAvLyBXZSBkcm9wIHRoZSBjb25maXJtYXRpb25zIGZyb20gdHJhbnNhY3Rpb25zIGFzIGl0IGlzIGFwcHJveGltYXRlXG5cdCAgICAgICAgY2FzZSBcImdldEJsb2NrXCI6XG5cdCAgICAgICAgICAgIC8vIFdlIGRyb3AgdGhlIGNvbmZpcm1hdGlvbnMgZnJvbSB0cmFuc2FjdGlvbnMgYXMgaXQgaXMgYXBwcm94aW1hdGVcblx0ICAgICAgICAgICAgaWYgKHBhcmFtcy5pbmNsdWRlVHJhbnNhY3Rpb25zKSB7XG5cdCAgICAgICAgICAgICAgICBub3JtYWxpemUgPSBmdW5jdGlvbiAoYmxvY2spIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoYmxvY2sgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgYmxvY2sgPSBsaWIkMy5zaGFsbG93Q29weShibG9jayk7XG5cdCAgICAgICAgICAgICAgICAgICAgYmxvY2sudHJhbnNhY3Rpb25zID0gYmxvY2sudHJhbnNhY3Rpb25zLm1hcChmdW5jdGlvbiAodHgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHggPSBsaWIkMy5zaGFsbG93Q29weSh0eCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR4LmNvbmZpcm1hdGlvbnMgPSAtMTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR4O1xuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemUoYmxvY2spO1xuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIG5vcm1hbGl6ZSA9IGZ1bmN0aW9uIChibG9jaykge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChibG9jayA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplKGJsb2NrKTtcblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biBtZXRob2Q6IFwiICsgbWV0aG9kKTtcblx0ICAgIH1cblx0ICAgIC8vIFJldHVybiB0aGUgcmVzdWx0IGlmIGFuZCBvbmx5IGlmIHRoZSBleHBlY3RlZCBxdW9ydW0gaXNcblx0ICAgIC8vIHNhdGlzZmllZCBhbmQgYWdyZWVkIHVwb24gZm9yIHRoZSBmaW5hbCByZXN1bHQuXG5cdCAgICByZXR1cm4gbm9ybWFsaXplZFRhbGx5KG5vcm1hbGl6ZSwgcHJvdmlkZXIucXVvcnVtKTtcblx0fVxuXHQvLyBJZiB3ZSBhcmUgZG9pbmcgYSBibG9ja1RhZyBxdWVyeSwgd2UgbmVlZCB0byBtYWtlIHN1cmUgdGhlIGJhY2tlbmQgaXNcblx0Ly8gY2F1Z2h0IHVwIHRvIHRoZSBGYWxsYmFja1Byb3ZpZGVyLCBiZWZvcmUgc2VuZGluZyBhIHJlcXVlc3QgdG8gaXQuXG5cdGZ1bmN0aW9uIHdhaXRGb3JTeW5jKGNvbmZpZywgYmxvY2tOdW1iZXIpIHtcblx0ICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgcHJvdmlkZXI7XG5cdCAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICBwcm92aWRlciA9IChjb25maWcucHJvdmlkZXIpO1xuXHQgICAgICAgICAgICBpZiAoKHByb3ZpZGVyLmJsb2NrTnVtYmVyICE9IG51bGwgJiYgcHJvdmlkZXIuYmxvY2tOdW1iZXIgPj0gYmxvY2tOdW1iZXIpIHx8IGJsb2NrTnVtYmVyID09PSAtMSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHByb3ZpZGVyXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbGliJGwucG9sbChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBhcmUgc3luY2VkXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvdmlkZXIuYmxvY2tOdW1iZXIgPj0gYmxvY2tOdW1iZXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShwcm92aWRlcik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSdyZSBkb25lOyBqdXN0IHF1aXRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25maWcuY2FuY2VsbGVkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUobnVsbCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUcnkgYWdhaW4sIG5leHQgYmxvY2tcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHVuZGVmaW5lZCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0sIDApO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgfSwgeyBvbmNlUG9sbDogcHJvdmlkZXIgfSldO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfSk7XG5cdH1cblx0ZnVuY3Rpb24gZ2V0UnVubmVyKGNvbmZpZywgY3VycmVudEJsb2NrTnVtYmVyLCBtZXRob2QsIHBhcmFtcykge1xuXHQgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBwcm92aWRlciwgX2EsIGZpbHRlcjtcblx0ICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG5cdCAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMDpcblx0ICAgICAgICAgICAgICAgICAgICBwcm92aWRlciA9IGNvbmZpZy5wcm92aWRlcjtcblx0ICAgICAgICAgICAgICAgICAgICBfYSA9IG1ldGhvZDtcblx0ICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRCbG9ja051bWJlclwiOiByZXR1cm4gWzMgLypicmVhayovLCAxXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImdldEdhc1ByaWNlXCI6IHJldHVybiBbMyAvKmJyZWFrKi8sIDFdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0RXRoZXJQcmljZVwiOiByZXR1cm4gWzMgLypicmVhayovLCAyXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImdldEJhbGFuY2VcIjogcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvbkNvdW50XCI6IHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0Q29kZVwiOiByZXR1cm4gWzMgLypicmVhayovLCAzXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImdldFN0b3JhZ2VBdFwiOiByZXR1cm4gWzMgLypicmVhayovLCA2XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImdldEJsb2NrXCI6IHJldHVybiBbMyAvKmJyZWFrKi8sIDldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiY2FsbFwiOiByZXR1cm4gWzMgLypicmVhayovLCAxMl07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlc3RpbWF0ZUdhc1wiOiByZXR1cm4gWzMgLypicmVhayovLCAxMl07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvblwiOiByZXR1cm4gWzMgLypicmVhayovLCAxNV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvblJlY2VpcHRcIjogcmV0dXJuIFszIC8qYnJlYWsqLywgMTVdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0TG9nc1wiOiByZXR1cm4gWzMgLypicmVhayovLCAxNl07XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDE5XTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHByb3ZpZGVyW21ldGhvZF0oKV07XG5cdCAgICAgICAgICAgICAgICBjYXNlIDI6XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHByb3ZpZGVyLmdldEV0aGVyUHJpY2UpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHByb3ZpZGVyLmdldEV0aGVyUHJpY2UoKV07XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDE5XTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMzpcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIShwYXJhbXMuYmxvY2tUYWcgJiYgbGliJDEuaXNIZXhTdHJpbmcocGFyYW1zLmJsb2NrVGFnKSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHdhaXRGb3JTeW5jKGNvbmZpZywgY3VycmVudEJsb2NrTnVtYmVyKV07XG5cdCAgICAgICAgICAgICAgICBjYXNlIDQ6XG5cdCAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIgPSBfYi5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSA1O1xuXHQgICAgICAgICAgICAgICAgY2FzZSA1OiByZXR1cm4gWzIgLypyZXR1cm4qLywgcHJvdmlkZXJbbWV0aG9kXShwYXJhbXMuYWRkcmVzcywgcGFyYW1zLmJsb2NrVGFnIHx8IFwibGF0ZXN0XCIpXTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgNjpcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIShwYXJhbXMuYmxvY2tUYWcgJiYgbGliJDEuaXNIZXhTdHJpbmcocGFyYW1zLmJsb2NrVGFnKSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDhdO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHdhaXRGb3JTeW5jKGNvbmZpZywgY3VycmVudEJsb2NrTnVtYmVyKV07XG5cdCAgICAgICAgICAgICAgICBjYXNlIDc6XG5cdCAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIgPSBfYi5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSA4O1xuXHQgICAgICAgICAgICAgICAgY2FzZSA4OiByZXR1cm4gWzIgLypyZXR1cm4qLywgcHJvdmlkZXIuZ2V0U3RvcmFnZUF0KHBhcmFtcy5hZGRyZXNzLCBwYXJhbXMucG9zaXRpb24sIHBhcmFtcy5ibG9ja1RhZyB8fCBcImxhdGVzdFwiKV07XG5cdCAgICAgICAgICAgICAgICBjYXNlIDk6XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCEocGFyYW1zLmJsb2NrVGFnICYmIGxpYiQxLmlzSGV4U3RyaW5nKHBhcmFtcy5ibG9ja1RhZykpKSByZXR1cm4gWzMgLypicmVhayovLCAxMV07XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgd2FpdEZvclN5bmMoY29uZmlnLCBjdXJyZW50QmxvY2tOdW1iZXIpXTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMTA6XG5cdCAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIgPSBfYi5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAxMTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMTE6IHJldHVybiBbMiAvKnJldHVybiovLCBwcm92aWRlclsocGFyYW1zLmluY2x1ZGVUcmFuc2FjdGlvbnMgPyBcImdldEJsb2NrV2l0aFRyYW5zYWN0aW9uc1wiIDogXCJnZXRCbG9ja1wiKV0ocGFyYW1zLmJsb2NrVGFnIHx8IHBhcmFtcy5ibG9ja0hhc2gpXTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMTI6XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCEocGFyYW1zLmJsb2NrVGFnICYmIGxpYiQxLmlzSGV4U3RyaW5nKHBhcmFtcy5ibG9ja1RhZykpKSByZXR1cm4gWzMgLypicmVhayovLCAxNF07XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgd2FpdEZvclN5bmMoY29uZmlnLCBjdXJyZW50QmxvY2tOdW1iZXIpXTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMTM6XG5cdCAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIgPSBfYi5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAxNDtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMTQ6IHJldHVybiBbMiAvKnJldHVybiovLCBwcm92aWRlclttZXRob2RdKHBhcmFtcy50cmFuc2FjdGlvbildO1xuXHQgICAgICAgICAgICAgICAgY2FzZSAxNTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHByb3ZpZGVyW21ldGhvZF0ocGFyYW1zLnRyYW5zYWN0aW9uSGFzaCldO1xuXHQgICAgICAgICAgICAgICAgY2FzZSAxNjpcblx0ICAgICAgICAgICAgICAgICAgICBmaWx0ZXIgPSBwYXJhbXMuZmlsdGVyO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICghKChmaWx0ZXIuZnJvbUJsb2NrICYmIGxpYiQxLmlzSGV4U3RyaW5nKGZpbHRlci5mcm9tQmxvY2spKSB8fCAoZmlsdGVyLnRvQmxvY2sgJiYgbGliJDEuaXNIZXhTdHJpbmcoZmlsdGVyLnRvQmxvY2spKSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDE4XTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB3YWl0Rm9yU3luYyhjb25maWcsIGN1cnJlbnRCbG9ja051bWJlcildO1xuXHQgICAgICAgICAgICAgICAgY2FzZSAxNzpcblx0ICAgICAgICAgICAgICAgICAgICBwcm92aWRlciA9IF9iLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDE4O1xuXHQgICAgICAgICAgICAgICAgY2FzZSAxODogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHByb3ZpZGVyLmdldExvZ3MoZmlsdGVyKV07XG5cdCAgICAgICAgICAgICAgICBjYXNlIDE5OiByZXR1cm4gWzIgLypyZXR1cm4qLywgbG9nZ2VyLnRocm93RXJyb3IoXCJ1bmtub3duIG1ldGhvZCBlcnJvclwiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTktOT1dOX0VSUk9SLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IHBhcmFtc1xuXHQgICAgICAgICAgICAgICAgICAgIH0pXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgfSk7XG5cdH1cblx0dmFyIEZhbGxiYWNrUHJvdmlkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoRmFsbGJhY2tQcm92aWRlciwgX3N1cGVyKTtcblx0ICAgIGZ1bmN0aW9uIEZhbGxiYWNrUHJvdmlkZXIocHJvdmlkZXJzLCBxdW9ydW0pIHtcblx0ICAgICAgICB2YXIgX25ld1RhcmdldCA9IHRoaXMuY29uc3RydWN0b3I7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICBsb2dnZXIuY2hlY2tOZXcoX25ld1RhcmdldCwgRmFsbGJhY2tQcm92aWRlcik7XG5cdCAgICAgICAgaWYgKHByb3ZpZGVycy5sZW5ndGggPT09IDApIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm1pc3NpbmcgcHJvdmlkZXJzXCIsIFwicHJvdmlkZXJzXCIsIHByb3ZpZGVycyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBwcm92aWRlckNvbmZpZ3MgPSBwcm92aWRlcnMubWFwKGZ1bmN0aW9uIChjb25maWdPclByb3ZpZGVyLCBpbmRleCkge1xuXHQgICAgICAgICAgICBpZiAobGliJGIuUHJvdmlkZXIuaXNQcm92aWRlcihjb25maWdPclByb3ZpZGVyKSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyBwcm92aWRlcjogY29uZmlnT3JQcm92aWRlciwgd2VpZ2h0OiAxLCBzdGFsbFRpbWVvdXQ6IDc1MCwgcHJpb3JpdHk6IDEgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIGNvbmZpZyA9IGxpYiQzLnNoYWxsb3dDb3B5KGNvbmZpZ09yUHJvdmlkZXIpO1xuXHQgICAgICAgICAgICBpZiAoY29uZmlnLnByaW9yaXR5ID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgIGNvbmZpZy5wcmlvcml0eSA9IDE7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKGNvbmZpZy5zdGFsbFRpbWVvdXQgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgY29uZmlnLnN0YWxsVGltZW91dCA9IDc1MDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAoY29uZmlnLndlaWdodCA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICBjb25maWcud2VpZ2h0ID0gMTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgd2VpZ2h0ID0gY29uZmlnLndlaWdodDtcblx0ICAgICAgICAgICAgaWYgKHdlaWdodCAlIDEgfHwgd2VpZ2h0ID4gNTEyIHx8IHdlaWdodCA8IDEpIHtcblx0ICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHdlaWdodDsgbXVzdCBiZSBpbnRlZ2VyIGluIFsxLCA1MTJdXCIsIFwicHJvdmlkZXJzW1wiICsgaW5kZXggKyBcIl0ud2VpZ2h0XCIsIHdlaWdodCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5mcmVlemUoY29uZmlnKTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgICB2YXIgdG90YWwgPSBwcm92aWRlckNvbmZpZ3MucmVkdWNlKGZ1bmN0aW9uIChhY2N1bSwgYykgeyByZXR1cm4gKGFjY3VtICsgYy53ZWlnaHQpOyB9LCAwKTtcblx0ICAgICAgICBpZiAocXVvcnVtID09IG51bGwpIHtcblx0ICAgICAgICAgICAgcXVvcnVtID0gdG90YWwgLyAyO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIGlmIChxdW9ydW0gPiB0b3RhbCkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwicXVvcnVtIHdpbGwgYWx3YXlzIGZhaWw7IGxhcmdlciB0aGFuIHRvdGFsIHdlaWdodFwiLCBcInF1b3J1bVwiLCBxdW9ydW0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBBcmUgYWxsIHByb3ZpZGVycycgbmV0d29ya3MgYXJlIGtub3duXG5cdCAgICAgICAgdmFyIG5ldHdvcmtPclJlYWR5ID0gY2hlY2tOZXR3b3Jrcyhwcm92aWRlckNvbmZpZ3MubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiAoYy5wcm92aWRlcikubmV0d29yazsgfSkpO1xuXHQgICAgICAgIC8vIE5vdCBhbGwgbmV0d29ya3MgYXJlIGtub3duOyB3ZSBtdXN0IHN0YWxsXG5cdCAgICAgICAgaWYgKG5ldHdvcmtPclJlYWR5ID09IG51bGwpIHtcblx0ICAgICAgICAgICAgbmV0d29ya09yUmVhZHkgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdCAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICBfdGhpcy5kZXRlY3ROZXR3b3JrKCkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuXHQgICAgICAgICAgICAgICAgfSwgMCk7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG5ldHdvcmtPclJlYWR5KSB8fCB0aGlzO1xuXHQgICAgICAgIC8vIFByZXNlcnZlIGEgY29weSwgc28gd2UgZG8gbm90IGdldCBtdXRhdGVkXG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkoX3RoaXMsIFwicHJvdmlkZXJDb25maWdzXCIsIE9iamVjdC5mcmVlemUocHJvdmlkZXJDb25maWdzKSk7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkoX3RoaXMsIFwicXVvcnVtXCIsIHF1b3J1bSk7XG5cdCAgICAgICAgX3RoaXMuX2hpZ2hlc3RCbG9ja051bWJlciA9IC0xO1xuXHQgICAgICAgIHJldHVybiBfdGhpcztcblx0ICAgIH1cblx0ICAgIEZhbGxiYWNrUHJvdmlkZXIucHJvdG90eXBlLmRldGVjdE5ldHdvcmsgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgbmV0d29ya3M7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIFByb21pc2UuYWxsKHRoaXMucHJvdmlkZXJDb25maWdzLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gYy5wcm92aWRlci5nZXROZXR3b3JrKCk7IH0pKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBuZXR3b3JrcyA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGNoZWNrTmV0d29ya3MobmV0d29ya3MpXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgRmFsbGJhY2tQcm92aWRlci5wcm90b3R5cGUucGVyZm9ybSA9IGZ1bmN0aW9uIChtZXRob2QsIHBhcmFtcykge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIHJlc3VsdHMsIGlfMSwgcmVzdWx0LCBwcm9jZXNzRnVuYywgY29uZmlncywgY3VycmVudEJsb2NrTnVtYmVyLCBpLCBmaXJzdCwgX2xvb3BfMSwgdGhpc18xLCBzdGF0ZV8xO1xuXHQgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXRob2QgPT09IFwic2VuZFRyYW5zYWN0aW9uXCIpKSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgUHJvbWlzZS5hbGwodGhpcy5wcm92aWRlckNvbmZpZ3MubWFwKGZ1bmN0aW9uIChjKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGMucHJvdmlkZXIuc2VuZFRyYW5zYWN0aW9uKHBhcmFtcy5zaWduZWRUcmFuc2FjdGlvbikudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQuaGFzaDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFueSBzdWNjZXNzIGlzIGdvb2QgZW5vdWdoIChvdGhlciBlcnJvcnMgYXJlIGxpa2VseSBcImFscmVhZHkgc2VlblwiIGVycm9yc1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGlfMSA9IDA7IGlfMSA8IHJlc3VsdHMubGVuZ3RoOyBpXzErKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0c1tpXzFdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAocmVzdWx0KSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCByZXN1bHRdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZXkgd2VyZSBhbGwgYW4gZXJyb3I7IHBpY2sgdGhlIGZpcnN0IGVycm9yXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHJlc3VsdHNbMF07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh0aGlzLl9oaWdoZXN0QmxvY2tOdW1iZXIgPT09IC0xICYmIG1ldGhvZCAhPT0gXCJnZXRCbG9ja051bWJlclwiKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0QmxvY2tOdW1iZXIoKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gNDtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NGdW5jID0gZ2V0UHJvY2Vzc0Z1bmModGhpcywgbWV0aG9kLCBwYXJhbXMpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb25maWdzID0gYnJvd3NlciQ2LnNodWZmbGVkKHRoaXMucHJvdmlkZXJDb25maWdzLm1hcChsaWIkMy5zaGFsbG93Q29weSkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb25maWdzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIChhLnByaW9yaXR5IC0gYi5wcmlvcml0eSk7IH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50QmxvY2tOdW1iZXIgPSB0aGlzLl9oaWdoZXN0QmxvY2tOdW1iZXI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGkgPSAwO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9sb29wXzEgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdDAsIGluZmxpZ2h0V2VpZ2h0LCBfbG9vcF8yLCB3YWl0aW5nLCByZXN1bHRzLCByZXN1bHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0MCA9IG5vdygpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5mbGlnaHRXZWlnaHQgPSBjb25maWdzLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gKGMucnVubmVyICYmICgodDAgLSBjLnN0YXJ0KSA8IGMuc3RhbGxUaW1lb3V0KSk7IH0pXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlZHVjZShmdW5jdGlvbiAoYWNjdW0sIGMpIHsgcmV0dXJuIChhY2N1bSArIGMud2VpZ2h0KTsgfSwgMCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfbG9vcF8yID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb25maWcgPSBjb25maWdzW2krK107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJpZCA9IG5leHRSaWQrKztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuc3RhcnQgPSBub3coKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuc3RhbGxlciA9IHN0YWxsKGNvbmZpZy5zdGFsbFRpbWVvdXQpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5zdGFsbGVyLndhaXQoZnVuY3Rpb24gKCkgeyBjb25maWcuc3RhbGxlciA9IG51bGw7IH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5ydW5uZXIgPSBnZXRSdW5uZXIoY29uZmlnLCBjdXJyZW50QmxvY2tOdW1iZXIsIG1ldGhvZCwgcGFyYW1zKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLmRvbmUgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcucmVzdWx0ID0gcmVzdWx0O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMubGlzdGVuZXJDb3VudChcImRlYnVnXCIpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwiZGVidWdcIiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJyZXF1ZXN0XCIsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlkOiByaWQsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2VuZDogZXhwb3NlRGVidWdDb25maWcoY29uZmlnLCBub3coKSksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdDogeyBtZXRob2Q6IG1ldGhvZCwgcGFyYW1zOiBsaWIkMy5kZWVwQ29weShwYXJhbXMpIH0sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXI6IF90aGlzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuZG9uZSA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5lcnJvciA9IGVycm9yO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMubGlzdGVuZXJDb3VudChcImRlYnVnXCIpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwiZGVidWdcIiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJyZXF1ZXN0XCIsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlkOiByaWQsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2VuZDogZXhwb3NlRGVidWdDb25maWcoY29uZmlnLCBub3coKSksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdDogeyBtZXRob2Q6IG1ldGhvZCwgcGFyYW1zOiBsaWIkMy5kZWVwQ29weShwYXJhbXMpIH0sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXI6IF90aGlzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzXzEubGlzdGVuZXJDb3VudChcImRlYnVnXCIpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNfMS5lbWl0KFwiZGVidWdcIiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcInJlcXVlc3RcIixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZDogcmlkLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2VuZDogZXhwb3NlRGVidWdDb25maWcoY29uZmlnLCBudWxsKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHsgbWV0aG9kOiBtZXRob2QsIHBhcmFtczogbGliJDMuZGVlcENvcHkocGFyYW1zKSB9LFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXNfMVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5mbGlnaHRXZWlnaHQgKz0gY29uZmlnLndlaWdodDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdGFydCBydW5uaW5nIGVub3VnaCB0byBtZWV0IHF1b3J1bVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGluZmxpZ2h0V2VpZ2h0IDwgdGhpc18xLnF1b3J1bSAmJiBpIDwgY29uZmlncy5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfbG9vcF8yKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YWl0aW5nID0gW107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWdzLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYy5kb25lIHx8ICFjLnJ1bm5lcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhaXRpbmcucHVzaChjLnJ1bm5lcik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMuc3RhbGxlcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YWl0aW5nLnB1c2goYy5zdGFsbGVyLmdldFByb21pc2UoKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXdhaXRpbmcubGVuZ3RoKSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIFByb21pc2UucmFjZSh3YWl0aW5nKV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyA9IGNvbmZpZ3MuZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiAoYy5kb25lICYmIGMuZXJyb3IgPT0gbnVsbCk7IH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEocmVzdWx0cy5sZW5ndGggPj0gdGhpc18xLnF1b3J1bSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcHJvY2Vzc0Z1bmMocmVzdWx0cyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaHV0IGRvd24gYW55IHN0YWxsZXJzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlncy5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjLnN0YWxsZXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuc3RhbGxlci5jYW5jZWwoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmNhbmNlbGxlZCA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHsgdmFsdWU6IHJlc3VsdCB9XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghIWZpcnN0KSByZXR1cm4gWzMgLypicmVhayovLCA0XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHN0YWxsKDEwMCkuZ2V0UHJvbWlzZSgpXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSA0O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSA1O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGwgY29uZmlncyBoYXZlIHJ1biB0byBjb21wbGV0aW9uOyB3ZSB3aWxsIG5ldmVyIGdldCBtb3JlIGRhdGFcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25maWdzLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gIWMuZG9uZTsgfSkubGVuZ3RoID09PSAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIFwiYnJlYWtcIl07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNfMSA9IHRoaXM7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gNTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdHJ1ZSkgcmV0dXJuIFszIC8qYnJlYWsqLywgN107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNSAvKnlpZWxkKiovLCBfbG9vcF8xKCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVfMSA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZV8xID09PSBcIm9iamVjdFwiKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHN0YXRlXzEudmFsdWVdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGVfMSA9PT0gXCJicmVha1wiKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgN107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2h1dCBkb3duIGFueSBzdGFsbGVyczsgc2hvdWxkbid0IGJlIGFueVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb25maWdzLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjLnN0YWxsZXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLnN0YWxsZXIuY2FuY2VsKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmNhbmNlbGxlZCA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbG9nZ2VyLnRocm93RXJyb3IoXCJmYWlsZWQgdG8gbWVldCBxdW9ydW1cIiwgbGliLkxvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9yZXN1bHRzOiBjb25maWdzLm1hcCgoYykgPT4gYy5yZXN1bHQpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZXJyb3JzOiBjb25maWdzLm1hcCgoYykgPT4gYy5lcnJvciksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0czogY29uZmlncy5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGV4cG9zZURlYnVnQ29uZmlnKGMpOyB9KSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcjogdGhpc1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gRmFsbGJhY2tQcm92aWRlcjtcblx0fShiYXNlUHJvdmlkZXIuQmFzZVByb3ZpZGVyKSk7XG5cdGV4cG9ydHMuRmFsbGJhY2tQcm92aWRlciA9IEZhbGxiYWNrUHJvdmlkZXI7XG5cblx0fSk7XG5cblx0dmFyIGZhbGxiYWNrUHJvdmlkZXIkMSA9IHVud3JhcEV4cG9ydHMoZmFsbGJhY2tQcm92aWRlcik7XG5cdHZhciBmYWxsYmFja1Byb3ZpZGVyXzEgPSBmYWxsYmFja1Byb3ZpZGVyLkZhbGxiYWNrUHJvdmlkZXI7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciBJcGNQcm92aWRlciA9IG51bGw7XG5cblxuXHR2YXIgYnJvd3NlcklwY1Byb3ZpZGVyID0ge1xuXHRcdElwY1Byb3ZpZGVyOiBJcGNQcm92aWRlclxuXHR9O1xuXG5cdHZhciBpbmZ1cmFQcm92aWRlciA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciBfX2V4dGVuZHMgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcblx0ICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuXHQgICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcblx0ICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuXHQgICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcblx0ICAgIH07XG5cdH0pKCk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXG5cblxuXHR2YXIgbG9nZ2VyID0gbmV3IGxpYi5Mb2dnZXIoX3ZlcnNpb24kSS52ZXJzaW9uKTtcblxuXHR2YXIgZGVmYXVsdFByb2plY3RJZCA9IFwiODQ4NDIwNzhiMDk5NDY2MzhjMDMxNTdmODM0MDUyMTNcIjtcblx0dmFyIEluZnVyYVByb3ZpZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHQgICAgX19leHRlbmRzKEluZnVyYVByb3ZpZGVyLCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gSW5mdXJhUHJvdmlkZXIoKSB7XG5cdCAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuXHQgICAgfVxuXHQgICAgSW5mdXJhUHJvdmlkZXIuZ2V0V2ViU29ja2V0UHJvdmlkZXIgPSBmdW5jdGlvbiAobmV0d29yaywgYXBpS2V5KSB7XG5cdCAgICAgICAgdmFyIHByb3ZpZGVyID0gbmV3IEluZnVyYVByb3ZpZGVyKG5ldHdvcmssIGFwaUtleSk7XG5cdCAgICAgICAgdmFyIGNvbm5lY3Rpb24gPSBwcm92aWRlci5jb25uZWN0aW9uO1xuXHQgICAgICAgIGlmIChjb25uZWN0aW9uLnBhc3N3b3JkKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiSU5GVVJBIFdlYlNvY2tldCBwcm9qZWN0IHNlY3JldHMgdW5zdXBwb3J0ZWRcIiwgbGliLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG5cdCAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiSW5mdXJhUHJvdmlkZXIuZ2V0V2ViU29ja2V0UHJvdmlkZXIoKVwiXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgdXJsID0gY29ubmVjdGlvbi51cmwucmVwbGFjZSgvXmh0dHAvaSwgXCJ3c1wiKS5yZXBsYWNlKFwiL3YzL1wiLCBcIi93cy92My9cIik7XG5cdCAgICAgICAgcmV0dXJuIG5ldyB3ZWJzb2NrZXRQcm92aWRlci5XZWJTb2NrZXRQcm92aWRlcih1cmwsIG5ldHdvcmspO1xuXHQgICAgfTtcblx0ICAgIEluZnVyYVByb3ZpZGVyLmdldEFwaUtleSA9IGZ1bmN0aW9uIChhcGlLZXkpIHtcblx0ICAgICAgICB2YXIgYXBpS2V5T2JqID0ge1xuXHQgICAgICAgICAgICBhcGlLZXk6IGRlZmF1bHRQcm9qZWN0SWQsXG5cdCAgICAgICAgICAgIHByb2plY3RJZDogZGVmYXVsdFByb2plY3RJZCxcblx0ICAgICAgICAgICAgcHJvamVjdFNlY3JldDogbnVsbFxuXHQgICAgICAgIH07XG5cdCAgICAgICAgaWYgKGFwaUtleSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBhcGlLZXlPYmo7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICh0eXBlb2YgKGFwaUtleSkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgYXBpS2V5T2JqLnByb2plY3RJZCA9IGFwaUtleTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAoYXBpS2V5LnByb2plY3RTZWNyZXQgIT0gbnVsbCkge1xuXHQgICAgICAgICAgICBsb2dnZXIuYXNzZXJ0QXJndW1lbnQoKHR5cGVvZiAoYXBpS2V5LnByb2plY3RJZCkgPT09IFwic3RyaW5nXCIpLCBcInByb2plY3RTZWNyZXQgcmVxdWlyZXMgYSBwcm9qZWN0SWRcIiwgXCJwcm9qZWN0SWRcIiwgYXBpS2V5LnByb2plY3RJZCk7XG5cdCAgICAgICAgICAgIGxvZ2dlci5hc3NlcnRBcmd1bWVudCgodHlwZW9mIChhcGlLZXkucHJvamVjdFNlY3JldCkgPT09IFwic3RyaW5nXCIpLCBcImludmFsaWQgcHJvamVjdFNlY3JldFwiLCBcInByb2plY3RTZWNyZXRcIiwgXCJbUkVEQUNURURdXCIpO1xuXHQgICAgICAgICAgICBhcGlLZXlPYmoucHJvamVjdElkID0gYXBpS2V5LnByb2plY3RJZDtcblx0ICAgICAgICAgICAgYXBpS2V5T2JqLnByb2plY3RTZWNyZXQgPSBhcGlLZXkucHJvamVjdFNlY3JldDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAoYXBpS2V5LnByb2plY3RJZCkge1xuXHQgICAgICAgICAgICBhcGlLZXlPYmoucHJvamVjdElkID0gYXBpS2V5LnByb2plY3RJZDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgYXBpS2V5T2JqLmFwaUtleSA9IGFwaUtleU9iai5wcm9qZWN0SWQ7XG5cdCAgICAgICAgcmV0dXJuIGFwaUtleU9iajtcblx0ICAgIH07XG5cdCAgICBJbmZ1cmFQcm92aWRlci5nZXRVcmwgPSBmdW5jdGlvbiAobmV0d29yaywgYXBpS2V5KSB7XG5cdCAgICAgICAgdmFyIGhvc3QgPSBudWxsO1xuXHQgICAgICAgIHN3aXRjaCAobmV0d29yayA/IG5ldHdvcmsubmFtZSA6IFwidW5rbm93blwiKSB7XG5cdCAgICAgICAgICAgIGNhc2UgXCJob21lc3RlYWRcIjpcblx0ICAgICAgICAgICAgICAgIGhvc3QgPSBcIm1haW5uZXQuaW5mdXJhLmlvXCI7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSBcInJvcHN0ZW5cIjpcblx0ICAgICAgICAgICAgICAgIGhvc3QgPSBcInJvcHN0ZW4uaW5mdXJhLmlvXCI7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSBcInJpbmtlYnlcIjpcblx0ICAgICAgICAgICAgICAgIGhvc3QgPSBcInJpbmtlYnkuaW5mdXJhLmlvXCI7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSBcImtvdmFuXCI6XG5cdCAgICAgICAgICAgICAgICBob3N0ID0gXCJrb3Zhbi5pbmZ1cmEuaW9cIjtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlIFwiZ29lcmxpXCI6XG5cdCAgICAgICAgICAgICAgICBob3N0ID0gXCJnb2VybGkuaW5mdXJhLmlvXCI7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidW5zdXBwb3J0ZWQgbmV0d29ya1wiLCBsaWIuTG9nZ2VyLmVycm9ycy5JTlZBTElEX0FSR1VNRU5ULCB7XG5cdCAgICAgICAgICAgICAgICAgICAgYXJndW1lbnQ6IFwibmV0d29ya1wiLFxuXHQgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBuZXR3b3JrXG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGNvbm5lY3Rpb24gPSB7XG5cdCAgICAgICAgICAgIHVybDogKFwiaHR0cHM6L1wiICsgXCIvXCIgKyBob3N0ICsgXCIvdjMvXCIgKyBhcGlLZXkucHJvamVjdElkKSxcblx0ICAgICAgICAgICAgdGhyb3R0bGVDYWxsYmFjazogZnVuY3Rpb24gKGF0dGVtcHQsIHVybCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKGFwaUtleS5wcm9qZWN0SWQgPT09IGRlZmF1bHRQcm9qZWN0SWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZXIuc2hvd1Rocm90dGxlTWVzc2FnZSgpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH07XG5cdCAgICAgICAgaWYgKGFwaUtleS5wcm9qZWN0U2VjcmV0ICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgY29ubmVjdGlvbi51c2VyID0gXCJcIjtcblx0ICAgICAgICAgICAgY29ubmVjdGlvbi5wYXNzd29yZCA9IGFwaUtleS5wcm9qZWN0U2VjcmV0O1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gY29ubmVjdGlvbjtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gSW5mdXJhUHJvdmlkZXI7XG5cdH0odXJsSnNvblJwY1Byb3ZpZGVyLlVybEpzb25ScGNQcm92aWRlcikpO1xuXHRleHBvcnRzLkluZnVyYVByb3ZpZGVyID0gSW5mdXJhUHJvdmlkZXI7XG5cblx0fSk7XG5cblx0dmFyIGluZnVyYVByb3ZpZGVyJDEgPSB1bndyYXBFeHBvcnRzKGluZnVyYVByb3ZpZGVyKTtcblx0dmFyIGluZnVyYVByb3ZpZGVyXzEgPSBpbmZ1cmFQcm92aWRlci5JbmZ1cmFQcm92aWRlcjtcblxuXHR2YXIgbm9kZXNtaXRoUHJvdmlkZXIgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdC8qIGlzdGFuYnVsIGlnbm9yZSBmaWxlICovXG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19leHRlbmRzID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG5cdCAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcblx0ICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG5cdCAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cblx0ICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG5cdCAgICB9O1xuXHR9KSgpO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cblxuXG5cdHZhciBsb2dnZXIgPSBuZXcgbGliLkxvZ2dlcihfdmVyc2lvbiRJLnZlcnNpb24pO1xuXHQvLyBTcGVjaWFsIEFQSSBrZXkgcHJvdmlkZWQgYnkgTm9kZXNtaXRoIGZvciBldGhlcnMuanNcblx0dmFyIGRlZmF1bHRBcGlLZXkgPSBcIkVUSEVSU19KU19TSEFSRURcIjtcblx0dmFyIE5vZGVzbWl0aFByb3ZpZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHQgICAgX19leHRlbmRzKE5vZGVzbWl0aFByb3ZpZGVyLCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gTm9kZXNtaXRoUHJvdmlkZXIoKSB7XG5cdCAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuXHQgICAgfVxuXHQgICAgTm9kZXNtaXRoUHJvdmlkZXIuZ2V0QXBpS2V5ID0gZnVuY3Rpb24gKGFwaUtleSkge1xuXHQgICAgICAgIGlmIChhcGlLZXkgJiYgdHlwZW9mIChhcGlLZXkpICE9PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGFwaUtleVwiLCBcImFwaUtleVwiLCBhcGlLZXkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gYXBpS2V5IHx8IGRlZmF1bHRBcGlLZXk7XG5cdCAgICB9O1xuXHQgICAgTm9kZXNtaXRoUHJvdmlkZXIuZ2V0VXJsID0gZnVuY3Rpb24gKG5ldHdvcmssIGFwaUtleSkge1xuXHQgICAgICAgIGxvZ2dlci53YXJuKFwiTm9kZVNtaXRoIHdpbGwgYmUgZGlzY29udGludWVkIG9uIDIwMTktMTItMjA7IHBsZWFzZSBtaWdyYXRlIHRvIGFub3RoZXIgcGxhdGZvcm0uXCIpO1xuXHQgICAgICAgIHZhciBob3N0ID0gbnVsbDtcblx0ICAgICAgICBzd2l0Y2ggKG5ldHdvcmsubmFtZSkge1xuXHQgICAgICAgICAgICBjYXNlIFwiaG9tZXN0ZWFkXCI6XG5cdCAgICAgICAgICAgICAgICBob3N0ID0gXCJodHRwczovL2V0aGVyZXVtLmFwaS5ub2Rlc21pdGguaW8vdjEvbWFpbm5ldC9qc29ucnBjXCI7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSBcInJvcHN0ZW5cIjpcblx0ICAgICAgICAgICAgICAgIGhvc3QgPSBcImh0dHBzOi8vZXRoZXJldW0uYXBpLm5vZGVzbWl0aC5pby92MS9yb3BzdGVuL2pzb25ycGNcIjtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlIFwicmlua2VieVwiOlxuXHQgICAgICAgICAgICAgICAgaG9zdCA9IFwiaHR0cHM6Ly9ldGhlcmV1bS5hcGkubm9kZXNtaXRoLmlvL3YxL3JpbmtlYnkvanNvbnJwY1wiO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgXCJnb2VybGlcIjpcblx0ICAgICAgICAgICAgICAgIGhvc3QgPSBcImh0dHBzOi8vZXRoZXJldW0uYXBpLm5vZGVzbWl0aC5pby92MS9nb2VybGkvanNvbnJwY1wiO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgXCJrb3ZhblwiOlxuXHQgICAgICAgICAgICAgICAgaG9zdCA9IFwiaHR0cHM6Ly9ldGhlcmV1bS5hcGkubm9kZXNtaXRoLmlvL3YxL2tvdmFuL2pzb25ycGNcIjtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInVuc3VwcG9ydGVkIG5ldHdvcmtcIiwgXCJuZXR3b3JrXCIsIGFyZ3VtZW50c1swXSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiAoaG9zdCArIFwiP2FwaUtleT1cIiArIGFwaUtleSk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIE5vZGVzbWl0aFByb3ZpZGVyO1xuXHR9KHVybEpzb25ScGNQcm92aWRlci5VcmxKc29uUnBjUHJvdmlkZXIpKTtcblx0ZXhwb3J0cy5Ob2Rlc21pdGhQcm92aWRlciA9IE5vZGVzbWl0aFByb3ZpZGVyO1xuXG5cdH0pO1xuXG5cdHZhciBub2Rlc21pdGhQcm92aWRlciQxID0gdW53cmFwRXhwb3J0cyhub2Rlc21pdGhQcm92aWRlcik7XG5cdHZhciBub2Rlc21pdGhQcm92aWRlcl8xID0gbm9kZXNtaXRoUHJvdmlkZXIuTm9kZXNtaXRoUHJvdmlkZXI7XG5cblx0dmFyIHdlYjNQcm92aWRlciA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciBfX2V4dGVuZHMgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcblx0ICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuXHQgICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcblx0ICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuXHQgICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcblx0ICAgIH07XG5cdH0pKCk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXG5cblx0dmFyIGxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJEkudmVyc2lvbik7XG5cblx0dmFyIF9uZXh0SWQgPSAxO1xuXHRmdW5jdGlvbiBidWlsZFdlYjNMZWdhY3lGZXRjaGVyKHByb3ZpZGVyLCBzZW5kRnVuYykge1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIChtZXRob2QsIHBhcmFtcykge1xuXHQgICAgICAgIC8vIE1ldGFtYXNrIGNvbXBsYWlucyBhYm91dCBldGhfc2lnbiAoYW5kIG9uIHNvbWUgdmVyc2lvbnMgaGFuZ3MpXG5cdCAgICAgICAgaWYgKG1ldGhvZCA9PSBcImV0aF9zaWduXCIgJiYgcHJvdmlkZXIuaXNNZXRhTWFzaykge1xuXHQgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vZ28tZXRoZXJldW0vd2lraS9NYW5hZ2VtZW50LUFQSXMjcGVyc29uYWxfc2lnblxuXHQgICAgICAgICAgICBtZXRob2QgPSBcInBlcnNvbmFsX3NpZ25cIjtcblx0ICAgICAgICAgICAgcGFyYW1zID0gW3BhcmFtc1sxXSwgcGFyYW1zWzBdXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHJlcXVlc3QgPSB7XG5cdCAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuXHQgICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcblx0ICAgICAgICAgICAgaWQ6IChfbmV4dElkKyspLFxuXHQgICAgICAgICAgICBqc29ucnBjOiBcIjIuMFwiXG5cdCAgICAgICAgfTtcblx0ICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICAgICAgICBzZW5kRnVuYyhyZXF1ZXN0LCBmdW5jdGlvbiAoZXJyb3IsIHJlc3VsdCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnJvcik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yXzEgPSBuZXcgRXJyb3IocmVzdWx0LmVycm9yLm1lc3NhZ2UpO1xuXHQgICAgICAgICAgICAgICAgICAgIGVycm9yXzEuY29kZSA9IHJlc3VsdC5lcnJvci5jb2RlO1xuXHQgICAgICAgICAgICAgICAgICAgIGVycm9yXzEuZGF0YSA9IHJlc3VsdC5lcnJvci5kYXRhO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyb3JfMSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdC5yZXN1bHQpO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdH1cblx0ZnVuY3Rpb24gYnVpbGRFaXAxMTkzRmV0Y2hlcihwcm92aWRlcikge1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIChtZXRob2QsIHBhcmFtcykge1xuXHQgICAgICAgIGlmIChwYXJhbXMgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICBwYXJhbXMgPSBbXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gTWV0YW1hc2sgY29tcGxhaW5zIGFib3V0IGV0aF9zaWduIChhbmQgb24gc29tZSB2ZXJzaW9ucyBoYW5ncylcblx0ICAgICAgICBpZiAobWV0aG9kID09IFwiZXRoX3NpZ25cIiAmJiBwcm92aWRlci5pc01ldGFNYXNrKSB7XG5cdCAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9nby1ldGhlcmV1bS93aWtpL01hbmFnZW1lbnQtQVBJcyNwZXJzb25hbF9zaWduXG5cdCAgICAgICAgICAgIG1ldGhvZCA9IFwicGVyc29uYWxfc2lnblwiO1xuXHQgICAgICAgICAgICBwYXJhbXMgPSBbcGFyYW1zWzFdLCBwYXJhbXNbMF1dO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcHJvdmlkZXIucmVxdWVzdCh7IG1ldGhvZDogbWV0aG9kLCBwYXJhbXM6IHBhcmFtcyB9KTtcblx0ICAgIH07XG5cdH1cblx0dmFyIFdlYjNQcm92aWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0ICAgIF9fZXh0ZW5kcyhXZWIzUHJvdmlkZXIsIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBXZWIzUHJvdmlkZXIocHJvdmlkZXIsIG5ldHdvcmspIHtcblx0ICAgICAgICB2YXIgX25ld1RhcmdldCA9IHRoaXMuY29uc3RydWN0b3I7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICBsb2dnZXIuY2hlY2tOZXcoX25ld1RhcmdldCwgV2ViM1Byb3ZpZGVyKTtcblx0ICAgICAgICBpZiAocHJvdmlkZXIgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwibWlzc2luZyBwcm92aWRlclwiLCBcInByb3ZpZGVyXCIsIHByb3ZpZGVyKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHBhdGggPSBudWxsO1xuXHQgICAgICAgIHZhciBqc29uUnBjRmV0Y2hGdW5jID0gbnVsbDtcblx0ICAgICAgICB2YXIgc3VicHJvdmlkZXIgPSBudWxsO1xuXHQgICAgICAgIGlmICh0eXBlb2YgKHByb3ZpZGVyKSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdCAgICAgICAgICAgIHBhdGggPSBcInVua25vd246XCI7XG5cdCAgICAgICAgICAgIGpzb25ScGNGZXRjaEZ1bmMgPSBwcm92aWRlcjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIHBhdGggPSBwcm92aWRlci5ob3N0IHx8IHByb3ZpZGVyLnBhdGggfHwgXCJcIjtcblx0ICAgICAgICAgICAgaWYgKCFwYXRoICYmIHByb3ZpZGVyLmlzTWV0YU1hc2spIHtcblx0ICAgICAgICAgICAgICAgIHBhdGggPSBcIm1ldGFtYXNrXCI7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgc3VicHJvdmlkZXIgPSBwcm92aWRlcjtcblx0ICAgICAgICAgICAgaWYgKHByb3ZpZGVyLnJlcXVlc3QpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChwYXRoID09PSBcIlwiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcGF0aCA9IFwiZWlwLTExOTM6XCI7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBqc29uUnBjRmV0Y2hGdW5jID0gYnVpbGRFaXAxMTkzRmV0Y2hlcihwcm92aWRlcik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSBpZiAocHJvdmlkZXIuc2VuZEFzeW5jKSB7XG5cdCAgICAgICAgICAgICAgICBqc29uUnBjRmV0Y2hGdW5jID0gYnVpbGRXZWIzTGVnYWN5RmV0Y2hlcihwcm92aWRlciwgcHJvdmlkZXIuc2VuZEFzeW5jLmJpbmQocHJvdmlkZXIpKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIGlmIChwcm92aWRlci5zZW5kKSB7XG5cdCAgICAgICAgICAgICAgICBqc29uUnBjRmV0Y2hGdW5jID0gYnVpbGRXZWIzTGVnYWN5RmV0Y2hlcihwcm92aWRlciwgcHJvdmlkZXIuc2VuZC5iaW5kKHByb3ZpZGVyKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidW5zdXBwb3J0ZWQgcHJvdmlkZXJcIiwgXCJwcm92aWRlclwiLCBwcm92aWRlcik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKCFwYXRoKSB7XG5cdCAgICAgICAgICAgICAgICBwYXRoID0gXCJ1bmtub3duOlwiO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcGF0aCwgbmV0d29yaykgfHwgdGhpcztcblx0ICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seShfdGhpcywgXCJqc29uUnBjRmV0Y2hGdW5jXCIsIGpzb25ScGNGZXRjaEZ1bmMpO1xuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KF90aGlzLCBcInByb3ZpZGVyXCIsIHN1YnByb3ZpZGVyKTtcblx0ICAgICAgICByZXR1cm4gX3RoaXM7XG5cdCAgICB9XG5cdCAgICBXZWIzUHJvdmlkZXIucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAobWV0aG9kLCBwYXJhbXMpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5qc29uUnBjRmV0Y2hGdW5jKG1ldGhvZCwgcGFyYW1zKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gV2ViM1Byb3ZpZGVyO1xuXHR9KGpzb25ScGNQcm92aWRlci5Kc29uUnBjUHJvdmlkZXIpKTtcblx0ZXhwb3J0cy5XZWIzUHJvdmlkZXIgPSBXZWIzUHJvdmlkZXI7XG5cblx0fSk7XG5cblx0dmFyIHdlYjNQcm92aWRlciQxID0gdW53cmFwRXhwb3J0cyh3ZWIzUHJvdmlkZXIpO1xuXHR2YXIgd2ViM1Byb3ZpZGVyXzEgPSB3ZWIzUHJvdmlkZXIuV2ViM1Byb3ZpZGVyO1xuXG5cdHZhciBsaWIkbSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXHRleHBvcnRzLlByb3ZpZGVyID0gbGliJGIuUHJvdmlkZXI7XG5cblx0ZXhwb3J0cy5nZXROZXR3b3JrID0gbGliJGsuZ2V0TmV0d29yaztcblxuXHRleHBvcnRzLkJhc2VQcm92aWRlciA9IGJhc2VQcm92aWRlci5CYXNlUHJvdmlkZXI7XG5cblx0ZXhwb3J0cy5BbGNoZW15UHJvdmlkZXIgPSBhbGNoZW15UHJvdmlkZXIuQWxjaGVteVByb3ZpZGVyO1xuXG5cdGV4cG9ydHMuQ2xvdWRmbGFyZVByb3ZpZGVyID0gY2xvdWRmbGFyZVByb3ZpZGVyLkNsb3VkZmxhcmVQcm92aWRlcjtcblxuXHRleHBvcnRzLkV0aGVyc2NhblByb3ZpZGVyID0gZXRoZXJzY2FuUHJvdmlkZXIuRXRoZXJzY2FuUHJvdmlkZXI7XG5cblx0ZXhwb3J0cy5GYWxsYmFja1Byb3ZpZGVyID0gZmFsbGJhY2tQcm92aWRlci5GYWxsYmFja1Byb3ZpZGVyO1xuXG5cdGV4cG9ydHMuSXBjUHJvdmlkZXIgPSBicm93c2VySXBjUHJvdmlkZXIuSXBjUHJvdmlkZXI7XG5cblx0ZXhwb3J0cy5JbmZ1cmFQcm92aWRlciA9IGluZnVyYVByb3ZpZGVyLkluZnVyYVByb3ZpZGVyO1xuXG5cdGV4cG9ydHMuSnNvblJwY1Byb3ZpZGVyID0ganNvblJwY1Byb3ZpZGVyLkpzb25ScGNQcm92aWRlcjtcblx0ZXhwb3J0cy5Kc29uUnBjU2lnbmVyID0ganNvblJwY1Byb3ZpZGVyLkpzb25ScGNTaWduZXI7XG5cblx0ZXhwb3J0cy5Ob2Rlc21pdGhQcm92aWRlciA9IG5vZGVzbWl0aFByb3ZpZGVyLk5vZGVzbWl0aFByb3ZpZGVyO1xuXG5cdGV4cG9ydHMuU3RhdGljSnNvblJwY1Byb3ZpZGVyID0gdXJsSnNvblJwY1Byb3ZpZGVyLlN0YXRpY0pzb25ScGNQcm92aWRlcjtcblx0ZXhwb3J0cy5VcmxKc29uUnBjUHJvdmlkZXIgPSB1cmxKc29uUnBjUHJvdmlkZXIuVXJsSnNvblJwY1Byb3ZpZGVyO1xuXG5cdGV4cG9ydHMuV2ViM1Byb3ZpZGVyID0gd2ViM1Byb3ZpZGVyLldlYjNQcm92aWRlcjtcblxuXHRleHBvcnRzLldlYlNvY2tldFByb3ZpZGVyID0gd2Vic29ja2V0UHJvdmlkZXIuV2ViU29ja2V0UHJvdmlkZXI7XG5cblx0ZXhwb3J0cy5Gb3JtYXR0ZXIgPSBmb3JtYXR0ZXIuRm9ybWF0dGVyO1xuXG5cblx0dmFyIGxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJEkudmVyc2lvbik7XG5cdC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQvLyBIZWxwZXIgRnVuY3Rpb25zXG5cdGZ1bmN0aW9uIGdldERlZmF1bHRQcm92aWRlcihuZXR3b3JrLCBvcHRpb25zKSB7XG5cdCAgICBpZiAobmV0d29yayA9PSBudWxsKSB7XG5cdCAgICAgICAgbmV0d29yayA9IFwiaG9tZXN0ZWFkXCI7XG5cdCAgICB9XG5cdCAgICAvLyBJZiBwYXNzZWQgYSBVUkwsIGZpZ3VyZSBvdXQgdGhlIHJpZ2h0IHR5cGUgb2YgcHJvdmlkZXIgYmFzZWQgb24gdGhlIHNjaGVtZVxuXHQgICAgaWYgKHR5cGVvZiAobmV0d29yaykgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAvLyBAVE9ETzogQWRkIHN1cHBvcnQgZm9yIElwY1Byb3ZpZGVyOyBtYXliZSBpZiBpdCBlbmRzIGluIFwiLmlwY1wiP1xuXHQgICAgICAgIC8vIEhhbmRsZSBodHRwIGFuZCB3cyAoYW5kIHRoZWlyIHNlY3VyZSB2YXJpYW50cylcblx0ICAgICAgICB2YXIgbWF0Y2ggPSBuZXR3b3JrLm1hdGNoKC9eKHdzfGh0dHApcz86L2kpO1xuXHQgICAgICAgIGlmIChtYXRjaCkge1xuXHQgICAgICAgICAgICBzd2l0Y2ggKG1hdGNoWzFdKSB7XG5cdCAgICAgICAgICAgICAgICBjYXNlIFwiaHR0cFwiOlxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcganNvblJwY1Byb3ZpZGVyLkpzb25ScGNQcm92aWRlcihuZXR3b3JrKTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgXCJ3c1wiOlxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgd2Vic29ja2V0UHJvdmlkZXIuV2ViU29ja2V0UHJvdmlkZXIobmV0d29yayk7XG5cdCAgICAgICAgICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bnN1cHBvcnRlZCBVUkwgc2NoZW1lXCIsIFwibmV0d29ya1wiLCBuZXR3b3JrKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIHZhciBuID0gbGliJGsuZ2V0TmV0d29yayhuZXR3b3JrKTtcblx0ICAgIGlmICghbiB8fCAhbi5fZGVmYXVsdFByb3ZpZGVyKSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJ1bnN1cHBvcnRlZCBnZXREZWZhdWx0UHJvdmlkZXIgbmV0d29ya1wiLCBsaWIuTG9nZ2VyLmVycm9ycy5ORVRXT1JLX0VSUk9SLCB7XG5cdCAgICAgICAgICAgIG9wZXJhdGlvbjogXCJnZXREZWZhdWx0UHJvdmlkZXJcIixcblx0ICAgICAgICAgICAgbmV0d29yazogbmV0d29ya1xuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIG4uX2RlZmF1bHRQcm92aWRlcih7XG5cdCAgICAgICAgRmFsbGJhY2tQcm92aWRlcjogZmFsbGJhY2tQcm92aWRlci5GYWxsYmFja1Byb3ZpZGVyLFxuXHQgICAgICAgIEFsY2hlbXlQcm92aWRlcjogYWxjaGVteVByb3ZpZGVyLkFsY2hlbXlQcm92aWRlcixcblx0ICAgICAgICBDbG91ZGZsYXJlUHJvdmlkZXI6IGNsb3VkZmxhcmVQcm92aWRlci5DbG91ZGZsYXJlUHJvdmlkZXIsXG5cdCAgICAgICAgRXRoZXJzY2FuUHJvdmlkZXI6IGV0aGVyc2NhblByb3ZpZGVyLkV0aGVyc2NhblByb3ZpZGVyLFxuXHQgICAgICAgIEluZnVyYVByb3ZpZGVyOiBpbmZ1cmFQcm92aWRlci5JbmZ1cmFQcm92aWRlcixcblx0ICAgICAgICBKc29uUnBjUHJvdmlkZXI6IGpzb25ScGNQcm92aWRlci5Kc29uUnBjUHJvdmlkZXIsXG5cdCAgICAgICAgTm9kZXNtaXRoUHJvdmlkZXI6IG5vZGVzbWl0aFByb3ZpZGVyLk5vZGVzbWl0aFByb3ZpZGVyLFxuXHQgICAgICAgIFdlYjNQcm92aWRlcjogd2ViM1Byb3ZpZGVyLldlYjNQcm92aWRlcixcblx0ICAgICAgICBJcGNQcm92aWRlcjogYnJvd3NlcklwY1Byb3ZpZGVyLklwY1Byb3ZpZGVyLFxuXHQgICAgfSwgb3B0aW9ucyk7XG5cdH1cblx0ZXhwb3J0cy5nZXREZWZhdWx0UHJvdmlkZXIgPSBnZXREZWZhdWx0UHJvdmlkZXI7XG5cblx0fSk7XG5cblx0dmFyIGluZGV4JG0gPSB1bndyYXBFeHBvcnRzKGxpYiRtKTtcblx0dmFyIGxpYl8xJG0gPSBsaWIkbS5Qcm92aWRlcjtcblx0dmFyIGxpYl8yJGsgPSBsaWIkbS5nZXROZXR3b3JrO1xuXHR2YXIgbGliXzMkZyA9IGxpYiRtLkJhc2VQcm92aWRlcjtcblx0dmFyIGxpYl80JGMgPSBsaWIkbS5BbGNoZW15UHJvdmlkZXI7XG5cdHZhciBsaWJfNSRiID0gbGliJG0uQ2xvdWRmbGFyZVByb3ZpZGVyO1xuXHR2YXIgbGliXzYkNyA9IGxpYiRtLkV0aGVyc2NhblByb3ZpZGVyO1xuXHR2YXIgbGliXzckNiA9IGxpYiRtLkZhbGxiYWNrUHJvdmlkZXI7XG5cdHZhciBsaWJfOCQ1ID0gbGliJG0uSXBjUHJvdmlkZXI7XG5cdHZhciBsaWJfOSQ1ID0gbGliJG0uSW5mdXJhUHJvdmlkZXI7XG5cdHZhciBsaWJfMTAkMyA9IGxpYiRtLkpzb25ScGNQcm92aWRlcjtcblx0dmFyIGxpYl8xMSQyID0gbGliJG0uSnNvblJwY1NpZ25lcjtcblx0dmFyIGxpYl8xMiQyID0gbGliJG0uTm9kZXNtaXRoUHJvdmlkZXI7XG5cdHZhciBsaWJfMTMkMiA9IGxpYiRtLlN0YXRpY0pzb25ScGNQcm92aWRlcjtcblx0dmFyIGxpYl8xNCQxID0gbGliJG0uVXJsSnNvblJwY1Byb3ZpZGVyO1xuXHR2YXIgbGliXzE1JDEgPSBsaWIkbS5XZWIzUHJvdmlkZXI7XG5cdHZhciBsaWJfMTYkMSA9IGxpYiRtLldlYlNvY2tldFByb3ZpZGVyO1xuXHR2YXIgbGliXzE3ID0gbGliJG0uRm9ybWF0dGVyO1xuXHR2YXIgbGliXzE4ID0gbGliJG0uZ2V0RGVmYXVsdFByb3ZpZGVyO1xuXG5cdHZhciBsaWIkbiA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXG5cblxuXG5cdHZhciByZWdleEJ5dGVzID0gbmV3IFJlZ0V4cChcIl5ieXRlcyhbMC05XSspJFwiKTtcblx0dmFyIHJlZ2V4TnVtYmVyID0gbmV3IFJlZ0V4cChcIl4odT9pbnQpKFswLTldKikkXCIpO1xuXHR2YXIgcmVnZXhBcnJheSA9IG5ldyBSZWdFeHAoXCJeKC4qKVxcXFxbKFswLTldKilcXFxcXSRcIik7XG5cdHZhciBaZXJvcyA9IFwiMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO1xuXHRmdW5jdGlvbiBfcGFjayh0eXBlLCB2YWx1ZSwgaXNBcnJheSkge1xuXHQgICAgc3dpdGNoICh0eXBlKSB7XG5cdCAgICAgICAgY2FzZSBcImFkZHJlc3NcIjpcblx0ICAgICAgICAgICAgaWYgKGlzQXJyYXkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBsaWIkMS56ZXJvUGFkKHZhbHVlLCAzMik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIGxpYiQxLmFycmF5aWZ5KHZhbHVlKTtcblx0ICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG5cdCAgICAgICAgICAgIHJldHVybiBsaWIkOC50b1V0ZjhCeXRlcyh2YWx1ZSk7XG5cdCAgICAgICAgY2FzZSBcImJ5dGVzXCI6XG5cdCAgICAgICAgICAgIHJldHVybiBsaWIkMS5hcnJheWlmeSh2YWx1ZSk7XG5cdCAgICAgICAgY2FzZSBcImJvb2xcIjpcblx0ICAgICAgICAgICAgdmFsdWUgPSAodmFsdWUgPyBcIjB4MDFcIiA6IFwiMHgwMFwiKTtcblx0ICAgICAgICAgICAgaWYgKGlzQXJyYXkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBsaWIkMS56ZXJvUGFkKHZhbHVlLCAzMik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIGxpYiQxLmFycmF5aWZ5KHZhbHVlKTtcblx0ICAgIH1cblx0ICAgIHZhciBtYXRjaCA9IHR5cGUubWF0Y2gocmVnZXhOdW1iZXIpO1xuXHQgICAgaWYgKG1hdGNoKSB7XG5cdCAgICAgICAgLy9sZXQgc2lnbmVkID0gKG1hdGNoWzFdID09PSBcImludFwiKVxuXHQgICAgICAgIHZhciBzaXplID0gcGFyc2VJbnQobWF0Y2hbMl0gfHwgXCIyNTZcIik7XG5cdCAgICAgICAgaWYgKChtYXRjaFsyXSAmJiBTdHJpbmcoc2l6ZSkgIT09IG1hdGNoWzJdKSB8fCAoc2l6ZSAlIDggIT09IDApIHx8IHNpemUgPT09IDAgfHwgc2l6ZSA+IDI1Nikge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIG51bWJlciB0eXBlIC0gXCIgKyB0eXBlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGlzQXJyYXkpIHtcblx0ICAgICAgICAgICAgc2l6ZSA9IDI1Njtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFsdWUgPSBsaWIkMi5CaWdOdW1iZXIuZnJvbSh2YWx1ZSkudG9Ud29zKHNpemUpO1xuXHQgICAgICAgIHJldHVybiBsaWIkMS56ZXJvUGFkKHZhbHVlLCBzaXplIC8gOCk7XG5cdCAgICB9XG5cdCAgICBtYXRjaCA9IHR5cGUubWF0Y2gocmVnZXhCeXRlcyk7XG5cdCAgICBpZiAobWF0Y2gpIHtcblx0ICAgICAgICB2YXIgc2l6ZSA9IHBhcnNlSW50KG1hdGNoWzFdKTtcblx0ICAgICAgICBpZiAoU3RyaW5nKHNpemUpICE9PSBtYXRjaFsxXSB8fCBzaXplID09PSAwIHx8IHNpemUgPiAzMikge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGJ5dGVzIHR5cGUgLSBcIiArIHR5cGUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAobGliJDEuYXJyYXlpZnkodmFsdWUpLmJ5dGVMZW5ndGggIT09IHNpemUpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB2YWx1ZSBmb3IgXCIgKyB0eXBlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGlzQXJyYXkpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGxpYiQxLmFycmF5aWZ5KCh2YWx1ZSArIFplcm9zKS5zdWJzdHJpbmcoMCwgNjYpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHZhbHVlO1xuXHQgICAgfVxuXHQgICAgbWF0Y2ggPSB0eXBlLm1hdGNoKHJlZ2V4QXJyYXkpO1xuXHQgICAgaWYgKG1hdGNoICYmIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdCAgICAgICAgdmFyIGJhc2VUeXBlXzEgPSBtYXRjaFsxXTtcblx0ICAgICAgICB2YXIgY291bnQgPSBwYXJzZUludChtYXRjaFsyXSB8fCBTdHJpbmcodmFsdWUubGVuZ3RoKSk7XG5cdCAgICAgICAgaWYgKGNvdW50ICE9IHZhbHVlLmxlbmd0aCkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHZhbHVlIGZvciBcIiArIHR5cGUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgcmVzdWx0XzEgPSBbXTtcblx0ICAgICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgICAgICByZXN1bHRfMS5wdXNoKF9wYWNrKGJhc2VUeXBlXzEsIHZhbHVlLCB0cnVlKSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgcmV0dXJuIGxpYiQxLmNvbmNhdChyZXN1bHRfMSk7XG5cdCAgICB9XG5cdCAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHR5cGUgLSBcIiArIHR5cGUpO1xuXHR9XG5cdC8vIEBUT0RPOiBBcnJheSBFbnVtXG5cdGZ1bmN0aW9uIHBhY2sodHlwZXMsIHZhbHVlcykge1xuXHQgICAgaWYgKHR5cGVzLmxlbmd0aCAhPSB2YWx1ZXMubGVuZ3RoKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHlwZS92YWx1ZSBjb3VudCBtaXNtYXRjaFwiKTtcblx0ICAgIH1cblx0ICAgIHZhciB0aWdodCA9IFtdO1xuXHQgICAgdHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSwgaW5kZXgpIHtcblx0ICAgICAgICB0aWdodC5wdXNoKF9wYWNrKHR5cGUsIHZhbHVlc1tpbmRleF0pKTtcblx0ICAgIH0pO1xuXHQgICAgcmV0dXJuIGxpYiQxLmhleGxpZnkobGliJDEuY29uY2F0KHRpZ2h0KSk7XG5cdH1cblx0ZXhwb3J0cy5wYWNrID0gcGFjaztcblx0ZnVuY3Rpb24ga2VjY2FrMjU2KHR5cGVzLCB2YWx1ZXMpIHtcblx0ICAgIHJldHVybiBsaWIkNC5rZWNjYWsyNTYocGFjayh0eXBlcywgdmFsdWVzKSk7XG5cdH1cblx0ZXhwb3J0cy5rZWNjYWsyNTYgPSBrZWNjYWsyNTY7XG5cdGZ1bmN0aW9uIHNoYTI1Nih0eXBlcywgdmFsdWVzKSB7XG5cdCAgICByZXR1cm4gYnJvd3Nlci5zaGEyNTYocGFjayh0eXBlcywgdmFsdWVzKSk7XG5cdH1cblx0ZXhwb3J0cy5zaGEyNTYgPSBzaGEyNTY7XG5cblx0fSk7XG5cblx0dmFyIGluZGV4JG4gPSB1bndyYXBFeHBvcnRzKGxpYiRuKTtcblx0dmFyIGxpYl8xJG4gPSBsaWIkbi5wYWNrO1xuXHR2YXIgbGliXzIkbCA9IGxpYiRuLmtlY2NhazI1Njtcblx0dmFyIGxpYl8zJGggPSBsaWIkbi5zaGEyNTY7XG5cblx0dmFyIF92ZXJzaW9uJEsgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMudmVyc2lvbiA9IFwidW5pdHMvNS4wLjJcIjtcblxuXHR9KTtcblxuXHR2YXIgX3ZlcnNpb24kTCA9IHVud3JhcEV4cG9ydHMoX3ZlcnNpb24kSyk7XG5cdHZhciBfdmVyc2lvbl8xJG4gPSBfdmVyc2lvbiRLLnZlcnNpb247XG5cblx0dmFyIGxpYiRvID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5cblxuXHR2YXIgbG9nZ2VyID0gbmV3IGxpYi5Mb2dnZXIoX3ZlcnNpb24kSy52ZXJzaW9uKTtcblx0dmFyIG5hbWVzID0gW1xuXHQgICAgXCJ3ZWlcIixcblx0ICAgIFwia3dlaVwiLFxuXHQgICAgXCJtd2VpXCIsXG5cdCAgICBcImd3ZWlcIixcblx0ICAgIFwic3phYm9cIixcblx0ICAgIFwiZmlubmV5XCIsXG5cdCAgICBcImV0aGVyXCIsXG5cdF07XG5cdC8vIFNvbWUgZW52aXJvbm1lbnRzIGhhdmUgaXNzdWVzIHdpdGggUmVnRXggdGhhdCBjb250YWluIGJhY2stdHJhY2tpbmcsIHNvIHdlIGNhbm5vdFxuXHQvLyB1c2UgdGhlbS5cblx0ZnVuY3Rpb24gY29tbWlmeSh2YWx1ZSkge1xuXHQgICAgdmFyIGNvbXBzID0gU3RyaW5nKHZhbHVlKS5zcGxpdChcIi5cIik7XG5cdCAgICBpZiAoY29tcHMubGVuZ3RoID4gMiB8fCAhY29tcHNbMF0ubWF0Y2goL14tP1swLTldKiQvKSB8fCAoY29tcHNbMV0gJiYgIWNvbXBzWzFdLm1hdGNoKC9eWzAtOV0qJC8pKSB8fCB2YWx1ZSA9PT0gXCIuXCIgfHwgdmFsdWUgPT09IFwiLS5cIikge1xuXHQgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHZhbHVlXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuXHQgICAgfVxuXHQgICAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgYXQgbGVhc3Qgb25lIHdob2xlIGRpZ2l0ICgwIGlmIG5vbmUpXG5cdCAgICB2YXIgd2hvbGUgPSBjb21wc1swXTtcblx0ICAgIHZhciBuZWdhdGl2ZSA9IFwiXCI7XG5cdCAgICBpZiAod2hvbGUuc3Vic3RyaW5nKDAsIDEpID09PSBcIi1cIikge1xuXHQgICAgICAgIG5lZ2F0aXZlID0gXCItXCI7XG5cdCAgICAgICAgd2hvbGUgPSB3aG9sZS5zdWJzdHJpbmcoMSk7XG5cdCAgICB9XG5cdCAgICAvLyBNYWtlIHN1cmUgd2UgaGF2ZSBhdCBsZWFzdCAxIHdob2xlIGRpZ2l0IHdpdGggbm8gbGVhZGluZyB6ZXJvc1xuXHQgICAgd2hpbGUgKHdob2xlLnN1YnN0cmluZygwLCAxKSA9PT0gXCIwXCIpIHtcblx0ICAgICAgICB3aG9sZSA9IHdob2xlLnN1YnN0cmluZygxKTtcblx0ICAgIH1cblx0ICAgIGlmICh3aG9sZSA9PT0gXCJcIikge1xuXHQgICAgICAgIHdob2xlID0gXCIwXCI7XG5cdCAgICB9XG5cdCAgICB2YXIgc3VmZml4ID0gXCJcIjtcblx0ICAgIGlmIChjb21wcy5sZW5ndGggPT09IDIpIHtcblx0ICAgICAgICBzdWZmaXggPSBcIi5cIiArIChjb21wc1sxXSB8fCBcIjBcIik7XG5cdCAgICB9XG5cdCAgICB3aGlsZSAoc3VmZml4Lmxlbmd0aCA+IDIgJiYgc3VmZml4W3N1ZmZpeC5sZW5ndGggLSAxXSA9PT0gXCIwXCIpIHtcblx0ICAgICAgICBzdWZmaXggPSBzdWZmaXguc3Vic3RyaW5nKDAsIHN1ZmZpeC5sZW5ndGggLSAxKTtcblx0ICAgIH1cblx0ICAgIHZhciBmb3JtYXR0ZWQgPSBbXTtcblx0ICAgIHdoaWxlICh3aG9sZS5sZW5ndGgpIHtcblx0ICAgICAgICBpZiAod2hvbGUubGVuZ3RoIDw9IDMpIHtcblx0ICAgICAgICAgICAgZm9ybWF0dGVkLnVuc2hpZnQod2hvbGUpO1xuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIHZhciBpbmRleCA9IHdob2xlLmxlbmd0aCAtIDM7XG5cdCAgICAgICAgICAgIGZvcm1hdHRlZC51bnNoaWZ0KHdob2xlLnN1YnN0cmluZyhpbmRleCkpO1xuXHQgICAgICAgICAgICB3aG9sZSA9IHdob2xlLnN1YnN0cmluZygwLCBpbmRleCk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIG5lZ2F0aXZlICsgZm9ybWF0dGVkLmpvaW4oXCIsXCIpICsgc3VmZml4O1xuXHR9XG5cdGV4cG9ydHMuY29tbWlmeSA9IGNvbW1pZnk7XG5cdGZ1bmN0aW9uIGZvcm1hdFVuaXRzKHZhbHVlLCB1bml0TmFtZSkge1xuXHQgICAgaWYgKHR5cGVvZiAodW5pdE5hbWUpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgdmFyIGluZGV4ID0gbmFtZXMuaW5kZXhPZih1bml0TmFtZSk7XG5cdCAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuXHQgICAgICAgICAgICB1bml0TmFtZSA9IDMgKiBpbmRleDtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbGliJDIuZm9ybWF0Rml4ZWQodmFsdWUsICh1bml0TmFtZSAhPSBudWxsKSA/IHVuaXROYW1lIDogMTgpO1xuXHR9XG5cdGV4cG9ydHMuZm9ybWF0VW5pdHMgPSBmb3JtYXRVbml0cztcblx0ZnVuY3Rpb24gcGFyc2VVbml0cyh2YWx1ZSwgdW5pdE5hbWUpIHtcblx0ICAgIGlmICh0eXBlb2YgKHVuaXROYW1lKSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgIHZhciBpbmRleCA9IG5hbWVzLmluZGV4T2YodW5pdE5hbWUpO1xuXHQgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcblx0ICAgICAgICAgICAgdW5pdE5hbWUgPSAzICogaW5kZXg7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIGxpYiQyLnBhcnNlRml4ZWQodmFsdWUsICh1bml0TmFtZSAhPSBudWxsKSA/IHVuaXROYW1lIDogMTgpO1xuXHR9XG5cdGV4cG9ydHMucGFyc2VVbml0cyA9IHBhcnNlVW5pdHM7XG5cdGZ1bmN0aW9uIGZvcm1hdEV0aGVyKHdlaSkge1xuXHQgICAgcmV0dXJuIGZvcm1hdFVuaXRzKHdlaSwgMTgpO1xuXHR9XG5cdGV4cG9ydHMuZm9ybWF0RXRoZXIgPSBmb3JtYXRFdGhlcjtcblx0ZnVuY3Rpb24gcGFyc2VFdGhlcihldGhlcikge1xuXHQgICAgcmV0dXJuIHBhcnNlVW5pdHMoZXRoZXIsIDE4KTtcblx0fVxuXHRleHBvcnRzLnBhcnNlRXRoZXIgPSBwYXJzZUV0aGVyO1xuXG5cdH0pO1xuXG5cdHZhciBpbmRleCRvID0gdW53cmFwRXhwb3J0cyhsaWIkbyk7XG5cdHZhciBsaWJfMSRvID0gbGliJG8uY29tbWlmeTtcblx0dmFyIGxpYl8yJG0gPSBsaWIkby5mb3JtYXRVbml0cztcblx0dmFyIGxpYl8zJGkgPSBsaWIkby5wYXJzZVVuaXRzO1xuXHR2YXIgbGliXzQkZCA9IGxpYiRvLmZvcm1hdEV0aGVyO1xuXHR2YXIgbGliXzUkYyA9IGxpYiRvLnBhcnNlRXRoZXI7XG5cblx0dmFyIHV0aWxzJDMgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19pbXBvcnRTdGFyID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuXHQgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcblx0ICAgIHZhciByZXN1bHQgPSB7fTtcblx0ICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG5cdCAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0fTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5cdGV4cG9ydHMuQWJpQ29kZXIgPSBsaWIkYS5BYmlDb2Rlcjtcblx0ZXhwb3J0cy5jaGVja1Jlc3VsdEVycm9ycyA9IGxpYiRhLmNoZWNrUmVzdWx0RXJyb3JzO1xuXHRleHBvcnRzLmRlZmF1bHRBYmlDb2RlciA9IGxpYiRhLmRlZmF1bHRBYmlDb2Rlcjtcblx0ZXhwb3J0cy5FdmVudEZyYWdtZW50ID0gbGliJGEuRXZlbnRGcmFnbWVudDtcblx0ZXhwb3J0cy5Gb3JtYXRUeXBlcyA9IGxpYiRhLkZvcm1hdFR5cGVzO1xuXHRleHBvcnRzLkZyYWdtZW50ID0gbGliJGEuRnJhZ21lbnQ7XG5cdGV4cG9ydHMuRnVuY3Rpb25GcmFnbWVudCA9IGxpYiRhLkZ1bmN0aW9uRnJhZ21lbnQ7XG5cdGV4cG9ydHMuSW5kZXhlZCA9IGxpYiRhLkluZGV4ZWQ7XG5cdGV4cG9ydHMuSW50ZXJmYWNlID0gbGliJGEuSW50ZXJmYWNlO1xuXHRleHBvcnRzLkxvZ0Rlc2NyaXB0aW9uID0gbGliJGEuTG9nRGVzY3JpcHRpb247XG5cdGV4cG9ydHMuUGFyYW1UeXBlID0gbGliJGEuUGFyYW1UeXBlO1xuXHRleHBvcnRzLlRyYW5zYWN0aW9uRGVzY3JpcHRpb24gPSBsaWIkYS5UcmFuc2FjdGlvbkRlc2NyaXB0aW9uO1xuXG5cdGV4cG9ydHMuZ2V0QWRkcmVzcyA9IGxpYiQ2LmdldEFkZHJlc3M7XG5cdGV4cG9ydHMuZ2V0Q3JlYXRlMkFkZHJlc3MgPSBsaWIkNi5nZXRDcmVhdGUyQWRkcmVzcztcblx0ZXhwb3J0cy5nZXRDb250cmFjdEFkZHJlc3MgPSBsaWIkNi5nZXRDb250cmFjdEFkZHJlc3M7XG5cdGV4cG9ydHMuZ2V0SWNhcEFkZHJlc3MgPSBsaWIkNi5nZXRJY2FwQWRkcmVzcztcblx0ZXhwb3J0cy5pc0FkZHJlc3MgPSBsaWIkNi5pc0FkZHJlc3M7XG5cdHZhciBiYXNlNjQgPSBfX2ltcG9ydFN0YXIoYnJvd3NlciQ4KTtcblx0ZXhwb3J0cy5iYXNlNjQgPSBiYXNlNjQ7XG5cblx0ZXhwb3J0cy5iYXNlNTggPSBsaWIkZS5CYXNlNTg7XG5cblx0ZXhwb3J0cy5hcnJheWlmeSA9IGxpYiQxLmFycmF5aWZ5O1xuXHRleHBvcnRzLmNvbmNhdCA9IGxpYiQxLmNvbmNhdDtcblx0ZXhwb3J0cy5oZXhEYXRhU2xpY2UgPSBsaWIkMS5oZXhEYXRhU2xpY2U7XG5cdGV4cG9ydHMuaGV4RGF0YUxlbmd0aCA9IGxpYiQxLmhleERhdGFMZW5ndGg7XG5cdGV4cG9ydHMuaGV4bGlmeSA9IGxpYiQxLmhleGxpZnk7XG5cdGV4cG9ydHMuaGV4U3RyaXBaZXJvcyA9IGxpYiQxLmhleFN0cmlwWmVyb3M7XG5cdGV4cG9ydHMuaGV4VmFsdWUgPSBsaWIkMS5oZXhWYWx1ZTtcblx0ZXhwb3J0cy5oZXhaZXJvUGFkID0gbGliJDEuaGV4WmVyb1BhZDtcblx0ZXhwb3J0cy5pc0J5dGVzID0gbGliJDEuaXNCeXRlcztcblx0ZXhwb3J0cy5pc0J5dGVzTGlrZSA9IGxpYiQxLmlzQnl0ZXNMaWtlO1xuXHRleHBvcnRzLmlzSGV4U3RyaW5nID0gbGliJDEuaXNIZXhTdHJpbmc7XG5cdGV4cG9ydHMuam9pblNpZ25hdHVyZSA9IGxpYiQxLmpvaW5TaWduYXR1cmU7XG5cdGV4cG9ydHMuemVyb1BhZCA9IGxpYiQxLnplcm9QYWQ7XG5cdGV4cG9ydHMuc3BsaXRTaWduYXR1cmUgPSBsaWIkMS5zcGxpdFNpZ25hdHVyZTtcblx0ZXhwb3J0cy5zdHJpcFplcm9zID0gbGliJDEuc3RyaXBaZXJvcztcblxuXHRleHBvcnRzLmhhc2hNZXNzYWdlID0gbGliJDkuaGFzaE1lc3NhZ2U7XG5cdGV4cG9ydHMuaWQgPSBsaWIkOS5pZDtcblx0ZXhwb3J0cy5pc1ZhbGlkTmFtZSA9IGxpYiQ5LmlzVmFsaWROYW1lO1xuXHRleHBvcnRzLm5hbWVoYXNoID0gbGliJDkubmFtZWhhc2g7XG5cblx0ZXhwb3J0cy5kZWZhdWx0UGF0aCA9IGxpYiRoLmRlZmF1bHRQYXRoO1xuXHRleHBvcnRzLmVudHJvcHlUb01uZW1vbmljID0gbGliJGguZW50cm9weVRvTW5lbW9uaWM7XG5cdGV4cG9ydHMuSEROb2RlID0gbGliJGguSEROb2RlO1xuXHRleHBvcnRzLmlzVmFsaWRNbmVtb25pYyA9IGxpYiRoLmlzVmFsaWRNbmVtb25pYztcblx0ZXhwb3J0cy5tbmVtb25pY1RvRW50cm9weSA9IGxpYiRoLm1uZW1vbmljVG9FbnRyb3B5O1xuXHRleHBvcnRzLm1uZW1vbmljVG9TZWVkID0gbGliJGgubW5lbW9uaWNUb1NlZWQ7XG5cblx0ZXhwb3J0cy5nZXRKc29uV2FsbGV0QWRkcmVzcyA9IGxpYiRpLmdldEpzb25XYWxsZXRBZGRyZXNzO1xuXG5cdGV4cG9ydHMua2VjY2FrMjU2ID0gbGliJDQua2VjY2FrMjU2O1xuXG5cdGV4cG9ydHMuTG9nZ2VyID0gbGliLkxvZ2dlcjtcblxuXHRleHBvcnRzLmNvbXB1dGVIbWFjID0gYnJvd3Nlci5jb21wdXRlSG1hYztcblx0ZXhwb3J0cy5yaXBlbWQxNjAgPSBicm93c2VyLnJpcGVtZDE2MDtcblx0ZXhwb3J0cy5zaGEyNTYgPSBicm93c2VyLnNoYTI1Njtcblx0ZXhwb3J0cy5zaGE1MTIgPSBicm93c2VyLnNoYTUxMjtcblxuXHRleHBvcnRzLnNvbGlkaXR5S2VjY2FrMjU2ID0gbGliJG4ua2VjY2FrMjU2O1xuXHRleHBvcnRzLnNvbGlkaXR5UGFjayA9IGxpYiRuLnBhY2s7XG5cdGV4cG9ydHMuc29saWRpdHlTaGEyNTYgPSBsaWIkbi5zaGEyNTY7XG5cblx0ZXhwb3J0cy5yYW5kb21CeXRlcyA9IGJyb3dzZXIkNi5yYW5kb21CeXRlcztcblx0ZXhwb3J0cy5zaHVmZmxlZCA9IGJyb3dzZXIkNi5zaHVmZmxlZDtcblxuXHRleHBvcnRzLmNoZWNrUHJvcGVydGllcyA9IGxpYiQzLmNoZWNrUHJvcGVydGllcztcblx0ZXhwb3J0cy5kZWVwQ29weSA9IGxpYiQzLmRlZXBDb3B5O1xuXHRleHBvcnRzLmRlZmluZVJlYWRPbmx5ID0gbGliJDMuZGVmaW5lUmVhZE9ubHk7XG5cdGV4cG9ydHMuZ2V0U3RhdGljID0gbGliJDMuZ2V0U3RhdGljO1xuXHRleHBvcnRzLnJlc29sdmVQcm9wZXJ0aWVzID0gbGliJDMucmVzb2x2ZVByb3BlcnRpZXM7XG5cdGV4cG9ydHMuc2hhbGxvd0NvcHkgPSBsaWIkMy5zaGFsbG93Q29weTtcblx0dmFyIFJMUCA9IF9faW1wb3J0U3RhcihsaWIkNSk7XG5cdGV4cG9ydHMuUkxQID0gUkxQO1xuXG5cdGV4cG9ydHMuY29tcHV0ZVB1YmxpY0tleSA9IGxpYiRmLmNvbXB1dGVQdWJsaWNLZXk7XG5cdGV4cG9ydHMucmVjb3ZlclB1YmxpY0tleSA9IGxpYiRmLnJlY292ZXJQdWJsaWNLZXk7XG5cdGV4cG9ydHMuU2lnbmluZ0tleSA9IGxpYiRmLlNpZ25pbmdLZXk7XG5cblx0ZXhwb3J0cy5mb3JtYXRCeXRlczMyU3RyaW5nID0gbGliJDguZm9ybWF0Qnl0ZXMzMlN0cmluZztcblx0ZXhwb3J0cy5uYW1lcHJlcCA9IGxpYiQ4Lm5hbWVwcmVwO1xuXHRleHBvcnRzLnBhcnNlQnl0ZXMzMlN0cmluZyA9IGxpYiQ4LnBhcnNlQnl0ZXMzMlN0cmluZztcblx0ZXhwb3J0cy5fdG9Fc2NhcGVkVXRmOFN0cmluZyA9IGxpYiQ4Ll90b0VzY2FwZWRVdGY4U3RyaW5nO1xuXHRleHBvcnRzLnRvVXRmOEJ5dGVzID0gbGliJDgudG9VdGY4Qnl0ZXM7XG5cdGV4cG9ydHMudG9VdGY4Q29kZVBvaW50cyA9IGxpYiQ4LnRvVXRmOENvZGVQb2ludHM7XG5cdGV4cG9ydHMudG9VdGY4U3RyaW5nID0gbGliJDgudG9VdGY4U3RyaW5nO1xuXHRleHBvcnRzLlV0ZjhFcnJvckZ1bmNzID0gbGliJDguVXRmOEVycm9yRnVuY3M7XG5cblx0ZXhwb3J0cy5jb21wdXRlQWRkcmVzcyA9IGxpYiRnLmNvbXB1dGVBZGRyZXNzO1xuXHRleHBvcnRzLnBhcnNlVHJhbnNhY3Rpb24gPSBsaWIkZy5wYXJzZTtcblx0ZXhwb3J0cy5yZWNvdmVyQWRkcmVzcyA9IGxpYiRnLnJlY292ZXJBZGRyZXNzO1xuXHRleHBvcnRzLnNlcmlhbGl6ZVRyYW5zYWN0aW9uID0gbGliJGcuc2VyaWFsaXplO1xuXG5cdGV4cG9ydHMuY29tbWlmeSA9IGxpYiRvLmNvbW1pZnk7XG5cdGV4cG9ydHMuZm9ybWF0RXRoZXIgPSBsaWIkby5mb3JtYXRFdGhlcjtcblx0ZXhwb3J0cy5wYXJzZUV0aGVyID0gbGliJG8ucGFyc2VFdGhlcjtcblx0ZXhwb3J0cy5mb3JtYXRVbml0cyA9IGxpYiRvLmZvcm1hdFVuaXRzO1xuXHRleHBvcnRzLnBhcnNlVW5pdHMgPSBsaWIkby5wYXJzZVVuaXRzO1xuXG5cdGV4cG9ydHMudmVyaWZ5TWVzc2FnZSA9IGxpYiRqLnZlcmlmeU1lc3NhZ2U7XG5cblx0ZXhwb3J0cy5fZmV0Y2hEYXRhID0gbGliJGwuX2ZldGNoRGF0YTtcblx0ZXhwb3J0cy5mZXRjaEpzb24gPSBsaWIkbC5mZXRjaEpzb247XG5cdGV4cG9ydHMucG9sbCA9IGxpYiRsLnBvbGw7XG5cdC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQvLyBFbnVtc1xuXHR2YXIgc2hhMl8yID0gYnJvd3Nlcjtcblx0ZXhwb3J0cy5TdXBwb3J0ZWRBbGdvcml0aG0gPSBzaGEyXzIuU3VwcG9ydGVkQWxnb3JpdGhtO1xuXHR2YXIgc3RyaW5nc18yID0gbGliJDg7XG5cdGV4cG9ydHMuVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtID0gc3RyaW5nc18yLlVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybTtcblx0ZXhwb3J0cy5VdGY4RXJyb3JSZWFzb24gPSBzdHJpbmdzXzIuVXRmOEVycm9yUmVhc29uO1xuXG5cdH0pO1xuXG5cdHZhciB1dGlscyQ0ID0gdW53cmFwRXhwb3J0cyh1dGlscyQzKTtcblx0dmFyIHV0aWxzXzEkMyA9IHV0aWxzJDMuQWJpQ29kZXI7XG5cdHZhciB1dGlsc18yJDEgPSB1dGlscyQzLmNoZWNrUmVzdWx0RXJyb3JzO1xuXHR2YXIgdXRpbHNfMyQxID0gdXRpbHMkMy5kZWZhdWx0QWJpQ29kZXI7XG5cdHZhciB1dGlsc180JDEgPSB1dGlscyQzLkV2ZW50RnJhZ21lbnQ7XG5cdHZhciB1dGlsc181JDEgPSB1dGlscyQzLkZvcm1hdFR5cGVzO1xuXHR2YXIgdXRpbHNfNiA9IHV0aWxzJDMuRnJhZ21lbnQ7XG5cdHZhciB1dGlsc183ID0gdXRpbHMkMy5GdW5jdGlvbkZyYWdtZW50O1xuXHR2YXIgdXRpbHNfOCA9IHV0aWxzJDMuSW5kZXhlZDtcblx0dmFyIHV0aWxzXzkgPSB1dGlscyQzLkludGVyZmFjZTtcblx0dmFyIHV0aWxzXzEwID0gdXRpbHMkMy5Mb2dEZXNjcmlwdGlvbjtcblx0dmFyIHV0aWxzXzExID0gdXRpbHMkMy5QYXJhbVR5cGU7XG5cdHZhciB1dGlsc18xMiA9IHV0aWxzJDMuVHJhbnNhY3Rpb25EZXNjcmlwdGlvbjtcblx0dmFyIHV0aWxzXzEzID0gdXRpbHMkMy5nZXRBZGRyZXNzO1xuXHR2YXIgdXRpbHNfMTQgPSB1dGlscyQzLmdldENyZWF0ZTJBZGRyZXNzO1xuXHR2YXIgdXRpbHNfMTUgPSB1dGlscyQzLmdldENvbnRyYWN0QWRkcmVzcztcblx0dmFyIHV0aWxzXzE2ID0gdXRpbHMkMy5nZXRJY2FwQWRkcmVzcztcblx0dmFyIHV0aWxzXzE3ID0gdXRpbHMkMy5pc0FkZHJlc3M7XG5cdHZhciB1dGlsc18xOCA9IHV0aWxzJDMuYmFzZTY0O1xuXHR2YXIgdXRpbHNfMTkgPSB1dGlscyQzLmJhc2U1ODtcblx0dmFyIHV0aWxzXzIwID0gdXRpbHMkMy5hcnJheWlmeTtcblx0dmFyIHV0aWxzXzIxID0gdXRpbHMkMy5jb25jYXQ7XG5cdHZhciB1dGlsc18yMiA9IHV0aWxzJDMuaGV4RGF0YVNsaWNlO1xuXHR2YXIgdXRpbHNfMjMgPSB1dGlscyQzLmhleERhdGFMZW5ndGg7XG5cdHZhciB1dGlsc18yNCA9IHV0aWxzJDMuaGV4bGlmeTtcblx0dmFyIHV0aWxzXzI1ID0gdXRpbHMkMy5oZXhTdHJpcFplcm9zO1xuXHR2YXIgdXRpbHNfMjYgPSB1dGlscyQzLmhleFZhbHVlO1xuXHR2YXIgdXRpbHNfMjcgPSB1dGlscyQzLmhleFplcm9QYWQ7XG5cdHZhciB1dGlsc18yOCA9IHV0aWxzJDMuaXNCeXRlcztcblx0dmFyIHV0aWxzXzI5ID0gdXRpbHMkMy5pc0J5dGVzTGlrZTtcblx0dmFyIHV0aWxzXzMwID0gdXRpbHMkMy5pc0hleFN0cmluZztcblx0dmFyIHV0aWxzXzMxID0gdXRpbHMkMy5qb2luU2lnbmF0dXJlO1xuXHR2YXIgdXRpbHNfMzIgPSB1dGlscyQzLnplcm9QYWQ7XG5cdHZhciB1dGlsc18zMyA9IHV0aWxzJDMuc3BsaXRTaWduYXR1cmU7XG5cdHZhciB1dGlsc18zNCA9IHV0aWxzJDMuc3RyaXBaZXJvcztcblx0dmFyIHV0aWxzXzM1ID0gdXRpbHMkMy5oYXNoTWVzc2FnZTtcblx0dmFyIHV0aWxzXzM2ID0gdXRpbHMkMy5pZDtcblx0dmFyIHV0aWxzXzM3ID0gdXRpbHMkMy5pc1ZhbGlkTmFtZTtcblx0dmFyIHV0aWxzXzM4ID0gdXRpbHMkMy5uYW1laGFzaDtcblx0dmFyIHV0aWxzXzM5ID0gdXRpbHMkMy5kZWZhdWx0UGF0aDtcblx0dmFyIHV0aWxzXzQwID0gdXRpbHMkMy5lbnRyb3B5VG9NbmVtb25pYztcblx0dmFyIHV0aWxzXzQxID0gdXRpbHMkMy5IRE5vZGU7XG5cdHZhciB1dGlsc180MiA9IHV0aWxzJDMuaXNWYWxpZE1uZW1vbmljO1xuXHR2YXIgdXRpbHNfNDMgPSB1dGlscyQzLm1uZW1vbmljVG9FbnRyb3B5O1xuXHR2YXIgdXRpbHNfNDQgPSB1dGlscyQzLm1uZW1vbmljVG9TZWVkO1xuXHR2YXIgdXRpbHNfNDUgPSB1dGlscyQzLmdldEpzb25XYWxsZXRBZGRyZXNzO1xuXHR2YXIgdXRpbHNfNDYgPSB1dGlscyQzLmtlY2NhazI1Njtcblx0dmFyIHV0aWxzXzQ3ID0gdXRpbHMkMy5Mb2dnZXI7XG5cdHZhciB1dGlsc180OCA9IHV0aWxzJDMuY29tcHV0ZUhtYWM7XG5cdHZhciB1dGlsc180OSA9IHV0aWxzJDMucmlwZW1kMTYwO1xuXHR2YXIgdXRpbHNfNTAgPSB1dGlscyQzLnNoYTI1Njtcblx0dmFyIHV0aWxzXzUxID0gdXRpbHMkMy5zaGE1MTI7XG5cdHZhciB1dGlsc181MiA9IHV0aWxzJDMuc29saWRpdHlLZWNjYWsyNTY7XG5cdHZhciB1dGlsc181MyA9IHV0aWxzJDMuc29saWRpdHlQYWNrO1xuXHR2YXIgdXRpbHNfNTQgPSB1dGlscyQzLnNvbGlkaXR5U2hhMjU2O1xuXHR2YXIgdXRpbHNfNTUgPSB1dGlscyQzLnJhbmRvbUJ5dGVzO1xuXHR2YXIgdXRpbHNfNTYgPSB1dGlscyQzLnNodWZmbGVkO1xuXHR2YXIgdXRpbHNfNTcgPSB1dGlscyQzLmNoZWNrUHJvcGVydGllcztcblx0dmFyIHV0aWxzXzU4ID0gdXRpbHMkMy5kZWVwQ29weTtcblx0dmFyIHV0aWxzXzU5ID0gdXRpbHMkMy5kZWZpbmVSZWFkT25seTtcblx0dmFyIHV0aWxzXzYwID0gdXRpbHMkMy5nZXRTdGF0aWM7XG5cdHZhciB1dGlsc182MSA9IHV0aWxzJDMucmVzb2x2ZVByb3BlcnRpZXM7XG5cdHZhciB1dGlsc182MiA9IHV0aWxzJDMuc2hhbGxvd0NvcHk7XG5cdHZhciB1dGlsc182MyA9IHV0aWxzJDMuUkxQO1xuXHR2YXIgdXRpbHNfNjQgPSB1dGlscyQzLmNvbXB1dGVQdWJsaWNLZXk7XG5cdHZhciB1dGlsc182NSA9IHV0aWxzJDMucmVjb3ZlclB1YmxpY0tleTtcblx0dmFyIHV0aWxzXzY2ID0gdXRpbHMkMy5TaWduaW5nS2V5O1xuXHR2YXIgdXRpbHNfNjcgPSB1dGlscyQzLmZvcm1hdEJ5dGVzMzJTdHJpbmc7XG5cdHZhciB1dGlsc182OCA9IHV0aWxzJDMubmFtZXByZXA7XG5cdHZhciB1dGlsc182OSA9IHV0aWxzJDMucGFyc2VCeXRlczMyU3RyaW5nO1xuXHR2YXIgdXRpbHNfNzAgPSB1dGlscyQzLl90b0VzY2FwZWRVdGY4U3RyaW5nO1xuXHR2YXIgdXRpbHNfNzEgPSB1dGlscyQzLnRvVXRmOEJ5dGVzO1xuXHR2YXIgdXRpbHNfNzIgPSB1dGlscyQzLnRvVXRmOENvZGVQb2ludHM7XG5cdHZhciB1dGlsc183MyA9IHV0aWxzJDMudG9VdGY4U3RyaW5nO1xuXHR2YXIgdXRpbHNfNzQgPSB1dGlscyQzLlV0ZjhFcnJvckZ1bmNzO1xuXHR2YXIgdXRpbHNfNzUgPSB1dGlscyQzLmNvbXB1dGVBZGRyZXNzO1xuXHR2YXIgdXRpbHNfNzYgPSB1dGlscyQzLnBhcnNlVHJhbnNhY3Rpb247XG5cdHZhciB1dGlsc183NyA9IHV0aWxzJDMucmVjb3ZlckFkZHJlc3M7XG5cdHZhciB1dGlsc183OCA9IHV0aWxzJDMuc2VyaWFsaXplVHJhbnNhY3Rpb247XG5cdHZhciB1dGlsc183OSA9IHV0aWxzJDMuY29tbWlmeTtcblx0dmFyIHV0aWxzXzgwID0gdXRpbHMkMy5mb3JtYXRFdGhlcjtcblx0dmFyIHV0aWxzXzgxID0gdXRpbHMkMy5wYXJzZUV0aGVyO1xuXHR2YXIgdXRpbHNfODIgPSB1dGlscyQzLmZvcm1hdFVuaXRzO1xuXHR2YXIgdXRpbHNfODMgPSB1dGlscyQzLnBhcnNlVW5pdHM7XG5cdHZhciB1dGlsc184NCA9IHV0aWxzJDMudmVyaWZ5TWVzc2FnZTtcblx0dmFyIHV0aWxzXzg1ID0gdXRpbHMkMy5fZmV0Y2hEYXRhO1xuXHR2YXIgdXRpbHNfODYgPSB1dGlscyQzLmZldGNoSnNvbjtcblx0dmFyIHV0aWxzXzg3ID0gdXRpbHMkMy5wb2xsO1xuXHR2YXIgdXRpbHNfODggPSB1dGlscyQzLlN1cHBvcnRlZEFsZ29yaXRobTtcblx0dmFyIHV0aWxzXzg5ID0gdXRpbHMkMy5Vbmljb2RlTm9ybWFsaXphdGlvbkZvcm07XG5cdHZhciB1dGlsc185MCA9IHV0aWxzJDMuVXRmOEVycm9yUmVhc29uO1xuXG5cdHZhciBfdmVyc2lvbiRNID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLnZlcnNpb24gPSBcImV0aGVycy81LjAuOFwiO1xuXG5cdH0pO1xuXG5cdHZhciBfdmVyc2lvbiROID0gdW53cmFwRXhwb3J0cyhfdmVyc2lvbiRNKTtcblx0dmFyIF92ZXJzaW9uXzEkbyA9IF92ZXJzaW9uJE0udmVyc2lvbjtcblxuXHR2YXIgZXRoZXJzID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0dmFyIF9faW1wb3J0U3RhciA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcblx0ICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG5cdCAgICB2YXIgcmVzdWx0ID0ge307XG5cdCAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuXHQgICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdH07XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXHRleHBvcnRzLkNvbnRyYWN0ID0gbGliJGQuQ29udHJhY3Q7XG5cdGV4cG9ydHMuQ29udHJhY3RGYWN0b3J5ID0gbGliJGQuQ29udHJhY3RGYWN0b3J5O1xuXG5cdGV4cG9ydHMuQmlnTnVtYmVyID0gbGliJDIuQmlnTnVtYmVyO1xuXHRleHBvcnRzLkZpeGVkTnVtYmVyID0gbGliJDIuRml4ZWROdW1iZXI7XG5cblx0ZXhwb3J0cy5TaWduZXIgPSBsaWIkYy5TaWduZXI7XG5cdGV4cG9ydHMuVm9pZFNpZ25lciA9IGxpYiRjLlZvaWRTaWduZXI7XG5cblx0ZXhwb3J0cy5XYWxsZXQgPSBsaWIkai5XYWxsZXQ7XG5cdHZhciBjb25zdGFudHMgPSBfX2ltcG9ydFN0YXIobGliJDcpO1xuXHRleHBvcnRzLmNvbnN0YW50cyA9IGNvbnN0YW50cztcblx0dmFyIHByb3ZpZGVycyA9IF9faW1wb3J0U3RhcihsaWIkbSk7XG5cdGV4cG9ydHMucHJvdmlkZXJzID0gcHJvdmlkZXJzO1xuXHR2YXIgcHJvdmlkZXJzXzEgPSBsaWIkbTtcblx0ZXhwb3J0cy5nZXREZWZhdWx0UHJvdmlkZXIgPSBwcm92aWRlcnNfMS5nZXREZWZhdWx0UHJvdmlkZXI7XG5cblx0ZXhwb3J0cy5Xb3JkbGlzdCA9IGJyb3dzZXIkNC5Xb3JkbGlzdDtcblx0ZXhwb3J0cy53b3JkbGlzdHMgPSBicm93c2VyJDQud29yZGxpc3RzO1xuXHR2YXIgdXRpbHMgPSBfX2ltcG9ydFN0YXIodXRpbHMkMyk7XG5cdGV4cG9ydHMudXRpbHMgPSB1dGlscztcblxuXHRleHBvcnRzLmVycm9ycyA9IGxpYi5FcnJvckNvZGU7XG5cdC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQvLyBDb21waWxlLVRpbWUgQ29uc3RhbnRzXG5cdC8vIFRoaXMgaXMgZ2VuZXJhdGVkIGJ5IFwibnBtIHJ1biBkaXN0XCJcblxuXHRleHBvcnRzLnZlcnNpb24gPSBfdmVyc2lvbiRNLnZlcnNpb247XG5cdHZhciBsb2dnZXIgPSBuZXcgbGliLkxvZ2dlcihfdmVyc2lvbiRNLnZlcnNpb24pO1xuXHRleHBvcnRzLmxvZ2dlciA9IGxvZ2dlcjtcblxuXHR9KTtcblxuXHR2YXIgZXRoZXJzJDEgPSB1bndyYXBFeHBvcnRzKGV0aGVycyk7XG5cdHZhciBldGhlcnNfMSA9IGV0aGVycy5Db250cmFjdDtcblx0dmFyIGV0aGVyc18yID0gZXRoZXJzLkNvbnRyYWN0RmFjdG9yeTtcblx0dmFyIGV0aGVyc18zID0gZXRoZXJzLkJpZ051bWJlcjtcblx0dmFyIGV0aGVyc180ID0gZXRoZXJzLkZpeGVkTnVtYmVyO1xuXHR2YXIgZXRoZXJzXzUgPSBldGhlcnMuU2lnbmVyO1xuXHR2YXIgZXRoZXJzXzYgPSBldGhlcnMuVm9pZFNpZ25lcjtcblx0dmFyIGV0aGVyc183ID0gZXRoZXJzLldhbGxldDtcblx0dmFyIGV0aGVyc184ID0gZXRoZXJzLmNvbnN0YW50cztcblx0dmFyIGV0aGVyc185ID0gZXRoZXJzLnByb3ZpZGVycztcblx0dmFyIGV0aGVyc18xMCA9IGV0aGVycy5nZXREZWZhdWx0UHJvdmlkZXI7XG5cdHZhciBldGhlcnNfMTEgPSBldGhlcnMuV29yZGxpc3Q7XG5cdHZhciBldGhlcnNfMTIgPSBldGhlcnMud29yZGxpc3RzO1xuXHR2YXIgZXRoZXJzXzEzID0gZXRoZXJzLnV0aWxzO1xuXHR2YXIgZXRoZXJzXzE0ID0gZXRoZXJzLmVycm9ycztcblx0dmFyIGV0aGVyc18xNSA9IGV0aGVycy52ZXJzaW9uO1xuXHR2YXIgZXRoZXJzXzE2ID0gZXRoZXJzLmxvZ2dlcjtcblxuXHR2YXIgbGliJHAgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19pbXBvcnRTdGFyID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuXHQgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcblx0ICAgIHZhciByZXN1bHQgPSB7fTtcblx0ICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG5cdCAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0fTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHQvLyBUbyBtb2RpZnkgdGhpcyBmaWxlLCB5b3UgbXVzdCB1cGRhdGUgLi9hZG1pbi9jbWRzL3VwZGF0ZS1leHBvcnRzLmpzXG5cdHZhciBldGhlcnMkMSA9IF9faW1wb3J0U3RhcihldGhlcnMpO1xuXHRleHBvcnRzLmV0aGVycyA9IGV0aGVycyQxO1xuXHR0cnkge1xuXHQgICAgdmFyIGFueUdsb2JhbCA9IHdpbmRvdztcblx0ICAgIGlmIChhbnlHbG9iYWwuX2V0aGVycyA9PSBudWxsKSB7XG5cdCAgICAgICAgYW55R2xvYmFsLl9ldGhlcnMgPSBldGhlcnMkMTtcblx0ICAgIH1cblx0fVxuXHRjYXRjaCAoZXJyb3IpIHsgfVxuXHR2YXIgZXRoZXJzXzEgPSBldGhlcnM7XG5cdGV4cG9ydHMuU2lnbmVyID0gZXRoZXJzXzEuU2lnbmVyO1xuXHRleHBvcnRzLldhbGxldCA9IGV0aGVyc18xLldhbGxldDtcblx0ZXhwb3J0cy5Wb2lkU2lnbmVyID0gZXRoZXJzXzEuVm9pZFNpZ25lcjtcblx0ZXhwb3J0cy5nZXREZWZhdWx0UHJvdmlkZXIgPSBldGhlcnNfMS5nZXREZWZhdWx0UHJvdmlkZXI7XG5cdGV4cG9ydHMucHJvdmlkZXJzID0gZXRoZXJzXzEucHJvdmlkZXJzO1xuXHRleHBvcnRzLkNvbnRyYWN0ID0gZXRoZXJzXzEuQ29udHJhY3Q7XG5cdGV4cG9ydHMuQ29udHJhY3RGYWN0b3J5ID0gZXRoZXJzXzEuQ29udHJhY3RGYWN0b3J5O1xuXHRleHBvcnRzLkJpZ051bWJlciA9IGV0aGVyc18xLkJpZ051bWJlcjtcblx0ZXhwb3J0cy5GaXhlZE51bWJlciA9IGV0aGVyc18xLkZpeGVkTnVtYmVyO1xuXHRleHBvcnRzLmNvbnN0YW50cyA9IGV0aGVyc18xLmNvbnN0YW50cztcblx0ZXhwb3J0cy5lcnJvcnMgPSBldGhlcnNfMS5lcnJvcnM7XG5cdGV4cG9ydHMubG9nZ2VyID0gZXRoZXJzXzEubG9nZ2VyO1xuXHRleHBvcnRzLnV0aWxzID0gZXRoZXJzXzEudXRpbHM7XG5cdGV4cG9ydHMud29yZGxpc3RzID0gZXRoZXJzXzEud29yZGxpc3RzO1xuXHQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0Ly8gQ29tcGlsZS1UaW1lIENvbnN0YW50c1xuXHRleHBvcnRzLnZlcnNpb24gPSBldGhlcnNfMS52ZXJzaW9uO1xuXHRleHBvcnRzLldvcmRsaXN0ID0gZXRoZXJzXzEuV29yZGxpc3Q7XG5cblx0fSk7XG5cblx0dmFyIGluZGV4JHAgPSB1bndyYXBFeHBvcnRzKGxpYiRwKTtcblx0dmFyIGxpYl8xJHAgPSBsaWIkcC5ldGhlcnM7XG5cdHZhciBsaWJfMiRuID0gbGliJHAuU2lnbmVyO1xuXHR2YXIgbGliXzMkaiA9IGxpYiRwLldhbGxldDtcblx0dmFyIGxpYl80JGUgPSBsaWIkcC5Wb2lkU2lnbmVyO1xuXHR2YXIgbGliXzUkZCA9IGxpYiRwLmdldERlZmF1bHRQcm92aWRlcjtcblx0dmFyIGxpYl82JDggPSBsaWIkcC5wcm92aWRlcnM7XG5cdHZhciBsaWJfNyQ3ID0gbGliJHAuQ29udHJhY3Q7XG5cdHZhciBsaWJfOCQ2ID0gbGliJHAuQ29udHJhY3RGYWN0b3J5O1xuXHR2YXIgbGliXzkkNiA9IGxpYiRwLkJpZ051bWJlcjtcblx0dmFyIGxpYl8xMCQ0ID0gbGliJHAuRml4ZWROdW1iZXI7XG5cdHZhciBsaWJfMTEkMyA9IGxpYiRwLmNvbnN0YW50cztcblx0dmFyIGxpYl8xMiQzID0gbGliJHAuZXJyb3JzO1xuXHR2YXIgbGliXzEzJDMgPSBsaWIkcC5sb2dnZXI7XG5cdHZhciBsaWJfMTQkMiA9IGxpYiRwLnV0aWxzO1xuXHR2YXIgbGliXzE1JDIgPSBsaWIkcC53b3JkbGlzdHM7XG5cdHZhciBsaWJfMTYkMiA9IGxpYiRwLnZlcnNpb247XG5cdHZhciBsaWJfMTckMSA9IGxpYiRwLldvcmRsaXN0O1xuXG5cdGV4cG9ydHMuQmlnTnVtYmVyID0gbGliXzkkNjtcblx0ZXhwb3J0cy5Db250cmFjdCA9IGxpYl83JDc7XG5cdGV4cG9ydHMuQ29udHJhY3RGYWN0b3J5ID0gbGliXzgkNjtcblx0ZXhwb3J0cy5GaXhlZE51bWJlciA9IGxpYl8xMCQ0O1xuXHRleHBvcnRzLlNpZ25lciA9IGxpYl8yJG47XG5cdGV4cG9ydHMuVm9pZFNpZ25lciA9IGxpYl80JGU7XG5cdGV4cG9ydHMuV2FsbGV0ID0gbGliXzMkajtcblx0ZXhwb3J0cy5Xb3JkbGlzdCA9IGxpYl8xNyQxO1xuXHRleHBvcnRzLmNvbnN0YW50cyA9IGxpYl8xMSQzO1xuXHRleHBvcnRzLmRlZmF1bHQgPSBpbmRleCRwO1xuXHRleHBvcnRzLmVycm9ycyA9IGxpYl8xMiQzO1xuXHRleHBvcnRzLmV0aGVycyA9IGxpYl8xJHA7XG5cdGV4cG9ydHMuZ2V0RGVmYXVsdFByb3ZpZGVyID0gbGliXzUkZDtcblx0ZXhwb3J0cy5sb2dnZXIgPSBsaWJfMTMkMztcblx0ZXhwb3J0cy5wcm92aWRlcnMgPSBsaWJfNiQ4O1xuXHRleHBvcnRzLnV0aWxzID0gbGliXzE0JDI7XG5cdGV4cG9ydHMudmVyc2lvbiA9IGxpYl8xNiQyO1xuXHRleHBvcnRzLndvcmRsaXN0cyA9IGxpYl8xNSQyO1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFxQ0E7QUFLQTtBQUNBO0FBVUE7QUFVQTtBQWtHQTtBQVdBO0FBS0E7QUFrREE7QUFJQTtBQUlBO0FBU0E7QUFRQTtBQUtBO0FBd0JBO0FBSUE7QUFJQTtBQVNBO0FBSUE7QUErREE7QUFTQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1Q0E7QUFxRkE7QUFFQTtBQW1DQTtBQWtDQTtBQXdEQTtBQTJCQTtBQW9CQTtBQW1DQTtBQWFBO0FBa0JBO0FBV0E7QUFFQTtBQXNCQTtBQVdBO0FBRUE7QUErQkE7QUFXQTtBQU9BO0FBT0E7QUFLQTtBQUtBO0FBUUE7QUFrQkE7QUFJQTtBQU9BO0FBUUE7QUEwQkE7QUFVQTtBQW9CQTtBQUVBO0FBT0E7QUFRQTtBQUdBO0FBUUE7QUFzQkE7QUFnQkE7QUFXQTtBQVVBO0FBQ0E7QUF3QkE7QUFDQTtBQUNBO0FBOGpCQTtBQVlBO0FBQ0E7QUFzREE7QUFFQTtBQWdCQTtBQWFBO0FBQ0E7QUEwR0E7QUEwREE7QUFPQTtBQU9BO0FBU0E7QUFPQTtBQWlCQTtBQUtBO0FBS0E7QUFLQTtBQWlCQTtBQXdDQTtBQUtBO0FBQ0E7QUFDQTtBQWtCQTtBQVNBO0FBa0JBO0FBY0E7QUFLQTtBQVNBO0FBU0E7QUFPQTtBQUdBO0FBTUE7QUF5QkE7QUFLQTtBQU1BO0FBY0E7QUFPQTtBQWNBO0FBbUJBO0FBbURBO0FBbUJBO0FBVUE7QUF5QkE7QUFDQTtBQXFCQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBOERBO0FBQ0E7QUFRQTtBQXlCQTtBQUtBO0FBU0E7QUFJQTtBQVNBO0FBR0E7QUFnQkE7QUErQkE7QUFJQTtBQThEQTtBQUNBO0FBQ0E7QUE0RUE7QUFnQkE7QUFjQTtBQWFBO0FBS0E7QUFPQTtBQU9BO0FBNkNBO0FBQ0E7QUFDQTtBQUNBO0FBVUE7QUFFQTtBQTREQTtBQUNBO0FBQ0E7QUFDQTtBQTJFQTtBQWFBO0FBYUE7QUFRQTtBQUVBO0FBZ0JBO0FBQ0E7QUFtQkE7QUFHQTtBQXlCQTtBQWVBO0FBbUJBO0FBS0E7QUFTQTtBQTJCQTtBQVNBO0FBZ0JBO0FBRUE7QUFvQkE7QUFDQTtBQUNBO0FBMEdBO0FBTUE7QUFDQTtBQUNBO0FBWUE7QUFDQTtBQW9HQTtBQUNBO0FBRUE7QUF1RUE7QUE4QkE7QUFtQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQTRDQTtBQXlCQTtBQTJKQTtBQXVHQTtBQUtBOzs7Ozs7O0FBcUZBO0FBcUZBO0FBSUE7QUFTQTtBQUVBO0FBWUE7QUFDQTtBQUlBO0FBUUE7QUFVQTtBQTJDQTs7Ozs7O0FBZ0VBO0FBMElBO0FBc0RBO0FBRUE7QUFJQTtBQUVBO0FBRUE7QUFJQTtBQUVBO0FBSUE7QUFHQTtBQUlBO0FBSUE7QUFJQTtBQWdEQTtBQUtBO0FBa0JBO0FBVUE7QUFxQkE7QUFRQTtBQVlBO0FBSUE7QUFvQ0E7QUFvRkE7QUFRQTtBQUtBO0FBR0E7QUFzQkE7QUE0REE7QUFzR0E7QUF5REE7QUFrQkE7QUFDQTtBQUtBO0FBa0dBO0FBb0VBO0FBS0E7QUFFQTtBQVNBO0FBb0ZBO0FBRUE7QUFFQTtBQUVBO0FBaUNBO0FBQ0E7QUFDQTtBQUNBO0FBc0JBO0FBaUdBO0FBTUE7QUFpS0E7QUFPQTtBQVVBO0FBK0xBO0FBbUJBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFPQTtBQTZEQTtBQXVCQTtBQWdDQTtBQXFCQTtBQWdDQTtBQThCQTs7Ozs7OztBQWlCQTtBQWlnQkE7QUE4REE7QUFLQTtBQTZFQTtBQXVCQTtBQVFBO0FBQ0E7QUFRQTtBQU1BO0FBa0JBO0FBS0E7QUFJQTtBQUdBO0FBaUNBO0FBK0ZBO0FBbUZBO0FBRUE7QUFFQTtBQVVBO0FBU0E7QUFFQTtBQVdBO0FBZ0JBO0FBY0E7QUFDQTtBQUVBO0FBV0E7QUFpTUE7QUE4RUE7QUFDQTtBQTJEQTtBQWtEQTtBQVlBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFRQTtBQVdBO0FBQ0E7QUFJQTtBQUlBO0FBS0E7QUFFQTtBQUdBO0FBTUE7QUFRQTtBQUdBO0FBS0E7QUFHQTtBQUlBO0FBS0E7QUFlQTtBQUtBO0FBSUE7QUFVQTtBQUlBO0FBS0E7QUFLQTtBQVNBO0FBdUJBO0FBbUZBO0FBRUE7QUFJQTtBQU1BO0FBT0E7QUFLQTtBQW9FQTtBQXFGQTtBQUNBO0FBQ0E7QUFJQTtBQUdBO0FBT0E7QUFLQTtBQUdBO0FBRUE7QUFNQTtBQU1BO0FBRUE7QUFJQTtBQThJQTtBQXlDQTtBQVNBO0FBb0VBOzs7Ozs7Ozs7Ozs7QUFtSUE7QUFxQkE7QUFTQTtBQUlBO0FBQ0E7QUFJQTtBQWFBO0FBaUJBO0FBTUE7QUFhQTtBQVVBO0FBWUE7QUFPQTtBQVdBO0FBWUE7QUFPQTtBQU9BO0FBZ0JBO0FBV0E7QUFVQTtBQTZCQTtBQU9BO0FBdUJBO0FBMkJBO0FBOEJBO0FBaUJBO0FBNERBO0FBR0E7QUFtQkE7QUFNQTtBQUNBO0FBZUE7QUFDQTtBQU1BO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQW1CQTtBQXVGQTtBQUNBO0FBQ0E7QUFzRUE7QUFDQTtBQU9BO0FBSUE7QUF5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQU1BO0FBQ0E7QUF5QkE7QUFpQkE7QUFpQkE7QUFpREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWUE7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQStDQTtBQUNBO0FBZ0lBO0FBR0E7QUFJQTtBQVlBO0FBZ0JBO0FBZ0NBO0FBRUE7QUFHQTtBQUNBO0FBcUJBO0FBQ0E7QUFDQTtBQUNBO0FBY0E7QUFhQTtBQUlBO0FBV0E7QUF3SkE7QUFTQTtBQXdFQTtBQUlBO0FBT0E7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFzQkE7QUFVQTtBQUNBO0FBc0VBO0FBVUE7QUFDQTtBQU1BO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFlQTtBQWdDQTtBQU9BO0FBT0E7QUFDQTtBQUNBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFrQkE7QUFXQTtBQVFBO0FBUUE7QUFDQTtBQUlBO0FBSUE7QUFJQTtBQUlBO0FBRUE7QUFJQTtBQU1BO0FBWUE7QUFRQTtBQUNBO0FBY0E7QUFVQTtBQUVBO0FBSUE7QUFVQTtBQUlBO0FBTUE7QUEwQ0E7QUFxQ0E7QUFnQ0E7QUFJQTtBQUdBO0FBSUE7QUFJQTtBQVFBO0FBT0E7QUFTQTtBQU9BO0FBRUE7QUFrQkE7QUFJQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvR0E7QUFVQTtBQXdCQTtBQUlBO0FBK0JBO0FBYUE7QUFFQTtBQXNCQTtBQWVBO0FBNFRBO0FBUUE7QUFJQTtBQThCQTtBQTJTQTtBQUlBO0FBRUE7QUFFQTtBQUVBO0FBZ0pBO0FBRUE7QUFTQTtBQUVBO0FBV0E7QUFXQTtBQStCQTtBQVdBO0FBbU1BO0FBS0E7QUFRQTtBQXlCQTtBQXlGQTtBQUlBO0FBS0E7QUFRQTtBQUdBO0FBT0E7QUEwQkE7QUFLQTtBQUNBO0FBVUE7QUFVQTtBQWtHQTtBQVdBO0FBS0E7QUFrREE7QUFJQTtBQUlBO0FBU0E7QUFRQTtBQUtBO0FBd0JBO0FBSUE7QUFJQTtBQVNBO0FBSUE7QUErREE7QUFTQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1Q0E7QUFxRkE7QUFFQTtBQW1DQTtBQWtDQTtBQXdEQTtBQTJCQTtBQW9CQTtBQW1DQTtBQWFBO0FBa0JBO0FBV0E7QUFFQTtBQXNCQTtBQVdBO0FBRUE7QUErQkE7QUFXQTtBQU9BO0FBT0E7QUFLQTtBQUtBO0FBUUE7QUFrQkE7QUFJQTtBQU9BO0FBUUE7QUEwQkE7QUFVQTtBQW9CQTtBQUVBO0FBT0E7QUFRQTtBQUdBO0FBUUE7QUFzQkE7QUFnQkE7QUFXQTtBQVVBO0FBQ0E7QUF3QkE7QUFDQTtBQUNBO0FBOGpCQTtBQVlBO0FBQ0E7QUFzREE7QUFFQTtBQWdCQTtBQWFBO0FBQ0E7QUEwR0E7QUEwREE7QUFPQTtBQU9BO0FBU0E7QUFPQTtBQWlCQTtBQUtBO0FBS0E7QUFLQTtBQWlCQTtBQXdDQTtBQUtBO0FBQ0E7QUFDQTtBQWtCQTtBQVNBO0FBa0JBO0FBY0E7QUFLQTtBQVNBO0FBU0E7QUFPQTtBQUdBO0FBTUE7QUF5QkE7QUFLQTtBQU1BO0FBY0E7QUFPQTtBQWNBO0FBbUJBO0FBbURBO0FBbUJBO0FBVUE7QUF5QkE7QUFDQTtBQXFCQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBOERBO0FBQ0E7QUFRQTtBQXlCQTtBQUtBO0FBU0E7QUFJQTtBQVNBO0FBR0E7QUFnQkE7QUErQkE7QUFJQTtBQThEQTtBQUNBO0FBQ0E7QUE0RUE7QUFnQkE7QUFjQTtBQWFBO0FBS0E7QUFPQTtBQU9BO0FBNkNBO0FBQ0E7QUFDQTtBQUNBO0FBVUE7QUFFQTtBQTREQTtBQUNBO0FBQ0E7QUFDQTtBQTJFQTtBQWFBO0FBYUE7QUFRQTtBQUVBO0FBZ0JBO0FBQ0E7QUFtQkE7QUFHQTtBQXlCQTtBQWVBO0FBbUJBO0FBS0E7QUFTQTtBQTJCQTtBQVNBO0FBZ0JBO0FBRUE7QUFvQkE7QUFDQTtBQUNBO0FBMEdBO0FBTUE7QUFDQTtBQUNBO0FBWUE7QUFDQTtBQW9HQTtBQUNBO0FBRUE7QUF1RUE7QUFrRkE7QUE2QkE7QUFhQTtBQStCQTtBQWdEQTtBQUdBO0FBS0E7QUFJQTtBQVFBO0FBMkJBO0FBMkJBO0FBS0E7QUFHQTtBQUdBO0FBWUE7QUFNQTtBQW1CQTtBQVNBO0FBbUJBO0FBNkVBO0FBOEJBO0FBK0hBO0FBU0E7QUFJQTtBQU9BO0FBT0E7QUFVQTtBQXFCQTtBQUNBO0FBQ0E7QUFhQTtBQUdBO0FBQ0E7QUFRQTtBQUdBO0FBR0E7QUF5Q0E7QUE2QkE7QUFnQkE7QUFDQTtBQTZDQTtBQWlCQTtBQTBHQTtBQUlBO0FBSUE7QUFJQTtBQUlBO0FBZ0JBO0FBdUlBO0FBSUE7QUFJQTtBQTZCQTtBQUlBO0FBSUE7QUEwQ0E7QUFDQTtBQVNBO0FBeUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFHQTtBQUVBO0FBR0E7QUFLQTtBQUVBO0FBRUE7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUdBO0FBRUE7QUFHQTtBQUtBO0FBRUE7QUFFQTtBQVlBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFHQTtBQUVBO0FBRUE7QUFFQTtBQUtBO0FBR0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBR0E7QUFLQTtBQUVBO0FBY0E7QUErQkE7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBS0E7QUFFQTtBQUtBO0FBRUE7QUFPQTtBQUtBO0FBbUJBO0FBTUE7QUFrQ0E7QUFpTEE7QUFRQTtBQXNCQTtBQWdFQTtBQTJCQTtBQXFCQTtBQU9BO0FBNkJBO0FBMENBO0FBeUJBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFhQTtBQUtBO0FBaURBO0FBWUE7QUEwREE7QUFRQTtBQTZCQTtBQUdBO0FBc0NBO0FBT0E7QUFTQTtBQUlBO0FBcUJBO0FBMkNBO0FBSUE7QUFHQTtBQVNBO0FBNEJBO0FBZUE7QUFRQTtBQWFBO0FBRUE7QUFLQTtBQUNBO0FBQ0E7QUFhQTtBQU1BO0FBVUE7QUFDQTtBQXNDQTtBQXVJQTtBQTJDQTtBQUlBO0FBV0E7QUFPQTtBQUdBO0FBTUE7QUFJQTtBQUNBO0FBRUE7QUFPQTtBQTRCQTtBQWNBO0FBS0E7QUErQ0E7QUFhQTtBQUlBO0FBbUVBO0FBa0NBO0FBRUE7QUF1Q0E7QUFHQTtBQUlBOzs7Ozs7QUFpQ0E7QUF3QkE7QUFLQTtBQUtBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXVCQTtBQVVBO0FBRUE7QUFNQTtBQUdBO0FBT0E7QUFFQTtBQTREQTtBQUVBO0FBc0JBO0FBSUE7QUE2REE7QUFLQTtBQUtBO0FBS0E7QUFHQTtBQXNJQTtBQWNBO0FBU0E7QUFnQ0E7QUFLQTtBQThDQTtBQW1CQTtBQUdBO0FBR0E7QUFJQTtBQU1BO0FBTUE7QUF1Q0E7QUFHQTtBQVdBO0FBR0E7QUFRQTtBQVlBO0FBTUE7QUFpQkE7QUFXQTtBQW9CQTtBQU1BO0FBWUE7QUFxQkE7QUFNQTtBQVlBOztBQWdCQTs7QUFxREE7O0FBd0VBO0FBdUNBO0FBdUJBOztBQVVBO0FBb0NBOztBQU1BO0FBTUE7O0FBK0NBO0FBb0NBO0FBSUE7QUFFQTtBQUNBO0FBK0JBO0FBR0E7QUFDQTtBQWlDQTtBQUlBO0FBQ0E7QUFDQSxRQU9BO0FBcURBO0FBUUE7QUFJQTtBQU1BO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQStEQTtBQUlBO0FBRUE7QUFRQTtBQUdBO0FBK0NBO0FBSUE7QUFDQTtBQUNBO0FBbUNBO0FBQ0E7QUE2R0E7QUFVQTtBQU1BO0FBSUE7QUFTQTtBQWNBO0FBQ0E7QUFtRUE7QUErQkE7QUFDQTtBQXVDQTtBQUNBO0FBRUE7QUFLQTtBQUdBO0FBS0E7QUFHQTtBQUdBO0FBQ0E7QUFVQTtBQUlBO0FBQ0E7QUFJQTtBQUdBO0FBR0E7QUFDQTtBQUNBO0FBR0E7QUFLQTtBQVdBO0FBSUE7QUFHQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFJQTtBQWFBO0FBQ0E7QUFpQkE7QUFHQTtBQUlBO0FBSUE7QUFRQTtBQTZCQTtBQUlBO0FBQ0E7QUFDQSxRQU9BO0FBeUZBO0FBcURBO0FBa0JBO0FBQ0E7QUFDQTtBQTBCQTtBQUlBO0FBeURBO0FBSUE7QUFZQTtBQXVCQTtBQVNBO0FBV0E7QUFXQTtBQWFBO0FBQ0E7QUFDQTtBQUdBO0FBR0E7QUFFQTtBQUlBO0FBRUE7QUFzQkE7O0FBbVBBO0FBeUtBOzs7OztBQXVCQTtBQUVBO0FBa0NBO0FBT0E7QUFJQTtBQUNBO0FBVUE7QUFzTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFRQTtBQThHQTtBQUdBO0FBc0RBO0FBR0E7QUFlQTtBQUNBO0FBb0NBO0FBQ0E7QUFDQTtBQUlBO0FBa0NBO0FBc0JBO0FBV0E7QUFzS0E7QUFDQTtBQUlBO0FBSUE7QUFrQ0E7QUFDQTtBQWNBO0FBZ0JBO0FBUUE7QUE4QkE7QUFLQTtBQUlBO0FBQ0E7QUFJQTtBQUlBO0FBSUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBcUJBO0FBV0E7QUFtQkE7QUFvREE7QUFTQTtBQVNBO0FBZ0JBO0FBNEZBO0FBQ0E7QUFXQTtBQU9BO0FBS0E7QUE4Q0E7QUFDQTtBQVNBO0FBQ0E7Ozs7Ozs7Ozs7O0FBWUE7Ozs7Ozs7O0FBNkVBO0FBTUE7QUFJQTtBQUNBO0FBQ0E7QUFPQTtBQUVBO0FBNkNBO0FBQ0E7QUFJQTtBQWlCQTtBQUNBO0FBQ0E7QUFPQTtBQVdBO0FBT0E7QUFJQTtBQUNBO0FBMkJBO0FBWUE7QUF1QkE7QUFFQTtBQUtBO0FBY0E7QUFLQTtBQUlBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBTUE7QUFJQTtBQW9DQTtBQVNBO0FBY0E7QUFDQTtBQXdCQTtBQVFBO0FBQ0E7QUFDQTtBQXlDQTtBQUNBO0FBRUE7QUFDQTtBQUlBO0FBbUNBO0FBYUE7QUFJQTtBQUVBO0FBbUJBO0FBSUE7QUFpSkE7QUFPQTtBQUlBO0FBTUE7QUFDQTtBQUNBO0FBVUE7QUFtTkE7QUFFQTtBQUNBO0FBQ0E7QUFNQTtBQU1BO0FBd0hBO0FBZ0dBO0FBdUJBO0FBS0E7QUFnREE7QUFLQTtBQU1BO0FBb09BO0FBeUVBO0FBQ0E7QUFDQTtBQXdCQTtBQThDQTtBQStDQTtBQWFBO0FBa0tBO0FBSUE7QUFJQTtBQUlBO0FBK0JBO0FBK0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBV0E7Ozs7Ozs7Ozs7Ozs7QUF3R0E7QUFFQTtBQUNBO0FBS0E7QUFZQTtBQStCQTtBQUdBO0FBUUE7QUFDQTtBQUNBO0FBOEhBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQWdCQTtBQU9BO0FBbUNBO0FBQ0E7QUF5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW9CQTtBQUVBO0FBbUJBO0FBd0JBO0FBSUE7QUFDQTtBQUNBO0FBc0NBO0FBQ0E7QUFDQTtBQUNBO0FBaU9BO0FBZ0JBO0FBZUE7QUFRQTtBQU1BO0FBWUE7QUE0SEE7QUFzQkE7QUFJQTtBQUlBO0FBbUNBO0FBOEJBO0FBd0RBO0FBcUlBO0FBQ0E7QUFLQTtBQUtBO0FBZUE7QUFJQTtBQXVDQTtBQWlEQTtBQVNBO0FBUUE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBTUE7QUFJQTtBQU9BO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFJQTtBQVNBO0FBWUE7QUFFQTtBQTJCQTtBQUNBO0FBR0E7QUFDQTtBQVlBO0FBSUE7QUFJQTtBQXVIQTtBQUVBO0FBU0E7QUFvQ0E7QUFPQTtBQWlFQTtBQXdCQTtBQWtCQTtBQXFCQTtBQVVBO0FBQ0E7QUE2SkE7QUFzRUE7QUFFQTtBQStCQTtBQUVBO0FBdUdBO0FBQ0E7QUFLQTtBQUVBO0FBQ0E7QUF3RkE7QUF3Q0E7QUFzREE7QUFDQTtBQU1BO0FBT0E7QUF5TEE7QUFDQTtBQWlKQTtBQUNBO0FBRUE7QUFtQ0E7QUF5QkE7QUFDQTtBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/ethers/dist/ethers.umd.js\n");

/***/ }),

/***/ "./node_modules/jquery/dist/jquery.js":
/*!********************************************!*\
  !*** ./node_modules/jquery/dist/jquery.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*!\n * jQuery JavaScript Library v3.5.1\n * https://jquery.com/\n *\n * Includes Sizzle.js\n * https://sizzlejs.com/\n *\n * Copyright JS Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n *\n * Date: 2020-05-04T22:49Z\n */\n(function (global, factory) {\n  \"use strict\";\n\n  if (( false ? undefined : _typeof(module)) === \"object\" && _typeof(module.exports) === \"object\") {\n    // For CommonJS and CommonJS-like environments where a proper `window`\n    // is present, execute the factory and get jQuery.\n    // For environments that do not have a `window` with a `document`\n    // (such as Node.js), expose a factory as module.exports.\n    // This accentuates the need for the creation of a real `window`.\n    // e.g. var jQuery = require(\"jquery\")(window);\n    // See ticket #14549 for more info.\n    module.exports = global.document ? factory(global, true) : function (w) {\n      if (!w.document) {\n        throw new Error(\"jQuery requires a window with a document\");\n      }\n\n      return factory(w);\n    };\n  } else {\n    factory(global);\n  } // Pass this if window is not defined yet\n\n})(typeof window !== \"undefined\" ? window : this, function (window, noGlobal) {\n  // Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1\n  // throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode\n  // arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common\n  // enough that all such attempts are guarded in a try block.\n  \"use strict\";\n\n  var arr = [];\n  var getProto = Object.getPrototypeOf;\n  var _slice = arr.slice;\n  var flat = arr.flat ? function (array) {\n    return arr.flat.call(array);\n  } : function (array) {\n    return arr.concat.apply([], array);\n  };\n  var push = arr.push;\n  var indexOf = arr.indexOf;\n  var class2type = {};\n  var toString = class2type.toString;\n  var hasOwn = class2type.hasOwnProperty;\n  var fnToString = hasOwn.toString;\n  var ObjectFunctionString = fnToString.call(Object);\n  var support = {};\n\n  var isFunction = function isFunction(obj) {\n    // Support: Chrome <=57, Firefox <=52\n    // In some browsers, typeof returns \"function\" for HTML <object> elements\n    // (i.e., `typeof document.createElement( \"object\" ) === \"function\"`).\n    // We don't want to classify *any* DOM node as a function.\n    return typeof obj === \"function\" && typeof obj.nodeType !== \"number\";\n  };\n\n  var isWindow = function isWindow(obj) {\n    return obj != null && obj === obj.window;\n  };\n\n  var document = window.document;\n  var preservedScriptAttributes = {\n    type: true,\n    src: true,\n    nonce: true,\n    noModule: true\n  };\n\n  function DOMEval(code, node, doc) {\n    doc = doc || document;\n    var i,\n        val,\n        script = doc.createElement(\"script\");\n    script.text = code;\n\n    if (node) {\n      for (i in preservedScriptAttributes) {\n        // Support: Firefox 64+, Edge 18+\n        // Some browsers don't support the \"nonce\" property on scripts.\n        // On the other hand, just using `getAttribute` is not enough as\n        // the `nonce` attribute is reset to an empty string whenever it\n        // becomes browsing-context connected.\n        // See https://github.com/whatwg/html/issues/2369\n        // See https://html.spec.whatwg.org/#nonce-attributes\n        // The `node.getAttribute` check was added for the sake of\n        // `jQuery.globalEval` so that it can fake a nonce-containing node\n        // via an object.\n        val = node[i] || node.getAttribute && node.getAttribute(i);\n\n        if (val) {\n          script.setAttribute(i, val);\n        }\n      }\n    }\n\n    doc.head.appendChild(script).parentNode.removeChild(script);\n  }\n\n  function toType(obj) {\n    if (obj == null) {\n      return obj + \"\";\n    } // Support: Android <=2.3 only (functionish RegExp)\n\n\n    return _typeof(obj) === \"object\" || typeof obj === \"function\" ? class2type[toString.call(obj)] || \"object\" : _typeof(obj);\n  }\n  /* global Symbol */\n  // Defining this global in .eslintrc.json would create a danger of using the global\n  // unguarded in another place, it seems safer to define global only for this module\n\n\n  var version = \"3.5.1\",\n      // Define a local copy of jQuery\n  jQuery = function jQuery(selector, context) {\n    // The jQuery object is actually just the init constructor 'enhanced'\n    // Need init if jQuery is called (just allow error to be thrown if not included)\n    return new jQuery.fn.init(selector, context);\n  };\n\n  jQuery.fn = jQuery.prototype = {\n    // The current version of jQuery being used\n    jquery: version,\n    constructor: jQuery,\n    // The default length of a jQuery object is 0\n    length: 0,\n    toArray: function toArray() {\n      return _slice.call(this);\n    },\n    // Get the Nth element in the matched element set OR\n    // Get the whole matched element set as a clean array\n    get: function get(num) {\n      // Return all the elements in a clean array\n      if (num == null) {\n        return _slice.call(this);\n      } // Return just the one element from the set\n\n\n      return num < 0 ? this[num + this.length] : this[num];\n    },\n    // Take an array of elements and push it onto the stack\n    // (returning the new matched element set)\n    pushStack: function pushStack(elems) {\n      // Build a new jQuery matched element set\n      var ret = jQuery.merge(this.constructor(), elems); // Add the old object onto the stack (as a reference)\n\n      ret.prevObject = this; // Return the newly-formed element set\n\n      return ret;\n    },\n    // Execute a callback for every element in the matched set.\n    each: function each(callback) {\n      return jQuery.each(this, callback);\n    },\n    map: function map(callback) {\n      return this.pushStack(jQuery.map(this, function (elem, i) {\n        return callback.call(elem, i, elem);\n      }));\n    },\n    slice: function slice() {\n      return this.pushStack(_slice.apply(this, arguments));\n    },\n    first: function first() {\n      return this.eq(0);\n    },\n    last: function last() {\n      return this.eq(-1);\n    },\n    even: function even() {\n      return this.pushStack(jQuery.grep(this, function (_elem, i) {\n        return (i + 1) % 2;\n      }));\n    },\n    odd: function odd() {\n      return this.pushStack(jQuery.grep(this, function (_elem, i) {\n        return i % 2;\n      }));\n    },\n    eq: function eq(i) {\n      var len = this.length,\n          j = +i + (i < 0 ? len : 0);\n      return this.pushStack(j >= 0 && j < len ? [this[j]] : []);\n    },\n    end: function end() {\n      return this.prevObject || this.constructor();\n    },\n    // For internal use only.\n    // Behaves like an Array's method, not like a jQuery method.\n    push: push,\n    sort: arr.sort,\n    splice: arr.splice\n  };\n\n  jQuery.extend = jQuery.fn.extend = function () {\n    var options,\n        name,\n        src,\n        copy,\n        copyIsArray,\n        clone,\n        target = arguments[0] || {},\n        i = 1,\n        length = arguments.length,\n        deep = false; // Handle a deep copy situation\n\n    if (typeof target === \"boolean\") {\n      deep = target; // Skip the boolean and the target\n\n      target = arguments[i] || {};\n      i++;\n    } // Handle case when target is a string or something (possible in deep copy)\n\n\n    if (_typeof(target) !== \"object\" && !isFunction(target)) {\n      target = {};\n    } // Extend jQuery itself if only one argument is passed\n\n\n    if (i === length) {\n      target = this;\n      i--;\n    }\n\n    for (; i < length; i++) {\n      // Only deal with non-null/undefined values\n      if ((options = arguments[i]) != null) {\n        // Extend the base object\n        for (name in options) {\n          copy = options[name]; // Prevent Object.prototype pollution\n          // Prevent never-ending loop\n\n          if (name === \"__proto__\" || target === copy) {\n            continue;\n          } // Recurse if we're merging plain objects or arrays\n\n\n          if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {\n            src = target[name]; // Ensure proper type for the source value\n\n            if (copyIsArray && !Array.isArray(src)) {\n              clone = [];\n            } else if (!copyIsArray && !jQuery.isPlainObject(src)) {\n              clone = {};\n            } else {\n              clone = src;\n            }\n\n            copyIsArray = false; // Never move original objects, clone them\n\n            target[name] = jQuery.extend(deep, clone, copy); // Don't bring in undefined values\n          } else if (copy !== undefined) {\n            target[name] = copy;\n          }\n        }\n      }\n    } // Return the modified object\n\n\n    return target;\n  };\n\n  jQuery.extend({\n    // Unique for each copy of jQuery on the page\n    expando: \"jQuery\" + (version + Math.random()).replace(/\\D/g, \"\"),\n    // Assume jQuery is ready without the ready module\n    isReady: true,\n    error: function error(msg) {\n      throw new Error(msg);\n    },\n    noop: function noop() {},\n    isPlainObject: function isPlainObject(obj) {\n      var proto, Ctor; // Detect obvious negatives\n      // Use toString instead of jQuery.type to catch host objects\n\n      if (!obj || toString.call(obj) !== \"[object Object]\") {\n        return false;\n      }\n\n      proto = getProto(obj); // Objects with no prototype (e.g., `Object.create( null )`) are plain\n\n      if (!proto) {\n        return true;\n      } // Objects with prototype are plain iff they were constructed by a global Object function\n\n\n      Ctor = hasOwn.call(proto, \"constructor\") && proto.constructor;\n      return typeof Ctor === \"function\" && fnToString.call(Ctor) === ObjectFunctionString;\n    },\n    isEmptyObject: function isEmptyObject(obj) {\n      var name;\n\n      for (name in obj) {\n        return false;\n      }\n\n      return true;\n    },\n    // Evaluates a script in a provided context; falls back to the global one\n    // if not specified.\n    globalEval: function globalEval(code, options, doc) {\n      DOMEval(code, {\n        nonce: options && options.nonce\n      }, doc);\n    },\n    each: function each(obj, callback) {\n      var length,\n          i = 0;\n\n      if (isArrayLike(obj)) {\n        length = obj.length;\n\n        for (; i < length; i++) {\n          if (callback.call(obj[i], i, obj[i]) === false) {\n            break;\n          }\n        }\n      } else {\n        for (i in obj) {\n          if (callback.call(obj[i], i, obj[i]) === false) {\n            break;\n          }\n        }\n      }\n\n      return obj;\n    },\n    // results is for internal usage only\n    makeArray: function makeArray(arr, results) {\n      var ret = results || [];\n\n      if (arr != null) {\n        if (isArrayLike(Object(arr))) {\n          jQuery.merge(ret, typeof arr === \"string\" ? [arr] : arr);\n        } else {\n          push.call(ret, arr);\n        }\n      }\n\n      return ret;\n    },\n    inArray: function inArray(elem, arr, i) {\n      return arr == null ? -1 : indexOf.call(arr, elem, i);\n    },\n    // Support: Android <=4.0 only, PhantomJS 1 only\n    // push.apply(_, arraylike) throws on ancient WebKit\n    merge: function merge(first, second) {\n      var len = +second.length,\n          j = 0,\n          i = first.length;\n\n      for (; j < len; j++) {\n        first[i++] = second[j];\n      }\n\n      first.length = i;\n      return first;\n    },\n    grep: function grep(elems, callback, invert) {\n      var callbackInverse,\n          matches = [],\n          i = 0,\n          length = elems.length,\n          callbackExpect = !invert; // Go through the array, only saving the items\n      // that pass the validator function\n\n      for (; i < length; i++) {\n        callbackInverse = !callback(elems[i], i);\n\n        if (callbackInverse !== callbackExpect) {\n          matches.push(elems[i]);\n        }\n      }\n\n      return matches;\n    },\n    // arg is for internal usage only\n    map: function map(elems, callback, arg) {\n      var length,\n          value,\n          i = 0,\n          ret = []; // Go through the array, translating each of the items to their new values\n\n      if (isArrayLike(elems)) {\n        length = elems.length;\n\n        for (; i < length; i++) {\n          value = callback(elems[i], i, arg);\n\n          if (value != null) {\n            ret.push(value);\n          }\n        } // Go through every key on the object,\n\n      } else {\n        for (i in elems) {\n          value = callback(elems[i], i, arg);\n\n          if (value != null) {\n            ret.push(value);\n          }\n        }\n      } // Flatten any nested arrays\n\n\n      return flat(ret);\n    },\n    // A global GUID counter for objects\n    guid: 1,\n    // jQuery.support is not used in Core but other projects attach their\n    // properties to it so it needs to exist.\n    support: support\n  });\n\n  if (typeof Symbol === \"function\") {\n    jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];\n  } // Populate the class2type map\n\n\n  jQuery.each(\"Boolean Number String Function Array Date RegExp Object Error Symbol\".split(\" \"), function (_i, name) {\n    class2type[\"[object \" + name + \"]\"] = name.toLowerCase();\n  });\n\n  function isArrayLike(obj) {\n    // Support: real iOS 8.2 only (not reproducible in simulator)\n    // `in` check used to prevent JIT error (gh-2145)\n    // hasOwn isn't used here due to false negatives\n    // regarding Nodelist length in IE\n    var length = !!obj && \"length\" in obj && obj.length,\n        type = toType(obj);\n\n    if (isFunction(obj) || isWindow(obj)) {\n      return false;\n    }\n\n    return type === \"array\" || length === 0 || typeof length === \"number\" && length > 0 && length - 1 in obj;\n  }\n\n  var Sizzle =\n  /*!\n   * Sizzle CSS Selector Engine v2.3.5\n   * https://sizzlejs.com/\n   *\n   * Copyright JS Foundation and other contributors\n   * Released under the MIT license\n   * https://js.foundation/\n   *\n   * Date: 2020-03-14\n   */\n  function (window) {\n    var i,\n        support,\n        Expr,\n        getText,\n        isXML,\n        tokenize,\n        compile,\n        select,\n        outermostContext,\n        sortInput,\n        hasDuplicate,\n        // Local document vars\n    setDocument,\n        document,\n        docElem,\n        documentIsHTML,\n        rbuggyQSA,\n        rbuggyMatches,\n        matches,\n        contains,\n        // Instance-specific data\n    expando = \"sizzle\" + 1 * new Date(),\n        preferredDoc = window.document,\n        dirruns = 0,\n        done = 0,\n        classCache = createCache(),\n        tokenCache = createCache(),\n        compilerCache = createCache(),\n        nonnativeSelectorCache = createCache(),\n        sortOrder = function sortOrder(a, b) {\n      if (a === b) {\n        hasDuplicate = true;\n      }\n\n      return 0;\n    },\n        // Instance methods\n    hasOwn = {}.hasOwnProperty,\n        arr = [],\n        pop = arr.pop,\n        pushNative = arr.push,\n        push = arr.push,\n        slice = arr.slice,\n        // Use a stripped-down indexOf as it's faster than native\n    // https://jsperf.com/thor-indexof-vs-for/5\n    indexOf = function indexOf(list, elem) {\n      var i = 0,\n          len = list.length;\n\n      for (; i < len; i++) {\n        if (list[i] === elem) {\n          return i;\n        }\n      }\n\n      return -1;\n    },\n        booleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|\" + \"ismap|loop|multiple|open|readonly|required|scoped\",\n        // Regular expressions\n    // http://www.w3.org/TR/css3-selectors/#whitespace\n    whitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n        // https://www.w3.org/TR/css-syntax-3/#ident-token-diagram\n    identifier = \"(?:\\\\\\\\[\\\\da-fA-F]{1,6}\" + whitespace + \"?|\\\\\\\\[^\\\\r\\\\n\\\\f]|[\\\\w-]|[^\\0-\\\\x7f])+\",\n        // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n    attributes = \"\\\\[\" + whitespace + \"*(\" + identifier + \")(?:\" + whitespace + // Operator (capture 2)\n    \"*([*^$|!~]?=)\" + whitespace + // \"Attribute values must be CSS identifiers [capture 5]\n    // or strings [capture 3 or capture 4]\"\n    \"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" + whitespace + \"*\\\\]\",\n        pseudos = \":(\" + identifier + \")(?:\\\\((\" + // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n    // 1. quoted (capture 3; capture 4 or capture 5)\n    \"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" + // 2. simple (capture 6)\n    \"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" + // 3. anything else (capture 2)\n    \".*\" + \")\\\\)|)\",\n        // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n    rwhitespace = new RegExp(whitespace + \"+\", \"g\"),\n        rtrim = new RegExp(\"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\"),\n        rcomma = new RegExp(\"^\" + whitespace + \"*,\" + whitespace + \"*\"),\n        rcombinators = new RegExp(\"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\"),\n        rdescend = new RegExp(whitespace + \"|>\"),\n        rpseudo = new RegExp(pseudos),\n        ridentifier = new RegExp(\"^\" + identifier + \"$\"),\n        matchExpr = {\n      \"ID\": new RegExp(\"^#(\" + identifier + \")\"),\n      \"CLASS\": new RegExp(\"^\\\\.(\" + identifier + \")\"),\n      \"TAG\": new RegExp(\"^(\" + identifier + \"|[*])\"),\n      \"ATTR\": new RegExp(\"^\" + attributes),\n      \"PSEUDO\": new RegExp(\"^\" + pseudos),\n      \"CHILD\": new RegExp(\"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace + \"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace + \"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\"),\n      \"bool\": new RegExp(\"^(?:\" + booleans + \")$\", \"i\"),\n      // For use in libraries implementing .is()\n      // We use this for POS matching in `select`\n      \"needsContext\": new RegExp(\"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" + whitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\")\n    },\n        rhtml = /HTML$/i,\n        rinputs = /^(?:input|select|textarea|button)$/i,\n        rheader = /^h\\d$/i,\n        rnative = /^[^{]+\\{\\s*\\[native \\w/,\n        // Easily-parseable/retrievable ID or TAG or CLASS selectors\n    rquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n        rsibling = /[+~]/,\n        // CSS escapes\n    // http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n    runescape = new RegExp(\"\\\\\\\\[\\\\da-fA-F]{1,6}\" + whitespace + \"?|\\\\\\\\([^\\\\r\\\\n\\\\f])\", \"g\"),\n        funescape = function funescape(escape, nonHex) {\n      var high = \"0x\" + escape.slice(1) - 0x10000;\n      return nonHex ? // Strip the backslash prefix from a non-hex escape sequence\n      nonHex : // Replace a hexadecimal escape sequence with the encoded Unicode code point\n      // Support: IE <=11+\n      // For values outside the Basic Multilingual Plane (BMP), manually construct a\n      // surrogate pair\n      high < 0 ? String.fromCharCode(high + 0x10000) : String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);\n    },\n        // CSS string/identifier serialization\n    // https://drafts.csswg.org/cssom/#common-serializing-idioms\n    rcssescape = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,\n        fcssescape = function fcssescape(ch, asCodePoint) {\n      if (asCodePoint) {\n        // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n        if (ch === \"\\0\") {\n          return \"\\uFFFD\";\n        } // Control characters and (dependent upon position) numbers get escaped as code points\n\n\n        return ch.slice(0, -1) + \"\\\\\" + ch.charCodeAt(ch.length - 1).toString(16) + \" \";\n      } // Other potentially-special ASCII characters get backslash-escaped\n\n\n      return \"\\\\\" + ch;\n    },\n        // Used for iframes\n    // See setDocument()\n    // Removing the function wrapper causes a \"Permission Denied\"\n    // error in IE\n    unloadHandler = function unloadHandler() {\n      setDocument();\n    },\n        inDisabledFieldset = addCombinator(function (elem) {\n      return elem.disabled === true && elem.nodeName.toLowerCase() === \"fieldset\";\n    }, {\n      dir: \"parentNode\",\n      next: \"legend\"\n    }); // Optimize for push.apply( _, NodeList )\n\n\n    try {\n      push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes); // Support: Android<4.0\n      // Detect silently failing push.apply\n      // eslint-disable-next-line no-unused-expressions\n\n      arr[preferredDoc.childNodes.length].nodeType;\n    } catch (e) {\n      push = {\n        apply: arr.length ? // Leverage slice if possible\n        function (target, els) {\n          pushNative.apply(target, slice.call(els));\n        } : // Support: IE<9\n        // Otherwise append directly\n        function (target, els) {\n          var j = target.length,\n              i = 0; // Can't trust NodeList.length\n\n          while (target[j++] = els[i++]) {}\n\n          target.length = j - 1;\n        }\n      };\n    }\n\n    function Sizzle(selector, context, results, seed) {\n      var m,\n          i,\n          elem,\n          nid,\n          match,\n          groups,\n          newSelector,\n          newContext = context && context.ownerDocument,\n          // nodeType defaults to 9, since context defaults to document\n      nodeType = context ? context.nodeType : 9;\n      results = results || []; // Return early from calls with invalid selector or context\n\n      if (typeof selector !== \"string\" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {\n        return results;\n      } // Try to shortcut find operations (as opposed to filters) in HTML documents\n\n\n      if (!seed) {\n        setDocument(context);\n        context = context || document;\n\n        if (documentIsHTML) {\n          // If the selector is sufficiently simple, try using a \"get*By*\" DOM method\n          // (excepting DocumentFragment context, where the methods don't exist)\n          if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {\n            // ID selector\n            if (m = match[1]) {\n              // Document context\n              if (nodeType === 9) {\n                if (elem = context.getElementById(m)) {\n                  // Support: IE, Opera, Webkit\n                  // TODO: identify versions\n                  // getElementById can match elements by name instead of ID\n                  if (elem.id === m) {\n                    results.push(elem);\n                    return results;\n                  }\n                } else {\n                  return results;\n                } // Element context\n\n              } else {\n                // Support: IE, Opera, Webkit\n                // TODO: identify versions\n                // getElementById can match elements by name instead of ID\n                if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {\n                  results.push(elem);\n                  return results;\n                }\n              } // Type selector\n\n            } else if (match[2]) {\n              push.apply(results, context.getElementsByTagName(selector));\n              return results; // Class selector\n            } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {\n              push.apply(results, context.getElementsByClassName(m));\n              return results;\n            }\n          } // Take advantage of querySelectorAll\n\n\n          if (support.qsa && !nonnativeSelectorCache[selector + \" \"] && (!rbuggyQSA || !rbuggyQSA.test(selector)) && ( // Support: IE 8 only\n          // Exclude object elements\n          nodeType !== 1 || context.nodeName.toLowerCase() !== \"object\")) {\n            newSelector = selector;\n            newContext = context; // qSA considers elements outside a scoping root when evaluating child or\n            // descendant combinators, which is not what we want.\n            // In such cases, we work around the behavior by prefixing every selector in the\n            // list with an ID selector referencing the scope context.\n            // The technique has to be used as well when a leading combinator is used\n            // as such selectors are not recognized by querySelectorAll.\n            // Thanks to Andrew Dupont for this technique.\n\n            if (nodeType === 1 && (rdescend.test(selector) || rcombinators.test(selector))) {\n              // Expand context for sibling selectors\n              newContext = rsibling.test(selector) && testContext(context.parentNode) || context; // We can use :scope instead of the ID hack if the browser\n              // supports it & if we're not changing the context.\n\n              if (newContext !== context || !support.scope) {\n                // Capture the context ID, setting it first if necessary\n                if (nid = context.getAttribute(\"id\")) {\n                  nid = nid.replace(rcssescape, fcssescape);\n                } else {\n                  context.setAttribute(\"id\", nid = expando);\n                }\n              } // Prefix every selector in the list\n\n\n              groups = tokenize(selector);\n              i = groups.length;\n\n              while (i--) {\n                groups[i] = (nid ? \"#\" + nid : \":scope\") + \" \" + toSelector(groups[i]);\n              }\n\n              newSelector = groups.join(\",\");\n            }\n\n            try {\n              push.apply(results, newContext.querySelectorAll(newSelector));\n              return results;\n            } catch (qsaError) {\n              nonnativeSelectorCache(selector, true);\n            } finally {\n              if (nid === expando) {\n                context.removeAttribute(\"id\");\n              }\n            }\n          }\n        }\n      } // All others\n\n\n      return select(selector.replace(rtrim, \"$1\"), context, results, seed);\n    }\n    /**\n     * Create key-value caches of limited size\n     * @returns {function(string, object)} Returns the Object data after storing it on itself with\n     *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n     *\tdeleting the oldest entry\n     */\n\n\n    function createCache() {\n      var keys = [];\n\n      function cache(key, value) {\n        // Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n        if (keys.push(key + \" \") > Expr.cacheLength) {\n          // Only keep the most recent entries\n          delete cache[keys.shift()];\n        }\n\n        return cache[key + \" \"] = value;\n      }\n\n      return cache;\n    }\n    /**\n     * Mark a function for special use by Sizzle\n     * @param {Function} fn The function to mark\n     */\n\n\n    function markFunction(fn) {\n      fn[expando] = true;\n      return fn;\n    }\n    /**\n     * Support testing using an element\n     * @param {Function} fn Passed the created element and returns a boolean result\n     */\n\n\n    function assert(fn) {\n      var el = document.createElement(\"fieldset\");\n\n      try {\n        return !!fn(el);\n      } catch (e) {\n        return false;\n      } finally {\n        // Remove from its parent by default\n        if (el.parentNode) {\n          el.parentNode.removeChild(el);\n        } // release memory in IE\n\n\n        el = null;\n      }\n    }\n    /**\n     * Adds the same handler for all of the specified attrs\n     * @param {String} attrs Pipe-separated list of attributes\n     * @param {Function} handler The method that will be applied\n     */\n\n\n    function addHandle(attrs, handler) {\n      var arr = attrs.split(\"|\"),\n          i = arr.length;\n\n      while (i--) {\n        Expr.attrHandle[arr[i]] = handler;\n      }\n    }\n    /**\n     * Checks document order of two siblings\n     * @param {Element} a\n     * @param {Element} b\n     * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n     */\n\n\n    function siblingCheck(a, b) {\n      var cur = b && a,\n          diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex; // Use IE sourceIndex if available on both nodes\n\n      if (diff) {\n        return diff;\n      } // Check if b follows a\n\n\n      if (cur) {\n        while (cur = cur.nextSibling) {\n          if (cur === b) {\n            return -1;\n          }\n        }\n      }\n\n      return a ? 1 : -1;\n    }\n    /**\n     * Returns a function to use in pseudos for input types\n     * @param {String} type\n     */\n\n\n    function createInputPseudo(type) {\n      return function (elem) {\n        var name = elem.nodeName.toLowerCase();\n        return name === \"input\" && elem.type === type;\n      };\n    }\n    /**\n     * Returns a function to use in pseudos for buttons\n     * @param {String} type\n     */\n\n\n    function createButtonPseudo(type) {\n      return function (elem) {\n        var name = elem.nodeName.toLowerCase();\n        return (name === \"input\" || name === \"button\") && elem.type === type;\n      };\n    }\n    /**\n     * Returns a function to use in pseudos for :enabled/:disabled\n     * @param {Boolean} disabled true for :disabled; false for :enabled\n     */\n\n\n    function createDisabledPseudo(disabled) {\n      // Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\n      return function (elem) {\n        // Only certain elements can match :enabled or :disabled\n        // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\n        // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\n        if (\"form\" in elem) {\n          // Check for inherited disabledness on relevant non-disabled elements:\n          // * listed form-associated elements in a disabled fieldset\n          //   https://html.spec.whatwg.org/multipage/forms.html#category-listed\n          //   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\n          // * option elements in a disabled optgroup\n          //   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\n          // All such elements have a \"form\" property.\n          if (elem.parentNode && elem.disabled === false) {\n            // Option elements defer to a parent optgroup if present\n            if (\"label\" in elem) {\n              if (\"label\" in elem.parentNode) {\n                return elem.parentNode.disabled === disabled;\n              } else {\n                return elem.disabled === disabled;\n              }\n            } // Support: IE 6 - 11\n            // Use the isDisabled shortcut property to check for disabled fieldset ancestors\n\n\n            return elem.isDisabled === disabled || // Where there is no isDisabled, check manually\n\n            /* jshint -W018 */\n            elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;\n          }\n\n          return elem.disabled === disabled; // Try to winnow out elements that can't be disabled before trusting the disabled property.\n          // Some victims get caught in our net (label, legend, menu, track), but it shouldn't\n          // even exist on them, let alone have a boolean value.\n        } else if (\"label\" in elem) {\n          return elem.disabled === disabled;\n        } // Remaining elements are neither :enabled nor :disabled\n\n\n        return false;\n      };\n    }\n    /**\n     * Returns a function to use in pseudos for positionals\n     * @param {Function} fn\n     */\n\n\n    function createPositionalPseudo(fn) {\n      return markFunction(function (argument) {\n        argument = +argument;\n        return markFunction(function (seed, matches) {\n          var j,\n              matchIndexes = fn([], seed.length, argument),\n              i = matchIndexes.length; // Match elements found at the specified indexes\n\n          while (i--) {\n            if (seed[j = matchIndexes[i]]) {\n              seed[j] = !(matches[j] = seed[j]);\n            }\n          }\n        });\n      });\n    }\n    /**\n     * Checks a node for validity as a Sizzle context\n     * @param {Element|Object=} context\n     * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n     */\n\n\n    function testContext(context) {\n      return context && typeof context.getElementsByTagName !== \"undefined\" && context;\n    } // Expose support vars for convenience\n\n\n    support = Sizzle.support = {};\n    /**\n     * Detects XML nodes\n     * @param {Element|Object} elem An element or a document\n     * @returns {Boolean} True iff elem is a non-HTML XML node\n     */\n\n    isXML = Sizzle.isXML = function (elem) {\n      var namespace = elem.namespaceURI,\n          docElem = (elem.ownerDocument || elem).documentElement; // Support: IE <=8\n      // Assume HTML when documentElement doesn't yet exist, such as inside loading iframes\n      // https://bugs.jquery.com/ticket/4833\n\n      return !rhtml.test(namespace || docElem && docElem.nodeName || \"HTML\");\n    };\n    /**\n     * Sets document-related variables once based on the current document\n     * @param {Element|Object} [doc] An element or document object to use to set the document\n     * @returns {Object} Returns the current document\n     */\n\n\n    setDocument = Sizzle.setDocument = function (node) {\n      var hasCompare,\n          subWindow,\n          doc = node ? node.ownerDocument || node : preferredDoc; // Return early if doc is invalid or already selected\n      // Support: IE 11+, Edge 17 - 18+\n      // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n      // two documents; shallow comparisons work.\n      // eslint-disable-next-line eqeqeq\n\n      if (doc == document || doc.nodeType !== 9 || !doc.documentElement) {\n        return document;\n      } // Update global variables\n\n\n      document = doc;\n      docElem = document.documentElement;\n      documentIsHTML = !isXML(document); // Support: IE 9 - 11+, Edge 12 - 18+\n      // Accessing iframe documents after unload throws \"permission denied\" errors (jQuery #13936)\n      // Support: IE 11+, Edge 17 - 18+\n      // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n      // two documents; shallow comparisons work.\n      // eslint-disable-next-line eqeqeq\n\n      if (preferredDoc != document && (subWindow = document.defaultView) && subWindow.top !== subWindow) {\n        // Support: IE 11, Edge\n        if (subWindow.addEventListener) {\n          subWindow.addEventListener(\"unload\", unloadHandler, false); // Support: IE 9 - 10 only\n        } else if (subWindow.attachEvent) {\n          subWindow.attachEvent(\"onunload\", unloadHandler);\n        }\n      } // Support: IE 8 - 11+, Edge 12 - 18+, Chrome <=16 - 25 only, Firefox <=3.6 - 31 only,\n      // Safari 4 - 5 only, Opera <=11.6 - 12.x only\n      // IE/Edge & older browsers don't support the :scope pseudo-class.\n      // Support: Safari 6.0 only\n      // Safari 6.0 supports :scope but it's an alias of :root there.\n\n\n      support.scope = assert(function (el) {\n        docElem.appendChild(el).appendChild(document.createElement(\"div\"));\n        return typeof el.querySelectorAll !== \"undefined\" && !el.querySelectorAll(\":scope fieldset div\").length;\n      });\n      /* Attributes\n      ---------------------------------------------------------------------- */\n      // Support: IE<8\n      // Verify that getAttribute really returns attributes and not properties\n      // (excepting IE8 booleans)\n\n      support.attributes = assert(function (el) {\n        el.className = \"i\";\n        return !el.getAttribute(\"className\");\n      });\n      /* getElement(s)By*\n      ---------------------------------------------------------------------- */\n      // Check if getElementsByTagName(\"*\") returns only elements\n\n      support.getElementsByTagName = assert(function (el) {\n        el.appendChild(document.createComment(\"\"));\n        return !el.getElementsByTagName(\"*\").length;\n      }); // Support: IE<9\n\n      support.getElementsByClassName = rnative.test(document.getElementsByClassName); // Support: IE<10\n      // Check if getElementById returns elements by name\n      // The broken getElementById methods don't pick up programmatically-set names,\n      // so use a roundabout getElementsByName test\n\n      support.getById = assert(function (el) {\n        docElem.appendChild(el).id = expando;\n        return !document.getElementsByName || !document.getElementsByName(expando).length;\n      }); // ID filter and find\n\n      if (support.getById) {\n        Expr.filter[\"ID\"] = function (id) {\n          var attrId = id.replace(runescape, funescape);\n          return function (elem) {\n            return elem.getAttribute(\"id\") === attrId;\n          };\n        };\n\n        Expr.find[\"ID\"] = function (id, context) {\n          if (typeof context.getElementById !== \"undefined\" && documentIsHTML) {\n            var elem = context.getElementById(id);\n            return elem ? [elem] : [];\n          }\n        };\n      } else {\n        Expr.filter[\"ID\"] = function (id) {\n          var attrId = id.replace(runescape, funescape);\n          return function (elem) {\n            var node = typeof elem.getAttributeNode !== \"undefined\" && elem.getAttributeNode(\"id\");\n            return node && node.value === attrId;\n          };\n        }; // Support: IE 6 - 7 only\n        // getElementById is not reliable as a find shortcut\n\n\n        Expr.find[\"ID\"] = function (id, context) {\n          if (typeof context.getElementById !== \"undefined\" && documentIsHTML) {\n            var node,\n                i,\n                elems,\n                elem = context.getElementById(id);\n\n            if (elem) {\n              // Verify the id attribute\n              node = elem.getAttributeNode(\"id\");\n\n              if (node && node.value === id) {\n                return [elem];\n              } // Fall back on getElementsByName\n\n\n              elems = context.getElementsByName(id);\n              i = 0;\n\n              while (elem = elems[i++]) {\n                node = elem.getAttributeNode(\"id\");\n\n                if (node && node.value === id) {\n                  return [elem];\n                }\n              }\n            }\n\n            return [];\n          }\n        };\n      } // Tag\n\n\n      Expr.find[\"TAG\"] = support.getElementsByTagName ? function (tag, context) {\n        if (typeof context.getElementsByTagName !== \"undefined\") {\n          return context.getElementsByTagName(tag); // DocumentFragment nodes don't have gEBTN\n        } else if (support.qsa) {\n          return context.querySelectorAll(tag);\n        }\n      } : function (tag, context) {\n        var elem,\n            tmp = [],\n            i = 0,\n            // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n        results = context.getElementsByTagName(tag); // Filter out possible comments\n\n        if (tag === \"*\") {\n          while (elem = results[i++]) {\n            if (elem.nodeType === 1) {\n              tmp.push(elem);\n            }\n          }\n\n          return tmp;\n        }\n\n        return results;\n      }; // Class\n\n      Expr.find[\"CLASS\"] = support.getElementsByClassName && function (className, context) {\n        if (typeof context.getElementsByClassName !== \"undefined\" && documentIsHTML) {\n          return context.getElementsByClassName(className);\n        }\n      };\n      /* QSA/matchesSelector\n      ---------------------------------------------------------------------- */\n      // QSA and matchesSelector support\n      // matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\n\n      rbuggyMatches = []; // qSa(:focus) reports false when true (Chrome 21)\n      // We allow this because of a bug in IE8/9 that throws an error\n      // whenever `document.activeElement` is accessed on an iframe\n      // So, we allow :focus to pass through QSA all the time to avoid the IE error\n      // See https://bugs.jquery.com/ticket/13378\n\n      rbuggyQSA = [];\n\n      if (support.qsa = rnative.test(document.querySelectorAll)) {\n        // Build QSA regex\n        // Regex strategy adopted from Diego Perini\n        assert(function (el) {\n          var input; // Select is set to empty string on purpose\n          // This is to test IE's treatment of not explicitly\n          // setting a boolean content attribute,\n          // since its presence should be enough\n          // https://bugs.jquery.com/ticket/12359\n\n          docElem.appendChild(el).innerHTML = \"<a id='\" + expando + \"'></a>\" + \"<select id='\" + expando + \"-\\r\\\\' msallowcapture=''>\" + \"<option selected=''></option></select>\"; // Support: IE8, Opera 11-12.16\n          // Nothing should be selected when empty strings follow ^= or $= or *=\n          // The test attribute must be unknown in Opera but \"safe\" for WinRT\n          // https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\n          if (el.querySelectorAll(\"[msallowcapture^='']\").length) {\n            rbuggyQSA.push(\"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\");\n          } // Support: IE8\n          // Boolean attributes and \"value\" are not treated correctly\n\n\n          if (!el.querySelectorAll(\"[selected]\").length) {\n            rbuggyQSA.push(\"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\");\n          } // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\n\n\n          if (!el.querySelectorAll(\"[id~=\" + expando + \"-]\").length) {\n            rbuggyQSA.push(\"~=\");\n          } // Support: IE 11+, Edge 15 - 18+\n          // IE 11/Edge don't find elements on a `[name='']` query in some cases.\n          // Adding a temporary attribute to the document before the selection works\n          // around the issue.\n          // Interestingly, IE 10 & older don't seem to have the issue.\n\n\n          input = document.createElement(\"input\");\n          input.setAttribute(\"name\", \"\");\n          el.appendChild(input);\n\n          if (!el.querySelectorAll(\"[name='']\").length) {\n            rbuggyQSA.push(\"\\\\[\" + whitespace + \"*name\" + whitespace + \"*=\" + whitespace + \"*(?:''|\\\"\\\")\");\n          } // Webkit/Opera - :checked should return selected option elements\n          // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n          // IE8 throws error here and will not see later tests\n\n\n          if (!el.querySelectorAll(\":checked\").length) {\n            rbuggyQSA.push(\":checked\");\n          } // Support: Safari 8+, iOS 8+\n          // https://bugs.webkit.org/show_bug.cgi?id=136851\n          // In-page `selector#id sibling-combinator selector` fails\n\n\n          if (!el.querySelectorAll(\"a#\" + expando + \"+*\").length) {\n            rbuggyQSA.push(\".#.+[+~]\");\n          } // Support: Firefox <=3.6 - 5 only\n          // Old Firefox doesn't throw on a badly-escaped identifier.\n\n\n          el.querySelectorAll(\"\\\\\\f\");\n          rbuggyQSA.push(\"[\\\\r\\\\n\\\\f]\");\n        });\n        assert(function (el) {\n          el.innerHTML = \"<a href='' disabled='disabled'></a>\" + \"<select disabled='disabled'><option/></select>\"; // Support: Windows 8 Native Apps\n          // The type and name attributes are restricted during .innerHTML assignment\n\n          var input = document.createElement(\"input\");\n          input.setAttribute(\"type\", \"hidden\");\n          el.appendChild(input).setAttribute(\"name\", \"D\"); // Support: IE8\n          // Enforce case-sensitivity of name attribute\n\n          if (el.querySelectorAll(\"[name=d]\").length) {\n            rbuggyQSA.push(\"name\" + whitespace + \"*[*^$|!~]?=\");\n          } // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n          // IE8 throws error here and will not see later tests\n\n\n          if (el.querySelectorAll(\":enabled\").length !== 2) {\n            rbuggyQSA.push(\":enabled\", \":disabled\");\n          } // Support: IE9-11+\n          // IE's :disabled selector does not pick up the children of disabled fieldsets\n\n\n          docElem.appendChild(el).disabled = true;\n\n          if (el.querySelectorAll(\":disabled\").length !== 2) {\n            rbuggyQSA.push(\":enabled\", \":disabled\");\n          } // Support: Opera 10 - 11 only\n          // Opera 10-11 does not throw on post-comma invalid pseudos\n\n\n          el.querySelectorAll(\"*,:x\");\n          rbuggyQSA.push(\",.*:\");\n        });\n      }\n\n      if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {\n        assert(function (el) {\n          // Check to see if it's possible to do matchesSelector\n          // on a disconnected node (IE 9)\n          support.disconnectedMatch = matches.call(el, \"*\"); // This should fail with an exception\n          // Gecko does not error, returns false instead\n\n          matches.call(el, \"[s!='']:x\");\n          rbuggyMatches.push(\"!=\", pseudos);\n        });\n      }\n\n      rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join(\"|\"));\n      rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join(\"|\"));\n      /* Contains\n      ---------------------------------------------------------------------- */\n\n      hasCompare = rnative.test(docElem.compareDocumentPosition); // Element contains another\n      // Purposefully self-exclusive\n      // As in, an element does not contain itself\n\n      contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {\n        var adown = a.nodeType === 9 ? a.documentElement : a,\n            bup = b && b.parentNode;\n        return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));\n      } : function (a, b) {\n        if (b) {\n          while (b = b.parentNode) {\n            if (b === a) {\n              return true;\n            }\n          }\n        }\n\n        return false;\n      };\n      /* Sorting\n      ---------------------------------------------------------------------- */\n      // Document order sorting\n\n      sortOrder = hasCompare ? function (a, b) {\n        // Flag for duplicate removal\n        if (a === b) {\n          hasDuplicate = true;\n          return 0;\n        } // Sort on method existence if only one input has compareDocumentPosition\n\n\n        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\n        if (compare) {\n          return compare;\n        } // Calculate position if both inputs belong to the same document\n        // Support: IE 11+, Edge 17 - 18+\n        // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n        // two documents; shallow comparisons work.\n        // eslint-disable-next-line eqeqeq\n\n\n        compare = (a.ownerDocument || a) == (b.ownerDocument || b) ? a.compareDocumentPosition(b) : // Otherwise we know they are disconnected\n        1; // Disconnected nodes\n\n        if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {\n          // Choose the first element that is related to our preferred document\n          // Support: IE 11+, Edge 17 - 18+\n          // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n          // two documents; shallow comparisons work.\n          // eslint-disable-next-line eqeqeq\n          if (a == document || a.ownerDocument == preferredDoc && contains(preferredDoc, a)) {\n            return -1;\n          } // Support: IE 11+, Edge 17 - 18+\n          // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n          // two documents; shallow comparisons work.\n          // eslint-disable-next-line eqeqeq\n\n\n          if (b == document || b.ownerDocument == preferredDoc && contains(preferredDoc, b)) {\n            return 1;\n          } // Maintain original order\n\n\n          return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;\n        }\n\n        return compare & 4 ? -1 : 1;\n      } : function (a, b) {\n        // Exit early if the nodes are identical\n        if (a === b) {\n          hasDuplicate = true;\n          return 0;\n        }\n\n        var cur,\n            i = 0,\n            aup = a.parentNode,\n            bup = b.parentNode,\n            ap = [a],\n            bp = [b]; // Parentless nodes are either documents or disconnected\n\n        if (!aup || !bup) {\n          // Support: IE 11+, Edge 17 - 18+\n          // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n          // two documents; shallow comparisons work.\n\n          /* eslint-disable eqeqeq */\n          return a == document ? -1 : b == document ? 1 :\n          /* eslint-enable eqeqeq */\n          aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0; // If the nodes are siblings, we can do a quick check\n        } else if (aup === bup) {\n          return siblingCheck(a, b);\n        } // Otherwise we need full lists of their ancestors for comparison\n\n\n        cur = a;\n\n        while (cur = cur.parentNode) {\n          ap.unshift(cur);\n        }\n\n        cur = b;\n\n        while (cur = cur.parentNode) {\n          bp.unshift(cur);\n        } // Walk down the tree looking for a discrepancy\n\n\n        while (ap[i] === bp[i]) {\n          i++;\n        }\n\n        return i ? // Do a sibling check if the nodes have a common ancestor\n        siblingCheck(ap[i], bp[i]) : // Otherwise nodes in our document sort first\n        // Support: IE 11+, Edge 17 - 18+\n        // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n        // two documents; shallow comparisons work.\n\n        /* eslint-disable eqeqeq */\n        ap[i] == preferredDoc ? -1 : bp[i] == preferredDoc ? 1 :\n        /* eslint-enable eqeqeq */\n        0;\n      };\n      return document;\n    };\n\n    Sizzle.matches = function (expr, elements) {\n      return Sizzle(expr, null, null, elements);\n    };\n\n    Sizzle.matchesSelector = function (elem, expr) {\n      setDocument(elem);\n\n      if (support.matchesSelector && documentIsHTML && !nonnativeSelectorCache[expr + \" \"] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {\n        try {\n          var ret = matches.call(elem, expr); // IE 9's matchesSelector returns false on disconnected nodes\n\n          if (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document\n          // fragment in IE 9\n          elem.document && elem.document.nodeType !== 11) {\n            return ret;\n          }\n        } catch (e) {\n          nonnativeSelectorCache(expr, true);\n        }\n      }\n\n      return Sizzle(expr, document, null, [elem]).length > 0;\n    };\n\n    Sizzle.contains = function (context, elem) {\n      // Set document vars if needed\n      // Support: IE 11+, Edge 17 - 18+\n      // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n      // two documents; shallow comparisons work.\n      // eslint-disable-next-line eqeqeq\n      if ((context.ownerDocument || context) != document) {\n        setDocument(context);\n      }\n\n      return contains(context, elem);\n    };\n\n    Sizzle.attr = function (elem, name) {\n      // Set document vars if needed\n      // Support: IE 11+, Edge 17 - 18+\n      // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n      // two documents; shallow comparisons work.\n      // eslint-disable-next-line eqeqeq\n      if ((elem.ownerDocument || elem) != document) {\n        setDocument(elem);\n      }\n\n      var fn = Expr.attrHandle[name.toLowerCase()],\n          // Don't get fooled by Object.prototype properties (jQuery #13807)\n      val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;\n      return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;\n    };\n\n    Sizzle.escape = function (sel) {\n      return (sel + \"\").replace(rcssescape, fcssescape);\n    };\n\n    Sizzle.error = function (msg) {\n      throw new Error(\"Syntax error, unrecognized expression: \" + msg);\n    };\n    /**\n     * Document sorting and removing duplicates\n     * @param {ArrayLike} results\n     */\n\n\n    Sizzle.uniqueSort = function (results) {\n      var elem,\n          duplicates = [],\n          j = 0,\n          i = 0; // Unless we *know* we can detect duplicates, assume their presence\n\n      hasDuplicate = !support.detectDuplicates;\n      sortInput = !support.sortStable && results.slice(0);\n      results.sort(sortOrder);\n\n      if (hasDuplicate) {\n        while (elem = results[i++]) {\n          if (elem === results[i]) {\n            j = duplicates.push(i);\n          }\n        }\n\n        while (j--) {\n          results.splice(duplicates[j], 1);\n        }\n      } // Clear input after sorting to release objects\n      // See https://github.com/jquery/sizzle/pull/225\n\n\n      sortInput = null;\n      return results;\n    };\n    /**\n     * Utility function for retrieving the text value of an array of DOM nodes\n     * @param {Array|Element} elem\n     */\n\n\n    getText = Sizzle.getText = function (elem) {\n      var node,\n          ret = \"\",\n          i = 0,\n          nodeType = elem.nodeType;\n\n      if (!nodeType) {\n        // If no nodeType, this is expected to be an array\n        while (node = elem[i++]) {\n          // Do not traverse comment nodes\n          ret += getText(node);\n        }\n      } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {\n        // Use textContent for elements\n        // innerText usage removed for consistency of new lines (jQuery #11153)\n        if (typeof elem.textContent === \"string\") {\n          return elem.textContent;\n        } else {\n          // Traverse its children\n          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {\n            ret += getText(elem);\n          }\n        }\n      } else if (nodeType === 3 || nodeType === 4) {\n        return elem.nodeValue;\n      } // Do not include comment or processing instruction nodes\n\n\n      return ret;\n    };\n\n    Expr = Sizzle.selectors = {\n      // Can be adjusted by the user\n      cacheLength: 50,\n      createPseudo: markFunction,\n      match: matchExpr,\n      attrHandle: {},\n      find: {},\n      relative: {\n        \">\": {\n          dir: \"parentNode\",\n          first: true\n        },\n        \" \": {\n          dir: \"parentNode\"\n        },\n        \"+\": {\n          dir: \"previousSibling\",\n          first: true\n        },\n        \"~\": {\n          dir: \"previousSibling\"\n        }\n      },\n      preFilter: {\n        \"ATTR\": function ATTR(match) {\n          match[1] = match[1].replace(runescape, funescape); // Move the given value to match[3] whether quoted or unquoted\n\n          match[3] = (match[3] || match[4] || match[5] || \"\").replace(runescape, funescape);\n\n          if (match[2] === \"~=\") {\n            match[3] = \" \" + match[3] + \" \";\n          }\n\n          return match.slice(0, 4);\n        },\n        \"CHILD\": function CHILD(match) {\n          /* matches from matchExpr[\"CHILD\"]\n          \t1 type (only|nth|...)\n          \t2 what (child|of-type)\n          \t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n          \t4 xn-component of xn+y argument ([+-]?\\d*n|)\n          \t5 sign of xn-component\n          \t6 x of xn-component\n          \t7 sign of y-component\n          \t8 y of y-component\n          */\n          match[1] = match[1].toLowerCase();\n\n          if (match[1].slice(0, 3) === \"nth\") {\n            // nth-* requires argument\n            if (!match[3]) {\n              Sizzle.error(match[0]);\n            } // numeric x and y parameters for Expr.filter.CHILD\n            // remember that false/true cast respectively to 0/1\n\n\n            match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === \"even\" || match[3] === \"odd\"));\n            match[5] = +(match[7] + match[8] || match[3] === \"odd\"); // other types prohibit arguments\n          } else if (match[3]) {\n            Sizzle.error(match[0]);\n          }\n\n          return match;\n        },\n        \"PSEUDO\": function PSEUDO(match) {\n          var excess,\n              unquoted = !match[6] && match[2];\n\n          if (matchExpr[\"CHILD\"].test(match[0])) {\n            return null;\n          } // Accept quoted arguments as-is\n\n\n          if (match[3]) {\n            match[2] = match[4] || match[5] || \"\"; // Strip excess characters from unquoted arguments\n          } else if (unquoted && rpseudo.test(unquoted) && ( // Get excess from tokenize (recursively)\n          excess = tokenize(unquoted, true)) && ( // advance to the next closing parenthesis\n          excess = unquoted.indexOf(\")\", unquoted.length - excess) - unquoted.length)) {\n            // excess is a negative index\n            match[0] = match[0].slice(0, excess);\n            match[2] = unquoted.slice(0, excess);\n          } // Return only captures needed by the pseudo filter method (type and argument)\n\n\n          return match.slice(0, 3);\n        }\n      },\n      filter: {\n        \"TAG\": function TAG(nodeNameSelector) {\n          var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();\n          return nodeNameSelector === \"*\" ? function () {\n            return true;\n          } : function (elem) {\n            return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n          };\n        },\n        \"CLASS\": function CLASS(className) {\n          var pattern = classCache[className + \" \"];\n          return pattern || (pattern = new RegExp(\"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\")) && classCache(className, function (elem) {\n            return pattern.test(typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== \"undefined\" && elem.getAttribute(\"class\") || \"\");\n          });\n        },\n        \"ATTR\": function ATTR(name, operator, check) {\n          return function (elem) {\n            var result = Sizzle.attr(elem, name);\n\n            if (result == null) {\n              return operator === \"!=\";\n            }\n\n            if (!operator) {\n              return true;\n            }\n\n            result += \"\";\n            /* eslint-disable max-len */\n\n            return operator === \"=\" ? result === check : operator === \"!=\" ? result !== check : operator === \"^=\" ? check && result.indexOf(check) === 0 : operator === \"*=\" ? check && result.indexOf(check) > -1 : operator === \"$=\" ? check && result.slice(-check.length) === check : operator === \"~=\" ? (\" \" + result.replace(rwhitespace, \" \") + \" \").indexOf(check) > -1 : operator === \"|=\" ? result === check || result.slice(0, check.length + 1) === check + \"-\" : false;\n            /* eslint-enable max-len */\n          };\n        },\n        \"CHILD\": function CHILD(type, what, _argument, first, last) {\n          var simple = type.slice(0, 3) !== \"nth\",\n              forward = type.slice(-4) !== \"last\",\n              ofType = what === \"of-type\";\n          return first === 1 && last === 0 ? // Shortcut for :nth-*(n)\n          function (elem) {\n            return !!elem.parentNode;\n          } : function (elem, _context, xml) {\n            var cache,\n                uniqueCache,\n                outerCache,\n                node,\n                nodeIndex,\n                start,\n                dir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n                parent = elem.parentNode,\n                name = ofType && elem.nodeName.toLowerCase(),\n                useCache = !xml && !ofType,\n                diff = false;\n\n            if (parent) {\n              // :(first|last|only)-(child|of-type)\n              if (simple) {\n                while (dir) {\n                  node = elem;\n\n                  while (node = node[dir]) {\n                    if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {\n                      return false;\n                    }\n                  } // Reverse direction for :only-* (if we haven't yet done so)\n\n\n                  start = dir = type === \"only\" && !start && \"nextSibling\";\n                }\n\n                return true;\n              }\n\n              start = [forward ? parent.firstChild : parent.lastChild]; // non-xml :nth-child(...) stores cache data on `parent`\n\n              if (forward && useCache) {\n                // Seek `elem` from a previously-cached index\n                // ...in a gzip-friendly way\n                node = parent;\n                outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only\n                // Defend against cloned attroperties (jQuery gh-1709)\n\n                uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});\n                cache = uniqueCache[type] || [];\n                nodeIndex = cache[0] === dirruns && cache[1];\n                diff = nodeIndex && cache[2];\n                node = nodeIndex && parent.childNodes[nodeIndex];\n\n                while (node = ++nodeIndex && node && node[dir] || ( // Fallback to seeking `elem` from the start\n                diff = nodeIndex = 0) || start.pop()) {\n                  // When found, cache indexes on `parent` and break\n                  if (node.nodeType === 1 && ++diff && node === elem) {\n                    uniqueCache[type] = [dirruns, nodeIndex, diff];\n                    break;\n                  }\n                }\n              } else {\n                // Use previously-cached element index if available\n                if (useCache) {\n                  // ...in a gzip-friendly way\n                  node = elem;\n                  outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only\n                  // Defend against cloned attroperties (jQuery gh-1709)\n\n                  uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});\n                  cache = uniqueCache[type] || [];\n                  nodeIndex = cache[0] === dirruns && cache[1];\n                  diff = nodeIndex;\n                } // xml :nth-child(...)\n                // or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\n\n                if (diff === false) {\n                  // Use the same loop as above to seek `elem` from the start\n                  while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {\n                    if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {\n                      // Cache the index of each encountered element\n                      if (useCache) {\n                        outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only\n                        // Defend against cloned attroperties (jQuery gh-1709)\n\n                        uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});\n                        uniqueCache[type] = [dirruns, diff];\n                      }\n\n                      if (node === elem) {\n                        break;\n                      }\n                    }\n                  }\n                }\n              } // Incorporate the offset, then check against cycle size\n\n\n              diff -= last;\n              return diff === first || diff % first === 0 && diff / first >= 0;\n            }\n          };\n        },\n        \"PSEUDO\": function PSEUDO(pseudo, argument) {\n          // pseudo-class names are case-insensitive\n          // http://www.w3.org/TR/selectors/#pseudo-classes\n          // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n          // Remember that setFilters inherits from pseudos\n          var args,\n              fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error(\"unsupported pseudo: \" + pseudo); // The user may use createPseudo to indicate that\n          // arguments are needed to create the filter function\n          // just as Sizzle does\n\n          if (fn[expando]) {\n            return fn(argument);\n          } // But maintain support for old signatures\n\n\n          if (fn.length > 1) {\n            args = [pseudo, pseudo, \"\", argument];\n            return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {\n              var idx,\n                  matched = fn(seed, argument),\n                  i = matched.length;\n\n              while (i--) {\n                idx = indexOf(seed, matched[i]);\n                seed[idx] = !(matches[idx] = matched[i]);\n              }\n            }) : function (elem) {\n              return fn(elem, 0, args);\n            };\n          }\n\n          return fn;\n        }\n      },\n      pseudos: {\n        // Potentially complex pseudos\n        \"not\": markFunction(function (selector) {\n          // Trim the selector passed to compile\n          // to avoid treating leading and trailing\n          // spaces as combinators\n          var input = [],\n              results = [],\n              matcher = compile(selector.replace(rtrim, \"$1\"));\n          return matcher[expando] ? markFunction(function (seed, matches, _context, xml) {\n            var elem,\n                unmatched = matcher(seed, null, xml, []),\n                i = seed.length; // Match elements unmatched by `matcher`\n\n            while (i--) {\n              if (elem = unmatched[i]) {\n                seed[i] = !(matches[i] = elem);\n              }\n            }\n          }) : function (elem, _context, xml) {\n            input[0] = elem;\n            matcher(input, null, xml, results); // Don't keep the element (issue #299)\n\n            input[0] = null;\n            return !results.pop();\n          };\n        }),\n        \"has\": markFunction(function (selector) {\n          return function (elem) {\n            return Sizzle(selector, elem).length > 0;\n          };\n        }),\n        \"contains\": markFunction(function (text) {\n          text = text.replace(runescape, funescape);\n          return function (elem) {\n            return (elem.textContent || getText(elem)).indexOf(text) > -1;\n          };\n        }),\n        // \"Whether an element is represented by a :lang() selector\n        // is based solely on the element's language value\n        // being equal to the identifier C,\n        // or beginning with the identifier C immediately followed by \"-\".\n        // The matching of C against the element's language value is performed case-insensitively.\n        // The identifier C does not have to be a valid language name.\"\n        // http://www.w3.org/TR/selectors/#lang-pseudo\n        \"lang\": markFunction(function (lang) {\n          // lang value must be a valid identifier\n          if (!ridentifier.test(lang || \"\")) {\n            Sizzle.error(\"unsupported lang: \" + lang);\n          }\n\n          lang = lang.replace(runescape, funescape).toLowerCase();\n          return function (elem) {\n            var elemLang;\n\n            do {\n              if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) {\n                elemLang = elemLang.toLowerCase();\n                return elemLang === lang || elemLang.indexOf(lang + \"-\") === 0;\n              }\n            } while ((elem = elem.parentNode) && elem.nodeType === 1);\n\n            return false;\n          };\n        }),\n        // Miscellaneous\n        \"target\": function target(elem) {\n          var hash = window.location && window.location.hash;\n          return hash && hash.slice(1) === elem.id;\n        },\n        \"root\": function root(elem) {\n          return elem === docElem;\n        },\n        \"focus\": function focus(elem) {\n          return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n        },\n        // Boolean properties\n        \"enabled\": createDisabledPseudo(false),\n        \"disabled\": createDisabledPseudo(true),\n        \"checked\": function checked(elem) {\n          // In CSS3, :checked should return both checked and selected elements\n          // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n          var nodeName = elem.nodeName.toLowerCase();\n          return nodeName === \"input\" && !!elem.checked || nodeName === \"option\" && !!elem.selected;\n        },\n        \"selected\": function selected(elem) {\n          // Accessing this property makes selected-by-default\n          // options in Safari work properly\n          if (elem.parentNode) {\n            // eslint-disable-next-line no-unused-expressions\n            elem.parentNode.selectedIndex;\n          }\n\n          return elem.selected === true;\n        },\n        // Contents\n        \"empty\": function empty(elem) {\n          // http://www.w3.org/TR/selectors/#empty-pseudo\n          // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n          //   but not by others (comment: 8; processing instruction: 7; etc.)\n          // nodeType < 6 works because attributes (2) do not appear as children\n          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {\n            if (elem.nodeType < 6) {\n              return false;\n            }\n          }\n\n          return true;\n        },\n        \"parent\": function parent(elem) {\n          return !Expr.pseudos[\"empty\"](elem);\n        },\n        // Element/input types\n        \"header\": function header(elem) {\n          return rheader.test(elem.nodeName);\n        },\n        \"input\": function input(elem) {\n          return rinputs.test(elem.nodeName);\n        },\n        \"button\": function button(elem) {\n          var name = elem.nodeName.toLowerCase();\n          return name === \"input\" && elem.type === \"button\" || name === \"button\";\n        },\n        \"text\": function text(elem) {\n          var attr;\n          return elem.nodeName.toLowerCase() === \"input\" && elem.type === \"text\" && ( // Support: IE<8\n          // New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n          (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\");\n        },\n        // Position-in-collection\n        \"first\": createPositionalPseudo(function () {\n          return [0];\n        }),\n        \"last\": createPositionalPseudo(function (_matchIndexes, length) {\n          return [length - 1];\n        }),\n        \"eq\": createPositionalPseudo(function (_matchIndexes, length, argument) {\n          return [argument < 0 ? argument + length : argument];\n        }),\n        \"even\": createPositionalPseudo(function (matchIndexes, length) {\n          var i = 0;\n\n          for (; i < length; i += 2) {\n            matchIndexes.push(i);\n          }\n\n          return matchIndexes;\n        }),\n        \"odd\": createPositionalPseudo(function (matchIndexes, length) {\n          var i = 1;\n\n          for (; i < length; i += 2) {\n            matchIndexes.push(i);\n          }\n\n          return matchIndexes;\n        }),\n        \"lt\": createPositionalPseudo(function (matchIndexes, length, argument) {\n          var i = argument < 0 ? argument + length : argument > length ? length : argument;\n\n          for (; --i >= 0;) {\n            matchIndexes.push(i);\n          }\n\n          return matchIndexes;\n        }),\n        \"gt\": createPositionalPseudo(function (matchIndexes, length, argument) {\n          var i = argument < 0 ? argument + length : argument;\n\n          for (; ++i < length;) {\n            matchIndexes.push(i);\n          }\n\n          return matchIndexes;\n        })\n      }\n    };\n    Expr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"]; // Add button/input type pseudos\n\n    for (i in {\n      radio: true,\n      checkbox: true,\n      file: true,\n      password: true,\n      image: true\n    }) {\n      Expr.pseudos[i] = createInputPseudo(i);\n    }\n\n    for (i in {\n      submit: true,\n      reset: true\n    }) {\n      Expr.pseudos[i] = createButtonPseudo(i);\n    } // Easy API for creating new setFilters\n\n\n    function setFilters() {}\n\n    setFilters.prototype = Expr.filters = Expr.pseudos;\n    Expr.setFilters = new setFilters();\n\n    tokenize = Sizzle.tokenize = function (selector, parseOnly) {\n      var matched,\n          match,\n          tokens,\n          type,\n          soFar,\n          groups,\n          preFilters,\n          cached = tokenCache[selector + \" \"];\n\n      if (cached) {\n        return parseOnly ? 0 : cached.slice(0);\n      }\n\n      soFar = selector;\n      groups = [];\n      preFilters = Expr.preFilter;\n\n      while (soFar) {\n        // Comma and first run\n        if (!matched || (match = rcomma.exec(soFar))) {\n          if (match) {\n            // Don't consume trailing commas as valid\n            soFar = soFar.slice(match[0].length) || soFar;\n          }\n\n          groups.push(tokens = []);\n        }\n\n        matched = false; // Combinators\n\n        if (match = rcombinators.exec(soFar)) {\n          matched = match.shift();\n          tokens.push({\n            value: matched,\n            // Cast descendant combinators to space\n            type: match[0].replace(rtrim, \" \")\n          });\n          soFar = soFar.slice(matched.length);\n        } // Filters\n\n\n        for (type in Expr.filter) {\n          if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {\n            matched = match.shift();\n            tokens.push({\n              value: matched,\n              type: type,\n              matches: match\n            });\n            soFar = soFar.slice(matched.length);\n          }\n        }\n\n        if (!matched) {\n          break;\n        }\n      } // Return the length of the invalid excess\n      // if we're just parsing\n      // Otherwise, throw an error or return tokens\n\n\n      return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : // Cache the tokens\n      tokenCache(selector, groups).slice(0);\n    };\n\n    function toSelector(tokens) {\n      var i = 0,\n          len = tokens.length,\n          selector = \"\";\n\n      for (; i < len; i++) {\n        selector += tokens[i].value;\n      }\n\n      return selector;\n    }\n\n    function addCombinator(matcher, combinator, base) {\n      var dir = combinator.dir,\n          skip = combinator.next,\n          key = skip || dir,\n          checkNonElements = base && key === \"parentNode\",\n          doneName = done++;\n      return combinator.first ? // Check against closest ancestor/preceding element\n      function (elem, context, xml) {\n        while (elem = elem[dir]) {\n          if (elem.nodeType === 1 || checkNonElements) {\n            return matcher(elem, context, xml);\n          }\n        }\n\n        return false;\n      } : // Check against all ancestor/preceding elements\n      function (elem, context, xml) {\n        var oldCache,\n            uniqueCache,\n            outerCache,\n            newCache = [dirruns, doneName]; // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\n\n        if (xml) {\n          while (elem = elem[dir]) {\n            if (elem.nodeType === 1 || checkNonElements) {\n              if (matcher(elem, context, xml)) {\n                return true;\n              }\n            }\n          }\n        } else {\n          while (elem = elem[dir]) {\n            if (elem.nodeType === 1 || checkNonElements) {\n              outerCache = elem[expando] || (elem[expando] = {}); // Support: IE <9 only\n              // Defend against cloned attroperties (jQuery gh-1709)\n\n              uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});\n\n              if (skip && skip === elem.nodeName.toLowerCase()) {\n                elem = elem[dir] || elem;\n              } else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {\n                // Assign to newCache so results back-propagate to previous elements\n                return newCache[2] = oldCache[2];\n              } else {\n                // Reuse newcache so results back-propagate to previous elements\n                uniqueCache[key] = newCache; // A match means we're done; a fail means we have to keep checking\n\n                if (newCache[2] = matcher(elem, context, xml)) {\n                  return true;\n                }\n              }\n            }\n          }\n        }\n\n        return false;\n      };\n    }\n\n    function elementMatcher(matchers) {\n      return matchers.length > 1 ? function (elem, context, xml) {\n        var i = matchers.length;\n\n        while (i--) {\n          if (!matchers[i](elem, context, xml)) {\n            return false;\n          }\n        }\n\n        return true;\n      } : matchers[0];\n    }\n\n    function multipleContexts(selector, contexts, results) {\n      var i = 0,\n          len = contexts.length;\n\n      for (; i < len; i++) {\n        Sizzle(selector, contexts[i], results);\n      }\n\n      return results;\n    }\n\n    function condense(unmatched, map, filter, context, xml) {\n      var elem,\n          newUnmatched = [],\n          i = 0,\n          len = unmatched.length,\n          mapped = map != null;\n\n      for (; i < len; i++) {\n        if (elem = unmatched[i]) {\n          if (!filter || filter(elem, context, xml)) {\n            newUnmatched.push(elem);\n\n            if (mapped) {\n              map.push(i);\n            }\n          }\n        }\n      }\n\n      return newUnmatched;\n    }\n\n    function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {\n      if (postFilter && !postFilter[expando]) {\n        postFilter = setMatcher(postFilter);\n      }\n\n      if (postFinder && !postFinder[expando]) {\n        postFinder = setMatcher(postFinder, postSelector);\n      }\n\n      return markFunction(function (seed, results, context, xml) {\n        var temp,\n            i,\n            elem,\n            preMap = [],\n            postMap = [],\n            preexisting = results.length,\n            // Get initial elements from seed or context\n        elems = seed || multipleContexts(selector || \"*\", context.nodeType ? [context] : context, []),\n            // Prefilter to get matcher input, preserving a map for seed-results synchronization\n        matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,\n            matcherOut = matcher ? // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n        postFinder || (seed ? preFilter : preexisting || postFilter) ? // ...intermediate processing is necessary\n        [] : // ...otherwise use results directly\n        results : matcherIn; // Find primary matches\n\n        if (matcher) {\n          matcher(matcherIn, matcherOut, context, xml);\n        } // Apply postFilter\n\n\n        if (postFilter) {\n          temp = condense(matcherOut, postMap);\n          postFilter(temp, [], context, xml); // Un-match failing elements by moving them back to matcherIn\n\n          i = temp.length;\n\n          while (i--) {\n            if (elem = temp[i]) {\n              matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);\n            }\n          }\n        }\n\n        if (seed) {\n          if (postFinder || preFilter) {\n            if (postFinder) {\n              // Get the final matcherOut by condensing this intermediate into postFinder contexts\n              temp = [];\n              i = matcherOut.length;\n\n              while (i--) {\n                if (elem = matcherOut[i]) {\n                  // Restore matcherIn since elem is not yet a final match\n                  temp.push(matcherIn[i] = elem);\n                }\n              }\n\n              postFinder(null, matcherOut = [], temp, xml);\n            } // Move matched elements from seed to results to keep them synchronized\n\n\n            i = matcherOut.length;\n\n            while (i--) {\n              if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {\n                seed[temp] = !(results[temp] = elem);\n              }\n            }\n          } // Add elements to results, through postFinder if defined\n\n        } else {\n          matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);\n\n          if (postFinder) {\n            postFinder(null, results, matcherOut, xml);\n          } else {\n            push.apply(results, matcherOut);\n          }\n        }\n      });\n    }\n\n    function matcherFromTokens(tokens) {\n      var checkContext,\n          matcher,\n          j,\n          len = tokens.length,\n          leadingRelative = Expr.relative[tokens[0].type],\n          implicitRelative = leadingRelative || Expr.relative[\" \"],\n          i = leadingRelative ? 1 : 0,\n          // The foundational matcher ensures that elements are reachable from top-level context(s)\n      matchContext = addCombinator(function (elem) {\n        return elem === checkContext;\n      }, implicitRelative, true),\n          matchAnyContext = addCombinator(function (elem) {\n        return indexOf(checkContext, elem) > -1;\n      }, implicitRelative, true),\n          matchers = [function (elem, context, xml) {\n        var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml)); // Avoid hanging onto element (issue #299)\n\n        checkContext = null;\n        return ret;\n      }];\n\n      for (; i < len; i++) {\n        if (matcher = Expr.relative[tokens[i].type]) {\n          matchers = [addCombinator(elementMatcher(matchers), matcher)];\n        } else {\n          matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches); // Return special upon seeing a positional matcher\n\n          if (matcher[expando]) {\n            // Find the next relative operator (if any) for proper handling\n            j = ++i;\n\n            for (; j < len; j++) {\n              if (Expr.relative[tokens[j].type]) {\n                break;\n              }\n            }\n\n            return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector( // If the preceding token was a descendant combinator, insert an implicit any-element `*`\n            tokens.slice(0, i - 1).concat({\n              value: tokens[i - 2].type === \" \" ? \"*\" : \"\"\n            })).replace(rtrim, \"$1\"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));\n          }\n\n          matchers.push(matcher);\n        }\n      }\n\n      return elementMatcher(matchers);\n    }\n\n    function matcherFromGroupMatchers(elementMatchers, setMatchers) {\n      var bySet = setMatchers.length > 0,\n          byElement = elementMatchers.length > 0,\n          superMatcher = function superMatcher(seed, context, xml, results, outermost) {\n        var elem,\n            j,\n            matcher,\n            matchedCount = 0,\n            i = \"0\",\n            unmatched = seed && [],\n            setMatched = [],\n            contextBackup = outermostContext,\n            // We must always have either seed elements or outermost context\n        elems = seed || byElement && Expr.find[\"TAG\"](\"*\", outermost),\n            // Use integer dirruns iff this is the outermost matcher\n        dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1,\n            len = elems.length;\n\n        if (outermost) {\n          // Support: IE 11+, Edge 17 - 18+\n          // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n          // two documents; shallow comparisons work.\n          // eslint-disable-next-line eqeqeq\n          outermostContext = context == document || context || outermost;\n        } // Add elements passing elementMatchers directly to results\n        // Support: IE<9, Safari\n        // Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n\n\n        for (; i !== len && (elem = elems[i]) != null; i++) {\n          if (byElement && elem) {\n            j = 0; // Support: IE 11+, Edge 17 - 18+\n            // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n            // two documents; shallow comparisons work.\n            // eslint-disable-next-line eqeqeq\n\n            if (!context && elem.ownerDocument != document) {\n              setDocument(elem);\n              xml = !documentIsHTML;\n            }\n\n            while (matcher = elementMatchers[j++]) {\n              if (matcher(elem, context || document, xml)) {\n                results.push(elem);\n                break;\n              }\n            }\n\n            if (outermost) {\n              dirruns = dirrunsUnique;\n            }\n          } // Track unmatched elements for set filters\n\n\n          if (bySet) {\n            // They will have gone through all possible matchers\n            if (elem = !matcher && elem) {\n              matchedCount--;\n            } // Lengthen the array for every element, matched or not\n\n\n            if (seed) {\n              unmatched.push(elem);\n            }\n          }\n        } // `i` is now the count of elements visited above, and adding it to `matchedCount`\n        // makes the latter nonnegative.\n\n\n        matchedCount += i; // Apply set filters to unmatched elements\n        // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n        // equals `i`), unless we didn't visit _any_ elements in the above loop because we have\n        // no element matchers and no seed.\n        // Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\n        // case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\n        // numerically zero.\n\n        if (bySet && i !== matchedCount) {\n          j = 0;\n\n          while (matcher = setMatchers[j++]) {\n            matcher(unmatched, setMatched, context, xml);\n          }\n\n          if (seed) {\n            // Reintegrate element matches to eliminate the need for sorting\n            if (matchedCount > 0) {\n              while (i--) {\n                if (!(unmatched[i] || setMatched[i])) {\n                  setMatched[i] = pop.call(results);\n                }\n              }\n            } // Discard index placeholder values to get only actual matches\n\n\n            setMatched = condense(setMatched);\n          } // Add matches to results\n\n\n          push.apply(results, setMatched); // Seedless set matches succeeding multiple successful matchers stipulate sorting\n\n          if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {\n            Sizzle.uniqueSort(results);\n          }\n        } // Override manipulation of globals by nested matchers\n\n\n        if (outermost) {\n          dirruns = dirrunsUnique;\n          outermostContext = contextBackup;\n        }\n\n        return unmatched;\n      };\n\n      return bySet ? markFunction(superMatcher) : superMatcher;\n    }\n\n    compile = Sizzle.compile = function (selector, match\n    /* Internal Use Only */\n    ) {\n      var i,\n          setMatchers = [],\n          elementMatchers = [],\n          cached = compilerCache[selector + \" \"];\n\n      if (!cached) {\n        // Generate a function of recursive functions that can be used to check each element\n        if (!match) {\n          match = tokenize(selector);\n        }\n\n        i = match.length;\n\n        while (i--) {\n          cached = matcherFromTokens(match[i]);\n\n          if (cached[expando]) {\n            setMatchers.push(cached);\n          } else {\n            elementMatchers.push(cached);\n          }\n        } // Cache the compiled function\n\n\n        cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers)); // Save selector and tokenization\n\n        cached.selector = selector;\n      }\n\n      return cached;\n    };\n    /**\n     * A low-level selection function that works with Sizzle's compiled\n     *  selector functions\n     * @param {String|Function} selector A selector or a pre-compiled\n     *  selector function built with Sizzle.compile\n     * @param {Element} context\n     * @param {Array} [results]\n     * @param {Array} [seed] A set of elements to match against\n     */\n\n\n    select = Sizzle.select = function (selector, context, results, seed) {\n      var i,\n          tokens,\n          token,\n          type,\n          find,\n          compiled = typeof selector === \"function\" && selector,\n          match = !seed && tokenize(selector = compiled.selector || selector);\n      results = results || []; // Try to minimize operations if there is only one selector in the list and no seed\n      // (the latter of which guarantees us context)\n\n      if (match.length === 1) {\n        // Reduce context if the leading compound selector is an ID\n        tokens = match[0] = match[0].slice(0);\n\n        if (tokens.length > 2 && (token = tokens[0]).type === \"ID\" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {\n          context = (Expr.find[\"ID\"](token.matches[0].replace(runescape, funescape), context) || [])[0];\n\n          if (!context) {\n            return results; // Precompiled matchers will still verify ancestry, so step up a level\n          } else if (compiled) {\n            context = context.parentNode;\n          }\n\n          selector = selector.slice(tokens.shift().value.length);\n        } // Fetch a seed set for right-to-left matching\n\n\n        i = matchExpr[\"needsContext\"].test(selector) ? 0 : tokens.length;\n\n        while (i--) {\n          token = tokens[i]; // Abort if we hit a combinator\n\n          if (Expr.relative[type = token.type]) {\n            break;\n          }\n\n          if (find = Expr.find[type]) {\n            // Search, expanding context for leading sibling combinators\n            if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {\n              // If seed is empty or no tokens remain, we can return early\n              tokens.splice(i, 1);\n              selector = seed.length && toSelector(tokens);\n\n              if (!selector) {\n                push.apply(results, seed);\n                return results;\n              }\n\n              break;\n            }\n          }\n        }\n      } // Compile and execute a filtering function if one is not provided\n      // Provide `match` to avoid retokenization if we modified the selector above\n\n\n      (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);\n      return results;\n    }; // One-time assignments\n    // Sort stability\n\n\n    support.sortStable = expando.split(\"\").sort(sortOrder).join(\"\") === expando; // Support: Chrome 14-35+\n    // Always assume duplicates if they aren't passed to the comparison function\n\n    support.detectDuplicates = !!hasDuplicate; // Initialize against the default document\n\n    setDocument(); // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n    // Detached nodes confoundingly follow *each other*\n\n    support.sortDetached = assert(function (el) {\n      // Should return 1, but returns 4 (following)\n      return el.compareDocumentPosition(document.createElement(\"fieldset\")) & 1;\n    }); // Support: IE<8\n    // Prevent attribute/property \"interpolation\"\n    // https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\n\n    if (!assert(function (el) {\n      el.innerHTML = \"<a href='#'></a>\";\n      return el.firstChild.getAttribute(\"href\") === \"#\";\n    })) {\n      addHandle(\"type|href|height|width\", function (elem, name, isXML) {\n        if (!isXML) {\n          return elem.getAttribute(name, name.toLowerCase() === \"type\" ? 1 : 2);\n        }\n      });\n    } // Support: IE<9\n    // Use defaultValue in place of getAttribute(\"value\")\n\n\n    if (!support.attributes || !assert(function (el) {\n      el.innerHTML = \"<input/>\";\n      el.firstChild.setAttribute(\"value\", \"\");\n      return el.firstChild.getAttribute(\"value\") === \"\";\n    })) {\n      addHandle(\"value\", function (elem, _name, isXML) {\n        if (!isXML && elem.nodeName.toLowerCase() === \"input\") {\n          return elem.defaultValue;\n        }\n      });\n    } // Support: IE<9\n    // Use getAttributeNode to fetch booleans when getAttribute lies\n\n\n    if (!assert(function (el) {\n      return el.getAttribute(\"disabled\") == null;\n    })) {\n      addHandle(booleans, function (elem, name, isXML) {\n        var val;\n\n        if (!isXML) {\n          return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;\n        }\n      });\n    }\n\n    return Sizzle;\n  }(window);\n\n  jQuery.find = Sizzle;\n  jQuery.expr = Sizzle.selectors; // Deprecated\n\n  jQuery.expr[\":\"] = jQuery.expr.pseudos;\n  jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;\n  jQuery.text = Sizzle.getText;\n  jQuery.isXMLDoc = Sizzle.isXML;\n  jQuery.contains = Sizzle.contains;\n  jQuery.escapeSelector = Sizzle.escape;\n\n  var dir = function dir(elem, _dir, until) {\n    var matched = [],\n        truncate = until !== undefined;\n\n    while ((elem = elem[_dir]) && elem.nodeType !== 9) {\n      if (elem.nodeType === 1) {\n        if (truncate && jQuery(elem).is(until)) {\n          break;\n        }\n\n        matched.push(elem);\n      }\n    }\n\n    return matched;\n  };\n\n  var _siblings = function siblings(n, elem) {\n    var matched = [];\n\n    for (; n; n = n.nextSibling) {\n      if (n.nodeType === 1 && n !== elem) {\n        matched.push(n);\n      }\n    }\n\n    return matched;\n  };\n\n  var rneedsContext = jQuery.expr.match.needsContext;\n\n  function nodeName(elem, name) {\n    return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n  }\n\n  ;\n  var rsingleTag = /^<([a-z][^\\/\\0>:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\/?>(?:<\\/\\1>|)$/i; // Implement the identical functionality for filter and not\n\n  function winnow(elements, qualifier, not) {\n    if (isFunction(qualifier)) {\n      return jQuery.grep(elements, function (elem, i) {\n        return !!qualifier.call(elem, i, elem) !== not;\n      });\n    } // Single element\n\n\n    if (qualifier.nodeType) {\n      return jQuery.grep(elements, function (elem) {\n        return elem === qualifier !== not;\n      });\n    } // Arraylike of elements (jQuery, arguments, Array)\n\n\n    if (typeof qualifier !== \"string\") {\n      return jQuery.grep(elements, function (elem) {\n        return indexOf.call(qualifier, elem) > -1 !== not;\n      });\n    } // Filtered directly for both simple and complex selectors\n\n\n    return jQuery.filter(qualifier, elements, not);\n  }\n\n  jQuery.filter = function (expr, elems, not) {\n    var elem = elems[0];\n\n    if (not) {\n      expr = \":not(\" + expr + \")\";\n    }\n\n    if (elems.length === 1 && elem.nodeType === 1) {\n      return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];\n    }\n\n    return jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {\n      return elem.nodeType === 1;\n    }));\n  };\n\n  jQuery.fn.extend({\n    find: function find(selector) {\n      var i,\n          ret,\n          len = this.length,\n          self = this;\n\n      if (typeof selector !== \"string\") {\n        return this.pushStack(jQuery(selector).filter(function () {\n          for (i = 0; i < len; i++) {\n            if (jQuery.contains(self[i], this)) {\n              return true;\n            }\n          }\n        }));\n      }\n\n      ret = this.pushStack([]);\n\n      for (i = 0; i < len; i++) {\n        jQuery.find(selector, self[i], ret);\n      }\n\n      return len > 1 ? jQuery.uniqueSort(ret) : ret;\n    },\n    filter: function filter(selector) {\n      return this.pushStack(winnow(this, selector || [], false));\n    },\n    not: function not(selector) {\n      return this.pushStack(winnow(this, selector || [], true));\n    },\n    is: function is(selector) {\n      return !!winnow(this, // If this is a positional/relative selector, check membership in the returned set\n      // so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n      typeof selector === \"string\" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;\n    }\n  }); // Initialize a jQuery object\n  // A central reference to the root jQuery(document)\n\n  var rootjQuery,\n      // A simple way to check for HTML strings\n  // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n  // Strict HTML recognition (#11290: must start with <)\n  // Shortcut simple #id case for speed\n  rquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/,\n      init = jQuery.fn.init = function (selector, context, root) {\n    var match, elem; // HANDLE: $(\"\"), $(null), $(undefined), $(false)\n\n    if (!selector) {\n      return this;\n    } // Method init() accepts an alternate rootjQuery\n    // so migrate can support jQuery.sub (gh-2101)\n\n\n    root = root || rootjQuery; // Handle HTML strings\n\n    if (typeof selector === \"string\") {\n      if (selector[0] === \"<\" && selector[selector.length - 1] === \">\" && selector.length >= 3) {\n        // Assume that strings that start and end with <> are HTML and skip the regex check\n        match = [null, selector, null];\n      } else {\n        match = rquickExpr.exec(selector);\n      } // Match html or make sure no context is specified for #id\n\n\n      if (match && (match[1] || !context)) {\n        // HANDLE: $(html) -> $(array)\n        if (match[1]) {\n          context = context instanceof jQuery ? context[0] : context; // Option to run scripts is true for back-compat\n          // Intentionally let the error be thrown if parseHTML is not present\n\n          jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true)); // HANDLE: $(html, props)\n\n          if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {\n            for (match in context) {\n              // Properties of context are called as methods if possible\n              if (isFunction(this[match])) {\n                this[match](context[match]); // ...and otherwise set as attributes\n              } else {\n                this.attr(match, context[match]);\n              }\n            }\n          }\n\n          return this; // HANDLE: $(#id)\n        } else {\n          elem = document.getElementById(match[2]);\n\n          if (elem) {\n            // Inject the element directly into the jQuery object\n            this[0] = elem;\n            this.length = 1;\n          }\n\n          return this;\n        } // HANDLE: $(expr, $(...))\n\n      } else if (!context || context.jquery) {\n        return (context || root).find(selector); // HANDLE: $(expr, context)\n        // (which is just equivalent to: $(context).find(expr)\n      } else {\n        return this.constructor(context).find(selector);\n      } // HANDLE: $(DOMElement)\n\n    } else if (selector.nodeType) {\n      this[0] = selector;\n      this.length = 1;\n      return this; // HANDLE: $(function)\n      // Shortcut for document ready\n    } else if (isFunction(selector)) {\n      return root.ready !== undefined ? root.ready(selector) : // Execute immediately if ready is not present\n      selector(jQuery);\n    }\n\n    return jQuery.makeArray(selector, this);\n  }; // Give the init function the jQuery prototype for later instantiation\n\n\n  init.prototype = jQuery.fn; // Initialize central reference\n\n  rootjQuery = jQuery(document);\n  var rparentsprev = /^(?:parents|prev(?:Until|All))/,\n      // Methods guaranteed to produce a unique set when starting from a unique set\n  guaranteedUnique = {\n    children: true,\n    contents: true,\n    next: true,\n    prev: true\n  };\n  jQuery.fn.extend({\n    has: function has(target) {\n      var targets = jQuery(target, this),\n          l = targets.length;\n      return this.filter(function () {\n        var i = 0;\n\n        for (; i < l; i++) {\n          if (jQuery.contains(this, targets[i])) {\n            return true;\n          }\n        }\n      });\n    },\n    closest: function closest(selectors, context) {\n      var cur,\n          i = 0,\n          l = this.length,\n          matched = [],\n          targets = typeof selectors !== \"string\" && jQuery(selectors); // Positional selectors never match, since there's no _selection_ context\n\n      if (!rneedsContext.test(selectors)) {\n        for (; i < l; i++) {\n          for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {\n            // Always skip document fragments\n            if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : // Don't pass non-elements to Sizzle\n            cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {\n              matched.push(cur);\n              break;\n            }\n          }\n        }\n      }\n\n      return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);\n    },\n    // Determine the position of an element within the set\n    index: function index(elem) {\n      // No argument, return index in parent\n      if (!elem) {\n        return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;\n      } // Index in selector\n\n\n      if (typeof elem === \"string\") {\n        return indexOf.call(jQuery(elem), this[0]);\n      } // Locate the position of the desired element\n\n\n      return indexOf.call(this, // If it receives a jQuery object, the first element is used\n      elem.jquery ? elem[0] : elem);\n    },\n    add: function add(selector, context) {\n      return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));\n    },\n    addBack: function addBack(selector) {\n      return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));\n    }\n  });\n\n  function sibling(cur, dir) {\n    while ((cur = cur[dir]) && cur.nodeType !== 1) {}\n\n    return cur;\n  }\n\n  jQuery.each({\n    parent: function parent(elem) {\n      var parent = elem.parentNode;\n      return parent && parent.nodeType !== 11 ? parent : null;\n    },\n    parents: function parents(elem) {\n      return dir(elem, \"parentNode\");\n    },\n    parentsUntil: function parentsUntil(elem, _i, until) {\n      return dir(elem, \"parentNode\", until);\n    },\n    next: function next(elem) {\n      return sibling(elem, \"nextSibling\");\n    },\n    prev: function prev(elem) {\n      return sibling(elem, \"previousSibling\");\n    },\n    nextAll: function nextAll(elem) {\n      return dir(elem, \"nextSibling\");\n    },\n    prevAll: function prevAll(elem) {\n      return dir(elem, \"previousSibling\");\n    },\n    nextUntil: function nextUntil(elem, _i, until) {\n      return dir(elem, \"nextSibling\", until);\n    },\n    prevUntil: function prevUntil(elem, _i, until) {\n      return dir(elem, \"previousSibling\", until);\n    },\n    siblings: function siblings(elem) {\n      return _siblings((elem.parentNode || {}).firstChild, elem);\n    },\n    children: function children(elem) {\n      return _siblings(elem.firstChild);\n    },\n    contents: function contents(elem) {\n      if (elem.contentDocument != null && // Support: IE 11+\n      // <object> elements with no `data` attribute has an object\n      // `contentDocument` with a `null` prototype.\n      getProto(elem.contentDocument)) {\n        return elem.contentDocument;\n      } // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only\n      // Treat the template element as a regular one in browsers that\n      // don't support it.\n\n\n      if (nodeName(elem, \"template\")) {\n        elem = elem.content || elem;\n      }\n\n      return jQuery.merge([], elem.childNodes);\n    }\n  }, function (name, fn) {\n    jQuery.fn[name] = function (until, selector) {\n      var matched = jQuery.map(this, fn, until);\n\n      if (name.slice(-5) !== \"Until\") {\n        selector = until;\n      }\n\n      if (selector && typeof selector === \"string\") {\n        matched = jQuery.filter(selector, matched);\n      }\n\n      if (this.length > 1) {\n        // Remove duplicates\n        if (!guaranteedUnique[name]) {\n          jQuery.uniqueSort(matched);\n        } // Reverse order for parents* and prev-derivatives\n\n\n        if (rparentsprev.test(name)) {\n          matched.reverse();\n        }\n      }\n\n      return this.pushStack(matched);\n    };\n  });\n  var rnothtmlwhite = /[^\\x20\\t\\r\\n\\f]+/g; // Convert String-formatted options into Object-formatted ones\n\n  function createOptions(options) {\n    var object = {};\n    jQuery.each(options.match(rnothtmlwhite) || [], function (_, flag) {\n      object[flag] = true;\n    });\n    return object;\n  }\n  /*\n   * Create a callback list using the following parameters:\n   *\n   *\toptions: an optional list of space-separated options that will change how\n   *\t\t\tthe callback list behaves or a more traditional option object\n   *\n   * By default a callback list will act like an event callback list and can be\n   * \"fired\" multiple times.\n   *\n   * Possible options:\n   *\n   *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n   *\n   *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n   *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n   *\t\t\t\t\tvalues (like a Deferred)\n   *\n   *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n   *\n   *\tstopOnFalse:\tinterrupt callings when a callback returns false\n   *\n   */\n\n\n  jQuery.Callbacks = function (options) {\n    // Convert options from String-formatted to Object-formatted if needed\n    // (we check in cache first)\n    options = typeof options === \"string\" ? createOptions(options) : jQuery.extend({}, options);\n\n    var // Flag to know if list is currently firing\n    firing,\n        // Last fire value for non-forgettable lists\n    memory,\n        // Flag to know if list was already fired\n    _fired,\n        // Flag to prevent firing\n    _locked,\n        // Actual callback list\n    list = [],\n        // Queue of execution data for repeatable lists\n    queue = [],\n        // Index of currently firing callback (modified by add/remove as needed)\n    firingIndex = -1,\n        // Fire callbacks\n    fire = function fire() {\n      // Enforce single-firing\n      _locked = _locked || options.once; // Execute callbacks for all pending executions,\n      // respecting firingIndex overrides and runtime changes\n\n      _fired = firing = true;\n\n      for (; queue.length; firingIndex = -1) {\n        memory = queue.shift();\n\n        while (++firingIndex < list.length) {\n          // Run callback and check for early termination\n          if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {\n            // Jump to end and forget the data so .add doesn't re-fire\n            firingIndex = list.length;\n            memory = false;\n          }\n        }\n      } // Forget the data if we're done with it\n\n\n      if (!options.memory) {\n        memory = false;\n      }\n\n      firing = false; // Clean up if we're done firing for good\n\n      if (_locked) {\n        // Keep an empty list if we have data for future add calls\n        if (memory) {\n          list = []; // Otherwise, this object is spent\n        } else {\n          list = \"\";\n        }\n      }\n    },\n        // Actual Callbacks object\n    self = {\n      // Add a callback or a collection of callbacks to the list\n      add: function add() {\n        if (list) {\n          // If we have memory from a past run, we should fire after adding\n          if (memory && !firing) {\n            firingIndex = list.length - 1;\n            queue.push(memory);\n          }\n\n          (function add(args) {\n            jQuery.each(args, function (_, arg) {\n              if (isFunction(arg)) {\n                if (!options.unique || !self.has(arg)) {\n                  list.push(arg);\n                }\n              } else if (arg && arg.length && toType(arg) !== \"string\") {\n                // Inspect recursively\n                add(arg);\n              }\n            });\n          })(arguments);\n\n          if (memory && !firing) {\n            fire();\n          }\n        }\n\n        return this;\n      },\n      // Remove a callback from the list\n      remove: function remove() {\n        jQuery.each(arguments, function (_, arg) {\n          var index;\n\n          while ((index = jQuery.inArray(arg, list, index)) > -1) {\n            list.splice(index, 1); // Handle firing indexes\n\n            if (index <= firingIndex) {\n              firingIndex--;\n            }\n          }\n        });\n        return this;\n      },\n      // Check if a given callback is in the list.\n      // If no argument is given, return whether or not list has callbacks attached.\n      has: function has(fn) {\n        return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;\n      },\n      // Remove all callbacks from the list\n      empty: function empty() {\n        if (list) {\n          list = [];\n        }\n\n        return this;\n      },\n      // Disable .fire and .add\n      // Abort any current/pending executions\n      // Clear all callbacks and values\n      disable: function disable() {\n        _locked = queue = [];\n        list = memory = \"\";\n        return this;\n      },\n      disabled: function disabled() {\n        return !list;\n      },\n      // Disable .fire\n      // Also disable .add unless we have memory (since it would have no effect)\n      // Abort any pending executions\n      lock: function lock() {\n        _locked = queue = [];\n\n        if (!memory && !firing) {\n          list = memory = \"\";\n        }\n\n        return this;\n      },\n      locked: function locked() {\n        return !!_locked;\n      },\n      // Call all callbacks with the given context and arguments\n      fireWith: function fireWith(context, args) {\n        if (!_locked) {\n          args = args || [];\n          args = [context, args.slice ? args.slice() : args];\n          queue.push(args);\n\n          if (!firing) {\n            fire();\n          }\n        }\n\n        return this;\n      },\n      // Call all the callbacks with the given arguments\n      fire: function fire() {\n        self.fireWith(this, arguments);\n        return this;\n      },\n      // To know if the callbacks have already been called at least once\n      fired: function fired() {\n        return !!_fired;\n      }\n    };\n\n    return self;\n  };\n\n  function Identity(v) {\n    return v;\n  }\n\n  function Thrower(ex) {\n    throw ex;\n  }\n\n  function adoptValue(value, resolve, reject, noValue) {\n    var method;\n\n    try {\n      // Check for promise aspect first to privilege synchronous behavior\n      if (value && isFunction(method = value.promise)) {\n        method.call(value).done(resolve).fail(reject); // Other thenables\n      } else if (value && isFunction(method = value.then)) {\n        method.call(value, resolve, reject); // Other non-thenables\n      } else {\n        // Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:\n        // * false: [ value ].slice( 0 ) => resolve( value )\n        // * true: [ value ].slice( 1 ) => resolve()\n        resolve.apply(undefined, [value].slice(noValue));\n      } // For Promises/A+, convert exceptions into rejections\n      // Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in\n      // Deferred#then to conditionally suppress rejection.\n\n    } catch (value) {\n      // Support: Android 4.0 only\n      // Strict mode functions invoked without .call/.apply get global-object context\n      reject.apply(undefined, [value]);\n    }\n  }\n\n  jQuery.extend({\n    Deferred: function Deferred(func) {\n      var tuples = [// action, add listener, callbacks,\n      // ... .then handlers, argument index, [final state]\n      [\"notify\", \"progress\", jQuery.Callbacks(\"memory\"), jQuery.Callbacks(\"memory\"), 2], [\"resolve\", \"done\", jQuery.Callbacks(\"once memory\"), jQuery.Callbacks(\"once memory\"), 0, \"resolved\"], [\"reject\", \"fail\", jQuery.Callbacks(\"once memory\"), jQuery.Callbacks(\"once memory\"), 1, \"rejected\"]],\n          _state = \"pending\",\n          _promise = {\n        state: function state() {\n          return _state;\n        },\n        always: function always() {\n          deferred.done(arguments).fail(arguments);\n          return this;\n        },\n        \"catch\": function _catch(fn) {\n          return _promise.then(null, fn);\n        },\n        // Keep pipe for back-compat\n        pipe: function pipe()\n        /* fnDone, fnFail, fnProgress */\n        {\n          var fns = arguments;\n          return jQuery.Deferred(function (newDefer) {\n            jQuery.each(tuples, function (_i, tuple) {\n              // Map tuples (progress, done, fail) to arguments (done, fail, progress)\n              var fn = isFunction(fns[tuple[4]]) && fns[tuple[4]]; // deferred.progress(function() { bind to newDefer or newDefer.notify })\n              // deferred.done(function() { bind to newDefer or newDefer.resolve })\n              // deferred.fail(function() { bind to newDefer or newDefer.reject })\n\n              deferred[tuple[1]](function () {\n                var returned = fn && fn.apply(this, arguments);\n\n                if (returned && isFunction(returned.promise)) {\n                  returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);\n                } else {\n                  newDefer[tuple[0] + \"With\"](this, fn ? [returned] : arguments);\n                }\n              });\n            });\n            fns = null;\n          }).promise();\n        },\n        then: function then(onFulfilled, onRejected, onProgress) {\n          var maxDepth = 0;\n\n          function resolve(depth, deferred, handler, special) {\n            return function () {\n              var that = this,\n                  args = arguments,\n                  mightThrow = function mightThrow() {\n                var returned, then; // Support: Promises/A+ section 2.3.3.3.3\n                // https://promisesaplus.com/#point-59\n                // Ignore double-resolution attempts\n\n                if (depth < maxDepth) {\n                  return;\n                }\n\n                returned = handler.apply(that, args); // Support: Promises/A+ section 2.3.1\n                // https://promisesaplus.com/#point-48\n\n                if (returned === deferred.promise()) {\n                  throw new TypeError(\"Thenable self-resolution\");\n                } // Support: Promises/A+ sections 2.3.3.1, 3.5\n                // https://promisesaplus.com/#point-54\n                // https://promisesaplus.com/#point-75\n                // Retrieve `then` only once\n\n\n                then = returned && ( // Support: Promises/A+ section 2.3.4\n                // https://promisesaplus.com/#point-64\n                // Only check objects and functions for thenability\n                _typeof(returned) === \"object\" || typeof returned === \"function\") && returned.then; // Handle a returned thenable\n\n                if (isFunction(then)) {\n                  // Special processors (notify) just wait for resolution\n                  if (special) {\n                    then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special)); // Normal processors (resolve) also hook into progress\n                  } else {\n                    // ...and disregard older resolution values\n                    maxDepth++;\n                    then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special), resolve(maxDepth, deferred, Identity, deferred.notifyWith));\n                  } // Handle all other returned values\n\n                } else {\n                  // Only substitute handlers pass on context\n                  // and multiple values (non-spec behavior)\n                  if (handler !== Identity) {\n                    that = undefined;\n                    args = [returned];\n                  } // Process the value(s)\n                  // Default process is resolve\n\n\n                  (special || deferred.resolveWith)(that, args);\n                }\n              },\n                  // Only normal processors (resolve) catch and reject exceptions\n              process = special ? mightThrow : function () {\n                try {\n                  mightThrow();\n                } catch (e) {\n                  if (jQuery.Deferred.exceptionHook) {\n                    jQuery.Deferred.exceptionHook(e, process.stackTrace);\n                  } // Support: Promises/A+ section 2.3.3.3.4.1\n                  // https://promisesaplus.com/#point-61\n                  // Ignore post-resolution exceptions\n\n\n                  if (depth + 1 >= maxDepth) {\n                    // Only substitute handlers pass on context\n                    // and multiple values (non-spec behavior)\n                    if (handler !== Thrower) {\n                      that = undefined;\n                      args = [e];\n                    }\n\n                    deferred.rejectWith(that, args);\n                  }\n                }\n              }; // Support: Promises/A+ section 2.3.3.3.1\n              // https://promisesaplus.com/#point-57\n              // Re-resolve promises immediately to dodge false rejection from\n              // subsequent errors\n\n\n              if (depth) {\n                process();\n              } else {\n                // Call an optional hook to record the stack, in case of exception\n                // since it's otherwise lost when execution goes async\n                if (jQuery.Deferred.getStackHook) {\n                  process.stackTrace = jQuery.Deferred.getStackHook();\n                }\n\n                window.setTimeout(process);\n              }\n            };\n          }\n\n          return jQuery.Deferred(function (newDefer) {\n            // progress_handlers.add( ... )\n            tuples[0][3].add(resolve(0, newDefer, isFunction(onProgress) ? onProgress : Identity, newDefer.notifyWith)); // fulfilled_handlers.add( ... )\n\n            tuples[1][3].add(resolve(0, newDefer, isFunction(onFulfilled) ? onFulfilled : Identity)); // rejected_handlers.add( ... )\n\n            tuples[2][3].add(resolve(0, newDefer, isFunction(onRejected) ? onRejected : Thrower));\n          }).promise();\n        },\n        // Get a promise for this deferred\n        // If obj is provided, the promise aspect is added to the object\n        promise: function promise(obj) {\n          return obj != null ? jQuery.extend(obj, _promise) : _promise;\n        }\n      },\n          deferred = {}; // Add list-specific methods\n\n      jQuery.each(tuples, function (i, tuple) {\n        var list = tuple[2],\n            stateString = tuple[5]; // promise.progress = list.add\n        // promise.done = list.add\n        // promise.fail = list.add\n\n        _promise[tuple[1]] = list.add; // Handle state\n\n        if (stateString) {\n          list.add(function () {\n            // state = \"resolved\" (i.e., fulfilled)\n            // state = \"rejected\"\n            _state = stateString;\n          }, // rejected_callbacks.disable\n          // fulfilled_callbacks.disable\n          tuples[3 - i][2].disable, // rejected_handlers.disable\n          // fulfilled_handlers.disable\n          tuples[3 - i][3].disable, // progress_callbacks.lock\n          tuples[0][2].lock, // progress_handlers.lock\n          tuples[0][3].lock);\n        } // progress_handlers.fire\n        // fulfilled_handlers.fire\n        // rejected_handlers.fire\n\n\n        list.add(tuple[3].fire); // deferred.notify = function() { deferred.notifyWith(...) }\n        // deferred.resolve = function() { deferred.resolveWith(...) }\n        // deferred.reject = function() { deferred.rejectWith(...) }\n\n        deferred[tuple[0]] = function () {\n          deferred[tuple[0] + \"With\"](this === deferred ? undefined : this, arguments);\n          return this;\n        }; // deferred.notifyWith = list.fireWith\n        // deferred.resolveWith = list.fireWith\n        // deferred.rejectWith = list.fireWith\n\n\n        deferred[tuple[0] + \"With\"] = list.fireWith;\n      }); // Make the deferred a promise\n\n      _promise.promise(deferred); // Call given func if any\n\n\n      if (func) {\n        func.call(deferred, deferred);\n      } // All done!\n\n\n      return deferred;\n    },\n    // Deferred helper\n    when: function when(singleValue) {\n      var // count of uncompleted subordinates\n      remaining = arguments.length,\n          // count of unprocessed arguments\n      i = remaining,\n          // subordinate fulfillment data\n      resolveContexts = Array(i),\n          resolveValues = _slice.call(arguments),\n          // the master Deferred\n      master = jQuery.Deferred(),\n          // subordinate callback factory\n      updateFunc = function updateFunc(i) {\n        return function (value) {\n          resolveContexts[i] = this;\n          resolveValues[i] = arguments.length > 1 ? _slice.call(arguments) : value;\n\n          if (! --remaining) {\n            master.resolveWith(resolveContexts, resolveValues);\n          }\n        };\n      }; // Single- and empty arguments are adopted like Promise.resolve\n\n\n      if (remaining <= 1) {\n        adoptValue(singleValue, master.done(updateFunc(i)).resolve, master.reject, !remaining); // Use .then() to unwrap secondary thenables (cf. gh-3000)\n\n        if (master.state() === \"pending\" || isFunction(resolveValues[i] && resolveValues[i].then)) {\n          return master.then();\n        }\n      } // Multiple arguments are aggregated like Promise.all array elements\n\n\n      while (i--) {\n        adoptValue(resolveValues[i], updateFunc(i), master.reject);\n      }\n\n      return master.promise();\n    }\n  }); // These usually indicate a programmer mistake during development,\n  // warn about them ASAP rather than swallowing them by default.\n\n  var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;\n\n  jQuery.Deferred.exceptionHook = function (error, stack) {\n    // Support: IE 8 - 9 only\n    // Console exists when dev tools are open, which can happen at any time\n    if (window.console && window.console.warn && error && rerrorNames.test(error.name)) {\n      window.console.warn(\"jQuery.Deferred exception: \" + error.message, error.stack, stack);\n    }\n  };\n\n  jQuery.readyException = function (error) {\n    window.setTimeout(function () {\n      throw error;\n    });\n  }; // The deferred used on DOM ready\n\n\n  var readyList = jQuery.Deferred();\n\n  jQuery.fn.ready = function (fn) {\n    readyList.then(fn) // Wrap jQuery.readyException in a function so that the lookup\n    // happens at the time of error handling instead of callback\n    // registration.\n    .catch(function (error) {\n      jQuery.readyException(error);\n    });\n    return this;\n  };\n\n  jQuery.extend({\n    // Is the DOM ready to be used? Set to true once it occurs.\n    isReady: false,\n    // A counter to track how many items to wait for before\n    // the ready event fires. See #6781\n    readyWait: 1,\n    // Handle when the DOM is ready\n    ready: function ready(wait) {\n      // Abort if there are pending holds or we're already ready\n      if (wait === true ? --jQuery.readyWait : jQuery.isReady) {\n        return;\n      } // Remember that the DOM is ready\n\n\n      jQuery.isReady = true; // If a normal DOM Ready event fired, decrement, and wait if need be\n\n      if (wait !== true && --jQuery.readyWait > 0) {\n        return;\n      } // If there are functions bound, to execute\n\n\n      readyList.resolveWith(document, [jQuery]);\n    }\n  });\n  jQuery.ready.then = readyList.then; // The ready event handler and self cleanup method\n\n  function completed() {\n    document.removeEventListener(\"DOMContentLoaded\", completed);\n    window.removeEventListener(\"load\", completed);\n    jQuery.ready();\n  } // Catch cases where $(document).ready() is called\n  // after the browser event has already occurred.\n  // Support: IE <=9 - 10 only\n  // Older IE sometimes signals \"interactive\" too soon\n\n\n  if (document.readyState === \"complete\" || document.readyState !== \"loading\" && !document.documentElement.doScroll) {\n    // Handle it asynchronously to allow scripts the opportunity to delay ready\n    window.setTimeout(jQuery.ready);\n  } else {\n    // Use the handy event callback\n    document.addEventListener(\"DOMContentLoaded\", completed); // A fallback to window.onload, that will always work\n\n    window.addEventListener(\"load\", completed);\n  } // Multifunctional method to get and set values of a collection\n  // The value/s can optionally be executed if it's a function\n\n\n  var access = function access(elems, fn, key, value, chainable, emptyGet, raw) {\n    var i = 0,\n        len = elems.length,\n        bulk = key == null; // Sets many values\n\n    if (toType(key) === \"object\") {\n      chainable = true;\n\n      for (i in key) {\n        access(elems, fn, i, key[i], true, emptyGet, raw);\n      } // Sets one value\n\n    } else if (value !== undefined) {\n      chainable = true;\n\n      if (!isFunction(value)) {\n        raw = true;\n      }\n\n      if (bulk) {\n        // Bulk operations run against the entire set\n        if (raw) {\n          fn.call(elems, value);\n          fn = null; // ...except when executing function values\n        } else {\n          bulk = fn;\n\n          fn = function fn(elem, _key, value) {\n            return bulk.call(jQuery(elem), value);\n          };\n        }\n      }\n\n      if (fn) {\n        for (; i < len; i++) {\n          fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));\n        }\n      }\n    }\n\n    if (chainable) {\n      return elems;\n    } // Gets\n\n\n    if (bulk) {\n      return fn.call(elems);\n    }\n\n    return len ? fn(elems[0], key) : emptyGet;\n  }; // Matches dashed string for camelizing\n\n\n  var rmsPrefix = /^-ms-/,\n      rdashAlpha = /-([a-z])/g; // Used by camelCase as callback to replace()\n\n  function fcamelCase(_all, letter) {\n    return letter.toUpperCase();\n  } // Convert dashed to camelCase; used by the css and data modules\n  // Support: IE <=9 - 11, Edge 12 - 15\n  // Microsoft forgot to hump their vendor prefix (#9572)\n\n\n  function camelCase(string) {\n    return string.replace(rmsPrefix, \"ms-\").replace(rdashAlpha, fcamelCase);\n  }\n\n  var acceptData = function acceptData(owner) {\n    // Accepts only:\n    //  - Node\n    //    - Node.ELEMENT_NODE\n    //    - Node.DOCUMENT_NODE\n    //  - Object\n    //    - Any\n    return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;\n  };\n\n  function Data() {\n    this.expando = jQuery.expando + Data.uid++;\n  }\n\n  Data.uid = 1;\n  Data.prototype = {\n    cache: function cache(owner) {\n      // Check if the owner object already has a cache\n      var value = owner[this.expando]; // If not, create one\n\n      if (!value) {\n        value = {}; // We can accept data for non-element nodes in modern browsers,\n        // but we should not, see #8335.\n        // Always return an empty object.\n\n        if (acceptData(owner)) {\n          // If it is a node unlikely to be stringify-ed or looped over\n          // use plain assignment\n          if (owner.nodeType) {\n            owner[this.expando] = value; // Otherwise secure it in a non-enumerable property\n            // configurable must be true to allow the property to be\n            // deleted when data is removed\n          } else {\n            Object.defineProperty(owner, this.expando, {\n              value: value,\n              configurable: true\n            });\n          }\n        }\n      }\n\n      return value;\n    },\n    set: function set(owner, data, value) {\n      var prop,\n          cache = this.cache(owner); // Handle: [ owner, key, value ] args\n      // Always use camelCase key (gh-2257)\n\n      if (typeof data === \"string\") {\n        cache[camelCase(data)] = value; // Handle: [ owner, { properties } ] args\n      } else {\n        // Copy the properties one-by-one to the cache object\n        for (prop in data) {\n          cache[camelCase(prop)] = data[prop];\n        }\n      }\n\n      return cache;\n    },\n    get: function get(owner, key) {\n      return key === undefined ? this.cache(owner) : // Always use camelCase key (gh-2257)\n      owner[this.expando] && owner[this.expando][camelCase(key)];\n    },\n    access: function access(owner, key, value) {\n      // In cases where either:\n      //\n      //   1. No key was specified\n      //   2. A string key was specified, but no value provided\n      //\n      // Take the \"read\" path and allow the get method to determine\n      // which value to return, respectively either:\n      //\n      //   1. The entire cache object\n      //   2. The data stored at the key\n      //\n      if (key === undefined || key && typeof key === \"string\" && value === undefined) {\n        return this.get(owner, key);\n      } // When the key is not a string, or both a key and value\n      // are specified, set or extend (existing objects) with either:\n      //\n      //   1. An object of properties\n      //   2. A key and value\n      //\n\n\n      this.set(owner, key, value); // Since the \"set\" path can have two possible entry points\n      // return the expected data based on which path was taken[*]\n\n      return value !== undefined ? value : key;\n    },\n    remove: function remove(owner, key) {\n      var i,\n          cache = owner[this.expando];\n\n      if (cache === undefined) {\n        return;\n      }\n\n      if (key !== undefined) {\n        // Support array or space separated string of keys\n        if (Array.isArray(key)) {\n          // If key is an array of keys...\n          // We always set camelCase keys, so remove that.\n          key = key.map(camelCase);\n        } else {\n          key = camelCase(key); // If a key with the spaces exists, use it.\n          // Otherwise, create an array by matching non-whitespace\n\n          key = key in cache ? [key] : key.match(rnothtmlwhite) || [];\n        }\n\n        i = key.length;\n\n        while (i--) {\n          delete cache[key[i]];\n        }\n      } // Remove the expando if there's no more data\n\n\n      if (key === undefined || jQuery.isEmptyObject(cache)) {\n        // Support: Chrome <=35 - 45\n        // Webkit & Blink performance suffers when deleting properties\n        // from DOM nodes, so set to undefined instead\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)\n        if (owner.nodeType) {\n          owner[this.expando] = undefined;\n        } else {\n          delete owner[this.expando];\n        }\n      }\n    },\n    hasData: function hasData(owner) {\n      var cache = owner[this.expando];\n      return cache !== undefined && !jQuery.isEmptyObject(cache);\n    }\n  };\n  var dataPriv = new Data();\n  var dataUser = new Data(); //\tImplementation Summary\n  //\n  //\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n  //\t2. Improve the module's maintainability by reducing the storage\n  //\t\tpaths to a single mechanism.\n  //\t3. Use the same single mechanism to support \"private\" and \"user\" data.\n  //\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\n  //\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n  //\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n\n  var rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n      rmultiDash = /[A-Z]/g;\n\n  function getData(data) {\n    if (data === \"true\") {\n      return true;\n    }\n\n    if (data === \"false\") {\n      return false;\n    }\n\n    if (data === \"null\") {\n      return null;\n    } // Only convert to a number if it doesn't change the string\n\n\n    if (data === +data + \"\") {\n      return +data;\n    }\n\n    if (rbrace.test(data)) {\n      return JSON.parse(data);\n    }\n\n    return data;\n  }\n\n  function dataAttr(elem, key, data) {\n    var name; // If nothing was found internally, try to fetch any\n    // data from the HTML5 data-* attribute\n\n    if (data === undefined && elem.nodeType === 1) {\n      name = \"data-\" + key.replace(rmultiDash, \"-$&\").toLowerCase();\n      data = elem.getAttribute(name);\n\n      if (typeof data === \"string\") {\n        try {\n          data = getData(data);\n        } catch (e) {} // Make sure we set the data so it isn't changed later\n\n\n        dataUser.set(elem, key, data);\n      } else {\n        data = undefined;\n      }\n    }\n\n    return data;\n  }\n\n  jQuery.extend({\n    hasData: function hasData(elem) {\n      return dataUser.hasData(elem) || dataPriv.hasData(elem);\n    },\n    data: function data(elem, name, _data) {\n      return dataUser.access(elem, name, _data);\n    },\n    removeData: function removeData(elem, name) {\n      dataUser.remove(elem, name);\n    },\n    // TODO: Now that all calls to _data and _removeData have been replaced\n    // with direct calls to dataPriv methods, these can be deprecated.\n    _data: function _data(elem, name, data) {\n      return dataPriv.access(elem, name, data);\n    },\n    _removeData: function _removeData(elem, name) {\n      dataPriv.remove(elem, name);\n    }\n  });\n  jQuery.fn.extend({\n    data: function data(key, value) {\n      var i,\n          name,\n          data,\n          elem = this[0],\n          attrs = elem && elem.attributes; // Gets all values\n\n      if (key === undefined) {\n        if (this.length) {\n          data = dataUser.get(elem);\n\n          if (elem.nodeType === 1 && !dataPriv.get(elem, \"hasDataAttrs\")) {\n            i = attrs.length;\n\n            while (i--) {\n              // Support: IE 11 only\n              // The attrs elements can be null (#14894)\n              if (attrs[i]) {\n                name = attrs[i].name;\n\n                if (name.indexOf(\"data-\") === 0) {\n                  name = camelCase(name.slice(5));\n                  dataAttr(elem, name, data[name]);\n                }\n              }\n            }\n\n            dataPriv.set(elem, \"hasDataAttrs\", true);\n          }\n        }\n\n        return data;\n      } // Sets multiple values\n\n\n      if (_typeof(key) === \"object\") {\n        return this.each(function () {\n          dataUser.set(this, key);\n        });\n      }\n\n      return access(this, function (value) {\n        var data; // The calling jQuery object (element matches) is not empty\n        // (and therefore has an element appears at this[ 0 ]) and the\n        // `value` parameter was not undefined. An empty jQuery object\n        // will result in `undefined` for elem = this[ 0 ] which will\n        // throw an exception if an attempt to read a data cache is made.\n\n        if (elem && value === undefined) {\n          // Attempt to get data from the cache\n          // The key will always be camelCased in Data\n          data = dataUser.get(elem, key);\n\n          if (data !== undefined) {\n            return data;\n          } // Attempt to \"discover\" the data in\n          // HTML5 custom data-* attrs\n\n\n          data = dataAttr(elem, key);\n\n          if (data !== undefined) {\n            return data;\n          } // We tried really hard, but the data doesn't exist.\n\n\n          return;\n        } // Set the data...\n\n\n        this.each(function () {\n          // We always store the camelCased key\n          dataUser.set(this, key, value);\n        });\n      }, null, value, arguments.length > 1, null, true);\n    },\n    removeData: function removeData(key) {\n      return this.each(function () {\n        dataUser.remove(this, key);\n      });\n    }\n  });\n  jQuery.extend({\n    queue: function queue(elem, type, data) {\n      var queue;\n\n      if (elem) {\n        type = (type || \"fx\") + \"queue\";\n        queue = dataPriv.get(elem, type); // Speed up dequeue by getting out quickly if this is just a lookup\n\n        if (data) {\n          if (!queue || Array.isArray(data)) {\n            queue = dataPriv.access(elem, type, jQuery.makeArray(data));\n          } else {\n            queue.push(data);\n          }\n        }\n\n        return queue || [];\n      }\n    },\n    dequeue: function dequeue(elem, type) {\n      type = type || \"fx\";\n\n      var queue = jQuery.queue(elem, type),\n          startLength = queue.length,\n          fn = queue.shift(),\n          hooks = jQuery._queueHooks(elem, type),\n          next = function next() {\n        jQuery.dequeue(elem, type);\n      }; // If the fx queue is dequeued, always remove the progress sentinel\n\n\n      if (fn === \"inprogress\") {\n        fn = queue.shift();\n        startLength--;\n      }\n\n      if (fn) {\n        // Add a progress sentinel to prevent the fx queue from being\n        // automatically dequeued\n        if (type === \"fx\") {\n          queue.unshift(\"inprogress\");\n        } // Clear up the last queue stop function\n\n\n        delete hooks.stop;\n        fn.call(elem, next, hooks);\n      }\n\n      if (!startLength && hooks) {\n        hooks.empty.fire();\n      }\n    },\n    // Not public - generate a queueHooks object, or return the current one\n    _queueHooks: function _queueHooks(elem, type) {\n      var key = type + \"queueHooks\";\n      return dataPriv.get(elem, key) || dataPriv.access(elem, key, {\n        empty: jQuery.Callbacks(\"once memory\").add(function () {\n          dataPriv.remove(elem, [type + \"queue\", key]);\n        })\n      });\n    }\n  });\n  jQuery.fn.extend({\n    queue: function queue(type, data) {\n      var setter = 2;\n\n      if (typeof type !== \"string\") {\n        data = type;\n        type = \"fx\";\n        setter--;\n      }\n\n      if (arguments.length < setter) {\n        return jQuery.queue(this[0], type);\n      }\n\n      return data === undefined ? this : this.each(function () {\n        var queue = jQuery.queue(this, type, data); // Ensure a hooks for this queue\n\n        jQuery._queueHooks(this, type);\n\n        if (type === \"fx\" && queue[0] !== \"inprogress\") {\n          jQuery.dequeue(this, type);\n        }\n      });\n    },\n    dequeue: function dequeue(type) {\n      return this.each(function () {\n        jQuery.dequeue(this, type);\n      });\n    },\n    clearQueue: function clearQueue(type) {\n      return this.queue(type || \"fx\", []);\n    },\n    // Get a promise resolved when queues of a certain type\n    // are emptied (fx is the type by default)\n    promise: function promise(type, obj) {\n      var tmp,\n          count = 1,\n          defer = jQuery.Deferred(),\n          elements = this,\n          i = this.length,\n          resolve = function resolve() {\n        if (! --count) {\n          defer.resolveWith(elements, [elements]);\n        }\n      };\n\n      if (typeof type !== \"string\") {\n        obj = type;\n        type = undefined;\n      }\n\n      type = type || \"fx\";\n\n      while (i--) {\n        tmp = dataPriv.get(elements[i], type + \"queueHooks\");\n\n        if (tmp && tmp.empty) {\n          count++;\n          tmp.empty.add(resolve);\n        }\n      }\n\n      resolve();\n      return defer.promise(obj);\n    }\n  });\n  var pnum = /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source;\n  var rcssNum = new RegExp(\"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\");\n  var cssExpand = [\"Top\", \"Right\", \"Bottom\", \"Left\"];\n  var documentElement = document.documentElement;\n\n  var isAttached = function isAttached(elem) {\n    return jQuery.contains(elem.ownerDocument, elem);\n  },\n      composed = {\n    composed: true\n  }; // Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only\n  // Check attachment across shadow DOM boundaries when possible (gh-3504)\n  // Support: iOS 10.0-10.2 only\n  // Early iOS 10 versions support `attachShadow` but not `getRootNode`,\n  // leading to errors. We need to check for `getRootNode`.\n\n\n  if (documentElement.getRootNode) {\n    isAttached = function isAttached(elem) {\n      return jQuery.contains(elem.ownerDocument, elem) || elem.getRootNode(composed) === elem.ownerDocument;\n    };\n  }\n\n  var isHiddenWithinTree = function isHiddenWithinTree(elem, el) {\n    // isHiddenWithinTree might be called from jQuery#filter function;\n    // in that case, element will be second argument\n    elem = el || elem; // Inline style trumps all\n\n    return elem.style.display === \"none\" || elem.style.display === \"\" && // Otherwise, check computed style\n    // Support: Firefox <=43 - 45\n    // Disconnected elements can have computed display: none, so first confirm that elem is\n    // in the document.\n    isAttached(elem) && jQuery.css(elem, \"display\") === \"none\";\n  };\n\n  function adjustCSS(elem, prop, valueParts, tween) {\n    var adjusted,\n        scale,\n        maxIterations = 20,\n        currentValue = tween ? function () {\n      return tween.cur();\n    } : function () {\n      return jQuery.css(elem, prop, \"\");\n    },\n        initial = currentValue(),\n        unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? \"\" : \"px\"),\n        // Starting value computation is required for potential unit mismatches\n    initialInUnit = elem.nodeType && (jQuery.cssNumber[prop] || unit !== \"px\" && +initial) && rcssNum.exec(jQuery.css(elem, prop));\n\n    if (initialInUnit && initialInUnit[3] !== unit) {\n      // Support: Firefox <=54\n      // Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)\n      initial = initial / 2; // Trust units reported by jQuery.css\n\n      unit = unit || initialInUnit[3]; // Iteratively approximate from a nonzero starting point\n\n      initialInUnit = +initial || 1;\n\n      while (maxIterations--) {\n        // Evaluate and update our best guess (doubling guesses that zero out).\n        // Finish if the scale equals or crosses 1 (making the old*new product non-positive).\n        jQuery.style(elem, prop, initialInUnit + unit);\n\n        if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {\n          maxIterations = 0;\n        }\n\n        initialInUnit = initialInUnit / scale;\n      }\n\n      initialInUnit = initialInUnit * 2;\n      jQuery.style(elem, prop, initialInUnit + unit); // Make sure we update the tween properties later on\n\n      valueParts = valueParts || [];\n    }\n\n    if (valueParts) {\n      initialInUnit = +initialInUnit || +initial || 0; // Apply relative offset (+=/-=) if specified\n\n      adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];\n\n      if (tween) {\n        tween.unit = unit;\n        tween.start = initialInUnit;\n        tween.end = adjusted;\n      }\n    }\n\n    return adjusted;\n  }\n\n  var defaultDisplayMap = {};\n\n  function getDefaultDisplay(elem) {\n    var temp,\n        doc = elem.ownerDocument,\n        nodeName = elem.nodeName,\n        display = defaultDisplayMap[nodeName];\n\n    if (display) {\n      return display;\n    }\n\n    temp = doc.body.appendChild(doc.createElement(nodeName));\n    display = jQuery.css(temp, \"display\");\n    temp.parentNode.removeChild(temp);\n\n    if (display === \"none\") {\n      display = \"block\";\n    }\n\n    defaultDisplayMap[nodeName] = display;\n    return display;\n  }\n\n  function showHide(elements, show) {\n    var display,\n        elem,\n        values = [],\n        index = 0,\n        length = elements.length; // Determine new display value for elements that need to change\n\n    for (; index < length; index++) {\n      elem = elements[index];\n\n      if (!elem.style) {\n        continue;\n      }\n\n      display = elem.style.display;\n\n      if (show) {\n        // Since we force visibility upon cascade-hidden elements, an immediate (and slow)\n        // check is required in this first loop unless we have a nonempty display value (either\n        // inline or about-to-be-restored)\n        if (display === \"none\") {\n          values[index] = dataPriv.get(elem, \"display\") || null;\n\n          if (!values[index]) {\n            elem.style.display = \"\";\n          }\n        }\n\n        if (elem.style.display === \"\" && isHiddenWithinTree(elem)) {\n          values[index] = getDefaultDisplay(elem);\n        }\n      } else {\n        if (display !== \"none\") {\n          values[index] = \"none\"; // Remember what we're overwriting\n\n          dataPriv.set(elem, \"display\", display);\n        }\n      }\n    } // Set the display of the elements in a second loop to avoid constant reflow\n\n\n    for (index = 0; index < length; index++) {\n      if (values[index] != null) {\n        elements[index].style.display = values[index];\n      }\n    }\n\n    return elements;\n  }\n\n  jQuery.fn.extend({\n    show: function show() {\n      return showHide(this, true);\n    },\n    hide: function hide() {\n      return showHide(this);\n    },\n    toggle: function toggle(state) {\n      if (typeof state === \"boolean\") {\n        return state ? this.show() : this.hide();\n      }\n\n      return this.each(function () {\n        if (isHiddenWithinTree(this)) {\n          jQuery(this).show();\n        } else {\n          jQuery(this).hide();\n        }\n      });\n    }\n  });\n  var rcheckableType = /^(?:checkbox|radio)$/i;\n  var rtagName = /<([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)/i;\n  var rscriptType = /^$|^module$|\\/(?:java|ecma)script/i;\n\n  (function () {\n    var fragment = document.createDocumentFragment(),\n        div = fragment.appendChild(document.createElement(\"div\")),\n        input = document.createElement(\"input\"); // Support: Android 4.0 - 4.3 only\n    // Check state lost if the name is set (#11217)\n    // Support: Windows Web Apps (WWA)\n    // `name` and `type` must use .setAttribute for WWA (#14901)\n\n    input.setAttribute(\"type\", \"radio\");\n    input.setAttribute(\"checked\", \"checked\");\n    input.setAttribute(\"name\", \"t\");\n    div.appendChild(input); // Support: Android <=4.1 only\n    // Older WebKit doesn't clone checked state correctly in fragments\n\n    support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked; // Support: IE <=11 only\n    // Make sure textarea (and checkbox) defaultValue is properly cloned\n\n    div.innerHTML = \"<textarea>x</textarea>\";\n    support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue; // Support: IE <=9 only\n    // IE <=9 replaces <option> tags with their contents when inserted outside of\n    // the select element.\n\n    div.innerHTML = \"<option></option>\";\n    support.option = !!div.lastChild;\n  })(); // We have to close these tags to support XHTML (#13200)\n\n\n  var wrapMap = {\n    // XHTML parsers do not magically insert elements in the\n    // same way that tag soup parsers do. So we cannot shorten\n    // this by omitting <tbody> or other required elements.\n    thead: [1, \"<table>\", \"</table>\"],\n    col: [2, \"<table><colgroup>\", \"</colgroup></table>\"],\n    tr: [2, \"<table><tbody>\", \"</tbody></table>\"],\n    td: [3, \"<table><tbody><tr>\", \"</tr></tbody></table>\"],\n    _default: [0, \"\", \"\"]\n  };\n  wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\n  wrapMap.th = wrapMap.td; // Support: IE <=9 only\n\n  if (!support.option) {\n    wrapMap.optgroup = wrapMap.option = [1, \"<select multiple='multiple'>\", \"</select>\"];\n  }\n\n  function getAll(context, tag) {\n    // Support: IE <=9 - 11 only\n    // Use typeof to avoid zero-argument method invocation on host objects (#15151)\n    var ret;\n\n    if (typeof context.getElementsByTagName !== \"undefined\") {\n      ret = context.getElementsByTagName(tag || \"*\");\n    } else if (typeof context.querySelectorAll !== \"undefined\") {\n      ret = context.querySelectorAll(tag || \"*\");\n    } else {\n      ret = [];\n    }\n\n    if (tag === undefined || tag && nodeName(context, tag)) {\n      return jQuery.merge([context], ret);\n    }\n\n    return ret;\n  } // Mark scripts as having already been evaluated\n\n\n  function setGlobalEval(elems, refElements) {\n    var i = 0,\n        l = elems.length;\n\n    for (; i < l; i++) {\n      dataPriv.set(elems[i], \"globalEval\", !refElements || dataPriv.get(refElements[i], \"globalEval\"));\n    }\n  }\n\n  var rhtml = /<|&#?\\w+;/;\n\n  function buildFragment(elems, context, scripts, selection, ignored) {\n    var elem,\n        tmp,\n        tag,\n        wrap,\n        attached,\n        j,\n        fragment = context.createDocumentFragment(),\n        nodes = [],\n        i = 0,\n        l = elems.length;\n\n    for (; i < l; i++) {\n      elem = elems[i];\n\n      if (elem || elem === 0) {\n        // Add nodes directly\n        if (toType(elem) === \"object\") {\n          // Support: Android <=4.0 only, PhantomJS 1 only\n          // push.apply(_, arraylike) throws on ancient WebKit\n          jQuery.merge(nodes, elem.nodeType ? [elem] : elem); // Convert non-html into a text node\n        } else if (!rhtml.test(elem)) {\n          nodes.push(context.createTextNode(elem)); // Convert html into DOM nodes\n        } else {\n          tmp = tmp || fragment.appendChild(context.createElement(\"div\")); // Deserialize a standard representation\n\n          tag = (rtagName.exec(elem) || [\"\", \"\"])[1].toLowerCase();\n          wrap = wrapMap[tag] || wrapMap._default;\n          tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2]; // Descend through wrappers to the right content\n\n          j = wrap[0];\n\n          while (j--) {\n            tmp = tmp.lastChild;\n          } // Support: Android <=4.0 only, PhantomJS 1 only\n          // push.apply(_, arraylike) throws on ancient WebKit\n\n\n          jQuery.merge(nodes, tmp.childNodes); // Remember the top-level container\n\n          tmp = fragment.firstChild; // Ensure the created nodes are orphaned (#12392)\n\n          tmp.textContent = \"\";\n        }\n      }\n    } // Remove wrapper from fragment\n\n\n    fragment.textContent = \"\";\n    i = 0;\n\n    while (elem = nodes[i++]) {\n      // Skip elements already in the context collection (trac-4087)\n      if (selection && jQuery.inArray(elem, selection) > -1) {\n        if (ignored) {\n          ignored.push(elem);\n        }\n\n        continue;\n      }\n\n      attached = isAttached(elem); // Append to fragment\n\n      tmp = getAll(fragment.appendChild(elem), \"script\"); // Preserve script evaluation history\n\n      if (attached) {\n        setGlobalEval(tmp);\n      } // Capture executables\n\n\n      if (scripts) {\n        j = 0;\n\n        while (elem = tmp[j++]) {\n          if (rscriptType.test(elem.type || \"\")) {\n            scripts.push(elem);\n          }\n        }\n      }\n    }\n\n    return fragment;\n  }\n\n  var rkeyEvent = /^key/,\n      rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,\n      rtypenamespace = /^([^.]*)(?:\\.(.+)|)/;\n\n  function returnTrue() {\n    return true;\n  }\n\n  function returnFalse() {\n    return false;\n  } // Support: IE <=9 - 11+\n  // focus() and blur() are asynchronous, except when they are no-op.\n  // So expect focus to be synchronous when the element is already active,\n  // and blur to be synchronous when the element is not already active.\n  // (focus and blur are always synchronous in other supported browsers,\n  // this just defines when we can count on it).\n\n\n  function expectSync(elem, type) {\n    return elem === safeActiveElement() === (type === \"focus\");\n  } // Support: IE <=9 only\n  // Accessing document.activeElement can throw unexpectedly\n  // https://bugs.jquery.com/ticket/13393\n\n\n  function safeActiveElement() {\n    try {\n      return document.activeElement;\n    } catch (err) {}\n  }\n\n  function _on(elem, types, selector, data, fn, one) {\n    var origFn, type; // Types can be a map of types/handlers\n\n    if (_typeof(types) === \"object\") {\n      // ( types-Object, selector, data )\n      if (typeof selector !== \"string\") {\n        // ( types-Object, data )\n        data = data || selector;\n        selector = undefined;\n      }\n\n      for (type in types) {\n        _on(elem, type, selector, data, types[type], one);\n      }\n\n      return elem;\n    }\n\n    if (data == null && fn == null) {\n      // ( types, fn )\n      fn = selector;\n      data = selector = undefined;\n    } else if (fn == null) {\n      if (typeof selector === \"string\") {\n        // ( types, selector, fn )\n        fn = data;\n        data = undefined;\n      } else {\n        // ( types, data, fn )\n        fn = data;\n        data = selector;\n        selector = undefined;\n      }\n    }\n\n    if (fn === false) {\n      fn = returnFalse;\n    } else if (!fn) {\n      return elem;\n    }\n\n    if (one === 1) {\n      origFn = fn;\n\n      fn = function fn(event) {\n        // Can use an empty set, since event contains the info\n        jQuery().off(event);\n        return origFn.apply(this, arguments);\n      }; // Use same guid so caller can remove using origFn\n\n\n      fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);\n    }\n\n    return elem.each(function () {\n      jQuery.event.add(this, types, fn, data, selector);\n    });\n  }\n  /*\n   * Helper functions for managing events -- not part of the public interface.\n   * Props to Dean Edwards' addEvent library for many of the ideas.\n   */\n\n\n  jQuery.event = {\n    global: {},\n    add: function add(elem, types, handler, data, selector) {\n      var handleObjIn,\n          eventHandle,\n          tmp,\n          events,\n          t,\n          handleObj,\n          special,\n          handlers,\n          type,\n          namespaces,\n          origType,\n          elemData = dataPriv.get(elem); // Only attach events to objects that accept data\n\n      if (!acceptData(elem)) {\n        return;\n      } // Caller can pass in an object of custom data in lieu of the handler\n\n\n      if (handler.handler) {\n        handleObjIn = handler;\n        handler = handleObjIn.handler;\n        selector = handleObjIn.selector;\n      } // Ensure that invalid selectors throw exceptions at attach time\n      // Evaluate against documentElement in case elem is a non-element node (e.g., document)\n\n\n      if (selector) {\n        jQuery.find.matchesSelector(documentElement, selector);\n      } // Make sure that the handler has a unique ID, used to find/remove it later\n\n\n      if (!handler.guid) {\n        handler.guid = jQuery.guid++;\n      } // Init the element's event structure and main handler, if this is the first\n\n\n      if (!(events = elemData.events)) {\n        events = elemData.events = Object.create(null);\n      }\n\n      if (!(eventHandle = elemData.handle)) {\n        eventHandle = elemData.handle = function (e) {\n          // Discard the second event of a jQuery.event.trigger() and\n          // when an event is called after a page has unloaded\n          return typeof jQuery !== \"undefined\" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;\n        };\n      } // Handle multiple events separated by a space\n\n\n      types = (types || \"\").match(rnothtmlwhite) || [\"\"];\n      t = types.length;\n\n      while (t--) {\n        tmp = rtypenamespace.exec(types[t]) || [];\n        type = origType = tmp[1];\n        namespaces = (tmp[2] || \"\").split(\".\").sort(); // There *must* be a type, no attaching namespace-only handlers\n\n        if (!type) {\n          continue;\n        } // If event changes its type, use the special event handlers for the changed type\n\n\n        special = jQuery.event.special[type] || {}; // If selector defined, determine special event api type, otherwise given type\n\n        type = (selector ? special.delegateType : special.bindType) || type; // Update special based on newly reset type\n\n        special = jQuery.event.special[type] || {}; // handleObj is passed to all event handlers\n\n        handleObj = jQuery.extend({\n          type: type,\n          origType: origType,\n          data: data,\n          handler: handler,\n          guid: handler.guid,\n          selector: selector,\n          needsContext: selector && jQuery.expr.match.needsContext.test(selector),\n          namespace: namespaces.join(\".\")\n        }, handleObjIn); // Init the event handler queue if we're the first\n\n        if (!(handlers = events[type])) {\n          handlers = events[type] = [];\n          handlers.delegateCount = 0; // Only use addEventListener if the special events handler returns false\n\n          if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {\n            if (elem.addEventListener) {\n              elem.addEventListener(type, eventHandle);\n            }\n          }\n        }\n\n        if (special.add) {\n          special.add.call(elem, handleObj);\n\n          if (!handleObj.handler.guid) {\n            handleObj.handler.guid = handler.guid;\n          }\n        } // Add to the element's handler list, delegates in front\n\n\n        if (selector) {\n          handlers.splice(handlers.delegateCount++, 0, handleObj);\n        } else {\n          handlers.push(handleObj);\n        } // Keep track of which events have ever been used, for event optimization\n\n\n        jQuery.event.global[type] = true;\n      }\n    },\n    // Detach an event or set of events from an element\n    remove: function remove(elem, types, handler, selector, mappedTypes) {\n      var j,\n          origCount,\n          tmp,\n          events,\n          t,\n          handleObj,\n          special,\n          handlers,\n          type,\n          namespaces,\n          origType,\n          elemData = dataPriv.hasData(elem) && dataPriv.get(elem);\n\n      if (!elemData || !(events = elemData.events)) {\n        return;\n      } // Once for each type.namespace in types; type may be omitted\n\n\n      types = (types || \"\").match(rnothtmlwhite) || [\"\"];\n      t = types.length;\n\n      while (t--) {\n        tmp = rtypenamespace.exec(types[t]) || [];\n        type = origType = tmp[1];\n        namespaces = (tmp[2] || \"\").split(\".\").sort(); // Unbind all events (on this namespace, if provided) for the element\n\n        if (!type) {\n          for (type in events) {\n            jQuery.event.remove(elem, type + types[t], handler, selector, true);\n          }\n\n          continue;\n        }\n\n        special = jQuery.event.special[type] || {};\n        type = (selector ? special.delegateType : special.bindType) || type;\n        handlers = events[type] || [];\n        tmp = tmp[2] && new RegExp(\"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\"); // Remove matching events\n\n        origCount = j = handlers.length;\n\n        while (j--) {\n          handleObj = handlers[j];\n\n          if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === \"**\" && handleObj.selector)) {\n            handlers.splice(j, 1);\n\n            if (handleObj.selector) {\n              handlers.delegateCount--;\n            }\n\n            if (special.remove) {\n              special.remove.call(elem, handleObj);\n            }\n          }\n        } // Remove generic event handler if we removed something and no more handlers exist\n        // (avoids potential for endless recursion during removal of special event handlers)\n\n\n        if (origCount && !handlers.length) {\n          if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {\n            jQuery.removeEvent(elem, type, elemData.handle);\n          }\n\n          delete events[type];\n        }\n      } // Remove data and the expando if it's no longer used\n\n\n      if (jQuery.isEmptyObject(events)) {\n        dataPriv.remove(elem, \"handle events\");\n      }\n    },\n    dispatch: function dispatch(nativeEvent) {\n      var i,\n          j,\n          ret,\n          matched,\n          handleObj,\n          handlerQueue,\n          args = new Array(arguments.length),\n          // Make a writable jQuery.Event from the native event object\n      event = jQuery.event.fix(nativeEvent),\n          handlers = (dataPriv.get(this, \"events\") || Object.create(null))[event.type] || [],\n          special = jQuery.event.special[event.type] || {}; // Use the fix-ed jQuery.Event rather than the (read-only) native event\n\n      args[0] = event;\n\n      for (i = 1; i < arguments.length; i++) {\n        args[i] = arguments[i];\n      }\n\n      event.delegateTarget = this; // Call the preDispatch hook for the mapped type, and let it bail if desired\n\n      if (special.preDispatch && special.preDispatch.call(this, event) === false) {\n        return;\n      } // Determine handlers\n\n\n      handlerQueue = jQuery.event.handlers.call(this, event, handlers); // Run delegates first; they may want to stop propagation beneath us\n\n      i = 0;\n\n      while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {\n        event.currentTarget = matched.elem;\n        j = 0;\n\n        while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {\n          // If the event is namespaced, then each handler is only invoked if it is\n          // specially universal or its namespaces are a superset of the event's.\n          if (!event.rnamespace || handleObj.namespace === false || event.rnamespace.test(handleObj.namespace)) {\n            event.handleObj = handleObj;\n            event.data = handleObj.data;\n            ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);\n\n            if (ret !== undefined) {\n              if ((event.result = ret) === false) {\n                event.preventDefault();\n                event.stopPropagation();\n              }\n            }\n          }\n        }\n      } // Call the postDispatch hook for the mapped type\n\n\n      if (special.postDispatch) {\n        special.postDispatch.call(this, event);\n      }\n\n      return event.result;\n    },\n    handlers: function handlers(event, _handlers) {\n      var i,\n          handleObj,\n          sel,\n          matchedHandlers,\n          matchedSelectors,\n          handlerQueue = [],\n          delegateCount = _handlers.delegateCount,\n          cur = event.target; // Find delegate handlers\n\n      if (delegateCount && // Support: IE <=9\n      // Black-hole SVG <use> instance trees (trac-13180)\n      cur.nodeType && // Support: Firefox <=42\n      // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\n      // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\n      // Support: IE 11 only\n      // ...but not arrow key \"clicks\" of radio inputs, which can have `button` -1 (gh-2343)\n      !(event.type === \"click\" && event.button >= 1)) {\n        for (; cur !== this; cur = cur.parentNode || this) {\n          // Don't check non-elements (#13208)\n          // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n          if (cur.nodeType === 1 && !(event.type === \"click\" && cur.disabled === true)) {\n            matchedHandlers = [];\n            matchedSelectors = {};\n\n            for (i = 0; i < delegateCount; i++) {\n              handleObj = _handlers[i]; // Don't conflict with Object.prototype properties (#13203)\n\n              sel = handleObj.selector + \" \";\n\n              if (matchedSelectors[sel] === undefined) {\n                matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;\n              }\n\n              if (matchedSelectors[sel]) {\n                matchedHandlers.push(handleObj);\n              }\n            }\n\n            if (matchedHandlers.length) {\n              handlerQueue.push({\n                elem: cur,\n                handlers: matchedHandlers\n              });\n            }\n          }\n        }\n      } // Add the remaining (directly-bound) handlers\n\n\n      cur = this;\n\n      if (delegateCount < _handlers.length) {\n        handlerQueue.push({\n          elem: cur,\n          handlers: _handlers.slice(delegateCount)\n        });\n      }\n\n      return handlerQueue;\n    },\n    addProp: function addProp(name, hook) {\n      Object.defineProperty(jQuery.Event.prototype, name, {\n        enumerable: true,\n        configurable: true,\n        get: isFunction(hook) ? function () {\n          if (this.originalEvent) {\n            return hook(this.originalEvent);\n          }\n        } : function () {\n          if (this.originalEvent) {\n            return this.originalEvent[name];\n          }\n        },\n        set: function set(value) {\n          Object.defineProperty(this, name, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: value\n          });\n        }\n      });\n    },\n    fix: function fix(originalEvent) {\n      return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);\n    },\n    special: {\n      load: {\n        // Prevent triggered image.load events from bubbling to window.load\n        noBubble: true\n      },\n      click: {\n        // Utilize native event to ensure correct state for checkable inputs\n        setup: function setup(data) {\n          // For mutual compressibility with _default, replace `this` access with a local var.\n          // `|| data` is dead code meant only to preserve the variable through minification.\n          var el = this || data; // Claim the first handler\n\n          if (rcheckableType.test(el.type) && el.click && nodeName(el, \"input\")) {\n            // dataPriv.set( el, \"click\", ... )\n            leverageNative(el, \"click\", returnTrue);\n          } // Return false to allow normal processing in the caller\n\n\n          return false;\n        },\n        trigger: function trigger(data) {\n          // For mutual compressibility with _default, replace `this` access with a local var.\n          // `|| data` is dead code meant only to preserve the variable through minification.\n          var el = this || data; // Force setup before triggering a click\n\n          if (rcheckableType.test(el.type) && el.click && nodeName(el, \"input\")) {\n            leverageNative(el, \"click\");\n          } // Return non-false to allow normal event-path propagation\n\n\n          return true;\n        },\n        // For cross-browser consistency, suppress native .click() on links\n        // Also prevent it if we're currently inside a leveraged native-event stack\n        _default: function _default(event) {\n          var target = event.target;\n          return rcheckableType.test(target.type) && target.click && nodeName(target, \"input\") && dataPriv.get(target, \"click\") || nodeName(target, \"a\");\n        }\n      },\n      beforeunload: {\n        postDispatch: function postDispatch(event) {\n          // Support: Firefox 20+\n          // Firefox doesn't alert if the returnValue field is not set.\n          if (event.result !== undefined && event.originalEvent) {\n            event.originalEvent.returnValue = event.result;\n          }\n        }\n      }\n    }\n  }; // Ensure the presence of an event listener that handles manually-triggered\n  // synthetic events by interrupting progress until reinvoked in response to\n  // *native* events that it fires directly, ensuring that state changes have\n  // already occurred before other listeners are invoked.\n\n  function leverageNative(el, type, expectSync) {\n    // Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add\n    if (!expectSync) {\n      if (dataPriv.get(el, type) === undefined) {\n        jQuery.event.add(el, type, returnTrue);\n      }\n\n      return;\n    } // Register the controller as a special universal handler for all event namespaces\n\n\n    dataPriv.set(el, type, false);\n    jQuery.event.add(el, type, {\n      namespace: false,\n      handler: function handler(event) {\n        var notAsync,\n            result,\n            saved = dataPriv.get(this, type);\n\n        if (event.isTrigger & 1 && this[type]) {\n          // Interrupt processing of the outer synthetic .trigger()ed event\n          // Saved data should be false in such cases, but might be a leftover capture object\n          // from an async native handler (gh-4350)\n          if (!saved.length) {\n            // Store arguments for use when handling the inner native event\n            // There will always be at least one argument (an event object), so this array\n            // will not be confused with a leftover capture object.\n            saved = _slice.call(arguments);\n            dataPriv.set(this, type, saved); // Trigger the native event and capture its result\n            // Support: IE <=9 - 11+\n            // focus() and blur() are asynchronous\n\n            notAsync = expectSync(this, type);\n            this[type]();\n            result = dataPriv.get(this, type);\n\n            if (saved !== result || notAsync) {\n              dataPriv.set(this, type, false);\n            } else {\n              result = {};\n            }\n\n            if (saved !== result) {\n              // Cancel the outer synthetic event\n              event.stopImmediatePropagation();\n              event.preventDefault();\n              return result.value;\n            } // If this is an inner synthetic event for an event with a bubbling surrogate\n            // (focus or blur), assume that the surrogate already propagated from triggering the\n            // native event and prevent that from happening again here.\n            // This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the\n            // bubbling surrogate propagates *after* the non-bubbling base), but that seems\n            // less bad than duplication.\n\n          } else if ((jQuery.event.special[type] || {}).delegateType) {\n            event.stopPropagation();\n          } // If this is a native event triggered above, everything is now in order\n          // Fire an inner synthetic event with the original arguments\n\n        } else if (saved.length) {\n          // ...and capture the result\n          dataPriv.set(this, type, {\n            value: jQuery.event.trigger( // Support: IE <=9 - 11+\n            // Extend with the prototype to reset the above stopImmediatePropagation()\n            jQuery.extend(saved[0], jQuery.Event.prototype), saved.slice(1), this)\n          }); // Abort handling of the native event\n\n          event.stopImmediatePropagation();\n        }\n      }\n    });\n  }\n\n  jQuery.removeEvent = function (elem, type, handle) {\n    // This \"if\" is needed for plain objects\n    if (elem.removeEventListener) {\n      elem.removeEventListener(type, handle);\n    }\n  };\n\n  jQuery.Event = function (src, props) {\n    // Allow instantiation without the 'new' keyword\n    if (!(this instanceof jQuery.Event)) {\n      return new jQuery.Event(src, props);\n    } // Event object\n\n\n    if (src && src.type) {\n      this.originalEvent = src;\n      this.type = src.type; // Events bubbling up the document may have been marked as prevented\n      // by a handler lower down the tree; reflect the correct value.\n\n      this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && // Support: Android <=2.3 only\n      src.returnValue === false ? returnTrue : returnFalse; // Create target properties\n      // Support: Safari <=6 - 7 only\n      // Target should not be a text node (#504, #13143)\n\n      this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;\n      this.currentTarget = src.currentTarget;\n      this.relatedTarget = src.relatedTarget; // Event type\n    } else {\n      this.type = src;\n    } // Put explicitly provided properties onto the event object\n\n\n    if (props) {\n      jQuery.extend(this, props);\n    } // Create a timestamp if incoming event doesn't have one\n\n\n    this.timeStamp = src && src.timeStamp || Date.now(); // Mark it as fixed\n\n    this[jQuery.expando] = true;\n  }; // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n  // https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\n\n\n  jQuery.Event.prototype = {\n    constructor: jQuery.Event,\n    isDefaultPrevented: returnFalse,\n    isPropagationStopped: returnFalse,\n    isImmediatePropagationStopped: returnFalse,\n    isSimulated: false,\n    preventDefault: function preventDefault() {\n      var e = this.originalEvent;\n      this.isDefaultPrevented = returnTrue;\n\n      if (e && !this.isSimulated) {\n        e.preventDefault();\n      }\n    },\n    stopPropagation: function stopPropagation() {\n      var e = this.originalEvent;\n      this.isPropagationStopped = returnTrue;\n\n      if (e && !this.isSimulated) {\n        e.stopPropagation();\n      }\n    },\n    stopImmediatePropagation: function stopImmediatePropagation() {\n      var e = this.originalEvent;\n      this.isImmediatePropagationStopped = returnTrue;\n\n      if (e && !this.isSimulated) {\n        e.stopImmediatePropagation();\n      }\n\n      this.stopPropagation();\n    }\n  }; // Includes all common event props including KeyEvent and MouseEvent specific props\n\n  jQuery.each({\n    altKey: true,\n    bubbles: true,\n    cancelable: true,\n    changedTouches: true,\n    ctrlKey: true,\n    detail: true,\n    eventPhase: true,\n    metaKey: true,\n    pageX: true,\n    pageY: true,\n    shiftKey: true,\n    view: true,\n    \"char\": true,\n    code: true,\n    charCode: true,\n    key: true,\n    keyCode: true,\n    button: true,\n    buttons: true,\n    clientX: true,\n    clientY: true,\n    offsetX: true,\n    offsetY: true,\n    pointerId: true,\n    pointerType: true,\n    screenX: true,\n    screenY: true,\n    targetTouches: true,\n    toElement: true,\n    touches: true,\n    which: function which(event) {\n      var button = event.button; // Add which for key events\n\n      if (event.which == null && rkeyEvent.test(event.type)) {\n        return event.charCode != null ? event.charCode : event.keyCode;\n      } // Add which for click: 1 === left; 2 === middle; 3 === right\n\n\n      if (!event.which && button !== undefined && rmouseEvent.test(event.type)) {\n        if (button & 1) {\n          return 1;\n        }\n\n        if (button & 2) {\n          return 3;\n        }\n\n        if (button & 4) {\n          return 2;\n        }\n\n        return 0;\n      }\n\n      return event.which;\n    }\n  }, jQuery.event.addProp);\n  jQuery.each({\n    focus: \"focusin\",\n    blur: \"focusout\"\n  }, function (type, delegateType) {\n    jQuery.event.special[type] = {\n      // Utilize native event if possible so blur/focus sequence is correct\n      setup: function setup() {\n        // Claim the first handler\n        // dataPriv.set( this, \"focus\", ... )\n        // dataPriv.set( this, \"blur\", ... )\n        leverageNative(this, type, expectSync); // Return false to allow normal processing in the caller\n\n        return false;\n      },\n      trigger: function trigger() {\n        // Force setup before trigger\n        leverageNative(this, type); // Return non-false to allow normal event-path propagation\n\n        return true;\n      },\n      delegateType: delegateType\n    };\n  }); // Create mouseenter/leave events using mouseover/out and event-time checks\n  // so that event delegation works in jQuery.\n  // Do the same for pointerenter/pointerleave and pointerover/pointerout\n  //\n  // Support: Safari 7 only\n  // Safari sends mouseenter too often; see:\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=470258\n  // for the description of the bug (it existed in older Chrome versions as well).\n\n  jQuery.each({\n    mouseenter: \"mouseover\",\n    mouseleave: \"mouseout\",\n    pointerenter: \"pointerover\",\n    pointerleave: \"pointerout\"\n  }, function (orig, fix) {\n    jQuery.event.special[orig] = {\n      delegateType: fix,\n      bindType: fix,\n      handle: function handle(event) {\n        var ret,\n            target = this,\n            related = event.relatedTarget,\n            handleObj = event.handleObj; // For mouseenter/leave call the handler if related is outside the target.\n        // NB: No relatedTarget if the mouse left/entered the browser window\n\n        if (!related || related !== target && !jQuery.contains(target, related)) {\n          event.type = handleObj.origType;\n          ret = handleObj.handler.apply(this, arguments);\n          event.type = fix;\n        }\n\n        return ret;\n      }\n    };\n  });\n  jQuery.fn.extend({\n    on: function on(types, selector, data, fn) {\n      return _on(this, types, selector, data, fn);\n    },\n    one: function one(types, selector, data, fn) {\n      return _on(this, types, selector, data, fn, 1);\n    },\n    off: function off(types, selector, fn) {\n      var handleObj, type;\n\n      if (types && types.preventDefault && types.handleObj) {\n        // ( event )  dispatched jQuery.Event\n        handleObj = types.handleObj;\n        jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + \".\" + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);\n        return this;\n      }\n\n      if (_typeof(types) === \"object\") {\n        // ( types-object [, selector] )\n        for (type in types) {\n          this.off(type, selector, types[type]);\n        }\n\n        return this;\n      }\n\n      if (selector === false || typeof selector === \"function\") {\n        // ( types [, fn] )\n        fn = selector;\n        selector = undefined;\n      }\n\n      if (fn === false) {\n        fn = returnFalse;\n      }\n\n      return this.each(function () {\n        jQuery.event.remove(this, types, fn, selector);\n      });\n    }\n  });\n  var // Support: IE <=10 - 11, Edge 12 - 13 only\n  // In IE/Edge using regex groups here causes severe slowdowns.\n  // See https://connect.microsoft.com/IE/feedback/details/1736512/\n  rnoInnerhtml = /<script|<style|<link/i,\n      // checked=\"checked\" or checked\n  rchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n      rcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g; // Prefer a tbody over its parent table for containing new rows\n\n  function manipulationTarget(elem, content) {\n    if (nodeName(elem, \"table\") && nodeName(content.nodeType !== 11 ? content : content.firstChild, \"tr\")) {\n      return jQuery(elem).children(\"tbody\")[0] || elem;\n    }\n\n    return elem;\n  } // Replace/restore the type attribute of script elements for safe DOM manipulation\n\n\n  function disableScript(elem) {\n    elem.type = (elem.getAttribute(\"type\") !== null) + \"/\" + elem.type;\n    return elem;\n  }\n\n  function restoreScript(elem) {\n    if ((elem.type || \"\").slice(0, 5) === \"true/\") {\n      elem.type = elem.type.slice(5);\n    } else {\n      elem.removeAttribute(\"type\");\n    }\n\n    return elem;\n  }\n\n  function cloneCopyEvent(src, dest) {\n    var i, l, type, pdataOld, udataOld, udataCur, events;\n\n    if (dest.nodeType !== 1) {\n      return;\n    } // 1. Copy private data: events, handlers, etc.\n\n\n    if (dataPriv.hasData(src)) {\n      pdataOld = dataPriv.get(src);\n      events = pdataOld.events;\n\n      if (events) {\n        dataPriv.remove(dest, \"handle events\");\n\n        for (type in events) {\n          for (i = 0, l = events[type].length; i < l; i++) {\n            jQuery.event.add(dest, type, events[type][i]);\n          }\n        }\n      }\n    } // 2. Copy user data\n\n\n    if (dataUser.hasData(src)) {\n      udataOld = dataUser.access(src);\n      udataCur = jQuery.extend({}, udataOld);\n      dataUser.set(dest, udataCur);\n    }\n  } // Fix IE bugs, see support tests\n\n\n  function fixInput(src, dest) {\n    var nodeName = dest.nodeName.toLowerCase(); // Fails to persist the checked state of a cloned checkbox or radio button.\n\n    if (nodeName === \"input\" && rcheckableType.test(src.type)) {\n      dest.checked = src.checked; // Fails to return the selected option to the default selected state when cloning options\n    } else if (nodeName === \"input\" || nodeName === \"textarea\") {\n      dest.defaultValue = src.defaultValue;\n    }\n  }\n\n  function domManip(collection, args, callback, ignored) {\n    // Flatten any nested arrays\n    args = flat(args);\n    var fragment,\n        first,\n        scripts,\n        hasScripts,\n        node,\n        doc,\n        i = 0,\n        l = collection.length,\n        iNoClone = l - 1,\n        value = args[0],\n        valueIsFunction = isFunction(value); // We can't cloneNode fragments that contain checked, in WebKit\n\n    if (valueIsFunction || l > 1 && typeof value === \"string\" && !support.checkClone && rchecked.test(value)) {\n      return collection.each(function (index) {\n        var self = collection.eq(index);\n\n        if (valueIsFunction) {\n          args[0] = value.call(this, index, self.html());\n        }\n\n        domManip(self, args, callback, ignored);\n      });\n    }\n\n    if (l) {\n      fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);\n      first = fragment.firstChild;\n\n      if (fragment.childNodes.length === 1) {\n        fragment = first;\n      } // Require either new content or an interest in ignored elements to invoke the callback\n\n\n      if (first || ignored) {\n        scripts = jQuery.map(getAll(fragment, \"script\"), disableScript);\n        hasScripts = scripts.length; // Use the original fragment for the last item\n        // instead of the first because it can end up\n        // being emptied incorrectly in certain situations (#8070).\n\n        for (; i < l; i++) {\n          node = fragment;\n\n          if (i !== iNoClone) {\n            node = jQuery.clone(node, true, true); // Keep references to cloned scripts for later restoration\n\n            if (hasScripts) {\n              // Support: Android <=4.0 only, PhantomJS 1 only\n              // push.apply(_, arraylike) throws on ancient WebKit\n              jQuery.merge(scripts, getAll(node, \"script\"));\n            }\n          }\n\n          callback.call(collection[i], node, i);\n        }\n\n        if (hasScripts) {\n          doc = scripts[scripts.length - 1].ownerDocument; // Reenable scripts\n\n          jQuery.map(scripts, restoreScript); // Evaluate executable scripts on first document insertion\n\n          for (i = 0; i < hasScripts; i++) {\n            node = scripts[i];\n\n            if (rscriptType.test(node.type || \"\") && !dataPriv.access(node, \"globalEval\") && jQuery.contains(doc, node)) {\n              if (node.src && (node.type || \"\").toLowerCase() !== \"module\") {\n                // Optional AJAX dependency, but won't run scripts if not present\n                if (jQuery._evalUrl && !node.noModule) {\n                  jQuery._evalUrl(node.src, {\n                    nonce: node.nonce || node.getAttribute(\"nonce\")\n                  }, doc);\n                }\n              } else {\n                DOMEval(node.textContent.replace(rcleanScript, \"\"), node, doc);\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return collection;\n  }\n\n  function _remove(elem, selector, keepData) {\n    var node,\n        nodes = selector ? jQuery.filter(selector, elem) : elem,\n        i = 0;\n\n    for (; (node = nodes[i]) != null; i++) {\n      if (!keepData && node.nodeType === 1) {\n        jQuery.cleanData(getAll(node));\n      }\n\n      if (node.parentNode) {\n        if (keepData && isAttached(node)) {\n          setGlobalEval(getAll(node, \"script\"));\n        }\n\n        node.parentNode.removeChild(node);\n      }\n    }\n\n    return elem;\n  }\n\n  jQuery.extend({\n    htmlPrefilter: function htmlPrefilter(html) {\n      return html;\n    },\n    clone: function clone(elem, dataAndEvents, deepDataAndEvents) {\n      var i,\n          l,\n          srcElements,\n          destElements,\n          clone = elem.cloneNode(true),\n          inPage = isAttached(elem); // Fix IE cloning issues\n\n      if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {\n        // We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2\n        destElements = getAll(clone);\n        srcElements = getAll(elem);\n\n        for (i = 0, l = srcElements.length; i < l; i++) {\n          fixInput(srcElements[i], destElements[i]);\n        }\n      } // Copy the events from the original to the clone\n\n\n      if (dataAndEvents) {\n        if (deepDataAndEvents) {\n          srcElements = srcElements || getAll(elem);\n          destElements = destElements || getAll(clone);\n\n          for (i = 0, l = srcElements.length; i < l; i++) {\n            cloneCopyEvent(srcElements[i], destElements[i]);\n          }\n        } else {\n          cloneCopyEvent(elem, clone);\n        }\n      } // Preserve script evaluation history\n\n\n      destElements = getAll(clone, \"script\");\n\n      if (destElements.length > 0) {\n        setGlobalEval(destElements, !inPage && getAll(elem, \"script\"));\n      } // Return the cloned set\n\n\n      return clone;\n    },\n    cleanData: function cleanData(elems) {\n      var data,\n          elem,\n          type,\n          special = jQuery.event.special,\n          i = 0;\n\n      for (; (elem = elems[i]) !== undefined; i++) {\n        if (acceptData(elem)) {\n          if (data = elem[dataPriv.expando]) {\n            if (data.events) {\n              for (type in data.events) {\n                if (special[type]) {\n                  jQuery.event.remove(elem, type); // This is a shortcut to avoid jQuery.event.remove's overhead\n                } else {\n                  jQuery.removeEvent(elem, type, data.handle);\n                }\n              }\n            } // Support: Chrome <=35 - 45+\n            // Assign undefined instead of using delete, see Data#remove\n\n\n            elem[dataPriv.expando] = undefined;\n          }\n\n          if (elem[dataUser.expando]) {\n            // Support: Chrome <=35 - 45+\n            // Assign undefined instead of using delete, see Data#remove\n            elem[dataUser.expando] = undefined;\n          }\n        }\n      }\n    }\n  });\n  jQuery.fn.extend({\n    detach: function detach(selector) {\n      return _remove(this, selector, true);\n    },\n    remove: function remove(selector) {\n      return _remove(this, selector);\n    },\n    text: function text(value) {\n      return access(this, function (value) {\n        return value === undefined ? jQuery.text(this) : this.empty().each(function () {\n          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\n            this.textContent = value;\n          }\n        });\n      }, null, value, arguments.length);\n    },\n    append: function append() {\n      return domManip(this, arguments, function (elem) {\n        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\n          var target = manipulationTarget(this, elem);\n          target.appendChild(elem);\n        }\n      });\n    },\n    prepend: function prepend() {\n      return domManip(this, arguments, function (elem) {\n        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\n          var target = manipulationTarget(this, elem);\n          target.insertBefore(elem, target.firstChild);\n        }\n      });\n    },\n    before: function before() {\n      return domManip(this, arguments, function (elem) {\n        if (this.parentNode) {\n          this.parentNode.insertBefore(elem, this);\n        }\n      });\n    },\n    after: function after() {\n      return domManip(this, arguments, function (elem) {\n        if (this.parentNode) {\n          this.parentNode.insertBefore(elem, this.nextSibling);\n        }\n      });\n    },\n    empty: function empty() {\n      var elem,\n          i = 0;\n\n      for (; (elem = this[i]) != null; i++) {\n        if (elem.nodeType === 1) {\n          // Prevent memory leaks\n          jQuery.cleanData(getAll(elem, false)); // Remove any remaining nodes\n\n          elem.textContent = \"\";\n        }\n      }\n\n      return this;\n    },\n    clone: function clone(dataAndEvents, deepDataAndEvents) {\n      dataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n      deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n      return this.map(function () {\n        return jQuery.clone(this, dataAndEvents, deepDataAndEvents);\n      });\n    },\n    html: function html(value) {\n      return access(this, function (value) {\n        var elem = this[0] || {},\n            i = 0,\n            l = this.length;\n\n        if (value === undefined && elem.nodeType === 1) {\n          return elem.innerHTML;\n        } // See if we can take a shortcut and just use innerHTML\n\n\n        if (typeof value === \"string\" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || [\"\", \"\"])[1].toLowerCase()]) {\n          value = jQuery.htmlPrefilter(value);\n\n          try {\n            for (; i < l; i++) {\n              elem = this[i] || {}; // Remove element nodes and prevent memory leaks\n\n              if (elem.nodeType === 1) {\n                jQuery.cleanData(getAll(elem, false));\n                elem.innerHTML = value;\n              }\n            }\n\n            elem = 0; // If using innerHTML throws an exception, use the fallback method\n          } catch (e) {}\n        }\n\n        if (elem) {\n          this.empty().append(value);\n        }\n      }, null, value, arguments.length);\n    },\n    replaceWith: function replaceWith() {\n      var ignored = []; // Make the changes, replacing each non-ignored context element with the new content\n\n      return domManip(this, arguments, function (elem) {\n        var parent = this.parentNode;\n\n        if (jQuery.inArray(this, ignored) < 0) {\n          jQuery.cleanData(getAll(this));\n\n          if (parent) {\n            parent.replaceChild(elem, this);\n          }\n        } // Force callback invocation\n\n      }, ignored);\n    }\n  });\n  jQuery.each({\n    appendTo: \"append\",\n    prependTo: \"prepend\",\n    insertBefore: \"before\",\n    insertAfter: \"after\",\n    replaceAll: \"replaceWith\"\n  }, function (name, original) {\n    jQuery.fn[name] = function (selector) {\n      var elems,\n          ret = [],\n          insert = jQuery(selector),\n          last = insert.length - 1,\n          i = 0;\n\n      for (; i <= last; i++) {\n        elems = i === last ? this : this.clone(true);\n        jQuery(insert[i])[original](elems); // Support: Android <=4.0 only, PhantomJS 1 only\n        // .get() because push.apply(_, arraylike) throws on ancient WebKit\n\n        push.apply(ret, elems.get());\n      }\n\n      return this.pushStack(ret);\n    };\n  });\n  var rnumnonpx = new RegExp(\"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\");\n\n  var getStyles = function getStyles(elem) {\n    // Support: IE <=11 only, Firefox <=30 (#15098, #14150)\n    // IE throws on elements created in popups\n    // FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n    var view = elem.ownerDocument.defaultView;\n\n    if (!view || !view.opener) {\n      view = window;\n    }\n\n    return view.getComputedStyle(elem);\n  };\n\n  var swap = function swap(elem, options, callback) {\n    var ret,\n        name,\n        old = {}; // Remember the old values, and insert the new ones\n\n    for (name in options) {\n      old[name] = elem.style[name];\n      elem.style[name] = options[name];\n    }\n\n    ret = callback.call(elem); // Revert the old values\n\n    for (name in options) {\n      elem.style[name] = old[name];\n    }\n\n    return ret;\n  };\n\n  var rboxStyle = new RegExp(cssExpand.join(\"|\"), \"i\");\n\n  (function () {\n    // Executing both pixelPosition & boxSizingReliable tests require only one layout\n    // so they're executed at the same time to save the second computation.\n    function computeStyleTests() {\n      // This is a singleton, we need to execute it only once\n      if (!div) {\n        return;\n      }\n\n      container.style.cssText = \"position:absolute;left:-11111px;width:60px;\" + \"margin-top:1px;padding:0;border:0\";\n      div.style.cssText = \"position:relative;display:block;box-sizing:border-box;overflow:scroll;\" + \"margin:auto;border:1px;padding:1px;\" + \"width:60%;top:1%\";\n      documentElement.appendChild(container).appendChild(div);\n      var divStyle = window.getComputedStyle(div);\n      pixelPositionVal = divStyle.top !== \"1%\"; // Support: Android 4.0 - 4.3 only, Firefox <=3 - 44\n\n      reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12; // Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3\n      // Some styles come back with percentage values, even though they shouldn't\n\n      div.style.right = \"60%\";\n      pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36; // Support: IE 9 - 11 only\n      // Detect misreporting of content dimensions for box-sizing:border-box elements\n\n      boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36; // Support: IE 9 only\n      // Detect overflow:scroll screwiness (gh-3699)\n      // Support: Chrome <=64\n      // Don't get tricked when zoom affects offsetWidth (gh-4029)\n\n      div.style.position = \"absolute\";\n      scrollboxSizeVal = roundPixelMeasures(div.offsetWidth / 3) === 12;\n      documentElement.removeChild(container); // Nullify the div so it wouldn't be stored in the memory and\n      // it will also be a sign that checks already performed\n\n      div = null;\n    }\n\n    function roundPixelMeasures(measure) {\n      return Math.round(parseFloat(measure));\n    }\n\n    var pixelPositionVal,\n        boxSizingReliableVal,\n        scrollboxSizeVal,\n        pixelBoxStylesVal,\n        reliableTrDimensionsVal,\n        reliableMarginLeftVal,\n        container = document.createElement(\"div\"),\n        div = document.createElement(\"div\"); // Finish early in limited (non-browser) environments\n\n    if (!div.style) {\n      return;\n    } // Support: IE <=9 - 11 only\n    // Style of cloned element affects source element cloned (#8908)\n\n\n    div.style.backgroundClip = \"content-box\";\n    div.cloneNode(true).style.backgroundClip = \"\";\n    support.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n    jQuery.extend(support, {\n      boxSizingReliable: function boxSizingReliable() {\n        computeStyleTests();\n        return boxSizingReliableVal;\n      },\n      pixelBoxStyles: function pixelBoxStyles() {\n        computeStyleTests();\n        return pixelBoxStylesVal;\n      },\n      pixelPosition: function pixelPosition() {\n        computeStyleTests();\n        return pixelPositionVal;\n      },\n      reliableMarginLeft: function reliableMarginLeft() {\n        computeStyleTests();\n        return reliableMarginLeftVal;\n      },\n      scrollboxSize: function scrollboxSize() {\n        computeStyleTests();\n        return scrollboxSizeVal;\n      },\n      // Support: IE 9 - 11+, Edge 15 - 18+\n      // IE/Edge misreport `getComputedStyle` of table rows with width/height\n      // set in CSS while `offset*` properties report correct values.\n      // Behavior in IE 9 is more subtle than in newer versions & it passes\n      // some versions of this test; make sure not to make it pass there!\n      reliableTrDimensions: function reliableTrDimensions() {\n        var table, tr, trChild, trStyle;\n\n        if (reliableTrDimensionsVal == null) {\n          table = document.createElement(\"table\");\n          tr = document.createElement(\"tr\");\n          trChild = document.createElement(\"div\");\n          table.style.cssText = \"position:absolute;left:-11111px\";\n          tr.style.height = \"1px\";\n          trChild.style.height = \"9px\";\n          documentElement.appendChild(table).appendChild(tr).appendChild(trChild);\n          trStyle = window.getComputedStyle(tr);\n          reliableTrDimensionsVal = parseInt(trStyle.height) > 3;\n          documentElement.removeChild(table);\n        }\n\n        return reliableTrDimensionsVal;\n      }\n    });\n  })();\n\n  function curCSS(elem, name, computed) {\n    var width,\n        minWidth,\n        maxWidth,\n        ret,\n        // Support: Firefox 51+\n    // Retrieving style before computed somehow\n    // fixes an issue with getting wrong values\n    // on detached elements\n    style = elem.style;\n    computed = computed || getStyles(elem); // getPropertyValue is needed for:\n    //   .css('filter') (IE 9 only, #12537)\n    //   .css('--customProperty) (#3144)\n\n    if (computed) {\n      ret = computed.getPropertyValue(name) || computed[name];\n\n      if (ret === \"\" && !isAttached(elem)) {\n        ret = jQuery.style(elem, name);\n      } // A tribute to the \"awesome hack by Dean Edwards\"\n      // Android Browser returns percentage for some values,\n      // but width seems to be reliably pixels.\n      // This is against the CSSOM draft spec:\n      // https://drafts.csswg.org/cssom/#resolved-values\n\n\n      if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {\n        // Remember the original values\n        width = style.width;\n        minWidth = style.minWidth;\n        maxWidth = style.maxWidth; // Put in the new values to get a computed value out\n\n        style.minWidth = style.maxWidth = style.width = ret;\n        ret = computed.width; // Revert the changed values\n\n        style.width = width;\n        style.minWidth = minWidth;\n        style.maxWidth = maxWidth;\n      }\n    }\n\n    return ret !== undefined ? // Support: IE <=9 - 11 only\n    // IE returns zIndex value as an integer.\n    ret + \"\" : ret;\n  }\n\n  function addGetHookIf(conditionFn, hookFn) {\n    // Define the hook, we'll check on the first run if it's really needed.\n    return {\n      get: function get() {\n        if (conditionFn()) {\n          // Hook not needed (or it's not possible to use it due\n          // to missing dependency), remove it.\n          delete this.get;\n          return;\n        } // Hook needed; redefine it so that the support test is not executed again.\n\n\n        return (this.get = hookFn).apply(this, arguments);\n      }\n    };\n  }\n\n  var cssPrefixes = [\"Webkit\", \"Moz\", \"ms\"],\n      emptyStyle = document.createElement(\"div\").style,\n      vendorProps = {}; // Return a vendor-prefixed property or undefined\n\n  function vendorPropName(name) {\n    // Check for vendor prefixed names\n    var capName = name[0].toUpperCase() + name.slice(1),\n        i = cssPrefixes.length;\n\n    while (i--) {\n      name = cssPrefixes[i] + capName;\n\n      if (name in emptyStyle) {\n        return name;\n      }\n    }\n  } // Return a potentially-mapped jQuery.cssProps or vendor prefixed property\n\n\n  function finalPropName(name) {\n    var final = jQuery.cssProps[name] || vendorProps[name];\n\n    if (final) {\n      return final;\n    }\n\n    if (name in emptyStyle) {\n      return name;\n    }\n\n    return vendorProps[name] = vendorPropName(name) || name;\n  }\n\n  var // Swappable if display is none or starts with table\n  // except \"table\", \"table-cell\", or \"table-caption\"\n  // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n  rdisplayswap = /^(none|table(?!-c[ea]).+)/,\n      rcustomProp = /^--/,\n      cssShow = {\n    position: \"absolute\",\n    visibility: \"hidden\",\n    display: \"block\"\n  },\n      cssNormalTransform = {\n    letterSpacing: \"0\",\n    fontWeight: \"400\"\n  };\n\n  function setPositiveNumber(_elem, value, subtract) {\n    // Any relative (+/-) values have already been\n    // normalized at this point\n    var matches = rcssNum.exec(value);\n    return matches ? // Guard against undefined \"subtract\", e.g., when used as in cssHooks\n    Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || \"px\") : value;\n  }\n\n  function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {\n    var i = dimension === \"width\" ? 1 : 0,\n        extra = 0,\n        delta = 0; // Adjustment may not be necessary\n\n    if (box === (isBorderBox ? \"border\" : \"content\")) {\n      return 0;\n    }\n\n    for (; i < 4; i += 2) {\n      // Both box models exclude margin\n      if (box === \"margin\") {\n        delta += jQuery.css(elem, box + cssExpand[i], true, styles);\n      } // If we get here with a content-box, we're seeking \"padding\" or \"border\" or \"margin\"\n\n\n      if (!isBorderBox) {\n        // Add padding\n        delta += jQuery.css(elem, \"padding\" + cssExpand[i], true, styles); // For \"border\" or \"margin\", add border\n\n        if (box !== \"padding\") {\n          delta += jQuery.css(elem, \"border\" + cssExpand[i] + \"Width\", true, styles); // But still keep track of it otherwise\n        } else {\n          extra += jQuery.css(elem, \"border\" + cssExpand[i] + \"Width\", true, styles);\n        } // If we get here with a border-box (content + padding + border), we're seeking \"content\" or\n        // \"padding\" or \"margin\"\n\n      } else {\n        // For \"content\", subtract padding\n        if (box === \"content\") {\n          delta -= jQuery.css(elem, \"padding\" + cssExpand[i], true, styles);\n        } // For \"content\" or \"padding\", subtract border\n\n\n        if (box !== \"margin\") {\n          delta -= jQuery.css(elem, \"border\" + cssExpand[i] + \"Width\", true, styles);\n        }\n      }\n    } // Account for positive content-box scroll gutter when requested by providing computedVal\n\n\n    if (!isBorderBox && computedVal >= 0) {\n      // offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border\n      // Assuming integer scroll gutter, subtract the rest and round down\n      delta += Math.max(0, Math.ceil(elem[\"offset\" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5 // If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter\n      // Use an explicit zero to avoid NaN (gh-3964)\n      )) || 0;\n    }\n\n    return delta;\n  }\n\n  function getWidthOrHeight(elem, dimension, extra) {\n    // Start with computed style\n    var styles = getStyles(elem),\n        // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).\n    // Fake content-box until we know it's needed to know the true value.\n    boxSizingNeeded = !support.boxSizingReliable() || extra,\n        isBorderBox = boxSizingNeeded && jQuery.css(elem, \"boxSizing\", false, styles) === \"border-box\",\n        valueIsBorderBox = isBorderBox,\n        val = curCSS(elem, dimension, styles),\n        offsetProp = \"offset\" + dimension[0].toUpperCase() + dimension.slice(1); // Support: Firefox <=54\n    // Return a confounding non-pixel value or feign ignorance, as appropriate.\n\n    if (rnumnonpx.test(val)) {\n      if (!extra) {\n        return val;\n      }\n\n      val = \"auto\";\n    } // Support: IE 9 - 11 only\n    // Use offsetWidth/offsetHeight for when box sizing is unreliable.\n    // In those cases, the computed value can be trusted to be border-box.\n\n\n    if ((!support.boxSizingReliable() && isBorderBox || // Support: IE 10 - 11+, Edge 15 - 18+\n    // IE/Edge misreport `getComputedStyle` of table rows with width/height\n    // set in CSS while `offset*` properties report correct values.\n    // Interestingly, in some cases IE 9 doesn't suffer from this issue.\n    !support.reliableTrDimensions() && nodeName(elem, \"tr\") || // Fall back to offsetWidth/offsetHeight when value is \"auto\"\n    // This happens for inline elements with no explicit setting (gh-3571)\n    val === \"auto\" || // Support: Android <=4.1 - 4.3 only\n    // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)\n    !parseFloat(val) && jQuery.css(elem, \"display\", false, styles) === \"inline\") && // Make sure the element is visible & connected\n    elem.getClientRects().length) {\n      isBorderBox = jQuery.css(elem, \"boxSizing\", false, styles) === \"border-box\"; // Where available, offsetWidth/offsetHeight approximate border box dimensions.\n      // Where not available (e.g., SVG), assume unreliable box-sizing and interpret the\n      // retrieved value as a content box dimension.\n\n      valueIsBorderBox = offsetProp in elem;\n\n      if (valueIsBorderBox) {\n        val = elem[offsetProp];\n      }\n    } // Normalize \"\" and auto\n\n\n    val = parseFloat(val) || 0; // Adjust for the element's box model\n\n    return val + boxModelAdjustment(elem, dimension, extra || (isBorderBox ? \"border\" : \"content\"), valueIsBorderBox, styles, // Provide the current computed size to request scroll gutter calculation (gh-3589)\n    val) + \"px\";\n  }\n\n  jQuery.extend({\n    // Add in style property hooks for overriding the default\n    // behavior of getting and setting a style property\n    cssHooks: {\n      opacity: {\n        get: function get(elem, computed) {\n          if (computed) {\n            // We should always get a number back from opacity\n            var ret = curCSS(elem, \"opacity\");\n            return ret === \"\" ? \"1\" : ret;\n          }\n        }\n      }\n    },\n    // Don't automatically add \"px\" to these possibly-unitless properties\n    cssNumber: {\n      \"animationIterationCount\": true,\n      \"columnCount\": true,\n      \"fillOpacity\": true,\n      \"flexGrow\": true,\n      \"flexShrink\": true,\n      \"fontWeight\": true,\n      \"gridArea\": true,\n      \"gridColumn\": true,\n      \"gridColumnEnd\": true,\n      \"gridColumnStart\": true,\n      \"gridRow\": true,\n      \"gridRowEnd\": true,\n      \"gridRowStart\": true,\n      \"lineHeight\": true,\n      \"opacity\": true,\n      \"order\": true,\n      \"orphans\": true,\n      \"widows\": true,\n      \"zIndex\": true,\n      \"zoom\": true\n    },\n    // Add in properties whose names you wish to fix before\n    // setting or getting the value\n    cssProps: {},\n    // Get and set the style property on a DOM Node\n    style: function style(elem, name, value, extra) {\n      // Don't set styles on text and comment nodes\n      if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {\n        return;\n      } // Make sure that we're working with the right name\n\n\n      var ret,\n          type,\n          hooks,\n          origName = camelCase(name),\n          isCustomProp = rcustomProp.test(name),\n          style = elem.style; // Make sure that we're working with the right name. We don't\n      // want to query the value if it is a CSS custom property\n      // since they are user-defined.\n\n      if (!isCustomProp) {\n        name = finalPropName(origName);\n      } // Gets hook for the prefixed version, then unprefixed version\n\n\n      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]; // Check if we're setting a value\n\n      if (value !== undefined) {\n        type = _typeof(value); // Convert \"+=\" or \"-=\" to relative numbers (#7345)\n\n        if (type === \"string\" && (ret = rcssNum.exec(value)) && ret[1]) {\n          value = adjustCSS(elem, name, ret); // Fixes bug #9237\n\n          type = \"number\";\n        } // Make sure that null and NaN values aren't set (#7116)\n\n\n        if (value == null || value !== value) {\n          return;\n        } // If a number was passed in, add the unit (except for certain CSS properties)\n        // The isCustomProp check can be removed in jQuery 4.0 when we only auto-append\n        // \"px\" to a few hardcoded values.\n\n\n        if (type === \"number\" && !isCustomProp) {\n          value += ret && ret[3] || (jQuery.cssNumber[origName] ? \"\" : \"px\");\n        } // background-* props affect original clone's values\n\n\n        if (!support.clearCloneStyle && value === \"\" && name.indexOf(\"background\") === 0) {\n          style[name] = \"inherit\";\n        } // If a hook was provided, use that value, otherwise just set the specified value\n\n\n        if (!hooks || !(\"set\" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {\n          if (isCustomProp) {\n            style.setProperty(name, value);\n          } else {\n            style[name] = value;\n          }\n        }\n      } else {\n        // If a hook was provided get the non-computed value from there\n        if (hooks && \"get\" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {\n          return ret;\n        } // Otherwise just get the value from the style object\n\n\n        return style[name];\n      }\n    },\n    css: function css(elem, name, extra, styles) {\n      var val,\n          num,\n          hooks,\n          origName = camelCase(name),\n          isCustomProp = rcustomProp.test(name); // Make sure that we're working with the right name. We don't\n      // want to modify the value if it is a CSS custom property\n      // since they are user-defined.\n\n      if (!isCustomProp) {\n        name = finalPropName(origName);\n      } // Try prefixed name followed by the unprefixed name\n\n\n      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]; // If a hook was provided get the computed value from there\n\n      if (hooks && \"get\" in hooks) {\n        val = hooks.get(elem, true, extra);\n      } // Otherwise, if a way to get the computed value exists, use that\n\n\n      if (val === undefined) {\n        val = curCSS(elem, name, styles);\n      } // Convert \"normal\" to computed value\n\n\n      if (val === \"normal\" && name in cssNormalTransform) {\n        val = cssNormalTransform[name];\n      } // Make numeric if forced or a qualifier was provided and val looks numeric\n\n\n      if (extra === \"\" || extra) {\n        num = parseFloat(val);\n        return extra === true || isFinite(num) ? num || 0 : val;\n      }\n\n      return val;\n    }\n  });\n  jQuery.each([\"height\", \"width\"], function (_i, dimension) {\n    jQuery.cssHooks[dimension] = {\n      get: function get(elem, computed, extra) {\n        if (computed) {\n          // Certain elements can have dimension info if we invisibly show them\n          // but it must have a current display style that would benefit\n          return rdisplayswap.test(jQuery.css(elem, \"display\")) && ( // Support: Safari 8+\n          // Table columns in Safari have non-zero offsetWidth & zero\n          // getBoundingClientRect().width unless display is changed.\n          // Support: IE <=11 only\n          // Running getBoundingClientRect on a disconnected node\n          // in IE throws an error.\n          !elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function () {\n            return getWidthOrHeight(elem, dimension, extra);\n          }) : getWidthOrHeight(elem, dimension, extra);\n        }\n      },\n      set: function set(elem, value, extra) {\n        var matches,\n            styles = getStyles(elem),\n            // Only read styles.position if the test has a chance to fail\n        // to avoid forcing a reflow.\n        scrollboxSizeBuggy = !support.scrollboxSize() && styles.position === \"absolute\",\n            // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)\n        boxSizingNeeded = scrollboxSizeBuggy || extra,\n            isBorderBox = boxSizingNeeded && jQuery.css(elem, \"boxSizing\", false, styles) === \"border-box\",\n            subtract = extra ? boxModelAdjustment(elem, dimension, extra, isBorderBox, styles) : 0; // Account for unreliable border-box dimensions by comparing offset* to computed and\n        // faking a content-box to get border and padding (gh-3699)\n\n        if (isBorderBox && scrollboxSizeBuggy) {\n          subtract -= Math.ceil(elem[\"offset\" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, \"border\", false, styles) - 0.5);\n        } // Convert to pixels if value adjustment is needed\n\n\n        if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || \"px\") !== \"px\") {\n          elem.style[dimension] = value;\n          value = jQuery.css(elem, dimension);\n        }\n\n        return setPositiveNumber(elem, value, subtract);\n      }\n    };\n  });\n  jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function (elem, computed) {\n    if (computed) {\n      return (parseFloat(curCSS(elem, \"marginLeft\")) || elem.getBoundingClientRect().left - swap(elem, {\n        marginLeft: 0\n      }, function () {\n        return elem.getBoundingClientRect().left;\n      })) + \"px\";\n    }\n  }); // These hooks are used by animate to expand properties\n\n  jQuery.each({\n    margin: \"\",\n    padding: \"\",\n    border: \"Width\"\n  }, function (prefix, suffix) {\n    jQuery.cssHooks[prefix + suffix] = {\n      expand: function expand(value) {\n        var i = 0,\n            expanded = {},\n            // Assumes a single number if not a string\n        parts = typeof value === \"string\" ? value.split(\" \") : [value];\n\n        for (; i < 4; i++) {\n          expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];\n        }\n\n        return expanded;\n      }\n    };\n\n    if (prefix !== \"margin\") {\n      jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;\n    }\n  });\n  jQuery.fn.extend({\n    css: function css(name, value) {\n      return access(this, function (elem, name, value) {\n        var styles,\n            len,\n            map = {},\n            i = 0;\n\n        if (Array.isArray(name)) {\n          styles = getStyles(elem);\n          len = name.length;\n\n          for (; i < len; i++) {\n            map[name[i]] = jQuery.css(elem, name[i], false, styles);\n          }\n\n          return map;\n        }\n\n        return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);\n      }, name, value, arguments.length > 1);\n    }\n  });\n\n  function Tween(elem, options, prop, end, easing) {\n    return new Tween.prototype.init(elem, options, prop, end, easing);\n  }\n\n  jQuery.Tween = Tween;\n  Tween.prototype = {\n    constructor: Tween,\n    init: function init(elem, options, prop, end, easing, unit) {\n      this.elem = elem;\n      this.prop = prop;\n      this.easing = easing || jQuery.easing._default;\n      this.options = options;\n      this.start = this.now = this.cur();\n      this.end = end;\n      this.unit = unit || (jQuery.cssNumber[prop] ? \"\" : \"px\");\n    },\n    cur: function cur() {\n      var hooks = Tween.propHooks[this.prop];\n      return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);\n    },\n    run: function run(percent) {\n      var eased,\n          hooks = Tween.propHooks[this.prop];\n\n      if (this.options.duration) {\n        this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);\n      } else {\n        this.pos = eased = percent;\n      }\n\n      this.now = (this.end - this.start) * eased + this.start;\n\n      if (this.options.step) {\n        this.options.step.call(this.elem, this.now, this);\n      }\n\n      if (hooks && hooks.set) {\n        hooks.set(this);\n      } else {\n        Tween.propHooks._default.set(this);\n      }\n\n      return this;\n    }\n  };\n  Tween.prototype.init.prototype = Tween.prototype;\n  Tween.propHooks = {\n    _default: {\n      get: function get(tween) {\n        var result; // Use a property on the element directly when it is not a DOM element,\n        // or when there is no matching style property that exists.\n\n        if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {\n          return tween.elem[tween.prop];\n        } // Passing an empty string as a 3rd parameter to .css will automatically\n        // attempt a parseFloat and fallback to a string if the parse fails.\n        // Simple values such as \"10px\" are parsed to Float;\n        // complex values such as \"rotate(1rad)\" are returned as-is.\n\n\n        result = jQuery.css(tween.elem, tween.prop, \"\"); // Empty strings, null, undefined and \"auto\" are converted to 0.\n\n        return !result || result === \"auto\" ? 0 : result;\n      },\n      set: function set(tween) {\n        // Use step hook for back compat.\n        // Use cssHook if its there.\n        // Use .style if available and use plain properties where available.\n        if (jQuery.fx.step[tween.prop]) {\n          jQuery.fx.step[tween.prop](tween);\n        } else if (tween.elem.nodeType === 1 && (jQuery.cssHooks[tween.prop] || tween.elem.style[finalPropName(tween.prop)] != null)) {\n          jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);\n        } else {\n          tween.elem[tween.prop] = tween.now;\n        }\n      }\n    }\n  }; // Support: IE <=9 only\n  // Panic based approach to setting things on disconnected nodes\n\n  Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n    set: function set(tween) {\n      if (tween.elem.nodeType && tween.elem.parentNode) {\n        tween.elem[tween.prop] = tween.now;\n      }\n    }\n  };\n  jQuery.easing = {\n    linear: function linear(p) {\n      return p;\n    },\n    swing: function swing(p) {\n      return 0.5 - Math.cos(p * Math.PI) / 2;\n    },\n    _default: \"swing\"\n  };\n  jQuery.fx = Tween.prototype.init; // Back compat <1.8 extension point\n\n  jQuery.fx.step = {};\n  var fxNow,\n      inProgress,\n      rfxtypes = /^(?:toggle|show|hide)$/,\n      rrun = /queueHooks$/;\n\n  function schedule() {\n    if (inProgress) {\n      if (document.hidden === false && window.requestAnimationFrame) {\n        window.requestAnimationFrame(schedule);\n      } else {\n        window.setTimeout(schedule, jQuery.fx.interval);\n      }\n\n      jQuery.fx.tick();\n    }\n  } // Animations created synchronously will run synchronously\n\n\n  function createFxNow() {\n    window.setTimeout(function () {\n      fxNow = undefined;\n    });\n    return fxNow = Date.now();\n  } // Generate parameters to create a standard animation\n\n\n  function genFx(type, includeWidth) {\n    var which,\n        i = 0,\n        attrs = {\n      height: type\n    }; // If we include width, step value is 1 to do all cssExpand values,\n    // otherwise step value is 2 to skip over Left and Right\n\n    includeWidth = includeWidth ? 1 : 0;\n\n    for (; i < 4; i += 2 - includeWidth) {\n      which = cssExpand[i];\n      attrs[\"margin\" + which] = attrs[\"padding\" + which] = type;\n    }\n\n    if (includeWidth) {\n      attrs.opacity = attrs.width = type;\n    }\n\n    return attrs;\n  }\n\n  function createTween(value, prop, animation) {\n    var tween,\n        collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners[\"*\"]),\n        index = 0,\n        length = collection.length;\n\n    for (; index < length; index++) {\n      if (tween = collection[index].call(animation, prop, value)) {\n        // We're done with this property\n        return tween;\n      }\n    }\n  }\n\n  function defaultPrefilter(elem, props, opts) {\n    var prop,\n        value,\n        toggle,\n        hooks,\n        oldfire,\n        propTween,\n        restoreDisplay,\n        display,\n        isBox = \"width\" in props || \"height\" in props,\n        anim = this,\n        orig = {},\n        style = elem.style,\n        hidden = elem.nodeType && isHiddenWithinTree(elem),\n        dataShow = dataPriv.get(elem, \"fxshow\"); // Queue-skipping animations hijack the fx hooks\n\n    if (!opts.queue) {\n      hooks = jQuery._queueHooks(elem, \"fx\");\n\n      if (hooks.unqueued == null) {\n        hooks.unqueued = 0;\n        oldfire = hooks.empty.fire;\n\n        hooks.empty.fire = function () {\n          if (!hooks.unqueued) {\n            oldfire();\n          }\n        };\n      }\n\n      hooks.unqueued++;\n      anim.always(function () {\n        // Ensure the complete handler is called before this completes\n        anim.always(function () {\n          hooks.unqueued--;\n\n          if (!jQuery.queue(elem, \"fx\").length) {\n            hooks.empty.fire();\n          }\n        });\n      });\n    } // Detect show/hide animations\n\n\n    for (prop in props) {\n      value = props[prop];\n\n      if (rfxtypes.test(value)) {\n        delete props[prop];\n        toggle = toggle || value === \"toggle\";\n\n        if (value === (hidden ? \"hide\" : \"show\")) {\n          // Pretend to be hidden if this is a \"show\" and\n          // there is still data from a stopped show/hide\n          if (value === \"show\" && dataShow && dataShow[prop] !== undefined) {\n            hidden = true; // Ignore all other no-op show/hide data\n          } else {\n            continue;\n          }\n        }\n\n        orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);\n      }\n    } // Bail out if this is a no-op like .hide().hide()\n\n\n    propTween = !jQuery.isEmptyObject(props);\n\n    if (!propTween && jQuery.isEmptyObject(orig)) {\n      return;\n    } // Restrict \"overflow\" and \"display\" styles during box animations\n\n\n    if (isBox && elem.nodeType === 1) {\n      // Support: IE <=9 - 11, Edge 12 - 15\n      // Record all 3 overflow attributes because IE does not infer the shorthand\n      // from identically-valued overflowX and overflowY and Edge just mirrors\n      // the overflowX value there.\n      opts.overflow = [style.overflow, style.overflowX, style.overflowY]; // Identify a display type, preferring old show/hide data over the CSS cascade\n\n      restoreDisplay = dataShow && dataShow.display;\n\n      if (restoreDisplay == null) {\n        restoreDisplay = dataPriv.get(elem, \"display\");\n      }\n\n      display = jQuery.css(elem, \"display\");\n\n      if (display === \"none\") {\n        if (restoreDisplay) {\n          display = restoreDisplay;\n        } else {\n          // Get nonempty value(s) by temporarily forcing visibility\n          showHide([elem], true);\n          restoreDisplay = elem.style.display || restoreDisplay;\n          display = jQuery.css(elem, \"display\");\n          showHide([elem]);\n        }\n      } // Animate inline elements as inline-block\n\n\n      if (display === \"inline\" || display === \"inline-block\" && restoreDisplay != null) {\n        if (jQuery.css(elem, \"float\") === \"none\") {\n          // Restore the original display value at the end of pure show/hide animations\n          if (!propTween) {\n            anim.done(function () {\n              style.display = restoreDisplay;\n            });\n\n            if (restoreDisplay == null) {\n              display = style.display;\n              restoreDisplay = display === \"none\" ? \"\" : display;\n            }\n          }\n\n          style.display = \"inline-block\";\n        }\n      }\n    }\n\n    if (opts.overflow) {\n      style.overflow = \"hidden\";\n      anim.always(function () {\n        style.overflow = opts.overflow[0];\n        style.overflowX = opts.overflow[1];\n        style.overflowY = opts.overflow[2];\n      });\n    } // Implement show/hide animations\n\n\n    propTween = false;\n\n    for (prop in orig) {\n      // General show/hide setup for this element animation\n      if (!propTween) {\n        if (dataShow) {\n          if (\"hidden\" in dataShow) {\n            hidden = dataShow.hidden;\n          }\n        } else {\n          dataShow = dataPriv.access(elem, \"fxshow\", {\n            display: restoreDisplay\n          });\n        } // Store hidden/visible for toggle so `.stop().toggle()` \"reverses\"\n\n\n        if (toggle) {\n          dataShow.hidden = !hidden;\n        } // Show elements before animating them\n\n\n        if (hidden) {\n          showHide([elem], true);\n        }\n        /* eslint-disable no-loop-func */\n\n\n        anim.done(function () {\n          /* eslint-enable no-loop-func */\n          // The final step of a \"hide\" animation is actually hiding the element\n          if (!hidden) {\n            showHide([elem]);\n          }\n\n          dataPriv.remove(elem, \"fxshow\");\n\n          for (prop in orig) {\n            jQuery.style(elem, prop, orig[prop]);\n          }\n        });\n      } // Per-property setup\n\n\n      propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);\n\n      if (!(prop in dataShow)) {\n        dataShow[prop] = propTween.start;\n\n        if (hidden) {\n          propTween.end = propTween.start;\n          propTween.start = 0;\n        }\n      }\n    }\n  }\n\n  function propFilter(props, specialEasing) {\n    var index, name, easing, value, hooks; // camelCase, specialEasing and expand cssHook pass\n\n    for (index in props) {\n      name = camelCase(index);\n      easing = specialEasing[name];\n      value = props[index];\n\n      if (Array.isArray(value)) {\n        easing = value[1];\n        value = props[index] = value[0];\n      }\n\n      if (index !== name) {\n        props[name] = value;\n        delete props[index];\n      }\n\n      hooks = jQuery.cssHooks[name];\n\n      if (hooks && \"expand\" in hooks) {\n        value = hooks.expand(value);\n        delete props[name]; // Not quite $.extend, this won't overwrite existing keys.\n        // Reusing 'index' because we have the correct \"name\"\n\n        for (index in value) {\n          if (!(index in props)) {\n            props[index] = value[index];\n            specialEasing[index] = easing;\n          }\n        }\n      } else {\n        specialEasing[name] = easing;\n      }\n    }\n  }\n\n  function Animation(elem, properties, options) {\n    var result,\n        stopped,\n        index = 0,\n        length = Animation.prefilters.length,\n        deferred = jQuery.Deferred().always(function () {\n      // Don't match elem in the :animated selector\n      delete tick.elem;\n    }),\n        tick = function tick() {\n      if (stopped) {\n        return false;\n      }\n\n      var currentTime = fxNow || createFxNow(),\n          remaining = Math.max(0, animation.startTime + animation.duration - currentTime),\n          // Support: Android 2.3 only\n      // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)\n      temp = remaining / animation.duration || 0,\n          percent = 1 - temp,\n          index = 0,\n          length = animation.tweens.length;\n\n      for (; index < length; index++) {\n        animation.tweens[index].run(percent);\n      }\n\n      deferred.notifyWith(elem, [animation, percent, remaining]); // If there's more to do, yield\n\n      if (percent < 1 && length) {\n        return remaining;\n      } // If this was an empty animation, synthesize a final progress notification\n\n\n      if (!length) {\n        deferred.notifyWith(elem, [animation, 1, 0]);\n      } // Resolve the animation and report its conclusion\n\n\n      deferred.resolveWith(elem, [animation]);\n      return false;\n    },\n        animation = deferred.promise({\n      elem: elem,\n      props: jQuery.extend({}, properties),\n      opts: jQuery.extend(true, {\n        specialEasing: {},\n        easing: jQuery.easing._default\n      }, options),\n      originalProperties: properties,\n      originalOptions: options,\n      startTime: fxNow || createFxNow(),\n      duration: options.duration,\n      tweens: [],\n      createTween: function createTween(prop, end) {\n        var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);\n        animation.tweens.push(tween);\n        return tween;\n      },\n      stop: function stop(gotoEnd) {\n        var index = 0,\n            // If we are going to the end, we want to run all the tweens\n        // otherwise we skip this part\n        length = gotoEnd ? animation.tweens.length : 0;\n\n        if (stopped) {\n          return this;\n        }\n\n        stopped = true;\n\n        for (; index < length; index++) {\n          animation.tweens[index].run(1);\n        } // Resolve when we played the last frame; otherwise, reject\n\n\n        if (gotoEnd) {\n          deferred.notifyWith(elem, [animation, 1, 0]);\n          deferred.resolveWith(elem, [animation, gotoEnd]);\n        } else {\n          deferred.rejectWith(elem, [animation, gotoEnd]);\n        }\n\n        return this;\n      }\n    }),\n        props = animation.props;\n\n    propFilter(props, animation.opts.specialEasing);\n\n    for (; index < length; index++) {\n      result = Animation.prefilters[index].call(animation, elem, props, animation.opts);\n\n      if (result) {\n        if (isFunction(result.stop)) {\n          jQuery._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);\n        }\n\n        return result;\n      }\n    }\n\n    jQuery.map(props, createTween, animation);\n\n    if (isFunction(animation.opts.start)) {\n      animation.opts.start.call(elem, animation);\n    } // Attach callbacks from options\n\n\n    animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);\n    jQuery.fx.timer(jQuery.extend(tick, {\n      elem: elem,\n      anim: animation,\n      queue: animation.opts.queue\n    }));\n    return animation;\n  }\n\n  jQuery.Animation = jQuery.extend(Animation, {\n    tweeners: {\n      \"*\": [function (prop, value) {\n        var tween = this.createTween(prop, value);\n        adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);\n        return tween;\n      }]\n    },\n    tweener: function tweener(props, callback) {\n      if (isFunction(props)) {\n        callback = props;\n        props = [\"*\"];\n      } else {\n        props = props.match(rnothtmlwhite);\n      }\n\n      var prop,\n          index = 0,\n          length = props.length;\n\n      for (; index < length; index++) {\n        prop = props[index];\n        Animation.tweeners[prop] = Animation.tweeners[prop] || [];\n        Animation.tweeners[prop].unshift(callback);\n      }\n    },\n    prefilters: [defaultPrefilter],\n    prefilter: function prefilter(callback, prepend) {\n      if (prepend) {\n        Animation.prefilters.unshift(callback);\n      } else {\n        Animation.prefilters.push(callback);\n      }\n    }\n  });\n\n  jQuery.speed = function (speed, easing, fn) {\n    var opt = speed && _typeof(speed) === \"object\" ? jQuery.extend({}, speed) : {\n      complete: fn || !fn && easing || isFunction(speed) && speed,\n      duration: speed,\n      easing: fn && easing || easing && !isFunction(easing) && easing\n    }; // Go to the end state if fx are off\n\n    if (jQuery.fx.off) {\n      opt.duration = 0;\n    } else {\n      if (typeof opt.duration !== \"number\") {\n        if (opt.duration in jQuery.fx.speeds) {\n          opt.duration = jQuery.fx.speeds[opt.duration];\n        } else {\n          opt.duration = jQuery.fx.speeds._default;\n        }\n      }\n    } // Normalize opt.queue - true/undefined/null -> \"fx\"\n\n\n    if (opt.queue == null || opt.queue === true) {\n      opt.queue = \"fx\";\n    } // Queueing\n\n\n    opt.old = opt.complete;\n\n    opt.complete = function () {\n      if (isFunction(opt.old)) {\n        opt.old.call(this);\n      }\n\n      if (opt.queue) {\n        jQuery.dequeue(this, opt.queue);\n      }\n    };\n\n    return opt;\n  };\n\n  jQuery.fn.extend({\n    fadeTo: function fadeTo(speed, to, easing, callback) {\n      // Show any hidden elements after setting opacity to 0\n      return this.filter(isHiddenWithinTree).css(\"opacity\", 0).show() // Animate to the value specified\n      .end().animate({\n        opacity: to\n      }, speed, easing, callback);\n    },\n    animate: function animate(prop, speed, easing, callback) {\n      var empty = jQuery.isEmptyObject(prop),\n          optall = jQuery.speed(speed, easing, callback),\n          doAnimation = function doAnimation() {\n        // Operate on a copy of prop so per-property easing won't be lost\n        var anim = Animation(this, jQuery.extend({}, prop), optall); // Empty animations, or finishing resolves immediately\n\n        if (empty || dataPriv.get(this, \"finish\")) {\n          anim.stop(true);\n        }\n      };\n\n      doAnimation.finish = doAnimation;\n      return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);\n    },\n    stop: function stop(type, clearQueue, gotoEnd) {\n      var stopQueue = function stopQueue(hooks) {\n        var stop = hooks.stop;\n        delete hooks.stop;\n        stop(gotoEnd);\n      };\n\n      if (typeof type !== \"string\") {\n        gotoEnd = clearQueue;\n        clearQueue = type;\n        type = undefined;\n      }\n\n      if (clearQueue) {\n        this.queue(type || \"fx\", []);\n      }\n\n      return this.each(function () {\n        var dequeue = true,\n            index = type != null && type + \"queueHooks\",\n            timers = jQuery.timers,\n            data = dataPriv.get(this);\n\n        if (index) {\n          if (data[index] && data[index].stop) {\n            stopQueue(data[index]);\n          }\n        } else {\n          for (index in data) {\n            if (data[index] && data[index].stop && rrun.test(index)) {\n              stopQueue(data[index]);\n            }\n          }\n        }\n\n        for (index = timers.length; index--;) {\n          if (timers[index].elem === this && (type == null || timers[index].queue === type)) {\n            timers[index].anim.stop(gotoEnd);\n            dequeue = false;\n            timers.splice(index, 1);\n          }\n        } // Start the next in the queue if the last step wasn't forced.\n        // Timers currently will call their complete callbacks, which\n        // will dequeue but only if they were gotoEnd.\n\n\n        if (dequeue || !gotoEnd) {\n          jQuery.dequeue(this, type);\n        }\n      });\n    },\n    finish: function finish(type) {\n      if (type !== false) {\n        type = type || \"fx\";\n      }\n\n      return this.each(function () {\n        var index,\n            data = dataPriv.get(this),\n            queue = data[type + \"queue\"],\n            hooks = data[type + \"queueHooks\"],\n            timers = jQuery.timers,\n            length = queue ? queue.length : 0; // Enable finishing flag on private data\n\n        data.finish = true; // Empty the queue first\n\n        jQuery.queue(this, type, []);\n\n        if (hooks && hooks.stop) {\n          hooks.stop.call(this, true);\n        } // Look for any active animations, and finish them\n\n\n        for (index = timers.length; index--;) {\n          if (timers[index].elem === this && timers[index].queue === type) {\n            timers[index].anim.stop(true);\n            timers.splice(index, 1);\n          }\n        } // Look for any animations in the old queue and finish them\n\n\n        for (index = 0; index < length; index++) {\n          if (queue[index] && queue[index].finish) {\n            queue[index].finish.call(this);\n          }\n        } // Turn off finishing flag\n\n\n        delete data.finish;\n      });\n    }\n  });\n  jQuery.each([\"toggle\", \"show\", \"hide\"], function (_i, name) {\n    var cssFn = jQuery.fn[name];\n\n    jQuery.fn[name] = function (speed, easing, callback) {\n      return speed == null || typeof speed === \"boolean\" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);\n    };\n  }); // Generate shortcuts for custom animations\n\n  jQuery.each({\n    slideDown: genFx(\"show\"),\n    slideUp: genFx(\"hide\"),\n    slideToggle: genFx(\"toggle\"),\n    fadeIn: {\n      opacity: \"show\"\n    },\n    fadeOut: {\n      opacity: \"hide\"\n    },\n    fadeToggle: {\n      opacity: \"toggle\"\n    }\n  }, function (name, props) {\n    jQuery.fn[name] = function (speed, easing, callback) {\n      return this.animate(props, speed, easing, callback);\n    };\n  });\n  jQuery.timers = [];\n\n  jQuery.fx.tick = function () {\n    var timer,\n        i = 0,\n        timers = jQuery.timers;\n    fxNow = Date.now();\n\n    for (; i < timers.length; i++) {\n      timer = timers[i]; // Run the timer and safely remove it when done (allowing for external removal)\n\n      if (!timer() && timers[i] === timer) {\n        timers.splice(i--, 1);\n      }\n    }\n\n    if (!timers.length) {\n      jQuery.fx.stop();\n    }\n\n    fxNow = undefined;\n  };\n\n  jQuery.fx.timer = function (timer) {\n    jQuery.timers.push(timer);\n    jQuery.fx.start();\n  };\n\n  jQuery.fx.interval = 13;\n\n  jQuery.fx.start = function () {\n    if (inProgress) {\n      return;\n    }\n\n    inProgress = true;\n    schedule();\n  };\n\n  jQuery.fx.stop = function () {\n    inProgress = null;\n  };\n\n  jQuery.fx.speeds = {\n    slow: 600,\n    fast: 200,\n    // Default speed\n    _default: 400\n  }; // Based off of the plugin by Clint Helfers, with permission.\n  // https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/\n\n  jQuery.fn.delay = function (time, type) {\n    time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;\n    type = type || \"fx\";\n    return this.queue(type, function (next, hooks) {\n      var timeout = window.setTimeout(next, time);\n\n      hooks.stop = function () {\n        window.clearTimeout(timeout);\n      };\n    });\n  };\n\n  (function () {\n    var input = document.createElement(\"input\"),\n        select = document.createElement(\"select\"),\n        opt = select.appendChild(document.createElement(\"option\"));\n    input.type = \"checkbox\"; // Support: Android <=4.3 only\n    // Default value for a checkbox should be \"on\"\n\n    support.checkOn = input.value !== \"\"; // Support: IE <=11 only\n    // Must access selectedIndex to make default options select\n\n    support.optSelected = opt.selected; // Support: IE <=11 only\n    // An input loses its value after becoming a radio\n\n    input = document.createElement(\"input\");\n    input.value = \"t\";\n    input.type = \"radio\";\n    support.radioValue = input.value === \"t\";\n  })();\n\n  var boolHook,\n      attrHandle = jQuery.expr.attrHandle;\n  jQuery.fn.extend({\n    attr: function attr(name, value) {\n      return access(this, jQuery.attr, name, value, arguments.length > 1);\n    },\n    removeAttr: function removeAttr(name) {\n      return this.each(function () {\n        jQuery.removeAttr(this, name);\n      });\n    }\n  });\n  jQuery.extend({\n    attr: function attr(elem, name, value) {\n      var ret,\n          hooks,\n          nType = elem.nodeType; // Don't get/set attributes on text, comment and attribute nodes\n\n      if (nType === 3 || nType === 8 || nType === 2) {\n        return;\n      } // Fallback to prop when attributes are not supported\n\n\n      if (typeof elem.getAttribute === \"undefined\") {\n        return jQuery.prop(elem, name, value);\n      } // Attribute hooks are determined by the lowercase version\n      // Grab necessary hook if one is defined\n\n\n      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {\n        hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);\n      }\n\n      if (value !== undefined) {\n        if (value === null) {\n          jQuery.removeAttr(elem, name);\n          return;\n        }\n\n        if (hooks && \"set\" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {\n          return ret;\n        }\n\n        elem.setAttribute(name, value + \"\");\n        return value;\n      }\n\n      if (hooks && \"get\" in hooks && (ret = hooks.get(elem, name)) !== null) {\n        return ret;\n      }\n\n      ret = jQuery.find.attr(elem, name); // Non-existent attributes return null, we normalize to undefined\n\n      return ret == null ? undefined : ret;\n    },\n    attrHooks: {\n      type: {\n        set: function set(elem, value) {\n          if (!support.radioValue && value === \"radio\" && nodeName(elem, \"input\")) {\n            var val = elem.value;\n            elem.setAttribute(\"type\", value);\n\n            if (val) {\n              elem.value = val;\n            }\n\n            return value;\n          }\n        }\n      }\n    },\n    removeAttr: function removeAttr(elem, value) {\n      var name,\n          i = 0,\n          // Attribute names can contain non-HTML whitespace characters\n      // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n      attrNames = value && value.match(rnothtmlwhite);\n\n      if (attrNames && elem.nodeType === 1) {\n        while (name = attrNames[i++]) {\n          elem.removeAttribute(name);\n        }\n      }\n    }\n  }); // Hooks for boolean attributes\n\n  boolHook = {\n    set: function set(elem, value, name) {\n      if (value === false) {\n        // Remove boolean attributes when set to false\n        jQuery.removeAttr(elem, name);\n      } else {\n        elem.setAttribute(name, name);\n      }\n\n      return name;\n    }\n  };\n  jQuery.each(jQuery.expr.match.bool.source.match(/\\w+/g), function (_i, name) {\n    var getter = attrHandle[name] || jQuery.find.attr;\n\n    attrHandle[name] = function (elem, name, isXML) {\n      var ret,\n          handle,\n          lowercaseName = name.toLowerCase();\n\n      if (!isXML) {\n        // Avoid an infinite loop by temporarily removing this function from the getter\n        handle = attrHandle[lowercaseName];\n        attrHandle[lowercaseName] = ret;\n        ret = getter(elem, name, isXML) != null ? lowercaseName : null;\n        attrHandle[lowercaseName] = handle;\n      }\n\n      return ret;\n    };\n  });\n  var rfocusable = /^(?:input|select|textarea|button)$/i,\n      rclickable = /^(?:a|area)$/i;\n  jQuery.fn.extend({\n    prop: function prop(name, value) {\n      return access(this, jQuery.prop, name, value, arguments.length > 1);\n    },\n    removeProp: function removeProp(name) {\n      return this.each(function () {\n        delete this[jQuery.propFix[name] || name];\n      });\n    }\n  });\n  jQuery.extend({\n    prop: function prop(elem, name, value) {\n      var ret,\n          hooks,\n          nType = elem.nodeType; // Don't get/set properties on text, comment and attribute nodes\n\n      if (nType === 3 || nType === 8 || nType === 2) {\n        return;\n      }\n\n      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {\n        // Fix name and attach hooks\n        name = jQuery.propFix[name] || name;\n        hooks = jQuery.propHooks[name];\n      }\n\n      if (value !== undefined) {\n        if (hooks && \"set\" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {\n          return ret;\n        }\n\n        return elem[name] = value;\n      }\n\n      if (hooks && \"get\" in hooks && (ret = hooks.get(elem, name)) !== null) {\n        return ret;\n      }\n\n      return elem[name];\n    },\n    propHooks: {\n      tabIndex: {\n        get: function get(elem) {\n          // Support: IE <=9 - 11 only\n          // elem.tabIndex doesn't always return the\n          // correct value when it hasn't been explicitly set\n          // https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n          // Use proper attribute retrieval(#12072)\n          var tabindex = jQuery.find.attr(elem, \"tabindex\");\n\n          if (tabindex) {\n            return parseInt(tabindex, 10);\n          }\n\n          if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {\n            return 0;\n          }\n\n          return -1;\n        }\n      }\n    },\n    propFix: {\n      \"for\": \"htmlFor\",\n      \"class\": \"className\"\n    }\n  }); // Support: IE <=11 only\n  // Accessing the selectedIndex property\n  // forces the browser to respect setting selected\n  // on the option\n  // The getter ensures a default option is selected\n  // when in an optgroup\n  // eslint rule \"no-unused-expressions\" is disabled for this code\n  // since it considers such accessions noop\n\n  if (!support.optSelected) {\n    jQuery.propHooks.selected = {\n      get: function get(elem) {\n        /* eslint no-unused-expressions: \"off\" */\n        var parent = elem.parentNode;\n\n        if (parent && parent.parentNode) {\n          parent.parentNode.selectedIndex;\n        }\n\n        return null;\n      },\n      set: function set(elem) {\n        /* eslint no-unused-expressions: \"off\" */\n        var parent = elem.parentNode;\n\n        if (parent) {\n          parent.selectedIndex;\n\n          if (parent.parentNode) {\n            parent.parentNode.selectedIndex;\n          }\n        }\n      }\n    };\n  }\n\n  jQuery.each([\"tabIndex\", \"readOnly\", \"maxLength\", \"cellSpacing\", \"cellPadding\", \"rowSpan\", \"colSpan\", \"useMap\", \"frameBorder\", \"contentEditable\"], function () {\n    jQuery.propFix[this.toLowerCase()] = this;\n  }); // Strip and collapse whitespace according to HTML spec\n  // https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace\n\n  function stripAndCollapse(value) {\n    var tokens = value.match(rnothtmlwhite) || [];\n    return tokens.join(\" \");\n  }\n\n  function getClass(elem) {\n    return elem.getAttribute && elem.getAttribute(\"class\") || \"\";\n  }\n\n  function classesToArray(value) {\n    if (Array.isArray(value)) {\n      return value;\n    }\n\n    if (typeof value === \"string\") {\n      return value.match(rnothtmlwhite) || [];\n    }\n\n    return [];\n  }\n\n  jQuery.fn.extend({\n    addClass: function addClass(value) {\n      var classes,\n          elem,\n          cur,\n          curValue,\n          clazz,\n          j,\n          finalValue,\n          i = 0;\n\n      if (isFunction(value)) {\n        return this.each(function (j) {\n          jQuery(this).addClass(value.call(this, j, getClass(this)));\n        });\n      }\n\n      classes = classesToArray(value);\n\n      if (classes.length) {\n        while (elem = this[i++]) {\n          curValue = getClass(elem);\n          cur = elem.nodeType === 1 && \" \" + stripAndCollapse(curValue) + \" \";\n\n          if (cur) {\n            j = 0;\n\n            while (clazz = classes[j++]) {\n              if (cur.indexOf(\" \" + clazz + \" \") < 0) {\n                cur += clazz + \" \";\n              }\n            } // Only assign if different to avoid unneeded rendering.\n\n\n            finalValue = stripAndCollapse(cur);\n\n            if (curValue !== finalValue) {\n              elem.setAttribute(\"class\", finalValue);\n            }\n          }\n        }\n      }\n\n      return this;\n    },\n    removeClass: function removeClass(value) {\n      var classes,\n          elem,\n          cur,\n          curValue,\n          clazz,\n          j,\n          finalValue,\n          i = 0;\n\n      if (isFunction(value)) {\n        return this.each(function (j) {\n          jQuery(this).removeClass(value.call(this, j, getClass(this)));\n        });\n      }\n\n      if (!arguments.length) {\n        return this.attr(\"class\", \"\");\n      }\n\n      classes = classesToArray(value);\n\n      if (classes.length) {\n        while (elem = this[i++]) {\n          curValue = getClass(elem); // This expression is here for better compressibility (see addClass)\n\n          cur = elem.nodeType === 1 && \" \" + stripAndCollapse(curValue) + \" \";\n\n          if (cur) {\n            j = 0;\n\n            while (clazz = classes[j++]) {\n              // Remove *all* instances\n              while (cur.indexOf(\" \" + clazz + \" \") > -1) {\n                cur = cur.replace(\" \" + clazz + \" \", \" \");\n              }\n            } // Only assign if different to avoid unneeded rendering.\n\n\n            finalValue = stripAndCollapse(cur);\n\n            if (curValue !== finalValue) {\n              elem.setAttribute(\"class\", finalValue);\n            }\n          }\n        }\n      }\n\n      return this;\n    },\n    toggleClass: function toggleClass(value, stateVal) {\n      var type = _typeof(value),\n          isValidValue = type === \"string\" || Array.isArray(value);\n\n      if (typeof stateVal === \"boolean\" && isValidValue) {\n        return stateVal ? this.addClass(value) : this.removeClass(value);\n      }\n\n      if (isFunction(value)) {\n        return this.each(function (i) {\n          jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);\n        });\n      }\n\n      return this.each(function () {\n        var className, i, self, classNames;\n\n        if (isValidValue) {\n          // Toggle individual class names\n          i = 0;\n          self = jQuery(this);\n          classNames = classesToArray(value);\n\n          while (className = classNames[i++]) {\n            // Check each className given, space separated list\n            if (self.hasClass(className)) {\n              self.removeClass(className);\n            } else {\n              self.addClass(className);\n            }\n          } // Toggle whole class name\n\n        } else if (value === undefined || type === \"boolean\") {\n          className = getClass(this);\n\n          if (className) {\n            // Store className if set\n            dataPriv.set(this, \"__className__\", className);\n          } // If the element has a class name or if we're passed `false`,\n          // then remove the whole classname (if there was one, the above saved it).\n          // Otherwise bring back whatever was previously saved (if anything),\n          // falling back to the empty string if nothing was stored.\n\n\n          if (this.setAttribute) {\n            this.setAttribute(\"class\", className || value === false ? \"\" : dataPriv.get(this, \"__className__\") || \"\");\n          }\n        }\n      });\n    },\n    hasClass: function hasClass(selector) {\n      var className,\n          elem,\n          i = 0;\n      className = \" \" + selector + \" \";\n\n      while (elem = this[i++]) {\n        if (elem.nodeType === 1 && (\" \" + stripAndCollapse(getClass(elem)) + \" \").indexOf(className) > -1) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n  });\n  var rreturn = /\\r/g;\n  jQuery.fn.extend({\n    val: function val(value) {\n      var hooks,\n          ret,\n          valueIsFunction,\n          elem = this[0];\n\n      if (!arguments.length) {\n        if (elem) {\n          hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];\n\n          if (hooks && \"get\" in hooks && (ret = hooks.get(elem, \"value\")) !== undefined) {\n            return ret;\n          }\n\n          ret = elem.value; // Handle most common string cases\n\n          if (typeof ret === \"string\") {\n            return ret.replace(rreturn, \"\");\n          } // Handle cases where value is null/undef or number\n\n\n          return ret == null ? \"\" : ret;\n        }\n\n        return;\n      }\n\n      valueIsFunction = isFunction(value);\n      return this.each(function (i) {\n        var val;\n\n        if (this.nodeType !== 1) {\n          return;\n        }\n\n        if (valueIsFunction) {\n          val = value.call(this, i, jQuery(this).val());\n        } else {\n          val = value;\n        } // Treat null/undefined as \"\"; convert numbers to string\n\n\n        if (val == null) {\n          val = \"\";\n        } else if (typeof val === \"number\") {\n          val += \"\";\n        } else if (Array.isArray(val)) {\n          val = jQuery.map(val, function (value) {\n            return value == null ? \"\" : value + \"\";\n          });\n        }\n\n        hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()]; // If set returns undefined, fall back to normal setting\n\n        if (!hooks || !(\"set\" in hooks) || hooks.set(this, val, \"value\") === undefined) {\n          this.value = val;\n        }\n      });\n    }\n  });\n  jQuery.extend({\n    valHooks: {\n      option: {\n        get: function get(elem) {\n          var val = jQuery.find.attr(elem, \"value\");\n          return val != null ? val : // Support: IE <=10 - 11 only\n          // option.text throws exceptions (#14686, #14858)\n          // Strip and collapse whitespace\n          // https://html.spec.whatwg.org/#strip-and-collapse-whitespace\n          stripAndCollapse(jQuery.text(elem));\n        }\n      },\n      select: {\n        get: function get(elem) {\n          var value,\n              option,\n              i,\n              options = elem.options,\n              index = elem.selectedIndex,\n              one = elem.type === \"select-one\",\n              values = one ? null : [],\n              max = one ? index + 1 : options.length;\n\n          if (index < 0) {\n            i = max;\n          } else {\n            i = one ? index : 0;\n          } // Loop through all the selected options\n\n\n          for (; i < max; i++) {\n            option = options[i]; // Support: IE <=9 only\n            // IE8-9 doesn't update selected after form reset (#2551)\n\n            if ((option.selected || i === index) && // Don't return options that are disabled or in a disabled optgroup\n            !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, \"optgroup\"))) {\n              // Get the specific value for the option\n              value = jQuery(option).val(); // We don't need an array for one selects\n\n              if (one) {\n                return value;\n              } // Multi-Selects return an array\n\n\n              values.push(value);\n            }\n          }\n\n          return values;\n        },\n        set: function set(elem, value) {\n          var optionSet,\n              option,\n              options = elem.options,\n              values = jQuery.makeArray(value),\n              i = options.length;\n\n          while (i--) {\n            option = options[i];\n            /* eslint-disable no-cond-assign */\n\n            if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {\n              optionSet = true;\n            }\n            /* eslint-enable no-cond-assign */\n\n          } // Force browsers to behave consistently when non-matching value is set\n\n\n          if (!optionSet) {\n            elem.selectedIndex = -1;\n          }\n\n          return values;\n        }\n      }\n    }\n  }); // Radios and checkboxes getter/setter\n\n  jQuery.each([\"radio\", \"checkbox\"], function () {\n    jQuery.valHooks[this] = {\n      set: function set(elem, value) {\n        if (Array.isArray(value)) {\n          return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;\n        }\n      }\n    };\n\n    if (!support.checkOn) {\n      jQuery.valHooks[this].get = function (elem) {\n        return elem.getAttribute(\"value\") === null ? \"on\" : elem.value;\n      };\n    }\n  }); // Return jQuery for attributes-only inclusion\n\n  support.focusin = \"onfocusin\" in window;\n\n  var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\n      stopPropagationCallback = function stopPropagationCallback(e) {\n    e.stopPropagation();\n  };\n\n  jQuery.extend(jQuery.event, {\n    trigger: function trigger(event, data, elem, onlyHandlers) {\n      var i,\n          cur,\n          tmp,\n          bubbleType,\n          ontype,\n          handle,\n          special,\n          lastElement,\n          eventPath = [elem || document],\n          type = hasOwn.call(event, \"type\") ? event.type : event,\n          namespaces = hasOwn.call(event, \"namespace\") ? event.namespace.split(\".\") : [];\n      cur = lastElement = tmp = elem = elem || document; // Don't do events on text and comment nodes\n\n      if (elem.nodeType === 3 || elem.nodeType === 8) {\n        return;\n      } // focus/blur morphs to focusin/out; ensure we're not firing them right now\n\n\n      if (rfocusMorph.test(type + jQuery.event.triggered)) {\n        return;\n      }\n\n      if (type.indexOf(\".\") > -1) {\n        // Namespaced trigger; create a regexp to match event type in handle()\n        namespaces = type.split(\".\");\n        type = namespaces.shift();\n        namespaces.sort();\n      }\n\n      ontype = type.indexOf(\":\") < 0 && \"on\" + type; // Caller can pass in a jQuery.Event object, Object, or just an event type string\n\n      event = event[jQuery.expando] ? event : new jQuery.Event(type, _typeof(event) === \"object\" && event); // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n\n      event.isTrigger = onlyHandlers ? 2 : 3;\n      event.namespace = namespaces.join(\".\");\n      event.rnamespace = event.namespace ? new RegExp(\"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\") : null; // Clean up the event in case it is being reused\n\n      event.result = undefined;\n\n      if (!event.target) {\n        event.target = elem;\n      } // Clone any incoming data and prepend the event, creating the handler arg list\n\n\n      data = data == null ? [event] : jQuery.makeArray(data, [event]); // Allow special events to draw outside the lines\n\n      special = jQuery.event.special[type] || {};\n\n      if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {\n        return;\n      } // Determine event propagation path in advance, per W3C events spec (#9951)\n      // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\n\n      if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {\n        bubbleType = special.delegateType || type;\n\n        if (!rfocusMorph.test(bubbleType + type)) {\n          cur = cur.parentNode;\n        }\n\n        for (; cur; cur = cur.parentNode) {\n          eventPath.push(cur);\n          tmp = cur;\n        } // Only add window if we got to document (e.g., not plain obj or detached DOM)\n\n\n        if (tmp === (elem.ownerDocument || document)) {\n          eventPath.push(tmp.defaultView || tmp.parentWindow || window);\n        }\n      } // Fire handlers on the event path\n\n\n      i = 0;\n\n      while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {\n        lastElement = cur;\n        event.type = i > 1 ? bubbleType : special.bindType || type; // jQuery handler\n\n        handle = (dataPriv.get(cur, \"events\") || Object.create(null))[event.type] && dataPriv.get(cur, \"handle\");\n\n        if (handle) {\n          handle.apply(cur, data);\n        } // Native handler\n\n\n        handle = ontype && cur[ontype];\n\n        if (handle && handle.apply && acceptData(cur)) {\n          event.result = handle.apply(cur, data);\n\n          if (event.result === false) {\n            event.preventDefault();\n          }\n        }\n      }\n\n      event.type = type; // If nobody prevented the default action, do it now\n\n      if (!onlyHandlers && !event.isDefaultPrevented()) {\n        if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {\n          // Call a native DOM method on the target with the same name as the event.\n          // Don't do default actions on window, that's where global variables be (#6170)\n          if (ontype && isFunction(elem[type]) && !isWindow(elem)) {\n            // Don't re-trigger an onFOO event when we call its FOO() method\n            tmp = elem[ontype];\n\n            if (tmp) {\n              elem[ontype] = null;\n            } // Prevent re-triggering of the same event, since we already bubbled it above\n\n\n            jQuery.event.triggered = type;\n\n            if (event.isPropagationStopped()) {\n              lastElement.addEventListener(type, stopPropagationCallback);\n            }\n\n            elem[type]();\n\n            if (event.isPropagationStopped()) {\n              lastElement.removeEventListener(type, stopPropagationCallback);\n            }\n\n            jQuery.event.triggered = undefined;\n\n            if (tmp) {\n              elem[ontype] = tmp;\n            }\n          }\n        }\n      }\n\n      return event.result;\n    },\n    // Piggyback on a donor event to simulate a different one\n    // Used only for `focus(in | out)` events\n    simulate: function simulate(type, elem, event) {\n      var e = jQuery.extend(new jQuery.Event(), event, {\n        type: type,\n        isSimulated: true\n      });\n      jQuery.event.trigger(e, null, elem);\n    }\n  });\n  jQuery.fn.extend({\n    trigger: function trigger(type, data) {\n      return this.each(function () {\n        jQuery.event.trigger(type, data, this);\n      });\n    },\n    triggerHandler: function triggerHandler(type, data) {\n      var elem = this[0];\n\n      if (elem) {\n        return jQuery.event.trigger(type, data, elem, true);\n      }\n    }\n  }); // Support: Firefox <=44\n  // Firefox doesn't have focus(in | out) events\n  // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787\n  //\n  // Support: Chrome <=48 - 49, Safari <=9.0 - 9.1\n  // focus(in | out) events fire after focus & blur events,\n  // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order\n  // Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857\n\n  if (!support.focusin) {\n    jQuery.each({\n      focus: \"focusin\",\n      blur: \"focusout\"\n    }, function (orig, fix) {\n      // Attach a single capturing handler on the document while someone wants focusin/focusout\n      var handler = function handler(event) {\n        jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));\n      };\n\n      jQuery.event.special[fix] = {\n        setup: function setup() {\n          // Handle: regular nodes (via `this.ownerDocument`), window\n          // (via `this.document`) & document (via `this`).\n          var doc = this.ownerDocument || this.document || this,\n              attaches = dataPriv.access(doc, fix);\n\n          if (!attaches) {\n            doc.addEventListener(orig, handler, true);\n          }\n\n          dataPriv.access(doc, fix, (attaches || 0) + 1);\n        },\n        teardown: function teardown() {\n          var doc = this.ownerDocument || this.document || this,\n              attaches = dataPriv.access(doc, fix) - 1;\n\n          if (!attaches) {\n            doc.removeEventListener(orig, handler, true);\n            dataPriv.remove(doc, fix);\n          } else {\n            dataPriv.access(doc, fix, attaches);\n          }\n        }\n      };\n    });\n  }\n\n  var location = window.location;\n  var nonce = {\n    guid: Date.now()\n  };\n  var rquery = /\\?/; // Cross-browser xml parsing\n\n  jQuery.parseXML = function (data) {\n    var xml;\n\n    if (!data || typeof data !== \"string\") {\n      return null;\n    } // Support: IE 9 - 11 only\n    // IE throws on parseFromString with invalid input.\n\n\n    try {\n      xml = new window.DOMParser().parseFromString(data, \"text/xml\");\n    } catch (e) {\n      xml = undefined;\n    }\n\n    if (!xml || xml.getElementsByTagName(\"parsererror\").length) {\n      jQuery.error(\"Invalid XML: \" + data);\n    }\n\n    return xml;\n  };\n\n  var rbracket = /\\[\\]$/,\n      rCRLF = /\\r?\\n/g,\n      rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n      rsubmittable = /^(?:input|select|textarea|keygen)/i;\n\n  function buildParams(prefix, obj, traditional, add) {\n    var name;\n\n    if (Array.isArray(obj)) {\n      // Serialize array item.\n      jQuery.each(obj, function (i, v) {\n        if (traditional || rbracket.test(prefix)) {\n          // Treat each array item as a scalar.\n          add(prefix, v);\n        } else {\n          // Item is non-scalar (array or object), encode its numeric index.\n          buildParams(prefix + \"[\" + (_typeof(v) === \"object\" && v != null ? i : \"\") + \"]\", v, traditional, add);\n        }\n      });\n    } else if (!traditional && toType(obj) === \"object\") {\n      // Serialize object item.\n      for (name in obj) {\n        buildParams(prefix + \"[\" + name + \"]\", obj[name], traditional, add);\n      }\n    } else {\n      // Serialize scalar item.\n      add(prefix, obj);\n    }\n  } // Serialize an array of form elements or a set of\n  // key/values into a query string\n\n\n  jQuery.param = function (a, traditional) {\n    var prefix,\n        s = [],\n        add = function add(key, valueOrFunction) {\n      // If value is a function, invoke it and use its return value\n      var value = isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;\n      s[s.length] = encodeURIComponent(key) + \"=\" + encodeURIComponent(value == null ? \"\" : value);\n    };\n\n    if (a == null) {\n      return \"\";\n    } // If an array was passed in, assume that it is an array of form elements.\n\n\n    if (Array.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {\n      // Serialize the form elements\n      jQuery.each(a, function () {\n        add(this.name, this.value);\n      });\n    } else {\n      // If traditional, encode the \"old\" way (the way 1.3.2 or older\n      // did it), otherwise encode params recursively.\n      for (prefix in a) {\n        buildParams(prefix, a[prefix], traditional, add);\n      }\n    } // Return the resulting serialization\n\n\n    return s.join(\"&\");\n  };\n\n  jQuery.fn.extend({\n    serialize: function serialize() {\n      return jQuery.param(this.serializeArray());\n    },\n    serializeArray: function serializeArray() {\n      return this.map(function () {\n        // Can add propHook for \"elements\" to filter or add form elements\n        var elements = jQuery.prop(this, \"elements\");\n        return elements ? jQuery.makeArray(elements) : this;\n      }).filter(function () {\n        var type = this.type; // Use .is( \":disabled\" ) so that fieldset[disabled] works\n\n        return this.name && !jQuery(this).is(\":disabled\") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));\n      }).map(function (_i, elem) {\n        var val = jQuery(this).val();\n\n        if (val == null) {\n          return null;\n        }\n\n        if (Array.isArray(val)) {\n          return jQuery.map(val, function (val) {\n            return {\n              name: elem.name,\n              value: val.replace(rCRLF, \"\\r\\n\")\n            };\n          });\n        }\n\n        return {\n          name: elem.name,\n          value: val.replace(rCRLF, \"\\r\\n\")\n        };\n      }).get();\n    }\n  });\n  var r20 = /%20/g,\n      rhash = /#.*$/,\n      rantiCache = /([?&])_=[^&]*/,\n      rheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n      // #7653, #8125, #8152: local protocol detection\n  rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n      rnoContent = /^(?:GET|HEAD)$/,\n      rprotocol = /^\\/\\//,\n\n  /* Prefilters\n   * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n   * 2) These are called:\n   *    - BEFORE asking for a transport\n   *    - AFTER param serialization (s.data is a string if s.processData is true)\n   * 3) key is the dataType\n   * 4) the catchall symbol \"*\" can be used\n   * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n   */\n  prefilters = {},\n\n  /* Transports bindings\n   * 1) key is the dataType\n   * 2) the catchall symbol \"*\" can be used\n   * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n   */\n  transports = {},\n      // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n  allTypes = \"*/\".concat(\"*\"),\n      // Anchor tag for parsing the document origin\n  originAnchor = document.createElement(\"a\");\n  originAnchor.href = location.href; // Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\n\n  function addToPrefiltersOrTransports(structure) {\n    // dataTypeExpression is optional and defaults to \"*\"\n    return function (dataTypeExpression, func) {\n      if (typeof dataTypeExpression !== \"string\") {\n        func = dataTypeExpression;\n        dataTypeExpression = \"*\";\n      }\n\n      var dataType,\n          i = 0,\n          dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];\n\n      if (isFunction(func)) {\n        // For each dataType in the dataTypeExpression\n        while (dataType = dataTypes[i++]) {\n          // Prepend if requested\n          if (dataType[0] === \"+\") {\n            dataType = dataType.slice(1) || \"*\";\n            (structure[dataType] = structure[dataType] || []).unshift(func); // Otherwise append\n          } else {\n            (structure[dataType] = structure[dataType] || []).push(func);\n          }\n        }\n      }\n    };\n  } // Base inspection function for prefilters and transports\n\n\n  function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {\n    var inspected = {},\n        seekingTransport = structure === transports;\n\n    function inspect(dataType) {\n      var selected;\n      inspected[dataType] = true;\n      jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {\n        var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);\n\n        if (typeof dataTypeOrTransport === \"string\" && !seekingTransport && !inspected[dataTypeOrTransport]) {\n          options.dataTypes.unshift(dataTypeOrTransport);\n          inspect(dataTypeOrTransport);\n          return false;\n        } else if (seekingTransport) {\n          return !(selected = dataTypeOrTransport);\n        }\n      });\n      return selected;\n    }\n\n    return inspect(options.dataTypes[0]) || !inspected[\"*\"] && inspect(\"*\");\n  } // A special extend for ajax options\n  // that takes \"flat\" options (not to be deep extended)\n  // Fixes #9887\n\n\n  function ajaxExtend(target, src) {\n    var key,\n        deep,\n        flatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n    for (key in src) {\n      if (src[key] !== undefined) {\n        (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];\n      }\n    }\n\n    if (deep) {\n      jQuery.extend(true, target, deep);\n    }\n\n    return target;\n  }\n  /* Handles responses to an ajax request:\n   * - finds the right dataType (mediates between content-type and expected dataType)\n   * - returns the corresponding response\n   */\n\n\n  function ajaxHandleResponses(s, jqXHR, responses) {\n    var ct,\n        type,\n        finalDataType,\n        firstDataType,\n        contents = s.contents,\n        dataTypes = s.dataTypes; // Remove auto dataType and get content-type in the process\n\n    while (dataTypes[0] === \"*\") {\n      dataTypes.shift();\n\n      if (ct === undefined) {\n        ct = s.mimeType || jqXHR.getResponseHeader(\"Content-Type\");\n      }\n    } // Check if we're dealing with a known content-type\n\n\n    if (ct) {\n      for (type in contents) {\n        if (contents[type] && contents[type].test(ct)) {\n          dataTypes.unshift(type);\n          break;\n        }\n      }\n    } // Check to see if we have a response for the expected dataType\n\n\n    if (dataTypes[0] in responses) {\n      finalDataType = dataTypes[0];\n    } else {\n      // Try convertible dataTypes\n      for (type in responses) {\n        if (!dataTypes[0] || s.converters[type + \" \" + dataTypes[0]]) {\n          finalDataType = type;\n          break;\n        }\n\n        if (!firstDataType) {\n          firstDataType = type;\n        }\n      } // Or just use first one\n\n\n      finalDataType = finalDataType || firstDataType;\n    } // If we found a dataType\n    // We add the dataType to the list if needed\n    // and return the corresponding response\n\n\n    if (finalDataType) {\n      if (finalDataType !== dataTypes[0]) {\n        dataTypes.unshift(finalDataType);\n      }\n\n      return responses[finalDataType];\n    }\n  }\n  /* Chain conversions given the request and the original response\n   * Also sets the responseXXX fields on the jqXHR instance\n   */\n\n\n  function ajaxConvert(s, response, jqXHR, isSuccess) {\n    var conv2,\n        current,\n        conv,\n        tmp,\n        prev,\n        converters = {},\n        // Work with a copy of dataTypes in case we need to modify it for conversion\n    dataTypes = s.dataTypes.slice(); // Create converters map with lowercased keys\n\n    if (dataTypes[1]) {\n      for (conv in s.converters) {\n        converters[conv.toLowerCase()] = s.converters[conv];\n      }\n    }\n\n    current = dataTypes.shift(); // Convert to each sequential dataType\n\n    while (current) {\n      if (s.responseFields[current]) {\n        jqXHR[s.responseFields[current]] = response;\n      } // Apply the dataFilter if provided\n\n\n      if (!prev && isSuccess && s.dataFilter) {\n        response = s.dataFilter(response, s.dataType);\n      }\n\n      prev = current;\n      current = dataTypes.shift();\n\n      if (current) {\n        // There's only work to do if current dataType is non-auto\n        if (current === \"*\") {\n          current = prev; // Convert response if prev dataType is non-auto and differs from current\n        } else if (prev !== \"*\" && prev !== current) {\n          // Seek a direct converter\n          conv = converters[prev + \" \" + current] || converters[\"* \" + current]; // If none found, seek a pair\n\n          if (!conv) {\n            for (conv2 in converters) {\n              // If conv2 outputs current\n              tmp = conv2.split(\" \");\n\n              if (tmp[1] === current) {\n                // If prev can be converted to accepted input\n                conv = converters[prev + \" \" + tmp[0]] || converters[\"* \" + tmp[0]];\n\n                if (conv) {\n                  // Condense equivalence converters\n                  if (conv === true) {\n                    conv = converters[conv2]; // Otherwise, insert the intermediate dataType\n                  } else if (converters[conv2] !== true) {\n                    current = tmp[0];\n                    dataTypes.unshift(tmp[1]);\n                  }\n\n                  break;\n                }\n              }\n            }\n          } // Apply converter (if not an equivalence)\n\n\n          if (conv !== true) {\n            // Unless errors are allowed to bubble, catch and return them\n            if (conv && s.throws) {\n              response = conv(response);\n            } else {\n              try {\n                response = conv(response);\n              } catch (e) {\n                return {\n                  state: \"parsererror\",\n                  error: conv ? e : \"No conversion from \" + prev + \" to \" + current\n                };\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return {\n      state: \"success\",\n      data: response\n    };\n  }\n\n  jQuery.extend({\n    // Counter for holding the number of active queries\n    active: 0,\n    // Last-Modified header cache for next request\n    lastModified: {},\n    etag: {},\n    ajaxSettings: {\n      url: location.href,\n      type: \"GET\",\n      isLocal: rlocalProtocol.test(location.protocol),\n      global: true,\n      processData: true,\n      async: true,\n      contentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n\n      /*\n      timeout: 0,\n      data: null,\n      dataType: null,\n      username: null,\n      password: null,\n      cache: null,\n      throws: false,\n      traditional: false,\n      headers: {},\n      */\n      accepts: {\n        \"*\": allTypes,\n        text: \"text/plain\",\n        html: \"text/html\",\n        xml: \"application/xml, text/xml\",\n        json: \"application/json, text/javascript\"\n      },\n      contents: {\n        xml: /\\bxml\\b/,\n        html: /\\bhtml/,\n        json: /\\bjson\\b/\n      },\n      responseFields: {\n        xml: \"responseXML\",\n        text: \"responseText\",\n        json: \"responseJSON\"\n      },\n      // Data converters\n      // Keys separate source (or catchall \"*\") and destination types with a single space\n      converters: {\n        // Convert anything to text\n        \"* text\": String,\n        // Text to html (true = no transformation)\n        \"text html\": true,\n        // Evaluate text as a json expression\n        \"text json\": JSON.parse,\n        // Parse text as xml\n        \"text xml\": jQuery.parseXML\n      },\n      // For options that shouldn't be deep extended:\n      // you can add your own custom options here if\n      // and when you create one that shouldn't be\n      // deep extended (see ajaxExtend)\n      flatOptions: {\n        url: true,\n        context: true\n      }\n    },\n    // Creates a full fledged settings object into target\n    // with both ajaxSettings and settings fields.\n    // If target is omitted, writes into ajaxSettings.\n    ajaxSetup: function ajaxSetup(target, settings) {\n      return settings ? // Building a settings object\n      ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : // Extending ajaxSettings\n      ajaxExtend(jQuery.ajaxSettings, target);\n    },\n    ajaxPrefilter: addToPrefiltersOrTransports(prefilters),\n    ajaxTransport: addToPrefiltersOrTransports(transports),\n    // Main method\n    ajax: function ajax(url, options) {\n      // If url is an object, simulate pre-1.5 signature\n      if (_typeof(url) === \"object\") {\n        options = url;\n        url = undefined;\n      } // Force options to be an object\n\n\n      options = options || {};\n\n      var transport,\n          // URL without anti-cache param\n      cacheURL,\n          // Response headers\n      responseHeadersString,\n          responseHeaders,\n          // timeout handle\n      timeoutTimer,\n          // Url cleanup var\n      urlAnchor,\n          // Request state (becomes false upon send and true upon completion)\n      completed,\n          // To know if global events are to be dispatched\n      fireGlobals,\n          // Loop variable\n      i,\n          // uncached part of the url\n      uncached,\n          // Create the final options object\n      s = jQuery.ajaxSetup({}, options),\n          // Callbacks context\n      callbackContext = s.context || s,\n          // Context for global events is callbackContext if it is a DOM node or jQuery collection\n      globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,\n          // Deferreds\n      deferred = jQuery.Deferred(),\n          completeDeferred = jQuery.Callbacks(\"once memory\"),\n          // Status-dependent callbacks\n      _statusCode = s.statusCode || {},\n          // Headers (they are sent all at once)\n      requestHeaders = {},\n          requestHeadersNames = {},\n          // Default abort message\n      strAbort = \"canceled\",\n          // Fake xhr\n      jqXHR = {\n        readyState: 0,\n        // Builds headers hashtable if needed\n        getResponseHeader: function getResponseHeader(key) {\n          var match;\n\n          if (completed) {\n            if (!responseHeaders) {\n              responseHeaders = {};\n\n              while (match = rheaders.exec(responseHeadersString)) {\n                responseHeaders[match[1].toLowerCase() + \" \"] = (responseHeaders[match[1].toLowerCase() + \" \"] || []).concat(match[2]);\n              }\n            }\n\n            match = responseHeaders[key.toLowerCase() + \" \"];\n          }\n\n          return match == null ? null : match.join(\", \");\n        },\n        // Raw string\n        getAllResponseHeaders: function getAllResponseHeaders() {\n          return completed ? responseHeadersString : null;\n        },\n        // Caches the header\n        setRequestHeader: function setRequestHeader(name, value) {\n          if (completed == null) {\n            name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;\n            requestHeaders[name] = value;\n          }\n\n          return this;\n        },\n        // Overrides response content-type header\n        overrideMimeType: function overrideMimeType(type) {\n          if (completed == null) {\n            s.mimeType = type;\n          }\n\n          return this;\n        },\n        // Status-dependent callbacks\n        statusCode: function statusCode(map) {\n          var code;\n\n          if (map) {\n            if (completed) {\n              // Execute the appropriate callbacks\n              jqXHR.always(map[jqXHR.status]);\n            } else {\n              // Lazy-add the new callbacks in a way that preserves old ones\n              for (code in map) {\n                _statusCode[code] = [_statusCode[code], map[code]];\n              }\n            }\n          }\n\n          return this;\n        },\n        // Cancel the request\n        abort: function abort(statusText) {\n          var finalText = statusText || strAbort;\n\n          if (transport) {\n            transport.abort(finalText);\n          }\n\n          done(0, finalText);\n          return this;\n        }\n      }; // Attach deferreds\n\n\n      deferred.promise(jqXHR); // Add protocol if not provided (prefilters might expect it)\n      // Handle falsy url in the settings object (#10093: consistency with old signature)\n      // We also use the url parameter if available\n\n      s.url = ((url || s.url || location.href) + \"\").replace(rprotocol, location.protocol + \"//\"); // Alias method option to type as per ticket #12004\n\n      s.type = options.method || options.type || s.method || s.type; // Extract dataTypes list\n\n      s.dataTypes = (s.dataType || \"*\").toLowerCase().match(rnothtmlwhite) || [\"\"]; // A cross-domain request is in order when the origin doesn't match the current origin.\n\n      if (s.crossDomain == null) {\n        urlAnchor = document.createElement(\"a\"); // Support: IE <=8 - 11, Edge 12 - 15\n        // IE throws exception on accessing the href property if url is malformed,\n        // e.g. http://example.com:80x/\n\n        try {\n          urlAnchor.href = s.url; // Support: IE <=8 - 11 only\n          // Anchor's host property isn't correctly set when s.url is relative\n\n          urlAnchor.href = urlAnchor.href;\n          s.crossDomain = originAnchor.protocol + \"//\" + originAnchor.host !== urlAnchor.protocol + \"//\" + urlAnchor.host;\n        } catch (e) {\n          // If there is an error parsing the URL, assume it is crossDomain,\n          // it can be rejected by the transport if it is invalid\n          s.crossDomain = true;\n        }\n      } // Convert data if not already a string\n\n\n      if (s.data && s.processData && typeof s.data !== \"string\") {\n        s.data = jQuery.param(s.data, s.traditional);\n      } // Apply prefilters\n\n\n      inspectPrefiltersOrTransports(prefilters, s, options, jqXHR); // If request was aborted inside a prefilter, stop there\n\n      if (completed) {\n        return jqXHR;\n      } // We can fire global events as of now if asked to\n      // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n\n\n      fireGlobals = jQuery.event && s.global; // Watch for a new set of requests\n\n      if (fireGlobals && jQuery.active++ === 0) {\n        jQuery.event.trigger(\"ajaxStart\");\n      } // Uppercase the type\n\n\n      s.type = s.type.toUpperCase(); // Determine if request has content\n\n      s.hasContent = !rnoContent.test(s.type); // Save the URL in case we're toying with the If-Modified-Since\n      // and/or If-None-Match header later on\n      // Remove hash to simplify url manipulation\n\n      cacheURL = s.url.replace(rhash, \"\"); // More options handling for requests with no content\n\n      if (!s.hasContent) {\n        // Remember the hash so we can put it back\n        uncached = s.url.slice(cacheURL.length); // If data is available and should be processed, append data to url\n\n        if (s.data && (s.processData || typeof s.data === \"string\")) {\n          cacheURL += (rquery.test(cacheURL) ? \"&\" : \"?\") + s.data; // #9682: remove data so that it's not used in an eventual retry\n\n          delete s.data;\n        } // Add or update anti-cache param if needed\n\n\n        if (s.cache === false) {\n          cacheURL = cacheURL.replace(rantiCache, \"$1\");\n          uncached = (rquery.test(cacheURL) ? \"&\" : \"?\") + \"_=\" + nonce.guid++ + uncached;\n        } // Put hash and anti-cache on the URL that will be requested (gh-1732)\n\n\n        s.url = cacheURL + uncached; // Change '%20' to '+' if this is encoded form body content (gh-2658)\n      } else if (s.data && s.processData && (s.contentType || \"\").indexOf(\"application/x-www-form-urlencoded\") === 0) {\n        s.data = s.data.replace(r20, \"+\");\n      } // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\n\n      if (s.ifModified) {\n        if (jQuery.lastModified[cacheURL]) {\n          jqXHR.setRequestHeader(\"If-Modified-Since\", jQuery.lastModified[cacheURL]);\n        }\n\n        if (jQuery.etag[cacheURL]) {\n          jqXHR.setRequestHeader(\"If-None-Match\", jQuery.etag[cacheURL]);\n        }\n      } // Set the correct header, if data is being sent\n\n\n      if (s.data && s.hasContent && s.contentType !== false || options.contentType) {\n        jqXHR.setRequestHeader(\"Content-Type\", s.contentType);\n      } // Set the Accepts header for the server, depending on the dataType\n\n\n      jqXHR.setRequestHeader(\"Accept\", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\") : s.accepts[\"*\"]); // Check for headers option\n\n      for (i in s.headers) {\n        jqXHR.setRequestHeader(i, s.headers[i]);\n      } // Allow custom headers/mimetypes and early abort\n\n\n      if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed)) {\n        // Abort if not done already and return\n        return jqXHR.abort();\n      } // Aborting is no longer a cancellation\n\n\n      strAbort = \"abort\"; // Install callbacks on deferreds\n\n      completeDeferred.add(s.complete);\n      jqXHR.done(s.success);\n      jqXHR.fail(s.error); // Get transport\n\n      transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR); // If no transport, we auto-abort\n\n      if (!transport) {\n        done(-1, \"No Transport\");\n      } else {\n        jqXHR.readyState = 1; // Send global event\n\n        if (fireGlobals) {\n          globalEventContext.trigger(\"ajaxSend\", [jqXHR, s]);\n        } // If request was aborted inside ajaxSend, stop there\n\n\n        if (completed) {\n          return jqXHR;\n        } // Timeout\n\n\n        if (s.async && s.timeout > 0) {\n          timeoutTimer = window.setTimeout(function () {\n            jqXHR.abort(\"timeout\");\n          }, s.timeout);\n        }\n\n        try {\n          completed = false;\n          transport.send(requestHeaders, done);\n        } catch (e) {\n          // Rethrow post-completion exceptions\n          if (completed) {\n            throw e;\n          } // Propagate others as results\n\n\n          done(-1, e);\n        }\n      } // Callback for when everything is done\n\n\n      function done(status, nativeStatusText, responses, headers) {\n        var isSuccess,\n            success,\n            error,\n            response,\n            modified,\n            statusText = nativeStatusText; // Ignore repeat invocations\n\n        if (completed) {\n          return;\n        }\n\n        completed = true; // Clear timeout if it exists\n\n        if (timeoutTimer) {\n          window.clearTimeout(timeoutTimer);\n        } // Dereference transport for early garbage collection\n        // (no matter how long the jqXHR object will be used)\n\n\n        transport = undefined; // Cache response headers\n\n        responseHeadersString = headers || \"\"; // Set readyState\n\n        jqXHR.readyState = status > 0 ? 4 : 0; // Determine if successful\n\n        isSuccess = status >= 200 && status < 300 || status === 304; // Get response data\n\n        if (responses) {\n          response = ajaxHandleResponses(s, jqXHR, responses);\n        } // Use a noop converter for missing script\n\n\n        if (!isSuccess && jQuery.inArray(\"script\", s.dataTypes) > -1) {\n          s.converters[\"text script\"] = function () {};\n        } // Convert no matter what (that way responseXXX fields are always set)\n\n\n        response = ajaxConvert(s, response, jqXHR, isSuccess); // If successful, handle type chaining\n\n        if (isSuccess) {\n          // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n          if (s.ifModified) {\n            modified = jqXHR.getResponseHeader(\"Last-Modified\");\n\n            if (modified) {\n              jQuery.lastModified[cacheURL] = modified;\n            }\n\n            modified = jqXHR.getResponseHeader(\"etag\");\n\n            if (modified) {\n              jQuery.etag[cacheURL] = modified;\n            }\n          } // if no content\n\n\n          if (status === 204 || s.type === \"HEAD\") {\n            statusText = \"nocontent\"; // if not modified\n          } else if (status === 304) {\n            statusText = \"notmodified\"; // If we have data, let's convert it\n          } else {\n            statusText = response.state;\n            success = response.data;\n            error = response.error;\n            isSuccess = !error;\n          }\n        } else {\n          // Extract error from statusText and normalize for non-aborts\n          error = statusText;\n\n          if (status || !statusText) {\n            statusText = \"error\";\n\n            if (status < 0) {\n              status = 0;\n            }\n          }\n        } // Set data for the fake xhr object\n\n\n        jqXHR.status = status;\n        jqXHR.statusText = (nativeStatusText || statusText) + \"\"; // Success/Error\n\n        if (isSuccess) {\n          deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);\n        } else {\n          deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);\n        } // Status-dependent callbacks\n\n\n        jqXHR.statusCode(_statusCode);\n        _statusCode = undefined;\n\n        if (fireGlobals) {\n          globalEventContext.trigger(isSuccess ? \"ajaxSuccess\" : \"ajaxError\", [jqXHR, s, isSuccess ? success : error]);\n        } // Complete\n\n\n        completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);\n\n        if (fireGlobals) {\n          globalEventContext.trigger(\"ajaxComplete\", [jqXHR, s]); // Handle the global AJAX counter\n\n          if (! --jQuery.active) {\n            jQuery.event.trigger(\"ajaxStop\");\n          }\n        }\n      }\n\n      return jqXHR;\n    },\n    getJSON: function getJSON(url, data, callback) {\n      return jQuery.get(url, data, callback, \"json\");\n    },\n    getScript: function getScript(url, callback) {\n      return jQuery.get(url, undefined, callback, \"script\");\n    }\n  });\n  jQuery.each([\"get\", \"post\"], function (_i, method) {\n    jQuery[method] = function (url, data, callback, type) {\n      // Shift arguments if data argument was omitted\n      if (isFunction(data)) {\n        type = type || callback;\n        callback = data;\n        data = undefined;\n      } // The url can be an options object (which then must have .url)\n\n\n      return jQuery.ajax(jQuery.extend({\n        url: url,\n        type: method,\n        dataType: type,\n        data: data,\n        success: callback\n      }, jQuery.isPlainObject(url) && url));\n    };\n  });\n  jQuery.ajaxPrefilter(function (s) {\n    var i;\n\n    for (i in s.headers) {\n      if (i.toLowerCase() === \"content-type\") {\n        s.contentType = s.headers[i] || \"\";\n      }\n    }\n  });\n\n  jQuery._evalUrl = function (url, options, doc) {\n    return jQuery.ajax({\n      url: url,\n      // Make this explicit, since user can override this through ajaxSetup (#11264)\n      type: \"GET\",\n      dataType: \"script\",\n      cache: true,\n      async: false,\n      global: false,\n      // Only evaluate the response if it is successful (gh-4126)\n      // dataFilter is not invoked for failure responses, so using it instead\n      // of the default converter is kludgy but it works.\n      converters: {\n        \"text script\": function textScript() {}\n      },\n      dataFilter: function dataFilter(response) {\n        jQuery.globalEval(response, options, doc);\n      }\n    });\n  };\n\n  jQuery.fn.extend({\n    wrapAll: function wrapAll(html) {\n      var wrap;\n\n      if (this[0]) {\n        if (isFunction(html)) {\n          html = html.call(this[0]);\n        } // The elements to wrap the target around\n\n\n        wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);\n\n        if (this[0].parentNode) {\n          wrap.insertBefore(this[0]);\n        }\n\n        wrap.map(function () {\n          var elem = this;\n\n          while (elem.firstElementChild) {\n            elem = elem.firstElementChild;\n          }\n\n          return elem;\n        }).append(this);\n      }\n\n      return this;\n    },\n    wrapInner: function wrapInner(html) {\n      if (isFunction(html)) {\n        return this.each(function (i) {\n          jQuery(this).wrapInner(html.call(this, i));\n        });\n      }\n\n      return this.each(function () {\n        var self = jQuery(this),\n            contents = self.contents();\n\n        if (contents.length) {\n          contents.wrapAll(html);\n        } else {\n          self.append(html);\n        }\n      });\n    },\n    wrap: function wrap(html) {\n      var htmlIsFunction = isFunction(html);\n      return this.each(function (i) {\n        jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i) : html);\n      });\n    },\n    unwrap: function unwrap(selector) {\n      this.parent(selector).not(\"body\").each(function () {\n        jQuery(this).replaceWith(this.childNodes);\n      });\n      return this;\n    }\n  });\n\n  jQuery.expr.pseudos.hidden = function (elem) {\n    return !jQuery.expr.pseudos.visible(elem);\n  };\n\n  jQuery.expr.pseudos.visible = function (elem) {\n    return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);\n  };\n\n  jQuery.ajaxSettings.xhr = function () {\n    try {\n      return new window.XMLHttpRequest();\n    } catch (e) {}\n  };\n\n  var xhrSuccessStatus = {\n    // File protocol always yields status code 0, assume 200\n    0: 200,\n    // Support: IE <=9 only\n    // #1450: sometimes IE returns 1223 when it should be 204\n    1223: 204\n  },\n      xhrSupported = jQuery.ajaxSettings.xhr();\n  support.cors = !!xhrSupported && \"withCredentials\" in xhrSupported;\n  support.ajax = xhrSupported = !!xhrSupported;\n  jQuery.ajaxTransport(function (options) {\n    var _callback, errorCallback; // Cross domain only allowed if supported through XMLHttpRequest\n\n\n    if (support.cors || xhrSupported && !options.crossDomain) {\n      return {\n        send: function send(headers, complete) {\n          var i,\n              xhr = options.xhr();\n          xhr.open(options.type, options.url, options.async, options.username, options.password); // Apply custom fields if provided\n\n          if (options.xhrFields) {\n            for (i in options.xhrFields) {\n              xhr[i] = options.xhrFields[i];\n            }\n          } // Override mime type if needed\n\n\n          if (options.mimeType && xhr.overrideMimeType) {\n            xhr.overrideMimeType(options.mimeType);\n          } // X-Requested-With header\n          // For cross-domain requests, seeing as conditions for a preflight are\n          // akin to a jigsaw puzzle, we simply never set it to be sure.\n          // (it can always be set on a per-request basis or even using ajaxSetup)\n          // For same-domain requests, won't change header if already provided.\n\n\n          if (!options.crossDomain && !headers[\"X-Requested-With\"]) {\n            headers[\"X-Requested-With\"] = \"XMLHttpRequest\";\n          } // Set headers\n\n\n          for (i in headers) {\n            xhr.setRequestHeader(i, headers[i]);\n          } // Callback\n\n\n          _callback = function callback(type) {\n            return function () {\n              if (_callback) {\n                _callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;\n\n                if (type === \"abort\") {\n                  xhr.abort();\n                } else if (type === \"error\") {\n                  // Support: IE <=9 only\n                  // On a manual native abort, IE9 throws\n                  // errors on any property access that is not readyState\n                  if (typeof xhr.status !== \"number\") {\n                    complete(0, \"error\");\n                  } else {\n                    complete( // File: protocol always yields status 0; see #8605, #14207\n                    xhr.status, xhr.statusText);\n                  }\n                } else {\n                  complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, // Support: IE <=9 only\n                  // IE9 has no XHR2 but throws on binary (trac-11426)\n                  // For XHR2 non-text, let the caller handle it (gh-2498)\n                  (xhr.responseType || \"text\") !== \"text\" || typeof xhr.responseText !== \"string\" ? {\n                    binary: xhr.response\n                  } : {\n                    text: xhr.responseText\n                  }, xhr.getAllResponseHeaders());\n                }\n              }\n            };\n          }; // Listen to events\n\n\n          xhr.onload = _callback();\n          errorCallback = xhr.onerror = xhr.ontimeout = _callback(\"error\"); // Support: IE 9 only\n          // Use onreadystatechange to replace onabort\n          // to handle uncaught aborts\n\n          if (xhr.onabort !== undefined) {\n            xhr.onabort = errorCallback;\n          } else {\n            xhr.onreadystatechange = function () {\n              // Check readyState before timeout as it changes\n              if (xhr.readyState === 4) {\n                // Allow onerror to be called first,\n                // but that will not handle a native abort\n                // Also, save errorCallback to a variable\n                // as xhr.onerror cannot be accessed\n                window.setTimeout(function () {\n                  if (_callback) {\n                    errorCallback();\n                  }\n                });\n              }\n            };\n          } // Create the abort callback\n\n\n          _callback = _callback(\"abort\");\n\n          try {\n            // Do send the request (this may raise an exception)\n            xhr.send(options.hasContent && options.data || null);\n          } catch (e) {\n            // #14683: Only rethrow if this hasn't been notified as an error yet\n            if (_callback) {\n              throw e;\n            }\n          }\n        },\n        abort: function abort() {\n          if (_callback) {\n            _callback();\n          }\n        }\n      };\n    }\n  }); // Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)\n\n  jQuery.ajaxPrefilter(function (s) {\n    if (s.crossDomain) {\n      s.contents.script = false;\n    }\n  }); // Install script dataType\n\n  jQuery.ajaxSetup({\n    accepts: {\n      script: \"text/javascript, application/javascript, \" + \"application/ecmascript, application/x-ecmascript\"\n    },\n    contents: {\n      script: /\\b(?:java|ecma)script\\b/\n    },\n    converters: {\n      \"text script\": function textScript(text) {\n        jQuery.globalEval(text);\n        return text;\n      }\n    }\n  }); // Handle cache's special case and crossDomain\n\n  jQuery.ajaxPrefilter(\"script\", function (s) {\n    if (s.cache === undefined) {\n      s.cache = false;\n    }\n\n    if (s.crossDomain) {\n      s.type = \"GET\";\n    }\n  }); // Bind script tag hack transport\n\n  jQuery.ajaxTransport(\"script\", function (s) {\n    // This transport only deals with cross domain or forced-by-attrs requests\n    if (s.crossDomain || s.scriptAttrs) {\n      var script, _callback2;\n\n      return {\n        send: function send(_, complete) {\n          script = jQuery(\"<script>\").attr(s.scriptAttrs || {}).prop({\n            charset: s.scriptCharset,\n            src: s.url\n          }).on(\"load error\", _callback2 = function callback(evt) {\n            script.remove();\n            _callback2 = null;\n\n            if (evt) {\n              complete(evt.type === \"error\" ? 404 : 200, evt.type);\n            }\n          }); // Use native DOM manipulation to avoid our domManip AJAX trickery\n\n          document.head.appendChild(script[0]);\n        },\n        abort: function abort() {\n          if (_callback2) {\n            _callback2();\n          }\n        }\n      };\n    }\n  });\n  var oldCallbacks = [],\n      rjsonp = /(=)\\?(?=&|$)|\\?\\?/; // Default jsonp settings\n\n  jQuery.ajaxSetup({\n    jsonp: \"callback\",\n    jsonpCallback: function jsonpCallback() {\n      var callback = oldCallbacks.pop() || jQuery.expando + \"_\" + nonce.guid++;\n      this[callback] = true;\n      return callback;\n    }\n  }); // Detect, normalize options and install callbacks for jsonp requests\n\n  jQuery.ajaxPrefilter(\"json jsonp\", function (s, originalSettings, jqXHR) {\n    var callbackName,\n        overwritten,\n        responseContainer,\n        jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? \"url\" : typeof s.data === \"string\" && (s.contentType || \"\").indexOf(\"application/x-www-form-urlencoded\") === 0 && rjsonp.test(s.data) && \"data\"); // Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n\n    if (jsonProp || s.dataTypes[0] === \"jsonp\") {\n      // Get callback name, remembering preexisting value associated with it\n      callbackName = s.jsonpCallback = isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback; // Insert callback into url or form data\n\n      if (jsonProp) {\n        s[jsonProp] = s[jsonProp].replace(rjsonp, \"$1\" + callbackName);\n      } else if (s.jsonp !== false) {\n        s.url += (rquery.test(s.url) ? \"&\" : \"?\") + s.jsonp + \"=\" + callbackName;\n      } // Use data converter to retrieve json after script execution\n\n\n      s.converters[\"script json\"] = function () {\n        if (!responseContainer) {\n          jQuery.error(callbackName + \" was not called\");\n        }\n\n        return responseContainer[0];\n      }; // Force json dataType\n\n\n      s.dataTypes[0] = \"json\"; // Install callback\n\n      overwritten = window[callbackName];\n\n      window[callbackName] = function () {\n        responseContainer = arguments;\n      }; // Clean-up function (fires after converters)\n\n\n      jqXHR.always(function () {\n        // If previous value didn't exist - remove it\n        if (overwritten === undefined) {\n          jQuery(window).removeProp(callbackName); // Otherwise restore preexisting value\n        } else {\n          window[callbackName] = overwritten;\n        } // Save back as free\n\n\n        if (s[callbackName]) {\n          // Make sure that re-using the options doesn't screw things around\n          s.jsonpCallback = originalSettings.jsonpCallback; // Save the callback name for future use\n\n          oldCallbacks.push(callbackName);\n        } // Call if it was a function and we have a response\n\n\n        if (responseContainer && isFunction(overwritten)) {\n          overwritten(responseContainer[0]);\n        }\n\n        responseContainer = overwritten = undefined;\n      }); // Delegate to script\n\n      return \"script\";\n    }\n  }); // Support: Safari 8 only\n  // In Safari 8 documents created via document.implementation.createHTMLDocument\n  // collapse sibling forms: the second one becomes a child of the first one.\n  // Because of that, this security measure has to be disabled in Safari 8.\n  // https://bugs.webkit.org/show_bug.cgi?id=137337\n\n  support.createHTMLDocument = function () {\n    var body = document.implementation.createHTMLDocument(\"\").body;\n    body.innerHTML = \"<form></form><form></form>\";\n    return body.childNodes.length === 2;\n  }(); // Argument \"data\" should be string of html\n  // context (optional): If specified, the fragment will be created in this context,\n  // defaults to document\n  // keepScripts (optional): If true, will include scripts passed in the html string\n\n\n  jQuery.parseHTML = function (data, context, keepScripts) {\n    if (typeof data !== \"string\") {\n      return [];\n    }\n\n    if (typeof context === \"boolean\") {\n      keepScripts = context;\n      context = false;\n    }\n\n    var base, parsed, scripts;\n\n    if (!context) {\n      // Stop scripts or inline event handlers from being executed immediately\n      // by using document.implementation\n      if (support.createHTMLDocument) {\n        context = document.implementation.createHTMLDocument(\"\"); // Set the base href for the created document\n        // so any parsed elements with URLs\n        // are based on the document's URL (gh-2965)\n\n        base = context.createElement(\"base\");\n        base.href = document.location.href;\n        context.head.appendChild(base);\n      } else {\n        context = document;\n      }\n    }\n\n    parsed = rsingleTag.exec(data);\n    scripts = !keepScripts && []; // Single tag\n\n    if (parsed) {\n      return [context.createElement(parsed[1])];\n    }\n\n    parsed = buildFragment([data], context, scripts);\n\n    if (scripts && scripts.length) {\n      jQuery(scripts).remove();\n    }\n\n    return jQuery.merge([], parsed.childNodes);\n  };\n  /**\n   * Load a url into a page\n   */\n\n\n  jQuery.fn.load = function (url, params, callback) {\n    var selector,\n        type,\n        response,\n        self = this,\n        off = url.indexOf(\" \");\n\n    if (off > -1) {\n      selector = stripAndCollapse(url.slice(off));\n      url = url.slice(0, off);\n    } // If it's a function\n\n\n    if (isFunction(params)) {\n      // We assume that it's the callback\n      callback = params;\n      params = undefined; // Otherwise, build a param string\n    } else if (params && _typeof(params) === \"object\") {\n      type = \"POST\";\n    } // If we have elements to modify, make the request\n\n\n    if (self.length > 0) {\n      jQuery.ajax({\n        url: url,\n        // If \"type\" variable is undefined, then \"GET\" method will be used.\n        // Make value of this field explicit since\n        // user can override it through ajaxSetup method\n        type: type || \"GET\",\n        dataType: \"html\",\n        data: params\n      }).done(function (responseText) {\n        // Save response for use in complete callback\n        response = arguments;\n        self.html(selector ? // If a selector was specified, locate the right elements in a dummy div\n        // Exclude scripts to avoid IE 'Permission Denied' errors\n        jQuery(\"<div>\").append(jQuery.parseHTML(responseText)).find(selector) : // Otherwise use the full result\n        responseText); // If the request succeeds, this function gets \"data\", \"status\", \"jqXHR\"\n        // but they are ignored because response was set above.\n        // If it fails, this function gets \"jqXHR\", \"status\", \"error\"\n      }).always(callback && function (jqXHR, status) {\n        self.each(function () {\n          callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);\n        });\n      });\n    }\n\n    return this;\n  };\n\n  jQuery.expr.pseudos.animated = function (elem) {\n    return jQuery.grep(jQuery.timers, function (fn) {\n      return elem === fn.elem;\n    }).length;\n  };\n\n  jQuery.offset = {\n    setOffset: function setOffset(elem, options, i) {\n      var curPosition,\n          curLeft,\n          curCSSTop,\n          curTop,\n          curOffset,\n          curCSSLeft,\n          calculatePosition,\n          position = jQuery.css(elem, \"position\"),\n          curElem = jQuery(elem),\n          props = {}; // Set position first, in-case top/left are set even on static elem\n\n      if (position === \"static\") {\n        elem.style.position = \"relative\";\n      }\n\n      curOffset = curElem.offset();\n      curCSSTop = jQuery.css(elem, \"top\");\n      curCSSLeft = jQuery.css(elem, \"left\");\n      calculatePosition = (position === \"absolute\" || position === \"fixed\") && (curCSSTop + curCSSLeft).indexOf(\"auto\") > -1; // Need to be able to calculate position if either\n      // top or left is auto and position is either absolute or fixed\n\n      if (calculatePosition) {\n        curPosition = curElem.position();\n        curTop = curPosition.top;\n        curLeft = curPosition.left;\n      } else {\n        curTop = parseFloat(curCSSTop) || 0;\n        curLeft = parseFloat(curCSSLeft) || 0;\n      }\n\n      if (isFunction(options)) {\n        // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\n        options = options.call(elem, i, jQuery.extend({}, curOffset));\n      }\n\n      if (options.top != null) {\n        props.top = options.top - curOffset.top + curTop;\n      }\n\n      if (options.left != null) {\n        props.left = options.left - curOffset.left + curLeft;\n      }\n\n      if (\"using\" in options) {\n        options.using.call(elem, props);\n      } else {\n        if (typeof props.top === \"number\") {\n          props.top += \"px\";\n        }\n\n        if (typeof props.left === \"number\") {\n          props.left += \"px\";\n        }\n\n        curElem.css(props);\n      }\n    }\n  };\n  jQuery.fn.extend({\n    // offset() relates an element's border box to the document origin\n    offset: function offset(options) {\n      // Preserve chaining for setter\n      if (arguments.length) {\n        return options === undefined ? this : this.each(function (i) {\n          jQuery.offset.setOffset(this, options, i);\n        });\n      }\n\n      var rect,\n          win,\n          elem = this[0];\n\n      if (!elem) {\n        return;\n      } // Return zeros for disconnected and hidden (display: none) elements (gh-2310)\n      // Support: IE <=11 only\n      // Running getBoundingClientRect on a\n      // disconnected node in IE throws an error\n\n\n      if (!elem.getClientRects().length) {\n        return {\n          top: 0,\n          left: 0\n        };\n      } // Get document-relative position by adding viewport scroll to viewport-relative gBCR\n\n\n      rect = elem.getBoundingClientRect();\n      win = elem.ownerDocument.defaultView;\n      return {\n        top: rect.top + win.pageYOffset,\n        left: rect.left + win.pageXOffset\n      };\n    },\n    // position() relates an element's margin box to its offset parent's padding box\n    // This corresponds to the behavior of CSS absolute positioning\n    position: function position() {\n      if (!this[0]) {\n        return;\n      }\n\n      var offsetParent,\n          offset,\n          doc,\n          elem = this[0],\n          parentOffset = {\n        top: 0,\n        left: 0\n      }; // position:fixed elements are offset from the viewport, which itself always has zero offset\n\n      if (jQuery.css(elem, \"position\") === \"fixed\") {\n        // Assume position:fixed implies availability of getBoundingClientRect\n        offset = elem.getBoundingClientRect();\n      } else {\n        offset = this.offset(); // Account for the *real* offset parent, which can be the document or its root element\n        // when a statically positioned element is identified\n\n        doc = elem.ownerDocument;\n        offsetParent = elem.offsetParent || doc.documentElement;\n\n        while (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && jQuery.css(offsetParent, \"position\") === \"static\") {\n          offsetParent = offsetParent.parentNode;\n        }\n\n        if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {\n          // Incorporate borders into its offset, since they are outside its content origin\n          parentOffset = jQuery(offsetParent).offset();\n          parentOffset.top += jQuery.css(offsetParent, \"borderTopWidth\", true);\n          parentOffset.left += jQuery.css(offsetParent, \"borderLeftWidth\", true);\n        }\n      } // Subtract parent offsets and element margins\n\n\n      return {\n        top: offset.top - parentOffset.top - jQuery.css(elem, \"marginTop\", true),\n        left: offset.left - parentOffset.left - jQuery.css(elem, \"marginLeft\", true)\n      };\n    },\n    // This method will return documentElement in the following cases:\n    // 1) For the element inside the iframe without offsetParent, this method will return\n    //    documentElement of the parent window\n    // 2) For the hidden or detached element\n    // 3) For body or html element, i.e. in case of the html node - it will return itself\n    //\n    // but those exceptions were never presented as a real life use-cases\n    // and might be considered as more preferable results.\n    //\n    // This logic, however, is not guaranteed and can change at any point in the future\n    offsetParent: function offsetParent() {\n      return this.map(function () {\n        var offsetParent = this.offsetParent;\n\n        while (offsetParent && jQuery.css(offsetParent, \"position\") === \"static\") {\n          offsetParent = offsetParent.offsetParent;\n        }\n\n        return offsetParent || documentElement;\n      });\n    }\n  }); // Create scrollLeft and scrollTop methods\n\n  jQuery.each({\n    scrollLeft: \"pageXOffset\",\n    scrollTop: \"pageYOffset\"\n  }, function (method, prop) {\n    var top = \"pageYOffset\" === prop;\n\n    jQuery.fn[method] = function (val) {\n      return access(this, function (elem, method, val) {\n        // Coalesce documents and windows\n        var win;\n\n        if (isWindow(elem)) {\n          win = elem;\n        } else if (elem.nodeType === 9) {\n          win = elem.defaultView;\n        }\n\n        if (val === undefined) {\n          return win ? win[prop] : elem[method];\n        }\n\n        if (win) {\n          win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);\n        } else {\n          elem[method] = val;\n        }\n      }, method, val, arguments.length);\n    };\n  }); // Support: Safari <=7 - 9.1, Chrome <=37 - 49\n  // Add the top/left cssHooks using jQuery.fn.position\n  // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n  // Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347\n  // getComputedStyle returns percent when specified for top/left/bottom/right;\n  // rather than make the css module depend on the offset module, just check for it here\n\n  jQuery.each([\"top\", \"left\"], function (_i, prop) {\n    jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {\n      if (computed) {\n        computed = curCSS(elem, prop); // If curCSS returns percentage, fallback to offset\n\n        return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + \"px\" : computed;\n      }\n    });\n  }); // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\n\n  jQuery.each({\n    Height: \"height\",\n    Width: \"width\"\n  }, function (name, type) {\n    jQuery.each({\n      padding: \"inner\" + name,\n      content: type,\n      \"\": \"outer\" + name\n    }, function (defaultExtra, funcName) {\n      // Margin is only for outerHeight, outerWidth\n      jQuery.fn[funcName] = function (margin, value) {\n        var chainable = arguments.length && (defaultExtra || typeof margin !== \"boolean\"),\n            extra = defaultExtra || (margin === true || value === true ? \"margin\" : \"border\");\n        return access(this, function (elem, type, value) {\n          var doc;\n\n          if (isWindow(elem)) {\n            // $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)\n            return funcName.indexOf(\"outer\") === 0 ? elem[\"inner\" + name] : elem.document.documentElement[\"client\" + name];\n          } // Get document width or height\n\n\n          if (elem.nodeType === 9) {\n            doc = elem.documentElement; // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n            // whichever is greatest\n\n            return Math.max(elem.body[\"scroll\" + name], doc[\"scroll\" + name], elem.body[\"offset\" + name], doc[\"offset\" + name], doc[\"client\" + name]);\n          }\n\n          return value === undefined ? // Get width or height on the element, requesting but not forcing parseFloat\n          jQuery.css(elem, type, extra) : // Set width or height on the element\n          jQuery.style(elem, type, value, extra);\n        }, type, chainable ? margin : undefined, chainable);\n      };\n    });\n  });\n  jQuery.each([\"ajaxStart\", \"ajaxStop\", \"ajaxComplete\", \"ajaxError\", \"ajaxSuccess\", \"ajaxSend\"], function (_i, type) {\n    jQuery.fn[type] = function (fn) {\n      return this.on(type, fn);\n    };\n  });\n  jQuery.fn.extend({\n    bind: function bind(types, data, fn) {\n      return this.on(types, null, data, fn);\n    },\n    unbind: function unbind(types, fn) {\n      return this.off(types, null, fn);\n    },\n    delegate: function delegate(selector, types, data, fn) {\n      return this.on(types, selector, data, fn);\n    },\n    undelegate: function undelegate(selector, types, fn) {\n      // ( namespace ) or ( selector, types [, fn] )\n      return arguments.length === 1 ? this.off(selector, \"**\") : this.off(types, selector || \"**\", fn);\n    },\n    hover: function hover(fnOver, fnOut) {\n      return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);\n    }\n  });\n  jQuery.each((\"blur focus focusin focusout resize scroll click dblclick \" + \"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" + \"change select submit keydown keypress keyup contextmenu\").split(\" \"), function (_i, name) {\n    // Handle event binding\n    jQuery.fn[name] = function (data, fn) {\n      return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);\n    };\n  }); // Support: Android <=4.0 only\n  // Make sure we trim BOM and NBSP\n\n  var rtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g; // Bind a function to a context, optionally partially applying any\n  // arguments.\n  // jQuery.proxy is deprecated to promote standards (specifically Function#bind)\n  // However, it is not slated for removal any time soon\n\n  jQuery.proxy = function (fn, context) {\n    var tmp, args, proxy;\n\n    if (typeof context === \"string\") {\n      tmp = fn[context];\n      context = fn;\n      fn = tmp;\n    } // Quick check to determine if target is callable, in the spec\n    // this throws a TypeError, but we will just return undefined.\n\n\n    if (!isFunction(fn)) {\n      return undefined;\n    } // Simulated bind\n\n\n    args = _slice.call(arguments, 2);\n\n    proxy = function proxy() {\n      return fn.apply(context || this, args.concat(_slice.call(arguments)));\n    }; // Set the guid of unique handler to the same of original handler, so it can be removed\n\n\n    proxy.guid = fn.guid = fn.guid || jQuery.guid++;\n    return proxy;\n  };\n\n  jQuery.holdReady = function (hold) {\n    if (hold) {\n      jQuery.readyWait++;\n    } else {\n      jQuery.ready(true);\n    }\n  };\n\n  jQuery.isArray = Array.isArray;\n  jQuery.parseJSON = JSON.parse;\n  jQuery.nodeName = nodeName;\n  jQuery.isFunction = isFunction;\n  jQuery.isWindow = isWindow;\n  jQuery.camelCase = camelCase;\n  jQuery.type = toType;\n  jQuery.now = Date.now;\n\n  jQuery.isNumeric = function (obj) {\n    // As of jQuery 3.0, isNumeric is limited to\n    // strings and numbers (primitives or objects)\n    // that can be coerced to finite numbers (gh-2662)\n    var type = jQuery.type(obj);\n    return (type === \"number\" || type === \"string\") && // parseFloat NaNs numeric-cast false positives (\"\")\n    // ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n    // subtraction forces infinities to NaN\n    !isNaN(obj - parseFloat(obj));\n  };\n\n  jQuery.trim = function (text) {\n    return text == null ? \"\" : (text + \"\").replace(rtrim, \"\");\n  }; // Register as a named AMD module, since jQuery can be concatenated with other\n  // files that may use define, but not via a proper concatenation script that\n  // understands anonymous AMD modules. A named AMD is safest and most robust\n  // way to register. Lowercase jquery is used because AMD module names are\n  // derived from file names, and jQuery is normally delivered in a lowercase\n  // file name. Do this after creating the global so that if an AMD module wants\n  // to call noConflict to hide this version of jQuery, it will work.\n  // Note that for maximum portability, libraries that are not jQuery should\n  // declare themselves as anonymous modules, and avoid setting a global if an\n  // AMD loader is present. jQuery is a special case. For more information, see\n  // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n      return jQuery;\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  }\n\n  var // Map over jQuery in case of overwrite\n  _jQuery = window.jQuery,\n      // Map over the $ in case of overwrite\n  _$ = window.$;\n\n  jQuery.noConflict = function (deep) {\n    if (window.$ === jQuery) {\n      window.$ = _$;\n    }\n\n    if (deep && window.jQuery === jQuery) {\n      window.jQuery = _jQuery;\n    }\n\n    return jQuery;\n  }; // Expose jQuery and $ identifiers, even in AMD\n  // (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n  // and CommonJS for browser emulators (#13566)\n\n\n  if (typeof noGlobal === \"undefined\") {\n    window.jQuery = window.$ = jQuery;\n  }\n\n  return jQuery;\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvanF1ZXJ5L2Rpc3QvanF1ZXJ5LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS9kaXN0L2pxdWVyeS5qcz8xMTU3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogalF1ZXJ5IEphdmFTY3JpcHQgTGlicmFyeSB2My41LjFcbiAqIGh0dHBzOi8vanF1ZXJ5LmNvbS9cbiAqXG4gKiBJbmNsdWRlcyBTaXp6bGUuanNcbiAqIGh0dHBzOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCBKUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cHM6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDIwLTA1LTA0VDIyOjQ5WlxuICovXG4oIGZ1bmN0aW9uKCBnbG9iYWwsIGZhY3RvcnkgKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0aWYgKCB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vIEZvciBDb21tb25KUyBhbmQgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgd2hlcmUgYSBwcm9wZXIgYHdpbmRvd2Bcblx0XHQvLyBpcyBwcmVzZW50LCBleGVjdXRlIHRoZSBmYWN0b3J5IGFuZCBnZXQgalF1ZXJ5LlxuXHRcdC8vIEZvciBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3QgaGF2ZSBhIGB3aW5kb3dgIHdpdGggYSBgZG9jdW1lbnRgXG5cdFx0Ly8gKHN1Y2ggYXMgTm9kZS5qcyksIGV4cG9zZSBhIGZhY3RvcnkgYXMgbW9kdWxlLmV4cG9ydHMuXG5cdFx0Ly8gVGhpcyBhY2NlbnR1YXRlcyB0aGUgbmVlZCBmb3IgdGhlIGNyZWF0aW9uIG9mIGEgcmVhbCBgd2luZG93YC5cblx0XHQvLyBlLmcuIHZhciBqUXVlcnkgPSByZXF1aXJlKFwianF1ZXJ5XCIpKHdpbmRvdyk7XG5cdFx0Ly8gU2VlIHRpY2tldCAjMTQ1NDkgZm9yIG1vcmUgaW5mby5cblx0XHRtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5kb2N1bWVudCA/XG5cdFx0XHRmYWN0b3J5KCBnbG9iYWwsIHRydWUgKSA6XG5cdFx0XHRmdW5jdGlvbiggdyApIHtcblx0XHRcdFx0aWYgKCAhdy5kb2N1bWVudCApIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIFwialF1ZXJ5IHJlcXVpcmVzIGEgd2luZG93IHdpdGggYSBkb2N1bWVudFwiICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhY3RvcnkoIHcgKTtcblx0XHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0ZmFjdG9yeSggZ2xvYmFsICk7XG5cdH1cblxuLy8gUGFzcyB0aGlzIGlmIHdpbmRvdyBpcyBub3QgZGVmaW5lZCB5ZXRcbn0gKSggdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHRoaXMsIGZ1bmN0aW9uKCB3aW5kb3csIG5vR2xvYmFsICkge1xuXG4vLyBFZGdlIDw9IDEyIC0gMTMrLCBGaXJlZm94IDw9MTggLSA0NSssIElFIDEwIC0gMTEsIFNhZmFyaSA1LjEgLSA5KywgaU9TIDYgLSA5LjFcbi8vIHRocm93IGV4Y2VwdGlvbnMgd2hlbiBub24tc3RyaWN0IGNvZGUgKGUuZy4sIEFTUC5ORVQgNC41KSBhY2Nlc3NlcyBzdHJpY3QgbW9kZVxuLy8gYXJndW1lbnRzLmNhbGxlZS5jYWxsZXIgKHRyYWMtMTMzMzUpLiBCdXQgYXMgb2YgalF1ZXJ5IDMuMCAoMjAxNiksIHN0cmljdCBtb2RlIHNob3VsZCBiZSBjb21tb25cbi8vIGVub3VnaCB0aGF0IGFsbCBzdWNoIGF0dGVtcHRzIGFyZSBndWFyZGVkIGluIGEgdHJ5IGJsb2NrLlxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBhcnIgPSBbXTtcblxudmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuXG52YXIgc2xpY2UgPSBhcnIuc2xpY2U7XG5cbnZhciBmbGF0ID0gYXJyLmZsYXQgPyBmdW5jdGlvbiggYXJyYXkgKSB7XG5cdHJldHVybiBhcnIuZmxhdC5jYWxsKCBhcnJheSApO1xufSA6IGZ1bmN0aW9uKCBhcnJheSApIHtcblx0cmV0dXJuIGFyci5jb25jYXQuYXBwbHkoIFtdLCBhcnJheSApO1xufTtcblxuXG52YXIgcHVzaCA9IGFyci5wdXNoO1xuXG52YXIgaW5kZXhPZiA9IGFyci5pbmRleE9mO1xuXG52YXIgY2xhc3MydHlwZSA9IHt9O1xuXG52YXIgdG9TdHJpbmcgPSBjbGFzczJ0eXBlLnRvU3RyaW5nO1xuXG52YXIgaGFzT3duID0gY2xhc3MydHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIGZuVG9TdHJpbmcgPSBoYXNPd24udG9TdHJpbmc7XG5cbnZhciBPYmplY3RGdW5jdGlvblN0cmluZyA9IGZuVG9TdHJpbmcuY2FsbCggT2JqZWN0ICk7XG5cbnZhciBzdXBwb3J0ID0ge307XG5cbnZhciBpc0Z1bmN0aW9uID0gZnVuY3Rpb24gaXNGdW5jdGlvbiggb2JqICkge1xuXG4gICAgICAvLyBTdXBwb3J0OiBDaHJvbWUgPD01NywgRmlyZWZveCA8PTUyXG4gICAgICAvLyBJbiBzb21lIGJyb3dzZXJzLCB0eXBlb2YgcmV0dXJucyBcImZ1bmN0aW9uXCIgZm9yIEhUTUwgPG9iamVjdD4gZWxlbWVudHNcbiAgICAgIC8vIChpLmUuLCBgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwib2JqZWN0XCIgKSA9PT0gXCJmdW5jdGlvblwiYCkuXG4gICAgICAvLyBXZSBkb24ndCB3YW50IHRvIGNsYXNzaWZ5ICphbnkqIERPTSBub2RlIGFzIGEgZnVuY3Rpb24uXG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBvYmoubm9kZVR5cGUgIT09IFwibnVtYmVyXCI7XG4gIH07XG5cblxudmFyIGlzV2luZG93ID0gZnVuY3Rpb24gaXNXaW5kb3coIG9iaiApIHtcblx0XHRyZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqID09PSBvYmoud2luZG93O1xuXHR9O1xuXG5cbnZhciBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcblxuXG5cblx0dmFyIHByZXNlcnZlZFNjcmlwdEF0dHJpYnV0ZXMgPSB7XG5cdFx0dHlwZTogdHJ1ZSxcblx0XHRzcmM6IHRydWUsXG5cdFx0bm9uY2U6IHRydWUsXG5cdFx0bm9Nb2R1bGU6IHRydWVcblx0fTtcblxuXHRmdW5jdGlvbiBET01FdmFsKCBjb2RlLCBub2RlLCBkb2MgKSB7XG5cdFx0ZG9jID0gZG9jIHx8IGRvY3VtZW50O1xuXG5cdFx0dmFyIGksIHZhbCxcblx0XHRcdHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KCBcInNjcmlwdFwiICk7XG5cblx0XHRzY3JpcHQudGV4dCA9IGNvZGU7XG5cdFx0aWYgKCBub2RlICkge1xuXHRcdFx0Zm9yICggaSBpbiBwcmVzZXJ2ZWRTY3JpcHRBdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggNjQrLCBFZGdlIDE4K1xuXHRcdFx0XHQvLyBTb21lIGJyb3dzZXJzIGRvbid0IHN1cHBvcnQgdGhlIFwibm9uY2VcIiBwcm9wZXJ0eSBvbiBzY3JpcHRzLlxuXHRcdFx0XHQvLyBPbiB0aGUgb3RoZXIgaGFuZCwganVzdCB1c2luZyBgZ2V0QXR0cmlidXRlYCBpcyBub3QgZW5vdWdoIGFzXG5cdFx0XHRcdC8vIHRoZSBgbm9uY2VgIGF0dHJpYnV0ZSBpcyByZXNldCB0byBhbiBlbXB0eSBzdHJpbmcgd2hlbmV2ZXIgaXRcblx0XHRcdFx0Ly8gYmVjb21lcyBicm93c2luZy1jb250ZXh0IGNvbm5lY3RlZC5cblx0XHRcdFx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93aGF0d2cvaHRtbC9pc3N1ZXMvMjM2OVxuXHRcdFx0XHQvLyBTZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jbm9uY2UtYXR0cmlidXRlc1xuXHRcdFx0XHQvLyBUaGUgYG5vZGUuZ2V0QXR0cmlidXRlYCBjaGVjayB3YXMgYWRkZWQgZm9yIHRoZSBzYWtlIG9mXG5cdFx0XHRcdC8vIGBqUXVlcnkuZ2xvYmFsRXZhbGAgc28gdGhhdCBpdCBjYW4gZmFrZSBhIG5vbmNlLWNvbnRhaW5pbmcgbm9kZVxuXHRcdFx0XHQvLyB2aWEgYW4gb2JqZWN0LlxuXHRcdFx0XHR2YWwgPSBub2RlWyBpIF0gfHwgbm9kZS5nZXRBdHRyaWJ1dGUgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoIGkgKTtcblx0XHRcdFx0aWYgKCB2YWwgKSB7XG5cdFx0XHRcdFx0c2NyaXB0LnNldEF0dHJpYnV0ZSggaSwgdmFsICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZG9jLmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdCApLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHNjcmlwdCApO1xuXHR9XG5cblxuZnVuY3Rpb24gdG9UeXBlKCBvYmogKSB7XG5cdGlmICggb2JqID09IG51bGwgKSB7XG5cdFx0cmV0dXJuIG9iaiArIFwiXCI7XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHkgKGZ1bmN0aW9uaXNoIFJlZ0V4cClcblx0cmV0dXJuIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiID9cblx0XHRjbGFzczJ0eXBlWyB0b1N0cmluZy5jYWxsKCBvYmogKSBdIHx8IFwib2JqZWN0XCIgOlxuXHRcdHR5cGVvZiBvYmo7XG59XG4vKiBnbG9iYWwgU3ltYm9sICovXG4vLyBEZWZpbmluZyB0aGlzIGdsb2JhbCBpbiAuZXNsaW50cmMuanNvbiB3b3VsZCBjcmVhdGUgYSBkYW5nZXIgb2YgdXNpbmcgdGhlIGdsb2JhbFxuLy8gdW5ndWFyZGVkIGluIGFub3RoZXIgcGxhY2UsIGl0IHNlZW1zIHNhZmVyIHRvIGRlZmluZSBnbG9iYWwgb25seSBmb3IgdGhpcyBtb2R1bGVcblxuXG5cbnZhclxuXHR2ZXJzaW9uID0gXCIzLjUuMVwiLFxuXG5cdC8vIERlZmluZSBhIGxvY2FsIGNvcHkgb2YgalF1ZXJ5XG5cdGpRdWVyeSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblxuXHRcdC8vIFRoZSBqUXVlcnkgb2JqZWN0IGlzIGFjdHVhbGx5IGp1c3QgdGhlIGluaXQgY29uc3RydWN0b3IgJ2VuaGFuY2VkJ1xuXHRcdC8vIE5lZWQgaW5pdCBpZiBqUXVlcnkgaXMgY2FsbGVkIChqdXN0IGFsbG93IGVycm9yIHRvIGJlIHRocm93biBpZiBub3QgaW5jbHVkZWQpXG5cdFx0cmV0dXJuIG5ldyBqUXVlcnkuZm4uaW5pdCggc2VsZWN0b3IsIGNvbnRleHQgKTtcblx0fTtcblxualF1ZXJ5LmZuID0galF1ZXJ5LnByb3RvdHlwZSA9IHtcblxuXHQvLyBUaGUgY3VycmVudCB2ZXJzaW9uIG9mIGpRdWVyeSBiZWluZyB1c2VkXG5cdGpxdWVyeTogdmVyc2lvbixcblxuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LFxuXG5cdC8vIFRoZSBkZWZhdWx0IGxlbmd0aCBvZiBhIGpRdWVyeSBvYmplY3QgaXMgMFxuXHRsZW5ndGg6IDAsXG5cblx0dG9BcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0fSxcblxuXHQvLyBHZXQgdGhlIE50aCBlbGVtZW50IGluIHRoZSBtYXRjaGVkIGVsZW1lbnQgc2V0IE9SXG5cdC8vIEdldCB0aGUgd2hvbGUgbWF0Y2hlZCBlbGVtZW50IHNldCBhcyBhIGNsZWFuIGFycmF5XG5cdGdldDogZnVuY3Rpb24oIG51bSApIHtcblxuXHRcdC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIGluIGEgY2xlYW4gYXJyYXlcblx0XHRpZiAoIG51bSA9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4ganVzdCB0aGUgb25lIGVsZW1lbnQgZnJvbSB0aGUgc2V0XG5cdFx0cmV0dXJuIG51bSA8IDAgPyB0aGlzWyBudW0gKyB0aGlzLmxlbmd0aCBdIDogdGhpc1sgbnVtIF07XG5cdH0sXG5cblx0Ly8gVGFrZSBhbiBhcnJheSBvZiBlbGVtZW50cyBhbmQgcHVzaCBpdCBvbnRvIHRoZSBzdGFja1xuXHQvLyAocmV0dXJuaW5nIHRoZSBuZXcgbWF0Y2hlZCBlbGVtZW50IHNldClcblx0cHVzaFN0YWNrOiBmdW5jdGlvbiggZWxlbXMgKSB7XG5cblx0XHQvLyBCdWlsZCBhIG5ldyBqUXVlcnkgbWF0Y2hlZCBlbGVtZW50IHNldFxuXHRcdHZhciByZXQgPSBqUXVlcnkubWVyZ2UoIHRoaXMuY29uc3RydWN0b3IoKSwgZWxlbXMgKTtcblxuXHRcdC8vIEFkZCB0aGUgb2xkIG9iamVjdCBvbnRvIHRoZSBzdGFjayAoYXMgYSByZWZlcmVuY2UpXG5cdFx0cmV0LnByZXZPYmplY3QgPSB0aGlzO1xuXG5cdFx0Ly8gUmV0dXJuIHRoZSBuZXdseS1mb3JtZWQgZWxlbWVudCBzZXRcblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdC8vIEV4ZWN1dGUgYSBjYWxsYmFjayBmb3IgZXZlcnkgZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBzZXQuXG5cdGVhY2g6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmVhY2goIHRoaXMsIGNhbGxiYWNrICk7XG5cdH0sXG5cblx0bWFwOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkubWFwKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiBjYWxsYmFjay5jYWxsKCBlbGVtLCBpLCBlbGVtICk7XG5cdFx0fSApICk7XG5cdH0sXG5cblx0c2xpY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggc2xpY2UuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApICk7XG5cdH0sXG5cblx0Zmlyc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAwICk7XG5cdH0sXG5cblx0bGFzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIC0xICk7XG5cdH0sXG5cblx0ZXZlbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkuZ3JlcCggdGhpcywgZnVuY3Rpb24oIF9lbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuICggaSArIDEgKSAlIDI7XG5cdFx0fSApICk7XG5cdH0sXG5cblx0b2RkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeS5ncmVwKCB0aGlzLCBmdW5jdGlvbiggX2VsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gaSAlIDI7XG5cdFx0fSApICk7XG5cdH0sXG5cblx0ZXE6IGZ1bmN0aW9uKCBpICkge1xuXHRcdHZhciBsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdGogPSAraSArICggaSA8IDAgPyBsZW4gOiAwICk7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqID49IDAgJiYgaiA8IGxlbiA/IFsgdGhpc1sgaiBdIF0gOiBbXSApO1xuXHR9LFxuXG5cdGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHJldk9iamVjdCB8fCB0aGlzLmNvbnN0cnVjdG9yKCk7XG5cdH0sXG5cblx0Ly8gRm9yIGludGVybmFsIHVzZSBvbmx5LlxuXHQvLyBCZWhhdmVzIGxpa2UgYW4gQXJyYXkncyBtZXRob2QsIG5vdCBsaWtlIGEgalF1ZXJ5IG1ldGhvZC5cblx0cHVzaDogcHVzaCxcblx0c29ydDogYXJyLnNvcnQsXG5cdHNwbGljZTogYXJyLnNwbGljZVxufTtcblxualF1ZXJ5LmV4dGVuZCA9IGpRdWVyeS5mbi5leHRlbmQgPSBmdW5jdGlvbigpIHtcblx0dmFyIG9wdGlvbnMsIG5hbWUsIHNyYywgY29weSwgY29weUlzQXJyYXksIGNsb25lLFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sgMCBdIHx8IHt9LFxuXHRcdGkgPSAxLFxuXHRcdGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cdFx0ZGVlcCA9IGZhbHNlO1xuXG5cdC8vIEhhbmRsZSBhIGRlZXAgY29weSBzaXR1YXRpb25cblx0aWYgKCB0eXBlb2YgdGFyZ2V0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRkZWVwID0gdGFyZ2V0O1xuXG5cdFx0Ly8gU2tpcCB0aGUgYm9vbGVhbiBhbmQgdGhlIHRhcmdldFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sgaSBdIHx8IHt9O1xuXHRcdGkrKztcblx0fVxuXG5cdC8vIEhhbmRsZSBjYXNlIHdoZW4gdGFyZ2V0IGlzIGEgc3RyaW5nIG9yIHNvbWV0aGluZyAocG9zc2libGUgaW4gZGVlcCBjb3B5KVxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIgJiYgIWlzRnVuY3Rpb24oIHRhcmdldCApICkge1xuXHRcdHRhcmdldCA9IHt9O1xuXHR9XG5cblx0Ly8gRXh0ZW5kIGpRdWVyeSBpdHNlbGYgaWYgb25seSBvbmUgYXJndW1lbnQgaXMgcGFzc2VkXG5cdGlmICggaSA9PT0gbGVuZ3RoICkge1xuXHRcdHRhcmdldCA9IHRoaXM7XG5cdFx0aS0tO1xuXHR9XG5cblx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cblx0XHQvLyBPbmx5IGRlYWwgd2l0aCBub24tbnVsbC91bmRlZmluZWQgdmFsdWVzXG5cdFx0aWYgKCAoIG9wdGlvbnMgPSBhcmd1bWVudHNbIGkgXSApICE9IG51bGwgKSB7XG5cblx0XHRcdC8vIEV4dGVuZCB0aGUgYmFzZSBvYmplY3Rcblx0XHRcdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRcdFx0Y29weSA9IG9wdGlvbnNbIG5hbWUgXTtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IE9iamVjdC5wcm90b3R5cGUgcG9sbHV0aW9uXG5cdFx0XHRcdC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3Bcblx0XHRcdFx0aWYgKCBuYW1lID09PSBcIl9fcHJvdG9fX1wiIHx8IHRhcmdldCA9PT0gY29weSApIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlY3Vyc2UgaWYgd2UncmUgbWVyZ2luZyBwbGFpbiBvYmplY3RzIG9yIGFycmF5c1xuXHRcdFx0XHRpZiAoIGRlZXAgJiYgY29weSAmJiAoIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb3B5ICkgfHxcblx0XHRcdFx0XHQoIGNvcHlJc0FycmF5ID0gQXJyYXkuaXNBcnJheSggY29weSApICkgKSApIHtcblx0XHRcdFx0XHRzcmMgPSB0YXJnZXRbIG5hbWUgXTtcblxuXHRcdFx0XHRcdC8vIEVuc3VyZSBwcm9wZXIgdHlwZSBmb3IgdGhlIHNvdXJjZSB2YWx1ZVxuXHRcdFx0XHRcdGlmICggY29weUlzQXJyYXkgJiYgIUFycmF5LmlzQXJyYXkoIHNyYyApICkge1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBbXTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCAhY29weUlzQXJyYXkgJiYgIWpRdWVyeS5pc1BsYWluT2JqZWN0KCBzcmMgKSApIHtcblx0XHRcdFx0XHRcdGNsb25lID0ge307XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNsb25lID0gc3JjO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb3B5SXNBcnJheSA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0Ly8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBqUXVlcnkuZXh0ZW5kKCBkZWVwLCBjbG9uZSwgY29weSApO1xuXG5cdFx0XHRcdC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcblx0XHRcdFx0fSBlbHNlIGlmICggY29weSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0gY29weTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gVW5pcXVlIGZvciBlYWNoIGNvcHkgb2YgalF1ZXJ5IG9uIHRoZSBwYWdlXG5cdGV4cGFuZG86IFwialF1ZXJ5XCIgKyAoIHZlcnNpb24gKyBNYXRoLnJhbmRvbSgpICkucmVwbGFjZSggL1xcRC9nLCBcIlwiICksXG5cblx0Ly8gQXNzdW1lIGpRdWVyeSBpcyByZWFkeSB3aXRob3V0IHRoZSByZWFkeSBtb2R1bGVcblx0aXNSZWFkeTogdHJ1ZSxcblxuXHRlcnJvcjogZnVuY3Rpb24oIG1zZyApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xuXHR9LFxuXG5cdG5vb3A6IGZ1bmN0aW9uKCkge30sXG5cblx0aXNQbGFpbk9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblx0XHR2YXIgcHJvdG8sIEN0b3I7XG5cblx0XHQvLyBEZXRlY3Qgb2J2aW91cyBuZWdhdGl2ZXNcblx0XHQvLyBVc2UgdG9TdHJpbmcgaW5zdGVhZCBvZiBqUXVlcnkudHlwZSB0byBjYXRjaCBob3N0IG9iamVjdHNcblx0XHRpZiAoICFvYmogfHwgdG9TdHJpbmcuY2FsbCggb2JqICkgIT09IFwiW29iamVjdCBPYmplY3RdXCIgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cHJvdG8gPSBnZXRQcm90byggb2JqICk7XG5cblx0XHQvLyBPYmplY3RzIHdpdGggbm8gcHJvdG90eXBlIChlLmcuLCBgT2JqZWN0LmNyZWF0ZSggbnVsbCApYCkgYXJlIHBsYWluXG5cdFx0aWYgKCAhcHJvdG8gKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBPYmplY3RzIHdpdGggcHJvdG90eXBlIGFyZSBwbGFpbiBpZmYgdGhleSB3ZXJlIGNvbnN0cnVjdGVkIGJ5IGEgZ2xvYmFsIE9iamVjdCBmdW5jdGlvblxuXHRcdEN0b3IgPSBoYXNPd24uY2FsbCggcHJvdG8sIFwiY29uc3RydWN0b3JcIiApICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuXHRcdHJldHVybiB0eXBlb2YgQ3RvciA9PT0gXCJmdW5jdGlvblwiICYmIGZuVG9TdHJpbmcuY2FsbCggQ3RvciApID09PSBPYmplY3RGdW5jdGlvblN0cmluZztcblx0fSxcblxuXHRpc0VtcHR5T2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHZhciBuYW1lO1xuXG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdC8vIEV2YWx1YXRlcyBhIHNjcmlwdCBpbiBhIHByb3ZpZGVkIGNvbnRleHQ7IGZhbGxzIGJhY2sgdG8gdGhlIGdsb2JhbCBvbmVcblx0Ly8gaWYgbm90IHNwZWNpZmllZC5cblx0Z2xvYmFsRXZhbDogZnVuY3Rpb24oIGNvZGUsIG9wdGlvbnMsIGRvYyApIHtcblx0XHRET01FdmFsKCBjb2RlLCB7IG5vbmNlOiBvcHRpb25zICYmIG9wdGlvbnMubm9uY2UgfSwgZG9jICk7XG5cdH0sXG5cblx0ZWFjaDogZnVuY3Rpb24oIG9iaiwgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIGxlbmd0aCwgaSA9IDA7XG5cblx0XHRpZiAoIGlzQXJyYXlMaWtlKCBvYmogKSApIHtcblx0XHRcdGxlbmd0aCA9IG9iai5sZW5ndGg7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICggaSBpbiBvYmogKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG9iajtcblx0fSxcblxuXHQvLyByZXN1bHRzIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1ha2VBcnJheTogZnVuY3Rpb24oIGFyciwgcmVzdWx0cyApIHtcblx0XHR2YXIgcmV0ID0gcmVzdWx0cyB8fCBbXTtcblxuXHRcdGlmICggYXJyICE9IG51bGwgKSB7XG5cdFx0XHRpZiAoIGlzQXJyYXlMaWtlKCBPYmplY3QoIGFyciApICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggcmV0LFxuXHRcdFx0XHRcdHR5cGVvZiBhcnIgPT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdFsgYXJyIF0gOiBhcnJcblx0XHRcdFx0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guY2FsbCggcmV0LCBhcnIgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdGluQXJyYXk6IGZ1bmN0aW9uKCBlbGVtLCBhcnIsIGkgKSB7XG5cdFx0cmV0dXJuIGFyciA9PSBudWxsID8gLTEgOiBpbmRleE9mLmNhbGwoIGFyciwgZWxlbSwgaSApO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdG1lcmdlOiBmdW5jdGlvbiggZmlyc3QsIHNlY29uZCApIHtcblx0XHR2YXIgbGVuID0gK3NlY29uZC5sZW5ndGgsXG5cdFx0XHRqID0gMCxcblx0XHRcdGkgPSBmaXJzdC5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGogPCBsZW47IGorKyApIHtcblx0XHRcdGZpcnN0WyBpKysgXSA9IHNlY29uZFsgaiBdO1xuXHRcdH1cblxuXHRcdGZpcnN0Lmxlbmd0aCA9IGk7XG5cblx0XHRyZXR1cm4gZmlyc3Q7XG5cdH0sXG5cblx0Z3JlcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgaW52ZXJ0ICkge1xuXHRcdHZhciBjYWxsYmFja0ludmVyc2UsXG5cdFx0XHRtYXRjaGVzID0gW10sXG5cdFx0XHRpID0gMCxcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aCxcblx0XHRcdGNhbGxiYWNrRXhwZWN0ID0gIWludmVydDtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCBvbmx5IHNhdmluZyB0aGUgaXRlbXNcblx0XHQvLyB0aGF0IHBhc3MgdGhlIHZhbGlkYXRvciBmdW5jdGlvblxuXHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0Y2FsbGJhY2tJbnZlcnNlID0gIWNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpICk7XG5cdFx0XHRpZiAoIGNhbGxiYWNrSW52ZXJzZSAhPT0gY2FsbGJhY2tFeHBlY3QgKSB7XG5cdFx0XHRcdG1hdGNoZXMucHVzaCggZWxlbXNbIGkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBtYXRjaGVzO1xuXHR9LFxuXG5cdC8vIGFyZyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuXHRtYXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGFyZyApIHtcblx0XHR2YXIgbGVuZ3RoLCB2YWx1ZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0cmV0ID0gW107XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgdHJhbnNsYXRpbmcgZWFjaCBvZiB0aGUgaXRlbXMgdG8gdGhlaXIgbmV3IHZhbHVlc1xuXHRcdGlmICggaXNBcnJheUxpa2UoIGVsZW1zICkgKSB7XG5cdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGg7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdHJldC5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBHbyB0aHJvdWdoIGV2ZXJ5IGtleSBvbiB0aGUgb2JqZWN0LFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKCBpIGluIGVsZW1zICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG5cdFx0cmV0dXJuIGZsYXQoIHJldCApO1xuXHR9LFxuXG5cdC8vIEEgZ2xvYmFsIEdVSUQgY291bnRlciBmb3Igb2JqZWN0c1xuXHRndWlkOiAxLFxuXG5cdC8vIGpRdWVyeS5zdXBwb3J0IGlzIG5vdCB1c2VkIGluIENvcmUgYnV0IG90aGVyIHByb2plY3RzIGF0dGFjaCB0aGVpclxuXHQvLyBwcm9wZXJ0aWVzIHRvIGl0IHNvIGl0IG5lZWRzIHRvIGV4aXN0LlxuXHRzdXBwb3J0OiBzdXBwb3J0XG59ICk7XG5cbmlmICggdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICkge1xuXHRqUXVlcnkuZm5bIFN5bWJvbC5pdGVyYXRvciBdID0gYXJyWyBTeW1ib2wuaXRlcmF0b3IgXTtcbn1cblxuLy8gUG9wdWxhdGUgdGhlIGNsYXNzMnR5cGUgbWFwXG5qUXVlcnkuZWFjaCggXCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgT2JqZWN0IEVycm9yIFN5bWJvbFwiLnNwbGl0KCBcIiBcIiApLFxuZnVuY3Rpb24oIF9pLCBuYW1lICkge1xuXHRjbGFzczJ0eXBlWyBcIltvYmplY3QgXCIgKyBuYW1lICsgXCJdXCIgXSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbn0gKTtcblxuZnVuY3Rpb24gaXNBcnJheUxpa2UoIG9iaiApIHtcblxuXHQvLyBTdXBwb3J0OiByZWFsIGlPUyA4LjIgb25seSAobm90IHJlcHJvZHVjaWJsZSBpbiBzaW11bGF0b3IpXG5cdC8vIGBpbmAgY2hlY2sgdXNlZCB0byBwcmV2ZW50IEpJVCBlcnJvciAoZ2gtMjE0NSlcblx0Ly8gaGFzT3duIGlzbid0IHVzZWQgaGVyZSBkdWUgdG8gZmFsc2UgbmVnYXRpdmVzXG5cdC8vIHJlZ2FyZGluZyBOb2RlbGlzdCBsZW5ndGggaW4gSUVcblx0dmFyIGxlbmd0aCA9ICEhb2JqICYmIFwibGVuZ3RoXCIgaW4gb2JqICYmIG9iai5sZW5ndGgsXG5cdFx0dHlwZSA9IHRvVHlwZSggb2JqICk7XG5cblx0aWYgKCBpc0Z1bmN0aW9uKCBvYmogKSB8fCBpc1dpbmRvdyggb2JqICkgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0cmV0dXJuIHR5cGUgPT09IFwiYXJyYXlcIiB8fCBsZW5ndGggPT09IDAgfHxcblx0XHR0eXBlb2YgbGVuZ3RoID09PSBcIm51bWJlclwiICYmIGxlbmd0aCA+IDAgJiYgKCBsZW5ndGggLSAxICkgaW4gb2JqO1xufVxudmFyIFNpenpsZSA9XG4vKiFcbiAqIFNpenpsZSBDU1MgU2VsZWN0b3IgRW5naW5lIHYyLjMuNVxuICogaHR0cHM6Ly9zaXp6bGVqcy5jb20vXG4gKlxuICogQ29weXJpZ2h0IEpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwczovL2pzLmZvdW5kYXRpb24vXG4gKlxuICogRGF0ZTogMjAyMC0wMy0xNFxuICovXG4oIGZ1bmN0aW9uKCB3aW5kb3cgKSB7XG52YXIgaSxcblx0c3VwcG9ydCxcblx0RXhwcixcblx0Z2V0VGV4dCxcblx0aXNYTUwsXG5cdHRva2VuaXplLFxuXHRjb21waWxlLFxuXHRzZWxlY3QsXG5cdG91dGVybW9zdENvbnRleHQsXG5cdHNvcnRJbnB1dCxcblx0aGFzRHVwbGljYXRlLFxuXG5cdC8vIExvY2FsIGRvY3VtZW50IHZhcnNcblx0c2V0RG9jdW1lbnQsXG5cdGRvY3VtZW50LFxuXHRkb2NFbGVtLFxuXHRkb2N1bWVudElzSFRNTCxcblx0cmJ1Z2d5UVNBLFxuXHRyYnVnZ3lNYXRjaGVzLFxuXHRtYXRjaGVzLFxuXHRjb250YWlucyxcblxuXHQvLyBJbnN0YW5jZS1zcGVjaWZpYyBkYXRhXG5cdGV4cGFuZG8gPSBcInNpenpsZVwiICsgMSAqIG5ldyBEYXRlKCksXG5cdHByZWZlcnJlZERvYyA9IHdpbmRvdy5kb2N1bWVudCxcblx0ZGlycnVucyA9IDAsXG5cdGRvbmUgPSAwLFxuXHRjbGFzc0NhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0dG9rZW5DYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdGNvbXBpbGVyQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRub25uYXRpdmVTZWxlY3RvckNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0c29ydE9yZGVyID0gZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIDA7XG5cdH0sXG5cblx0Ly8gSW5zdGFuY2UgbWV0aG9kc1xuXHRoYXNPd24gPSAoIHt9ICkuaGFzT3duUHJvcGVydHksXG5cdGFyciA9IFtdLFxuXHRwb3AgPSBhcnIucG9wLFxuXHRwdXNoTmF0aXZlID0gYXJyLnB1c2gsXG5cdHB1c2ggPSBhcnIucHVzaCxcblx0c2xpY2UgPSBhcnIuc2xpY2UsXG5cblx0Ly8gVXNlIGEgc3RyaXBwZWQtZG93biBpbmRleE9mIGFzIGl0J3MgZmFzdGVyIHRoYW4gbmF0aXZlXG5cdC8vIGh0dHBzOi8vanNwZXJmLmNvbS90aG9yLWluZGV4b2YtdnMtZm9yLzVcblx0aW5kZXhPZiA9IGZ1bmN0aW9uKCBsaXN0LCBlbGVtICkge1xuXHRcdHZhciBpID0gMCxcblx0XHRcdGxlbiA9IGxpc3QubGVuZ3RoO1xuXHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0aWYgKCBsaXN0WyBpIF0gPT09IGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gLTE7XG5cdH0sXG5cblx0Ym9vbGVhbnMgPSBcImNoZWNrZWR8c2VsZWN0ZWR8YXN5bmN8YXV0b2ZvY3VzfGF1dG9wbGF5fGNvbnRyb2xzfGRlZmVyfGRpc2FibGVkfGhpZGRlbnxcIiArXG5cdFx0XCJpc21hcHxsb29wfG11bHRpcGxlfG9wZW58cmVhZG9ubHl8cmVxdWlyZWR8c2NvcGVkXCIsXG5cblx0Ly8gUmVndWxhciBleHByZXNzaW9uc1xuXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtc2VsZWN0b3JzLyN3aGl0ZXNwYWNlXG5cdHdoaXRlc3BhY2UgPSBcIltcXFxceDIwXFxcXHRcXFxcclxcXFxuXFxcXGZdXCIsXG5cblx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2Nzcy1zeW50YXgtMy8jaWRlbnQtdG9rZW4tZGlhZ3JhbVxuXHRpZGVudGlmaWVyID0gXCIoPzpcXFxcXFxcXFtcXFxcZGEtZkEtRl17MSw2fVwiICsgd2hpdGVzcGFjZSArXG5cdFx0XCI/fFxcXFxcXFxcW15cXFxcclxcXFxuXFxcXGZdfFtcXFxcdy1dfFteXFwwLVxcXFx4N2ZdKStcIixcblxuXHQvLyBBdHRyaWJ1dGUgc2VsZWN0b3JzOiBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2F0dHJpYnV0ZS1zZWxlY3RvcnNcblx0YXR0cmlidXRlcyA9IFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooXCIgKyBpZGVudGlmaWVyICsgXCIpKD86XCIgKyB3aGl0ZXNwYWNlICtcblxuXHRcdC8vIE9wZXJhdG9yIChjYXB0dXJlIDIpXG5cdFx0XCIqKFsqXiR8IX5dPz0pXCIgKyB3aGl0ZXNwYWNlICtcblxuXHRcdC8vIFwiQXR0cmlidXRlIHZhbHVlcyBtdXN0IGJlIENTUyBpZGVudGlmaWVycyBbY2FwdHVyZSA1XVxuXHRcdC8vIG9yIHN0cmluZ3MgW2NhcHR1cmUgMyBvciBjYXB0dXJlIDRdXCJcblx0XHRcIiooPzonKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCJ8KFwiICsgaWRlbnRpZmllciArIFwiKSl8KVwiICtcblx0XHR3aGl0ZXNwYWNlICsgXCIqXFxcXF1cIixcblxuXHRwc2V1ZG9zID0gXCI6KFwiICsgaWRlbnRpZmllciArIFwiKSg/OlxcXFwoKFwiICtcblxuXHRcdC8vIFRvIHJlZHVjZSB0aGUgbnVtYmVyIG9mIHNlbGVjdG9ycyBuZWVkaW5nIHRva2VuaXplIGluIHRoZSBwcmVGaWx0ZXIsIHByZWZlciBhcmd1bWVudHM6XG5cdFx0Ly8gMS4gcXVvdGVkIChjYXB0dXJlIDM7IGNhcHR1cmUgNCBvciBjYXB0dXJlIDUpXG5cdFx0XCIoJygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwiKXxcIiArXG5cblx0XHQvLyAyLiBzaW1wbGUgKGNhcHR1cmUgNilcblx0XHRcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpW1xcXFxdXXxcIiArIGF0dHJpYnV0ZXMgKyBcIikqKXxcIiArXG5cblx0XHQvLyAzLiBhbnl0aGluZyBlbHNlIChjYXB0dXJlIDIpXG5cdFx0XCIuKlwiICtcblx0XHRcIilcXFxcKXwpXCIsXG5cblx0Ly8gTGVhZGluZyBhbmQgbm9uLWVzY2FwZWQgdHJhaWxpbmcgd2hpdGVzcGFjZSwgY2FwdHVyaW5nIHNvbWUgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVycyBwcmVjZWRpbmcgdGhlIGxhdHRlclxuXHRyd2hpdGVzcGFjZSA9IG5ldyBSZWdFeHAoIHdoaXRlc3BhY2UgKyBcIitcIiwgXCJnXCIgKSxcblx0cnRyaW0gPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIit8KCg/Ol58W15cXFxcXFxcXF0pKD86XFxcXFxcXFwuKSopXCIgK1xuXHRcdHdoaXRlc3BhY2UgKyBcIiskXCIsIFwiZ1wiICksXG5cblx0cmNvbW1hID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqLFwiICsgd2hpdGVzcGFjZSArIFwiKlwiICksXG5cdHJjb21iaW5hdG9ycyA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKihbPit+XXxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFwiKlwiICksXG5cdHJkZXNjZW5kID0gbmV3IFJlZ0V4cCggd2hpdGVzcGFjZSArIFwifD5cIiApLFxuXG5cdHJwc2V1ZG8gPSBuZXcgUmVnRXhwKCBwc2V1ZG9zICksXG5cdHJpZGVudGlmaWVyID0gbmV3IFJlZ0V4cCggXCJeXCIgKyBpZGVudGlmaWVyICsgXCIkXCIgKSxcblxuXHRtYXRjaEV4cHIgPSB7XG5cdFx0XCJJRFwiOiBuZXcgUmVnRXhwKCBcIl4jKFwiICsgaWRlbnRpZmllciArIFwiKVwiICksXG5cdFx0XCJDTEFTU1wiOiBuZXcgUmVnRXhwKCBcIl5cXFxcLihcIiArIGlkZW50aWZpZXIgKyBcIilcIiApLFxuXHRcdFwiVEFHXCI6IG5ldyBSZWdFeHAoIFwiXihcIiArIGlkZW50aWZpZXIgKyBcInxbKl0pXCIgKSxcblx0XHRcIkFUVFJcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBhdHRyaWJ1dGVzICksXG5cdFx0XCJQU0VVRE9cIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBwc2V1ZG9zICksXG5cdFx0XCJDSElMRFwiOiBuZXcgUmVnRXhwKCBcIl46KG9ubHl8Zmlyc3R8bGFzdHxudGh8bnRoLWxhc3QpLShjaGlsZHxvZi10eXBlKSg/OlxcXFwoXCIgK1xuXHRcdFx0d2hpdGVzcGFjZSArIFwiKihldmVufG9kZHwoKFsrLV18KShcXFxcZCopbnwpXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86KFsrLV18KVwiICtcblx0XHRcdHdoaXRlc3BhY2UgKyBcIiooXFxcXGQrKXwpKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfClcIiwgXCJpXCIgKSxcblx0XHRcImJvb2xcIjogbmV3IFJlZ0V4cCggXCJeKD86XCIgKyBib29sZWFucyArIFwiKSRcIiwgXCJpXCIgKSxcblxuXHRcdC8vIEZvciB1c2UgaW4gbGlicmFyaWVzIGltcGxlbWVudGluZyAuaXMoKVxuXHRcdC8vIFdlIHVzZSB0aGlzIGZvciBQT1MgbWF0Y2hpbmcgaW4gYHNlbGVjdGBcblx0XHRcIm5lZWRzQ29udGV4dFwiOiBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XCIqWz4rfl18OihldmVufG9kZHxlcXxndHxsdHxudGh8Zmlyc3R8bGFzdCkoPzpcXFxcKFwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIiooKD86LVxcXFxkKT9cXFxcZCopXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KSg/PVteLV18JClcIiwgXCJpXCIgKVxuXHR9LFxuXG5cdHJodG1sID0gL0hUTUwkL2ksXG5cdHJpbnB1dHMgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuXHRyaGVhZGVyID0gL15oXFxkJC9pLFxuXG5cdHJuYXRpdmUgPSAvXltee10rXFx7XFxzKlxcW25hdGl2ZSBcXHcvLFxuXG5cdC8vIEVhc2lseS1wYXJzZWFibGUvcmV0cmlldmFibGUgSUQgb3IgVEFHIG9yIENMQVNTIHNlbGVjdG9yc1xuXHRycXVpY2tFeHByID0gL14oPzojKFtcXHctXSspfChcXHcrKXxcXC4oW1xcdy1dKykpJC8sXG5cblx0cnNpYmxpbmcgPSAvWyt+XS8sXG5cblx0Ly8gQ1NTIGVzY2FwZXNcblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI2VzY2FwZWQtY2hhcmFjdGVyc1xuXHRydW5lc2NhcGUgPSBuZXcgUmVnRXhwKCBcIlxcXFxcXFxcW1xcXFxkYS1mQS1GXXsxLDZ9XCIgKyB3aGl0ZXNwYWNlICsgXCI/fFxcXFxcXFxcKFteXFxcXHJcXFxcblxcXFxmXSlcIiwgXCJnXCIgKSxcblx0ZnVuZXNjYXBlID0gZnVuY3Rpb24oIGVzY2FwZSwgbm9uSGV4ICkge1xuXHRcdHZhciBoaWdoID0gXCIweFwiICsgZXNjYXBlLnNsaWNlKCAxICkgLSAweDEwMDAwO1xuXG5cdFx0cmV0dXJuIG5vbkhleCA/XG5cblx0XHRcdC8vIFN0cmlwIHRoZSBiYWNrc2xhc2ggcHJlZml4IGZyb20gYSBub24taGV4IGVzY2FwZSBzZXF1ZW5jZVxuXHRcdFx0bm9uSGV4IDpcblxuXHRcdFx0Ly8gUmVwbGFjZSBhIGhleGFkZWNpbWFsIGVzY2FwZSBzZXF1ZW5jZSB3aXRoIHRoZSBlbmNvZGVkIFVuaWNvZGUgY29kZSBwb2ludFxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgPD0xMStcblx0XHRcdC8vIEZvciB2YWx1ZXMgb3V0c2lkZSB0aGUgQmFzaWMgTXVsdGlsaW5ndWFsIFBsYW5lIChCTVApLCBtYW51YWxseSBjb25zdHJ1Y3QgYVxuXHRcdFx0Ly8gc3Vycm9nYXRlIHBhaXJcblx0XHRcdGhpZ2ggPCAwID9cblx0XHRcdFx0U3RyaW5nLmZyb21DaGFyQ29kZSggaGlnaCArIDB4MTAwMDAgKSA6XG5cdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggPj4gMTAgfCAweEQ4MDAsIGhpZ2ggJiAweDNGRiB8IDB4REMwMCApO1xuXHR9LFxuXG5cdC8vIENTUyBzdHJpbmcvaWRlbnRpZmllciBzZXJpYWxpemF0aW9uXG5cdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jY29tbW9uLXNlcmlhbGl6aW5nLWlkaW9tc1xuXHRyY3NzZXNjYXBlID0gLyhbXFwwLVxceDFmXFx4N2ZdfF4tP1xcZCl8Xi0kfFteXFwwLVxceDFmXFx4N2YtXFx1RkZGRlxcdy1dL2csXG5cdGZjc3Nlc2NhcGUgPSBmdW5jdGlvbiggY2gsIGFzQ29kZVBvaW50ICkge1xuXHRcdGlmICggYXNDb2RlUG9pbnQgKSB7XG5cblx0XHRcdC8vIFUrMDAwMCBOVUxMIGJlY29tZXMgVStGRkZEIFJFUExBQ0VNRU5UIENIQVJBQ1RFUlxuXHRcdFx0aWYgKCBjaCA9PT0gXCJcXDBcIiApIHtcblx0XHRcdFx0cmV0dXJuIFwiXFx1RkZGRFwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb250cm9sIGNoYXJhY3RlcnMgYW5kIChkZXBlbmRlbnQgdXBvbiBwb3NpdGlvbikgbnVtYmVycyBnZXQgZXNjYXBlZCBhcyBjb2RlIHBvaW50c1xuXHRcdFx0cmV0dXJuIGNoLnNsaWNlKCAwLCAtMSApICsgXCJcXFxcXCIgK1xuXHRcdFx0XHRjaC5jaGFyQ29kZUF0KCBjaC5sZW5ndGggLSAxICkudG9TdHJpbmcoIDE2ICkgKyBcIiBcIjtcblx0XHR9XG5cblx0XHQvLyBPdGhlciBwb3RlbnRpYWxseS1zcGVjaWFsIEFTQ0lJIGNoYXJhY3RlcnMgZ2V0IGJhY2tzbGFzaC1lc2NhcGVkXG5cdFx0cmV0dXJuIFwiXFxcXFwiICsgY2g7XG5cdH0sXG5cblx0Ly8gVXNlZCBmb3IgaWZyYW1lc1xuXHQvLyBTZWUgc2V0RG9jdW1lbnQoKVxuXHQvLyBSZW1vdmluZyB0aGUgZnVuY3Rpb24gd3JhcHBlciBjYXVzZXMgYSBcIlBlcm1pc3Npb24gRGVuaWVkXCJcblx0Ly8gZXJyb3IgaW4gSUVcblx0dW5sb2FkSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuXHRcdHNldERvY3VtZW50KCk7XG5cdH0sXG5cblx0aW5EaXNhYmxlZEZpZWxkc2V0ID0gYWRkQ29tYmluYXRvcihcblx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSB0cnVlICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJmaWVsZHNldFwiO1xuXHRcdH0sXG5cdFx0eyBkaXI6IFwicGFyZW50Tm9kZVwiLCBuZXh0OiBcImxlZ2VuZFwiIH1cblx0KTtcblxuLy8gT3B0aW1pemUgZm9yIHB1c2guYXBwbHkoIF8sIE5vZGVMaXN0IClcbnRyeSB7XG5cdHB1c2guYXBwbHkoXG5cdFx0KCBhcnIgPSBzbGljZS5jYWxsKCBwcmVmZXJyZWREb2MuY2hpbGROb2RlcyApICksXG5cdFx0cHJlZmVycmVkRG9jLmNoaWxkTm9kZXNcblx0KTtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMFxuXHQvLyBEZXRlY3Qgc2lsZW50bHkgZmFpbGluZyBwdXNoLmFwcGx5XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcblx0YXJyWyBwcmVmZXJyZWREb2MuY2hpbGROb2Rlcy5sZW5ndGggXS5ub2RlVHlwZTtcbn0gY2F0Y2ggKCBlICkge1xuXHRwdXNoID0geyBhcHBseTogYXJyLmxlbmd0aCA/XG5cblx0XHQvLyBMZXZlcmFnZSBzbGljZSBpZiBwb3NzaWJsZVxuXHRcdGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcblx0XHRcdHB1c2hOYXRpdmUuYXBwbHkoIHRhcmdldCwgc2xpY2UuY2FsbCggZWxzICkgKTtcblx0XHR9IDpcblxuXHRcdC8vIFN1cHBvcnQ6IElFPDlcblx0XHQvLyBPdGhlcndpc2UgYXBwZW5kIGRpcmVjdGx5XG5cdFx0ZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xuXHRcdFx0dmFyIGogPSB0YXJnZXQubGVuZ3RoLFxuXHRcdFx0XHRpID0gMDtcblxuXHRcdFx0Ly8gQ2FuJ3QgdHJ1c3QgTm9kZUxpc3QubGVuZ3RoXG5cdFx0XHR3aGlsZSAoICggdGFyZ2V0WyBqKysgXSA9IGVsc1sgaSsrIF0gKSApIHt9XG5cdFx0XHR0YXJnZXQubGVuZ3RoID0gaiAtIDE7XG5cdFx0fVxuXHR9O1xufVxuXG5mdW5jdGlvbiBTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuXHR2YXIgbSwgaSwgZWxlbSwgbmlkLCBtYXRjaCwgZ3JvdXBzLCBuZXdTZWxlY3Rvcixcblx0XHRuZXdDb250ZXh0ID0gY29udGV4dCAmJiBjb250ZXh0Lm93bmVyRG9jdW1lbnQsXG5cblx0XHQvLyBub2RlVHlwZSBkZWZhdWx0cyB0byA5LCBzaW5jZSBjb250ZXh0IGRlZmF1bHRzIHRvIGRvY3VtZW50XG5cdFx0bm9kZVR5cGUgPSBjb250ZXh0ID8gY29udGV4dC5ub2RlVHlwZSA6IDk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gUmV0dXJuIGVhcmx5IGZyb20gY2FsbHMgd2l0aCBpbnZhbGlkIHNlbGVjdG9yIG9yIGNvbnRleHRcblx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgfHwgIXNlbGVjdG9yIHx8XG5cdFx0bm9kZVR5cGUgIT09IDEgJiYgbm9kZVR5cGUgIT09IDkgJiYgbm9kZVR5cGUgIT09IDExICkge1xuXG5cdFx0cmV0dXJuIHJlc3VsdHM7XG5cdH1cblxuXHQvLyBUcnkgdG8gc2hvcnRjdXQgZmluZCBvcGVyYXRpb25zIChhcyBvcHBvc2VkIHRvIGZpbHRlcnMpIGluIEhUTUwgZG9jdW1lbnRzXG5cdGlmICggIXNlZWQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0XHRjb250ZXh0ID0gY29udGV4dCB8fCBkb2N1bWVudDtcblxuXHRcdGlmICggZG9jdW1lbnRJc0hUTUwgKSB7XG5cblx0XHRcdC8vIElmIHRoZSBzZWxlY3RvciBpcyBzdWZmaWNpZW50bHkgc2ltcGxlLCB0cnkgdXNpbmcgYSBcImdldCpCeSpcIiBET00gbWV0aG9kXG5cdFx0XHQvLyAoZXhjZXB0aW5nIERvY3VtZW50RnJhZ21lbnQgY29udGV4dCwgd2hlcmUgdGhlIG1ldGhvZHMgZG9uJ3QgZXhpc3QpXG5cdFx0XHRpZiAoIG5vZGVUeXBlICE9PSAxMSAmJiAoIG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApICkgKSB7XG5cblx0XHRcdFx0Ly8gSUQgc2VsZWN0b3Jcblx0XHRcdFx0aWYgKCAoIG0gPSBtYXRjaFsgMSBdICkgKSB7XG5cblx0XHRcdFx0XHQvLyBEb2N1bWVudCBjb250ZXh0XG5cdFx0XHRcdFx0aWYgKCBub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRcdGlmICggKCBlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcblx0XHRcdFx0XHRcdFx0Ly8gVE9ETzogaWRlbnRpZnkgdmVyc2lvbnNcblx0XHRcdFx0XHRcdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0XHRpZiAoIGVsZW0uaWQgPT09IG0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRWxlbWVudCBjb250ZXh0XG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcblx0XHRcdFx0XHRcdC8vIFRPRE86IGlkZW50aWZ5IHZlcnNpb25zXG5cdFx0XHRcdFx0XHQvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG5cdFx0XHRcdFx0XHRpZiAoIG5ld0NvbnRleHQgJiYgKCBlbGVtID0gbmV3Q29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApICkgJiZcblx0XHRcdFx0XHRcdFx0Y29udGFpbnMoIGNvbnRleHQsIGVsZW0gKSAmJlxuXHRcdFx0XHRcdFx0XHRlbGVtLmlkID09PSBtICkge1xuXG5cdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHlwZSBzZWxlY3RvclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFsgMiBdICkge1xuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHNlbGVjdG9yICkgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0XHQvLyBDbGFzcyBzZWxlY3RvclxuXHRcdFx0XHR9IGVsc2UgaWYgKCAoIG0gPSBtYXRjaFsgMyBdICkgJiYgc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmXG5cdFx0XHRcdFx0Y29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICkge1xuXG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBtICkgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUYWtlIGFkdmFudGFnZSBvZiBxdWVyeVNlbGVjdG9yQWxsXG5cdFx0XHRpZiAoIHN1cHBvcnQucXNhICYmXG5cdFx0XHRcdCFub25uYXRpdmVTZWxlY3RvckNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF0gJiZcblx0XHRcdFx0KCAhcmJ1Z2d5UVNBIHx8ICFyYnVnZ3lRU0EudGVzdCggc2VsZWN0b3IgKSApICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgOCBvbmx5XG5cdFx0XHRcdC8vIEV4Y2x1ZGUgb2JqZWN0IGVsZW1lbnRzXG5cdFx0XHRcdCggbm9kZVR5cGUgIT09IDEgfHwgY29udGV4dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcIm9iamVjdFwiICkgKSB7XG5cblx0XHRcdFx0bmV3U2VsZWN0b3IgPSBzZWxlY3Rvcjtcblx0XHRcdFx0bmV3Q29udGV4dCA9IGNvbnRleHQ7XG5cblx0XHRcdFx0Ly8gcVNBIGNvbnNpZGVycyBlbGVtZW50cyBvdXRzaWRlIGEgc2NvcGluZyByb290IHdoZW4gZXZhbHVhdGluZyBjaGlsZCBvclxuXHRcdFx0XHQvLyBkZXNjZW5kYW50IGNvbWJpbmF0b3JzLCB3aGljaCBpcyBub3Qgd2hhdCB3ZSB3YW50LlxuXHRcdFx0XHQvLyBJbiBzdWNoIGNhc2VzLCB3ZSB3b3JrIGFyb3VuZCB0aGUgYmVoYXZpb3IgYnkgcHJlZml4aW5nIGV2ZXJ5IHNlbGVjdG9yIGluIHRoZVxuXHRcdFx0XHQvLyBsaXN0IHdpdGggYW4gSUQgc2VsZWN0b3IgcmVmZXJlbmNpbmcgdGhlIHNjb3BlIGNvbnRleHQuXG5cdFx0XHRcdC8vIFRoZSB0ZWNobmlxdWUgaGFzIHRvIGJlIHVzZWQgYXMgd2VsbCB3aGVuIGEgbGVhZGluZyBjb21iaW5hdG9yIGlzIHVzZWRcblx0XHRcdFx0Ly8gYXMgc3VjaCBzZWxlY3RvcnMgYXJlIG5vdCByZWNvZ25pemVkIGJ5IHF1ZXJ5U2VsZWN0b3JBbGwuXG5cdFx0XHRcdC8vIFRoYW5rcyB0byBBbmRyZXcgRHVwb250IGZvciB0aGlzIHRlY2huaXF1ZS5cblx0XHRcdFx0aWYgKCBub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHRcdCggcmRlc2NlbmQudGVzdCggc2VsZWN0b3IgKSB8fCByY29tYmluYXRvcnMudGVzdCggc2VsZWN0b3IgKSApICkge1xuXG5cdFx0XHRcdFx0Ly8gRXhwYW5kIGNvbnRleHQgZm9yIHNpYmxpbmcgc2VsZWN0b3JzXG5cdFx0XHRcdFx0bmV3Q29udGV4dCA9IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8XG5cdFx0XHRcdFx0XHRjb250ZXh0O1xuXG5cdFx0XHRcdFx0Ly8gV2UgY2FuIHVzZSA6c2NvcGUgaW5zdGVhZCBvZiB0aGUgSUQgaGFjayBpZiB0aGUgYnJvd3NlclxuXHRcdFx0XHRcdC8vIHN1cHBvcnRzIGl0ICYgaWYgd2UncmUgbm90IGNoYW5naW5nIHRoZSBjb250ZXh0LlxuXHRcdFx0XHRcdGlmICggbmV3Q29udGV4dCAhPT0gY29udGV4dCB8fCAhc3VwcG9ydC5zY29wZSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gQ2FwdHVyZSB0aGUgY29udGV4dCBJRCwgc2V0dGluZyBpdCBmaXJzdCBpZiBuZWNlc3Nhcnlcblx0XHRcdFx0XHRcdGlmICggKCBuaWQgPSBjb250ZXh0LmdldEF0dHJpYnV0ZSggXCJpZFwiICkgKSApIHtcblx0XHRcdFx0XHRcdFx0bmlkID0gbmlkLnJlcGxhY2UoIHJjc3Nlc2NhcGUsIGZjc3Nlc2NhcGUgKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGNvbnRleHQuc2V0QXR0cmlidXRlKCBcImlkXCIsICggbmlkID0gZXhwYW5kbyApICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUHJlZml4IGV2ZXJ5IHNlbGVjdG9yIGluIHRoZSBsaXN0XG5cdFx0XHRcdFx0Z3JvdXBzID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG5cdFx0XHRcdFx0aSA9IGdyb3Vwcy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRncm91cHNbIGkgXSA9ICggbmlkID8gXCIjXCIgKyBuaWQgOiBcIjpzY29wZVwiICkgKyBcIiBcIiArXG5cdFx0XHRcdFx0XHRcdHRvU2VsZWN0b3IoIGdyb3Vwc1sgaSBdICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG5ld1NlbGVjdG9yID0gZ3JvdXBzLmpvaW4oIFwiLFwiICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsXG5cdFx0XHRcdFx0XHRuZXdDb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIG5ld1NlbGVjdG9yIClcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHR9IGNhdGNoICggcXNhRXJyb3IgKSB7XG5cdFx0XHRcdFx0bm9ubmF0aXZlU2VsZWN0b3JDYWNoZSggc2VsZWN0b3IsIHRydWUgKTtcblx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRpZiAoIG5pZCA9PT0gZXhwYW5kbyApIHtcblx0XHRcdFx0XHRcdGNvbnRleHQucmVtb3ZlQXR0cmlidXRlKCBcImlkXCIgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBBbGwgb3RoZXJzXG5cdHJldHVybiBzZWxlY3QoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApO1xufVxuXG4vKipcbiAqIENyZWF0ZSBrZXktdmFsdWUgY2FjaGVzIG9mIGxpbWl0ZWQgc2l6ZVxuICogQHJldHVybnMge2Z1bmN0aW9uKHN0cmluZywgb2JqZWN0KX0gUmV0dXJucyB0aGUgT2JqZWN0IGRhdGEgYWZ0ZXIgc3RvcmluZyBpdCBvbiBpdHNlbGYgd2l0aFxuICpcdHByb3BlcnR5IG5hbWUgdGhlIChzcGFjZS1zdWZmaXhlZCkgc3RyaW5nIGFuZCAoaWYgdGhlIGNhY2hlIGlzIGxhcmdlciB0aGFuIEV4cHIuY2FjaGVMZW5ndGgpXG4gKlx0ZGVsZXRpbmcgdGhlIG9sZGVzdCBlbnRyeVxuICovXG5mdW5jdGlvbiBjcmVhdGVDYWNoZSgpIHtcblx0dmFyIGtleXMgPSBbXTtcblxuXHRmdW5jdGlvbiBjYWNoZSgga2V5LCB2YWx1ZSApIHtcblxuXHRcdC8vIFVzZSAoa2V5ICsgXCIgXCIpIHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoIG5hdGl2ZSBwcm90b3R5cGUgcHJvcGVydGllcyAoc2VlIElzc3VlICMxNTcpXG5cdFx0aWYgKCBrZXlzLnB1c2goIGtleSArIFwiIFwiICkgPiBFeHByLmNhY2hlTGVuZ3RoICkge1xuXG5cdFx0XHQvLyBPbmx5IGtlZXAgdGhlIG1vc3QgcmVjZW50IGVudHJpZXNcblx0XHRcdGRlbGV0ZSBjYWNoZVsga2V5cy5zaGlmdCgpIF07XG5cdFx0fVxuXHRcdHJldHVybiAoIGNhY2hlWyBrZXkgKyBcIiBcIiBdID0gdmFsdWUgKTtcblx0fVxuXHRyZXR1cm4gY2FjaGU7XG59XG5cbi8qKlxuICogTWFyayBhIGZ1bmN0aW9uIGZvciBzcGVjaWFsIHVzZSBieSBTaXp6bGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBtYXJrXG4gKi9cbmZ1bmN0aW9uIG1hcmtGdW5jdGlvbiggZm4gKSB7XG5cdGZuWyBleHBhbmRvIF0gPSB0cnVlO1xuXHRyZXR1cm4gZm47XG59XG5cbi8qKlxuICogU3VwcG9ydCB0ZXN0aW5nIHVzaW5nIGFuIGVsZW1lbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFBhc3NlZCB0aGUgY3JlYXRlZCBlbGVtZW50IGFuZCByZXR1cm5zIGEgYm9vbGVhbiByZXN1bHRcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0KCBmbiApIHtcblx0dmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJmaWVsZHNldFwiICk7XG5cblx0dHJ5IHtcblx0XHRyZXR1cm4gISFmbiggZWwgKTtcblx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9IGZpbmFsbHkge1xuXG5cdFx0Ly8gUmVtb3ZlIGZyb20gaXRzIHBhcmVudCBieSBkZWZhdWx0XG5cdFx0aWYgKCBlbC5wYXJlbnROb2RlICkge1xuXHRcdFx0ZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggZWwgKTtcblx0XHR9XG5cblx0XHQvLyByZWxlYXNlIG1lbW9yeSBpbiBJRVxuXHRcdGVsID0gbnVsbDtcblx0fVxufVxuXG4vKipcbiAqIEFkZHMgdGhlIHNhbWUgaGFuZGxlciBmb3IgYWxsIG9mIHRoZSBzcGVjaWZpZWQgYXR0cnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBhdHRycyBQaXBlLXNlcGFyYXRlZCBsaXN0IG9mIGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgVGhlIG1ldGhvZCB0aGF0IHdpbGwgYmUgYXBwbGllZFxuICovXG5mdW5jdGlvbiBhZGRIYW5kbGUoIGF0dHJzLCBoYW5kbGVyICkge1xuXHR2YXIgYXJyID0gYXR0cnMuc3BsaXQoIFwifFwiICksXG5cdFx0aSA9IGFyci5sZW5ndGg7XG5cblx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0RXhwci5hdHRySGFuZGxlWyBhcnJbIGkgXSBdID0gaGFuZGxlcjtcblx0fVxufVxuXG4vKipcbiAqIENoZWNrcyBkb2N1bWVudCBvcmRlciBvZiB0d28gc2libGluZ3NcbiAqIEBwYXJhbSB7RWxlbWVudH0gYVxuICogQHBhcmFtIHtFbGVtZW50fSBiXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBSZXR1cm5zIGxlc3MgdGhhbiAwIGlmIGEgcHJlY2VkZXMgYiwgZ3JlYXRlciB0aGFuIDAgaWYgYSBmb2xsb3dzIGJcbiAqL1xuZnVuY3Rpb24gc2libGluZ0NoZWNrKCBhLCBiICkge1xuXHR2YXIgY3VyID0gYiAmJiBhLFxuXHRcdGRpZmYgPSBjdXIgJiYgYS5ub2RlVHlwZSA9PT0gMSAmJiBiLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRhLnNvdXJjZUluZGV4IC0gYi5zb3VyY2VJbmRleDtcblxuXHQvLyBVc2UgSUUgc291cmNlSW5kZXggaWYgYXZhaWxhYmxlIG9uIGJvdGggbm9kZXNcblx0aWYgKCBkaWZmICkge1xuXHRcdHJldHVybiBkaWZmO1xuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgYiBmb2xsb3dzIGFcblx0aWYgKCBjdXIgKSB7XG5cdFx0d2hpbGUgKCAoIGN1ciA9IGN1ci5uZXh0U2libGluZyApICkge1xuXHRcdFx0aWYgKCBjdXIgPT09IGIgKSB7XG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gYSA/IDEgOiAtMTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGlucHV0IHR5cGVzXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnB1dFBzZXVkbyggdHlwZSApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdHJldHVybiBuYW1lID09PSBcImlucHV0XCIgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgYnV0dG9uc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQnV0dG9uUHNldWRvKCB0eXBlICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0cmV0dXJuICggbmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCIgKSAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciA6ZW5hYmxlZC86ZGlzYWJsZWRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlzYWJsZWQgdHJ1ZSBmb3IgOmRpc2FibGVkOyBmYWxzZSBmb3IgOmVuYWJsZWRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIGRpc2FibGVkICkge1xuXG5cdC8vIEtub3duIDpkaXNhYmxlZCBmYWxzZSBwb3NpdGl2ZXM6IGZpZWxkc2V0W2Rpc2FibGVkXSA+IGxlZ2VuZDpudGgtb2YtdHlwZShuKzIpIDpjYW4tZGlzYWJsZVxuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBPbmx5IGNlcnRhaW4gZWxlbWVudHMgY2FuIG1hdGNoIDplbmFibGVkIG9yIDpkaXNhYmxlZFxuXHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NjcmlwdGluZy5odG1sI3NlbGVjdG9yLWVuYWJsZWRcblx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zY3JpcHRpbmcuaHRtbCNzZWxlY3Rvci1kaXNhYmxlZFxuXHRcdGlmICggXCJmb3JtXCIgaW4gZWxlbSApIHtcblxuXHRcdFx0Ly8gQ2hlY2sgZm9yIGluaGVyaXRlZCBkaXNhYmxlZG5lc3Mgb24gcmVsZXZhbnQgbm9uLWRpc2FibGVkIGVsZW1lbnRzOlxuXHRcdFx0Ly8gKiBsaXN0ZWQgZm9ybS1hc3NvY2lhdGVkIGVsZW1lbnRzIGluIGEgZGlzYWJsZWQgZmllbGRzZXRcblx0XHRcdC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjYXRlZ29yeS1saXN0ZWRcblx0XHRcdC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjb25jZXB0LWZlLWRpc2FibGVkXG5cdFx0XHQvLyAqIG9wdGlvbiBlbGVtZW50cyBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY29uY2VwdC1vcHRpb24tZGlzYWJsZWRcblx0XHRcdC8vIEFsbCBzdWNoIGVsZW1lbnRzIGhhdmUgYSBcImZvcm1cIiBwcm9wZXJ0eS5cblx0XHRcdGlmICggZWxlbS5wYXJlbnROb2RlICYmIGVsZW0uZGlzYWJsZWQgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdC8vIE9wdGlvbiBlbGVtZW50cyBkZWZlciB0byBhIHBhcmVudCBvcHRncm91cCBpZiBwcmVzZW50XG5cdFx0XHRcdGlmICggXCJsYWJlbFwiIGluIGVsZW0gKSB7XG5cdFx0XHRcdFx0aWYgKCBcImxhYmVsXCIgaW4gZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0ucGFyZW50Tm9kZS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA2IC0gMTFcblx0XHRcdFx0Ly8gVXNlIHRoZSBpc0Rpc2FibGVkIHNob3J0Y3V0IHByb3BlcnR5IHRvIGNoZWNrIGZvciBkaXNhYmxlZCBmaWVsZHNldCBhbmNlc3RvcnNcblx0XHRcdFx0cmV0dXJuIGVsZW0uaXNEaXNhYmxlZCA9PT0gZGlzYWJsZWQgfHxcblxuXHRcdFx0XHRcdC8vIFdoZXJlIHRoZXJlIGlzIG5vIGlzRGlzYWJsZWQsIGNoZWNrIG1hbnVhbGx5XG5cdFx0XHRcdFx0LyoganNoaW50IC1XMDE4ICovXG5cdFx0XHRcdFx0ZWxlbS5pc0Rpc2FibGVkICE9PSAhZGlzYWJsZWQgJiZcblx0XHRcdFx0XHRpbkRpc2FibGVkRmllbGRzZXQoIGVsZW0gKSA9PT0gZGlzYWJsZWQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblxuXHRcdC8vIFRyeSB0byB3aW5ub3cgb3V0IGVsZW1lbnRzIHRoYXQgY2FuJ3QgYmUgZGlzYWJsZWQgYmVmb3JlIHRydXN0aW5nIHRoZSBkaXNhYmxlZCBwcm9wZXJ0eS5cblx0XHQvLyBTb21lIHZpY3RpbXMgZ2V0IGNhdWdodCBpbiBvdXIgbmV0IChsYWJlbCwgbGVnZW5kLCBtZW51LCB0cmFjayksIGJ1dCBpdCBzaG91bGRuJ3Rcblx0XHQvLyBldmVuIGV4aXN0IG9uIHRoZW0sIGxldCBhbG9uZSBoYXZlIGEgYm9vbGVhbiB2YWx1ZS5cblx0XHR9IGVsc2UgaWYgKCBcImxhYmVsXCIgaW4gZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblx0XHR9XG5cblx0XHQvLyBSZW1haW5pbmcgZWxlbWVudHMgYXJlIG5laXRoZXIgOmVuYWJsZWQgbm9yIDpkaXNhYmxlZFxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIHBvc2l0aW9uYWxzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5mdW5jdGlvbiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmbiApIHtcblx0cmV0dXJuIG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIGFyZ3VtZW50ICkge1xuXHRcdGFyZ3VtZW50ID0gK2FyZ3VtZW50O1xuXHRcdHJldHVybiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xuXHRcdFx0dmFyIGosXG5cdFx0XHRcdG1hdGNoSW5kZXhlcyA9IGZuKCBbXSwgc2VlZC5sZW5ndGgsIGFyZ3VtZW50ICksXG5cdFx0XHRcdGkgPSBtYXRjaEluZGV4ZXMubGVuZ3RoO1xuXG5cdFx0XHQvLyBNYXRjaCBlbGVtZW50cyBmb3VuZCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4ZXNcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoIHNlZWRbICggaiA9IG1hdGNoSW5kZXhlc1sgaSBdICkgXSApIHtcblx0XHRcdFx0XHRzZWVkWyBqIF0gPSAhKCBtYXRjaGVzWyBqIF0gPSBzZWVkWyBqIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSApO1xufVxuXG4vKipcbiAqIENoZWNrcyBhIG5vZGUgZm9yIHZhbGlkaXR5IGFzIGEgU2l6emxlIGNvbnRleHRcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3Q9fSBjb250ZXh0XG4gKiBAcmV0dXJucyB7RWxlbWVudHxPYmplY3R8Qm9vbGVhbn0gVGhlIGlucHV0IG5vZGUgaWYgYWNjZXB0YWJsZSwgb3RoZXJ3aXNlIGEgZmFsc3kgdmFsdWVcbiAqL1xuZnVuY3Rpb24gdGVzdENvbnRleHQoIGNvbnRleHQgKSB7XG5cdHJldHVybiBjb250ZXh0ICYmIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGNvbnRleHQ7XG59XG5cbi8vIEV4cG9zZSBzdXBwb3J0IHZhcnMgZm9yIGNvbnZlbmllbmNlXG5zdXBwb3J0ID0gU2l6emxlLnN1cHBvcnQgPSB7fTtcblxuLyoqXG4gKiBEZXRlY3RzIFhNTCBub2Rlc1xuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gZWxlbSBBbiBlbGVtZW50IG9yIGEgZG9jdW1lbnRcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmZiBlbGVtIGlzIGEgbm9uLUhUTUwgWE1MIG5vZGVcbiAqL1xuaXNYTUwgPSBTaXp6bGUuaXNYTUwgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0dmFyIG5hbWVzcGFjZSA9IGVsZW0ubmFtZXNwYWNlVVJJLFxuXHRcdGRvY0VsZW0gPSAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkuZG9jdW1lbnRFbGVtZW50O1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OFxuXHQvLyBBc3N1bWUgSFRNTCB3aGVuIGRvY3VtZW50RWxlbWVudCBkb2Vzbid0IHlldCBleGlzdCwgc3VjaCBhcyBpbnNpZGUgbG9hZGluZyBpZnJhbWVzXG5cdC8vIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC80ODMzXG5cdHJldHVybiAhcmh0bWwudGVzdCggbmFtZXNwYWNlIHx8IGRvY0VsZW0gJiYgZG9jRWxlbS5ub2RlTmFtZSB8fCBcIkhUTUxcIiApO1xufTtcblxuLyoqXG4gKiBTZXRzIGRvY3VtZW50LXJlbGF0ZWQgdmFyaWFibGVzIG9uY2UgYmFzZWQgb24gdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IFtkb2NdIEFuIGVsZW1lbnQgb3IgZG9jdW1lbnQgb2JqZWN0IHRvIHVzZSB0byBzZXQgdGhlIGRvY3VtZW50XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKi9cbnNldERvY3VtZW50ID0gU2l6emxlLnNldERvY3VtZW50ID0gZnVuY3Rpb24oIG5vZGUgKSB7XG5cdHZhciBoYXNDb21wYXJlLCBzdWJXaW5kb3csXG5cdFx0ZG9jID0gbm9kZSA/IG5vZGUub3duZXJEb2N1bWVudCB8fCBub2RlIDogcHJlZmVycmVkRG9jO1xuXG5cdC8vIFJldHVybiBlYXJseSBpZiBkb2MgaXMgaW52YWxpZCBvciBhbHJlYWR5IHNlbGVjdGVkXG5cdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdGlmICggZG9jID09IGRvY3VtZW50IHx8IGRvYy5ub2RlVHlwZSAhPT0gOSB8fCAhZG9jLmRvY3VtZW50RWxlbWVudCApIHtcblx0XHRyZXR1cm4gZG9jdW1lbnQ7XG5cdH1cblxuXHQvLyBVcGRhdGUgZ2xvYmFsIHZhcmlhYmxlc1xuXHRkb2N1bWVudCA9IGRvYztcblx0ZG9jRWxlbSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblx0ZG9jdW1lbnRJc0hUTUwgPSAhaXNYTUwoIGRvY3VtZW50ICk7XG5cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExKywgRWRnZSAxMiAtIDE4K1xuXHQvLyBBY2Nlc3NpbmcgaWZyYW1lIGRvY3VtZW50cyBhZnRlciB1bmxvYWQgdGhyb3dzIFwicGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvcnMgKGpRdWVyeSAjMTM5MzYpXG5cdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdGlmICggcHJlZmVycmVkRG9jICE9IGRvY3VtZW50ICYmXG5cdFx0KCBzdWJXaW5kb3cgPSBkb2N1bWVudC5kZWZhdWx0VmlldyApICYmIHN1YldpbmRvdy50b3AgIT09IHN1YldpbmRvdyApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDExLCBFZGdlXG5cdFx0aWYgKCBzdWJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdHN1YldpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcInVubG9hZFwiLCB1bmxvYWRIYW5kbGVyLCBmYWxzZSApO1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDEwIG9ubHlcblx0XHR9IGVsc2UgaWYgKCBzdWJXaW5kb3cuYXR0YWNoRXZlbnQgKSB7XG5cdFx0XHRzdWJXaW5kb3cuYXR0YWNoRXZlbnQoIFwib251bmxvYWRcIiwgdW5sb2FkSGFuZGxlciApO1xuXHRcdH1cblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFIDggLSAxMSssIEVkZ2UgMTIgLSAxOCssIENocm9tZSA8PTE2IC0gMjUgb25seSwgRmlyZWZveCA8PTMuNiAtIDMxIG9ubHksXG5cdC8vIFNhZmFyaSA0IC0gNSBvbmx5LCBPcGVyYSA8PTExLjYgLSAxMi54IG9ubHlcblx0Ly8gSUUvRWRnZSAmIG9sZGVyIGJyb3dzZXJzIGRvbid0IHN1cHBvcnQgdGhlIDpzY29wZSBwc2V1ZG8tY2xhc3MuXG5cdC8vIFN1cHBvcnQ6IFNhZmFyaSA2LjAgb25seVxuXHQvLyBTYWZhcmkgNi4wIHN1cHBvcnRzIDpzY29wZSBidXQgaXQncyBhbiBhbGlhcyBvZiA6cm9vdCB0aGVyZS5cblx0c3VwcG9ydC5zY29wZSA9IGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApO1xuXHRcdHJldHVybiB0eXBlb2YgZWwucXVlcnlTZWxlY3RvckFsbCAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuXHRcdFx0IWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiOnNjb3BlIGZpZWxkc2V0IGRpdlwiICkubGVuZ3RoO1xuXHR9ICk7XG5cblx0LyogQXR0cmlidXRlc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gU3VwcG9ydDogSUU8OFxuXHQvLyBWZXJpZnkgdGhhdCBnZXRBdHRyaWJ1dGUgcmVhbGx5IHJldHVybnMgYXR0cmlidXRlcyBhbmQgbm90IHByb3BlcnRpZXNcblx0Ly8gKGV4Y2VwdGluZyBJRTggYm9vbGVhbnMpXG5cdHN1cHBvcnQuYXR0cmlidXRlcyA9IGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXHRcdGVsLmNsYXNzTmFtZSA9IFwiaVwiO1xuXHRcdHJldHVybiAhZWwuZ2V0QXR0cmlidXRlKCBcImNsYXNzTmFtZVwiICk7XG5cdH0gKTtcblxuXHQvKiBnZXRFbGVtZW50KHMpQnkqXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikgcmV0dXJucyBvbmx5IGVsZW1lbnRzXG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPSBhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblx0XHRlbC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlQ29tbWVudCggXCJcIiApICk7XG5cdFx0cmV0dXJuICFlbC5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCIqXCIgKS5sZW5ndGg7XG5cdH0gKTtcblxuXHQvLyBTdXBwb3J0OiBJRTw5XG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSA9IHJuYXRpdmUudGVzdCggZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApO1xuXG5cdC8vIFN1cHBvcnQ6IElFPDEwXG5cdC8vIENoZWNrIGlmIGdldEVsZW1lbnRCeUlkIHJldHVybnMgZWxlbWVudHMgYnkgbmFtZVxuXHQvLyBUaGUgYnJva2VuIGdldEVsZW1lbnRCeUlkIG1ldGhvZHMgZG9uJ3QgcGljayB1cCBwcm9ncmFtbWF0aWNhbGx5LXNldCBuYW1lcyxcblx0Ly8gc28gdXNlIGEgcm91bmRhYm91dCBnZXRFbGVtZW50c0J5TmFtZSB0ZXN0XG5cdHN1cHBvcnQuZ2V0QnlJZCA9IGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuaWQgPSBleHBhbmRvO1xuXHRcdHJldHVybiAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUgfHwgIWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKCBleHBhbmRvICkubGVuZ3RoO1xuXHR9ICk7XG5cblx0Ly8gSUQgZmlsdGVyIGFuZCBmaW5kXG5cdGlmICggc3VwcG9ydC5nZXRCeUlkICkge1xuXHRcdEV4cHIuZmlsdGVyWyBcIklEXCIgXSA9IGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIFwiaWRcIiApID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0RXhwci5maW5kWyBcIklEXCIgXSA9IGZ1bmN0aW9uKCBpZCwgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRcdHZhciBlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggaWQgKTtcblx0XHRcdFx0cmV0dXJuIGVsZW0gPyBbIGVsZW0gXSA6IFtdO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0RXhwci5maWx0ZXJbIFwiSURcIiBdID0gIGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZU5vZGUgIT09IFwidW5kZWZpbmVkXCIgJiZcblx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIFwiaWRcIiApO1xuXHRcdFx0XHRyZXR1cm4gbm9kZSAmJiBub2RlLnZhbHVlID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA2IC0gNyBvbmx5XG5cdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgaXMgbm90IHJlbGlhYmxlIGFzIGEgZmluZCBzaG9ydGN1dFxuXHRcdEV4cHIuZmluZFsgXCJJRFwiIF0gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0XHR2YXIgbm9kZSwgaSwgZWxlbXMsXG5cdFx0XHRcdFx0ZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG5cblx0XHRcdFx0aWYgKCBlbGVtICkge1xuXG5cdFx0XHRcdFx0Ly8gVmVyaWZ5IHRoZSBpZCBhdHRyaWJ1dGVcblx0XHRcdFx0XHRub2RlID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBcImlkXCIgKTtcblx0XHRcdFx0XHRpZiAoIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gaWQgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gWyBlbGVtIF07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRmFsbCBiYWNrIG9uIGdldEVsZW1lbnRzQnlOYW1lXG5cdFx0XHRcdFx0ZWxlbXMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlOYW1lKCBpZCApO1xuXHRcdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKCBlbGVtID0gZWxlbXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdFx0XHRub2RlID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBcImlkXCIgKTtcblx0XHRcdFx0XHRcdGlmICggbm9kZSAmJiBub2RlLnZhbHVlID09PSBpZCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIFsgZWxlbSBdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cblx0Ly8gVGFnXG5cdEV4cHIuZmluZFsgXCJUQUdcIiBdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA/XG5cdFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0Ly8gRG9jdW1lbnRGcmFnbWVudCBub2RlcyBkb24ndCBoYXZlIGdFQlROXG5cdFx0XHR9IGVsc2UgaWYgKCBzdXBwb3J0LnFzYSApIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnICk7XG5cdFx0XHR9XG5cdFx0fSA6XG5cblx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdHRtcCA9IFtdLFxuXHRcdFx0XHRpID0gMCxcblxuXHRcdFx0XHQvLyBCeSBoYXBweSBjb2luY2lkZW5jZSwgYSAoYnJva2VuKSBnRUJUTiBhcHBlYXJzIG9uIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgdG9vXG5cdFx0XHRcdHJlc3VsdHMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0Ly8gRmlsdGVyIG91dCBwb3NzaWJsZSBjb21tZW50c1xuXHRcdFx0aWYgKCB0YWcgPT09IFwiKlwiICkge1xuXHRcdFx0XHR3aGlsZSAoICggZWxlbSA9IHJlc3VsdHNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0dG1wLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdG1wO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0fTtcblxuXHQvLyBDbGFzc1xuXHRFeHByLmZpbmRbIFwiQ0xBU1NcIiBdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmIGZ1bmN0aW9uKCBjbGFzc05hbWUsIGNvbnRleHQgKSB7XG5cdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggY2xhc3NOYW1lICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIFFTQS9tYXRjaGVzU2VsZWN0b3Jcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIFFTQSBhbmQgbWF0Y2hlc1NlbGVjdG9yIHN1cHBvcnRcblxuXHQvLyBtYXRjaGVzU2VsZWN0b3IoOmFjdGl2ZSkgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKElFOS9PcGVyYSAxMS41KVxuXHRyYnVnZ3lNYXRjaGVzID0gW107XG5cblx0Ly8gcVNhKDpmb2N1cykgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKENocm9tZSAyMSlcblx0Ly8gV2UgYWxsb3cgdGhpcyBiZWNhdXNlIG9mIGEgYnVnIGluIElFOC85IHRoYXQgdGhyb3dzIGFuIGVycm9yXG5cdC8vIHdoZW5ldmVyIGBkb2N1bWVudC5hY3RpdmVFbGVtZW50YCBpcyBhY2Nlc3NlZCBvbiBhbiBpZnJhbWVcblx0Ly8gU28sIHdlIGFsbG93IDpmb2N1cyB0byBwYXNzIHRocm91Z2ggUVNBIGFsbCB0aGUgdGltZSB0byBhdm9pZCB0aGUgSUUgZXJyb3Jcblx0Ly8gU2VlIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMzM3OFxuXHRyYnVnZ3lRU0EgPSBbXTtcblxuXHRpZiAoICggc3VwcG9ydC5xc2EgPSBybmF0aXZlLnRlc3QoIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwgKSApICkge1xuXG5cdFx0Ly8gQnVpbGQgUVNBIHJlZ2V4XG5cdFx0Ly8gUmVnZXggc3RyYXRlZ3kgYWRvcHRlZCBmcm9tIERpZWdvIFBlcmluaVxuXHRcdGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXG5cdFx0XHR2YXIgaW5wdXQ7XG5cblx0XHRcdC8vIFNlbGVjdCBpcyBzZXQgdG8gZW1wdHkgc3RyaW5nIG9uIHB1cnBvc2Vcblx0XHRcdC8vIFRoaXMgaXMgdG8gdGVzdCBJRSdzIHRyZWF0bWVudCBvZiBub3QgZXhwbGljaXRseVxuXHRcdFx0Ly8gc2V0dGluZyBhIGJvb2xlYW4gY29udGVudCBhdHRyaWJ1dGUsXG5cdFx0XHQvLyBzaW5jZSBpdHMgcHJlc2VuY2Ugc2hvdWxkIGJlIGVub3VnaFxuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEyMzU5XG5cdFx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmlubmVySFRNTCA9IFwiPGEgaWQ9J1wiICsgZXhwYW5kbyArIFwiJz48L2E+XCIgK1xuXHRcdFx0XHRcIjxzZWxlY3QgaWQ9J1wiICsgZXhwYW5kbyArIFwiLVxcclxcXFwnIG1zYWxsb3djYXB0dXJlPScnPlwiICtcblx0XHRcdFx0XCI8b3B0aW9uIHNlbGVjdGVkPScnPjwvb3B0aW9uPjwvc2VsZWN0PlwiO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTgsIE9wZXJhIDExLTEyLjE2XG5cdFx0XHQvLyBOb3RoaW5nIHNob3VsZCBiZSBzZWxlY3RlZCB3aGVuIGVtcHR5IHN0cmluZ3MgZm9sbG93IF49IG9yICQ9IG9yICo9XG5cdFx0XHQvLyBUaGUgdGVzdCBhdHRyaWJ1dGUgbXVzdCBiZSB1bmtub3duIGluIE9wZXJhIGJ1dCBcInNhZmVcIiBmb3IgV2luUlRcblx0XHRcdC8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvaGg0NjUzODguYXNweCNhdHRyaWJ1dGVfc2VjdGlvblxuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIlttc2FsbG93Y2FwdHVyZV49JyddXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlsqXiRdPVwiICsgd2hpdGVzcGFjZSArIFwiKig/OicnfFxcXCJcXFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOFxuXHRcdFx0Ly8gQm9vbGVhbiBhdHRyaWJ1dGVzIGFuZCBcInZhbHVlXCIgYXJlIG5vdCB0cmVhdGVkIGNvcnJlY3RseVxuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJbc2VsZWN0ZWRdXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86dmFsdWV8XCIgKyBib29sZWFucyArIFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZTwyOSwgQW5kcm9pZDw0LjQsIFNhZmFyaTw3LjArLCBpT1M8Ny4wKywgUGhhbnRvbUpTPDEuOS44K1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJbaWR+PVwiICsgZXhwYW5kbyArIFwiLV1cIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwifj1cIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTUgLSAxOCtcblx0XHRcdC8vIElFIDExL0VkZ2UgZG9uJ3QgZmluZCBlbGVtZW50cyBvbiBhIGBbbmFtZT0nJ11gIHF1ZXJ5IGluIHNvbWUgY2FzZXMuXG5cdFx0XHQvLyBBZGRpbmcgYSB0ZW1wb3JhcnkgYXR0cmlidXRlIHRvIHRoZSBkb2N1bWVudCBiZWZvcmUgdGhlIHNlbGVjdGlvbiB3b3Jrc1xuXHRcdFx0Ly8gYXJvdW5kIHRoZSBpc3N1ZS5cblx0XHRcdC8vIEludGVyZXN0aW5nbHksIElFIDEwICYgb2xkZXIgZG9uJ3Qgc2VlbSB0byBoYXZlIHRoZSBpc3N1ZS5cblx0XHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cdFx0XHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcIlwiICk7XG5cdFx0XHRlbC5hcHBlbmRDaGlsZCggaW5wdXQgKTtcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiW25hbWU9JyddXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqbmFtZVwiICsgd2hpdGVzcGFjZSArIFwiKj1cIiArXG5cdFx0XHRcdFx0d2hpdGVzcGFjZSArIFwiKig/OicnfFxcXCJcXFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFdlYmtpdC9PcGVyYSAtIDpjaGVja2VkIHNob3VsZCByZXR1cm4gc2VsZWN0ZWQgb3B0aW9uIGVsZW1lbnRzXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuXHRcdFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiOmNoZWNrZWRcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmNoZWNrZWRcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgOCssIGlPUyA4K1xuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzNjg1MVxuXHRcdFx0Ly8gSW4tcGFnZSBgc2VsZWN0b3IjaWQgc2libGluZy1jb21iaW5hdG9yIHNlbGVjdG9yYCBmYWlsc1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJhI1wiICsgZXhwYW5kbyArIFwiKypcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiLiMuK1srfl1cIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9My42IC0gNSBvbmx5XG5cdFx0XHQvLyBPbGQgRmlyZWZveCBkb2Vzbid0IHRocm93IG9uIGEgYmFkbHktZXNjYXBlZCBpZGVudGlmaWVyLlxuXHRcdFx0ZWwucXVlcnlTZWxlY3RvckFsbCggXCJcXFxcXFxmXCIgKTtcblx0XHRcdHJidWdneVFTQS5wdXNoKCBcIltcXFxcclxcXFxuXFxcXGZdXCIgKTtcblx0XHR9ICk7XG5cblx0XHRhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblx0XHRcdGVsLmlubmVySFRNTCA9IFwiPGEgaHJlZj0nJyBkaXNhYmxlZD0nZGlzYWJsZWQnPjwvYT5cIiArXG5cdFx0XHRcdFwiPHNlbGVjdCBkaXNhYmxlZD0nZGlzYWJsZWQnPjxvcHRpb24vPjwvc2VsZWN0PlwiO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBXaW5kb3dzIDggTmF0aXZlIEFwcHNcblx0XHRcdC8vIFRoZSB0eXBlIGFuZCBuYW1lIGF0dHJpYnV0ZXMgYXJlIHJlc3RyaWN0ZWQgZHVyaW5nIC5pbm5lckhUTUwgYXNzaWdubWVudFxuXHRcdFx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cdFx0XHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcImhpZGRlblwiICk7XG5cdFx0XHRlbC5hcHBlbmRDaGlsZCggaW5wdXQgKS5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcIkRcIiApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRThcblx0XHRcdC8vIEVuZm9yY2UgY2FzZS1zZW5zaXRpdml0eSBvZiBuYW1lIGF0dHJpYnV0ZVxuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIltuYW1lPWRdXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIm5hbWVcIiArIHdoaXRlc3BhY2UgKyBcIipbKl4kfCF+XT89XCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRkYgMy41IC0gOmVuYWJsZWQvOmRpc2FibGVkIGFuZCBoaWRkZW4gZWxlbWVudHMgKGhpZGRlbiBlbGVtZW50cyBhcmUgc3RpbGwgZW5hYmxlZClcblx0XHRcdC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiOmVuYWJsZWRcIiApLmxlbmd0aCAhPT0gMiApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTktMTErXG5cdFx0XHQvLyBJRSdzIDpkaXNhYmxlZCBzZWxlY3RvciBkb2VzIG5vdCBwaWNrIHVwIHRoZSBjaGlsZHJlbiBvZiBkaXNhYmxlZCBmaWVsZHNldHNcblx0XHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuZGlzYWJsZWQgPSB0cnVlO1xuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIjpkaXNhYmxlZFwiICkubGVuZ3RoICE9PSAyICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IE9wZXJhIDEwIC0gMTEgb25seVxuXHRcdFx0Ly8gT3BlcmEgMTAtMTEgZG9lcyBub3QgdGhyb3cgb24gcG9zdC1jb21tYSBpbnZhbGlkIHBzZXVkb3Ncblx0XHRcdGVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiKiw6eFwiICk7XG5cdFx0XHRyYnVnZ3lRU0EucHVzaCggXCIsLio6XCIgKTtcblx0XHR9ICk7XG5cdH1cblxuXHRpZiAoICggc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgPSBybmF0aXZlLnRlc3QoICggbWF0Y2hlcyA9IGRvY0VsZW0ubWF0Y2hlcyB8fFxuXHRcdGRvY0VsZW0ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5tb3pNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm9NYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm1zTWF0Y2hlc1NlbGVjdG9yICkgKSApICkge1xuXG5cdFx0YXNzZXJ0KCBmdW5jdGlvbiggZWwgKSB7XG5cblx0XHRcdC8vIENoZWNrIHRvIHNlZSBpZiBpdCdzIHBvc3NpYmxlIHRvIGRvIG1hdGNoZXNTZWxlY3RvclxuXHRcdFx0Ly8gb24gYSBkaXNjb25uZWN0ZWQgbm9kZSAoSUUgOSlcblx0XHRcdHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggPSBtYXRjaGVzLmNhbGwoIGVsLCBcIipcIiApO1xuXG5cdFx0XHQvLyBUaGlzIHNob3VsZCBmYWlsIHdpdGggYW4gZXhjZXB0aW9uXG5cdFx0XHQvLyBHZWNrbyBkb2VzIG5vdCBlcnJvciwgcmV0dXJucyBmYWxzZSBpbnN0ZWFkXG5cdFx0XHRtYXRjaGVzLmNhbGwoIGVsLCBcIltzIT0nJ106eFwiICk7XG5cdFx0XHRyYnVnZ3lNYXRjaGVzLnB1c2goIFwiIT1cIiwgcHNldWRvcyApO1xuXHRcdH0gKTtcblx0fVxuXG5cdHJidWdneVFTQSA9IHJidWdneVFTQS5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5UVNBLmpvaW4oIFwifFwiICkgKTtcblx0cmJ1Z2d5TWF0Y2hlcyA9IHJidWdneU1hdGNoZXMubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneU1hdGNoZXMuam9pbiggXCJ8XCIgKSApO1xuXG5cdC8qIENvbnRhaW5zXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblx0aGFzQ29tcGFyZSA9IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiApO1xuXG5cdC8vIEVsZW1lbnQgY29udGFpbnMgYW5vdGhlclxuXHQvLyBQdXJwb3NlZnVsbHkgc2VsZi1leGNsdXNpdmVcblx0Ly8gQXMgaW4sIGFuIGVsZW1lbnQgZG9lcyBub3QgY29udGFpbiBpdHNlbGZcblx0Y29udGFpbnMgPSBoYXNDb21wYXJlIHx8IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb250YWlucyApID9cblx0XHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdHZhciBhZG93biA9IGEubm9kZVR5cGUgPT09IDkgPyBhLmRvY3VtZW50RWxlbWVudCA6IGEsXG5cdFx0XHRcdGJ1cCA9IGIgJiYgYi5wYXJlbnROb2RlO1xuXHRcdFx0cmV0dXJuIGEgPT09IGJ1cCB8fCAhISggYnVwICYmIGJ1cC5ub2RlVHlwZSA9PT0gMSAmJiAoXG5cdFx0XHRcdGFkb3duLmNvbnRhaW5zID9cblx0XHRcdFx0XHRhZG93bi5jb250YWlucyggYnVwICkgOlxuXHRcdFx0XHRcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gJiYgYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYnVwICkgJiAxNlxuXHRcdFx0KSApO1xuXHRcdH0gOlxuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0aWYgKCBiICkge1xuXHRcdFx0XHR3aGlsZSAoICggYiA9IGIucGFyZW50Tm9kZSApICkge1xuXHRcdFx0XHRcdGlmICggYiA9PT0gYSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cblx0LyogU29ydGluZ1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gRG9jdW1lbnQgb3JkZXIgc29ydGluZ1xuXHRzb3J0T3JkZXIgPSBoYXNDb21wYXJlID9cblx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cblx0XHQvLyBGbGFnIGZvciBkdXBsaWNhdGUgcmVtb3ZhbFxuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHQvLyBTb3J0IG9uIG1ldGhvZCBleGlzdGVuY2UgaWYgb25seSBvbmUgaW5wdXQgaGFzIGNvbXBhcmVEb2N1bWVudFBvc2l0aW9uXG5cdFx0dmFyIGNvbXBhcmUgPSAhYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAtICFiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uO1xuXHRcdGlmICggY29tcGFyZSApIHtcblx0XHRcdHJldHVybiBjb21wYXJlO1xuXHRcdH1cblxuXHRcdC8vIENhbGN1bGF0ZSBwb3NpdGlvbiBpZiBib3RoIGlucHV0cyBiZWxvbmcgdG8gdGhlIHNhbWUgZG9jdW1lbnRcblx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0XHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0XHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRcdGNvbXBhcmUgPSAoIGEub3duZXJEb2N1bWVudCB8fCBhICkgPT0gKCBiLm93bmVyRG9jdW1lbnQgfHwgYiApID9cblx0XHRcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGIgKSA6XG5cblx0XHRcdC8vIE90aGVyd2lzZSB3ZSBrbm93IHRoZXkgYXJlIGRpc2Nvbm5lY3RlZFxuXHRcdFx0MTtcblxuXHRcdC8vIERpc2Nvbm5lY3RlZCBub2Rlc1xuXHRcdGlmICggY29tcGFyZSAmIDEgfHxcblx0XHRcdCggIXN1cHBvcnQuc29ydERldGFjaGVkICYmIGIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGEgKSA9PT0gY29tcGFyZSApICkge1xuXG5cdFx0XHQvLyBDaG9vc2UgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBpcyByZWxhdGVkIHRvIG91ciBwcmVmZXJyZWQgZG9jdW1lbnRcblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHRcdFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdFx0XHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdFx0XHRpZiAoIGEgPT0gZG9jdW1lbnQgfHwgYS5vd25lckRvY3VtZW50ID09IHByZWZlcnJlZERvYyAmJlxuXHRcdFx0XHRjb250YWlucyggcHJlZmVycmVkRG9jLCBhICkgKSB7XG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdFx0XHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0XHRcdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0XHRcdGlmICggYiA9PSBkb2N1bWVudCB8fCBiLm93bmVyRG9jdW1lbnQgPT0gcHJlZmVycmVkRG9jICYmXG5cdFx0XHRcdGNvbnRhaW5zKCBwcmVmZXJyZWREb2MsIGIgKSApIHtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1haW50YWluIG9yaWdpbmFsIG9yZGVyXG5cdFx0XHRyZXR1cm4gc29ydElucHV0ID9cblx0XHRcdFx0KCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXHRcdH1cblxuXHRcdHJldHVybiBjb21wYXJlICYgNCA/IC0xIDogMTtcblx0fSA6XG5cdGZ1bmN0aW9uKCBhLCBiICkge1xuXG5cdFx0Ly8gRXhpdCBlYXJseSBpZiB0aGUgbm9kZXMgYXJlIGlkZW50aWNhbFxuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHR2YXIgY3VyLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRhdXAgPSBhLnBhcmVudE5vZGUsXG5cdFx0XHRidXAgPSBiLnBhcmVudE5vZGUsXG5cdFx0XHRhcCA9IFsgYSBdLFxuXHRcdFx0YnAgPSBbIGIgXTtcblxuXHRcdC8vIFBhcmVudGxlc3Mgbm9kZXMgYXJlIGVpdGhlciBkb2N1bWVudHMgb3IgZGlzY29ubmVjdGVkXG5cdFx0aWYgKCAhYXVwIHx8ICFidXAgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHRcdFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdFx0XHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBlcWVxZXEgKi9cblx0XHRcdHJldHVybiBhID09IGRvY3VtZW50ID8gLTEgOlxuXHRcdFx0XHRiID09IGRvY3VtZW50ID8gMSA6XG5cdFx0XHRcdC8qIGVzbGludC1lbmFibGUgZXFlcWVxICovXG5cdFx0XHRcdGF1cCA/IC0xIDpcblx0XHRcdFx0YnVwID8gMSA6XG5cdFx0XHRcdHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0MDtcblxuXHRcdC8vIElmIHRoZSBub2RlcyBhcmUgc2libGluZ3MsIHdlIGNhbiBkbyBhIHF1aWNrIGNoZWNrXG5cdFx0fSBlbHNlIGlmICggYXVwID09PSBidXAgKSB7XG5cdFx0XHRyZXR1cm4gc2libGluZ0NoZWNrKCBhLCBiICk7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXJ3aXNlIHdlIG5lZWQgZnVsbCBsaXN0cyBvZiB0aGVpciBhbmNlc3RvcnMgZm9yIGNvbXBhcmlzb25cblx0XHRjdXIgPSBhO1xuXHRcdHdoaWxlICggKCBjdXIgPSBjdXIucGFyZW50Tm9kZSApICkge1xuXHRcdFx0YXAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXHRcdGN1ciA9IGI7XG5cdFx0d2hpbGUgKCAoIGN1ciA9IGN1ci5wYXJlbnROb2RlICkgKSB7XG5cdFx0XHRicC51bnNoaWZ0KCBjdXIgKTtcblx0XHR9XG5cblx0XHQvLyBXYWxrIGRvd24gdGhlIHRyZWUgbG9va2luZyBmb3IgYSBkaXNjcmVwYW5jeVxuXHRcdHdoaWxlICggYXBbIGkgXSA9PT0gYnBbIGkgXSApIHtcblx0XHRcdGkrKztcblx0XHR9XG5cblx0XHRyZXR1cm4gaSA/XG5cblx0XHRcdC8vIERvIGEgc2libGluZyBjaGVjayBpZiB0aGUgbm9kZXMgaGF2ZSBhIGNvbW1vbiBhbmNlc3RvclxuXHRcdFx0c2libGluZ0NoZWNrKCBhcFsgaSBdLCBicFsgaSBdICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugbm9kZXMgaW4gb3VyIGRvY3VtZW50IHNvcnQgZmlyc3Rcblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHRcdFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdFx0XHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBlcWVxZXEgKi9cblx0XHRcdGFwWyBpIF0gPT0gcHJlZmVycmVkRG9jID8gLTEgOlxuXHRcdFx0YnBbIGkgXSA9PSBwcmVmZXJyZWREb2MgPyAxIDpcblx0XHRcdC8qIGVzbGludC1lbmFibGUgZXFlcWVxICovXG5cdFx0XHQwO1xuXHR9O1xuXG5cdHJldHVybiBkb2N1bWVudDtcbn07XG5cblNpenpsZS5tYXRjaGVzID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1lbnRzICkge1xuXHRyZXR1cm4gU2l6emxlKCBleHByLCBudWxsLCBudWxsLCBlbGVtZW50cyApO1xufTtcblxuU2l6emxlLm1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uKCBlbGVtLCBleHByICkge1xuXHRzZXREb2N1bWVudCggZWxlbSApO1xuXG5cdGlmICggc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgJiYgZG9jdW1lbnRJc0hUTUwgJiZcblx0XHQhbm9ubmF0aXZlU2VsZWN0b3JDYWNoZVsgZXhwciArIFwiIFwiIF0gJiZcblx0XHQoICFyYnVnZ3lNYXRjaGVzIHx8ICFyYnVnZ3lNYXRjaGVzLnRlc3QoIGV4cHIgKSApICYmXG5cdFx0KCAhcmJ1Z2d5UVNBICAgICB8fCAhcmJ1Z2d5UVNBLnRlc3QoIGV4cHIgKSApICkge1xuXG5cdFx0dHJ5IHtcblx0XHRcdHZhciByZXQgPSBtYXRjaGVzLmNhbGwoIGVsZW0sIGV4cHIgKTtcblxuXHRcdFx0Ly8gSUUgOSdzIG1hdGNoZXNTZWxlY3RvciByZXR1cm5zIGZhbHNlIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuXHRcdFx0aWYgKCByZXQgfHwgc3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCB8fFxuXG5cdFx0XHRcdC8vIEFzIHdlbGwsIGRpc2Nvbm5lY3RlZCBub2RlcyBhcmUgc2FpZCB0byBiZSBpbiBhIGRvY3VtZW50XG5cdFx0XHRcdC8vIGZyYWdtZW50IGluIElFIDlcblx0XHRcdFx0ZWxlbS5kb2N1bWVudCAmJiBlbGVtLmRvY3VtZW50Lm5vZGVUeXBlICE9PSAxMSApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdG5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGUoIGV4cHIsIHRydWUgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gU2l6emxlKCBleHByLCBkb2N1bWVudCwgbnVsbCwgWyBlbGVtIF0gKS5sZW5ndGggPiAwO1xufTtcblxuU2l6emxlLmNvbnRhaW5zID0gZnVuY3Rpb24oIGNvbnRleHQsIGVsZW0gKSB7XG5cblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdGlmICggKCBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCApICE9IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdH1cblx0cmV0dXJuIGNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICk7XG59O1xuXG5TaXp6bGUuYXR0ciA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRpZiAoICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKSAhPSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHR9XG5cblx0dmFyIGZuID0gRXhwci5hdHRySGFuZGxlWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSxcblxuXHRcdC8vIERvbid0IGdldCBmb29sZWQgYnkgT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzIChqUXVlcnkgIzEzODA3KVxuXHRcdHZhbCA9IGZuICYmIGhhc093bi5jYWxsKCBFeHByLmF0dHJIYW5kbGUsIG5hbWUudG9Mb3dlckNhc2UoKSApID9cblx0XHRcdGZuKCBlbGVtLCBuYW1lLCAhZG9jdW1lbnRJc0hUTUwgKSA6XG5cdFx0XHR1bmRlZmluZWQ7XG5cblx0cmV0dXJuIHZhbCAhPT0gdW5kZWZpbmVkID9cblx0XHR2YWwgOlxuXHRcdHN1cHBvcnQuYXR0cmlidXRlcyB8fCAhZG9jdW1lbnRJc0hUTUwgP1xuXHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKSA6XG5cdFx0XHQoIHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggbmFtZSApICkgJiYgdmFsLnNwZWNpZmllZCA/XG5cdFx0XHRcdHZhbC52YWx1ZSA6XG5cdFx0XHRcdG51bGw7XG59O1xuXG5TaXp6bGUuZXNjYXBlID0gZnVuY3Rpb24oIHNlbCApIHtcblx0cmV0dXJuICggc2VsICsgXCJcIiApLnJlcGxhY2UoIHJjc3Nlc2NhcGUsIGZjc3Nlc2NhcGUgKTtcbn07XG5cblNpenpsZS5lcnJvciA9IGZ1bmN0aW9uKCBtc2cgKSB7XG5cdHRocm93IG5ldyBFcnJvciggXCJTeW50YXggZXJyb3IsIHVucmVjb2duaXplZCBleHByZXNzaW9uOiBcIiArIG1zZyApO1xufTtcblxuLyoqXG4gKiBEb2N1bWVudCBzb3J0aW5nIGFuZCByZW1vdmluZyBkdXBsaWNhdGVzXG4gKiBAcGFyYW0ge0FycmF5TGlrZX0gcmVzdWx0c1xuICovXG5TaXp6bGUudW5pcXVlU29ydCA9IGZ1bmN0aW9uKCByZXN1bHRzICkge1xuXHR2YXIgZWxlbSxcblx0XHRkdXBsaWNhdGVzID0gW10sXG5cdFx0aiA9IDAsXG5cdFx0aSA9IDA7XG5cblx0Ly8gVW5sZXNzIHdlICprbm93KiB3ZSBjYW4gZGV0ZWN0IGR1cGxpY2F0ZXMsIGFzc3VtZSB0aGVpciBwcmVzZW5jZVxuXHRoYXNEdXBsaWNhdGUgPSAhc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzO1xuXHRzb3J0SW5wdXQgPSAhc3VwcG9ydC5zb3J0U3RhYmxlICYmIHJlc3VsdHMuc2xpY2UoIDAgKTtcblx0cmVzdWx0cy5zb3J0KCBzb3J0T3JkZXIgKTtcblxuXHRpZiAoIGhhc0R1cGxpY2F0ZSApIHtcblx0XHR3aGlsZSAoICggZWxlbSA9IHJlc3VsdHNbIGkrKyBdICkgKSB7XG5cdFx0XHRpZiAoIGVsZW0gPT09IHJlc3VsdHNbIGkgXSApIHtcblx0XHRcdFx0aiA9IGR1cGxpY2F0ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdHJlc3VsdHMuc3BsaWNlKCBkdXBsaWNhdGVzWyBqIF0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBDbGVhciBpbnB1dCBhZnRlciBzb3J0aW5nIHRvIHJlbGVhc2Ugb2JqZWN0c1xuXHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9zaXp6bGUvcHVsbC8yMjVcblx0c29ydElucHV0ID0gbnVsbDtcblxuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgcmV0cmlldmluZyB0aGUgdGV4dCB2YWx1ZSBvZiBhbiBhcnJheSBvZiBET00gbm9kZXNcbiAqIEBwYXJhbSB7QXJyYXl8RWxlbWVudH0gZWxlbVxuICovXG5nZXRUZXh0ID0gU2l6emxlLmdldFRleHQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0dmFyIG5vZGUsXG5cdFx0cmV0ID0gXCJcIixcblx0XHRpID0gMCxcblx0XHRub2RlVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0aWYgKCAhbm9kZVR5cGUgKSB7XG5cblx0XHQvLyBJZiBubyBub2RlVHlwZSwgdGhpcyBpcyBleHBlY3RlZCB0byBiZSBhbiBhcnJheVxuXHRcdHdoaWxlICggKCBub2RlID0gZWxlbVsgaSsrIF0gKSApIHtcblxuXHRcdFx0Ly8gRG8gbm90IHRyYXZlcnNlIGNvbW1lbnQgbm9kZXNcblx0XHRcdHJldCArPSBnZXRUZXh0KCBub2RlICk7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMSB8fCBub2RlVHlwZSA9PT0gOSB8fCBub2RlVHlwZSA9PT0gMTEgKSB7XG5cblx0XHQvLyBVc2UgdGV4dENvbnRlbnQgZm9yIGVsZW1lbnRzXG5cdFx0Ly8gaW5uZXJUZXh0IHVzYWdlIHJlbW92ZWQgZm9yIGNvbnNpc3RlbmN5IG9mIG5ldyBsaW5lcyAoalF1ZXJ5ICMxMTE1Mylcblx0XHRpZiAoIHR5cGVvZiBlbGVtLnRleHRDb250ZW50ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0udGV4dENvbnRlbnQ7XG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gVHJhdmVyc2UgaXRzIGNoaWxkcmVuXG5cdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcblx0XHRcdFx0cmV0ICs9IGdldFRleHQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAzIHx8IG5vZGVUeXBlID09PSA0ICkge1xuXHRcdHJldHVybiBlbGVtLm5vZGVWYWx1ZTtcblx0fVxuXG5cdC8vIERvIG5vdCBpbmNsdWRlIGNvbW1lbnQgb3IgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbiBub2Rlc1xuXG5cdHJldHVybiByZXQ7XG59O1xuXG5FeHByID0gU2l6emxlLnNlbGVjdG9ycyA9IHtcblxuXHQvLyBDYW4gYmUgYWRqdXN0ZWQgYnkgdGhlIHVzZXJcblx0Y2FjaGVMZW5ndGg6IDUwLFxuXG5cdGNyZWF0ZVBzZXVkbzogbWFya0Z1bmN0aW9uLFxuXG5cdG1hdGNoOiBtYXRjaEV4cHIsXG5cblx0YXR0ckhhbmRsZToge30sXG5cblx0ZmluZDoge30sXG5cblx0cmVsYXRpdmU6IHtcblx0XHRcIj5cIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiLCBmaXJzdDogdHJ1ZSB9LFxuXHRcdFwiIFwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIgfSxcblx0XHRcIitcIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIsIGZpcnN0OiB0cnVlIH0sXG5cdFx0XCJ+XCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiIH1cblx0fSxcblxuXHRwcmVGaWx0ZXI6IHtcblx0XHRcIkFUVFJcIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0bWF0Y2hbIDEgXSA9IG1hdGNoWyAxIF0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuXHRcdFx0Ly8gTW92ZSB0aGUgZ2l2ZW4gdmFsdWUgdG8gbWF0Y2hbM10gd2hldGhlciBxdW90ZWQgb3IgdW5xdW90ZWRcblx0XHRcdG1hdGNoWyAzIF0gPSAoIG1hdGNoWyAzIF0gfHwgbWF0Y2hbIDQgXSB8fFxuXHRcdFx0XHRtYXRjaFsgNSBdIHx8IFwiXCIgKS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXG5cdFx0XHRpZiAoIG1hdGNoWyAyIF0gPT09IFwifj1cIiApIHtcblx0XHRcdFx0bWF0Y2hbIDMgXSA9IFwiIFwiICsgbWF0Y2hbIDMgXSArIFwiIFwiO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0Y2guc2xpY2UoIDAsIDQgKTtcblx0XHR9LFxuXG5cdFx0XCJDSElMRFwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cblx0XHRcdC8qIG1hdGNoZXMgZnJvbSBtYXRjaEV4cHJbXCJDSElMRFwiXVxuXHRcdFx0XHQxIHR5cGUgKG9ubHl8bnRofC4uLilcblx0XHRcdFx0MiB3aGF0IChjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHQzIGFyZ3VtZW50IChldmVufG9kZHxcXGQqfFxcZCpuKFsrLV1cXGQrKT98Li4uKVxuXHRcdFx0XHQ0IHhuLWNvbXBvbmVudCBvZiB4bit5IGFyZ3VtZW50IChbKy1dP1xcZCpufClcblx0XHRcdFx0NSBzaWduIG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ2IHggb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDcgc2lnbiBvZiB5LWNvbXBvbmVudFxuXHRcdFx0XHQ4IHkgb2YgeS1jb21wb25lbnRcblx0XHRcdCovXG5cdFx0XHRtYXRjaFsgMSBdID0gbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHRpZiAoIG1hdGNoWyAxIF0uc2xpY2UoIDAsIDMgKSA9PT0gXCJudGhcIiApIHtcblxuXHRcdFx0XHQvLyBudGgtKiByZXF1aXJlcyBhcmd1bWVudFxuXHRcdFx0XHRpZiAoICFtYXRjaFsgMyBdICkge1xuXHRcdFx0XHRcdFNpenpsZS5lcnJvciggbWF0Y2hbIDAgXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gbnVtZXJpYyB4IGFuZCB5IHBhcmFtZXRlcnMgZm9yIEV4cHIuZmlsdGVyLkNISUxEXG5cdFx0XHRcdC8vIHJlbWVtYmVyIHRoYXQgZmFsc2UvdHJ1ZSBjYXN0IHJlc3BlY3RpdmVseSB0byAwLzFcblx0XHRcdFx0bWF0Y2hbIDQgXSA9ICsoIG1hdGNoWyA0IF0gP1xuXHRcdFx0XHRcdG1hdGNoWyA1IF0gKyAoIG1hdGNoWyA2IF0gfHwgMSApIDpcblx0XHRcdFx0XHQyICogKCBtYXRjaFsgMyBdID09PSBcImV2ZW5cIiB8fCBtYXRjaFsgMyBdID09PSBcIm9kZFwiICkgKTtcblx0XHRcdFx0bWF0Y2hbIDUgXSA9ICsoICggbWF0Y2hbIDcgXSArIG1hdGNoWyA4IF0gKSB8fCBtYXRjaFsgMyBdID09PSBcIm9kZFwiICk7XG5cblx0XHRcdFx0Ly8gb3RoZXIgdHlwZXMgcHJvaGliaXQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFsgMyBdICkge1xuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdH0sXG5cblx0XHRcIlBTRVVET1wiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHR2YXIgZXhjZXNzLFxuXHRcdFx0XHR1bnF1b3RlZCA9ICFtYXRjaFsgNiBdICYmIG1hdGNoWyAyIF07XG5cblx0XHRcdGlmICggbWF0Y2hFeHByWyBcIkNISUxEXCIgXS50ZXN0KCBtYXRjaFsgMCBdICkgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBY2NlcHQgcXVvdGVkIGFyZ3VtZW50cyBhcy1pc1xuXHRcdFx0aWYgKCBtYXRjaFsgMyBdICkge1xuXHRcdFx0XHRtYXRjaFsgMiBdID0gbWF0Y2hbIDQgXSB8fCBtYXRjaFsgNSBdIHx8IFwiXCI7XG5cblx0XHRcdC8vIFN0cmlwIGV4Y2VzcyBjaGFyYWN0ZXJzIGZyb20gdW5xdW90ZWQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCB1bnF1b3RlZCAmJiBycHNldWRvLnRlc3QoIHVucXVvdGVkICkgJiZcblxuXHRcdFx0XHQvLyBHZXQgZXhjZXNzIGZyb20gdG9rZW5pemUgKHJlY3Vyc2l2ZWx5KVxuXHRcdFx0XHQoIGV4Y2VzcyA9IHRva2VuaXplKCB1bnF1b3RlZCwgdHJ1ZSApICkgJiZcblxuXHRcdFx0XHQvLyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNsb3NpbmcgcGFyZW50aGVzaXNcblx0XHRcdFx0KCBleGNlc3MgPSB1bnF1b3RlZC5pbmRleE9mKCBcIilcIiwgdW5xdW90ZWQubGVuZ3RoIC0gZXhjZXNzICkgLSB1bnF1b3RlZC5sZW5ndGggKSApIHtcblxuXHRcdFx0XHQvLyBleGNlc3MgaXMgYSBuZWdhdGl2ZSBpbmRleFxuXHRcdFx0XHRtYXRjaFsgMCBdID0gbWF0Y2hbIDAgXS5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHRcdG1hdGNoWyAyIF0gPSB1bnF1b3RlZC5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldHVybiBvbmx5IGNhcHR1cmVzIG5lZWRlZCBieSB0aGUgcHNldWRvIGZpbHRlciBtZXRob2QgKHR5cGUgYW5kIGFyZ3VtZW50KVxuXHRcdFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCAzICk7XG5cdFx0fVxuXHR9LFxuXG5cdGZpbHRlcjoge1xuXG5cdFx0XCJUQUdcIjogZnVuY3Rpb24oIG5vZGVOYW1lU2VsZWN0b3IgKSB7XG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBub2RlTmFtZVNlbGVjdG9yLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBub2RlTmFtZVNlbGVjdG9yID09PSBcIipcIiA/XG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9IDpcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBub2RlTmFtZTtcblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJDTEFTU1wiOiBmdW5jdGlvbiggY2xhc3NOYW1lICkge1xuXHRcdFx0dmFyIHBhdHRlcm4gPSBjbGFzc0NhY2hlWyBjbGFzc05hbWUgKyBcIiBcIiBdO1xuXG5cdFx0XHRyZXR1cm4gcGF0dGVybiB8fFxuXHRcdFx0XHQoIHBhdHRlcm4gPSBuZXcgUmVnRXhwKCBcIihefFwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcdFx0XCIpXCIgKyBjbGFzc05hbWUgKyBcIihcIiArIHdoaXRlc3BhY2UgKyBcInwkKVwiICkgKSAmJiBjbGFzc0NhY2hlKFxuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHBhdHRlcm4udGVzdChcblx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgZWxlbS5jbGFzc05hbWUgPT09IFwic3RyaW5nXCIgJiYgZWxlbS5jbGFzc05hbWUgfHxcblx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgIT09IFwidW5kZWZpbmVkXCIgJiZcblx0XHRcdFx0XHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKCBcImNsYXNzXCIgKSB8fFxuXHRcdFx0XHRcdFx0XHRcdFwiXCJcblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0fSApO1xuXHRcdH0sXG5cblx0XHRcIkFUVFJcIjogZnVuY3Rpb24oIG5hbWUsIG9wZXJhdG9yLCBjaGVjayApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHJlc3VsdCA9IFNpenpsZS5hdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHRcdFx0aWYgKCByZXN1bHQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiIT1cIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICFvcGVyYXRvciApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJlc3VsdCArPSBcIlwiO1xuXG5cdFx0XHRcdC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cblxuXHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiPVwiID8gcmVzdWx0ID09PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiIT1cIiA/IHJlc3VsdCAhPT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIl49XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA9PT0gMCA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiKj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIiQ9XCIgPyBjaGVjayAmJiByZXN1bHQuc2xpY2UoIC1jaGVjay5sZW5ndGggKSA9PT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIn49XCIgPyAoIFwiIFwiICsgcmVzdWx0LnJlcGxhY2UoIHJ3aGl0ZXNwYWNlLCBcIiBcIiApICsgXCIgXCIgKS5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcInw9XCIgPyByZXN1bHQgPT09IGNoZWNrIHx8IHJlc3VsdC5zbGljZSggMCwgY2hlY2subGVuZ3RoICsgMSApID09PSBjaGVjayArIFwiLVwiIDpcblx0XHRcdFx0XHRmYWxzZTtcblx0XHRcdFx0LyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG5cblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiQ0hJTERcIjogZnVuY3Rpb24oIHR5cGUsIHdoYXQsIF9hcmd1bWVudCwgZmlyc3QsIGxhc3QgKSB7XG5cdFx0XHR2YXIgc2ltcGxlID0gdHlwZS5zbGljZSggMCwgMyApICE9PSBcIm50aFwiLFxuXHRcdFx0XHRmb3J3YXJkID0gdHlwZS5zbGljZSggLTQgKSAhPT0gXCJsYXN0XCIsXG5cdFx0XHRcdG9mVHlwZSA9IHdoYXQgPT09IFwib2YtdHlwZVwiO1xuXG5cdFx0XHRyZXR1cm4gZmlyc3QgPT09IDEgJiYgbGFzdCA9PT0gMCA/XG5cblx0XHRcdFx0Ly8gU2hvcnRjdXQgZm9yIDpudGgtKihuKVxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gISFlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRcdH0gOlxuXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBfY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdHZhciBjYWNoZSwgdW5pcXVlQ2FjaGUsIG91dGVyQ2FjaGUsIG5vZGUsIG5vZGVJbmRleCwgc3RhcnQsXG5cdFx0XHRcdFx0XHRkaXIgPSBzaW1wbGUgIT09IGZvcndhcmQgPyBcIm5leHRTaWJsaW5nXCIgOiBcInByZXZpb3VzU2libGluZ1wiLFxuXHRcdFx0XHRcdFx0cGFyZW50ID0gZWxlbS5wYXJlbnROb2RlLFxuXHRcdFx0XHRcdFx0bmFtZSA9IG9mVHlwZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksXG5cdFx0XHRcdFx0XHR1c2VDYWNoZSA9ICF4bWwgJiYgIW9mVHlwZSxcblx0XHRcdFx0XHRcdGRpZmYgPSBmYWxzZTtcblxuXHRcdFx0XHRcdGlmICggcGFyZW50ICkge1xuXG5cdFx0XHRcdFx0XHQvLyA6KGZpcnN0fGxhc3R8b25seSktKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdFx0XHRpZiAoIHNpbXBsZSApIHtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCBkaXIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCAoIG5vZGUgPSBub2RlWyBkaXIgXSApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBvZlR5cGUgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBSZXZlcnNlIGRpcmVjdGlvbiBmb3IgOm9ubHktKiAoaWYgd2UgaGF2ZW4ndCB5ZXQgZG9uZSBzbylcblx0XHRcdFx0XHRcdFx0XHRzdGFydCA9IGRpciA9IHR5cGUgPT09IFwib25seVwiICYmICFzdGFydCAmJiBcIm5leHRTaWJsaW5nXCI7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHN0YXJ0ID0gWyBmb3J3YXJkID8gcGFyZW50LmZpcnN0Q2hpbGQgOiBwYXJlbnQubGFzdENoaWxkIF07XG5cblx0XHRcdFx0XHRcdC8vIG5vbi14bWwgOm50aC1jaGlsZCguLi4pIHN0b3JlcyBjYWNoZSBkYXRhIG9uIGBwYXJlbnRgXG5cdFx0XHRcdFx0XHRpZiAoIGZvcndhcmQgJiYgdXNlQ2FjaGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU2VlayBgZWxlbWAgZnJvbSBhIHByZXZpb3VzbHktY2FjaGVkIGluZGV4XG5cblx0XHRcdFx0XHRcdFx0Ly8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxuXHRcdFx0XHRcdFx0XHRub2RlID0gcGFyZW50O1xuXHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8ICggbm9kZVsgZXhwYW5kbyBdID0ge30gKTtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdCggb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30gKTtcblxuXHRcdFx0XHRcdFx0XHRjYWNoZSA9IHVuaXF1ZUNhY2hlWyB0eXBlIF0gfHwgW107XG5cdFx0XHRcdFx0XHRcdG5vZGVJbmRleCA9IGNhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbIDEgXTtcblx0XHRcdFx0XHRcdFx0ZGlmZiA9IG5vZGVJbmRleCAmJiBjYWNoZVsgMiBdO1xuXHRcdFx0XHRcdFx0XHRub2RlID0gbm9kZUluZGV4ICYmIHBhcmVudC5jaGlsZE5vZGVzWyBub2RlSW5kZXggXTtcblxuXHRcdFx0XHRcdFx0XHR3aGlsZSAoICggbm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblxuXHRcdFx0XHRcdFx0XHRcdC8vIEZhbGxiYWNrIHRvIHNlZWtpbmcgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdFx0KCBkaWZmID0gbm9kZUluZGV4ID0gMCApIHx8IHN0YXJ0LnBvcCgpICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBXaGVuIGZvdW5kLCBjYWNoZSBpbmRleGVzIG9uIGBwYXJlbnRgIGFuZCBicmVha1xuXHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiArK2RpZmYgJiYgbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIG5vZGVJbmRleCwgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gVXNlIHByZXZpb3VzbHktY2FjaGVkIGVsZW1lbnQgaW5kZXggaWYgYXZhaWxhYmxlXG5cdFx0XHRcdFx0XHRcdGlmICggdXNlQ2FjaGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAoIG5vZGVbIGV4cGFuZG8gXSA9IHt9ICk7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdCggb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30gKTtcblxuXHRcdFx0XHRcdFx0XHRcdGNhY2hlID0gdW5pcXVlQ2FjaGVbIHR5cGUgXSB8fCBbXTtcblx0XHRcdFx0XHRcdFx0XHRub2RlSW5kZXggPSBjYWNoZVsgMCBdID09PSBkaXJydW5zICYmIGNhY2hlWyAxIF07XG5cdFx0XHRcdFx0XHRcdFx0ZGlmZiA9IG5vZGVJbmRleDtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdC8vIHhtbCA6bnRoLWNoaWxkKC4uLilcblx0XHRcdFx0XHRcdFx0Ly8gb3IgOm50aC1sYXN0LWNoaWxkKC4uLikgb3IgOm50aCgtbGFzdCk/LW9mLXR5cGUoLi4uKVxuXHRcdFx0XHRcdFx0XHRpZiAoIGRpZmYgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gVXNlIHRoZSBzYW1lIGxvb3AgYXMgYWJvdmUgdG8gc2VlayBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoICggbm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdCggZGlmZiA9IG5vZGVJbmRleCA9IDAgKSB8fCBzdGFydC5wb3AoKSApICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoICggb2ZUeXBlID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlVHlwZSA9PT0gMSApICYmXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCsrZGlmZiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBDYWNoZSB0aGUgaW5kZXggb2YgZWFjaCBlbmNvdW50ZXJlZCBlbGVtZW50XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggdXNlQ2FjaGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0KCBub2RlWyBleHBhbmRvIF0gPSB7fSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQoIG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9ICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSW5jb3Jwb3JhdGUgdGhlIG9mZnNldCwgdGhlbiBjaGVjayBhZ2FpbnN0IGN5Y2xlIHNpemVcblx0XHRcdFx0XHRcdGRpZmYgLT0gbGFzdDtcblx0XHRcdFx0XHRcdHJldHVybiBkaWZmID09PSBmaXJzdCB8fCAoIGRpZmYgJSBmaXJzdCA9PT0gMCAmJiBkaWZmIC8gZmlyc3QgPj0gMCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIHBzZXVkbywgYXJndW1lbnQgKSB7XG5cblx0XHRcdC8vIHBzZXVkby1jbGFzcyBuYW1lcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZVxuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNwc2V1ZG8tY2xhc3Nlc1xuXHRcdFx0Ly8gUHJpb3JpdGl6ZSBieSBjYXNlIHNlbnNpdGl2aXR5IGluIGNhc2UgY3VzdG9tIHBzZXVkb3MgYXJlIGFkZGVkIHdpdGggdXBwZXJjYXNlIGxldHRlcnNcblx0XHRcdC8vIFJlbWVtYmVyIHRoYXQgc2V0RmlsdGVycyBpbmhlcml0cyBmcm9tIHBzZXVkb3Ncblx0XHRcdHZhciBhcmdzLFxuXHRcdFx0XHRmbiA9IEV4cHIucHNldWRvc1sgcHNldWRvIF0gfHwgRXhwci5zZXRGaWx0ZXJzWyBwc2V1ZG8udG9Mb3dlckNhc2UoKSBdIHx8XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBcInVuc3VwcG9ydGVkIHBzZXVkbzogXCIgKyBwc2V1ZG8gKTtcblxuXHRcdFx0Ly8gVGhlIHVzZXIgbWF5IHVzZSBjcmVhdGVQc2V1ZG8gdG8gaW5kaWNhdGUgdGhhdFxuXHRcdFx0Ly8gYXJndW1lbnRzIGFyZSBuZWVkZWQgdG8gY3JlYXRlIHRoZSBmaWx0ZXIgZnVuY3Rpb25cblx0XHRcdC8vIGp1c3QgYXMgU2l6emxlIGRvZXNcblx0XHRcdGlmICggZm5bIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0cmV0dXJuIGZuKCBhcmd1bWVudCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBCdXQgbWFpbnRhaW4gc3VwcG9ydCBmb3Igb2xkIHNpZ25hdHVyZXNcblx0XHRcdGlmICggZm4ubGVuZ3RoID4gMSApIHtcblx0XHRcdFx0YXJncyA9IFsgcHNldWRvLCBwc2V1ZG8sIFwiXCIsIGFyZ3VtZW50IF07XG5cdFx0XHRcdHJldHVybiBFeHByLnNldEZpbHRlcnMuaGFzT3duUHJvcGVydHkoIHBzZXVkby50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0XHRcdG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG5cdFx0XHRcdFx0XHR2YXIgaWR4LFxuXHRcdFx0XHRcdFx0XHRtYXRjaGVkID0gZm4oIHNlZWQsIGFyZ3VtZW50ICksXG5cdFx0XHRcdFx0XHRcdGkgPSBtYXRjaGVkLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRpZHggPSBpbmRleE9mKCBzZWVkLCBtYXRjaGVkWyBpIF0gKTtcblx0XHRcdFx0XHRcdFx0c2VlZFsgaWR4IF0gPSAhKCBtYXRjaGVzWyBpZHggXSA9IG1hdGNoZWRbIGkgXSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gKSA6XG5cdFx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZm4oIGVsZW0sIDAsIGFyZ3MgKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZm47XG5cdFx0fVxuXHR9LFxuXG5cdHBzZXVkb3M6IHtcblxuXHRcdC8vIFBvdGVudGlhbGx5IGNvbXBsZXggcHNldWRvc1xuXHRcdFwibm90XCI6IG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXG5cdFx0XHQvLyBUcmltIHRoZSBzZWxlY3RvciBwYXNzZWQgdG8gY29tcGlsZVxuXHRcdFx0Ly8gdG8gYXZvaWQgdHJlYXRpbmcgbGVhZGluZyBhbmQgdHJhaWxpbmdcblx0XHRcdC8vIHNwYWNlcyBhcyBjb21iaW5hdG9yc1xuXHRcdFx0dmFyIGlucHV0ID0gW10sXG5cdFx0XHRcdHJlc3VsdHMgPSBbXSxcblx0XHRcdFx0bWF0Y2hlciA9IGNvbXBpbGUoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSApO1xuXG5cdFx0XHRyZXR1cm4gbWF0Y2hlclsgZXhwYW5kbyBdID9cblx0XHRcdFx0bWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcywgX2NvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0XHRcdHVubWF0Y2hlZCA9IG1hdGNoZXIoIHNlZWQsIG51bGwsIHhtbCwgW10gKSxcblx0XHRcdFx0XHRcdGkgPSBzZWVkLmxlbmd0aDtcblxuXHRcdFx0XHRcdC8vIE1hdGNoIGVsZW1lbnRzIHVubWF0Y2hlZCBieSBgbWF0Y2hlcmBcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKCBlbGVtID0gdW5tYXRjaGVkWyBpIF0gKSApIHtcblx0XHRcdFx0XHRcdFx0c2VlZFsgaSBdID0gISggbWF0Y2hlc1sgaSBdID0gZWxlbSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApIDpcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIF9jb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0aW5wdXRbIDAgXSA9IGVsZW07XG5cdFx0XHRcdFx0bWF0Y2hlciggaW5wdXQsIG51bGwsIHhtbCwgcmVzdWx0cyApO1xuXG5cdFx0XHRcdFx0Ly8gRG9uJ3Qga2VlcCB0aGUgZWxlbWVudCAoaXNzdWUgIzI5OSlcblx0XHRcdFx0XHRpbnB1dFsgMCBdID0gbnVsbDtcblx0XHRcdFx0XHRyZXR1cm4gIXJlc3VsdHMucG9wKCk7XG5cdFx0XHRcdH07XG5cdFx0fSApLFxuXG5cdFx0XCJoYXNcIjogbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBTaXp6bGUoIHNlbGVjdG9yLCBlbGVtICkubGVuZ3RoID4gMDtcblx0XHRcdH07XG5cdFx0fSApLFxuXG5cdFx0XCJjb250YWluc1wiOiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0dGV4dCA9IHRleHQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS50ZXh0Q29udGVudCB8fCBnZXRUZXh0KCBlbGVtICkgKS5pbmRleE9mKCB0ZXh0ICkgPiAtMTtcblx0XHRcdH07XG5cdFx0fSApLFxuXG5cdFx0Ly8gXCJXaGV0aGVyIGFuIGVsZW1lbnQgaXMgcmVwcmVzZW50ZWQgYnkgYSA6bGFuZygpIHNlbGVjdG9yXG5cdFx0Ly8gaXMgYmFzZWQgc29sZWx5IG9uIHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWVcblx0XHQvLyBiZWluZyBlcXVhbCB0byB0aGUgaWRlbnRpZmllciBDLFxuXHRcdC8vIG9yIGJlZ2lubmluZyB3aXRoIHRoZSBpZGVudGlmaWVyIEMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgXCItXCIuXG5cdFx0Ly8gVGhlIG1hdGNoaW5nIG9mIEMgYWdhaW5zdCB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlIGlzIHBlcmZvcm1lZCBjYXNlLWluc2Vuc2l0aXZlbHkuXG5cdFx0Ly8gVGhlIGlkZW50aWZpZXIgQyBkb2VzIG5vdCBoYXZlIHRvIGJlIGEgdmFsaWQgbGFuZ3VhZ2UgbmFtZS5cIlxuXHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jbGFuZy1wc2V1ZG9cblx0XHRcImxhbmdcIjogbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggbGFuZyApIHtcblxuXHRcdFx0Ly8gbGFuZyB2YWx1ZSBtdXN0IGJlIGEgdmFsaWQgaWRlbnRpZmllclxuXHRcdFx0aWYgKCAhcmlkZW50aWZpZXIudGVzdCggbGFuZyB8fCBcIlwiICkgKSB7XG5cdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBsYW5nOiBcIiArIGxhbmcgKTtcblx0XHRcdH1cblx0XHRcdGxhbmcgPSBsYW5nLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIGVsZW1MYW5nO1xuXHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0aWYgKCAoIGVsZW1MYW5nID0gZG9jdW1lbnRJc0hUTUwgP1xuXHRcdFx0XHRcdFx0ZWxlbS5sYW5nIDpcblx0XHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKCBcInhtbDpsYW5nXCIgKSB8fCBlbGVtLmdldEF0dHJpYnV0ZSggXCJsYW5nXCIgKSApICkge1xuXG5cdFx0XHRcdFx0XHRlbGVtTGFuZyA9IGVsZW1MYW5nLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbUxhbmcgPT09IGxhbmcgfHwgZWxlbUxhbmcuaW5kZXhPZiggbGFuZyArIFwiLVwiICkgPT09IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IHdoaWxlICggKCBlbGVtID0gZWxlbS5wYXJlbnROb2RlICkgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH0gKSxcblxuXHRcdC8vIE1pc2NlbGxhbmVvdXNcblx0XHRcInRhcmdldFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBoYXNoID0gd2luZG93LmxvY2F0aW9uICYmIHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xuXHRcdFx0cmV0dXJuIGhhc2ggJiYgaGFzaC5zbGljZSggMSApID09PSBlbGVtLmlkO1xuXHRcdH0sXG5cblx0XHRcInJvb3RcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZG9jRWxlbTtcblx0XHR9LFxuXG5cdFx0XCJmb2N1c1wiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmXG5cdFx0XHRcdCggIWRvY3VtZW50Lmhhc0ZvY3VzIHx8IGRvY3VtZW50Lmhhc0ZvY3VzKCkgKSAmJlxuXHRcdFx0XHQhISggZWxlbS50eXBlIHx8IGVsZW0uaHJlZiB8fCB+ZWxlbS50YWJJbmRleCApO1xuXHRcdH0sXG5cblx0XHQvLyBCb29sZWFuIHByb3BlcnRpZXNcblx0XHRcImVuYWJsZWRcIjogY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIGZhbHNlICksXG5cdFx0XCJkaXNhYmxlZFwiOiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggdHJ1ZSApLFxuXG5cdFx0XCJjaGVja2VkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvLyBJbiBDU1MzLCA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIGJvdGggY2hlY2tlZCBhbmQgc2VsZWN0ZWQgZWxlbWVudHNcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmICEhZWxlbS5jaGVja2VkICkgfHxcblx0XHRcdFx0KCBub2RlTmFtZSA9PT0gXCJvcHRpb25cIiAmJiAhIWVsZW0uc2VsZWN0ZWQgKTtcblx0XHR9LFxuXG5cdFx0XCJzZWxlY3RlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0Ly8gQWNjZXNzaW5nIHRoaXMgcHJvcGVydHkgbWFrZXMgc2VsZWN0ZWQtYnktZGVmYXVsdFxuXHRcdFx0Ly8gb3B0aW9ucyBpbiBTYWZhcmkgd29yayBwcm9wZXJseVxuXHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcblx0XHRcdFx0ZWxlbS5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtLnNlbGVjdGVkID09PSB0cnVlO1xuXHRcdH0sXG5cblx0XHQvLyBDb250ZW50c1xuXHRcdFwiZW1wdHlcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jZW1wdHktcHNldWRvXG5cdFx0XHQvLyA6ZW1wdHkgaXMgbmVnYXRlZCBieSBlbGVtZW50ICgxKSBvciBjb250ZW50IG5vZGVzICh0ZXh0OiAzOyBjZGF0YTogNDsgZW50aXR5IHJlZjogNSksXG5cdFx0XHQvLyAgIGJ1dCBub3QgYnkgb3RoZXJzIChjb21tZW50OiA4OyBwcm9jZXNzaW5nIGluc3RydWN0aW9uOiA3OyBldGMuKVxuXHRcdFx0Ly8gbm9kZVR5cGUgPCA2IHdvcmtzIGJlY2F1c2UgYXR0cmlidXRlcyAoMikgZG8gbm90IGFwcGVhciBhcyBjaGlsZHJlblxuXHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA8IDYgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0XCJwYXJlbnRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gIUV4cHIucHNldWRvc1sgXCJlbXB0eVwiIF0oIGVsZW0gKTtcblx0XHR9LFxuXG5cdFx0Ly8gRWxlbWVudC9pbnB1dCB0eXBlc1xuXHRcdFwiaGVhZGVyXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJoZWFkZXIudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImlucHV0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJpbnB1dHMudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImJ1dHRvblwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IFwiYnV0dG9uXCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIjtcblx0XHR9LFxuXG5cdFx0XCJ0ZXh0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGF0dHI7XG5cdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgJiZcblx0XHRcdFx0ZWxlbS50eXBlID09PSBcInRleHRcIiAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFPDhcblx0XHRcdFx0Ly8gTmV3IEhUTUw1IGF0dHJpYnV0ZSB2YWx1ZXMgKGUuZy4sIFwic2VhcmNoXCIpIGFwcGVhciB3aXRoIGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCJcblx0XHRcdFx0KCAoIGF0dHIgPSBlbGVtLmdldEF0dHJpYnV0ZSggXCJ0eXBlXCIgKSApID09IG51bGwgfHxcblx0XHRcdFx0XHRhdHRyLnRvTG93ZXJDYXNlKCkgPT09IFwidGV4dFwiICk7XG5cdFx0fSxcblxuXHRcdC8vIFBvc2l0aW9uLWluLWNvbGxlY3Rpb25cblx0XHRcImZpcnN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIFsgMCBdO1xuXHRcdH0gKSxcblxuXHRcdFwibGFzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmdW5jdGlvbiggX21hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIFsgbGVuZ3RoIC0gMSBdO1xuXHRcdH0gKSxcblxuXHRcdFwiZXFcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZnVuY3Rpb24oIF9tYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHRyZXR1cm4gWyBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50IF07XG5cdFx0fSApLFxuXG5cdFx0XCJldmVuXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9ICksXG5cblx0XHRcIm9kZFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgaSA9IDE7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSApLFxuXG5cdFx0XCJsdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgP1xuXHRcdFx0XHRhcmd1bWVudCArIGxlbmd0aCA6XG5cdFx0XHRcdGFyZ3VtZW50ID4gbGVuZ3RoID9cblx0XHRcdFx0XHRsZW5ndGggOlxuXHRcdFx0XHRcdGFyZ3VtZW50O1xuXHRcdFx0Zm9yICggOyAtLWkgPj0gMDsgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0gKSxcblxuXHRcdFwiZ3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgKytpIDwgbGVuZ3RoOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSApXG5cdH1cbn07XG5cbkV4cHIucHNldWRvc1sgXCJudGhcIiBdID0gRXhwci5wc2V1ZG9zWyBcImVxXCIgXTtcblxuLy8gQWRkIGJ1dHRvbi9pbnB1dCB0eXBlIHBzZXVkb3NcbmZvciAoIGkgaW4geyByYWRpbzogdHJ1ZSwgY2hlY2tib3g6IHRydWUsIGZpbGU6IHRydWUsIHBhc3N3b3JkOiB0cnVlLCBpbWFnZTogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUlucHV0UHNldWRvKCBpICk7XG59XG5mb3IgKCBpIGluIHsgc3VibWl0OiB0cnVlLCByZXNldDogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUJ1dHRvblBzZXVkbyggaSApO1xufVxuXG4vLyBFYXN5IEFQSSBmb3IgY3JlYXRpbmcgbmV3IHNldEZpbHRlcnNcbmZ1bmN0aW9uIHNldEZpbHRlcnMoKSB7fVxuc2V0RmlsdGVycy5wcm90b3R5cGUgPSBFeHByLmZpbHRlcnMgPSBFeHByLnBzZXVkb3M7XG5FeHByLnNldEZpbHRlcnMgPSBuZXcgc2V0RmlsdGVycygpO1xuXG50b2tlbml6ZSA9IFNpenpsZS50b2tlbml6ZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgcGFyc2VPbmx5ICkge1xuXHR2YXIgbWF0Y2hlZCwgbWF0Y2gsIHRva2VucywgdHlwZSxcblx0XHRzb0ZhciwgZ3JvdXBzLCBwcmVGaWx0ZXJzLFxuXHRcdGNhY2hlZCA9IHRva2VuQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoIGNhY2hlZCApIHtcblx0XHRyZXR1cm4gcGFyc2VPbmx5ID8gMCA6IGNhY2hlZC5zbGljZSggMCApO1xuXHR9XG5cblx0c29GYXIgPSBzZWxlY3Rvcjtcblx0Z3JvdXBzID0gW107XG5cdHByZUZpbHRlcnMgPSBFeHByLnByZUZpbHRlcjtcblxuXHR3aGlsZSAoIHNvRmFyICkge1xuXG5cdFx0Ly8gQ29tbWEgYW5kIGZpcnN0IHJ1blxuXHRcdGlmICggIW1hdGNoZWQgfHwgKCBtYXRjaCA9IHJjb21tYS5leGVjKCBzb0ZhciApICkgKSB7XG5cdFx0XHRpZiAoIG1hdGNoICkge1xuXG5cdFx0XHRcdC8vIERvbid0IGNvbnN1bWUgdHJhaWxpbmcgY29tbWFzIGFzIHZhbGlkXG5cdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoWyAwIF0ubGVuZ3RoICkgfHwgc29GYXI7XG5cdFx0XHR9XG5cdFx0XHRncm91cHMucHVzaCggKCB0b2tlbnMgPSBbXSApICk7XG5cdFx0fVxuXG5cdFx0bWF0Y2hlZCA9IGZhbHNlO1xuXG5cdFx0Ly8gQ29tYmluYXRvcnNcblx0XHRpZiAoICggbWF0Y2ggPSByY29tYmluYXRvcnMuZXhlYyggc29GYXIgKSApICkge1xuXHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHR0b2tlbnMucHVzaCgge1xuXHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblxuXHRcdFx0XHQvLyBDYXN0IGRlc2NlbmRhbnQgY29tYmluYXRvcnMgdG8gc3BhY2Vcblx0XHRcdFx0dHlwZTogbWF0Y2hbIDAgXS5yZXBsYWNlKCBydHJpbSwgXCIgXCIgKVxuXHRcdFx0fSApO1xuXHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGaWx0ZXJzXG5cdFx0Zm9yICggdHlwZSBpbiBFeHByLmZpbHRlciApIHtcblx0XHRcdGlmICggKCBtYXRjaCA9IG1hdGNoRXhwclsgdHlwZSBdLmV4ZWMoIHNvRmFyICkgKSAmJiAoICFwcmVGaWx0ZXJzWyB0eXBlIF0gfHxcblx0XHRcdFx0KCBtYXRjaCA9IHByZUZpbHRlcnNbIHR5cGUgXSggbWF0Y2ggKSApICkgKSB7XG5cdFx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0XHR0b2tlbnMucHVzaCgge1xuXHRcdFx0XHRcdHZhbHVlOiBtYXRjaGVkLFxuXHRcdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdFx0bWF0Y2hlczogbWF0Y2hcblx0XHRcdFx0fSApO1xuXHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggIW1hdGNoZWQgKSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgaW52YWxpZCBleGNlc3Ncblx0Ly8gaWYgd2UncmUganVzdCBwYXJzaW5nXG5cdC8vIE90aGVyd2lzZSwgdGhyb3cgYW4gZXJyb3Igb3IgcmV0dXJuIHRva2Vuc1xuXHRyZXR1cm4gcGFyc2VPbmx5ID9cblx0XHRzb0Zhci5sZW5ndGggOlxuXHRcdHNvRmFyID9cblx0XHRcdFNpenpsZS5lcnJvciggc2VsZWN0b3IgKSA6XG5cblx0XHRcdC8vIENhY2hlIHRoZSB0b2tlbnNcblx0XHRcdHRva2VuQ2FjaGUoIHNlbGVjdG9yLCBncm91cHMgKS5zbGljZSggMCApO1xufTtcblxuZnVuY3Rpb24gdG9TZWxlY3RvciggdG9rZW5zICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gdG9rZW5zLmxlbmd0aCxcblx0XHRzZWxlY3RvciA9IFwiXCI7XG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdHNlbGVjdG9yICs9IHRva2Vuc1sgaSBdLnZhbHVlO1xuXHR9XG5cdHJldHVybiBzZWxlY3Rvcjtcbn1cblxuZnVuY3Rpb24gYWRkQ29tYmluYXRvciggbWF0Y2hlciwgY29tYmluYXRvciwgYmFzZSApIHtcblx0dmFyIGRpciA9IGNvbWJpbmF0b3IuZGlyLFxuXHRcdHNraXAgPSBjb21iaW5hdG9yLm5leHQsXG5cdFx0a2V5ID0gc2tpcCB8fCBkaXIsXG5cdFx0Y2hlY2tOb25FbGVtZW50cyA9IGJhc2UgJiYga2V5ID09PSBcInBhcmVudE5vZGVcIixcblx0XHRkb25lTmFtZSA9IGRvbmUrKztcblxuXHRyZXR1cm4gY29tYmluYXRvci5maXJzdCA/XG5cblx0XHQvLyBDaGVjayBhZ2FpbnN0IGNsb3Nlc3QgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRcblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSBlbGVtWyBkaXIgXSApICkge1xuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9IDpcblxuXHRcdC8vIENoZWNrIGFnYWluc3QgYWxsIGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50c1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgb2xkQ2FjaGUsIHVuaXF1ZUNhY2hlLCBvdXRlckNhY2hlLFxuXHRcdFx0XHRuZXdDYWNoZSA9IFsgZGlycnVucywgZG9uZU5hbWUgXTtcblxuXHRcdFx0Ly8gV2UgY2FuJ3Qgc2V0IGFyYml0cmFyeSBkYXRhIG9uIFhNTCBub2Rlcywgc28gdGhleSBkb24ndCBiZW5lZml0IGZyb20gY29tYmluYXRvciBjYWNoaW5nXG5cdFx0XHRpZiAoIHhtbCApIHtcblx0XHRcdFx0d2hpbGUgKCAoIGVsZW0gPSBlbGVtWyBkaXIgXSApICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aGlsZSAoICggZWxlbSA9IGVsZW1bIGRpciBdICkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gZWxlbVsgZXhwYW5kbyBdIHx8ICggZWxlbVsgZXhwYW5kbyBdID0ge30gKTtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIGVsZW0udW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHQoIG91dGVyQ2FjaGVbIGVsZW0udW5pcXVlSUQgXSA9IHt9ICk7XG5cblx0XHRcdFx0XHRcdGlmICggc2tpcCAmJiBza2lwID09PSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgKSB7XG5cdFx0XHRcdFx0XHRcdGVsZW0gPSBlbGVtWyBkaXIgXSB8fCBlbGVtO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggKCBvbGRDYWNoZSA9IHVuaXF1ZUNhY2hlWyBrZXkgXSApICYmXG5cdFx0XHRcdFx0XHRcdG9sZENhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgb2xkQ2FjaGVbIDEgXSA9PT0gZG9uZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQXNzaWduIHRvIG5ld0NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcblx0XHRcdFx0XHRcdFx0cmV0dXJuICggbmV3Q2FjaGVbIDIgXSA9IG9sZENhY2hlWyAyIF0gKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gUmV1c2UgbmV3Y2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsga2V5IF0gPSBuZXdDYWNoZTtcblxuXHRcdFx0XHRcdFx0XHQvLyBBIG1hdGNoIG1lYW5zIHdlJ3JlIGRvbmU7IGEgZmFpbCBtZWFucyB3ZSBoYXZlIHRvIGtlZXAgY2hlY2tpbmdcblx0XHRcdFx0XHRcdFx0aWYgKCAoIG5ld0NhY2hlWyAyIF0gPSBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcbn1cblxuZnVuY3Rpb24gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICkge1xuXHRyZXR1cm4gbWF0Y2hlcnMubGVuZ3RoID4gMSA/XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBpID0gbWF0Y2hlcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggIW1hdGNoZXJzWyBpIF0oIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSA6XG5cdFx0bWF0Y2hlcnNbIDAgXTtcbn1cblxuZnVuY3Rpb24gbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IsIGNvbnRleHRzLCByZXN1bHRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gY29udGV4dHMubGVuZ3RoO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0c1sgaSBdLCByZXN1bHRzICk7XG5cdH1cblx0cmV0dXJuIHJlc3VsdHM7XG59XG5cbmZ1bmN0aW9uIGNvbmRlbnNlKCB1bm1hdGNoZWQsIG1hcCwgZmlsdGVyLCBjb250ZXh0LCB4bWwgKSB7XG5cdHZhciBlbGVtLFxuXHRcdG5ld1VubWF0Y2hlZCA9IFtdLFxuXHRcdGkgPSAwLFxuXHRcdGxlbiA9IHVubWF0Y2hlZC5sZW5ndGgsXG5cdFx0bWFwcGVkID0gbWFwICE9IG51bGw7XG5cblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0aWYgKCAoIGVsZW0gPSB1bm1hdGNoZWRbIGkgXSApICkge1xuXHRcdFx0aWYgKCAhZmlsdGVyIHx8IGZpbHRlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdG5ld1VubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdGlmICggbWFwcGVkICkge1xuXHRcdFx0XHRcdG1hcC5wdXNoKCBpICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbmV3VW5tYXRjaGVkO1xufVxuXG5mdW5jdGlvbiBzZXRNYXRjaGVyKCBwcmVGaWx0ZXIsIHNlbGVjdG9yLCBtYXRjaGVyLCBwb3N0RmlsdGVyLCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKSB7XG5cdGlmICggcG9zdEZpbHRlciAmJiAhcG9zdEZpbHRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaWx0ZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmlsdGVyICk7XG5cdH1cblx0aWYgKCBwb3N0RmluZGVyICYmICFwb3N0RmluZGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbmRlciA9IHNldE1hdGNoZXIoIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApO1xuXHR9XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBzZWVkLCByZXN1bHRzLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0dmFyIHRlbXAsIGksIGVsZW0sXG5cdFx0XHRwcmVNYXAgPSBbXSxcblx0XHRcdHBvc3RNYXAgPSBbXSxcblx0XHRcdHByZWV4aXN0aW5nID0gcmVzdWx0cy5sZW5ndGgsXG5cblx0XHRcdC8vIEdldCBpbml0aWFsIGVsZW1lbnRzIGZyb20gc2VlZCBvciBjb250ZXh0XG5cdFx0XHRlbGVtcyA9IHNlZWQgfHwgbXVsdGlwbGVDb250ZXh0cyhcblx0XHRcdFx0c2VsZWN0b3IgfHwgXCIqXCIsXG5cdFx0XHRcdGNvbnRleHQubm9kZVR5cGUgPyBbIGNvbnRleHQgXSA6IGNvbnRleHQsXG5cdFx0XHRcdFtdXG5cdFx0XHQpLFxuXG5cdFx0XHQvLyBQcmVmaWx0ZXIgdG8gZ2V0IG1hdGNoZXIgaW5wdXQsIHByZXNlcnZpbmcgYSBtYXAgZm9yIHNlZWQtcmVzdWx0cyBzeW5jaHJvbml6YXRpb25cblx0XHRcdG1hdGNoZXJJbiA9IHByZUZpbHRlciAmJiAoIHNlZWQgfHwgIXNlbGVjdG9yICkgP1xuXHRcdFx0XHRjb25kZW5zZSggZWxlbXMsIHByZU1hcCwgcHJlRmlsdGVyLCBjb250ZXh0LCB4bWwgKSA6XG5cdFx0XHRcdGVsZW1zLFxuXG5cdFx0XHRtYXRjaGVyT3V0ID0gbWF0Y2hlciA/XG5cblx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBhIHBvc3RGaW5kZXIsIG9yIGZpbHRlcmVkIHNlZWQsIG9yIG5vbi1zZWVkIHBvc3RGaWx0ZXIgb3IgcHJlZXhpc3RpbmcgcmVzdWx0cyxcblx0XHRcdFx0cG9zdEZpbmRlciB8fCAoIHNlZWQgPyBwcmVGaWx0ZXIgOiBwcmVleGlzdGluZyB8fCBwb3N0RmlsdGVyICkgP1xuXG5cdFx0XHRcdFx0Ly8gLi4uaW50ZXJtZWRpYXRlIHByb2Nlc3NpbmcgaXMgbmVjZXNzYXJ5XG5cdFx0XHRcdFx0W10gOlxuXG5cdFx0XHRcdFx0Ly8gLi4ub3RoZXJ3aXNlIHVzZSByZXN1bHRzIGRpcmVjdGx5XG5cdFx0XHRcdFx0cmVzdWx0cyA6XG5cdFx0XHRcdG1hdGNoZXJJbjtcblxuXHRcdC8vIEZpbmQgcHJpbWFyeSBtYXRjaGVzXG5cdFx0aWYgKCBtYXRjaGVyICkge1xuXHRcdFx0bWF0Y2hlciggbWF0Y2hlckluLCBtYXRjaGVyT3V0LCBjb250ZXh0LCB4bWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwb3N0RmlsdGVyXG5cdFx0aWYgKCBwb3N0RmlsdGVyICkge1xuXHRcdFx0dGVtcCA9IGNvbmRlbnNlKCBtYXRjaGVyT3V0LCBwb3N0TWFwICk7XG5cdFx0XHRwb3N0RmlsdGVyKCB0ZW1wLCBbXSwgY29udGV4dCwgeG1sICk7XG5cblx0XHRcdC8vIFVuLW1hdGNoIGZhaWxpbmcgZWxlbWVudHMgYnkgbW92aW5nIHRoZW0gYmFjayB0byBtYXRjaGVySW5cblx0XHRcdGkgPSB0ZW1wLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoICggZWxlbSA9IHRlbXBbIGkgXSApICkge1xuXHRcdFx0XHRcdG1hdGNoZXJPdXRbIHBvc3RNYXBbIGkgXSBdID0gISggbWF0Y2hlckluWyBwb3N0TWFwWyBpIF0gXSA9IGVsZW0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggc2VlZCApIHtcblx0XHRcdGlmICggcG9zdEZpbmRlciB8fCBwcmVGaWx0ZXIgKSB7XG5cdFx0XHRcdGlmICggcG9zdEZpbmRlciApIHtcblxuXHRcdFx0XHRcdC8vIEdldCB0aGUgZmluYWwgbWF0Y2hlck91dCBieSBjb25kZW5zaW5nIHRoaXMgaW50ZXJtZWRpYXRlIGludG8gcG9zdEZpbmRlciBjb250ZXh0c1xuXHRcdFx0XHRcdHRlbXAgPSBbXTtcblx0XHRcdFx0XHRpID0gbWF0Y2hlck91dC5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoICggZWxlbSA9IG1hdGNoZXJPdXRbIGkgXSApICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFJlc3RvcmUgbWF0Y2hlckluIHNpbmNlIGVsZW0gaXMgbm90IHlldCBhIGZpbmFsIG1hdGNoXG5cdFx0XHRcdFx0XHRcdHRlbXAucHVzaCggKCBtYXRjaGVySW5bIGkgXSA9IGVsZW0gKSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCAoIG1hdGNoZXJPdXQgPSBbXSApLCB0ZW1wLCB4bWwgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE1vdmUgbWF0Y2hlZCBlbGVtZW50cyBmcm9tIHNlZWQgdG8gcmVzdWx0cyB0byBrZWVwIHRoZW0gc3luY2hyb25pemVkXG5cdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0aWYgKCAoIGVsZW0gPSBtYXRjaGVyT3V0WyBpIF0gKSAmJlxuXHRcdFx0XHRcdFx0KCB0ZW1wID0gcG9zdEZpbmRlciA/IGluZGV4T2YoIHNlZWQsIGVsZW0gKSA6IHByZU1hcFsgaSBdICkgPiAtMSApIHtcblxuXHRcdFx0XHRcdFx0c2VlZFsgdGVtcCBdID0gISggcmVzdWx0c1sgdGVtcCBdID0gZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gQWRkIGVsZW1lbnRzIHRvIHJlc3VsdHMsIHRocm91Z2ggcG9zdEZpbmRlciBpZiBkZWZpbmVkXG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXJPdXQgPSBjb25kZW5zZShcblx0XHRcdFx0bWF0Y2hlck91dCA9PT0gcmVzdWx0cyA/XG5cdFx0XHRcdFx0bWF0Y2hlck91dC5zcGxpY2UoIHByZWV4aXN0aW5nLCBtYXRjaGVyT3V0Lmxlbmd0aCApIDpcblx0XHRcdFx0XHRtYXRjaGVyT3V0XG5cdFx0XHQpO1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCByZXN1bHRzLCBtYXRjaGVyT3V0LCB4bWwgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIG1hdGNoZXJPdXQgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Ub2tlbnMoIHRva2VucyApIHtcblx0dmFyIGNoZWNrQ29udGV4dCwgbWF0Y2hlciwgaixcblx0XHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxuXHRcdGxlYWRpbmdSZWxhdGl2ZSA9IEV4cHIucmVsYXRpdmVbIHRva2Vuc1sgMCBdLnR5cGUgXSxcblx0XHRpbXBsaWNpdFJlbGF0aXZlID0gbGVhZGluZ1JlbGF0aXZlIHx8IEV4cHIucmVsYXRpdmVbIFwiIFwiIF0sXG5cdFx0aSA9IGxlYWRpbmdSZWxhdGl2ZSA/IDEgOiAwLFxuXG5cdFx0Ly8gVGhlIGZvdW5kYXRpb25hbCBtYXRjaGVyIGVuc3VyZXMgdGhhdCBlbGVtZW50cyBhcmUgcmVhY2hhYmxlIGZyb20gdG9wLWxldmVsIGNvbnRleHQocylcblx0XHRtYXRjaENvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBjaGVja0NvbnRleHQ7XG5cdFx0fSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxuXHRcdG1hdGNoQW55Q29udGV4dCA9IGFkZENvbWJpbmF0b3IoIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGluZGV4T2YoIGNoZWNrQ29udGV4dCwgZWxlbSApID4gLTE7XG5cdFx0fSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxuXHRcdG1hdGNoZXJzID0gWyBmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIHJldCA9ICggIWxlYWRpbmdSZWxhdGl2ZSAmJiAoIHhtbCB8fCBjb250ZXh0ICE9PSBvdXRlcm1vc3RDb250ZXh0ICkgKSB8fCAoXG5cdFx0XHRcdCggY2hlY2tDb250ZXh0ID0gY29udGV4dCApLm5vZGVUeXBlID9cblx0XHRcdFx0XHRtYXRjaENvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApIDpcblx0XHRcdFx0XHRtYXRjaEFueUNvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApICk7XG5cblx0XHRcdC8vIEF2b2lkIGhhbmdpbmcgb250byBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0Y2hlY2tDb250ZXh0ID0gbnVsbDtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fSBdO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKCBtYXRjaGVyID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zWyBpIF0udHlwZSBdICkgKSB7XG5cdFx0XHRtYXRjaGVycyA9IFsgYWRkQ29tYmluYXRvciggZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICksIG1hdGNoZXIgKSBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyID0gRXhwci5maWx0ZXJbIHRva2Vuc1sgaSBdLnR5cGUgXS5hcHBseSggbnVsbCwgdG9rZW5zWyBpIF0ubWF0Y2hlcyApO1xuXG5cdFx0XHQvLyBSZXR1cm4gc3BlY2lhbCB1cG9uIHNlZWluZyBhIHBvc2l0aW9uYWwgbWF0Y2hlclxuXHRcdFx0aWYgKCBtYXRjaGVyWyBleHBhbmRvIF0gKSB7XG5cblx0XHRcdFx0Ly8gRmluZCB0aGUgbmV4dCByZWxhdGl2ZSBvcGVyYXRvciAoaWYgYW55KSBmb3IgcHJvcGVyIGhhbmRsaW5nXG5cdFx0XHRcdGogPSArK2k7XG5cdFx0XHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgdG9rZW5zWyBqIF0udHlwZSBdICkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBzZXRNYXRjaGVyKFxuXHRcdFx0XHRcdGkgPiAxICYmIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLFxuXHRcdFx0XHRcdGkgPiAxICYmIHRvU2VsZWN0b3IoXG5cblx0XHRcdFx0XHQvLyBJZiB0aGUgcHJlY2VkaW5nIHRva2VuIHdhcyBhIGRlc2NlbmRhbnQgY29tYmluYXRvciwgaW5zZXJ0IGFuIGltcGxpY2l0IGFueS1lbGVtZW50IGAqYFxuXHRcdFx0XHRcdHRva2Vuc1xuXHRcdFx0XHRcdFx0LnNsaWNlKCAwLCBpIC0gMSApXG5cdFx0XHRcdFx0XHQuY29uY2F0KCB7IHZhbHVlOiB0b2tlbnNbIGkgLSAyIF0udHlwZSA9PT0gXCIgXCIgPyBcIipcIiA6IFwiXCIgfSApXG5cdFx0XHRcdFx0KS5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksXG5cdFx0XHRcdFx0bWF0Y2hlcixcblx0XHRcdFx0XHRpIDwgaiAmJiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zLnNsaWNlKCBpLCBqICkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIG1hdGNoZXJGcm9tVG9rZW5zKCAoIHRva2VucyA9IHRva2Vucy5zbGljZSggaiApICkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIHRvU2VsZWN0b3IoIHRva2VucyApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0XHRtYXRjaGVycy5wdXNoKCBtYXRjaGVyICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKSB7XG5cdHZhciBieVNldCA9IHNldE1hdGNoZXJzLmxlbmd0aCA+IDAsXG5cdFx0YnlFbGVtZW50ID0gZWxlbWVudE1hdGNoZXJzLmxlbmd0aCA+IDAsXG5cdFx0c3VwZXJNYXRjaGVyID0gZnVuY3Rpb24oIHNlZWQsIGNvbnRleHQsIHhtbCwgcmVzdWx0cywgb3V0ZXJtb3N0ICkge1xuXHRcdFx0dmFyIGVsZW0sIGosIG1hdGNoZXIsXG5cdFx0XHRcdG1hdGNoZWRDb3VudCA9IDAsXG5cdFx0XHRcdGkgPSBcIjBcIixcblx0XHRcdFx0dW5tYXRjaGVkID0gc2VlZCAmJiBbXSxcblx0XHRcdFx0c2V0TWF0Y2hlZCA9IFtdLFxuXHRcdFx0XHRjb250ZXh0QmFja3VwID0gb3V0ZXJtb3N0Q29udGV4dCxcblxuXHRcdFx0XHQvLyBXZSBtdXN0IGFsd2F5cyBoYXZlIGVpdGhlciBzZWVkIGVsZW1lbnRzIG9yIG91dGVybW9zdCBjb250ZXh0XG5cdFx0XHRcdGVsZW1zID0gc2VlZCB8fCBieUVsZW1lbnQgJiYgRXhwci5maW5kWyBcIlRBR1wiIF0oIFwiKlwiLCBvdXRlcm1vc3QgKSxcblxuXHRcdFx0XHQvLyBVc2UgaW50ZWdlciBkaXJydW5zIGlmZiB0aGlzIGlzIHRoZSBvdXRlcm1vc3QgbWF0Y2hlclxuXHRcdFx0XHRkaXJydW5zVW5pcXVlID0gKCBkaXJydW5zICs9IGNvbnRleHRCYWNrdXAgPT0gbnVsbCA/IDEgOiBNYXRoLnJhbmRvbSgpIHx8IDAuMSApLFxuXHRcdFx0XHRsZW4gPSBlbGVtcy5sZW5ndGg7XG5cblx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHRcdFx0XHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0XHRcdFx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0ID09IGRvY3VtZW50IHx8IGNvbnRleHQgfHwgb3V0ZXJtb3N0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgZWxlbWVudHMgcGFzc2luZyBlbGVtZW50TWF0Y2hlcnMgZGlyZWN0bHkgdG8gcmVzdWx0c1xuXHRcdFx0Ly8gU3VwcG9ydDogSUU8OSwgU2FmYXJpXG5cdFx0XHQvLyBUb2xlcmF0ZSBOb2RlTGlzdCBwcm9wZXJ0aWVzIChJRTogXCJsZW5ndGhcIjsgU2FmYXJpOiA8bnVtYmVyPikgbWF0Y2hpbmcgZWxlbWVudHMgYnkgaWRcblx0XHRcdGZvciAoIDsgaSAhPT0gbGVuICYmICggZWxlbSA9IGVsZW1zWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggYnlFbGVtZW50ICYmIGVsZW0gKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0XHRcdFx0XHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0XHRcdFx0XHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdFx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRcdFx0XHRcdGlmICggIWNvbnRleHQgJiYgZWxlbS5vd25lckRvY3VtZW50ICE9IGRvY3VtZW50ICkge1xuXHRcdFx0XHRcdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0XHRcdFx0XHRcdHhtbCA9ICFkb2N1bWVudElzSFRNTDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0d2hpbGUgKCAoIG1hdGNoZXIgPSBlbGVtZW50TWF0Y2hlcnNbIGorKyBdICkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQgfHwgZG9jdW1lbnQsIHhtbCApICkge1xuXHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHJhY2sgdW5tYXRjaGVkIGVsZW1lbnRzIGZvciBzZXQgZmlsdGVyc1xuXHRcdFx0XHRpZiAoIGJ5U2V0ICkge1xuXG5cdFx0XHRcdFx0Ly8gVGhleSB3aWxsIGhhdmUgZ29uZSB0aHJvdWdoIGFsbCBwb3NzaWJsZSBtYXRjaGVyc1xuXHRcdFx0XHRcdGlmICggKCBlbGVtID0gIW1hdGNoZXIgJiYgZWxlbSApICkge1xuXHRcdFx0XHRcdFx0bWF0Y2hlZENvdW50LS07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTGVuZ3RoZW4gdGhlIGFycmF5IGZvciBldmVyeSBlbGVtZW50LCBtYXRjaGVkIG9yIG5vdFxuXHRcdFx0XHRcdGlmICggc2VlZCApIHtcblx0XHRcdFx0XHRcdHVubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGBpYCBpcyBub3cgdGhlIGNvdW50IG9mIGVsZW1lbnRzIHZpc2l0ZWQgYWJvdmUsIGFuZCBhZGRpbmcgaXQgdG8gYG1hdGNoZWRDb3VudGBcblx0XHRcdC8vIG1ha2VzIHRoZSBsYXR0ZXIgbm9ubmVnYXRpdmUuXG5cdFx0XHRtYXRjaGVkQ291bnQgKz0gaTtcblxuXHRcdFx0Ly8gQXBwbHkgc2V0IGZpbHRlcnMgdG8gdW5tYXRjaGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBOT1RFOiBUaGlzIGNhbiBiZSBza2lwcGVkIGlmIHRoZXJlIGFyZSBubyB1bm1hdGNoZWQgZWxlbWVudHMgKGkuZS4sIGBtYXRjaGVkQ291bnRgXG5cdFx0XHQvLyBlcXVhbHMgYGlgKSwgdW5sZXNzIHdlIGRpZG4ndCB2aXNpdCBfYW55XyBlbGVtZW50cyBpbiB0aGUgYWJvdmUgbG9vcCBiZWNhdXNlIHdlIGhhdmVcblx0XHRcdC8vIG5vIGVsZW1lbnQgbWF0Y2hlcnMgYW5kIG5vIHNlZWQuXG5cdFx0XHQvLyBJbmNyZW1lbnRpbmcgYW4gaW5pdGlhbGx5LXN0cmluZyBcIjBcIiBgaWAgYWxsb3dzIGBpYCB0byByZW1haW4gYSBzdHJpbmcgb25seSBpbiB0aGF0XG5cdFx0XHQvLyBjYXNlLCB3aGljaCB3aWxsIHJlc3VsdCBpbiBhIFwiMDBcIiBgbWF0Y2hlZENvdW50YCB0aGF0IGRpZmZlcnMgZnJvbSBgaWAgYnV0IGlzIGFsc29cblx0XHRcdC8vIG51bWVyaWNhbGx5IHplcm8uXG5cdFx0XHRpZiAoIGJ5U2V0ICYmIGkgIT09IG1hdGNoZWRDb3VudCApIHtcblx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdHdoaWxlICggKCBtYXRjaGVyID0gc2V0TWF0Y2hlcnNbIGorKyBdICkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlciggdW5tYXRjaGVkLCBzZXRNYXRjaGVkLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggc2VlZCApIHtcblxuXHRcdFx0XHRcdC8vIFJlaW50ZWdyYXRlIGVsZW1lbnQgbWF0Y2hlcyB0byBlbGltaW5hdGUgdGhlIG5lZWQgZm9yIHNvcnRpbmdcblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRDb3VudCA+IDAgKSB7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCAhKCB1bm1hdGNoZWRbIGkgXSB8fCBzZXRNYXRjaGVkWyBpIF0gKSApIHtcblx0XHRcdFx0XHRcdFx0XHRzZXRNYXRjaGVkWyBpIF0gPSBwb3AuY2FsbCggcmVzdWx0cyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRGlzY2FyZCBpbmRleCBwbGFjZWhvbGRlciB2YWx1ZXMgdG8gZ2V0IG9ubHkgYWN0dWFsIG1hdGNoZXNcblx0XHRcdFx0XHRzZXRNYXRjaGVkID0gY29uZGVuc2UoIHNldE1hdGNoZWQgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFkZCBtYXRjaGVzIHRvIHJlc3VsdHNcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2V0TWF0Y2hlZCApO1xuXG5cdFx0XHRcdC8vIFNlZWRsZXNzIHNldCBtYXRjaGVzIHN1Y2NlZWRpbmcgbXVsdGlwbGUgc3VjY2Vzc2Z1bCBtYXRjaGVycyBzdGlwdWxhdGUgc29ydGluZ1xuXHRcdFx0XHRpZiAoIG91dGVybW9zdCAmJiAhc2VlZCAmJiBzZXRNYXRjaGVkLmxlbmd0aCA+IDAgJiZcblx0XHRcdFx0XHQoIG1hdGNoZWRDb3VudCArIHNldE1hdGNoZXJzLmxlbmd0aCApID4gMSApIHtcblxuXHRcdFx0XHRcdFNpenpsZS51bmlxdWVTb3J0KCByZXN1bHRzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gT3ZlcnJpZGUgbWFuaXB1bGF0aW9uIG9mIGdsb2JhbHMgYnkgbmVzdGVkIG1hdGNoZXJzXG5cdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0QmFja3VwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdW5tYXRjaGVkO1xuXHRcdH07XG5cblx0cmV0dXJuIGJ5U2V0ID9cblx0XHRtYXJrRnVuY3Rpb24oIHN1cGVyTWF0Y2hlciApIDpcblx0XHRzdXBlck1hdGNoZXI7XG59XG5cbmNvbXBpbGUgPSBTaXp6bGUuY29tcGlsZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgbWF0Y2ggLyogSW50ZXJuYWwgVXNlIE9ubHkgKi8gKSB7XG5cdHZhciBpLFxuXHRcdHNldE1hdGNoZXJzID0gW10sXG5cdFx0ZWxlbWVudE1hdGNoZXJzID0gW10sXG5cdFx0Y2FjaGVkID0gY29tcGlsZXJDYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdO1xuXG5cdGlmICggIWNhY2hlZCApIHtcblxuXHRcdC8vIEdlbmVyYXRlIGEgZnVuY3Rpb24gb2YgcmVjdXJzaXZlIGZ1bmN0aW9ucyB0aGF0IGNhbiBiZSB1c2VkIHRvIGNoZWNrIGVhY2ggZWxlbWVudFxuXHRcdGlmICggIW1hdGNoICkge1xuXHRcdFx0bWF0Y2ggPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcblx0XHR9XG5cdFx0aSA9IG1hdGNoLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGNhY2hlZCA9IG1hdGNoZXJGcm9tVG9rZW5zKCBtYXRjaFsgaSBdICk7XG5cdFx0XHRpZiAoIGNhY2hlZFsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRzZXRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1lbnRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWNoZSB0aGUgY29tcGlsZWQgZnVuY3Rpb25cblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlKFxuXHRcdFx0c2VsZWN0b3IsXG5cdFx0XHRtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKVxuXHRcdCk7XG5cblx0XHQvLyBTYXZlIHNlbGVjdG9yIGFuZCB0b2tlbml6YXRpb25cblx0XHRjYWNoZWQuc2VsZWN0b3IgPSBzZWxlY3Rvcjtcblx0fVxuXHRyZXR1cm4gY2FjaGVkO1xufTtcblxuLyoqXG4gKiBBIGxvdy1sZXZlbCBzZWxlY3Rpb24gZnVuY3Rpb24gdGhhdCB3b3JrcyB3aXRoIFNpenpsZSdzIGNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb25zXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gc2VsZWN0b3IgQSBzZWxlY3RvciBvciBhIHByZS1jb21waWxlZFxuICogIHNlbGVjdG9yIGZ1bmN0aW9uIGJ1aWx0IHdpdGggU2l6emxlLmNvbXBpbGVcbiAqIEBwYXJhbSB7RWxlbWVudH0gY29udGV4dFxuICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdHNdXG4gKiBAcGFyYW0ge0FycmF5fSBbc2VlZF0gQSBzZXQgb2YgZWxlbWVudHMgdG8gbWF0Y2ggYWdhaW5zdFxuICovXG5zZWxlY3QgPSBTaXp6bGUuc2VsZWN0ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuXHR2YXIgaSwgdG9rZW5zLCB0b2tlbiwgdHlwZSwgZmluZCxcblx0XHRjb21waWxlZCA9IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICYmIHNlbGVjdG9yLFxuXHRcdG1hdGNoID0gIXNlZWQgJiYgdG9rZW5pemUoICggc2VsZWN0b3IgPSBjb21waWxlZC5zZWxlY3RvciB8fCBzZWxlY3RvciApICk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gVHJ5IHRvIG1pbmltaXplIG9wZXJhdGlvbnMgaWYgdGhlcmUgaXMgb25seSBvbmUgc2VsZWN0b3IgaW4gdGhlIGxpc3QgYW5kIG5vIHNlZWRcblx0Ly8gKHRoZSBsYXR0ZXIgb2Ygd2hpY2ggZ3VhcmFudGVlcyB1cyBjb250ZXh0KVxuXHRpZiAoIG1hdGNoLmxlbmd0aCA9PT0gMSApIHtcblxuXHRcdC8vIFJlZHVjZSBjb250ZXh0IGlmIHRoZSBsZWFkaW5nIGNvbXBvdW5kIHNlbGVjdG9yIGlzIGFuIElEXG5cdFx0dG9rZW5zID0gbWF0Y2hbIDAgXSA9IG1hdGNoWyAwIF0uc2xpY2UoIDAgKTtcblx0XHRpZiAoIHRva2Vucy5sZW5ndGggPiAyICYmICggdG9rZW4gPSB0b2tlbnNbIDAgXSApLnR5cGUgPT09IFwiSURcIiAmJlxuXHRcdFx0Y29udGV4dC5ub2RlVHlwZSA9PT0gOSAmJiBkb2N1bWVudElzSFRNTCAmJiBFeHByLnJlbGF0aXZlWyB0b2tlbnNbIDEgXS50eXBlIF0gKSB7XG5cblx0XHRcdGNvbnRleHQgPSAoIEV4cHIuZmluZFsgXCJJRFwiIF0oIHRva2VuLm1hdGNoZXNbIDAgXVxuXHRcdFx0XHQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKSwgY29udGV4dCApIHx8IFtdIClbIDAgXTtcblx0XHRcdGlmICggIWNvbnRleHQgKSB7XG5cdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXG5cdFx0XHQvLyBQcmVjb21waWxlZCBtYXRjaGVycyB3aWxsIHN0aWxsIHZlcmlmeSBhbmNlc3RyeSwgc28gc3RlcCB1cCBhIGxldmVsXG5cdFx0XHR9IGVsc2UgaWYgKCBjb21waWxlZCApIHtcblx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQucGFyZW50Tm9kZTtcblx0XHRcdH1cblxuXHRcdFx0c2VsZWN0b3IgPSBzZWxlY3Rvci5zbGljZSggdG9rZW5zLnNoaWZ0KCkudmFsdWUubGVuZ3RoICk7XG5cdFx0fVxuXG5cdFx0Ly8gRmV0Y2ggYSBzZWVkIHNldCBmb3IgcmlnaHQtdG8tbGVmdCBtYXRjaGluZ1xuXHRcdGkgPSBtYXRjaEV4cHJbIFwibmVlZHNDb250ZXh0XCIgXS50ZXN0KCBzZWxlY3RvciApID8gMCA6IHRva2Vucy5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0b2tlbiA9IHRva2Vuc1sgaSBdO1xuXG5cdFx0XHQvLyBBYm9ydCBpZiB3ZSBoaXQgYSBjb21iaW5hdG9yXG5cdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbICggdHlwZSA9IHRva2VuLnR5cGUgKSBdICkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggKCBmaW5kID0gRXhwci5maW5kWyB0eXBlIF0gKSApIHtcblxuXHRcdFx0XHQvLyBTZWFyY2gsIGV4cGFuZGluZyBjb250ZXh0IGZvciBsZWFkaW5nIHNpYmxpbmcgY29tYmluYXRvcnNcblx0XHRcdFx0aWYgKCAoIHNlZWQgPSBmaW5kKFxuXHRcdFx0XHRcdHRva2VuLm1hdGNoZXNbIDAgXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLFxuXHRcdFx0XHRcdHJzaWJsaW5nLnRlc3QoIHRva2Vuc1sgMCBdLnR5cGUgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHxcblx0XHRcdFx0XHRcdGNvbnRleHRcblx0XHRcdFx0KSApICkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgc2VlZCBpcyBlbXB0eSBvciBubyB0b2tlbnMgcmVtYWluLCB3ZSBjYW4gcmV0dXJuIGVhcmx5XG5cdFx0XHRcdFx0dG9rZW5zLnNwbGljZSggaSwgMSApO1xuXHRcdFx0XHRcdHNlbGVjdG9yID0gc2VlZC5sZW5ndGggJiYgdG9TZWxlY3RvciggdG9rZW5zICk7XG5cdFx0XHRcdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBzZWVkICk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENvbXBpbGUgYW5kIGV4ZWN1dGUgYSBmaWx0ZXJpbmcgZnVuY3Rpb24gaWYgb25lIGlzIG5vdCBwcm92aWRlZFxuXHQvLyBQcm92aWRlIGBtYXRjaGAgdG8gYXZvaWQgcmV0b2tlbml6YXRpb24gaWYgd2UgbW9kaWZpZWQgdGhlIHNlbGVjdG9yIGFib3ZlXG5cdCggY29tcGlsZWQgfHwgY29tcGlsZSggc2VsZWN0b3IsIG1hdGNoICkgKShcblx0XHRzZWVkLFxuXHRcdGNvbnRleHQsXG5cdFx0IWRvY3VtZW50SXNIVE1MLFxuXHRcdHJlc3VsdHMsXG5cdFx0IWNvbnRleHQgfHwgcnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHwgY29udGV4dFxuXHQpO1xuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbi8vIE9uZS10aW1lIGFzc2lnbm1lbnRzXG5cbi8vIFNvcnQgc3RhYmlsaXR5XG5zdXBwb3J0LnNvcnRTdGFibGUgPSBleHBhbmRvLnNwbGl0KCBcIlwiICkuc29ydCggc29ydE9yZGVyICkuam9pbiggXCJcIiApID09PSBleHBhbmRvO1xuXG4vLyBTdXBwb3J0OiBDaHJvbWUgMTQtMzUrXG4vLyBBbHdheXMgYXNzdW1lIGR1cGxpY2F0ZXMgaWYgdGhleSBhcmVuJ3QgcGFzc2VkIHRvIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9uXG5zdXBwb3J0LmRldGVjdER1cGxpY2F0ZXMgPSAhIWhhc0R1cGxpY2F0ZTtcblxuLy8gSW5pdGlhbGl6ZSBhZ2FpbnN0IHRoZSBkZWZhdWx0IGRvY3VtZW50XG5zZXREb2N1bWVudCgpO1xuXG4vLyBTdXBwb3J0OiBXZWJraXQ8NTM3LjMyIC0gU2FmYXJpIDYuMC4zL0Nocm9tZSAyNSAoZml4ZWQgaW4gQ2hyb21lIDI3KVxuLy8gRGV0YWNoZWQgbm9kZXMgY29uZm91bmRpbmdseSBmb2xsb3cgKmVhY2ggb3RoZXIqXG5zdXBwb3J0LnNvcnREZXRhY2hlZCA9IGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXG5cdC8vIFNob3VsZCByZXR1cm4gMSwgYnV0IHJldHVybnMgNCAoZm9sbG93aW5nKVxuXHRyZXR1cm4gZWwuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZmllbGRzZXRcIiApICkgJiAxO1xufSApO1xuXG4vLyBTdXBwb3J0OiBJRTw4XG4vLyBQcmV2ZW50IGF0dHJpYnV0ZS9wcm9wZXJ0eSBcImludGVycG9sYXRpb25cIlxuLy8gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzNjQyOSUyOFZTLjg1JTI5LmFzcHhcbmlmICggIWFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXHRlbC5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JyMnPjwvYT5cIjtcblx0cmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKCBcImhyZWZcIiApID09PSBcIiNcIjtcbn0gKSApIHtcblx0YWRkSGFuZGxlKCBcInR5cGV8aHJlZnxoZWlnaHR8d2lkdGhcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lLCBuYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwidHlwZVwiID8gMSA6IDIgKTtcblx0XHR9XG5cdH0gKTtcbn1cblxuLy8gU3VwcG9ydDogSUU8OVxuLy8gVXNlIGRlZmF1bHRWYWx1ZSBpbiBwbGFjZSBvZiBnZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKVxuaWYgKCAhc3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblx0ZWwuaW5uZXJIVE1MID0gXCI8aW5wdXQvPlwiO1xuXHRlbC5maXJzdENoaWxkLnNldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiLCBcIlwiICk7XG5cdHJldHVybiBlbC5maXJzdENoaWxkLmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IFwiXCI7XG59ICkgKSB7XG5cdGFkZEhhbmRsZSggXCJ2YWx1ZVwiLCBmdW5jdGlvbiggZWxlbSwgX25hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGVmYXVsdFZhbHVlO1xuXHRcdH1cblx0fSApO1xufVxuXG4vLyBTdXBwb3J0OiBJRTw5XG4vLyBVc2UgZ2V0QXR0cmlidXRlTm9kZSB0byBmZXRjaCBib29sZWFucyB3aGVuIGdldEF0dHJpYnV0ZSBsaWVzXG5pZiAoICFhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblx0cmV0dXJuIGVsLmdldEF0dHJpYnV0ZSggXCJkaXNhYmxlZFwiICkgPT0gbnVsbDtcbn0gKSApIHtcblx0YWRkSGFuZGxlKCBib29sZWFucywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdHZhciB2YWw7XG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbVsgbmFtZSBdID09PSB0cnVlID8gbmFtZS50b0xvd2VyQ2FzZSgpIDpcblx0XHRcdFx0KCB2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIG5hbWUgKSApICYmIHZhbC5zcGVjaWZpZWQgP1xuXHRcdFx0XHRcdHZhbC52YWx1ZSA6XG5cdFx0XHRcdFx0bnVsbDtcblx0XHR9XG5cdH0gKTtcbn1cblxucmV0dXJuIFNpenpsZTtcblxufSApKCB3aW5kb3cgKTtcblxuXG5cbmpRdWVyeS5maW5kID0gU2l6emxlO1xualF1ZXJ5LmV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzO1xuXG4vLyBEZXByZWNhdGVkXG5qUXVlcnkuZXhwclsgXCI6XCIgXSA9IGpRdWVyeS5leHByLnBzZXVkb3M7XG5qUXVlcnkudW5pcXVlU29ydCA9IGpRdWVyeS51bmlxdWUgPSBTaXp6bGUudW5pcXVlU29ydDtcbmpRdWVyeS50ZXh0ID0gU2l6emxlLmdldFRleHQ7XG5qUXVlcnkuaXNYTUxEb2MgPSBTaXp6bGUuaXNYTUw7XG5qUXVlcnkuY29udGFpbnMgPSBTaXp6bGUuY29udGFpbnM7XG5qUXVlcnkuZXNjYXBlU2VsZWN0b3IgPSBTaXp6bGUuZXNjYXBlO1xuXG5cblxuXG52YXIgZGlyID0gZnVuY3Rpb24oIGVsZW0sIGRpciwgdW50aWwgKSB7XG5cdHZhciBtYXRjaGVkID0gW10sXG5cdFx0dHJ1bmNhdGUgPSB1bnRpbCAhPT0gdW5kZWZpbmVkO1xuXG5cdHdoaWxlICggKCBlbGVtID0gZWxlbVsgZGlyIF0gKSAmJiBlbGVtLm5vZGVUeXBlICE9PSA5ICkge1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGlmICggdHJ1bmNhdGUgJiYgalF1ZXJ5KCBlbGVtICkuaXMoIHVudGlsICkgKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBtYXRjaGVkO1xufTtcblxuXG52YXIgc2libGluZ3MgPSBmdW5jdGlvbiggbiwgZWxlbSApIHtcblx0dmFyIG1hdGNoZWQgPSBbXTtcblxuXHRmb3IgKCA7IG47IG4gPSBuLm5leHRTaWJsaW5nICkge1xuXHRcdGlmICggbi5ub2RlVHlwZSA9PT0gMSAmJiBuICE9PSBlbGVtICkge1xuXHRcdFx0bWF0Y2hlZC5wdXNoKCBuICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG1hdGNoZWQ7XG59O1xuXG5cbnZhciBybmVlZHNDb250ZXh0ID0galF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0O1xuXG5cblxuZnVuY3Rpb24gbm9kZU5hbWUoIGVsZW0sIG5hbWUgKSB7XG5cbiAgcmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cbn07XG52YXIgcnNpbmdsZVRhZyA9ICggL148KFthLXpdW15cXC9cXDA+OlxceDIwXFx0XFxyXFxuXFxmXSopW1xceDIwXFx0XFxyXFxuXFxmXSpcXC8/Pig/OjxcXC9cXDE+fCkkL2kgKTtcblxuXG5cbi8vIEltcGxlbWVudCB0aGUgaWRlbnRpY2FsIGZ1bmN0aW9uYWxpdHkgZm9yIGZpbHRlciBhbmQgbm90XG5mdW5jdGlvbiB3aW5ub3coIGVsZW1lbnRzLCBxdWFsaWZpZXIsIG5vdCApIHtcblx0aWYgKCBpc0Z1bmN0aW9uKCBxdWFsaWZpZXIgKSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiAhIXF1YWxpZmllci5jYWxsKCBlbGVtLCBpLCBlbGVtICkgIT09IG5vdDtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBTaW5nbGUgZWxlbWVudFxuXHRpZiAoIHF1YWxpZmllci5ub2RlVHlwZSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoIGVsZW0gPT09IHF1YWxpZmllciApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gQXJyYXlsaWtlIG9mIGVsZW1lbnRzIChqUXVlcnksIGFyZ3VtZW50cywgQXJyYXkpXG5cdGlmICggdHlwZW9mIHF1YWxpZmllciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoIGluZGV4T2YuY2FsbCggcXVhbGlmaWVyLCBlbGVtICkgPiAtMSApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gRmlsdGVyZWQgZGlyZWN0bHkgZm9yIGJvdGggc2ltcGxlIGFuZCBjb21wbGV4IHNlbGVjdG9yc1xuXHRyZXR1cm4galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cywgbm90ICk7XG59XG5cbmpRdWVyeS5maWx0ZXIgPSBmdW5jdGlvbiggZXhwciwgZWxlbXMsIG5vdCApIHtcblx0dmFyIGVsZW0gPSBlbGVtc1sgMCBdO1xuXG5cdGlmICggbm90ICkge1xuXHRcdGV4cHIgPSBcIjpub3QoXCIgKyBleHByICsgXCIpXCI7XG5cdH1cblxuXHRpZiAoIGVsZW1zLmxlbmd0aCA9PT0gMSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdHJldHVybiBqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGVsZW0sIGV4cHIgKSA/IFsgZWxlbSBdIDogW107XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5LmZpbmQubWF0Y2hlcyggZXhwciwgalF1ZXJ5LmdyZXAoIGVsZW1zLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlVHlwZSA9PT0gMTtcblx0fSApICk7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGZpbmQ6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgaSwgcmV0LFxuXHRcdFx0bGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRzZWxmID0gdGhpcztcblxuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkoIHNlbGVjdG9yICkuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggc2VsZlsgaSBdLCB0aGlzICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gKSApO1xuXHRcdH1cblxuXHRcdHJldCA9IHRoaXMucHVzaFN0YWNrKCBbXSApO1xuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGpRdWVyeS5maW5kKCBzZWxlY3Rvciwgc2VsZlsgaSBdLCByZXQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbGVuID4gMSA/IGpRdWVyeS51bmlxdWVTb3J0KCByZXQgKSA6IHJldDtcblx0fSxcblx0ZmlsdGVyOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3coIHRoaXMsIHNlbGVjdG9yIHx8IFtdLCBmYWxzZSApICk7XG5cdH0sXG5cdG5vdDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgdHJ1ZSApICk7XG5cdH0sXG5cdGlzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuICEhd2lubm93KFxuXHRcdFx0dGhpcyxcblxuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhIHBvc2l0aW9uYWwvcmVsYXRpdmUgc2VsZWN0b3IsIGNoZWNrIG1lbWJlcnNoaXAgaW4gdGhlIHJldHVybmVkIHNldFxuXHRcdFx0Ly8gc28gJChcInA6Zmlyc3RcIikuaXMoXCJwOmxhc3RcIikgd29uJ3QgcmV0dXJuIHRydWUgZm9yIGEgZG9jIHdpdGggdHdvIFwicFwiLlxuXHRcdFx0dHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICYmIHJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSA/XG5cdFx0XHRcdGpRdWVyeSggc2VsZWN0b3IgKSA6XG5cdFx0XHRcdHNlbGVjdG9yIHx8IFtdLFxuXHRcdFx0ZmFsc2Vcblx0XHQpLmxlbmd0aDtcblx0fVxufSApO1xuXG5cbi8vIEluaXRpYWxpemUgYSBqUXVlcnkgb2JqZWN0XG5cblxuLy8gQSBjZW50cmFsIHJlZmVyZW5jZSB0byB0aGUgcm9vdCBqUXVlcnkoZG9jdW1lbnQpXG52YXIgcm9vdGpRdWVyeSxcblxuXHQvLyBBIHNpbXBsZSB3YXkgdG8gY2hlY2sgZm9yIEhUTUwgc3RyaW5nc1xuXHQvLyBQcmlvcml0aXplICNpZCBvdmVyIDx0YWc+IHRvIGF2b2lkIFhTUyB2aWEgbG9jYXRpb24uaGFzaCAoIzk1MjEpXG5cdC8vIFN0cmljdCBIVE1MIHJlY29nbml0aW9uICgjMTEyOTA6IG11c3Qgc3RhcnQgd2l0aCA8KVxuXHQvLyBTaG9ydGN1dCBzaW1wbGUgI2lkIGNhc2UgZm9yIHNwZWVkXG5cdHJxdWlja0V4cHIgPSAvXig/OlxccyooPFtcXHdcXFddKz4pW14+XSp8IyhbXFx3LV0rKSkkLyxcblxuXHRpbml0ID0galF1ZXJ5LmZuLmluaXQgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJvb3QgKSB7XG5cdFx0dmFyIG1hdGNoLCBlbGVtO1xuXG5cdFx0Ly8gSEFORExFOiAkKFwiXCIpLCAkKG51bGwpLCAkKHVuZGVmaW5lZCksICQoZmFsc2UpXG5cdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQvLyBNZXRob2QgaW5pdCgpIGFjY2VwdHMgYW4gYWx0ZXJuYXRlIHJvb3RqUXVlcnlcblx0XHQvLyBzbyBtaWdyYXRlIGNhbiBzdXBwb3J0IGpRdWVyeS5zdWIgKGdoLTIxMDEpXG5cdFx0cm9vdCA9IHJvb3QgfHwgcm9vdGpRdWVyeTtcblxuXHRcdC8vIEhhbmRsZSBIVE1MIHN0cmluZ3Ncblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGlmICggc2VsZWN0b3JbIDAgXSA9PT0gXCI8XCIgJiZcblx0XHRcdFx0c2VsZWN0b3JbIHNlbGVjdG9yLmxlbmd0aCAtIDEgXSA9PT0gXCI+XCIgJiZcblx0XHRcdFx0c2VsZWN0b3IubGVuZ3RoID49IDMgKSB7XG5cblx0XHRcdFx0Ly8gQXNzdW1lIHRoYXQgc3RyaW5ncyB0aGF0IHN0YXJ0IGFuZCBlbmQgd2l0aCA8PiBhcmUgSFRNTCBhbmQgc2tpcCB0aGUgcmVnZXggY2hlY2tcblx0XHRcdFx0bWF0Y2ggPSBbIG51bGwsIHNlbGVjdG9yLCBudWxsIF07XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYXRjaCBodG1sIG9yIG1ha2Ugc3VyZSBubyBjb250ZXh0IGlzIHNwZWNpZmllZCBmb3IgI2lkXG5cdFx0XHRpZiAoIG1hdGNoICYmICggbWF0Y2hbIDEgXSB8fCAhY29udGV4dCApICkge1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJChodG1sKSAtPiAkKGFycmF5KVxuXHRcdFx0XHRpZiAoIG1hdGNoWyAxIF0gKSB7XG5cdFx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQgaW5zdGFuY2VvZiBqUXVlcnkgPyBjb250ZXh0WyAwIF0gOiBjb250ZXh0O1xuXG5cdFx0XHRcdFx0Ly8gT3B0aW9uIHRvIHJ1biBzY3JpcHRzIGlzIHRydWUgZm9yIGJhY2stY29tcGF0XG5cdFx0XHRcdFx0Ly8gSW50ZW50aW9uYWxseSBsZXQgdGhlIGVycm9yIGJlIHRocm93biBpZiBwYXJzZUhUTUwgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHRoaXMsIGpRdWVyeS5wYXJzZUhUTUwoXG5cdFx0XHRcdFx0XHRtYXRjaFsgMSBdLFxuXHRcdFx0XHRcdFx0Y29udGV4dCAmJiBjb250ZXh0Lm5vZGVUeXBlID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBkb2N1bWVudCxcblx0XHRcdFx0XHRcdHRydWVcblx0XHRcdFx0XHQpICk7XG5cblx0XHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCwgcHJvcHMpXG5cdFx0XHRcdFx0aWYgKCByc2luZ2xlVGFnLnRlc3QoIG1hdGNoWyAxIF0gKSAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdCggY29udGV4dCApICkge1xuXHRcdFx0XHRcdFx0Zm9yICggbWF0Y2ggaW4gY29udGV4dCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBQcm9wZXJ0aWVzIG9mIGNvbnRleHQgYXJlIGNhbGxlZCBhcyBtZXRob2RzIGlmIHBvc3NpYmxlXG5cdFx0XHRcdFx0XHRcdGlmICggaXNGdW5jdGlvbiggdGhpc1sgbWF0Y2ggXSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXNbIG1hdGNoIF0oIGNvbnRleHRbIG1hdGNoIF0gKTtcblxuXHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgb3RoZXJ3aXNlIHNldCBhcyBhdHRyaWJ1dGVzXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5hdHRyKCBtYXRjaCwgY29udGV4dFsgbWF0Y2ggXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKCNpZClcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIG1hdGNoWyAyIF0gKTtcblxuXHRcdFx0XHRcdGlmICggZWxlbSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSW5qZWN0IHRoZSBlbGVtZW50IGRpcmVjdGx5IGludG8gdGhlIGpRdWVyeSBvYmplY3Rcblx0XHRcdFx0XHRcdHRoaXNbIDAgXSA9IGVsZW07XG5cdFx0XHRcdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCAkKC4uLikpXG5cdFx0XHR9IGVsc2UgaWYgKCAhY29udGV4dCB8fCBjb250ZXh0LmpxdWVyeSApIHtcblx0XHRcdFx0cmV0dXJuICggY29udGV4dCB8fCByb290ICkuZmluZCggc2VsZWN0b3IgKTtcblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsIGNvbnRleHQpXG5cdFx0XHQvLyAod2hpY2ggaXMganVzdCBlcXVpdmFsZW50IHRvOiAkKGNvbnRleHQpLmZpbmQoZXhwcilcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKCBjb250ZXh0ICkuZmluZCggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdC8vIEhBTkRMRTogJChET01FbGVtZW50KVxuXHRcdH0gZWxzZSBpZiAoIHNlbGVjdG9yLm5vZGVUeXBlICkge1xuXHRcdFx0dGhpc1sgMCBdID0gc2VsZWN0b3I7XG5cdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdC8vIEhBTkRMRTogJChmdW5jdGlvbilcblx0XHQvLyBTaG9ydGN1dCBmb3IgZG9jdW1lbnQgcmVhZHlcblx0XHR9IGVsc2UgaWYgKCBpc0Z1bmN0aW9uKCBzZWxlY3RvciApICkge1xuXHRcdFx0cmV0dXJuIHJvb3QucmVhZHkgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHJvb3QucmVhZHkoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHRcdC8vIEV4ZWN1dGUgaW1tZWRpYXRlbHkgaWYgcmVhZHkgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0c2VsZWN0b3IoIGpRdWVyeSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkubWFrZUFycmF5KCBzZWxlY3RvciwgdGhpcyApO1xuXHR9O1xuXG4vLyBHaXZlIHRoZSBpbml0IGZ1bmN0aW9uIHRoZSBqUXVlcnkgcHJvdG90eXBlIGZvciBsYXRlciBpbnN0YW50aWF0aW9uXG5pbml0LnByb3RvdHlwZSA9IGpRdWVyeS5mbjtcblxuLy8gSW5pdGlhbGl6ZSBjZW50cmFsIHJlZmVyZW5jZVxucm9vdGpRdWVyeSA9IGpRdWVyeSggZG9jdW1lbnQgKTtcblxuXG52YXIgcnBhcmVudHNwcmV2ID0gL14oPzpwYXJlbnRzfHByZXYoPzpVbnRpbHxBbGwpKS8sXG5cblx0Ly8gTWV0aG9kcyBndWFyYW50ZWVkIHRvIHByb2R1Y2UgYSB1bmlxdWUgc2V0IHdoZW4gc3RhcnRpbmcgZnJvbSBhIHVuaXF1ZSBzZXRcblx0Z3VhcmFudGVlZFVuaXF1ZSA9IHtcblx0XHRjaGlsZHJlbjogdHJ1ZSxcblx0XHRjb250ZW50czogdHJ1ZSxcblx0XHRuZXh0OiB0cnVlLFxuXHRcdHByZXY6IHRydWVcblx0fTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRoYXM6IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XG5cdFx0dmFyIHRhcmdldHMgPSBqUXVlcnkoIHRhcmdldCwgdGhpcyApLFxuXHRcdFx0bCA9IHRhcmdldHMubGVuZ3RoO1xuXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHRoaXMsIHRhcmdldHNbIGkgXSApICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGNsb3Nlc3Q6IGZ1bmN0aW9uKCBzZWxlY3RvcnMsIGNvbnRleHQgKSB7XG5cdFx0dmFyIGN1cixcblx0XHRcdGkgPSAwLFxuXHRcdFx0bCA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0bWF0Y2hlZCA9IFtdLFxuXHRcdFx0dGFyZ2V0cyA9IHR5cGVvZiBzZWxlY3RvcnMgIT09IFwic3RyaW5nXCIgJiYgalF1ZXJ5KCBzZWxlY3RvcnMgKTtcblxuXHRcdC8vIFBvc2l0aW9uYWwgc2VsZWN0b3JzIG5ldmVyIG1hdGNoLCBzaW5jZSB0aGVyZSdzIG5vIF9zZWxlY3Rpb25fIGNvbnRleHRcblx0XHRpZiAoICFybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9ycyApICkge1xuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRmb3IgKCBjdXIgPSB0aGlzWyBpIF07IGN1ciAmJiBjdXIgIT09IGNvbnRleHQ7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXG5cdFx0XHRcdFx0Ly8gQWx3YXlzIHNraXAgZG9jdW1lbnQgZnJhZ21lbnRzXG5cdFx0XHRcdFx0aWYgKCBjdXIubm9kZVR5cGUgPCAxMSAmJiAoIHRhcmdldHMgP1xuXHRcdFx0XHRcdFx0dGFyZ2V0cy5pbmRleCggY3VyICkgPiAtMSA6XG5cblx0XHRcdFx0XHRcdC8vIERvbid0IHBhc3Mgbm9uLWVsZW1lbnRzIHRvIFNpenpsZVxuXHRcdFx0XHRcdFx0Y3VyLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggY3VyLCBzZWxlY3RvcnMgKSApICkge1xuXG5cdFx0XHRcdFx0XHRtYXRjaGVkLnB1c2goIGN1ciApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkLmxlbmd0aCA+IDEgPyBqUXVlcnkudW5pcXVlU29ydCggbWF0Y2hlZCApIDogbWF0Y2hlZCApO1xuXHR9LFxuXG5cdC8vIERldGVybWluZSB0aGUgcG9zaXRpb24gb2YgYW4gZWxlbWVudCB3aXRoaW4gdGhlIHNldFxuXHRpbmRleDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBObyBhcmd1bWVudCwgcmV0dXJuIGluZGV4IGluIHBhcmVudFxuXHRcdGlmICggIWVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCB0aGlzWyAwIF0gJiYgdGhpc1sgMCBdLnBhcmVudE5vZGUgKSA/IHRoaXMuZmlyc3QoKS5wcmV2QWxsKCkubGVuZ3RoIDogLTE7XG5cdFx0fVxuXG5cdFx0Ly8gSW5kZXggaW4gc2VsZWN0b3Jcblx0XHRpZiAoIHR5cGVvZiBlbGVtID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGluZGV4T2YuY2FsbCggalF1ZXJ5KCBlbGVtICksIHRoaXNbIDAgXSApO1xuXHRcdH1cblxuXHRcdC8vIExvY2F0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGRlc2lyZWQgZWxlbWVudFxuXHRcdHJldHVybiBpbmRleE9mLmNhbGwoIHRoaXMsXG5cblx0XHRcdC8vIElmIGl0IHJlY2VpdmVzIGEgalF1ZXJ5IG9iamVjdCwgdGhlIGZpcnN0IGVsZW1lbnQgaXMgdXNlZFxuXHRcdFx0ZWxlbS5qcXVlcnkgPyBlbGVtWyAwIF0gOiBlbGVtXG5cdFx0KTtcblx0fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soXG5cdFx0XHRqUXVlcnkudW5pcXVlU29ydChcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLmdldCgpLCBqUXVlcnkoIHNlbGVjdG9yLCBjb250ZXh0ICkgKVxuXHRcdFx0KVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkQmFjazogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLmFkZCggc2VsZWN0b3IgPT0gbnVsbCA/XG5cdFx0XHR0aGlzLnByZXZPYmplY3QgOiB0aGlzLnByZXZPYmplY3QuZmlsdGVyKCBzZWxlY3RvciApXG5cdFx0KTtcblx0fVxufSApO1xuXG5mdW5jdGlvbiBzaWJsaW5nKCBjdXIsIGRpciApIHtcblx0d2hpbGUgKCAoIGN1ciA9IGN1clsgZGlyIF0gKSAmJiBjdXIubm9kZVR5cGUgIT09IDEgKSB7fVxuXHRyZXR1cm4gY3VyO1xufVxuXG5qUXVlcnkuZWFjaCgge1xuXHRwYXJlbnQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0cmV0dXJuIHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgIT09IDExID8gcGFyZW50IDogbnVsbDtcblx0fSxcblx0cGFyZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIgKTtcblx0fSxcblx0cGFyZW50c1VudGlsOiBmdW5jdGlvbiggZWxlbSwgX2ksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiLCB1bnRpbCApO1xuXHR9LFxuXHRuZXh0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZyggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXY6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuXHR9LFxuXHRwcmV2QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRVbnRpbDogZnVuY3Rpb24oIGVsZW0sIF9pLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIsIHVudGlsICk7XG5cdH0sXG5cdHByZXZVbnRpbDogZnVuY3Rpb24oIGVsZW0sIF9pLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRzaWJsaW5nczogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmdzKCAoIGVsZW0ucGFyZW50Tm9kZSB8fCB7fSApLmZpcnN0Q2hpbGQsIGVsZW0gKTtcblx0fSxcblx0Y2hpbGRyZW46IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5ncyggZWxlbS5maXJzdENoaWxkICk7XG5cdH0sXG5cdGNvbnRlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRpZiAoIGVsZW0uY29udGVudERvY3VtZW50ICE9IG51bGwgJiZcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgMTErXG5cdFx0XHQvLyA8b2JqZWN0PiBlbGVtZW50cyB3aXRoIG5vIGBkYXRhYCBhdHRyaWJ1dGUgaGFzIGFuIG9iamVjdFxuXHRcdFx0Ly8gYGNvbnRlbnREb2N1bWVudGAgd2l0aCBhIGBudWxsYCBwcm90b3R5cGUuXG5cdFx0XHRnZXRQcm90byggZWxlbS5jb250ZW50RG9jdW1lbnQgKSApIHtcblxuXHRcdFx0cmV0dXJuIGVsZW0uY29udGVudERvY3VtZW50O1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5LCBpT1MgNyBvbmx5LCBBbmRyb2lkIEJyb3dzZXIgPD00LjMgb25seVxuXHRcdC8vIFRyZWF0IHRoZSB0ZW1wbGF0ZSBlbGVtZW50IGFzIGEgcmVndWxhciBvbmUgaW4gYnJvd3NlcnMgdGhhdFxuXHRcdC8vIGRvbid0IHN1cHBvcnQgaXQuXG5cdFx0aWYgKCBub2RlTmFtZSggZWxlbSwgXCJ0ZW1wbGF0ZVwiICkgKSB7XG5cdFx0XHRlbGVtID0gZWxlbS5jb250ZW50IHx8IGVsZW07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpRdWVyeS5tZXJnZSggW10sIGVsZW0uY2hpbGROb2RlcyApO1xuXHR9XG59LCBmdW5jdGlvbiggbmFtZSwgZm4gKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHVudGlsLCBzZWxlY3RvciApIHtcblx0XHR2YXIgbWF0Y2hlZCA9IGpRdWVyeS5tYXAoIHRoaXMsIGZuLCB1bnRpbCApO1xuXG5cdFx0aWYgKCBuYW1lLnNsaWNlKCAtNSApICE9PSBcIlVudGlsXCIgKSB7XG5cdFx0XHRzZWxlY3RvciA9IHVudGlsO1xuXHRcdH1cblxuXHRcdGlmICggc2VsZWN0b3IgJiYgdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0bWF0Y2hlZCA9IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBtYXRjaGVkICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmxlbmd0aCA+IDEgKSB7XG5cblx0XHRcdC8vIFJlbW92ZSBkdXBsaWNhdGVzXG5cdFx0XHRpZiAoICFndWFyYW50ZWVkVW5pcXVlWyBuYW1lIF0gKSB7XG5cdFx0XHRcdGpRdWVyeS51bmlxdWVTb3J0KCBtYXRjaGVkICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldmVyc2Ugb3JkZXIgZm9yIHBhcmVudHMqIGFuZCBwcmV2LWRlcml2YXRpdmVzXG5cdFx0XHRpZiAoIHJwYXJlbnRzcHJldi50ZXN0KCBuYW1lICkgKSB7XG5cdFx0XHRcdG1hdGNoZWQucmV2ZXJzZSgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZCApO1xuXHR9O1xufSApO1xudmFyIHJub3RodG1sd2hpdGUgPSAoIC9bXlxceDIwXFx0XFxyXFxuXFxmXSsvZyApO1xuXG5cblxuLy8gQ29udmVydCBTdHJpbmctZm9ybWF0dGVkIG9wdGlvbnMgaW50byBPYmplY3QtZm9ybWF0dGVkIG9uZXNcbmZ1bmN0aW9uIGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSB7XG5cdHZhciBvYmplY3QgPSB7fTtcblx0alF1ZXJ5LmVhY2goIG9wdGlvbnMubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXSwgZnVuY3Rpb24oIF8sIGZsYWcgKSB7XG5cdFx0b2JqZWN0WyBmbGFnIF0gPSB0cnVlO1xuXHR9ICk7XG5cdHJldHVybiBvYmplY3Q7XG59XG5cbi8qXG4gKiBDcmVhdGUgYSBjYWxsYmFjayBsaXN0IHVzaW5nIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyczpcbiAqXG4gKlx0b3B0aW9uczogYW4gb3B0aW9uYWwgbGlzdCBvZiBzcGFjZS1zZXBhcmF0ZWQgb3B0aW9ucyB0aGF0IHdpbGwgY2hhbmdlIGhvd1xuICpcdFx0XHR0aGUgY2FsbGJhY2sgbGlzdCBiZWhhdmVzIG9yIGEgbW9yZSB0cmFkaXRpb25hbCBvcHRpb24gb2JqZWN0XG4gKlxuICogQnkgZGVmYXVsdCBhIGNhbGxiYWNrIGxpc3Qgd2lsbCBhY3QgbGlrZSBhbiBldmVudCBjYWxsYmFjayBsaXN0IGFuZCBjYW4gYmVcbiAqIFwiZmlyZWRcIiBtdWx0aXBsZSB0aW1lcy5cbiAqXG4gKiBQb3NzaWJsZSBvcHRpb25zOlxuICpcbiAqXHRvbmNlOlx0XHRcdHdpbGwgZW5zdXJlIHRoZSBjYWxsYmFjayBsaXN0IGNhbiBvbmx5IGJlIGZpcmVkIG9uY2UgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0bWVtb3J5Olx0XHRcdHdpbGwga2VlcCB0cmFjayBvZiBwcmV2aW91cyB2YWx1ZXMgYW5kIHdpbGwgY2FsbCBhbnkgY2FsbGJhY2sgYWRkZWRcbiAqXHRcdFx0XHRcdGFmdGVyIHRoZSBsaXN0IGhhcyBiZWVuIGZpcmVkIHJpZ2h0IGF3YXkgd2l0aCB0aGUgbGF0ZXN0IFwibWVtb3JpemVkXCJcbiAqXHRcdFx0XHRcdHZhbHVlcyAobGlrZSBhIERlZmVycmVkKVxuICpcbiAqXHR1bmlxdWU6XHRcdFx0d2lsbCBlbnN1cmUgYSBjYWxsYmFjayBjYW4gb25seSBiZSBhZGRlZCBvbmNlIChubyBkdXBsaWNhdGUgaW4gdGhlIGxpc3QpXG4gKlxuICpcdHN0b3BPbkZhbHNlOlx0aW50ZXJydXB0IGNhbGxpbmdzIHdoZW4gYSBjYWxsYmFjayByZXR1cm5zIGZhbHNlXG4gKlxuICovXG5qUXVlcnkuQ2FsbGJhY2tzID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cblx0Ly8gQ29udmVydCBvcHRpb25zIGZyb20gU3RyaW5nLWZvcm1hdHRlZCB0byBPYmplY3QtZm9ybWF0dGVkIGlmIG5lZWRlZFxuXHQvLyAod2UgY2hlY2sgaW4gY2FjaGUgZmlyc3QpXG5cdG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0Y3JlYXRlT3B0aW9ucyggb3B0aW9ucyApIDpcblx0XHRqUXVlcnkuZXh0ZW5kKCB7fSwgb3B0aW9ucyApO1xuXG5cdHZhciAvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCBpcyBjdXJyZW50bHkgZmlyaW5nXG5cdFx0ZmlyaW5nLFxuXG5cdFx0Ly8gTGFzdCBmaXJlIHZhbHVlIGZvciBub24tZm9yZ2V0dGFibGUgbGlzdHNcblx0XHRtZW1vcnksXG5cblx0XHQvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCB3YXMgYWxyZWFkeSBmaXJlZFxuXHRcdGZpcmVkLFxuXG5cdFx0Ly8gRmxhZyB0byBwcmV2ZW50IGZpcmluZ1xuXHRcdGxvY2tlZCxcblxuXHRcdC8vIEFjdHVhbCBjYWxsYmFjayBsaXN0XG5cdFx0bGlzdCA9IFtdLFxuXG5cdFx0Ly8gUXVldWUgb2YgZXhlY3V0aW9uIGRhdGEgZm9yIHJlcGVhdGFibGUgbGlzdHNcblx0XHRxdWV1ZSA9IFtdLFxuXG5cdFx0Ly8gSW5kZXggb2YgY3VycmVudGx5IGZpcmluZyBjYWxsYmFjayAobW9kaWZpZWQgYnkgYWRkL3JlbW92ZSBhcyBuZWVkZWQpXG5cdFx0ZmlyaW5nSW5kZXggPSAtMSxcblxuXHRcdC8vIEZpcmUgY2FsbGJhY2tzXG5cdFx0ZmlyZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBFbmZvcmNlIHNpbmdsZS1maXJpbmdcblx0XHRcdGxvY2tlZCA9IGxvY2tlZCB8fCBvcHRpb25zLm9uY2U7XG5cblx0XHRcdC8vIEV4ZWN1dGUgY2FsbGJhY2tzIGZvciBhbGwgcGVuZGluZyBleGVjdXRpb25zLFxuXHRcdFx0Ly8gcmVzcGVjdGluZyBmaXJpbmdJbmRleCBvdmVycmlkZXMgYW5kIHJ1bnRpbWUgY2hhbmdlc1xuXHRcdFx0ZmlyZWQgPSBmaXJpbmcgPSB0cnVlO1xuXHRcdFx0Zm9yICggOyBxdWV1ZS5sZW5ndGg7IGZpcmluZ0luZGV4ID0gLTEgKSB7XG5cdFx0XHRcdG1lbW9yeSA9IHF1ZXVlLnNoaWZ0KCk7XG5cdFx0XHRcdHdoaWxlICggKytmaXJpbmdJbmRleCA8IGxpc3QubGVuZ3RoICkge1xuXG5cdFx0XHRcdFx0Ly8gUnVuIGNhbGxiYWNrIGFuZCBjaGVjayBmb3IgZWFybHkgdGVybWluYXRpb25cblx0XHRcdFx0XHRpZiAoIGxpc3RbIGZpcmluZ0luZGV4IF0uYXBwbHkoIG1lbW9yeVsgMCBdLCBtZW1vcnlbIDEgXSApID09PSBmYWxzZSAmJlxuXHRcdFx0XHRcdFx0b3B0aW9ucy5zdG9wT25GYWxzZSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSnVtcCB0byBlbmQgYW5kIGZvcmdldCB0aGUgZGF0YSBzbyAuYWRkIGRvZXNuJ3QgcmUtZmlyZVxuXHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXggPSBsaXN0Lmxlbmd0aDtcblx0XHRcdFx0XHRcdG1lbW9yeSA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBGb3JnZXQgdGhlIGRhdGEgaWYgd2UncmUgZG9uZSB3aXRoIGl0XG5cdFx0XHRpZiAoICFvcHRpb25zLm1lbW9yeSApIHtcblx0XHRcdFx0bWVtb3J5ID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGZpcmluZyA9IGZhbHNlO1xuXG5cdFx0XHQvLyBDbGVhbiB1cCBpZiB3ZSdyZSBkb25lIGZpcmluZyBmb3IgZ29vZFxuXHRcdFx0aWYgKCBsb2NrZWQgKSB7XG5cblx0XHRcdFx0Ly8gS2VlcCBhbiBlbXB0eSBsaXN0IGlmIHdlIGhhdmUgZGF0YSBmb3IgZnV0dXJlIGFkZCBjYWxsc1xuXHRcdFx0XHRpZiAoIG1lbW9yeSApIHtcblx0XHRcdFx0XHRsaXN0ID0gW107XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCB0aGlzIG9iamVjdCBpcyBzcGVudFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxpc3QgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8vIEFjdHVhbCBDYWxsYmFja3Mgb2JqZWN0XG5cdFx0c2VsZiA9IHtcblxuXHRcdFx0Ly8gQWRkIGEgY2FsbGJhY2sgb3IgYSBjb2xsZWN0aW9uIG9mIGNhbGxiYWNrcyB0byB0aGUgbGlzdFxuXHRcdFx0YWRkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBsaXN0ICkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBtZW1vcnkgZnJvbSBhIHBhc3QgcnVuLCB3ZSBzaG91bGQgZmlyZSBhZnRlciBhZGRpbmdcblx0XHRcdFx0XHRpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXggPSBsaXN0Lmxlbmd0aCAtIDE7XG5cdFx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBtZW1vcnkgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQoIGZ1bmN0aW9uIGFkZCggYXJncyApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmdzLCBmdW5jdGlvbiggXywgYXJnICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIGlzRnVuY3Rpb24oIGFyZyApICkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICggIW9wdGlvbnMudW5pcXVlIHx8ICFzZWxmLmhhcyggYXJnICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRsaXN0LnB1c2goIGFyZyApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggYXJnICYmIGFyZy5sZW5ndGggJiYgdG9UeXBlKCBhcmcgKSAhPT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIEluc3BlY3QgcmVjdXJzaXZlbHlcblx0XHRcdFx0XHRcdFx0XHRhZGQoIGFyZyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0fSApKCBhcmd1bWVudHMgKTtcblxuXHRcdFx0XHRcdGlmICggbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gUmVtb3ZlIGEgY2FsbGJhY2sgZnJvbSB0aGUgbGlzdFxuXHRcdFx0cmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5LmVhY2goIGFyZ3VtZW50cywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHR2YXIgaW5kZXg7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGluZGV4ID0galF1ZXJ5LmluQXJyYXkoIGFyZywgbGlzdCwgaW5kZXggKSApID4gLTEgKSB7XG5cdFx0XHRcdFx0XHRsaXN0LnNwbGljZSggaW5kZXgsIDEgKTtcblxuXHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGZpcmluZyBpbmRleGVzXG5cdFx0XHRcdFx0XHRpZiAoIGluZGV4IDw9IGZpcmluZ0luZGV4ICkge1xuXHRcdFx0XHRcdFx0XHRmaXJpbmdJbmRleC0tO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIENoZWNrIGlmIGEgZ2l2ZW4gY2FsbGJhY2sgaXMgaW4gdGhlIGxpc3QuXG5cdFx0XHQvLyBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgcmV0dXJuIHdoZXRoZXIgb3Igbm90IGxpc3QgaGFzIGNhbGxiYWNrcyBhdHRhY2hlZC5cblx0XHRcdGhhczogZnVuY3Rpb24oIGZuICkge1xuXHRcdFx0XHRyZXR1cm4gZm4gP1xuXHRcdFx0XHRcdGpRdWVyeS5pbkFycmF5KCBmbiwgbGlzdCApID4gLTEgOlxuXHRcdFx0XHRcdGxpc3QubGVuZ3RoID4gMDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIFJlbW92ZSBhbGwgY2FsbGJhY2tzIGZyb20gdGhlIGxpc3Rcblx0XHRcdGVtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBsaXN0ICkge1xuXHRcdFx0XHRcdGxpc3QgPSBbXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIERpc2FibGUgLmZpcmUgYW5kIC5hZGRcblx0XHRcdC8vIEFib3J0IGFueSBjdXJyZW50L3BlbmRpbmcgZXhlY3V0aW9uc1xuXHRcdFx0Ly8gQ2xlYXIgYWxsIGNhbGxiYWNrcyBhbmQgdmFsdWVzXG5cdFx0XHRkaXNhYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bG9ja2VkID0gcXVldWUgPSBbXTtcblx0XHRcdFx0bGlzdCA9IG1lbW9yeSA9IFwiXCI7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdGRpc2FibGVkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICFsaXN0O1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRGlzYWJsZSAuZmlyZVxuXHRcdFx0Ly8gQWxzbyBkaXNhYmxlIC5hZGQgdW5sZXNzIHdlIGhhdmUgbWVtb3J5IChzaW5jZSBpdCB3b3VsZCBoYXZlIG5vIGVmZmVjdClcblx0XHRcdC8vIEFib3J0IGFueSBwZW5kaW5nIGV4ZWN1dGlvbnNcblx0XHRcdGxvY2s6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRsb2NrZWQgPSBxdWV1ZSA9IFtdO1xuXHRcdFx0XHRpZiAoICFtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRsaXN0ID0gbWVtb3J5ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHRsb2NrZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gISFsb2NrZWQ7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDYWxsIGFsbCBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gY29udGV4dCBhbmQgYXJndW1lbnRzXG5cdFx0XHRmaXJlV2l0aDogZnVuY3Rpb24oIGNvbnRleHQsIGFyZ3MgKSB7XG5cdFx0XHRcdGlmICggIWxvY2tlZCApIHtcblx0XHRcdFx0XHRhcmdzID0gYXJncyB8fCBbXTtcblx0XHRcdFx0XHRhcmdzID0gWyBjb250ZXh0LCBhcmdzLnNsaWNlID8gYXJncy5zbGljZSgpIDogYXJncyBdO1xuXHRcdFx0XHRcdHF1ZXVlLnB1c2goIGFyZ3MgKTtcblx0XHRcdFx0XHRpZiAoICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2FsbCBhbGwgdGhlIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudHNcblx0XHRcdGZpcmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZWxmLmZpcmVXaXRoKCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBUbyBrbm93IGlmIHRoZSBjYWxsYmFja3MgaGF2ZSBhbHJlYWR5IGJlZW4gY2FsbGVkIGF0IGxlYXN0IG9uY2Vcblx0XHRcdGZpcmVkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICEhZmlyZWQ7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRyZXR1cm4gc2VsZjtcbn07XG5cblxuZnVuY3Rpb24gSWRlbnRpdHkoIHYgKSB7XG5cdHJldHVybiB2O1xufVxuZnVuY3Rpb24gVGhyb3dlciggZXggKSB7XG5cdHRocm93IGV4O1xufVxuXG5mdW5jdGlvbiBhZG9wdFZhbHVlKCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0LCBub1ZhbHVlICkge1xuXHR2YXIgbWV0aG9kO1xuXG5cdHRyeSB7XG5cblx0XHQvLyBDaGVjayBmb3IgcHJvbWlzZSBhc3BlY3QgZmlyc3QgdG8gcHJpdmlsZWdlIHN5bmNocm9ub3VzIGJlaGF2aW9yXG5cdFx0aWYgKCB2YWx1ZSAmJiBpc0Z1bmN0aW9uKCAoIG1ldGhvZCA9IHZhbHVlLnByb21pc2UgKSApICkge1xuXHRcdFx0bWV0aG9kLmNhbGwoIHZhbHVlICkuZG9uZSggcmVzb2x2ZSApLmZhaWwoIHJlamVjdCApO1xuXG5cdFx0Ly8gT3RoZXIgdGhlbmFibGVzXG5cdFx0fSBlbHNlIGlmICggdmFsdWUgJiYgaXNGdW5jdGlvbiggKCBtZXRob2QgPSB2YWx1ZS50aGVuICkgKSApIHtcblx0XHRcdG1ldGhvZC5jYWxsKCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0ICk7XG5cblx0XHQvLyBPdGhlciBub24tdGhlbmFibGVzXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gQ29udHJvbCBgcmVzb2x2ZWAgYXJndW1lbnRzIGJ5IGxldHRpbmcgQXJyYXkjc2xpY2UgY2FzdCBib29sZWFuIGBub1ZhbHVlYCB0byBpbnRlZ2VyOlxuXHRcdFx0Ly8gKiBmYWxzZTogWyB2YWx1ZSBdLnNsaWNlKCAwICkgPT4gcmVzb2x2ZSggdmFsdWUgKVxuXHRcdFx0Ly8gKiB0cnVlOiBbIHZhbHVlIF0uc2xpY2UoIDEgKSA9PiByZXNvbHZlKClcblx0XHRcdHJlc29sdmUuYXBwbHkoIHVuZGVmaW5lZCwgWyB2YWx1ZSBdLnNsaWNlKCBub1ZhbHVlICkgKTtcblx0XHR9XG5cblx0Ly8gRm9yIFByb21pc2VzL0ErLCBjb252ZXJ0IGV4Y2VwdGlvbnMgaW50byByZWplY3Rpb25zXG5cdC8vIFNpbmNlIGpRdWVyeS53aGVuIGRvZXNuJ3QgdW53cmFwIHRoZW5hYmxlcywgd2UgY2FuIHNraXAgdGhlIGV4dHJhIGNoZWNrcyBhcHBlYXJpbmcgaW5cblx0Ly8gRGVmZXJyZWQjdGhlbiB0byBjb25kaXRpb25hbGx5IHN1cHByZXNzIHJlamVjdGlvbi5cblx0fSBjYXRjaCAoIHZhbHVlICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgb25seVxuXHRcdC8vIFN0cmljdCBtb2RlIGZ1bmN0aW9ucyBpbnZva2VkIHdpdGhvdXQgLmNhbGwvLmFwcGx5IGdldCBnbG9iYWwtb2JqZWN0IGNvbnRleHRcblx0XHRyZWplY3QuYXBwbHkoIHVuZGVmaW5lZCwgWyB2YWx1ZSBdICk7XG5cdH1cbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdERlZmVycmVkOiBmdW5jdGlvbiggZnVuYyApIHtcblx0XHR2YXIgdHVwbGVzID0gW1xuXG5cdFx0XHRcdC8vIGFjdGlvbiwgYWRkIGxpc3RlbmVyLCBjYWxsYmFja3MsXG5cdFx0XHRcdC8vIC4uLiAudGhlbiBoYW5kbGVycywgYXJndW1lbnQgaW5kZXgsIFtmaW5hbCBzdGF0ZV1cblx0XHRcdFx0WyBcIm5vdGlmeVwiLCBcInByb2dyZXNzXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwibWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm1lbW9yeVwiICksIDIgXSxcblx0XHRcdFx0WyBcInJlc29sdmVcIiwgXCJkb25lXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLCAwLCBcInJlc29sdmVkXCIgXSxcblx0XHRcdFx0WyBcInJlamVjdFwiLCBcImZhaWxcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksIDEsIFwicmVqZWN0ZWRcIiBdXG5cdFx0XHRdLFxuXHRcdFx0c3RhdGUgPSBcInBlbmRpbmdcIixcblx0XHRcdHByb21pc2UgPSB7XG5cdFx0XHRcdHN0YXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gc3RhdGU7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGFsd2F5czogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQuZG9uZSggYXJndW1lbnRzICkuZmFpbCggYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdFwiY2F0Y2hcIjogZnVuY3Rpb24oIGZuICkge1xuXHRcdFx0XHRcdHJldHVybiBwcm9taXNlLnRoZW4oIG51bGwsIGZuICk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gS2VlcCBwaXBlIGZvciBiYWNrLWNvbXBhdFxuXHRcdFx0XHRwaXBlOiBmdW5jdGlvbiggLyogZm5Eb25lLCBmbkZhaWwsIGZuUHJvZ3Jlc3MgKi8gKSB7XG5cdFx0XHRcdFx0dmFyIGZucyA9IGFyZ3VtZW50cztcblxuXHRcdFx0XHRcdHJldHVybiBqUXVlcnkuRGVmZXJyZWQoIGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBfaSwgdHVwbGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gTWFwIHR1cGxlcyAocHJvZ3Jlc3MsIGRvbmUsIGZhaWwpIHRvIGFyZ3VtZW50cyAoZG9uZSwgZmFpbCwgcHJvZ3Jlc3MpXG5cdFx0XHRcdFx0XHRcdHZhciBmbiA9IGlzRnVuY3Rpb24oIGZuc1sgdHVwbGVbIDQgXSBdICkgJiYgZm5zWyB0dXBsZVsgNCBdIF07XG5cblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQucHJvZ3Jlc3MoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIubm90aWZ5IH0pXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLmRvbmUoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIucmVzb2x2ZSB9KVxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5mYWlsKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLnJlamVjdCB9KVxuXHRcdFx0XHRcdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDEgXSBdKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgcmV0dXJuZWQgPSBmbiAmJiBmbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCByZXR1cm5lZCAmJiBpc0Z1bmN0aW9uKCByZXR1cm5lZC5wcm9taXNlICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC5wcm9taXNlKClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LnByb2dyZXNzKCBuZXdEZWZlci5ub3RpZnkgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZG9uZSggbmV3RGVmZXIucmVzb2x2ZSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5mYWlsKCBuZXdEZWZlci5yZWplY3QgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXJbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRmbiA/IFsgcmV0dXJuZWQgXSA6IGFyZ3VtZW50c1xuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdGZucyA9IG51bGw7XG5cdFx0XHRcdFx0fSApLnByb21pc2UoKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0dGhlbjogZnVuY3Rpb24oIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBvblByb2dyZXNzICkge1xuXHRcdFx0XHRcdHZhciBtYXhEZXB0aCA9IDA7XG5cdFx0XHRcdFx0ZnVuY3Rpb24gcmVzb2x2ZSggZGVwdGgsIGRlZmVycmVkLCBoYW5kbGVyLCBzcGVjaWFsICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRcdFx0XHRcdFx0YXJncyA9IGFyZ3VtZW50cyxcblx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgcmV0dXJuZWQsIHRoZW47XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy4zXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01OVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSWdub3JlIGRvdWJsZS1yZXNvbHV0aW9uIGF0dGVtcHRzXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoIDwgbWF4RGVwdGggKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQgPSBoYW5kbGVyLmFwcGx5KCB0aGF0LCBhcmdzICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjFcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTQ4XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHJldHVybmVkID09PSBkZWZlcnJlZC5wcm9taXNlKCkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoIFwiVGhlbmFibGUgc2VsZi1yZXNvbHV0aW9uXCIgKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbnMgMi4zLjMuMSwgMy41XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01NFxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNzVcblx0XHRcdFx0XHRcdFx0XHRcdC8vIFJldHJpZXZlIGB0aGVuYCBvbmx5IG9uY2Vcblx0XHRcdFx0XHRcdFx0XHRcdHRoZW4gPSByZXR1cm5lZCAmJlxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNjRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBjaGVjayBvYmplY3RzIGFuZCBmdW5jdGlvbnMgZm9yIHRoZW5hYmlsaXR5XG5cdFx0XHRcdFx0XHRcdFx0XHRcdCggdHlwZW9mIHJldHVybmVkID09PSBcIm9iamVjdFwiIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZW9mIHJldHVybmVkID09PSBcImZ1bmN0aW9uXCIgKSAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC50aGVuO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBIYW5kbGUgYSByZXR1cm5lZCB0aGVuYWJsZVxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCB0aGVuICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3BlY2lhbCBwcm9jZXNzb3JzIChub3RpZnkpIGp1c3Qgd2FpdCBmb3IgcmVzb2x1dGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHNwZWNpYWwgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhlbi5jYWxsKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIFRocm93ZXIsIHNwZWNpYWwgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gTm9ybWFsIHByb2Nlc3NvcnMgKHJlc29sdmUpIGFsc28gaG9vayBpbnRvIHByb2dyZXNzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgZGlzcmVnYXJkIG9sZGVyIHJlc29sdXRpb24gdmFsdWVzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWF4RGVwdGgrKztcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoZW4uY2FsbChcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBUaHJvd2VyLCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIEhhbmRsZSBhbGwgb3RoZXIgcmV0dXJuZWQgdmFsdWVzXG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgc3Vic3RpdHV0ZSBoYW5kbGVycyBwYXNzIG9uIGNvbnRleHRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gYW5kIG11bHRpcGxlIHZhbHVlcyAobm9uLXNwZWMgYmVoYXZpb3IpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggaGFuZGxlciAhPT0gSWRlbnRpdHkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhhdCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhcmdzID0gWyByZXR1cm5lZCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gUHJvY2VzcyB0aGUgdmFsdWUocylcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRGVmYXVsdCBwcm9jZXNzIGlzIHJlc29sdmVcblx0XHRcdFx0XHRcdFx0XHRcdFx0KCBzcGVjaWFsIHx8IGRlZmVycmVkLnJlc29sdmVXaXRoICkoIHRoYXQsIGFyZ3MgKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBub3JtYWwgcHJvY2Vzc29ycyAocmVzb2x2ZSkgY2F0Y2ggYW5kIHJlamVjdCBleGNlcHRpb25zXG5cdFx0XHRcdFx0XHRcdFx0cHJvY2VzcyA9IHNwZWNpYWwgP1xuXHRcdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdyA6XG5cdFx0XHRcdFx0XHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93KCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rKCBlLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzLnN0YWNrVHJhY2UgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuNC4xXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNjFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBJZ25vcmUgcG9zdC1yZXNvbHV0aW9uIGV4Y2VwdGlvbnNcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoICsgMSA+PSBtYXhEZXB0aCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBzdWJzdGl0dXRlIGhhbmRsZXJzIHBhc3Mgb24gY29udGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gYW5kIG11bHRpcGxlIHZhbHVlcyAobm9uLXNwZWMgYmVoYXZpb3IpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGhhbmRsZXIgIT09IFRocm93ZXIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoYXQgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBbIGUgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggdGhhdCwgYXJncyApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuMVxuXHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01N1xuXHRcdFx0XHRcdFx0XHQvLyBSZS1yZXNvbHZlIHByb21pc2VzIGltbWVkaWF0ZWx5IHRvIGRvZGdlIGZhbHNlIHJlamVjdGlvbiBmcm9tXG5cdFx0XHRcdFx0XHRcdC8vIHN1YnNlcXVlbnQgZXJyb3JzXG5cdFx0XHRcdFx0XHRcdGlmICggZGVwdGggKSB7XG5cdFx0XHRcdFx0XHRcdFx0cHJvY2VzcygpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ2FsbCBhbiBvcHRpb25hbCBob29rIHRvIHJlY29yZCB0aGUgc3RhY2ssIGluIGNhc2Ugb2YgZXhjZXB0aW9uXG5cdFx0XHRcdFx0XHRcdFx0Ly8gc2luY2UgaXQncyBvdGhlcndpc2UgbG9zdCB3aGVuIGV4ZWN1dGlvbiBnb2VzIGFzeW5jXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuRGVmZXJyZWQuZ2V0U3RhY2tIb29rICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cHJvY2Vzcy5zdGFja1RyYWNlID0galF1ZXJ5LkRlZmVycmVkLmdldFN0YWNrSG9vaygpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dCggcHJvY2VzcyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBqUXVlcnkuRGVmZXJyZWQoIGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcblxuXHRcdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRpc0Z1bmN0aW9uKCBvblByb2dyZXNzICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25Qcm9ncmVzcyA6XG5cdFx0XHRcdFx0XHRcdFx0XHRJZGVudGl0eSxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlci5ub3RpZnlXaXRoXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5hZGQoIC4uLiApXG5cdFx0XHRcdFx0XHR0dXBsZXNbIDEgXVsgMyBdLmFkZChcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShcblx0XHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLFxuXHRcdFx0XHRcdFx0XHRcdGlzRnVuY3Rpb24oIG9uRnVsZmlsbGVkICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25GdWxmaWxsZWQgOlxuXHRcdFx0XHRcdFx0XHRcdFx0SWRlbnRpdHlcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAyIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRpc0Z1bmN0aW9uKCBvblJlamVjdGVkICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25SZWplY3RlZCA6XG5cdFx0XHRcdFx0XHRcdFx0XHRUaHJvd2VyXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fSApLnByb21pc2UoKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBHZXQgYSBwcm9taXNlIGZvciB0aGlzIGRlZmVycmVkXG5cdFx0XHRcdC8vIElmIG9iaiBpcyBwcm92aWRlZCwgdGhlIHByb21pc2UgYXNwZWN0IGlzIGFkZGVkIHRvIHRoZSBvYmplY3Rcblx0XHRcdFx0cHJvbWlzZTogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRcdFx0XHRyZXR1cm4gb2JqICE9IG51bGwgPyBqUXVlcnkuZXh0ZW5kKCBvYmosIHByb21pc2UgKSA6IHByb21pc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWZlcnJlZCA9IHt9O1xuXG5cdFx0Ly8gQWRkIGxpc3Qtc3BlY2lmaWMgbWV0aG9kc1xuXHRcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBpLCB0dXBsZSApIHtcblx0XHRcdHZhciBsaXN0ID0gdHVwbGVbIDIgXSxcblx0XHRcdFx0c3RhdGVTdHJpbmcgPSB0dXBsZVsgNSBdO1xuXG5cdFx0XHQvLyBwcm9taXNlLnByb2dyZXNzID0gbGlzdC5hZGRcblx0XHRcdC8vIHByb21pc2UuZG9uZSA9IGxpc3QuYWRkXG5cdFx0XHQvLyBwcm9taXNlLmZhaWwgPSBsaXN0LmFkZFxuXHRcdFx0cHJvbWlzZVsgdHVwbGVbIDEgXSBdID0gbGlzdC5hZGQ7XG5cblx0XHRcdC8vIEhhbmRsZSBzdGF0ZVxuXHRcdFx0aWYgKCBzdGF0ZVN0cmluZyApIHtcblx0XHRcdFx0bGlzdC5hZGQoXG5cdFx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHRcdC8vIHN0YXRlID0gXCJyZXNvbHZlZFwiIChpLmUuLCBmdWxmaWxsZWQpXG5cdFx0XHRcdFx0XHQvLyBzdGF0ZSA9IFwicmVqZWN0ZWRcIlxuXHRcdFx0XHRcdFx0c3RhdGUgPSBzdGF0ZVN0cmluZztcblx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfY2FsbGJhY2tzLmRpc2FibGVcblx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfY2FsbGJhY2tzLmRpc2FibGVcblx0XHRcdFx0XHR0dXBsZXNbIDMgLSBpIF1bIDIgXS5kaXNhYmxlLFxuXG5cdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuZGlzYWJsZVxuXHRcdFx0XHRcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5kaXNhYmxlXG5cdFx0XHRcdFx0dHVwbGVzWyAzIC0gaSBdWyAzIF0uZGlzYWJsZSxcblxuXHRcdFx0XHRcdC8vIHByb2dyZXNzX2NhbGxiYWNrcy5sb2NrXG5cdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDIgXS5sb2NrLFxuXG5cdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMubG9ja1xuXHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAzIF0ubG9ja1xuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBwcm9ncmVzc19oYW5kbGVycy5maXJlXG5cdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuZmlyZVxuXHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuZmlyZVxuXHRcdFx0bGlzdC5hZGQoIHR1cGxlWyAzIF0uZmlyZSApO1xuXG5cdFx0XHQvLyBkZWZlcnJlZC5ub3RpZnkgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQubm90aWZ5V2l0aCguLi4pIH1cblx0XHRcdC8vIGRlZmVycmVkLnJlc29sdmUgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQucmVzb2x2ZVdpdGgoLi4uKSB9XG5cdFx0XHQvLyBkZWZlcnJlZC5yZWplY3QgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQucmVqZWN0V2l0aCguLi4pIH1cblx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKCB0aGlzID09PSBkZWZlcnJlZCA/IHVuZGVmaW5lZCA6IHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH07XG5cblx0XHRcdC8vIGRlZmVycmVkLm5vdGlmeVdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHQvLyBkZWZlcnJlZC5yZXNvbHZlV2l0aCA9IGxpc3QuZmlyZVdpdGhcblx0XHRcdC8vIGRlZmVycmVkLnJlamVjdFdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0gPSBsaXN0LmZpcmVXaXRoO1xuXHRcdH0gKTtcblxuXHRcdC8vIE1ha2UgdGhlIGRlZmVycmVkIGEgcHJvbWlzZVxuXHRcdHByb21pc2UucHJvbWlzZSggZGVmZXJyZWQgKTtcblxuXHRcdC8vIENhbGwgZ2l2ZW4gZnVuYyBpZiBhbnlcblx0XHRpZiAoIGZ1bmMgKSB7XG5cdFx0XHRmdW5jLmNhbGwoIGRlZmVycmVkLCBkZWZlcnJlZCApO1xuXHRcdH1cblxuXHRcdC8vIEFsbCBkb25lIVxuXHRcdHJldHVybiBkZWZlcnJlZDtcblx0fSxcblxuXHQvLyBEZWZlcnJlZCBoZWxwZXJcblx0d2hlbjogZnVuY3Rpb24oIHNpbmdsZVZhbHVlICkge1xuXHRcdHZhclxuXG5cdFx0XHQvLyBjb3VudCBvZiB1bmNvbXBsZXRlZCBzdWJvcmRpbmF0ZXNcblx0XHRcdHJlbWFpbmluZyA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cblx0XHRcdC8vIGNvdW50IG9mIHVucHJvY2Vzc2VkIGFyZ3VtZW50c1xuXHRcdFx0aSA9IHJlbWFpbmluZyxcblxuXHRcdFx0Ly8gc3Vib3JkaW5hdGUgZnVsZmlsbG1lbnQgZGF0YVxuXHRcdFx0cmVzb2x2ZUNvbnRleHRzID0gQXJyYXkoIGkgKSxcblx0XHRcdHJlc29sdmVWYWx1ZXMgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSxcblxuXHRcdFx0Ly8gdGhlIG1hc3RlciBEZWZlcnJlZFxuXHRcdFx0bWFzdGVyID0galF1ZXJ5LkRlZmVycmVkKCksXG5cblx0XHRcdC8vIHN1Ym9yZGluYXRlIGNhbGxiYWNrIGZhY3Rvcnlcblx0XHRcdHVwZGF0ZUZ1bmMgPSBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXNvbHZlQ29udGV4dHNbIGkgXSA9IHRoaXM7XG5cdFx0XHRcdFx0cmVzb2x2ZVZhbHVlc1sgaSBdID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSA6IHZhbHVlO1xuXHRcdFx0XHRcdGlmICggISggLS1yZW1haW5pbmcgKSApIHtcblx0XHRcdFx0XHRcdG1hc3Rlci5yZXNvbHZlV2l0aCggcmVzb2x2ZUNvbnRleHRzLCByZXNvbHZlVmFsdWVzICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblxuXHRcdC8vIFNpbmdsZS0gYW5kIGVtcHR5IGFyZ3VtZW50cyBhcmUgYWRvcHRlZCBsaWtlIFByb21pc2UucmVzb2x2ZVxuXHRcdGlmICggcmVtYWluaW5nIDw9IDEgKSB7XG5cdFx0XHRhZG9wdFZhbHVlKCBzaW5nbGVWYWx1ZSwgbWFzdGVyLmRvbmUoIHVwZGF0ZUZ1bmMoIGkgKSApLnJlc29sdmUsIG1hc3Rlci5yZWplY3QsXG5cdFx0XHRcdCFyZW1haW5pbmcgKTtcblxuXHRcdFx0Ly8gVXNlIC50aGVuKCkgdG8gdW53cmFwIHNlY29uZGFyeSB0aGVuYWJsZXMgKGNmLiBnaC0zMDAwKVxuXHRcdFx0aWYgKCBtYXN0ZXIuc3RhdGUoKSA9PT0gXCJwZW5kaW5nXCIgfHxcblx0XHRcdFx0aXNGdW5jdGlvbiggcmVzb2x2ZVZhbHVlc1sgaSBdICYmIHJlc29sdmVWYWx1ZXNbIGkgXS50aGVuICkgKSB7XG5cblx0XHRcdFx0cmV0dXJuIG1hc3Rlci50aGVuKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gTXVsdGlwbGUgYXJndW1lbnRzIGFyZSBhZ2dyZWdhdGVkIGxpa2UgUHJvbWlzZS5hbGwgYXJyYXkgZWxlbWVudHNcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGFkb3B0VmFsdWUoIHJlc29sdmVWYWx1ZXNbIGkgXSwgdXBkYXRlRnVuYyggaSApLCBtYXN0ZXIucmVqZWN0ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hc3Rlci5wcm9taXNlKCk7XG5cdH1cbn0gKTtcblxuXG4vLyBUaGVzZSB1c3VhbGx5IGluZGljYXRlIGEgcHJvZ3JhbW1lciBtaXN0YWtlIGR1cmluZyBkZXZlbG9wbWVudCxcbi8vIHdhcm4gYWJvdXQgdGhlbSBBU0FQIHJhdGhlciB0aGFuIHN3YWxsb3dpbmcgdGhlbSBieSBkZWZhdWx0LlxudmFyIHJlcnJvck5hbWVzID0gL14oRXZhbHxJbnRlcm5hbHxSYW5nZXxSZWZlcmVuY2V8U3ludGF4fFR5cGV8VVJJKUVycm9yJC87XG5cbmpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rID0gZnVuY3Rpb24oIGVycm9yLCBzdGFjayApIHtcblxuXHQvLyBTdXBwb3J0OiBJRSA4IC0gOSBvbmx5XG5cdC8vIENvbnNvbGUgZXhpc3RzIHdoZW4gZGV2IHRvb2xzIGFyZSBvcGVuLCB3aGljaCBjYW4gaGFwcGVuIGF0IGFueSB0aW1lXG5cdGlmICggd2luZG93LmNvbnNvbGUgJiYgd2luZG93LmNvbnNvbGUud2FybiAmJiBlcnJvciAmJiByZXJyb3JOYW1lcy50ZXN0KCBlcnJvci5uYW1lICkgKSB7XG5cdFx0d2luZG93LmNvbnNvbGUud2FybiggXCJqUXVlcnkuRGVmZXJyZWQgZXhjZXB0aW9uOiBcIiArIGVycm9yLm1lc3NhZ2UsIGVycm9yLnN0YWNrLCBzdGFjayApO1xuXHR9XG59O1xuXG5cblxuXG5qUXVlcnkucmVhZHlFeGNlcHRpb24gPSBmdW5jdGlvbiggZXJyb3IgKSB7XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHR0aHJvdyBlcnJvcjtcblx0fSApO1xufTtcblxuXG5cblxuLy8gVGhlIGRlZmVycmVkIHVzZWQgb24gRE9NIHJlYWR5XG52YXIgcmVhZHlMaXN0ID0galF1ZXJ5LkRlZmVycmVkKCk7XG5cbmpRdWVyeS5mbi5yZWFkeSA9IGZ1bmN0aW9uKCBmbiApIHtcblxuXHRyZWFkeUxpc3Rcblx0XHQudGhlbiggZm4gKVxuXG5cdFx0Ly8gV3JhcCBqUXVlcnkucmVhZHlFeGNlcHRpb24gaW4gYSBmdW5jdGlvbiBzbyB0aGF0IHRoZSBsb29rdXBcblx0XHQvLyBoYXBwZW5zIGF0IHRoZSB0aW1lIG9mIGVycm9yIGhhbmRsaW5nIGluc3RlYWQgb2YgY2FsbGJhY2tcblx0XHQvLyByZWdpc3RyYXRpb24uXG5cdFx0LmNhdGNoKCBmdW5jdGlvbiggZXJyb3IgKSB7XG5cdFx0XHRqUXVlcnkucmVhZHlFeGNlcHRpb24oIGVycm9yICk7XG5cdFx0fSApO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIElzIHRoZSBET00gcmVhZHkgdG8gYmUgdXNlZD8gU2V0IHRvIHRydWUgb25jZSBpdCBvY2N1cnMuXG5cdGlzUmVhZHk6IGZhbHNlLFxuXG5cdC8vIEEgY291bnRlciB0byB0cmFjayBob3cgbWFueSBpdGVtcyB0byB3YWl0IGZvciBiZWZvcmVcblx0Ly8gdGhlIHJlYWR5IGV2ZW50IGZpcmVzLiBTZWUgIzY3ODFcblx0cmVhZHlXYWl0OiAxLFxuXG5cdC8vIEhhbmRsZSB3aGVuIHRoZSBET00gaXMgcmVhZHlcblx0cmVhZHk6IGZ1bmN0aW9uKCB3YWl0ICkge1xuXG5cdFx0Ly8gQWJvcnQgaWYgdGhlcmUgYXJlIHBlbmRpbmcgaG9sZHMgb3Igd2UncmUgYWxyZWFkeSByZWFkeVxuXHRcdGlmICggd2FpdCA9PT0gdHJ1ZSA/IC0talF1ZXJ5LnJlYWR5V2FpdCA6IGpRdWVyeS5pc1JlYWR5ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFJlbWVtYmVyIHRoYXQgdGhlIERPTSBpcyByZWFkeVxuXHRcdGpRdWVyeS5pc1JlYWR5ID0gdHJ1ZTtcblxuXHRcdC8vIElmIGEgbm9ybWFsIERPTSBSZWFkeSBldmVudCBmaXJlZCwgZGVjcmVtZW50LCBhbmQgd2FpdCBpZiBuZWVkIGJlXG5cdFx0aWYgKCB3YWl0ICE9PSB0cnVlICYmIC0talF1ZXJ5LnJlYWR5V2FpdCA+IDAgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlcmUgYXJlIGZ1bmN0aW9ucyBib3VuZCwgdG8gZXhlY3V0ZVxuXHRcdHJlYWR5TGlzdC5yZXNvbHZlV2l0aCggZG9jdW1lbnQsIFsgalF1ZXJ5IF0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkucmVhZHkudGhlbiA9IHJlYWR5TGlzdC50aGVuO1xuXG4vLyBUaGUgcmVhZHkgZXZlbnQgaGFuZGxlciBhbmQgc2VsZiBjbGVhbnVwIG1ldGhvZFxuZnVuY3Rpb24gY29tcGxldGVkKCkge1xuXHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkICk7XG5cdGpRdWVyeS5yZWFkeSgpO1xufVxuXG4vLyBDYXRjaCBjYXNlcyB3aGVyZSAkKGRvY3VtZW50KS5yZWFkeSgpIGlzIGNhbGxlZFxuLy8gYWZ0ZXIgdGhlIGJyb3dzZXIgZXZlbnQgaGFzIGFscmVhZHkgb2NjdXJyZWQuXG4vLyBTdXBwb3J0OiBJRSA8PTkgLSAxMCBvbmx5XG4vLyBPbGRlciBJRSBzb21ldGltZXMgc2lnbmFscyBcImludGVyYWN0aXZlXCIgdG9vIHNvb25cbmlmICggZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiIHx8XG5cdCggZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gXCJsb2FkaW5nXCIgJiYgIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbCApICkge1xuXG5cdC8vIEhhbmRsZSBpdCBhc3luY2hyb25vdXNseSB0byBhbGxvdyBzY3JpcHRzIHRoZSBvcHBvcnR1bml0eSB0byBkZWxheSByZWFkeVxuXHR3aW5kb3cuc2V0VGltZW91dCggalF1ZXJ5LnJlYWR5ICk7XG5cbn0gZWxzZSB7XG5cblx0Ly8gVXNlIHRoZSBoYW5keSBldmVudCBjYWxsYmFja1xuXHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cblx0Ly8gQSBmYWxsYmFjayB0byB3aW5kb3cub25sb2FkLCB0aGF0IHdpbGwgYWx3YXlzIHdvcmtcblx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBjb21wbGV0ZWQgKTtcbn1cblxuXG5cblxuLy8gTXVsdGlmdW5jdGlvbmFsIG1ldGhvZCB0byBnZXQgYW5kIHNldCB2YWx1ZXMgb2YgYSBjb2xsZWN0aW9uXG4vLyBUaGUgdmFsdWUvcyBjYW4gb3B0aW9uYWxseSBiZSBleGVjdXRlZCBpZiBpdCdzIGEgZnVuY3Rpb25cbnZhciBhY2Nlc3MgPSBmdW5jdGlvbiggZWxlbXMsIGZuLCBrZXksIHZhbHVlLCBjaGFpbmFibGUsIGVtcHR5R2V0LCByYXcgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSBlbGVtcy5sZW5ndGgsXG5cdFx0YnVsayA9IGtleSA9PSBudWxsO1xuXG5cdC8vIFNldHMgbWFueSB2YWx1ZXNcblx0aWYgKCB0b1R5cGUoIGtleSApID09PSBcIm9iamVjdFwiICkge1xuXHRcdGNoYWluYWJsZSA9IHRydWU7XG5cdFx0Zm9yICggaSBpbiBrZXkgKSB7XG5cdFx0XHRhY2Nlc3MoIGVsZW1zLCBmbiwgaSwga2V5WyBpIF0sIHRydWUsIGVtcHR5R2V0LCByYXcgKTtcblx0XHR9XG5cblx0Ly8gU2V0cyBvbmUgdmFsdWVcblx0fSBlbHNlIGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXG5cdFx0aWYgKCAhaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJhdyA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBidWxrICkge1xuXG5cdFx0XHQvLyBCdWxrIG9wZXJhdGlvbnMgcnVuIGFnYWluc3QgdGhlIGVudGlyZSBzZXRcblx0XHRcdGlmICggcmF3ICkge1xuXHRcdFx0XHRmbi5jYWxsKCBlbGVtcywgdmFsdWUgKTtcblx0XHRcdFx0Zm4gPSBudWxsO1xuXG5cdFx0XHQvLyAuLi5leGNlcHQgd2hlbiBleGVjdXRpbmcgZnVuY3Rpb24gdmFsdWVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRidWxrID0gZm47XG5cdFx0XHRcdGZuID0gZnVuY3Rpb24oIGVsZW0sIF9rZXksIHZhbHVlICkge1xuXHRcdFx0XHRcdHJldHVybiBidWxrLmNhbGwoIGpRdWVyeSggZWxlbSApLCB2YWx1ZSApO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggZm4gKSB7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0Zm4oXG5cdFx0XHRcdFx0ZWxlbXNbIGkgXSwga2V5LCByYXcgP1xuXHRcdFx0XHRcdHZhbHVlIDpcblx0XHRcdFx0XHR2YWx1ZS5jYWxsKCBlbGVtc1sgaSBdLCBpLCBmbiggZWxlbXNbIGkgXSwga2V5ICkgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmICggY2hhaW5hYmxlICkge1xuXHRcdHJldHVybiBlbGVtcztcblx0fVxuXG5cdC8vIEdldHNcblx0aWYgKCBidWxrICkge1xuXHRcdHJldHVybiBmbi5jYWxsKCBlbGVtcyApO1xuXHR9XG5cblx0cmV0dXJuIGxlbiA/IGZuKCBlbGVtc1sgMCBdLCBrZXkgKSA6IGVtcHR5R2V0O1xufTtcblxuXG4vLyBNYXRjaGVzIGRhc2hlZCBzdHJpbmcgZm9yIGNhbWVsaXppbmdcbnZhciBybXNQcmVmaXggPSAvXi1tcy0vLFxuXHRyZGFzaEFscGhhID0gLy0oW2Etel0pL2c7XG5cbi8vIFVzZWQgYnkgY2FtZWxDYXNlIGFzIGNhbGxiYWNrIHRvIHJlcGxhY2UoKVxuZnVuY3Rpb24gZmNhbWVsQ2FzZSggX2FsbCwgbGV0dGVyICkge1xuXHRyZXR1cm4gbGV0dGVyLnRvVXBwZXJDYXNlKCk7XG59XG5cbi8vIENvbnZlcnQgZGFzaGVkIHRvIGNhbWVsQ2FzZTsgdXNlZCBieSB0aGUgY3NzIGFuZCBkYXRhIG1vZHVsZXNcbi8vIFN1cHBvcnQ6IElFIDw9OSAtIDExLCBFZGdlIDEyIC0gMTVcbi8vIE1pY3Jvc29mdCBmb3Jnb3QgdG8gaHVtcCB0aGVpciB2ZW5kb3IgcHJlZml4ICgjOTU3MilcbmZ1bmN0aW9uIGNhbWVsQ2FzZSggc3RyaW5nICkge1xuXHRyZXR1cm4gc3RyaW5nLnJlcGxhY2UoIHJtc1ByZWZpeCwgXCJtcy1cIiApLnJlcGxhY2UoIHJkYXNoQWxwaGEsIGZjYW1lbENhc2UgKTtcbn1cbnZhciBhY2NlcHREYXRhID0gZnVuY3Rpb24oIG93bmVyICkge1xuXG5cdC8vIEFjY2VwdHMgb25seTpcblx0Ly8gIC0gTm9kZVxuXHQvLyAgICAtIE5vZGUuRUxFTUVOVF9OT0RFXG5cdC8vICAgIC0gTm9kZS5ET0NVTUVOVF9OT0RFXG5cdC8vICAtIE9iamVjdFxuXHQvLyAgICAtIEFueVxuXHRyZXR1cm4gb3duZXIubm9kZVR5cGUgPT09IDEgfHwgb3duZXIubm9kZVR5cGUgPT09IDkgfHwgISggK293bmVyLm5vZGVUeXBlICk7XG59O1xuXG5cblxuXG5mdW5jdGlvbiBEYXRhKCkge1xuXHR0aGlzLmV4cGFuZG8gPSBqUXVlcnkuZXhwYW5kbyArIERhdGEudWlkKys7XG59XG5cbkRhdGEudWlkID0gMTtcblxuRGF0YS5wcm90b3R5cGUgPSB7XG5cblx0Y2FjaGU6IGZ1bmN0aW9uKCBvd25lciApIHtcblxuXHRcdC8vIENoZWNrIGlmIHRoZSBvd25lciBvYmplY3QgYWxyZWFkeSBoYXMgYSBjYWNoZVxuXHRcdHZhciB2YWx1ZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblxuXHRcdC8vIElmIG5vdCwgY3JlYXRlIG9uZVxuXHRcdGlmICggIXZhbHVlICkge1xuXHRcdFx0dmFsdWUgPSB7fTtcblxuXHRcdFx0Ly8gV2UgY2FuIGFjY2VwdCBkYXRhIGZvciBub24tZWxlbWVudCBub2RlcyBpbiBtb2Rlcm4gYnJvd3NlcnMsXG5cdFx0XHQvLyBidXQgd2Ugc2hvdWxkIG5vdCwgc2VlICM4MzM1LlxuXHRcdFx0Ly8gQWx3YXlzIHJldHVybiBhbiBlbXB0eSBvYmplY3QuXG5cdFx0XHRpZiAoIGFjY2VwdERhdGEoIG93bmVyICkgKSB7XG5cblx0XHRcdFx0Ly8gSWYgaXQgaXMgYSBub2RlIHVubGlrZWx5IHRvIGJlIHN0cmluZ2lmeS1lZCBvciBsb29wZWQgb3ZlclxuXHRcdFx0XHQvLyB1c2UgcGxhaW4gYXNzaWdubWVudFxuXHRcdFx0XHRpZiAoIG93bmVyLm5vZGVUeXBlICkge1xuXHRcdFx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSA9IHZhbHVlO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBzZWN1cmUgaXQgaW4gYSBub24tZW51bWVyYWJsZSBwcm9wZXJ0eVxuXHRcdFx0XHQvLyBjb25maWd1cmFibGUgbXVzdCBiZSB0cnVlIHRvIGFsbG93IHRoZSBwcm9wZXJ0eSB0byBiZVxuXHRcdFx0XHQvLyBkZWxldGVkIHdoZW4gZGF0YSBpcyByZW1vdmVkXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBvd25lciwgdGhpcy5leHBhbmRvLCB7XG5cdFx0XHRcdFx0XHR2YWx1ZTogdmFsdWUsXG5cdFx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWVcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsdWU7XG5cdH0sXG5cdHNldDogZnVuY3Rpb24oIG93bmVyLCBkYXRhLCB2YWx1ZSApIHtcblx0XHR2YXIgcHJvcCxcblx0XHRcdGNhY2hlID0gdGhpcy5jYWNoZSggb3duZXIgKTtcblxuXHRcdC8vIEhhbmRsZTogWyBvd25lciwga2V5LCB2YWx1ZSBdIGFyZ3Ncblx0XHQvLyBBbHdheXMgdXNlIGNhbWVsQ2FzZSBrZXkgKGdoLTIyNTcpXG5cdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGNhY2hlWyBjYW1lbENhc2UoIGRhdGEgKSBdID0gdmFsdWU7XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIHsgcHJvcGVydGllcyB9IF0gYXJnc1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIENvcHkgdGhlIHByb3BlcnRpZXMgb25lLWJ5LW9uZSB0byB0aGUgY2FjaGUgb2JqZWN0XG5cdFx0XHRmb3IgKCBwcm9wIGluIGRhdGEgKSB7XG5cdFx0XHRcdGNhY2hlWyBjYW1lbENhc2UoIHByb3AgKSBdID0gZGF0YVsgcHJvcCBdO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gY2FjaGU7XG5cdH0sXG5cdGdldDogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XG5cdFx0cmV0dXJuIGtleSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdHRoaXMuY2FjaGUoIG93bmVyICkgOlxuXG5cdFx0XHQvLyBBbHdheXMgdXNlIGNhbWVsQ2FzZSBrZXkgKGdoLTIyNTcpXG5cdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gJiYgb3duZXJbIHRoaXMuZXhwYW5kbyBdWyBjYW1lbENhc2UoIGtleSApIF07XG5cdH0sXG5cdGFjY2VzczogZnVuY3Rpb24oIG93bmVyLCBrZXksIHZhbHVlICkge1xuXG5cdFx0Ly8gSW4gY2FzZXMgd2hlcmUgZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBObyBrZXkgd2FzIHNwZWNpZmllZFxuXHRcdC8vICAgMi4gQSBzdHJpbmcga2V5IHdhcyBzcGVjaWZpZWQsIGJ1dCBubyB2YWx1ZSBwcm92aWRlZFxuXHRcdC8vXG5cdFx0Ly8gVGFrZSB0aGUgXCJyZWFkXCIgcGF0aCBhbmQgYWxsb3cgdGhlIGdldCBtZXRob2QgdG8gZGV0ZXJtaW5lXG5cdFx0Ly8gd2hpY2ggdmFsdWUgdG8gcmV0dXJuLCByZXNwZWN0aXZlbHkgZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBUaGUgZW50aXJlIGNhY2hlIG9iamVjdFxuXHRcdC8vICAgMi4gVGhlIGRhdGEgc3RvcmVkIGF0IHRoZSBrZXlcblx0XHQvL1xuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHxcblx0XHRcdFx0KCAoIGtleSAmJiB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICkgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCApICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5nZXQoIG93bmVyLCBrZXkgKTtcblx0XHR9XG5cblx0XHQvLyBXaGVuIHRoZSBrZXkgaXMgbm90IGEgc3RyaW5nLCBvciBib3RoIGEga2V5IGFuZCB2YWx1ZVxuXHRcdC8vIGFyZSBzcGVjaWZpZWQsIHNldCBvciBleHRlbmQgKGV4aXN0aW5nIG9iamVjdHMpIHdpdGggZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBBbiBvYmplY3Qgb2YgcHJvcGVydGllc1xuXHRcdC8vICAgMi4gQSBrZXkgYW5kIHZhbHVlXG5cdFx0Ly9cblx0XHR0aGlzLnNldCggb3duZXIsIGtleSwgdmFsdWUgKTtcblxuXHRcdC8vIFNpbmNlIHRoZSBcInNldFwiIHBhdGggY2FuIGhhdmUgdHdvIHBvc3NpYmxlIGVudHJ5IHBvaW50c1xuXHRcdC8vIHJldHVybiB0aGUgZXhwZWN0ZWQgZGF0YSBiYXNlZCBvbiB3aGljaCBwYXRoIHdhcyB0YWtlblsqXVxuXHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiBrZXk7XG5cdH0sXG5cdHJlbW92ZTogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XG5cdFx0dmFyIGksXG5cdFx0XHRjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblxuXHRcdGlmICggY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIGtleSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0IGFycmF5IG9yIHNwYWNlIHNlcGFyYXRlZCBzdHJpbmcgb2Yga2V5c1xuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBrZXkgKSApIHtcblxuXHRcdFx0XHQvLyBJZiBrZXkgaXMgYW4gYXJyYXkgb2Yga2V5cy4uLlxuXHRcdFx0XHQvLyBXZSBhbHdheXMgc2V0IGNhbWVsQ2FzZSBrZXlzLCBzbyByZW1vdmUgdGhhdC5cblx0XHRcdFx0a2V5ID0ga2V5Lm1hcCggY2FtZWxDYXNlICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRrZXkgPSBjYW1lbENhc2UoIGtleSApO1xuXG5cdFx0XHRcdC8vIElmIGEga2V5IHdpdGggdGhlIHNwYWNlcyBleGlzdHMsIHVzZSBpdC5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBjcmVhdGUgYW4gYXJyYXkgYnkgbWF0Y2hpbmcgbm9uLXdoaXRlc3BhY2Vcblx0XHRcdFx0a2V5ID0ga2V5IGluIGNhY2hlID9cblx0XHRcdFx0XHRbIGtleSBdIDpcblx0XHRcdFx0XHQoIGtleS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdICk7XG5cdFx0XHR9XG5cblx0XHRcdGkgPSBrZXkubGVuZ3RoO1xuXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0ZGVsZXRlIGNhY2hlWyBrZXlbIGkgXSBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSB0aGUgZXhwYW5kbyBpZiB0aGVyZSdzIG5vIG1vcmUgZGF0YVxuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHwgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICkgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDVcblx0XHRcdC8vIFdlYmtpdCAmIEJsaW5rIHBlcmZvcm1hbmNlIHN1ZmZlcnMgd2hlbiBkZWxldGluZyBwcm9wZXJ0aWVzXG5cdFx0XHQvLyBmcm9tIERPTSBub2Rlcywgc28gc2V0IHRvIHVuZGVmaW5lZCBpbnN0ZWFkXG5cdFx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNzg2MDcgKGJ1ZyByZXN0cmljdGVkKVxuXHRcdFx0aWYgKCBvd25lci5ub2RlVHlwZSApIHtcblx0XHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVsZXRlIG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdGhhc0RhdGE6IGZ1bmN0aW9uKCBvd25lciApIHtcblx0XHR2YXIgY2FjaGUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cdFx0cmV0dXJuIGNhY2hlICE9PSB1bmRlZmluZWQgJiYgIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBjYWNoZSApO1xuXHR9XG59O1xudmFyIGRhdGFQcml2ID0gbmV3IERhdGEoKTtcblxudmFyIGRhdGFVc2VyID0gbmV3IERhdGEoKTtcblxuXG5cbi8vXHRJbXBsZW1lbnRhdGlvbiBTdW1tYXJ5XG4vL1xuLy9cdDEuIEVuZm9yY2UgQVBJIHN1cmZhY2UgYW5kIHNlbWFudGljIGNvbXBhdGliaWxpdHkgd2l0aCAxLjkueCBicmFuY2hcbi8vXHQyLiBJbXByb3ZlIHRoZSBtb2R1bGUncyBtYWludGFpbmFiaWxpdHkgYnkgcmVkdWNpbmcgdGhlIHN0b3JhZ2Vcbi8vXHRcdHBhdGhzIHRvIGEgc2luZ2xlIG1lY2hhbmlzbS5cbi8vXHQzLiBVc2UgdGhlIHNhbWUgc2luZ2xlIG1lY2hhbmlzbSB0byBzdXBwb3J0IFwicHJpdmF0ZVwiIGFuZCBcInVzZXJcIiBkYXRhLlxuLy9cdDQuIF9OZXZlcl8gZXhwb3NlIFwicHJpdmF0ZVwiIGRhdGEgdG8gdXNlciBjb2RlIChUT0RPOiBEcm9wIF9kYXRhLCBfcmVtb3ZlRGF0YSlcbi8vXHQ1LiBBdm9pZCBleHBvc2luZyBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzIG9uIHVzZXIgb2JqZWN0cyAoZWcuIGV4cGFuZG8gcHJvcGVydGllcylcbi8vXHQ2LiBQcm92aWRlIGEgY2xlYXIgcGF0aCBmb3IgaW1wbGVtZW50YXRpb24gdXBncmFkZSB0byBXZWFrTWFwIGluIDIwMTRcblxudmFyIHJicmFjZSA9IC9eKD86XFx7W1xcd1xcV10qXFx9fFxcW1tcXHdcXFddKlxcXSkkLyxcblx0cm11bHRpRGFzaCA9IC9bQS1aXS9nO1xuXG5mdW5jdGlvbiBnZXREYXRhKCBkYXRhICkge1xuXHRpZiAoIGRhdGEgPT09IFwidHJ1ZVwiICkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0aWYgKCBkYXRhID09PSBcImZhbHNlXCIgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0aWYgKCBkYXRhID09PSBcIm51bGxcIiApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8vIE9ubHkgY29udmVydCB0byBhIG51bWJlciBpZiBpdCBkb2Vzbid0IGNoYW5nZSB0aGUgc3RyaW5nXG5cdGlmICggZGF0YSA9PT0gK2RhdGEgKyBcIlwiICkge1xuXHRcdHJldHVybiArZGF0YTtcblx0fVxuXG5cdGlmICggcmJyYWNlLnRlc3QoIGRhdGEgKSApIHtcblx0XHRyZXR1cm4gSlNPTi5wYXJzZSggZGF0YSApO1xuXHR9XG5cblx0cmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIGRhdGFBdHRyKCBlbGVtLCBrZXksIGRhdGEgKSB7XG5cdHZhciBuYW1lO1xuXG5cdC8vIElmIG5vdGhpbmcgd2FzIGZvdW5kIGludGVybmFsbHksIHRyeSB0byBmZXRjaCBhbnlcblx0Ly8gZGF0YSBmcm9tIHRoZSBIVE1MNSBkYXRhLSogYXR0cmlidXRlXG5cdGlmICggZGF0YSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0bmFtZSA9IFwiZGF0YS1cIiArIGtleS5yZXBsYWNlKCBybXVsdGlEYXNoLCBcIi0kJlwiICkudG9Mb3dlckNhc2UoKTtcblx0XHRkYXRhID0gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKTtcblxuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRkYXRhID0gZ2V0RGF0YSggZGF0YSApO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgd2Ugc2V0IHRoZSBkYXRhIHNvIGl0IGlzbid0IGNoYW5nZWQgbGF0ZXJcblx0XHRcdGRhdGFVc2VyLnNldCggZWxlbSwga2V5LCBkYXRhICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBkYXRhO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGhhc0RhdGE6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkYXRhVXNlci5oYXNEYXRhKCBlbGVtICkgfHwgZGF0YVByaXYuaGFzRGF0YSggZWxlbSApO1xuXHR9LFxuXG5cdGRhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBkYXRhVXNlci5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcblx0fSxcblxuXHRyZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRkYXRhVXNlci5yZW1vdmUoIGVsZW0sIG5hbWUgKTtcblx0fSxcblxuXHQvLyBUT0RPOiBOb3cgdGhhdCBhbGwgY2FsbHMgdG8gX2RhdGEgYW5kIF9yZW1vdmVEYXRhIGhhdmUgYmVlbiByZXBsYWNlZFxuXHQvLyB3aXRoIGRpcmVjdCBjYWxscyB0byBkYXRhUHJpdiBtZXRob2RzLCB0aGVzZSBjYW4gYmUgZGVwcmVjYXRlZC5cblx0X2RhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcblx0fSxcblxuXHRfcmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBuYW1lICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRkYXRhOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHR2YXIgaSwgbmFtZSwgZGF0YSxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRhdHRycyA9IGVsZW0gJiYgZWxlbS5hdHRyaWJ1dGVzO1xuXG5cdFx0Ly8gR2V0cyBhbGwgdmFsdWVzXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggdGhpcy5sZW5ndGggKSB7XG5cdFx0XHRcdGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0gKTtcblxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgIWRhdGFQcml2LmdldCggZWxlbSwgXCJoYXNEYXRhQXR0cnNcIiApICkge1xuXHRcdFx0XHRcdGkgPSBhdHRycy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDExIG9ubHlcblx0XHRcdFx0XHRcdC8vIFRoZSBhdHRycyBlbGVtZW50cyBjYW4gYmUgbnVsbCAoIzE0ODk0KVxuXHRcdFx0XHRcdFx0aWYgKCBhdHRyc1sgaSBdICkge1xuXHRcdFx0XHRcdFx0XHRuYW1lID0gYXR0cnNbIGkgXS5uYW1lO1xuXHRcdFx0XHRcdFx0XHRpZiAoIG5hbWUuaW5kZXhPZiggXCJkYXRhLVwiICkgPT09IDAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bmFtZSA9IGNhbWVsQ2FzZSggbmFtZS5zbGljZSggNSApICk7XG5cdFx0XHRcdFx0XHRcdFx0ZGF0YUF0dHIoIGVsZW0sIG5hbWUsIGRhdGFbIG5hbWUgXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRhdGFQcml2LnNldCggZWxlbSwgXCJoYXNEYXRhQXR0cnNcIiwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH1cblxuXHRcdC8vIFNldHMgbXVsdGlwbGUgdmFsdWVzXG5cdFx0aWYgKCB0eXBlb2Yga2V5ID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRhdGFVc2VyLnNldCggdGhpcywga2V5ICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGRhdGE7XG5cblx0XHRcdC8vIFRoZSBjYWxsaW5nIGpRdWVyeSBvYmplY3QgKGVsZW1lbnQgbWF0Y2hlcykgaXMgbm90IGVtcHR5XG5cdFx0XHQvLyAoYW5kIHRoZXJlZm9yZSBoYXMgYW4gZWxlbWVudCBhcHBlYXJzIGF0IHRoaXNbIDAgXSkgYW5kIHRoZVxuXHRcdFx0Ly8gYHZhbHVlYCBwYXJhbWV0ZXIgd2FzIG5vdCB1bmRlZmluZWQuIEFuIGVtcHR5IGpRdWVyeSBvYmplY3Rcblx0XHRcdC8vIHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGZvciBlbGVtID0gdGhpc1sgMCBdIHdoaWNoIHdpbGxcblx0XHRcdC8vIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhbiBhdHRlbXB0IHRvIHJlYWQgYSBkYXRhIGNhY2hlIGlzIG1hZGUuXG5cdFx0XHRpZiAoIGVsZW0gJiYgdmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIGdldCBkYXRhIGZyb20gdGhlIGNhY2hlXG5cdFx0XHRcdC8vIFRoZSBrZXkgd2lsbCBhbHdheXMgYmUgY2FtZWxDYXNlZCBpbiBEYXRhXG5cdFx0XHRcdGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0sIGtleSApO1xuXHRcdFx0XHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEF0dGVtcHQgdG8gXCJkaXNjb3ZlclwiIHRoZSBkYXRhIGluXG5cdFx0XHRcdC8vIEhUTUw1IGN1c3RvbSBkYXRhLSogYXR0cnNcblx0XHRcdFx0ZGF0YSA9IGRhdGFBdHRyKCBlbGVtLCBrZXkgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBXZSB0cmllZCByZWFsbHkgaGFyZCwgYnV0IHRoZSBkYXRhIGRvZXNuJ3QgZXhpc3QuXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IHRoZSBkYXRhLi4uXG5cdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIFdlIGFsd2F5cyBzdG9yZSB0aGUgY2FtZWxDYXNlZCBrZXlcblx0XHRcdFx0ZGF0YVVzZXIuc2V0KCB0aGlzLCBrZXksIHZhbHVlICk7XG5cdFx0XHR9ICk7XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxLCBudWxsLCB0cnVlICk7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGtleSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGRhdGFVc2VyLnJlbW92ZSggdGhpcywga2V5ICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIHF1ZXVlO1xuXG5cdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0dHlwZSA9ICggdHlwZSB8fCBcImZ4XCIgKSArIFwicXVldWVcIjtcblx0XHRcdHF1ZXVlID0gZGF0YVByaXYuZ2V0KCBlbGVtLCB0eXBlICk7XG5cblx0XHRcdC8vIFNwZWVkIHVwIGRlcXVldWUgYnkgZ2V0dGluZyBvdXQgcXVpY2tseSBpZiB0aGlzIGlzIGp1c3QgYSBsb29rdXBcblx0XHRcdGlmICggZGF0YSApIHtcblx0XHRcdFx0aWYgKCAhcXVldWUgfHwgQXJyYXkuaXNBcnJheSggZGF0YSApICkge1xuXHRcdFx0XHRcdHF1ZXVlID0gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCB0eXBlLCBqUXVlcnkubWFrZUFycmF5KCBkYXRhICkgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBkYXRhICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBxdWV1ZSB8fCBbXTtcblx0XHR9XG5cdH0sXG5cblx0ZGVxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCBlbGVtLCB0eXBlICksXG5cdFx0XHRzdGFydExlbmd0aCA9IHF1ZXVlLmxlbmd0aCxcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKSxcblx0XHRcdGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKCBlbGVtLCB0eXBlICksXG5cdFx0XHRuZXh0ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCBlbGVtLCB0eXBlICk7XG5cdFx0XHR9O1xuXG5cdFx0Ly8gSWYgdGhlIGZ4IHF1ZXVlIGlzIGRlcXVldWVkLCBhbHdheXMgcmVtb3ZlIHRoZSBwcm9ncmVzcyBzZW50aW5lbFxuXHRcdGlmICggZm4gPT09IFwiaW5wcm9ncmVzc1wiICkge1xuXHRcdFx0Zm4gPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0c3RhcnRMZW5ndGgtLTtcblx0XHR9XG5cblx0XHRpZiAoIGZuICkge1xuXG5cdFx0XHQvLyBBZGQgYSBwcm9ncmVzcyBzZW50aW5lbCB0byBwcmV2ZW50IHRoZSBmeCBxdWV1ZSBmcm9tIGJlaW5nXG5cdFx0XHQvLyBhdXRvbWF0aWNhbGx5IGRlcXVldWVkXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwiZnhcIiApIHtcblx0XHRcdFx0cXVldWUudW5zaGlmdCggXCJpbnByb2dyZXNzXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2xlYXIgdXAgdGhlIGxhc3QgcXVldWUgc3RvcCBmdW5jdGlvblxuXHRcdFx0ZGVsZXRlIGhvb2tzLnN0b3A7XG5cdFx0XHRmbi5jYWxsKCBlbGVtLCBuZXh0LCBob29rcyApO1xuXHRcdH1cblxuXHRcdGlmICggIXN0YXJ0TGVuZ3RoICYmIGhvb2tzICkge1xuXHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBOb3QgcHVibGljIC0gZ2VuZXJhdGUgYSBxdWV1ZUhvb2tzIG9iamVjdCwgb3IgcmV0dXJuIHRoZSBjdXJyZW50IG9uZVxuXHRfcXVldWVIb29rczogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XG5cdFx0dmFyIGtleSA9IHR5cGUgKyBcInF1ZXVlSG9va3NcIjtcblx0XHRyZXR1cm4gZGF0YVByaXYuZ2V0KCBlbGVtLCBrZXkgKSB8fCBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIGtleSwge1xuXHRcdFx0ZW1wdHk6IGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLmFkZCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgWyB0eXBlICsgXCJxdWV1ZVwiLCBrZXkgXSApO1xuXHRcdFx0fSApXG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0cXVldWU6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBzZXR0ZXIgPSAyO1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGRhdGEgPSB0eXBlO1xuXHRcdFx0dHlwZSA9IFwiZnhcIjtcblx0XHRcdHNldHRlci0tO1xuXHRcdH1cblxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA8IHNldHRlciApIHtcblx0XHRcdHJldHVybiBqUXVlcnkucXVldWUoIHRoaXNbIDAgXSwgdHlwZSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBkYXRhID09PSB1bmRlZmluZWQgP1xuXHRcdFx0dGhpcyA6XG5cdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIGRhdGEgKTtcblxuXHRcdFx0XHQvLyBFbnN1cmUgYSBob29rcyBmb3IgdGhpcyBxdWV1ZVxuXHRcdFx0XHRqUXVlcnkuX3F1ZXVlSG9va3MoIHRoaXMsIHR5cGUgKTtcblxuXHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiZnhcIiAmJiBxdWV1ZVsgMCBdICE9PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdH0sXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHR9ICk7XG5cdH0sXG5cdGNsZWFyUXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0fSxcblxuXHQvLyBHZXQgYSBwcm9taXNlIHJlc29sdmVkIHdoZW4gcXVldWVzIG9mIGEgY2VydGFpbiB0eXBlXG5cdC8vIGFyZSBlbXB0aWVkIChmeCBpcyB0aGUgdHlwZSBieSBkZWZhdWx0KVxuXHRwcm9taXNlOiBmdW5jdGlvbiggdHlwZSwgb2JqICkge1xuXHRcdHZhciB0bXAsXG5cdFx0XHRjb3VudCA9IDEsXG5cdFx0XHRkZWZlciA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXHRcdFx0ZWxlbWVudHMgPSB0aGlzLFxuXHRcdFx0aSA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0cmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICEoIC0tY291bnQgKSApIHtcblx0XHRcdFx0XHRkZWZlci5yZXNvbHZlV2l0aCggZWxlbWVudHMsIFsgZWxlbWVudHMgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG9iaiA9IHR5cGU7XG5cdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHRtcCA9IGRhdGFQcml2LmdldCggZWxlbWVudHNbIGkgXSwgdHlwZSArIFwicXVldWVIb29rc1wiICk7XG5cdFx0XHRpZiAoIHRtcCAmJiB0bXAuZW1wdHkgKSB7XG5cdFx0XHRcdGNvdW50Kys7XG5cdFx0XHRcdHRtcC5lbXB0eS5hZGQoIHJlc29sdmUgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmVzb2x2ZSgpO1xuXHRcdHJldHVybiBkZWZlci5wcm9taXNlKCBvYmogKTtcblx0fVxufSApO1xudmFyIHBudW0gPSAoIC9bKy1dPyg/OlxcZCpcXC58KVxcZCsoPzpbZUVdWystXT9cXGQrfCkvICkuc291cmNlO1xuXG52YXIgcmNzc051bSA9IG5ldyBSZWdFeHAoIFwiXig/OihbKy1dKT18KShcIiArIHBudW0gKyBcIikoW2EteiVdKikkXCIsIFwiaVwiICk7XG5cblxudmFyIGNzc0V4cGFuZCA9IFsgXCJUb3BcIiwgXCJSaWdodFwiLCBcIkJvdHRvbVwiLCBcIkxlZnRcIiBdO1xuXG52YXIgZG9jdW1lbnRFbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG5cblxuXHR2YXIgaXNBdHRhY2hlZCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7XG5cdFx0fSxcblx0XHRjb21wb3NlZCA9IHsgY29tcG9zZWQ6IHRydWUgfTtcblxuXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTErLCBFZGdlIDEyIC0gMTgrLCBpT1MgMTAuMCAtIDEwLjIgb25seVxuXHQvLyBDaGVjayBhdHRhY2htZW50IGFjcm9zcyBzaGFkb3cgRE9NIGJvdW5kYXJpZXMgd2hlbiBwb3NzaWJsZSAoZ2gtMzUwNClcblx0Ly8gU3VwcG9ydDogaU9TIDEwLjAtMTAuMiBvbmx5XG5cdC8vIEVhcmx5IGlPUyAxMCB2ZXJzaW9ucyBzdXBwb3J0IGBhdHRhY2hTaGFkb3dgIGJ1dCBub3QgYGdldFJvb3ROb2RlYCxcblx0Ly8gbGVhZGluZyB0byBlcnJvcnMuIFdlIG5lZWQgdG8gY2hlY2sgZm9yIGBnZXRSb290Tm9kZWAuXG5cdGlmICggZG9jdW1lbnRFbGVtZW50LmdldFJvb3ROb2RlICkge1xuXHRcdGlzQXR0YWNoZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApIHx8XG5cdFx0XHRcdGVsZW0uZ2V0Um9vdE5vZGUoIGNvbXBvc2VkICkgPT09IGVsZW0ub3duZXJEb2N1bWVudDtcblx0XHR9O1xuXHR9XG52YXIgaXNIaWRkZW5XaXRoaW5UcmVlID0gZnVuY3Rpb24oIGVsZW0sIGVsICkge1xuXG5cdFx0Ly8gaXNIaWRkZW5XaXRoaW5UcmVlIG1pZ2h0IGJlIGNhbGxlZCBmcm9tIGpRdWVyeSNmaWx0ZXIgZnVuY3Rpb247XG5cdFx0Ly8gaW4gdGhhdCBjYXNlLCBlbGVtZW50IHdpbGwgYmUgc2Vjb25kIGFyZ3VtZW50XG5cdFx0ZWxlbSA9IGVsIHx8IGVsZW07XG5cblx0XHQvLyBJbmxpbmUgc3R5bGUgdHJ1bXBzIGFsbFxuXHRcdHJldHVybiBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwibm9uZVwiIHx8XG5cdFx0XHRlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiZcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlLCBjaGVjayBjb21wdXRlZCBzdHlsZVxuXHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTQzIC0gNDVcblx0XHRcdC8vIERpc2Nvbm5lY3RlZCBlbGVtZW50cyBjYW4gaGF2ZSBjb21wdXRlZCBkaXNwbGF5OiBub25lLCBzbyBmaXJzdCBjb25maXJtIHRoYXQgZWxlbSBpc1xuXHRcdFx0Ly8gaW4gdGhlIGRvY3VtZW50LlxuXHRcdFx0aXNBdHRhY2hlZCggZWxlbSApICYmXG5cblx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgPT09IFwibm9uZVwiO1xuXHR9O1xuXG5cblxuZnVuY3Rpb24gYWRqdXN0Q1NTKCBlbGVtLCBwcm9wLCB2YWx1ZVBhcnRzLCB0d2VlbiApIHtcblx0dmFyIGFkanVzdGVkLCBzY2FsZSxcblx0XHRtYXhJdGVyYXRpb25zID0gMjAsXG5cdFx0Y3VycmVudFZhbHVlID0gdHdlZW4gP1xuXHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0d2Vlbi5jdXIoKTtcblx0XHRcdH0gOlxuXHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBqUXVlcnkuY3NzKCBlbGVtLCBwcm9wLCBcIlwiICk7XG5cdFx0XHR9LFxuXHRcdGluaXRpYWwgPSBjdXJyZW50VmFsdWUoKSxcblx0XHR1bml0ID0gdmFsdWVQYXJ0cyAmJiB2YWx1ZVBhcnRzWyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICksXG5cblx0XHQvLyBTdGFydGluZyB2YWx1ZSBjb21wdXRhdGlvbiBpcyByZXF1aXJlZCBmb3IgcG90ZW50aWFsIHVuaXQgbWlzbWF0Y2hlc1xuXHRcdGluaXRpYWxJblVuaXQgPSBlbGVtLm5vZGVUeXBlICYmXG5cdFx0XHQoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSB8fCB1bml0ICE9PSBcInB4XCIgJiYgK2luaXRpYWwgKSAmJlxuXHRcdFx0cmNzc051bS5leGVjKCBqUXVlcnkuY3NzKCBlbGVtLCBwcm9wICkgKTtcblxuXHRpZiAoIGluaXRpYWxJblVuaXQgJiYgaW5pdGlhbEluVW5pdFsgMyBdICE9PSB1bml0ICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTU0XG5cdFx0Ly8gSGFsdmUgdGhlIGl0ZXJhdGlvbiB0YXJnZXQgdmFsdWUgdG8gcHJldmVudCBpbnRlcmZlcmVuY2UgZnJvbSBDU1MgdXBwZXIgYm91bmRzIChnaC0yMTQ0KVxuXHRcdGluaXRpYWwgPSBpbml0aWFsIC8gMjtcblxuXHRcdC8vIFRydXN0IHVuaXRzIHJlcG9ydGVkIGJ5IGpRdWVyeS5jc3Ncblx0XHR1bml0ID0gdW5pdCB8fCBpbml0aWFsSW5Vbml0WyAzIF07XG5cblx0XHQvLyBJdGVyYXRpdmVseSBhcHByb3hpbWF0ZSBmcm9tIGEgbm9uemVybyBzdGFydGluZyBwb2ludFxuXHRcdGluaXRpYWxJblVuaXQgPSAraW5pdGlhbCB8fCAxO1xuXG5cdFx0d2hpbGUgKCBtYXhJdGVyYXRpb25zLS0gKSB7XG5cblx0XHRcdC8vIEV2YWx1YXRlIGFuZCB1cGRhdGUgb3VyIGJlc3QgZ3Vlc3MgKGRvdWJsaW5nIGd1ZXNzZXMgdGhhdCB6ZXJvIG91dCkuXG5cdFx0XHQvLyBGaW5pc2ggaWYgdGhlIHNjYWxlIGVxdWFscyBvciBjcm9zc2VzIDEgKG1ha2luZyB0aGUgb2xkKm5ldyBwcm9kdWN0IG5vbi1wb3NpdGl2ZSkuXG5cdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIGluaXRpYWxJblVuaXQgKyB1bml0ICk7XG5cdFx0XHRpZiAoICggMSAtIHNjYWxlICkgKiAoIDEgLSAoIHNjYWxlID0gY3VycmVudFZhbHVlKCkgLyBpbml0aWFsIHx8IDAuNSApICkgPD0gMCApIHtcblx0XHRcdFx0bWF4SXRlcmF0aW9ucyA9IDA7XG5cdFx0XHR9XG5cdFx0XHRpbml0aWFsSW5Vbml0ID0gaW5pdGlhbEluVW5pdCAvIHNjYWxlO1xuXG5cdFx0fVxuXG5cdFx0aW5pdGlhbEluVW5pdCA9IGluaXRpYWxJblVuaXQgKiAyO1xuXHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgaW5pdGlhbEluVW5pdCArIHVuaXQgKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB3ZSB1cGRhdGUgdGhlIHR3ZWVuIHByb3BlcnRpZXMgbGF0ZXIgb25cblx0XHR2YWx1ZVBhcnRzID0gdmFsdWVQYXJ0cyB8fCBbXTtcblx0fVxuXG5cdGlmICggdmFsdWVQYXJ0cyApIHtcblx0XHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWxJblVuaXQgfHwgK2luaXRpYWwgfHwgMDtcblxuXHRcdC8vIEFwcGx5IHJlbGF0aXZlIG9mZnNldCAoKz0vLT0pIGlmIHNwZWNpZmllZFxuXHRcdGFkanVzdGVkID0gdmFsdWVQYXJ0c1sgMSBdID9cblx0XHRcdGluaXRpYWxJblVuaXQgKyAoIHZhbHVlUGFydHNbIDEgXSArIDEgKSAqIHZhbHVlUGFydHNbIDIgXSA6XG5cdFx0XHQrdmFsdWVQYXJ0c1sgMiBdO1xuXHRcdGlmICggdHdlZW4gKSB7XG5cdFx0XHR0d2Vlbi51bml0ID0gdW5pdDtcblx0XHRcdHR3ZWVuLnN0YXJ0ID0gaW5pdGlhbEluVW5pdDtcblx0XHRcdHR3ZWVuLmVuZCA9IGFkanVzdGVkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gYWRqdXN0ZWQ7XG59XG5cblxudmFyIGRlZmF1bHREaXNwbGF5TWFwID0ge307XG5cbmZ1bmN0aW9uIGdldERlZmF1bHREaXNwbGF5KCBlbGVtICkge1xuXHR2YXIgdGVtcCxcblx0XHRkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQsXG5cdFx0bm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLFxuXHRcdGRpc3BsYXkgPSBkZWZhdWx0RGlzcGxheU1hcFsgbm9kZU5hbWUgXTtcblxuXHRpZiAoIGRpc3BsYXkgKSB7XG5cdFx0cmV0dXJuIGRpc3BsYXk7XG5cdH1cblxuXHR0ZW1wID0gZG9jLmJvZHkuYXBwZW5kQ2hpbGQoIGRvYy5jcmVhdGVFbGVtZW50KCBub2RlTmFtZSApICk7XG5cdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCB0ZW1wLCBcImRpc3BsYXlcIiApO1xuXG5cdHRlbXAucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggdGVtcCApO1xuXG5cdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0ZGlzcGxheSA9IFwiYmxvY2tcIjtcblx0fVxuXHRkZWZhdWx0RGlzcGxheU1hcFsgbm9kZU5hbWUgXSA9IGRpc3BsYXk7XG5cblx0cmV0dXJuIGRpc3BsYXk7XG59XG5cbmZ1bmN0aW9uIHNob3dIaWRlKCBlbGVtZW50cywgc2hvdyApIHtcblx0dmFyIGRpc3BsYXksIGVsZW0sXG5cdFx0dmFsdWVzID0gW10sXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGVsZW1lbnRzLmxlbmd0aDtcblxuXHQvLyBEZXRlcm1pbmUgbmV3IGRpc3BsYXkgdmFsdWUgZm9yIGVsZW1lbnRzIHRoYXQgbmVlZCB0byBjaGFuZ2Vcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRlbGVtID0gZWxlbWVudHNbIGluZGV4IF07XG5cdFx0aWYgKCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGRpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXk7XG5cdFx0aWYgKCBzaG93ICkge1xuXG5cdFx0XHQvLyBTaW5jZSB3ZSBmb3JjZSB2aXNpYmlsaXR5IHVwb24gY2FzY2FkZS1oaWRkZW4gZWxlbWVudHMsIGFuIGltbWVkaWF0ZSAoYW5kIHNsb3cpXG5cdFx0XHQvLyBjaGVjayBpcyByZXF1aXJlZCBpbiB0aGlzIGZpcnN0IGxvb3AgdW5sZXNzIHdlIGhhdmUgYSBub25lbXB0eSBkaXNwbGF5IHZhbHVlIChlaXRoZXJcblx0XHRcdC8vIGlubGluZSBvciBhYm91dC10by1iZS1yZXN0b3JlZClcblx0XHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJkaXNwbGF5XCIgKSB8fCBudWxsO1xuXHRcdFx0XHRpZiAoICF2YWx1ZXNbIGluZGV4IF0gKSB7XG5cdFx0XHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiYgaXNIaWRkZW5XaXRoaW5UcmVlKCBlbGVtICkgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGdldERlZmF1bHREaXNwbGF5KCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICggZGlzcGxheSAhPT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IFwibm9uZVwiO1xuXG5cdFx0XHRcdC8vIFJlbWVtYmVyIHdoYXQgd2UncmUgb3ZlcndyaXRpbmdcblx0XHRcdFx0ZGF0YVByaXYuc2V0KCBlbGVtLCBcImRpc3BsYXlcIiwgZGlzcGxheSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFNldCB0aGUgZGlzcGxheSBvZiB0aGUgZWxlbWVudHMgaW4gYSBzZWNvbmQgbG9vcCB0byBhdm9pZCBjb25zdGFudCByZWZsb3dcblx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoIHZhbHVlc1sgaW5kZXggXSAhPSBudWxsICkge1xuXHRcdFx0ZWxlbWVudHNbIGluZGV4IF0uc3R5bGUuZGlzcGxheSA9IHZhbHVlc1sgaW5kZXggXTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbWVudHM7XG59XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0c2hvdzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzLCB0cnVlICk7XG5cdH0sXG5cdGhpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcyApO1xuXHR9LFxuXHR0b2dnbGU6IGZ1bmN0aW9uKCBzdGF0ZSApIHtcblx0XHRpZiAoIHR5cGVvZiBzdGF0ZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRyZXR1cm4gc3RhdGUgPyB0aGlzLnNob3coKSA6IHRoaXMuaGlkZSgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBpc0hpZGRlbldpdGhpblRyZWUoIHRoaXMgKSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuc2hvdygpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuaGlkZSgpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufSApO1xudmFyIHJjaGVja2FibGVUeXBlID0gKCAvXig/OmNoZWNrYm94fHJhZGlvKSQvaSApO1xuXG52YXIgcnRhZ05hbWUgPSAoIC88KFthLXpdW15cXC9cXDA+XFx4MjBcXHRcXHJcXG5cXGZdKikvaSApO1xuXG52YXIgcnNjcmlwdFR5cGUgPSAoIC9eJHxebW9kdWxlJHxcXC8oPzpqYXZhfGVjbWEpc2NyaXB0L2kgKTtcblxuXG5cbiggZnVuY3Rpb24oKSB7XG5cdHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcblx0XHRkaXYgPSBmcmFnbWVudC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICksXG5cdFx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5XG5cdC8vIENoZWNrIHN0YXRlIGxvc3QgaWYgdGhlIG5hbWUgaXMgc2V0ICgjMTEyMTcpXG5cdC8vIFN1cHBvcnQ6IFdpbmRvd3MgV2ViIEFwcHMgKFdXQSlcblx0Ly8gYG5hbWVgIGFuZCBgdHlwZWAgbXVzdCB1c2UgLnNldEF0dHJpYnV0ZSBmb3IgV1dBICgjMTQ5MDEpXG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIFwicmFkaW9cIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwiY2hlY2tlZFwiLCBcImNoZWNrZWRcIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcInRcIiApO1xuXG5cdGRpdi5hcHBlbmRDaGlsZCggaW5wdXQgKTtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4xIG9ubHlcblx0Ly8gT2xkZXIgV2ViS2l0IGRvZXNuJ3QgY2xvbmUgY2hlY2tlZCBzdGF0ZSBjb3JyZWN0bHkgaW4gZnJhZ21lbnRzXG5cdHN1cHBvcnQuY2hlY2tDbG9uZSA9IGRpdi5jbG9uZU5vZGUoIHRydWUgKS5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuY2hlY2tlZDtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gTWFrZSBzdXJlIHRleHRhcmVhIChhbmQgY2hlY2tib3gpIGRlZmF1bHRWYWx1ZSBpcyBwcm9wZXJseSBjbG9uZWRcblx0ZGl2LmlubmVySFRNTCA9IFwiPHRleHRhcmVhPng8L3RleHRhcmVhPlwiO1xuXHRzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkID0gISFkaXYuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmRlZmF1bHRWYWx1ZTtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHQvLyBJRSA8PTkgcmVwbGFjZXMgPG9wdGlvbj4gdGFncyB3aXRoIHRoZWlyIGNvbnRlbnRzIHdoZW4gaW5zZXJ0ZWQgb3V0c2lkZSBvZlxuXHQvLyB0aGUgc2VsZWN0IGVsZW1lbnQuXG5cdGRpdi5pbm5lckhUTUwgPSBcIjxvcHRpb24+PC9vcHRpb24+XCI7XG5cdHN1cHBvcnQub3B0aW9uID0gISFkaXYubGFzdENoaWxkO1xufSApKCk7XG5cblxuLy8gV2UgaGF2ZSB0byBjbG9zZSB0aGVzZSB0YWdzIHRvIHN1cHBvcnQgWEhUTUwgKCMxMzIwMClcbnZhciB3cmFwTWFwID0ge1xuXG5cdC8vIFhIVE1MIHBhcnNlcnMgZG8gbm90IG1hZ2ljYWxseSBpbnNlcnQgZWxlbWVudHMgaW4gdGhlXG5cdC8vIHNhbWUgd2F5IHRoYXQgdGFnIHNvdXAgcGFyc2VycyBkby4gU28gd2UgY2Fubm90IHNob3J0ZW5cblx0Ly8gdGhpcyBieSBvbWl0dGluZyA8dGJvZHk+IG9yIG90aGVyIHJlcXVpcmVkIGVsZW1lbnRzLlxuXHR0aGVhZDogWyAxLCBcIjx0YWJsZT5cIiwgXCI8L3RhYmxlPlwiIF0sXG5cdGNvbDogWyAyLCBcIjx0YWJsZT48Y29sZ3JvdXA+XCIsIFwiPC9jb2xncm91cD48L3RhYmxlPlwiIF0sXG5cdHRyOiBbIDIsIFwiPHRhYmxlPjx0Ym9keT5cIiwgXCI8L3Rib2R5PjwvdGFibGU+XCIgXSxcblx0dGQ6IFsgMywgXCI8dGFibGU+PHRib2R5Pjx0cj5cIiwgXCI8L3RyPjwvdGJvZHk+PC90YWJsZT5cIiBdLFxuXG5cdF9kZWZhdWx0OiBbIDAsIFwiXCIsIFwiXCIgXVxufTtcblxud3JhcE1hcC50Ym9keSA9IHdyYXBNYXAudGZvb3QgPSB3cmFwTWFwLmNvbGdyb3VwID0gd3JhcE1hcC5jYXB0aW9uID0gd3JhcE1hcC50aGVhZDtcbndyYXBNYXAudGggPSB3cmFwTWFwLnRkO1xuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuaWYgKCAhc3VwcG9ydC5vcHRpb24gKSB7XG5cdHdyYXBNYXAub3B0Z3JvdXAgPSB3cmFwTWFwLm9wdGlvbiA9IFsgMSwgXCI8c2VsZWN0IG11bHRpcGxlPSdtdWx0aXBsZSc+XCIsIFwiPC9zZWxlY3Q+XCIgXTtcbn1cblxuXG5mdW5jdGlvbiBnZXRBbGwoIGNvbnRleHQsIHRhZyApIHtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdC8vIFVzZSB0eXBlb2YgdG8gYXZvaWQgemVyby1hcmd1bWVudCBtZXRob2QgaW52b2NhdGlvbiBvbiBob3N0IG9iamVjdHMgKCMxNTE1MSlcblx0dmFyIHJldDtcblxuXHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdHJldCA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyB8fCBcIipcIiApO1xuXG5cdH0gZWxzZSBpZiAoIHR5cGVvZiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0cmV0ID0gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgfHwgXCIqXCIgKTtcblxuXHR9IGVsc2Uge1xuXHRcdHJldCA9IFtdO1xuXHR9XG5cblx0aWYgKCB0YWcgPT09IHVuZGVmaW5lZCB8fCB0YWcgJiYgbm9kZU5hbWUoIGNvbnRleHQsIHRhZyApICkge1xuXHRcdHJldHVybiBqUXVlcnkubWVyZ2UoIFsgY29udGV4dCBdLCByZXQgKTtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59XG5cblxuLy8gTWFyayBzY3JpcHRzIGFzIGhhdmluZyBhbHJlYWR5IGJlZW4gZXZhbHVhdGVkXG5mdW5jdGlvbiBzZXRHbG9iYWxFdmFsKCBlbGVtcywgcmVmRWxlbWVudHMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsID0gZWxlbXMubGVuZ3RoO1xuXG5cdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRkYXRhUHJpdi5zZXQoXG5cdFx0XHRlbGVtc1sgaSBdLFxuXHRcdFx0XCJnbG9iYWxFdmFsXCIsXG5cdFx0XHQhcmVmRWxlbWVudHMgfHwgZGF0YVByaXYuZ2V0KCByZWZFbGVtZW50c1sgaSBdLCBcImdsb2JhbEV2YWxcIiApXG5cdFx0KTtcblx0fVxufVxuXG5cbnZhciByaHRtbCA9IC88fCYjP1xcdys7LztcblxuZnVuY3Rpb24gYnVpbGRGcmFnbWVudCggZWxlbXMsIGNvbnRleHQsIHNjcmlwdHMsIHNlbGVjdGlvbiwgaWdub3JlZCApIHtcblx0dmFyIGVsZW0sIHRtcCwgdGFnLCB3cmFwLCBhdHRhY2hlZCwgaixcblx0XHRmcmFnbWVudCA9IGNvbnRleHQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuXHRcdG5vZGVzID0gW10sXG5cdFx0aSA9IDAsXG5cdFx0bCA9IGVsZW1zLmxlbmd0aDtcblxuXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1zWyBpIF07XG5cblx0XHRpZiAoIGVsZW0gfHwgZWxlbSA9PT0gMCApIHtcblxuXHRcdFx0Ly8gQWRkIG5vZGVzIGRpcmVjdGx5XG5cdFx0XHRpZiAoIHRvVHlwZSggZWxlbSApID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIGVsZW0ubm9kZVR5cGUgPyBbIGVsZW0gXSA6IGVsZW0gKTtcblxuXHRcdFx0Ly8gQ29udmVydCBub24taHRtbCBpbnRvIGEgdGV4dCBub2RlXG5cdFx0XHR9IGVsc2UgaWYgKCAhcmh0bWwudGVzdCggZWxlbSApICkge1xuXHRcdFx0XHRub2Rlcy5wdXNoKCBjb250ZXh0LmNyZWF0ZVRleHROb2RlKCBlbGVtICkgKTtcblxuXHRcdFx0Ly8gQ29udmVydCBodG1sIGludG8gRE9NIG5vZGVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0bXAgPSB0bXAgfHwgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGNvbnRleHQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICk7XG5cblx0XHRcdFx0Ly8gRGVzZXJpYWxpemUgYSBzdGFuZGFyZCByZXByZXNlbnRhdGlvblxuXHRcdFx0XHR0YWcgPSAoIHJ0YWdOYW1lLmV4ZWMoIGVsZW0gKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0d3JhcCA9IHdyYXBNYXBbIHRhZyBdIHx8IHdyYXBNYXAuX2RlZmF1bHQ7XG5cdFx0XHRcdHRtcC5pbm5lckhUTUwgPSB3cmFwWyAxIF0gKyBqUXVlcnkuaHRtbFByZWZpbHRlciggZWxlbSApICsgd3JhcFsgMiBdO1xuXG5cdFx0XHRcdC8vIERlc2NlbmQgdGhyb3VnaCB3cmFwcGVycyB0byB0aGUgcmlnaHQgY29udGVudFxuXHRcdFx0XHRqID0gd3JhcFsgMCBdO1xuXHRcdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0XHR0bXAgPSB0bXAubGFzdENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBub2RlcywgdG1wLmNoaWxkTm9kZXMgKTtcblxuXHRcdFx0XHQvLyBSZW1lbWJlciB0aGUgdG9wLWxldmVsIGNvbnRhaW5lclxuXHRcdFx0XHR0bXAgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0XHRcdC8vIEVuc3VyZSB0aGUgY3JlYXRlZCBub2RlcyBhcmUgb3JwaGFuZWQgKCMxMjM5Milcblx0XHRcdFx0dG1wLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBSZW1vdmUgd3JhcHBlciBmcm9tIGZyYWdtZW50XG5cdGZyYWdtZW50LnRleHRDb250ZW50ID0gXCJcIjtcblxuXHRpID0gMDtcblx0d2hpbGUgKCAoIGVsZW0gPSBub2Rlc1sgaSsrIF0gKSApIHtcblxuXHRcdC8vIFNraXAgZWxlbWVudHMgYWxyZWFkeSBpbiB0aGUgY29udGV4dCBjb2xsZWN0aW9uICh0cmFjLTQwODcpXG5cdFx0aWYgKCBzZWxlY3Rpb24gJiYgalF1ZXJ5LmluQXJyYXkoIGVsZW0sIHNlbGVjdGlvbiApID4gLTEgKSB7XG5cdFx0XHRpZiAoIGlnbm9yZWQgKSB7XG5cdFx0XHRcdGlnbm9yZWQucHVzaCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0YXR0YWNoZWQgPSBpc0F0dGFjaGVkKCBlbGVtICk7XG5cblx0XHQvLyBBcHBlbmQgdG8gZnJhZ21lbnRcblx0XHR0bXAgPSBnZXRBbGwoIGZyYWdtZW50LmFwcGVuZENoaWxkKCBlbGVtICksIFwic2NyaXB0XCIgKTtcblxuXHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRpZiAoIGF0dGFjaGVkICkge1xuXHRcdFx0c2V0R2xvYmFsRXZhbCggdG1wICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FwdHVyZSBleGVjdXRhYmxlc1xuXHRcdGlmICggc2NyaXB0cyApIHtcblx0XHRcdGogPSAwO1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0bXBbIGorKyBdICkgKSB7XG5cdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggZWxlbS50eXBlIHx8IFwiXCIgKSApIHtcblx0XHRcdFx0XHRzY3JpcHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBmcmFnbWVudDtcbn1cblxuXG52YXJcblx0cmtleUV2ZW50ID0gL15rZXkvLFxuXHRybW91c2VFdmVudCA9IC9eKD86bW91c2V8cG9pbnRlcnxjb250ZXh0bWVudXxkcmFnfGRyb3ApfGNsaWNrLyxcblx0cnR5cGVuYW1lc3BhY2UgPSAvXihbXi5dKikoPzpcXC4oLispfCkvO1xuXG5mdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG5cdHJldHVybiBmYWxzZTtcbn1cblxuLy8gU3VwcG9ydDogSUUgPD05IC0gMTErXG4vLyBmb2N1cygpIGFuZCBibHVyKCkgYXJlIGFzeW5jaHJvbm91cywgZXhjZXB0IHdoZW4gdGhleSBhcmUgbm8tb3AuXG4vLyBTbyBleHBlY3QgZm9jdXMgdG8gYmUgc3luY2hyb25vdXMgd2hlbiB0aGUgZWxlbWVudCBpcyBhbHJlYWR5IGFjdGl2ZSxcbi8vIGFuZCBibHVyIHRvIGJlIHN5bmNocm9ub3VzIHdoZW4gdGhlIGVsZW1lbnQgaXMgbm90IGFscmVhZHkgYWN0aXZlLlxuLy8gKGZvY3VzIGFuZCBibHVyIGFyZSBhbHdheXMgc3luY2hyb25vdXMgaW4gb3RoZXIgc3VwcG9ydGVkIGJyb3dzZXJzLFxuLy8gdGhpcyBqdXN0IGRlZmluZXMgd2hlbiB3ZSBjYW4gY291bnQgb24gaXQpLlxuZnVuY3Rpb24gZXhwZWN0U3luYyggZWxlbSwgdHlwZSApIHtcblx0cmV0dXJuICggZWxlbSA9PT0gc2FmZUFjdGl2ZUVsZW1lbnQoKSApID09PSAoIHR5cGUgPT09IFwiZm9jdXNcIiApO1xufVxuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuLy8gQWNjZXNzaW5nIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgY2FuIHRocm93IHVuZXhwZWN0ZWRseVxuLy8gaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEzMzkzXG5mdW5jdGlvbiBzYWZlQWN0aXZlRWxlbWVudCgpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblx0fSBjYXRjaCAoIGVyciApIHsgfVxufVxuXG5mdW5jdGlvbiBvbiggZWxlbSwgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgb25lICkge1xuXHR2YXIgb3JpZ0ZuLCB0eXBlO1xuXG5cdC8vIFR5cGVzIGNhbiBiZSBhIG1hcCBvZiB0eXBlcy9oYW5kbGVyc1xuXHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vICggdHlwZXMtT2JqZWN0LCBzZWxlY3RvciwgZGF0YSApXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMtT2JqZWN0LCBkYXRhIClcblx0XHRcdGRhdGEgPSBkYXRhIHx8IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRvbiggZWxlbSwgdHlwZSwgc2VsZWN0b3IsIGRhdGEsIHR5cGVzWyB0eXBlIF0sIG9uZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gZWxlbTtcblx0fVxuXG5cdGlmICggZGF0YSA9PSBudWxsICYmIGZuID09IG51bGwgKSB7XG5cblx0XHQvLyAoIHR5cGVzLCBmbiApXG5cdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRkYXRhID0gc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdH0gZWxzZSBpZiAoIGZuID09IG51bGwgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMsIHNlbGVjdG9yLCBmbiApXG5cdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vICggdHlwZXMsIGRhdGEsIGZuIClcblx0XHRcdGZuID0gZGF0YTtcblx0XHRcdGRhdGEgPSBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHR9IGVsc2UgaWYgKCAhZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW07XG5cdH1cblxuXHRpZiAoIG9uZSA9PT0gMSApIHtcblx0XHRvcmlnRm4gPSBmbjtcblx0XHRmbiA9IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0Ly8gQ2FuIHVzZSBhbiBlbXB0eSBzZXQsIHNpbmNlIGV2ZW50IGNvbnRhaW5zIHRoZSBpbmZvXG5cdFx0XHRqUXVlcnkoKS5vZmYoIGV2ZW50ICk7XG5cdFx0XHRyZXR1cm4gb3JpZ0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9O1xuXG5cdFx0Ly8gVXNlIHNhbWUgZ3VpZCBzbyBjYWxsZXIgY2FuIHJlbW92ZSB1c2luZyBvcmlnRm5cblx0XHRmbi5ndWlkID0gb3JpZ0ZuLmd1aWQgfHwgKCBvcmlnRm4uZ3VpZCA9IGpRdWVyeS5ndWlkKysgKTtcblx0fVxuXHRyZXR1cm4gZWxlbS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRqUXVlcnkuZXZlbnQuYWRkKCB0aGlzLCB0eXBlcywgZm4sIGRhdGEsIHNlbGVjdG9yICk7XG5cdH0gKTtcbn1cblxuLypcbiAqIEhlbHBlciBmdW5jdGlvbnMgZm9yIG1hbmFnaW5nIGV2ZW50cyAtLSBub3QgcGFydCBvZiB0aGUgcHVibGljIGludGVyZmFjZS5cbiAqIFByb3BzIHRvIERlYW4gRWR3YXJkcycgYWRkRXZlbnQgbGlicmFyeSBmb3IgbWFueSBvZiB0aGUgaWRlYXMuXG4gKi9cbmpRdWVyeS5ldmVudCA9IHtcblxuXHRnbG9iYWw6IHt9LFxuXG5cdGFkZDogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBkYXRhLCBzZWxlY3RvciApIHtcblxuXHRcdHZhciBoYW5kbGVPYmpJbiwgZXZlbnRIYW5kbGUsIHRtcCxcblx0XHRcdGV2ZW50cywgdCwgaGFuZGxlT2JqLFxuXHRcdFx0c3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuXHRcdFx0ZWxlbURhdGEgPSBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdC8vIE9ubHkgYXR0YWNoIGV2ZW50cyB0byBvYmplY3RzIHRoYXQgYWNjZXB0IGRhdGFcblx0XHRpZiAoICFhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGFuIG9iamVjdCBvZiBjdXN0b20gZGF0YSBpbiBsaWV1IG9mIHRoZSBoYW5kbGVyXG5cdFx0aWYgKCBoYW5kbGVyLmhhbmRsZXIgKSB7XG5cdFx0XHRoYW5kbGVPYmpJbiA9IGhhbmRsZXI7XG5cdFx0XHRoYW5kbGVyID0gaGFuZGxlT2JqSW4uaGFuZGxlcjtcblx0XHRcdHNlbGVjdG9yID0gaGFuZGxlT2JqSW4uc2VsZWN0b3I7XG5cdFx0fVxuXG5cdFx0Ly8gRW5zdXJlIHRoYXQgaW52YWxpZCBzZWxlY3RvcnMgdGhyb3cgZXhjZXB0aW9ucyBhdCBhdHRhY2ggdGltZVxuXHRcdC8vIEV2YWx1YXRlIGFnYWluc3QgZG9jdW1lbnRFbGVtZW50IGluIGNhc2UgZWxlbSBpcyBhIG5vbi1lbGVtZW50IG5vZGUgKGUuZy4sIGRvY3VtZW50KVxuXHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGRvY3VtZW50RWxlbWVudCwgc2VsZWN0b3IgKTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB0aGUgaGFuZGxlciBoYXMgYSB1bmlxdWUgSUQsIHVzZWQgdG8gZmluZC9yZW1vdmUgaXQgbGF0ZXJcblx0XHRpZiAoICFoYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRoYW5kbGVyLmd1aWQgPSBqUXVlcnkuZ3VpZCsrO1xuXHRcdH1cblxuXHRcdC8vIEluaXQgdGhlIGVsZW1lbnQncyBldmVudCBzdHJ1Y3R1cmUgYW5kIG1haW4gaGFuZGxlciwgaWYgdGhpcyBpcyB0aGUgZmlyc3Rcblx0XHRpZiAoICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuXHRcdFx0ZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzID0gT2JqZWN0LmNyZWF0ZSggbnVsbCApO1xuXHRcdH1cblx0XHRpZiAoICEoIGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlICkgKSB7XG5cdFx0XHRldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSA9IGZ1bmN0aW9uKCBlICkge1xuXG5cdFx0XHRcdC8vIERpc2NhcmQgdGhlIHNlY29uZCBldmVudCBvZiBhIGpRdWVyeS5ldmVudC50cmlnZ2VyKCkgYW5kXG5cdFx0XHRcdC8vIHdoZW4gYW4gZXZlbnQgaXMgY2FsbGVkIGFmdGVyIGEgcGFnZSBoYXMgdW5sb2FkZWRcblx0XHRcdFx0cmV0dXJuIHR5cGVvZiBqUXVlcnkgIT09IFwidW5kZWZpbmVkXCIgJiYgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCAhPT0gZS50eXBlID9cblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuZGlzcGF0Y2guYXBwbHkoIGVsZW0sIGFyZ3VtZW50cyApIDogdW5kZWZpbmVkO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvLyBIYW5kbGUgbXVsdGlwbGUgZXZlbnRzIHNlcGFyYXRlZCBieSBhIHNwYWNlXG5cdFx0dHlwZXMgPSAoIHR5cGVzIHx8IFwiXCIgKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1sgdCBdICkgfHwgW107XG5cdFx0XHR0eXBlID0gb3JpZ1R5cGUgPSB0bXBbIDEgXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsgMiBdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFRoZXJlICptdXN0KiBiZSBhIHR5cGUsIG5vIGF0dGFjaGluZyBuYW1lc3BhY2Utb25seSBoYW5kbGVyc1xuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGV2ZW50IGNoYW5nZXMgaXRzIHR5cGUsIHVzZSB0aGUgc3BlY2lhbCBldmVudCBoYW5kbGVycyBmb3IgdGhlIGNoYW5nZWQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIElmIHNlbGVjdG9yIGRlZmluZWQsIGRldGVybWluZSBzcGVjaWFsIGV2ZW50IGFwaSB0eXBlLCBvdGhlcndpc2UgZ2l2ZW4gdHlwZVxuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXG5cdFx0XHQvLyBVcGRhdGUgc3BlY2lhbCBiYXNlZCBvbiBuZXdseSByZXNldCB0eXBlXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gaGFuZGxlT2JqIGlzIHBhc3NlZCB0byBhbGwgZXZlbnQgaGFuZGxlcnNcblx0XHRcdGhhbmRsZU9iaiA9IGpRdWVyeS5leHRlbmQoIHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0b3JpZ1R5cGU6IG9yaWdUeXBlLFxuXHRcdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0XHRoYW5kbGVyOiBoYW5kbGVyLFxuXHRcdFx0XHRndWlkOiBoYW5kbGVyLmd1aWQsXG5cdFx0XHRcdHNlbGVjdG9yOiBzZWxlY3Rvcixcblx0XHRcdFx0bmVlZHNDb250ZXh0OiBzZWxlY3RvciAmJiBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSxcblx0XHRcdFx0bmFtZXNwYWNlOiBuYW1lc3BhY2VzLmpvaW4oIFwiLlwiIClcblx0XHRcdH0sIGhhbmRsZU9iakluICk7XG5cblx0XHRcdC8vIEluaXQgdGhlIGV2ZW50IGhhbmRsZXIgcXVldWUgaWYgd2UncmUgdGhlIGZpcnN0XG5cdFx0XHRpZiAoICEoIGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gKSApIHtcblx0XHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSA9IFtdO1xuXHRcdFx0XHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50ID0gMDtcblxuXHRcdFx0XHQvLyBPbmx5IHVzZSBhZGRFdmVudExpc3RlbmVyIGlmIHRoZSBzcGVjaWFsIGV2ZW50cyBoYW5kbGVyIHJldHVybnMgZmFsc2Vcblx0XHRcdFx0aWYgKCAhc3BlY2lhbC5zZXR1cCB8fFxuXHRcdFx0XHRcdHNwZWNpYWwuc2V0dXAuY2FsbCggZWxlbSwgZGF0YSwgbmFtZXNwYWNlcywgZXZlbnRIYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGVsZW0uYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdFx0XHRcdGVsZW0uYWRkRXZlbnRMaXN0ZW5lciggdHlwZSwgZXZlbnRIYW5kbGUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBzcGVjaWFsLmFkZCApIHtcblx0XHRcdFx0c3BlY2lhbC5hZGQuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cblx0XHRcdFx0aWYgKCAhaGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCApIHtcblx0XHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlci5ndWlkID0gaGFuZGxlci5ndWlkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCB0byB0aGUgZWxlbWVudCdzIGhhbmRsZXIgbGlzdCwgZGVsZWdhdGVzIGluIGZyb250XG5cdFx0XHRpZiAoIHNlbGVjdG9yICkge1xuXHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGhhbmRsZXJzLmRlbGVnYXRlQ291bnQrKywgMCwgaGFuZGxlT2JqICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRoYW5kbGVycy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gS2VlcCB0cmFjayBvZiB3aGljaCBldmVudHMgaGF2ZSBldmVyIGJlZW4gdXNlZCwgZm9yIGV2ZW50IG9wdGltaXphdGlvblxuXHRcdFx0alF1ZXJ5LmV2ZW50Lmdsb2JhbFsgdHlwZSBdID0gdHJ1ZTtcblx0XHR9XG5cblx0fSxcblxuXHQvLyBEZXRhY2ggYW4gZXZlbnQgb3Igc2V0IG9mIGV2ZW50cyBmcm9tIGFuIGVsZW1lbnRcblx0cmVtb3ZlOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIHNlbGVjdG9yLCBtYXBwZWRUeXBlcyApIHtcblxuXHRcdHZhciBqLCBvcmlnQ291bnQsIHRtcCxcblx0XHRcdGV2ZW50cywgdCwgaGFuZGxlT2JqLFxuXHRcdFx0c3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuXHRcdFx0ZWxlbURhdGEgPSBkYXRhUHJpdi5oYXNEYXRhKCBlbGVtICkgJiYgZGF0YVByaXYuZ2V0KCBlbGVtICk7XG5cblx0XHRpZiAoICFlbGVtRGF0YSB8fCAhKCBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBPbmNlIGZvciBlYWNoIHR5cGUubmFtZXNwYWNlIGluIHR5cGVzOyB0eXBlIG1heSBiZSBvbWl0dGVkXG5cdFx0dHlwZXMgPSAoIHR5cGVzIHx8IFwiXCIgKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1sgdCBdICkgfHwgW107XG5cdFx0XHR0eXBlID0gb3JpZ1R5cGUgPSB0bXBbIDEgXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsgMiBdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFVuYmluZCBhbGwgZXZlbnRzIChvbiB0aGlzIG5hbWVzcGFjZSwgaWYgcHJvdmlkZWQpIGZvciB0aGUgZWxlbWVudFxuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSArIHR5cGVzWyB0IF0sIGhhbmRsZXIsIHNlbGVjdG9yLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSB8fCBbXTtcblx0XHRcdHRtcCA9IHRtcFsgMiBdICYmXG5cdFx0XHRcdG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oIFwiXFxcXC4oPzouKlxcXFwufClcIiApICsgXCIoXFxcXC58JClcIiApO1xuXG5cdFx0XHQvLyBSZW1vdmUgbWF0Y2hpbmcgZXZlbnRzXG5cdFx0XHRvcmlnQ291bnQgPSBqID0gaGFuZGxlcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBqIF07XG5cblx0XHRcdFx0aWYgKCAoIG1hcHBlZFR5cGVzIHx8IG9yaWdUeXBlID09PSBoYW5kbGVPYmoub3JpZ1R5cGUgKSAmJlxuXHRcdFx0XHRcdCggIWhhbmRsZXIgfHwgaGFuZGxlci5ndWlkID09PSBoYW5kbGVPYmouZ3VpZCApICYmXG5cdFx0XHRcdFx0KCAhdG1wIHx8IHRtcC50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSAmJlxuXHRcdFx0XHRcdCggIXNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSBoYW5kbGVPYmouc2VsZWN0b3IgfHxcblx0XHRcdFx0XHRcdHNlbGVjdG9yID09PSBcIioqXCIgJiYgaGFuZGxlT2JqLnNlbGVjdG9yICkgKSB7XG5cdFx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBqLCAxICk7XG5cblx0XHRcdFx0XHRpZiAoIGhhbmRsZU9iai5zZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQtLTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBzcGVjaWFsLnJlbW92ZSApIHtcblx0XHRcdFx0XHRcdHNwZWNpYWwucmVtb3ZlLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZW1vdmUgZ2VuZXJpYyBldmVudCBoYW5kbGVyIGlmIHdlIHJlbW92ZWQgc29tZXRoaW5nIGFuZCBubyBtb3JlIGhhbmRsZXJzIGV4aXN0XG5cdFx0XHQvLyAoYXZvaWRzIHBvdGVudGlhbCBmb3IgZW5kbGVzcyByZWN1cnNpb24gZHVyaW5nIHJlbW92YWwgb2Ygc3BlY2lhbCBldmVudCBoYW5kbGVycylcblx0XHRcdGlmICggb3JpZ0NvdW50ICYmICFoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdGlmICggIXNwZWNpYWwudGVhcmRvd24gfHxcblx0XHRcdFx0XHRzcGVjaWFsLnRlYXJkb3duLmNhbGwoIGVsZW0sIG5hbWVzcGFjZXMsIGVsZW1EYXRhLmhhbmRsZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZWxlbURhdGEuaGFuZGxlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkZWxldGUgZXZlbnRzWyB0eXBlIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIGRhdGEgYW5kIHRoZSBleHBhbmRvIGlmIGl0J3Mgbm8gbG9uZ2VyIHVzZWRcblx0XHRpZiAoIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBldmVudHMgKSApIHtcblx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgXCJoYW5kbGUgZXZlbnRzXCIgKTtcblx0XHR9XG5cdH0sXG5cblx0ZGlzcGF0Y2g6IGZ1bmN0aW9uKCBuYXRpdmVFdmVudCApIHtcblxuXHRcdHZhciBpLCBqLCByZXQsIG1hdGNoZWQsIGhhbmRsZU9iaiwgaGFuZGxlclF1ZXVlLFxuXHRcdFx0YXJncyA9IG5ldyBBcnJheSggYXJndW1lbnRzLmxlbmd0aCApLFxuXG5cdFx0XHQvLyBNYWtlIGEgd3JpdGFibGUgalF1ZXJ5LkV2ZW50IGZyb20gdGhlIG5hdGl2ZSBldmVudCBvYmplY3Rcblx0XHRcdGV2ZW50ID0galF1ZXJ5LmV2ZW50LmZpeCggbmF0aXZlRXZlbnQgKSxcblxuXHRcdFx0aGFuZGxlcnMgPSAoXG5cdFx0XHRcdFx0ZGF0YVByaXYuZ2V0KCB0aGlzLCBcImV2ZW50c1wiICkgfHwgT2JqZWN0LmNyZWF0ZSggbnVsbCApXG5cdFx0XHRcdClbIGV2ZW50LnR5cGUgXSB8fCBbXSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZXZlbnQudHlwZSBdIHx8IHt9O1xuXG5cdFx0Ly8gVXNlIHRoZSBmaXgtZWQgalF1ZXJ5LkV2ZW50IHJhdGhlciB0aGFuIHRoZSAocmVhZC1vbmx5KSBuYXRpdmUgZXZlbnRcblx0XHRhcmdzWyAwIF0gPSBldmVudDtcblxuXHRcdGZvciAoIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrICkge1xuXHRcdFx0YXJnc1sgaSBdID0gYXJndW1lbnRzWyBpIF07XG5cdFx0fVxuXG5cdFx0ZXZlbnQuZGVsZWdhdGVUYXJnZXQgPSB0aGlzO1xuXG5cdFx0Ly8gQ2FsbCB0aGUgcHJlRGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlLCBhbmQgbGV0IGl0IGJhaWwgaWYgZGVzaXJlZFxuXHRcdGlmICggc3BlY2lhbC5wcmVEaXNwYXRjaCAmJiBzcGVjaWFsLnByZURpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBoYW5kbGVyc1xuXHRcdGhhbmRsZXJRdWV1ZSA9IGpRdWVyeS5ldmVudC5oYW5kbGVycy5jYWxsKCB0aGlzLCBldmVudCwgaGFuZGxlcnMgKTtcblxuXHRcdC8vIFJ1biBkZWxlZ2F0ZXMgZmlyc3Q7IHRoZXkgbWF5IHdhbnQgdG8gc3RvcCBwcm9wYWdhdGlvbiBiZW5lYXRoIHVzXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoIG1hdGNoZWQgPSBoYW5kbGVyUXVldWVbIGkrKyBdICkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRldmVudC5jdXJyZW50VGFyZ2V0ID0gbWF0Y2hlZC5lbGVtO1xuXG5cdFx0XHRqID0gMDtcblx0XHRcdHdoaWxlICggKCBoYW5kbGVPYmogPSBtYXRjaGVkLmhhbmRsZXJzWyBqKysgXSApICYmXG5cdFx0XHRcdCFldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXG5cdFx0XHRcdC8vIElmIHRoZSBldmVudCBpcyBuYW1lc3BhY2VkLCB0aGVuIGVhY2ggaGFuZGxlciBpcyBvbmx5IGludm9rZWQgaWYgaXQgaXNcblx0XHRcdFx0Ly8gc3BlY2lhbGx5IHVuaXZlcnNhbCBvciBpdHMgbmFtZXNwYWNlcyBhcmUgYSBzdXBlcnNldCBvZiB0aGUgZXZlbnQncy5cblx0XHRcdFx0aWYgKCAhZXZlbnQucm5hbWVzcGFjZSB8fCBoYW5kbGVPYmoubmFtZXNwYWNlID09PSBmYWxzZSB8fFxuXHRcdFx0XHRcdGV2ZW50LnJuYW1lc3BhY2UudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkge1xuXG5cdFx0XHRcdFx0ZXZlbnQuaGFuZGxlT2JqID0gaGFuZGxlT2JqO1xuXHRcdFx0XHRcdGV2ZW50LmRhdGEgPSBoYW5kbGVPYmouZGF0YTtcblxuXHRcdFx0XHRcdHJldCA9ICggKCBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgaGFuZGxlT2JqLm9yaWdUeXBlIF0gfHwge30gKS5oYW5kbGUgfHxcblx0XHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyICkuYXBwbHkoIG1hdGNoZWQuZWxlbSwgYXJncyApO1xuXG5cdFx0XHRcdFx0aWYgKCByZXQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdGlmICggKCBldmVudC5yZXN1bHQgPSByZXQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGwgdGhlIHBvc3REaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGVcblx0XHRpZiAoIHNwZWNpYWwucG9zdERpc3BhdGNoICkge1xuXHRcdFx0c3BlY2lhbC5wb3N0RGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdGhhbmRsZXJzOiBmdW5jdGlvbiggZXZlbnQsIGhhbmRsZXJzICkge1xuXHRcdHZhciBpLCBoYW5kbGVPYmosIHNlbCwgbWF0Y2hlZEhhbmRsZXJzLCBtYXRjaGVkU2VsZWN0b3JzLFxuXHRcdFx0aGFuZGxlclF1ZXVlID0gW10sXG5cdFx0XHRkZWxlZ2F0ZUNvdW50ID0gaGFuZGxlcnMuZGVsZWdhdGVDb3VudCxcblx0XHRcdGN1ciA9IGV2ZW50LnRhcmdldDtcblxuXHRcdC8vIEZpbmQgZGVsZWdhdGUgaGFuZGxlcnNcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgJiZcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05XG5cdFx0XHQvLyBCbGFjay1ob2xlIFNWRyA8dXNlPiBpbnN0YW5jZSB0cmVlcyAodHJhYy0xMzE4MClcblx0XHRcdGN1ci5ub2RlVHlwZSAmJlxuXG5cdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDJcblx0XHRcdC8vIFN1cHByZXNzIHNwZWMtdmlvbGF0aW5nIGNsaWNrcyBpbmRpY2F0aW5nIGEgbm9uLXByaW1hcnkgcG9pbnRlciBidXR0b24gKHRyYWMtMzg2MSlcblx0XHRcdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50LXR5cGUtY2xpY2tcblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExIG9ubHlcblx0XHRcdC8vIC4uLmJ1dCBub3QgYXJyb3cga2V5IFwiY2xpY2tzXCIgb2YgcmFkaW8gaW5wdXRzLCB3aGljaCBjYW4gaGF2ZSBgYnV0dG9uYCAtMSAoZ2gtMjM0Mylcblx0XHRcdCEoIGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIiAmJiBldmVudC5idXR0b24gPj0gMSApICkge1xuXG5cdFx0XHRmb3IgKCA7IGN1ciAhPT0gdGhpczsgY3VyID0gY3VyLnBhcmVudE5vZGUgfHwgdGhpcyApIHtcblxuXHRcdFx0XHQvLyBEb24ndCBjaGVjayBub24tZWxlbWVudHMgKCMxMzIwOClcblx0XHRcdFx0Ly8gRG9uJ3QgcHJvY2VzcyBjbGlja3Mgb24gZGlzYWJsZWQgZWxlbWVudHMgKCM2OTExLCAjODE2NSwgIzExMzgyLCAjMTE3NjQpXG5cdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlID09PSAxICYmICEoIGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIiAmJiBjdXIuZGlzYWJsZWQgPT09IHRydWUgKSApIHtcblx0XHRcdFx0XHRtYXRjaGVkSGFuZGxlcnMgPSBbXTtcblx0XHRcdFx0XHRtYXRjaGVkU2VsZWN0b3JzID0ge307XG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBkZWxlZ2F0ZUNvdW50OyBpKysgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoIzEzMjAzKVxuXHRcdFx0XHRcdFx0c2VsID0gaGFuZGxlT2JqLnNlbGVjdG9yICsgXCIgXCI7XG5cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gPSBoYW5kbGVPYmoubmVlZHNDb250ZXh0ID9cblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkoIHNlbCwgdGhpcyApLmluZGV4KCBjdXIgKSA+IC0xIDpcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZmluZCggc2VsLCB0aGlzLCBudWxsLCBbIGN1ciBdICkubGVuZ3RoO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZEhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRIYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBtYXRjaGVkSGFuZGxlcnMgfSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFkZCB0aGUgcmVtYWluaW5nIChkaXJlY3RseS1ib3VuZCkgaGFuZGxlcnNcblx0XHRjdXIgPSB0aGlzO1xuXHRcdGlmICggZGVsZWdhdGVDb3VudCA8IGhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKCB7IGVsZW06IGN1ciwgaGFuZGxlcnM6IGhhbmRsZXJzLnNsaWNlKCBkZWxlZ2F0ZUNvdW50ICkgfSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBoYW5kbGVyUXVldWU7XG5cdH0sXG5cblx0YWRkUHJvcDogZnVuY3Rpb24oIG5hbWUsIGhvb2sgKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBqUXVlcnkuRXZlbnQucHJvdG90eXBlLCBuYW1lLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXG5cdFx0XHRnZXQ6IGlzRnVuY3Rpb24oIGhvb2sgKSA/XG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gaG9vayggdGhpcy5vcmlnaW5hbEV2ZW50ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IDpcblx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzLm9yaWdpbmFsRXZlbnRbIG5hbWUgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsIG5hbWUsIHtcblx0XHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR2YWx1ZTogdmFsdWVcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRmaXg6IGZ1bmN0aW9uKCBvcmlnaW5hbEV2ZW50ICkge1xuXHRcdHJldHVybiBvcmlnaW5hbEV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cblx0XHRcdG9yaWdpbmFsRXZlbnQgOlxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCggb3JpZ2luYWxFdmVudCApO1xuXHR9LFxuXG5cdHNwZWNpYWw6IHtcblx0XHRsb2FkOiB7XG5cblx0XHRcdC8vIFByZXZlbnQgdHJpZ2dlcmVkIGltYWdlLmxvYWQgZXZlbnRzIGZyb20gYnViYmxpbmcgdG8gd2luZG93LmxvYWRcblx0XHRcdG5vQnViYmxlOiB0cnVlXG5cdFx0fSxcblx0XHRjbGljazoge1xuXG5cdFx0XHQvLyBVdGlsaXplIG5hdGl2ZSBldmVudCB0byBlbnN1cmUgY29ycmVjdCBzdGF0ZSBmb3IgY2hlY2thYmxlIGlucHV0c1xuXHRcdFx0c2V0dXA6IGZ1bmN0aW9uKCBkYXRhICkge1xuXG5cdFx0XHRcdC8vIEZvciBtdXR1YWwgY29tcHJlc3NpYmlsaXR5IHdpdGggX2RlZmF1bHQsIHJlcGxhY2UgYHRoaXNgIGFjY2VzcyB3aXRoIGEgbG9jYWwgdmFyLlxuXHRcdFx0XHQvLyBgfHwgZGF0YWAgaXMgZGVhZCBjb2RlIG1lYW50IG9ubHkgdG8gcHJlc2VydmUgdGhlIHZhcmlhYmxlIHRocm91Z2ggbWluaWZpY2F0aW9uLlxuXHRcdFx0XHR2YXIgZWwgPSB0aGlzIHx8IGRhdGE7XG5cblx0XHRcdFx0Ly8gQ2xhaW0gdGhlIGZpcnN0IGhhbmRsZXJcblx0XHRcdFx0aWYgKCByY2hlY2thYmxlVHlwZS50ZXN0KCBlbC50eXBlICkgJiZcblx0XHRcdFx0XHRlbC5jbGljayAmJiBub2RlTmFtZSggZWwsIFwiaW5wdXRcIiApICkge1xuXG5cdFx0XHRcdFx0Ly8gZGF0YVByaXYuc2V0KCBlbCwgXCJjbGlja1wiLCAuLi4gKVxuXHRcdFx0XHRcdGxldmVyYWdlTmF0aXZlKCBlbCwgXCJjbGlja1wiLCByZXR1cm5UcnVlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXR1cm4gZmFsc2UgdG8gYWxsb3cgbm9ybWFsIHByb2Nlc3NpbmcgaW4gdGhlIGNhbGxlclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9LFxuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oIGRhdGEgKSB7XG5cblx0XHRcdFx0Ly8gRm9yIG11dHVhbCBjb21wcmVzc2liaWxpdHkgd2l0aCBfZGVmYXVsdCwgcmVwbGFjZSBgdGhpc2AgYWNjZXNzIHdpdGggYSBsb2NhbCB2YXIuXG5cdFx0XHRcdC8vIGB8fCBkYXRhYCBpcyBkZWFkIGNvZGUgbWVhbnQgb25seSB0byBwcmVzZXJ2ZSB0aGUgdmFyaWFibGUgdGhyb3VnaCBtaW5pZmljYXRpb24uXG5cdFx0XHRcdHZhciBlbCA9IHRoaXMgfHwgZGF0YTtcblxuXHRcdFx0XHQvLyBGb3JjZSBzZXR1cCBiZWZvcmUgdHJpZ2dlcmluZyBhIGNsaWNrXG5cdFx0XHRcdGlmICggcmNoZWNrYWJsZVR5cGUudGVzdCggZWwudHlwZSApICYmXG5cdFx0XHRcdFx0ZWwuY2xpY2sgJiYgbm9kZU5hbWUoIGVsLCBcImlucHV0XCIgKSApIHtcblxuXHRcdFx0XHRcdGxldmVyYWdlTmF0aXZlKCBlbCwgXCJjbGlja1wiICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXR1cm4gbm9uLWZhbHNlIHRvIGFsbG93IG5vcm1hbCBldmVudC1wYXRoIHByb3BhZ2F0aW9uXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRm9yIGNyb3NzLWJyb3dzZXIgY29uc2lzdGVuY3ksIHN1cHByZXNzIG5hdGl2ZSAuY2xpY2soKSBvbiBsaW5rc1xuXHRcdFx0Ly8gQWxzbyBwcmV2ZW50IGl0IGlmIHdlJ3JlIGN1cnJlbnRseSBpbnNpZGUgYSBsZXZlcmFnZWQgbmF0aXZlLWV2ZW50IHN0YWNrXG5cdFx0XHRfZGVmYXVsdDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuXHRcdFx0XHRyZXR1cm4gcmNoZWNrYWJsZVR5cGUudGVzdCggdGFyZ2V0LnR5cGUgKSAmJlxuXHRcdFx0XHRcdHRhcmdldC5jbGljayAmJiBub2RlTmFtZSggdGFyZ2V0LCBcImlucHV0XCIgKSAmJlxuXHRcdFx0XHRcdGRhdGFQcml2LmdldCggdGFyZ2V0LCBcImNsaWNrXCIgKSB8fFxuXHRcdFx0XHRcdG5vZGVOYW1lKCB0YXJnZXQsIFwiYVwiICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGJlZm9yZXVubG9hZDoge1xuXHRcdFx0cG9zdERpc3BhdGNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCAyMCtcblx0XHRcdFx0Ly8gRmlyZWZveCBkb2Vzbid0IGFsZXJ0IGlmIHRoZSByZXR1cm5WYWx1ZSBmaWVsZCBpcyBub3Qgc2V0LlxuXHRcdFx0XHRpZiAoIGV2ZW50LnJlc3VsdCAhPT0gdW5kZWZpbmVkICYmIGV2ZW50Lm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0ZXZlbnQub3JpZ2luYWxFdmVudC5yZXR1cm5WYWx1ZSA9IGV2ZW50LnJlc3VsdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuLy8gRW5zdXJlIHRoZSBwcmVzZW5jZSBvZiBhbiBldmVudCBsaXN0ZW5lciB0aGF0IGhhbmRsZXMgbWFudWFsbHktdHJpZ2dlcmVkXG4vLyBzeW50aGV0aWMgZXZlbnRzIGJ5IGludGVycnVwdGluZyBwcm9ncmVzcyB1bnRpbCByZWludm9rZWQgaW4gcmVzcG9uc2UgdG9cbi8vICpuYXRpdmUqIGV2ZW50cyB0aGF0IGl0IGZpcmVzIGRpcmVjdGx5LCBlbnN1cmluZyB0aGF0IHN0YXRlIGNoYW5nZXMgaGF2ZVxuLy8gYWxyZWFkeSBvY2N1cnJlZCBiZWZvcmUgb3RoZXIgbGlzdGVuZXJzIGFyZSBpbnZva2VkLlxuZnVuY3Rpb24gbGV2ZXJhZ2VOYXRpdmUoIGVsLCB0eXBlLCBleHBlY3RTeW5jICkge1xuXG5cdC8vIE1pc3NpbmcgZXhwZWN0U3luYyBpbmRpY2F0ZXMgYSB0cmlnZ2VyIGNhbGwsIHdoaWNoIG11c3QgZm9yY2Ugc2V0dXAgdGhyb3VnaCBqUXVlcnkuZXZlbnQuYWRkXG5cdGlmICggIWV4cGVjdFN5bmMgKSB7XG5cdFx0aWYgKCBkYXRhUHJpdi5nZXQoIGVsLCB0eXBlICkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIGVsLCB0eXBlLCByZXR1cm5UcnVlICk7XG5cdFx0fVxuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFJlZ2lzdGVyIHRoZSBjb250cm9sbGVyIGFzIGEgc3BlY2lhbCB1bml2ZXJzYWwgaGFuZGxlciBmb3IgYWxsIGV2ZW50IG5hbWVzcGFjZXNcblx0ZGF0YVByaXYuc2V0KCBlbCwgdHlwZSwgZmFsc2UgKTtcblx0alF1ZXJ5LmV2ZW50LmFkZCggZWwsIHR5cGUsIHtcblx0XHRuYW1lc3BhY2U6IGZhbHNlLFxuXHRcdGhhbmRsZXI6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciBub3RBc3luYywgcmVzdWx0LFxuXHRcdFx0XHRzYXZlZCA9IGRhdGFQcml2LmdldCggdGhpcywgdHlwZSApO1xuXG5cdFx0XHRpZiAoICggZXZlbnQuaXNUcmlnZ2VyICYgMSApICYmIHRoaXNbIHR5cGUgXSApIHtcblxuXHRcdFx0XHQvLyBJbnRlcnJ1cHQgcHJvY2Vzc2luZyBvZiB0aGUgb3V0ZXIgc3ludGhldGljIC50cmlnZ2VyKCllZCBldmVudFxuXHRcdFx0XHQvLyBTYXZlZCBkYXRhIHNob3VsZCBiZSBmYWxzZSBpbiBzdWNoIGNhc2VzLCBidXQgbWlnaHQgYmUgYSBsZWZ0b3ZlciBjYXB0dXJlIG9iamVjdFxuXHRcdFx0XHQvLyBmcm9tIGFuIGFzeW5jIG5hdGl2ZSBoYW5kbGVyIChnaC00MzUwKVxuXHRcdFx0XHRpZiAoICFzYXZlZC5sZW5ndGggKSB7XG5cblx0XHRcdFx0XHQvLyBTdG9yZSBhcmd1bWVudHMgZm9yIHVzZSB3aGVuIGhhbmRsaW5nIHRoZSBpbm5lciBuYXRpdmUgZXZlbnRcblx0XHRcdFx0XHQvLyBUaGVyZSB3aWxsIGFsd2F5cyBiZSBhdCBsZWFzdCBvbmUgYXJndW1lbnQgKGFuIGV2ZW50IG9iamVjdCksIHNvIHRoaXMgYXJyYXlcblx0XHRcdFx0XHQvLyB3aWxsIG5vdCBiZSBjb25mdXNlZCB3aXRoIGEgbGVmdG92ZXIgY2FwdHVyZSBvYmplY3QuXG5cdFx0XHRcdFx0c2F2ZWQgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIHR5cGUsIHNhdmVkICk7XG5cblx0XHRcdFx0XHQvLyBUcmlnZ2VyIHRoZSBuYXRpdmUgZXZlbnQgYW5kIGNhcHR1cmUgaXRzIHJlc3VsdFxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExK1xuXHRcdFx0XHRcdC8vIGZvY3VzKCkgYW5kIGJsdXIoKSBhcmUgYXN5bmNocm9ub3VzXG5cdFx0XHRcdFx0bm90QXN5bmMgPSBleHBlY3RTeW5jKCB0aGlzLCB0eXBlICk7XG5cdFx0XHRcdFx0dGhpc1sgdHlwZSBdKCk7XG5cdFx0XHRcdFx0cmVzdWx0ID0gZGF0YVByaXYuZ2V0KCB0aGlzLCB0eXBlICk7XG5cdFx0XHRcdFx0aWYgKCBzYXZlZCAhPT0gcmVzdWx0IHx8IG5vdEFzeW5jICkge1xuXHRcdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCB0eXBlLCBmYWxzZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXN1bHQgPSB7fTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBzYXZlZCAhPT0gcmVzdWx0ICkge1xuXG5cdFx0XHRcdFx0XHQvLyBDYW5jZWwgdGhlIG91dGVyIHN5bnRoZXRpYyBldmVudFxuXHRcdFx0XHRcdFx0ZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdC52YWx1ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgdGhpcyBpcyBhbiBpbm5lciBzeW50aGV0aWMgZXZlbnQgZm9yIGFuIGV2ZW50IHdpdGggYSBidWJibGluZyBzdXJyb2dhdGVcblx0XHRcdFx0Ly8gKGZvY3VzIG9yIGJsdXIpLCBhc3N1bWUgdGhhdCB0aGUgc3Vycm9nYXRlIGFscmVhZHkgcHJvcGFnYXRlZCBmcm9tIHRyaWdnZXJpbmcgdGhlXG5cdFx0XHRcdC8vIG5hdGl2ZSBldmVudCBhbmQgcHJldmVudCB0aGF0IGZyb20gaGFwcGVuaW5nIGFnYWluIGhlcmUuXG5cdFx0XHRcdC8vIFRoaXMgdGVjaG5pY2FsbHkgZ2V0cyB0aGUgb3JkZXJpbmcgd3Jvbmcgdy5yLnQuIHRvIGAudHJpZ2dlcigpYCAoaW4gd2hpY2ggdGhlXG5cdFx0XHRcdC8vIGJ1YmJsaW5nIHN1cnJvZ2F0ZSBwcm9wYWdhdGVzICphZnRlciogdGhlIG5vbi1idWJibGluZyBiYXNlKSwgYnV0IHRoYXQgc2VlbXNcblx0XHRcdFx0Ly8gbGVzcyBiYWQgdGhhbiBkdXBsaWNhdGlvbi5cblx0XHRcdFx0fSBlbHNlIGlmICggKCBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9ICkuZGVsZWdhdGVUeXBlICkge1xuXHRcdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoaXMgaXMgYSBuYXRpdmUgZXZlbnQgdHJpZ2dlcmVkIGFib3ZlLCBldmVyeXRoaW5nIGlzIG5vdyBpbiBvcmRlclxuXHRcdFx0Ly8gRmlyZSBhbiBpbm5lciBzeW50aGV0aWMgZXZlbnQgd2l0aCB0aGUgb3JpZ2luYWwgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCBzYXZlZC5sZW5ndGggKSB7XG5cblx0XHRcdFx0Ly8gLi4uYW5kIGNhcHR1cmUgdGhlIHJlc3VsdFxuXHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIHR5cGUsIHtcblx0XHRcdFx0XHR2YWx1ZTogalF1ZXJ5LmV2ZW50LnRyaWdnZXIoXG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExK1xuXHRcdFx0XHRcdFx0Ly8gRXh0ZW5kIHdpdGggdGhlIHByb3RvdHlwZSB0byByZXNldCB0aGUgYWJvdmUgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKClcblx0XHRcdFx0XHRcdGpRdWVyeS5leHRlbmQoIHNhdmVkWyAwIF0sIGpRdWVyeS5FdmVudC5wcm90b3R5cGUgKSxcblx0XHRcdFx0XHRcdHNhdmVkLnNsaWNlKCAxICksXG5cdFx0XHRcdFx0XHR0aGlzXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0Ly8gQWJvcnQgaGFuZGxpbmcgb2YgdGhlIG5hdGl2ZSBldmVudFxuXHRcdFx0XHRldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gKTtcbn1cblxualF1ZXJ5LnJlbW92ZUV2ZW50ID0gZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGhhbmRsZSApIHtcblxuXHQvLyBUaGlzIFwiaWZcIiBpcyBuZWVkZWQgZm9yIHBsYWluIG9iamVjdHNcblx0aWYgKCBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0ZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBoYW5kbGUgKTtcblx0fVxufTtcblxualF1ZXJ5LkV2ZW50ID0gZnVuY3Rpb24oIHNyYywgcHJvcHMgKSB7XG5cblx0Ly8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IHRoZSAnbmV3JyBrZXl3b3JkXG5cdGlmICggISggdGhpcyBpbnN0YW5jZW9mIGpRdWVyeS5FdmVudCApICkge1xuXHRcdHJldHVybiBuZXcgalF1ZXJ5LkV2ZW50KCBzcmMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBFdmVudCBvYmplY3Rcblx0aWYgKCBzcmMgJiYgc3JjLnR5cGUgKSB7XG5cdFx0dGhpcy5vcmlnaW5hbEV2ZW50ID0gc3JjO1xuXHRcdHRoaXMudHlwZSA9IHNyYy50eXBlO1xuXG5cdFx0Ly8gRXZlbnRzIGJ1YmJsaW5nIHVwIHRoZSBkb2N1bWVudCBtYXkgaGF2ZSBiZWVuIG1hcmtlZCBhcyBwcmV2ZW50ZWRcblx0XHQvLyBieSBhIGhhbmRsZXIgbG93ZXIgZG93biB0aGUgdHJlZTsgcmVmbGVjdCB0aGUgY29ycmVjdCB2YWx1ZS5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHNyYy5kZWZhdWx0UHJldmVudGVkIHx8XG5cdFx0XHRcdHNyYy5kZWZhdWx0UHJldmVudGVkID09PSB1bmRlZmluZWQgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHlcblx0XHRcdFx0c3JjLnJldHVyblZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRyZXR1cm5UcnVlIDpcblx0XHRcdHJldHVybkZhbHNlO1xuXG5cdFx0Ly8gQ3JlYXRlIHRhcmdldCBwcm9wZXJ0aWVzXG5cdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDw9NiAtIDcgb25seVxuXHRcdC8vIFRhcmdldCBzaG91bGQgbm90IGJlIGEgdGV4dCBub2RlICgjNTA0LCAjMTMxNDMpXG5cdFx0dGhpcy50YXJnZXQgPSAoIHNyYy50YXJnZXQgJiYgc3JjLnRhcmdldC5ub2RlVHlwZSA9PT0gMyApID9cblx0XHRcdHNyYy50YXJnZXQucGFyZW50Tm9kZSA6XG5cdFx0XHRzcmMudGFyZ2V0O1xuXG5cdFx0dGhpcy5jdXJyZW50VGFyZ2V0ID0gc3JjLmN1cnJlbnRUYXJnZXQ7XG5cdFx0dGhpcy5yZWxhdGVkVGFyZ2V0ID0gc3JjLnJlbGF0ZWRUYXJnZXQ7XG5cblx0Ly8gRXZlbnQgdHlwZVxuXHR9IGVsc2Uge1xuXHRcdHRoaXMudHlwZSA9IHNyYztcblx0fVxuXG5cdC8vIFB1dCBleHBsaWNpdGx5IHByb3ZpZGVkIHByb3BlcnRpZXMgb250byB0aGUgZXZlbnQgb2JqZWN0XG5cdGlmICggcHJvcHMgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggdGhpcywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIENyZWF0ZSBhIHRpbWVzdGFtcCBpZiBpbmNvbWluZyBldmVudCBkb2Vzbid0IGhhdmUgb25lXG5cdHRoaXMudGltZVN0YW1wID0gc3JjICYmIHNyYy50aW1lU3RhbXAgfHwgRGF0ZS5ub3coKTtcblxuXHQvLyBNYXJrIGl0IGFzIGZpeGVkXG5cdHRoaXNbIGpRdWVyeS5leHBhbmRvIF0gPSB0cnVlO1xufTtcblxuLy8galF1ZXJ5LkV2ZW50IGlzIGJhc2VkIG9uIERPTTMgRXZlbnRzIGFzIHNwZWNpZmllZCBieSB0aGUgRUNNQVNjcmlwdCBMYW5ndWFnZSBCaW5kaW5nXG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvMjAwMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwMzAzMzEvZWNtYS1zY3JpcHQtYmluZGluZy5odG1sXG5qUXVlcnkuRXZlbnQucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LkV2ZW50LFxuXHRpc0RlZmF1bHRQcmV2ZW50ZWQ6IHJldHVybkZhbHNlLFxuXHRpc1Byb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblx0aXNTaW11bGF0ZWQ6IGZhbHNlLFxuXG5cdHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cdH0sXG5cdHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdH1cblxuXHRcdHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH1cbn07XG5cbi8vIEluY2x1ZGVzIGFsbCBjb21tb24gZXZlbnQgcHJvcHMgaW5jbHVkaW5nIEtleUV2ZW50IGFuZCBNb3VzZUV2ZW50IHNwZWNpZmljIHByb3BzXG5qUXVlcnkuZWFjaCgge1xuXHRhbHRLZXk6IHRydWUsXG5cdGJ1YmJsZXM6IHRydWUsXG5cdGNhbmNlbGFibGU6IHRydWUsXG5cdGNoYW5nZWRUb3VjaGVzOiB0cnVlLFxuXHRjdHJsS2V5OiB0cnVlLFxuXHRkZXRhaWw6IHRydWUsXG5cdGV2ZW50UGhhc2U6IHRydWUsXG5cdG1ldGFLZXk6IHRydWUsXG5cdHBhZ2VYOiB0cnVlLFxuXHRwYWdlWTogdHJ1ZSxcblx0c2hpZnRLZXk6IHRydWUsXG5cdHZpZXc6IHRydWUsXG5cdFwiY2hhclwiOiB0cnVlLFxuXHRjb2RlOiB0cnVlLFxuXHRjaGFyQ29kZTogdHJ1ZSxcblx0a2V5OiB0cnVlLFxuXHRrZXlDb2RlOiB0cnVlLFxuXHRidXR0b246IHRydWUsXG5cdGJ1dHRvbnM6IHRydWUsXG5cdGNsaWVudFg6IHRydWUsXG5cdGNsaWVudFk6IHRydWUsXG5cdG9mZnNldFg6IHRydWUsXG5cdG9mZnNldFk6IHRydWUsXG5cdHBvaW50ZXJJZDogdHJ1ZSxcblx0cG9pbnRlclR5cGU6IHRydWUsXG5cdHNjcmVlblg6IHRydWUsXG5cdHNjcmVlblk6IHRydWUsXG5cdHRhcmdldFRvdWNoZXM6IHRydWUsXG5cdHRvRWxlbWVudDogdHJ1ZSxcblx0dG91Y2hlczogdHJ1ZSxcblxuXHR3aGljaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHZhciBidXR0b24gPSBldmVudC5idXR0b247XG5cblx0XHQvLyBBZGQgd2hpY2ggZm9yIGtleSBldmVudHNcblx0XHRpZiAoIGV2ZW50LndoaWNoID09IG51bGwgJiYgcmtleUV2ZW50LnRlc3QoIGV2ZW50LnR5cGUgKSApIHtcblx0XHRcdHJldHVybiBldmVudC5jaGFyQ29kZSAhPSBudWxsID8gZXZlbnQuY2hhckNvZGUgOiBldmVudC5rZXlDb2RlO1xuXHRcdH1cblxuXHRcdC8vIEFkZCB3aGljaCBmb3IgY2xpY2s6IDEgPT09IGxlZnQ7IDIgPT09IG1pZGRsZTsgMyA9PT0gcmlnaHRcblx0XHRpZiAoICFldmVudC53aGljaCAmJiBidXR0b24gIT09IHVuZGVmaW5lZCAmJiBybW91c2VFdmVudC50ZXN0KCBldmVudC50eXBlICkgKSB7XG5cdFx0XHRpZiAoIGJ1dHRvbiAmIDEgKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGJ1dHRvbiAmIDIgKSB7XG5cdFx0XHRcdHJldHVybiAzO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGJ1dHRvbiAmIDQgKSB7XG5cdFx0XHRcdHJldHVybiAyO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQud2hpY2g7XG5cdH1cbn0sIGpRdWVyeS5ldmVudC5hZGRQcm9wICk7XG5cbmpRdWVyeS5lYWNoKCB7IGZvY3VzOiBcImZvY3VzaW5cIiwgYmx1cjogXCJmb2N1c291dFwiIH0sIGZ1bmN0aW9uKCB0eXBlLCBkZWxlZ2F0ZVR5cGUgKSB7XG5cdGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gPSB7XG5cblx0XHQvLyBVdGlsaXplIG5hdGl2ZSBldmVudCBpZiBwb3NzaWJsZSBzbyBibHVyL2ZvY3VzIHNlcXVlbmNlIGlzIGNvcnJlY3Rcblx0XHRzZXR1cDogZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIENsYWltIHRoZSBmaXJzdCBoYW5kbGVyXG5cdFx0XHQvLyBkYXRhUHJpdi5zZXQoIHRoaXMsIFwiZm9jdXNcIiwgLi4uIClcblx0XHRcdC8vIGRhdGFQcml2LnNldCggdGhpcywgXCJibHVyXCIsIC4uLiApXG5cdFx0XHRsZXZlcmFnZU5hdGl2ZSggdGhpcywgdHlwZSwgZXhwZWN0U3luYyApO1xuXG5cdFx0XHQvLyBSZXR1cm4gZmFsc2UgdG8gYWxsb3cgbm9ybWFsIHByb2Nlc3NpbmcgaW4gdGhlIGNhbGxlclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEZvcmNlIHNldHVwIGJlZm9yZSB0cmlnZ2VyXG5cdFx0XHRsZXZlcmFnZU5hdGl2ZSggdGhpcywgdHlwZSApO1xuXG5cdFx0XHQvLyBSZXR1cm4gbm9uLWZhbHNlIHRvIGFsbG93IG5vcm1hbCBldmVudC1wYXRoIHByb3BhZ2F0aW9uXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0ZGVsZWdhdGVUeXBlOiBkZWxlZ2F0ZVR5cGVcblx0fTtcbn0gKTtcblxuLy8gQ3JlYXRlIG1vdXNlZW50ZXIvbGVhdmUgZXZlbnRzIHVzaW5nIG1vdXNlb3Zlci9vdXQgYW5kIGV2ZW50LXRpbWUgY2hlY2tzXG4vLyBzbyB0aGF0IGV2ZW50IGRlbGVnYXRpb24gd29ya3MgaW4galF1ZXJ5LlxuLy8gRG8gdGhlIHNhbWUgZm9yIHBvaW50ZXJlbnRlci9wb2ludGVybGVhdmUgYW5kIHBvaW50ZXJvdmVyL3BvaW50ZXJvdXRcbi8vXG4vLyBTdXBwb3J0OiBTYWZhcmkgNyBvbmx5XG4vLyBTYWZhcmkgc2VuZHMgbW91c2VlbnRlciB0b28gb2Z0ZW47IHNlZTpcbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ3MDI1OFxuLy8gZm9yIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgYnVnIChpdCBleGlzdGVkIGluIG9sZGVyIENocm9tZSB2ZXJzaW9ucyBhcyB3ZWxsKS5cbmpRdWVyeS5lYWNoKCB7XG5cdG1vdXNlZW50ZXI6IFwibW91c2VvdmVyXCIsXG5cdG1vdXNlbGVhdmU6IFwibW91c2VvdXRcIixcblx0cG9pbnRlcmVudGVyOiBcInBvaW50ZXJvdmVyXCIsXG5cdHBvaW50ZXJsZWF2ZTogXCJwb2ludGVyb3V0XCJcbn0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBvcmlnIF0gPSB7XG5cdFx0ZGVsZWdhdGVUeXBlOiBmaXgsXG5cdFx0YmluZFR5cGU6IGZpeCxcblxuXHRcdGhhbmRsZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0dmFyIHJldCxcblx0XHRcdFx0dGFyZ2V0ID0gdGhpcyxcblx0XHRcdFx0cmVsYXRlZCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQsXG5cdFx0XHRcdGhhbmRsZU9iaiA9IGV2ZW50LmhhbmRsZU9iajtcblxuXHRcdFx0Ly8gRm9yIG1vdXNlZW50ZXIvbGVhdmUgY2FsbCB0aGUgaGFuZGxlciBpZiByZWxhdGVkIGlzIG91dHNpZGUgdGhlIHRhcmdldC5cblx0XHRcdC8vIE5COiBObyByZWxhdGVkVGFyZ2V0IGlmIHRoZSBtb3VzZSBsZWZ0L2VudGVyZWQgdGhlIGJyb3dzZXIgd2luZG93XG5cdFx0XHRpZiAoICFyZWxhdGVkIHx8ICggcmVsYXRlZCAhPT0gdGFyZ2V0ICYmICFqUXVlcnkuY29udGFpbnMoIHRhcmdldCwgcmVsYXRlZCApICkgKSB7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBoYW5kbGVPYmoub3JpZ1R5cGU7XG5cdFx0XHRcdHJldCA9IGhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0ZXZlbnQudHlwZSA9IGZpeDtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0b246IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBvbiggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHR9LFxuXHRvbmU6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBvbiggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgMSApO1xuXHR9LFxuXHRvZmY6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGZuICkge1xuXHRcdHZhciBoYW5kbGVPYmosIHR5cGU7XG5cdFx0aWYgKCB0eXBlcyAmJiB0eXBlcy5wcmV2ZW50RGVmYXVsdCAmJiB0eXBlcy5oYW5kbGVPYmogKSB7XG5cblx0XHRcdC8vICggZXZlbnQgKSAgZGlzcGF0Y2hlZCBqUXVlcnkuRXZlbnRcblx0XHRcdGhhbmRsZU9iaiA9IHR5cGVzLmhhbmRsZU9iajtcblx0XHRcdGpRdWVyeSggdHlwZXMuZGVsZWdhdGVUYXJnZXQgKS5vZmYoXG5cdFx0XHRcdGhhbmRsZU9iai5uYW1lc3BhY2UgP1xuXHRcdFx0XHRcdGhhbmRsZU9iai5vcmlnVHlwZSArIFwiLlwiICsgaGFuZGxlT2JqLm5hbWVzcGFjZSA6XG5cdFx0XHRcdFx0aGFuZGxlT2JqLm9yaWdUeXBlLFxuXHRcdFx0XHRoYW5kbGVPYmouc2VsZWN0b3IsXG5cdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyXG5cdFx0XHQpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLW9iamVjdCBbLCBzZWxlY3Rvcl0gKVxuXHRcdFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcblx0XHRcdFx0dGhpcy5vZmYoIHR5cGUsIHNlbGVjdG9yLCB0eXBlc1sgdHlwZSBdICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKCBzZWxlY3RvciA9PT0gZmFsc2UgfHwgdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMgWywgZm5dIClcblx0XHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIHRoaXMsIHR5cGVzLCBmbiwgc2VsZWN0b3IgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuXG52YXJcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTEwIC0gMTEsIEVkZ2UgMTIgLSAxMyBvbmx5XG5cdC8vIEluIElFL0VkZ2UgdXNpbmcgcmVnZXggZ3JvdXBzIGhlcmUgY2F1c2VzIHNldmVyZSBzbG93ZG93bnMuXG5cdC8vIFNlZSBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9JRS9mZWVkYmFjay9kZXRhaWxzLzE3MzY1MTIvXG5cdHJub0lubmVyaHRtbCA9IC88c2NyaXB0fDxzdHlsZXw8bGluay9pLFxuXG5cdC8vIGNoZWNrZWQ9XCJjaGVja2VkXCIgb3IgY2hlY2tlZFxuXHRyY2hlY2tlZCA9IC9jaGVja2VkXFxzKig/OltePV18PVxccyouY2hlY2tlZC4pL2ksXG5cdHJjbGVhblNjcmlwdCA9IC9eXFxzKjwhKD86XFxbQ0RBVEFcXFt8LS0pfCg/OlxcXVxcXXwtLSk+XFxzKiQvZztcblxuLy8gUHJlZmVyIGEgdGJvZHkgb3ZlciBpdHMgcGFyZW50IHRhYmxlIGZvciBjb250YWluaW5nIG5ldyByb3dzXG5mdW5jdGlvbiBtYW5pcHVsYXRpb25UYXJnZXQoIGVsZW0sIGNvbnRlbnQgKSB7XG5cdGlmICggbm9kZU5hbWUoIGVsZW0sIFwidGFibGVcIiApICYmXG5cdFx0bm9kZU5hbWUoIGNvbnRlbnQubm9kZVR5cGUgIT09IDExID8gY29udGVudCA6IGNvbnRlbnQuZmlyc3RDaGlsZCwgXCJ0clwiICkgKSB7XG5cblx0XHRyZXR1cm4galF1ZXJ5KCBlbGVtICkuY2hpbGRyZW4oIFwidGJvZHlcIiApWyAwIF0gfHwgZWxlbTtcblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG4vLyBSZXBsYWNlL3Jlc3RvcmUgdGhlIHR5cGUgYXR0cmlidXRlIG9mIHNjcmlwdCBlbGVtZW50cyBmb3Igc2FmZSBET00gbWFuaXB1bGF0aW9uXG5mdW5jdGlvbiBkaXNhYmxlU2NyaXB0KCBlbGVtICkge1xuXHRlbGVtLnR5cGUgPSAoIGVsZW0uZ2V0QXR0cmlidXRlKCBcInR5cGVcIiApICE9PSBudWxsICkgKyBcIi9cIiArIGVsZW0udHlwZTtcblx0cmV0dXJuIGVsZW07XG59XG5mdW5jdGlvbiByZXN0b3JlU2NyaXB0KCBlbGVtICkge1xuXHRpZiAoICggZWxlbS50eXBlIHx8IFwiXCIgKS5zbGljZSggMCwgNSApID09PSBcInRydWUvXCIgKSB7XG5cdFx0ZWxlbS50eXBlID0gZWxlbS50eXBlLnNsaWNlKCA1ICk7XG5cdH0gZWxzZSB7XG5cdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIFwidHlwZVwiICk7XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxuZnVuY3Rpb24gY2xvbmVDb3B5RXZlbnQoIHNyYywgZGVzdCApIHtcblx0dmFyIGksIGwsIHR5cGUsIHBkYXRhT2xkLCB1ZGF0YU9sZCwgdWRhdGFDdXIsIGV2ZW50cztcblxuXHRpZiAoIGRlc3Qubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gMS4gQ29weSBwcml2YXRlIGRhdGE6IGV2ZW50cywgaGFuZGxlcnMsIGV0Yy5cblx0aWYgKCBkYXRhUHJpdi5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHRwZGF0YU9sZCA9IGRhdGFQcml2LmdldCggc3JjICk7XG5cdFx0ZXZlbnRzID0gcGRhdGFPbGQuZXZlbnRzO1xuXG5cdFx0aWYgKCBldmVudHMgKSB7XG5cdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGRlc3QsIFwiaGFuZGxlIGV2ZW50c1wiICk7XG5cblx0XHRcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IGV2ZW50c1sgdHlwZSBdLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCBkZXN0LCB0eXBlLCBldmVudHNbIHR5cGUgXVsgaSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyAyLiBDb3B5IHVzZXIgZGF0YVxuXHRpZiAoIGRhdGFVc2VyLmhhc0RhdGEoIHNyYyApICkge1xuXHRcdHVkYXRhT2xkID0gZGF0YVVzZXIuYWNjZXNzKCBzcmMgKTtcblx0XHR1ZGF0YUN1ciA9IGpRdWVyeS5leHRlbmQoIHt9LCB1ZGF0YU9sZCApO1xuXG5cdFx0ZGF0YVVzZXIuc2V0KCBkZXN0LCB1ZGF0YUN1ciApO1xuXHR9XG59XG5cbi8vIEZpeCBJRSBidWdzLCBzZWUgc3VwcG9ydCB0ZXN0c1xuZnVuY3Rpb24gZml4SW5wdXQoIHNyYywgZGVzdCApIHtcblx0dmFyIG5vZGVOYW1lID0gZGVzdC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdC8vIEZhaWxzIHRvIHBlcnNpc3QgdGhlIGNoZWNrZWQgc3RhdGUgb2YgYSBjbG9uZWQgY2hlY2tib3ggb3IgcmFkaW8gYnV0dG9uLlxuXHRpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgcmNoZWNrYWJsZVR5cGUudGVzdCggc3JjLnR5cGUgKSApIHtcblx0XHRkZXN0LmNoZWNrZWQgPSBzcmMuY2hlY2tlZDtcblxuXHQvLyBGYWlscyB0byByZXR1cm4gdGhlIHNlbGVjdGVkIG9wdGlvbiB0byB0aGUgZGVmYXVsdCBzZWxlY3RlZCBzdGF0ZSB3aGVuIGNsb25pbmcgb3B0aW9uc1xuXHR9IGVsc2UgaWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5vZGVOYW1lID09PSBcInRleHRhcmVhXCIgKSB7XG5cdFx0ZGVzdC5kZWZhdWx0VmFsdWUgPSBzcmMuZGVmYXVsdFZhbHVlO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGRvbU1hbmlwKCBjb2xsZWN0aW9uLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCApIHtcblxuXHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG5cdGFyZ3MgPSBmbGF0KCBhcmdzICk7XG5cblx0dmFyIGZyYWdtZW50LCBmaXJzdCwgc2NyaXB0cywgaGFzU2NyaXB0cywgbm9kZSwgZG9jLFxuXHRcdGkgPSAwLFxuXHRcdGwgPSBjb2xsZWN0aW9uLmxlbmd0aCxcblx0XHRpTm9DbG9uZSA9IGwgLSAxLFxuXHRcdHZhbHVlID0gYXJnc1sgMCBdLFxuXHRcdHZhbHVlSXNGdW5jdGlvbiA9IGlzRnVuY3Rpb24oIHZhbHVlICk7XG5cblx0Ly8gV2UgY2FuJ3QgY2xvbmVOb2RlIGZyYWdtZW50cyB0aGF0IGNvbnRhaW4gY2hlY2tlZCwgaW4gV2ViS2l0XG5cdGlmICggdmFsdWVJc0Z1bmN0aW9uIHx8XG5cdFx0XHQoIGwgPiAxICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQhc3VwcG9ydC5jaGVja0Nsb25lICYmIHJjaGVja2VkLnRlc3QoIHZhbHVlICkgKSApIHtcblx0XHRyZXR1cm4gY29sbGVjdGlvbi5lYWNoKCBmdW5jdGlvbiggaW5kZXggKSB7XG5cdFx0XHR2YXIgc2VsZiA9IGNvbGxlY3Rpb24uZXEoIGluZGV4ICk7XG5cdFx0XHRpZiAoIHZhbHVlSXNGdW5jdGlvbiApIHtcblx0XHRcdFx0YXJnc1sgMCBdID0gdmFsdWUuY2FsbCggdGhpcywgaW5kZXgsIHNlbGYuaHRtbCgpICk7XG5cdFx0XHR9XG5cdFx0XHRkb21NYW5pcCggc2VsZiwgYXJncywgY2FsbGJhY2ssIGlnbm9yZWQgKTtcblx0XHR9ICk7XG5cdH1cblxuXHRpZiAoIGwgKSB7XG5cdFx0ZnJhZ21lbnQgPSBidWlsZEZyYWdtZW50KCBhcmdzLCBjb2xsZWN0aW9uWyAwIF0ub3duZXJEb2N1bWVudCwgZmFsc2UsIGNvbGxlY3Rpb24sIGlnbm9yZWQgKTtcblx0XHRmaXJzdCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG5cblx0XHRpZiAoIGZyYWdtZW50LmNoaWxkTm9kZXMubGVuZ3RoID09PSAxICkge1xuXHRcdFx0ZnJhZ21lbnQgPSBmaXJzdDtcblx0XHR9XG5cblx0XHQvLyBSZXF1aXJlIGVpdGhlciBuZXcgY29udGVudCBvciBhbiBpbnRlcmVzdCBpbiBpZ25vcmVkIGVsZW1lbnRzIHRvIGludm9rZSB0aGUgY2FsbGJhY2tcblx0XHRpZiAoIGZpcnN0IHx8IGlnbm9yZWQgKSB7XG5cdFx0XHRzY3JpcHRzID0galF1ZXJ5Lm1hcCggZ2V0QWxsKCBmcmFnbWVudCwgXCJzY3JpcHRcIiApLCBkaXNhYmxlU2NyaXB0ICk7XG5cdFx0XHRoYXNTY3JpcHRzID0gc2NyaXB0cy5sZW5ndGg7XG5cblx0XHRcdC8vIFVzZSB0aGUgb3JpZ2luYWwgZnJhZ21lbnQgZm9yIHRoZSBsYXN0IGl0ZW1cblx0XHRcdC8vIGluc3RlYWQgb2YgdGhlIGZpcnN0IGJlY2F1c2UgaXQgY2FuIGVuZCB1cFxuXHRcdFx0Ly8gYmVpbmcgZW1wdGllZCBpbmNvcnJlY3RseSBpbiBjZXJ0YWluIHNpdHVhdGlvbnMgKCM4MDcwKS5cblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0bm9kZSA9IGZyYWdtZW50O1xuXG5cdFx0XHRcdGlmICggaSAhPT0gaU5vQ2xvbmUgKSB7XG5cdFx0XHRcdFx0bm9kZSA9IGpRdWVyeS5jbG9uZSggbm9kZSwgdHJ1ZSwgdHJ1ZSApO1xuXG5cdFx0XHRcdFx0Ly8gS2VlcCByZWZlcmVuY2VzIHRvIGNsb25lZCBzY3JpcHRzIGZvciBsYXRlciByZXN0b3JhdGlvblxuXHRcdFx0XHRcdGlmICggaGFzU2NyaXB0cyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHNjcmlwdHMsIGdldEFsbCggbm9kZSwgXCJzY3JpcHRcIiApICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y2FsbGJhY2suY2FsbCggY29sbGVjdGlvblsgaSBdLCBub2RlLCBpICk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaGFzU2NyaXB0cyApIHtcblx0XHRcdFx0ZG9jID0gc2NyaXB0c1sgc2NyaXB0cy5sZW5ndGggLSAxIF0ub3duZXJEb2N1bWVudDtcblxuXHRcdFx0XHQvLyBSZWVuYWJsZSBzY3JpcHRzXG5cdFx0XHRcdGpRdWVyeS5tYXAoIHNjcmlwdHMsIHJlc3RvcmVTY3JpcHQgKTtcblxuXHRcdFx0XHQvLyBFdmFsdWF0ZSBleGVjdXRhYmxlIHNjcmlwdHMgb24gZmlyc3QgZG9jdW1lbnQgaW5zZXJ0aW9uXG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgaGFzU2NyaXB0czsgaSsrICkge1xuXHRcdFx0XHRcdG5vZGUgPSBzY3JpcHRzWyBpIF07XG5cdFx0XHRcdFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBub2RlLnR5cGUgfHwgXCJcIiApICYmXG5cdFx0XHRcdFx0XHQhZGF0YVByaXYuYWNjZXNzKCBub2RlLCBcImdsb2JhbEV2YWxcIiApICYmXG5cdFx0XHRcdFx0XHRqUXVlcnkuY29udGFpbnMoIGRvYywgbm9kZSApICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIG5vZGUuc3JjICYmICggbm9kZS50eXBlIHx8IFwiXCIgKS50b0xvd2VyQ2FzZSgpICAhPT0gXCJtb2R1bGVcIiApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBPcHRpb25hbCBBSkFYIGRlcGVuZGVuY3ksIGJ1dCB3b24ndCBydW4gc2NyaXB0cyBpZiBub3QgcHJlc2VudFxuXHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5fZXZhbFVybCAmJiAhbm9kZS5ub01vZHVsZSApIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuX2V2YWxVcmwoIG5vZGUuc3JjLCB7XG5cdFx0XHRcdFx0XHRcdFx0XHRub25jZTogbm9kZS5ub25jZSB8fCBub2RlLmdldEF0dHJpYnV0ZSggXCJub25jZVwiIClcblx0XHRcdFx0XHRcdFx0XHR9LCBkb2MgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0RE9NRXZhbCggbm9kZS50ZXh0Q29udGVudC5yZXBsYWNlKCByY2xlYW5TY3JpcHQsIFwiXCIgKSwgbm9kZSwgZG9jICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGNvbGxlY3Rpb247XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSggZWxlbSwgc2VsZWN0b3IsIGtlZXBEYXRhICkge1xuXHR2YXIgbm9kZSxcblx0XHRub2RlcyA9IHNlbGVjdG9yID8galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIGVsZW0gKSA6IGVsZW0sXG5cdFx0aSA9IDA7XG5cblx0Zm9yICggOyAoIG5vZGUgPSBub2Rlc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdGlmICggIWtlZXBEYXRhICYmIG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIG5vZGUgKSApO1xuXHRcdH1cblxuXHRcdGlmICggbm9kZS5wYXJlbnROb2RlICkge1xuXHRcdFx0aWYgKCBrZWVwRGF0YSAmJiBpc0F0dGFjaGVkKCBub2RlICkgKSB7XG5cdFx0XHRcdHNldEdsb2JhbEV2YWwoIGdldEFsbCggbm9kZSwgXCJzY3JpcHRcIiApICk7XG5cdFx0XHR9XG5cdFx0XHRub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIG5vZGUgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRodG1sUHJlZmlsdGVyOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRyZXR1cm4gaHRtbDtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oIGVsZW0sIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdHZhciBpLCBsLCBzcmNFbGVtZW50cywgZGVzdEVsZW1lbnRzLFxuXHRcdFx0Y2xvbmUgPSBlbGVtLmNsb25lTm9kZSggdHJ1ZSApLFxuXHRcdFx0aW5QYWdlID0gaXNBdHRhY2hlZCggZWxlbSApO1xuXG5cdFx0Ly8gRml4IElFIGNsb25pbmcgaXNzdWVzXG5cdFx0aWYgKCAhc3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCAmJiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgZWxlbS5ub2RlVHlwZSA9PT0gMTEgKSAmJlxuXHRcdFx0XHQhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cblx0XHRcdC8vIFdlIGVzY2hldyBTaXp6bGUgaGVyZSBmb3IgcGVyZm9ybWFuY2UgcmVhc29uczogaHR0cHM6Ly9qc3BlcmYuY29tL2dldGFsbC12cy1zaXp6bGUvMlxuXHRcdFx0ZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSApO1xuXHRcdFx0c3JjRWxlbWVudHMgPSBnZXRBbGwoIGVsZW0gKTtcblxuXHRcdFx0Zm9yICggaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGZpeElucHV0KCBzcmNFbGVtZW50c1sgaSBdLCBkZXN0RWxlbWVudHNbIGkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENvcHkgdGhlIGV2ZW50cyBmcm9tIHRoZSBvcmlnaW5hbCB0byB0aGUgY2xvbmVcblx0XHRpZiAoIGRhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRpZiAoIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdFx0XHRzcmNFbGVtZW50cyA9IHNyY0VsZW1lbnRzIHx8IGdldEFsbCggZWxlbSApO1xuXHRcdFx0XHRkZXN0RWxlbWVudHMgPSBkZXN0RWxlbWVudHMgfHwgZ2V0QWxsKCBjbG9uZSApO1xuXG5cdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdGNsb25lQ29weUV2ZW50KCBzcmNFbGVtZW50c1sgaSBdLCBkZXN0RWxlbWVudHNbIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjbG9uZUNvcHlFdmVudCggZWxlbSwgY2xvbmUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XG5cdFx0ZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSwgXCJzY3JpcHRcIiApO1xuXHRcdGlmICggZGVzdEVsZW1lbnRzLmxlbmd0aCA+IDAgKSB7XG5cdFx0XHRzZXRHbG9iYWxFdmFsKCBkZXN0RWxlbWVudHMsICFpblBhZ2UgJiYgZ2V0QWxsKCBlbGVtLCBcInNjcmlwdFwiICkgKTtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4gdGhlIGNsb25lZCBzZXRcblx0XHRyZXR1cm4gY2xvbmU7XG5cdH0sXG5cblx0Y2xlYW5EYXRhOiBmdW5jdGlvbiggZWxlbXMgKSB7XG5cdFx0dmFyIGRhdGEsIGVsZW0sIHR5cGUsXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWwsXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgKCBlbGVtID0gZWxlbXNbIGkgXSApICE9PSB1bmRlZmluZWQ7IGkrKyApIHtcblx0XHRcdGlmICggYWNjZXB0RGF0YSggZWxlbSApICkge1xuXHRcdFx0XHRpZiAoICggZGF0YSA9IGVsZW1bIGRhdGFQcml2LmV4cGFuZG8gXSApICkge1xuXHRcdFx0XHRcdGlmICggZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCB0eXBlIGluIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIHNwZWNpYWxbIHR5cGUgXSApIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gVGhpcyBpcyBhIHNob3J0Y3V0IHRvIGF2b2lkIGpRdWVyeS5ldmVudC5yZW1vdmUncyBvdmVyaGVhZFxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZGF0YS5oYW5kbGUgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDUrXG5cdFx0XHRcdFx0Ly8gQXNzaWduIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHVzaW5nIGRlbGV0ZSwgc2VlIERhdGEjcmVtb3ZlXG5cdFx0XHRcdFx0ZWxlbVsgZGF0YVByaXYuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggZWxlbVsgZGF0YVVzZXIuZXhwYW5kbyBdICkge1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NStcblx0XHRcdFx0XHQvLyBBc3NpZ24gdW5kZWZpbmVkIGluc3RlYWQgb2YgdXNpbmcgZGVsZXRlLCBzZWUgRGF0YSNyZW1vdmVcblx0XHRcdFx0XHRlbGVtWyBkYXRhVXNlci5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRkZXRhY2g6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gcmVtb3ZlKCB0aGlzLCBzZWxlY3RvciwgdHJ1ZSApO1xuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiByZW1vdmUoIHRoaXMsIHNlbGVjdG9yICk7XG5cdH0sXG5cblx0dGV4dDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnRleHQoIHRoaXMgKSA6XG5cdFx0XHRcdHRoaXMuZW1wdHkoKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRcdHRoaXMudGV4dENvbnRlbnQgPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdGFwcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcblx0XHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdHByZXBlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XG5cdFx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoIGVsZW0sIHRhcmdldC5maXJzdENoaWxkICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGJlZm9yZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0YWZ0ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzLm5leHRTaWJsaW5nICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGVtcHR5OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZWxlbSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoIGVsZW0gPSB0aGlzWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0Ly8gUHJldmVudCBtZW1vcnkgbGVha3Ncblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtLCBmYWxzZSApICk7XG5cblx0XHRcdFx0Ly8gUmVtb3ZlIGFueSByZW1haW5pbmcgbm9kZXNcblx0XHRcdFx0ZWxlbS50ZXh0Q29udGVudCA9IFwiXCI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRkYXRhQW5kRXZlbnRzID0gZGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZmFsc2UgOiBkYXRhQW5kRXZlbnRzO1xuXHRcdGRlZXBEYXRhQW5kRXZlbnRzID0gZGVlcERhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGRhdGFBbmRFdmVudHMgOiBkZWVwRGF0YUFuZEV2ZW50cztcblxuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmNsb25lKCB0aGlzLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApO1xuXHRcdH0gKTtcblx0fSxcblxuXHRodG1sOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGVsZW0gPSB0aGlzWyAwIF0gfHwge30sXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHRsID0gdGhpcy5sZW5ndGg7XG5cblx0XHRcdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5pbm5lckhUTUw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNlZSBpZiB3ZSBjYW4gdGFrZSBhIHNob3J0Y3V0IGFuZCBqdXN0IHVzZSBpbm5lckhUTUxcblx0XHRcdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmICFybm9Jbm5lcmh0bWwudGVzdCggdmFsdWUgKSAmJlxuXHRcdFx0XHQhd3JhcE1hcFsgKCBydGFnTmFtZS5leGVjKCB2YWx1ZSApIHx8IFsgXCJcIiwgXCJcIiBdIClbIDEgXS50b0xvd2VyQ2FzZSgpIF0gKSB7XG5cblx0XHRcdFx0dmFsdWUgPSBqUXVlcnkuaHRtbFByZWZpbHRlciggdmFsdWUgKTtcblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRcdGVsZW0gPSB0aGlzWyBpIF0gfHwge307XG5cblx0XHRcdFx0XHRcdC8vIFJlbW92ZSBlbGVtZW50IG5vZGVzIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblx0XHRcdFx0XHRcdFx0ZWxlbS5pbm5lckhUTUwgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRlbGVtID0gMDtcblxuXHRcdFx0XHQvLyBJZiB1c2luZyBpbm5lckhUTUwgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgdXNlIHRoZSBmYWxsYmFjayBtZXRob2Rcblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdHRoaXMuZW1wdHkoKS5hcHBlbmQoIHZhbHVlICk7XG5cdFx0XHR9XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fSxcblxuXHRyZXBsYWNlV2l0aDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGlnbm9yZWQgPSBbXTtcblxuXHRcdC8vIE1ha2UgdGhlIGNoYW5nZXMsIHJlcGxhY2luZyBlYWNoIG5vbi1pZ25vcmVkIGNvbnRleHQgZWxlbWVudCB3aXRoIHRoZSBuZXcgY29udGVudFxuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XG5cblx0XHRcdGlmICggalF1ZXJ5LmluQXJyYXkoIHRoaXMsIGlnbm9yZWQgKSA8IDAgKSB7XG5cdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggdGhpcyApICk7XG5cdFx0XHRcdGlmICggcGFyZW50ICkge1xuXHRcdFx0XHRcdHBhcmVudC5yZXBsYWNlQ2hpbGQoIGVsZW0sIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gRm9yY2UgY2FsbGJhY2sgaW52b2NhdGlvblxuXHRcdH0sIGlnbm9yZWQgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCgge1xuXHRhcHBlbmRUbzogXCJhcHBlbmRcIixcblx0cHJlcGVuZFRvOiBcInByZXBlbmRcIixcblx0aW5zZXJ0QmVmb3JlOiBcImJlZm9yZVwiLFxuXHRpbnNlcnRBZnRlcjogXCJhZnRlclwiLFxuXHRyZXBsYWNlQWxsOiBcInJlcGxhY2VXaXRoXCJcbn0sIGZ1bmN0aW9uKCBuYW1lLCBvcmlnaW5hbCApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGVsZW1zLFxuXHRcdFx0cmV0ID0gW10sXG5cdFx0XHRpbnNlcnQgPSBqUXVlcnkoIHNlbGVjdG9yICksXG5cdFx0XHRsYXN0ID0gaW5zZXJ0Lmxlbmd0aCAtIDEsXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgaSA8PSBsYXN0OyBpKysgKSB7XG5cdFx0XHRlbGVtcyA9IGkgPT09IGxhc3QgPyB0aGlzIDogdGhpcy5jbG9uZSggdHJ1ZSApO1xuXHRcdFx0alF1ZXJ5KCBpbnNlcnRbIGkgXSApWyBvcmlnaW5hbCBdKCBlbGVtcyApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdC8vIC5nZXQoKSBiZWNhdXNlIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdHB1c2guYXBwbHkoIHJldCwgZWxlbXMuZ2V0KCkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHJldCApO1xuXHR9O1xufSApO1xudmFyIHJudW1ub25weCA9IG5ldyBSZWdFeHAoIFwiXihcIiArIHBudW0gKyBcIikoPyFweClbYS16JV0rJFwiLCBcImlcIiApO1xuXG52YXIgZ2V0U3R5bGVzID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHksIEZpcmVmb3ggPD0zMCAoIzE1MDk4LCAjMTQxNTApXG5cdFx0Ly8gSUUgdGhyb3dzIG9uIGVsZW1lbnRzIGNyZWF0ZWQgaW4gcG9wdXBzXG5cdFx0Ly8gRkYgbWVhbndoaWxlIHRocm93cyBvbiBmcmFtZSBlbGVtZW50cyB0aHJvdWdoIFwiZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZVwiXG5cdFx0dmFyIHZpZXcgPSBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG5cblx0XHRpZiAoICF2aWV3IHx8ICF2aWV3Lm9wZW5lciApIHtcblx0XHRcdHZpZXcgPSB3aW5kb3c7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSggZWxlbSApO1xuXHR9O1xuXG52YXIgc3dhcCA9IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBjYWxsYmFjayApIHtcblx0dmFyIHJldCwgbmFtZSxcblx0XHRvbGQgPSB7fTtcblxuXHQvLyBSZW1lbWJlciB0aGUgb2xkIHZhbHVlcywgYW5kIGluc2VydCB0aGUgbmV3IG9uZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdG9sZFsgbmFtZSBdID0gZWxlbS5zdHlsZVsgbmFtZSBdO1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9wdGlvbnNbIG5hbWUgXTtcblx0fVxuXG5cdHJldCA9IGNhbGxiYWNrLmNhbGwoIGVsZW0gKTtcblxuXHQvLyBSZXZlcnQgdGhlIG9sZCB2YWx1ZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9sZFsgbmFtZSBdO1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn07XG5cblxudmFyIHJib3hTdHlsZSA9IG5ldyBSZWdFeHAoIGNzc0V4cGFuZC5qb2luKCBcInxcIiApLCBcImlcIiApO1xuXG5cblxuKCBmdW5jdGlvbigpIHtcblxuXHQvLyBFeGVjdXRpbmcgYm90aCBwaXhlbFBvc2l0aW9uICYgYm94U2l6aW5nUmVsaWFibGUgdGVzdHMgcmVxdWlyZSBvbmx5IG9uZSBsYXlvdXRcblx0Ly8gc28gdGhleSdyZSBleGVjdXRlZCBhdCB0aGUgc2FtZSB0aW1lIHRvIHNhdmUgdGhlIHNlY29uZCBjb21wdXRhdGlvbi5cblx0ZnVuY3Rpb24gY29tcHV0ZVN0eWxlVGVzdHMoKSB7XG5cblx0XHQvLyBUaGlzIGlzIGEgc2luZ2xldG9uLCB3ZSBuZWVkIHRvIGV4ZWN1dGUgaXQgb25seSBvbmNlXG5cdFx0aWYgKCAhZGl2ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0Oi0xMTExMXB4O3dpZHRoOjYwcHg7XCIgK1xuXHRcdFx0XCJtYXJnaW4tdG9wOjFweDtwYWRkaW5nOjA7Ym9yZGVyOjBcIjtcblx0XHRkaXYuc3R5bGUuY3NzVGV4dCA9XG5cdFx0XHRcInBvc2l0aW9uOnJlbGF0aXZlO2Rpc3BsYXk6YmxvY2s7Ym94LXNpemluZzpib3JkZXItYm94O292ZXJmbG93OnNjcm9sbDtcIiArXG5cdFx0XHRcIm1hcmdpbjphdXRvO2JvcmRlcjoxcHg7cGFkZGluZzoxcHg7XCIgK1xuXHRcdFx0XCJ3aWR0aDo2MCU7dG9wOjElXCI7XG5cdFx0ZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKCBjb250YWluZXIgKS5hcHBlbmRDaGlsZCggZGl2ICk7XG5cblx0XHR2YXIgZGl2U3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggZGl2ICk7XG5cdFx0cGl4ZWxQb3NpdGlvblZhbCA9IGRpdlN0eWxlLnRvcCAhPT0gXCIxJVwiO1xuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seSwgRmlyZWZveCA8PTMgLSA0NFxuXHRcdHJlbGlhYmxlTWFyZ2luTGVmdFZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyggZGl2U3R5bGUubWFyZ2luTGVmdCApID09PSAxMjtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHksIFNhZmFyaSA8PTkuMSAtIDEwLjEsIGlPUyA8PTcuMCAtIDkuM1xuXHRcdC8vIFNvbWUgc3R5bGVzIGNvbWUgYmFjayB3aXRoIHBlcmNlbnRhZ2UgdmFsdWVzLCBldmVuIHRob3VnaCB0aGV5IHNob3VsZG4ndFxuXHRcdGRpdi5zdHlsZS5yaWdodCA9IFwiNjAlXCI7XG5cdFx0cGl4ZWxCb3hTdHlsZXNWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdlN0eWxlLnJpZ2h0ICkgPT09IDM2O1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHlcblx0XHQvLyBEZXRlY3QgbWlzcmVwb3J0aW5nIG9mIGNvbnRlbnQgZGltZW5zaW9ucyBmb3IgYm94LXNpemluZzpib3JkZXItYm94IGVsZW1lbnRzXG5cdFx0Ym94U2l6aW5nUmVsaWFibGVWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdlN0eWxlLndpZHRoICkgPT09IDM2O1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSBvbmx5XG5cdFx0Ly8gRGV0ZWN0IG92ZXJmbG93OnNjcm9sbCBzY3Jld2luZXNzIChnaC0zNjk5KVxuXHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTY0XG5cdFx0Ly8gRG9uJ3QgZ2V0IHRyaWNrZWQgd2hlbiB6b29tIGFmZmVjdHMgb2Zmc2V0V2lkdGggKGdoLTQwMjkpXG5cdFx0ZGl2LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuXHRcdHNjcm9sbGJveFNpemVWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdi5vZmZzZXRXaWR0aCAvIDMgKSA9PT0gMTI7XG5cblx0XHRkb2N1bWVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoIGNvbnRhaW5lciApO1xuXG5cdFx0Ly8gTnVsbGlmeSB0aGUgZGl2IHNvIGl0IHdvdWxkbid0IGJlIHN0b3JlZCBpbiB0aGUgbWVtb3J5IGFuZFxuXHRcdC8vIGl0IHdpbGwgYWxzbyBiZSBhIHNpZ24gdGhhdCBjaGVja3MgYWxyZWFkeSBwZXJmb3JtZWRcblx0XHRkaXYgPSBudWxsO1xuXHR9XG5cblx0ZnVuY3Rpb24gcm91bmRQaXhlbE1lYXN1cmVzKCBtZWFzdXJlICkge1xuXHRcdHJldHVybiBNYXRoLnJvdW5kKCBwYXJzZUZsb2F0KCBtZWFzdXJlICkgKTtcblx0fVxuXG5cdHZhciBwaXhlbFBvc2l0aW9uVmFsLCBib3hTaXppbmdSZWxpYWJsZVZhbCwgc2Nyb2xsYm94U2l6ZVZhbCwgcGl4ZWxCb3hTdHlsZXNWYWwsXG5cdFx0cmVsaWFibGVUckRpbWVuc2lvbnNWYWwsIHJlbGlhYmxlTWFyZ2luTGVmdFZhbCxcblx0XHRjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICksXG5cdFx0ZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApO1xuXG5cdC8vIEZpbmlzaCBlYXJseSBpbiBsaW1pdGVkIChub24tYnJvd3NlcikgZW52aXJvbm1lbnRzXG5cdGlmICggIWRpdi5zdHlsZSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdC8vIFN0eWxlIG9mIGNsb25lZCBlbGVtZW50IGFmZmVjdHMgc291cmNlIGVsZW1lbnQgY2xvbmVkICgjODkwOClcblx0ZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJjb250ZW50LWJveFwiO1xuXHRkaXYuY2xvbmVOb2RlKCB0cnVlICkuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcIlwiO1xuXHRzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSA9IGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9PT0gXCJjb250ZW50LWJveFwiO1xuXG5cdGpRdWVyeS5leHRlbmQoIHN1cHBvcnQsIHtcblx0XHRib3hTaXppbmdSZWxpYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIGJveFNpemluZ1JlbGlhYmxlVmFsO1xuXHRcdH0sXG5cdFx0cGl4ZWxCb3hTdHlsZXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBwaXhlbEJveFN0eWxlc1ZhbDtcblx0XHR9LFxuXHRcdHBpeGVsUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBwaXhlbFBvc2l0aW9uVmFsO1xuXHRcdH0sXG5cdFx0cmVsaWFibGVNYXJnaW5MZWZ0OiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcmVsaWFibGVNYXJnaW5MZWZ0VmFsO1xuXHRcdH0sXG5cdFx0c2Nyb2xsYm94U2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHNjcm9sbGJveFNpemVWYWw7XG5cdFx0fSxcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSssIEVkZ2UgMTUgLSAxOCtcblx0XHQvLyBJRS9FZGdlIG1pc3JlcG9ydCBgZ2V0Q29tcHV0ZWRTdHlsZWAgb2YgdGFibGUgcm93cyB3aXRoIHdpZHRoL2hlaWdodFxuXHRcdC8vIHNldCBpbiBDU1Mgd2hpbGUgYG9mZnNldCpgIHByb3BlcnRpZXMgcmVwb3J0IGNvcnJlY3QgdmFsdWVzLlxuXHRcdC8vIEJlaGF2aW9yIGluIElFIDkgaXMgbW9yZSBzdWJ0bGUgdGhhbiBpbiBuZXdlciB2ZXJzaW9ucyAmIGl0IHBhc3Nlc1xuXHRcdC8vIHNvbWUgdmVyc2lvbnMgb2YgdGhpcyB0ZXN0OyBtYWtlIHN1cmUgbm90IHRvIG1ha2UgaXQgcGFzcyB0aGVyZSFcblx0XHRyZWxpYWJsZVRyRGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdGFibGUsIHRyLCB0ckNoaWxkLCB0clN0eWxlO1xuXHRcdFx0aWYgKCByZWxpYWJsZVRyRGltZW5zaW9uc1ZhbCA9PSBudWxsICkge1xuXHRcdFx0XHR0YWJsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwidGFibGVcIiApO1xuXHRcdFx0XHR0ciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwidHJcIiApO1xuXHRcdFx0XHR0ckNoaWxkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApO1xuXG5cdFx0XHRcdHRhYmxlLnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOmFic29sdXRlO2xlZnQ6LTExMTExcHhcIjtcblx0XHRcdFx0dHIuc3R5bGUuaGVpZ2h0ID0gXCIxcHhcIjtcblx0XHRcdFx0dHJDaGlsZC5zdHlsZS5oZWlnaHQgPSBcIjlweFwiO1xuXG5cdFx0XHRcdGRvY3VtZW50RWxlbWVudFxuXHRcdFx0XHRcdC5hcHBlbmRDaGlsZCggdGFibGUgKVxuXHRcdFx0XHRcdC5hcHBlbmRDaGlsZCggdHIgKVxuXHRcdFx0XHRcdC5hcHBlbmRDaGlsZCggdHJDaGlsZCApO1xuXG5cdFx0XHRcdHRyU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggdHIgKTtcblx0XHRcdFx0cmVsaWFibGVUckRpbWVuc2lvbnNWYWwgPSBwYXJzZUludCggdHJTdHlsZS5oZWlnaHQgKSA+IDM7XG5cblx0XHRcdFx0ZG9jdW1lbnRFbGVtZW50LnJlbW92ZUNoaWxkKCB0YWJsZSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlbGlhYmxlVHJEaW1lbnNpb25zVmFsO1xuXHRcdH1cblx0fSApO1xufSApKCk7XG5cblxuZnVuY3Rpb24gY3VyQ1NTKCBlbGVtLCBuYW1lLCBjb21wdXRlZCApIHtcblx0dmFyIHdpZHRoLCBtaW5XaWR0aCwgbWF4V2lkdGgsIHJldCxcblxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggNTErXG5cdFx0Ly8gUmV0cmlldmluZyBzdHlsZSBiZWZvcmUgY29tcHV0ZWQgc29tZWhvd1xuXHRcdC8vIGZpeGVzIGFuIGlzc3VlIHdpdGggZ2V0dGluZyB3cm9uZyB2YWx1ZXNcblx0XHQvLyBvbiBkZXRhY2hlZCBlbGVtZW50c1xuXHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRjb21wdXRlZCA9IGNvbXB1dGVkIHx8IGdldFN0eWxlcyggZWxlbSApO1xuXG5cdC8vIGdldFByb3BlcnR5VmFsdWUgaXMgbmVlZGVkIGZvcjpcblx0Ly8gICAuY3NzKCdmaWx0ZXInKSAoSUUgOSBvbmx5LCAjMTI1MzcpXG5cdC8vICAgLmNzcygnLS1jdXN0b21Qcm9wZXJ0eSkgKCMzMTQ0KVxuXHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdHJldCA9IGNvbXB1dGVkLmdldFByb3BlcnR5VmFsdWUoIG5hbWUgKSB8fCBjb21wdXRlZFsgbmFtZSBdO1xuXG5cdFx0aWYgKCByZXQgPT09IFwiXCIgJiYgIWlzQXR0YWNoZWQoIGVsZW0gKSApIHtcblx0XHRcdHJldCA9IGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIEEgdHJpYnV0ZSB0byB0aGUgXCJhd2Vzb21lIGhhY2sgYnkgRGVhbiBFZHdhcmRzXCJcblx0XHQvLyBBbmRyb2lkIEJyb3dzZXIgcmV0dXJucyBwZXJjZW50YWdlIGZvciBzb21lIHZhbHVlcyxcblx0XHQvLyBidXQgd2lkdGggc2VlbXMgdG8gYmUgcmVsaWFibHkgcGl4ZWxzLlxuXHRcdC8vIFRoaXMgaXMgYWdhaW5zdCB0aGUgQ1NTT00gZHJhZnQgc3BlYzpcblx0XHQvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20vI3Jlc29sdmVkLXZhbHVlc1xuXHRcdGlmICggIXN1cHBvcnQucGl4ZWxCb3hTdHlsZXMoKSAmJiBybnVtbm9ucHgudGVzdCggcmV0ICkgJiYgcmJveFN0eWxlLnRlc3QoIG5hbWUgKSApIHtcblxuXHRcdFx0Ly8gUmVtZW1iZXIgdGhlIG9yaWdpbmFsIHZhbHVlc1xuXHRcdFx0d2lkdGggPSBzdHlsZS53aWR0aDtcblx0XHRcdG1pbldpZHRoID0gc3R5bGUubWluV2lkdGg7XG5cdFx0XHRtYXhXaWR0aCA9IHN0eWxlLm1heFdpZHRoO1xuXG5cdFx0XHQvLyBQdXQgaW4gdGhlIG5ldyB2YWx1ZXMgdG8gZ2V0IGEgY29tcHV0ZWQgdmFsdWUgb3V0XG5cdFx0XHRzdHlsZS5taW5XaWR0aCA9IHN0eWxlLm1heFdpZHRoID0gc3R5bGUud2lkdGggPSByZXQ7XG5cdFx0XHRyZXQgPSBjb21wdXRlZC53aWR0aDtcblxuXHRcdFx0Ly8gUmV2ZXJ0IHRoZSBjaGFuZ2VkIHZhbHVlc1xuXHRcdFx0c3R5bGUud2lkdGggPSB3aWR0aDtcblx0XHRcdHN0eWxlLm1pbldpZHRoID0gbWluV2lkdGg7XG5cdFx0XHRzdHlsZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiByZXQgIT09IHVuZGVmaW5lZCA/XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdFx0Ly8gSUUgcmV0dXJucyB6SW5kZXggdmFsdWUgYXMgYW4gaW50ZWdlci5cblx0XHRyZXQgKyBcIlwiIDpcblx0XHRyZXQ7XG59XG5cblxuZnVuY3Rpb24gYWRkR2V0SG9va0lmKCBjb25kaXRpb25GbiwgaG9va0ZuICkge1xuXG5cdC8vIERlZmluZSB0aGUgaG9vaywgd2UnbGwgY2hlY2sgb24gdGhlIGZpcnN0IHJ1biBpZiBpdCdzIHJlYWxseSBuZWVkZWQuXG5cdHJldHVybiB7XG5cdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggY29uZGl0aW9uRm4oKSApIHtcblxuXHRcdFx0XHQvLyBIb29rIG5vdCBuZWVkZWQgKG9yIGl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBpdCBkdWVcblx0XHRcdFx0Ly8gdG8gbWlzc2luZyBkZXBlbmRlbmN5KSwgcmVtb3ZlIGl0LlxuXHRcdFx0XHRkZWxldGUgdGhpcy5nZXQ7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSG9vayBuZWVkZWQ7IHJlZGVmaW5lIGl0IHNvIHRoYXQgdGhlIHN1cHBvcnQgdGVzdCBpcyBub3QgZXhlY3V0ZWQgYWdhaW4uXG5cdFx0XHRyZXR1cm4gKCB0aGlzLmdldCA9IGhvb2tGbiApLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9XG5cdH07XG59XG5cblxudmFyIGNzc1ByZWZpeGVzID0gWyBcIldlYmtpdFwiLCBcIk1velwiLCBcIm1zXCIgXSxcblx0ZW1wdHlTdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKS5zdHlsZSxcblx0dmVuZG9yUHJvcHMgPSB7fTtcblxuLy8gUmV0dXJuIGEgdmVuZG9yLXByZWZpeGVkIHByb3BlcnR5IG9yIHVuZGVmaW5lZFxuZnVuY3Rpb24gdmVuZG9yUHJvcE5hbWUoIG5hbWUgKSB7XG5cblx0Ly8gQ2hlY2sgZm9yIHZlbmRvciBwcmVmaXhlZCBuYW1lc1xuXHR2YXIgY2FwTmFtZSA9IG5hbWVbIDAgXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSggMSApLFxuXHRcdGkgPSBjc3NQcmVmaXhlcy5sZW5ndGg7XG5cblx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0bmFtZSA9IGNzc1ByZWZpeGVzWyBpIF0gKyBjYXBOYW1lO1xuXHRcdGlmICggbmFtZSBpbiBlbXB0eVN0eWxlICkge1xuXHRcdFx0cmV0dXJuIG5hbWU7XG5cdFx0fVxuXHR9XG59XG5cbi8vIFJldHVybiBhIHBvdGVudGlhbGx5LW1hcHBlZCBqUXVlcnkuY3NzUHJvcHMgb3IgdmVuZG9yIHByZWZpeGVkIHByb3BlcnR5XG5mdW5jdGlvbiBmaW5hbFByb3BOYW1lKCBuYW1lICkge1xuXHR2YXIgZmluYWwgPSBqUXVlcnkuY3NzUHJvcHNbIG5hbWUgXSB8fCB2ZW5kb3JQcm9wc1sgbmFtZSBdO1xuXG5cdGlmICggZmluYWwgKSB7XG5cdFx0cmV0dXJuIGZpbmFsO1xuXHR9XG5cdGlmICggbmFtZSBpbiBlbXB0eVN0eWxlICkge1xuXHRcdHJldHVybiBuYW1lO1xuXHR9XG5cdHJldHVybiB2ZW5kb3JQcm9wc1sgbmFtZSBdID0gdmVuZG9yUHJvcE5hbWUoIG5hbWUgKSB8fCBuYW1lO1xufVxuXG5cbnZhclxuXG5cdC8vIFN3YXBwYWJsZSBpZiBkaXNwbGF5IGlzIG5vbmUgb3Igc3RhcnRzIHdpdGggdGFibGVcblx0Ly8gZXhjZXB0IFwidGFibGVcIiwgXCJ0YWJsZS1jZWxsXCIsIG9yIFwidGFibGUtY2FwdGlvblwiXG5cdC8vIFNlZSBoZXJlIGZvciBkaXNwbGF5IHZhbHVlczogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9DU1MvZGlzcGxheVxuXHRyZGlzcGxheXN3YXAgPSAvXihub25lfHRhYmxlKD8hLWNbZWFdKS4rKS8sXG5cdHJjdXN0b21Qcm9wID0gL14tLS8sXG5cdGNzc1Nob3cgPSB7IHBvc2l0aW9uOiBcImFic29sdXRlXCIsIHZpc2liaWxpdHk6IFwiaGlkZGVuXCIsIGRpc3BsYXk6IFwiYmxvY2tcIiB9LFxuXHRjc3NOb3JtYWxUcmFuc2Zvcm0gPSB7XG5cdFx0bGV0dGVyU3BhY2luZzogXCIwXCIsXG5cdFx0Zm9udFdlaWdodDogXCI0MDBcIlxuXHR9O1xuXG5mdW5jdGlvbiBzZXRQb3NpdGl2ZU51bWJlciggX2VsZW0sIHZhbHVlLCBzdWJ0cmFjdCApIHtcblxuXHQvLyBBbnkgcmVsYXRpdmUgKCsvLSkgdmFsdWVzIGhhdmUgYWxyZWFkeSBiZWVuXG5cdC8vIG5vcm1hbGl6ZWQgYXQgdGhpcyBwb2ludFxuXHR2YXIgbWF0Y2hlcyA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKTtcblx0cmV0dXJuIG1hdGNoZXMgP1xuXG5cdFx0Ly8gR3VhcmQgYWdhaW5zdCB1bmRlZmluZWQgXCJzdWJ0cmFjdFwiLCBlLmcuLCB3aGVuIHVzZWQgYXMgaW4gY3NzSG9va3Ncblx0XHRNYXRoLm1heCggMCwgbWF0Y2hlc1sgMiBdIC0gKCBzdWJ0cmFjdCB8fCAwICkgKSArICggbWF0Y2hlc1sgMyBdIHx8IFwicHhcIiApIDpcblx0XHR2YWx1ZTtcbn1cblxuZnVuY3Rpb24gYm94TW9kZWxBZGp1c3RtZW50KCBlbGVtLCBkaW1lbnNpb24sIGJveCwgaXNCb3JkZXJCb3gsIHN0eWxlcywgY29tcHV0ZWRWYWwgKSB7XG5cdHZhciBpID0gZGltZW5zaW9uID09PSBcIndpZHRoXCIgPyAxIDogMCxcblx0XHRleHRyYSA9IDAsXG5cdFx0ZGVsdGEgPSAwO1xuXG5cdC8vIEFkanVzdG1lbnQgbWF5IG5vdCBiZSBuZWNlc3Nhcnlcblx0aWYgKCBib3ggPT09ICggaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIgKSApIHtcblx0XHRyZXR1cm4gMDtcblx0fVxuXG5cdGZvciAoIDsgaSA8IDQ7IGkgKz0gMiApIHtcblxuXHRcdC8vIEJvdGggYm94IG1vZGVscyBleGNsdWRlIG1hcmdpblxuXHRcdGlmICggYm94ID09PSBcIm1hcmdpblwiICkge1xuXHRcdFx0ZGVsdGEgKz0galF1ZXJ5LmNzcyggZWxlbSwgYm94ICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdC8vIElmIHdlIGdldCBoZXJlIHdpdGggYSBjb250ZW50LWJveCwgd2UncmUgc2Vla2luZyBcInBhZGRpbmdcIiBvciBcImJvcmRlclwiIG9yIFwibWFyZ2luXCJcblx0XHRpZiAoICFpc0JvcmRlckJveCApIHtcblxuXHRcdFx0Ly8gQWRkIHBhZGRpbmdcblx0XHRcdGRlbHRhICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXG5cdFx0XHQvLyBGb3IgXCJib3JkZXJcIiBvciBcIm1hcmdpblwiLCBhZGQgYm9yZGVyXG5cdFx0XHRpZiAoIGJveCAhPT0gXCJwYWRkaW5nXCIgKSB7XG5cdFx0XHRcdGRlbHRhICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cblx0XHRcdC8vIEJ1dCBzdGlsbCBrZWVwIHRyYWNrIG9mIGl0IG90aGVyd2lzZVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZXh0cmEgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblxuXHRcdC8vIElmIHdlIGdldCBoZXJlIHdpdGggYSBib3JkZXItYm94IChjb250ZW50ICsgcGFkZGluZyArIGJvcmRlciksIHdlJ3JlIHNlZWtpbmcgXCJjb250ZW50XCIgb3Jcblx0XHQvLyBcInBhZGRpbmdcIiBvciBcIm1hcmdpblwiXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gRm9yIFwiY29udGVudFwiLCBzdWJ0cmFjdCBwYWRkaW5nXG5cdFx0XHRpZiAoIGJveCA9PT0gXCJjb250ZW50XCIgKSB7XG5cdFx0XHRcdGRlbHRhIC09IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGb3IgXCJjb250ZW50XCIgb3IgXCJwYWRkaW5nXCIsIHN1YnRyYWN0IGJvcmRlclxuXHRcdFx0aWYgKCBib3ggIT09IFwibWFyZ2luXCIgKSB7XG5cdFx0XHRcdGRlbHRhIC09IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQWNjb3VudCBmb3IgcG9zaXRpdmUgY29udGVudC1ib3ggc2Nyb2xsIGd1dHRlciB3aGVuIHJlcXVlc3RlZCBieSBwcm92aWRpbmcgY29tcHV0ZWRWYWxcblx0aWYgKCAhaXNCb3JkZXJCb3ggJiYgY29tcHV0ZWRWYWwgPj0gMCApIHtcblxuXHRcdC8vIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBpcyBhIHJvdW5kZWQgc3VtIG9mIGNvbnRlbnQsIHBhZGRpbmcsIHNjcm9sbCBndXR0ZXIsIGFuZCBib3JkZXJcblx0XHQvLyBBc3N1bWluZyBpbnRlZ2VyIHNjcm9sbCBndXR0ZXIsIHN1YnRyYWN0IHRoZSByZXN0IGFuZCByb3VuZCBkb3duXG5cdFx0ZGVsdGEgKz0gTWF0aC5tYXgoIDAsIE1hdGguY2VpbChcblx0XHRcdGVsZW1bIFwib2Zmc2V0XCIgKyBkaW1lbnNpb25bIDAgXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKCAxICkgXSAtXG5cdFx0XHRjb21wdXRlZFZhbCAtXG5cdFx0XHRkZWx0YSAtXG5cdFx0XHRleHRyYSAtXG5cdFx0XHQwLjVcblxuXHRcdC8vIElmIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBpcyB1bmtub3duLCB0aGVuIHdlIGNhbid0IGRldGVybWluZSBjb250ZW50LWJveCBzY3JvbGwgZ3V0dGVyXG5cdFx0Ly8gVXNlIGFuIGV4cGxpY2l0IHplcm8gdG8gYXZvaWQgTmFOIChnaC0zOTY0KVxuXHRcdCkgKSB8fCAwO1xuXHR9XG5cblx0cmV0dXJuIGRlbHRhO1xufVxuXG5mdW5jdGlvbiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBkaW1lbnNpb24sIGV4dHJhICkge1xuXG5cdC8vIFN0YXJ0IHdpdGggY29tcHV0ZWQgc3R5bGVcblx0dmFyIHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApLFxuXG5cdFx0Ly8gVG8gYXZvaWQgZm9yY2luZyBhIHJlZmxvdywgb25seSBmZXRjaCBib3hTaXppbmcgaWYgd2UgbmVlZCBpdCAoZ2gtNDMyMikuXG5cdFx0Ly8gRmFrZSBjb250ZW50LWJveCB1bnRpbCB3ZSBrbm93IGl0J3MgbmVlZGVkIHRvIGtub3cgdGhlIHRydWUgdmFsdWUuXG5cdFx0Ym94U2l6aW5nTmVlZGVkID0gIXN1cHBvcnQuYm94U2l6aW5nUmVsaWFibGUoKSB8fCBleHRyYSxcblx0XHRpc0JvcmRlckJveCA9IGJveFNpemluZ05lZWRlZCAmJlxuXHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIixcblx0XHR2YWx1ZUlzQm9yZGVyQm94ID0gaXNCb3JkZXJCb3gsXG5cblx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIGRpbWVuc2lvbiwgc3R5bGVzICksXG5cdFx0b2Zmc2V0UHJvcCA9IFwib2Zmc2V0XCIgKyBkaW1lbnNpb25bIDAgXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKCAxICk7XG5cblx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTU0XG5cdC8vIFJldHVybiBhIGNvbmZvdW5kaW5nIG5vbi1waXhlbCB2YWx1ZSBvciBmZWlnbiBpZ25vcmFuY2UsIGFzIGFwcHJvcHJpYXRlLlxuXHRpZiAoIHJudW1ub25weC50ZXN0KCB2YWwgKSApIHtcblx0XHRpZiAoICFleHRyYSApIHtcblx0XHRcdHJldHVybiB2YWw7XG5cdFx0fVxuXHRcdHZhbCA9IFwiYXV0b1wiO1xuXHR9XG5cblxuXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seVxuXHQvLyBVc2Ugb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGZvciB3aGVuIGJveCBzaXppbmcgaXMgdW5yZWxpYWJsZS5cblx0Ly8gSW4gdGhvc2UgY2FzZXMsIHRoZSBjb21wdXRlZCB2YWx1ZSBjYW4gYmUgdHJ1c3RlZCB0byBiZSBib3JkZXItYm94LlxuXHRpZiAoICggIXN1cHBvcnQuYm94U2l6aW5nUmVsaWFibGUoKSAmJiBpc0JvcmRlckJveCB8fFxuXG5cdFx0Ly8gU3VwcG9ydDogSUUgMTAgLSAxMSssIEVkZ2UgMTUgLSAxOCtcblx0XHQvLyBJRS9FZGdlIG1pc3JlcG9ydCBgZ2V0Q29tcHV0ZWRTdHlsZWAgb2YgdGFibGUgcm93cyB3aXRoIHdpZHRoL2hlaWdodFxuXHRcdC8vIHNldCBpbiBDU1Mgd2hpbGUgYG9mZnNldCpgIHByb3BlcnRpZXMgcmVwb3J0IGNvcnJlY3QgdmFsdWVzLlxuXHRcdC8vIEludGVyZXN0aW5nbHksIGluIHNvbWUgY2FzZXMgSUUgOSBkb2Vzbid0IHN1ZmZlciBmcm9tIHRoaXMgaXNzdWUuXG5cdFx0IXN1cHBvcnQucmVsaWFibGVUckRpbWVuc2lvbnMoKSAmJiBub2RlTmFtZSggZWxlbSwgXCJ0clwiICkgfHxcblxuXHRcdC8vIEZhbGwgYmFjayB0byBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgd2hlbiB2YWx1ZSBpcyBcImF1dG9cIlxuXHRcdC8vIFRoaXMgaGFwcGVucyBmb3IgaW5saW5lIGVsZW1lbnRzIHdpdGggbm8gZXhwbGljaXQgc2V0dGluZyAoZ2gtMzU3MSlcblx0XHR2YWwgPT09IFwiYXV0b1wiIHx8XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4xIC0gNC4zIG9ubHlcblx0XHQvLyBBbHNvIHVzZSBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgZm9yIG1pc3JlcG9ydGVkIGlubGluZSBkaW1lbnNpb25zIChnaC0zNjAyKVxuXHRcdCFwYXJzZUZsb2F0KCB2YWwgKSAmJiBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImlubGluZVwiICkgJiZcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGUgZWxlbWVudCBpcyB2aXNpYmxlICYgY29ubmVjdGVkXG5cdFx0ZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApIHtcblxuXHRcdGlzQm9yZGVyQm94ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIjtcblxuXHRcdC8vIFdoZXJlIGF2YWlsYWJsZSwgb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGFwcHJveGltYXRlIGJvcmRlciBib3ggZGltZW5zaW9ucy5cblx0XHQvLyBXaGVyZSBub3QgYXZhaWxhYmxlIChlLmcuLCBTVkcpLCBhc3N1bWUgdW5yZWxpYWJsZSBib3gtc2l6aW5nIGFuZCBpbnRlcnByZXQgdGhlXG5cdFx0Ly8gcmV0cmlldmVkIHZhbHVlIGFzIGEgY29udGVudCBib3ggZGltZW5zaW9uLlxuXHRcdHZhbHVlSXNCb3JkZXJCb3ggPSBvZmZzZXRQcm9wIGluIGVsZW07XG5cdFx0aWYgKCB2YWx1ZUlzQm9yZGVyQm94ICkge1xuXHRcdFx0dmFsID0gZWxlbVsgb2Zmc2V0UHJvcCBdO1xuXHRcdH1cblx0fVxuXG5cdC8vIE5vcm1hbGl6ZSBcIlwiIGFuZCBhdXRvXG5cdHZhbCA9IHBhcnNlRmxvYXQoIHZhbCApIHx8IDA7XG5cblx0Ly8gQWRqdXN0IGZvciB0aGUgZWxlbWVudCdzIGJveCBtb2RlbFxuXHRyZXR1cm4gKCB2YWwgK1xuXHRcdGJveE1vZGVsQWRqdXN0bWVudChcblx0XHRcdGVsZW0sXG5cdFx0XHRkaW1lbnNpb24sXG5cdFx0XHRleHRyYSB8fCAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICksXG5cdFx0XHR2YWx1ZUlzQm9yZGVyQm94LFxuXHRcdFx0c3R5bGVzLFxuXG5cdFx0XHQvLyBQcm92aWRlIHRoZSBjdXJyZW50IGNvbXB1dGVkIHNpemUgdG8gcmVxdWVzdCBzY3JvbGwgZ3V0dGVyIGNhbGN1bGF0aW9uIChnaC0zNTg5KVxuXHRcdFx0dmFsXG5cdFx0KVxuXHQpICsgXCJweFwiO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gQWRkIGluIHN0eWxlIHByb3BlcnR5IGhvb2tzIGZvciBvdmVycmlkaW5nIHRoZSBkZWZhdWx0XG5cdC8vIGJlaGF2aW9yIG9mIGdldHRpbmcgYW5kIHNldHRpbmcgYSBzdHlsZSBwcm9wZXJ0eVxuXHRjc3NIb29rczoge1xuXHRcdG9wYWNpdHk6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0XHRcdFx0Ly8gV2Ugc2hvdWxkIGFsd2F5cyBnZXQgYSBudW1iZXIgYmFjayBmcm9tIG9wYWNpdHlcblx0XHRcdFx0XHR2YXIgcmV0ID0gY3VyQ1NTKCBlbGVtLCBcIm9wYWNpdHlcIiApO1xuXHRcdFx0XHRcdHJldHVybiByZXQgPT09IFwiXCIgPyBcIjFcIiA6IHJldDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBEb24ndCBhdXRvbWF0aWNhbGx5IGFkZCBcInB4XCIgdG8gdGhlc2UgcG9zc2libHktdW5pdGxlc3MgcHJvcGVydGllc1xuXHRjc3NOdW1iZXI6IHtcblx0XHRcImFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50XCI6IHRydWUsXG5cdFx0XCJjb2x1bW5Db3VudFwiOiB0cnVlLFxuXHRcdFwiZmlsbE9wYWNpdHlcIjogdHJ1ZSxcblx0XHRcImZsZXhHcm93XCI6IHRydWUsXG5cdFx0XCJmbGV4U2hyaW5rXCI6IHRydWUsXG5cdFx0XCJmb250V2VpZ2h0XCI6IHRydWUsXG5cdFx0XCJncmlkQXJlYVwiOiB0cnVlLFxuXHRcdFwiZ3JpZENvbHVtblwiOiB0cnVlLFxuXHRcdFwiZ3JpZENvbHVtbkVuZFwiOiB0cnVlLFxuXHRcdFwiZ3JpZENvbHVtblN0YXJ0XCI6IHRydWUsXG5cdFx0XCJncmlkUm93XCI6IHRydWUsXG5cdFx0XCJncmlkUm93RW5kXCI6IHRydWUsXG5cdFx0XCJncmlkUm93U3RhcnRcIjogdHJ1ZSxcblx0XHRcImxpbmVIZWlnaHRcIjogdHJ1ZSxcblx0XHRcIm9wYWNpdHlcIjogdHJ1ZSxcblx0XHRcIm9yZGVyXCI6IHRydWUsXG5cdFx0XCJvcnBoYW5zXCI6IHRydWUsXG5cdFx0XCJ3aWRvd3NcIjogdHJ1ZSxcblx0XHRcInpJbmRleFwiOiB0cnVlLFxuXHRcdFwiem9vbVwiOiB0cnVlXG5cdH0sXG5cblx0Ly8gQWRkIGluIHByb3BlcnRpZXMgd2hvc2UgbmFtZXMgeW91IHdpc2ggdG8gZml4IGJlZm9yZVxuXHQvLyBzZXR0aW5nIG9yIGdldHRpbmcgdGhlIHZhbHVlXG5cdGNzc1Byb3BzOiB7fSxcblxuXHQvLyBHZXQgYW5kIHNldCB0aGUgc3R5bGUgcHJvcGVydHkgb24gYSBET00gTm9kZVxuXHRzdHlsZTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlLCBleHRyYSApIHtcblxuXHRcdC8vIERvbid0IHNldCBzdHlsZXMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggIWVsZW0gfHwgZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4IHx8ICFlbGVtLnN0eWxlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxuXHRcdHZhciByZXQsIHR5cGUsIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBjYW1lbENhc2UoIG5hbWUgKSxcblx0XHRcdGlzQ3VzdG9tUHJvcCA9IHJjdXN0b21Qcm9wLnRlc3QoIG5hbWUgKSxcblx0XHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZS4gV2UgZG9uJ3Rcblx0XHQvLyB3YW50IHRvIHF1ZXJ5IHRoZSB2YWx1ZSBpZiBpdCBpcyBhIENTUyBjdXN0b20gcHJvcGVydHlcblx0XHQvLyBzaW5jZSB0aGV5IGFyZSB1c2VyLWRlZmluZWQuXG5cdFx0aWYgKCAhaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0bmFtZSA9IGZpbmFsUHJvcE5hbWUoIG9yaWdOYW1lICk7XG5cdFx0fVxuXG5cdFx0Ly8gR2V0cyBob29rIGZvciB0aGUgcHJlZml4ZWQgdmVyc2lvbiwgdGhlbiB1bnByZWZpeGVkIHZlcnNpb25cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdC8vIENoZWNrIGlmIHdlJ3JlIHNldHRpbmcgYSB2YWx1ZVxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cblx0XHRcdC8vIENvbnZlcnQgXCIrPVwiIG9yIFwiLT1cIiB0byByZWxhdGl2ZSBudW1iZXJzICgjNzM0NSlcblx0XHRcdGlmICggdHlwZSA9PT0gXCJzdHJpbmdcIiAmJiAoIHJldCA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKSApICYmIHJldFsgMSBdICkge1xuXHRcdFx0XHR2YWx1ZSA9IGFkanVzdENTUyggZWxlbSwgbmFtZSwgcmV0ICk7XG5cblx0XHRcdFx0Ly8gRml4ZXMgYnVnICM5MjM3XG5cdFx0XHRcdHR5cGUgPSBcIm51bWJlclwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCBudWxsIGFuZCBOYU4gdmFsdWVzIGFyZW4ndCBzZXQgKCM3MTE2KVxuXHRcdFx0aWYgKCB2YWx1ZSA9PSBudWxsIHx8IHZhbHVlICE9PSB2YWx1ZSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhIG51bWJlciB3YXMgcGFzc2VkIGluLCBhZGQgdGhlIHVuaXQgKGV4Y2VwdCBmb3IgY2VydGFpbiBDU1MgcHJvcGVydGllcylcblx0XHRcdC8vIFRoZSBpc0N1c3RvbVByb3AgY2hlY2sgY2FuIGJlIHJlbW92ZWQgaW4galF1ZXJ5IDQuMCB3aGVuIHdlIG9ubHkgYXV0by1hcHBlbmRcblx0XHRcdC8vIFwicHhcIiB0byBhIGZldyBoYXJkY29kZWQgdmFsdWVzLlxuXHRcdFx0aWYgKCB0eXBlID09PSBcIm51bWJlclwiICYmICFpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRcdHZhbHVlICs9IHJldCAmJiByZXRbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIG9yaWdOYW1lIF0gPyBcIlwiIDogXCJweFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGJhY2tncm91bmQtKiBwcm9wcyBhZmZlY3Qgb3JpZ2luYWwgY2xvbmUncyB2YWx1ZXNcblx0XHRcdGlmICggIXN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlICYmIHZhbHVlID09PSBcIlwiICYmIG5hbWUuaW5kZXhPZiggXCJiYWNrZ3JvdW5kXCIgKSA9PT0gMCApIHtcblx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IFwiaW5oZXJpdFwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkLCB1c2UgdGhhdCB2YWx1ZSwgb3RoZXJ3aXNlIGp1c3Qgc2V0IHRoZSBzcGVjaWZpZWQgdmFsdWVcblx0XHRcdGlmICggIWhvb2tzIHx8ICEoIFwic2V0XCIgaW4gaG9va3MgKSB8fFxuXHRcdFx0XHQoIHZhbHVlID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0aWYgKCBpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRcdFx0c3R5bGUuc2V0UHJvcGVydHkoIG5hbWUsIHZhbHVlICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgbm9uLWNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcblx0XHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgZmFsc2UsIGV4dHJhICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE90aGVyd2lzZSBqdXN0IGdldCB0aGUgdmFsdWUgZnJvbSB0aGUgc3R5bGUgb2JqZWN0XG5cdFx0XHRyZXR1cm4gc3R5bGVbIG5hbWUgXTtcblx0XHR9XG5cdH0sXG5cblx0Y3NzOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZXh0cmEsIHN0eWxlcyApIHtcblx0XHR2YXIgdmFsLCBudW0sIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBjYW1lbENhc2UoIG5hbWUgKSxcblx0XHRcdGlzQ3VzdG9tUHJvcCA9IHJjdXN0b21Qcm9wLnRlc3QoIG5hbWUgKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZS4gV2UgZG9uJ3Rcblx0XHQvLyB3YW50IHRvIG1vZGlmeSB0aGUgdmFsdWUgaWYgaXQgaXMgYSBDU1MgY3VzdG9tIHByb3BlcnR5XG5cdFx0Ly8gc2luY2UgdGhleSBhcmUgdXNlci1kZWZpbmVkLlxuXHRcdGlmICggIWlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdG5hbWUgPSBmaW5hbFByb3BOYW1lKCBvcmlnTmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIFRyeSBwcmVmaXhlZCBuYW1lIGZvbGxvd2VkIGJ5IHRoZSB1bnByZWZpeGVkIG5hbWVcblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsID0gaG9va3MuZ2V0KCBlbGVtLCB0cnVlLCBleHRyYSApO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSwgaWYgYSB3YXkgdG8gZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBleGlzdHMsIHVzZSB0aGF0XG5cdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgbmFtZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBcIm5vcm1hbFwiIHRvIGNvbXB1dGVkIHZhbHVlXG5cdFx0aWYgKCB2YWwgPT09IFwibm9ybWFsXCIgJiYgbmFtZSBpbiBjc3NOb3JtYWxUcmFuc2Zvcm0gKSB7XG5cdFx0XHR2YWwgPSBjc3NOb3JtYWxUcmFuc2Zvcm1bIG5hbWUgXTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIG51bWVyaWMgaWYgZm9yY2VkIG9yIGEgcXVhbGlmaWVyIHdhcyBwcm92aWRlZCBhbmQgdmFsIGxvb2tzIG51bWVyaWNcblx0XHRpZiAoIGV4dHJhID09PSBcIlwiIHx8IGV4dHJhICkge1xuXHRcdFx0bnVtID0gcGFyc2VGbG9hdCggdmFsICk7XG5cdFx0XHRyZXR1cm4gZXh0cmEgPT09IHRydWUgfHwgaXNGaW5pdGUoIG51bSApID8gbnVtIHx8IDAgOiB2YWw7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbDtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcImhlaWdodFwiLCBcIndpZHRoXCIgXSwgZnVuY3Rpb24oIF9pLCBkaW1lbnNpb24gKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgZGltZW5zaW9uIF0gPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQsIGV4dHJhICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0XHQvLyBDZXJ0YWluIGVsZW1lbnRzIGNhbiBoYXZlIGRpbWVuc2lvbiBpbmZvIGlmIHdlIGludmlzaWJseSBzaG93IHRoZW1cblx0XHRcdFx0Ly8gYnV0IGl0IG11c3QgaGF2ZSBhIGN1cnJlbnQgZGlzcGxheSBzdHlsZSB0aGF0IHdvdWxkIGJlbmVmaXRcblx0XHRcdFx0cmV0dXJuIHJkaXNwbGF5c3dhcC50ZXN0KCBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApICkgJiZcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA4K1xuXHRcdFx0XHRcdC8vIFRhYmxlIGNvbHVtbnMgaW4gU2FmYXJpIGhhdmUgbm9uLXplcm8gb2Zmc2V0V2lkdGggJiB6ZXJvXG5cdFx0XHRcdFx0Ly8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggdW5sZXNzIGRpc3BsYXkgaXMgY2hhbmdlZC5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0XHRcdFx0XHQvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlXG5cdFx0XHRcdFx0Ly8gaW4gSUUgdGhyb3dzIGFuIGVycm9yLlxuXHRcdFx0XHRcdCggIWVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggfHwgIWVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggKSA/XG5cdFx0XHRcdFx0XHRzd2FwKCBlbGVtLCBjc3NTaG93LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIGRpbWVuc2lvbiwgZXh0cmEgKTtcblx0XHRcdFx0XHRcdH0gKSA6XG5cdFx0XHRcdFx0XHRnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBkaW1lbnNpb24sIGV4dHJhICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBleHRyYSApIHtcblx0XHRcdHZhciBtYXRjaGVzLFxuXHRcdFx0XHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKSxcblxuXHRcdFx0XHQvLyBPbmx5IHJlYWQgc3R5bGVzLnBvc2l0aW9uIGlmIHRoZSB0ZXN0IGhhcyBhIGNoYW5jZSB0byBmYWlsXG5cdFx0XHRcdC8vIHRvIGF2b2lkIGZvcmNpbmcgYSByZWZsb3cuXG5cdFx0XHRcdHNjcm9sbGJveFNpemVCdWdneSA9ICFzdXBwb3J0LnNjcm9sbGJveFNpemUoKSAmJlxuXHRcdFx0XHRcdHN0eWxlcy5wb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiLFxuXG5cdFx0XHRcdC8vIFRvIGF2b2lkIGZvcmNpbmcgYSByZWZsb3csIG9ubHkgZmV0Y2ggYm94U2l6aW5nIGlmIHdlIG5lZWQgaXQgKGdoLTM5OTEpXG5cdFx0XHRcdGJveFNpemluZ05lZWRlZCA9IHNjcm9sbGJveFNpemVCdWdneSB8fCBleHRyYSxcblx0XHRcdFx0aXNCb3JkZXJCb3ggPSBib3hTaXppbmdOZWVkZWQgJiZcblx0XHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiLFxuXHRcdFx0XHRzdWJ0cmFjdCA9IGV4dHJhID9cblx0XHRcdFx0XHRib3hNb2RlbEFkanVzdG1lbnQoXG5cdFx0XHRcdFx0XHRlbGVtLFxuXHRcdFx0XHRcdFx0ZGltZW5zaW9uLFxuXHRcdFx0XHRcdFx0ZXh0cmEsXG5cdFx0XHRcdFx0XHRpc0JvcmRlckJveCxcblx0XHRcdFx0XHRcdHN0eWxlc1xuXHRcdFx0XHRcdCkgOlxuXHRcdFx0XHRcdDA7XG5cblx0XHRcdC8vIEFjY291bnQgZm9yIHVucmVsaWFibGUgYm9yZGVyLWJveCBkaW1lbnNpb25zIGJ5IGNvbXBhcmluZyBvZmZzZXQqIHRvIGNvbXB1dGVkIGFuZFxuXHRcdFx0Ly8gZmFraW5nIGEgY29udGVudC1ib3ggdG8gZ2V0IGJvcmRlciBhbmQgcGFkZGluZyAoZ2gtMzY5OSlcblx0XHRcdGlmICggaXNCb3JkZXJCb3ggJiYgc2Nyb2xsYm94U2l6ZUJ1Z2d5ICkge1xuXHRcdFx0XHRzdWJ0cmFjdCAtPSBNYXRoLmNlaWwoXG5cdFx0XHRcdFx0ZWxlbVsgXCJvZmZzZXRcIiArIGRpbWVuc2lvblsgMCBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoIDEgKSBdIC1cblx0XHRcdFx0XHRwYXJzZUZsb2F0KCBzdHlsZXNbIGRpbWVuc2lvbiBdICkgLVxuXHRcdFx0XHRcdGJveE1vZGVsQWRqdXN0bWVudCggZWxlbSwgZGltZW5zaW9uLCBcImJvcmRlclwiLCBmYWxzZSwgc3R5bGVzICkgLVxuXHRcdFx0XHRcdDAuNVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb252ZXJ0IHRvIHBpeGVscyBpZiB2YWx1ZSBhZGp1c3RtZW50IGlzIG5lZWRlZFxuXHRcdFx0aWYgKCBzdWJ0cmFjdCAmJiAoIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJlxuXHRcdFx0XHQoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSAhPT0gXCJweFwiICkge1xuXG5cdFx0XHRcdGVsZW0uc3R5bGVbIGRpbWVuc2lvbiBdID0gdmFsdWU7XG5cdFx0XHRcdHZhbHVlID0galF1ZXJ5LmNzcyggZWxlbSwgZGltZW5zaW9uICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICk7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5qUXVlcnkuY3NzSG9va3MubWFyZ2luTGVmdCA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5yZWxpYWJsZU1hcmdpbkxlZnQsXG5cdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0cmV0dXJuICggcGFyc2VGbG9hdCggY3VyQ1NTKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiApICkgfHxcblx0XHRcdFx0ZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0IC1cblx0XHRcdFx0XHRzd2FwKCBlbGVtLCB7IG1hcmdpbkxlZnQ6IDAgfSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuXHRcdFx0XHRcdH0gKVxuXHRcdFx0XHQpICsgXCJweFwiO1xuXHRcdH1cblx0fVxuKTtcblxuLy8gVGhlc2UgaG9va3MgYXJlIHVzZWQgYnkgYW5pbWF0ZSB0byBleHBhbmQgcHJvcGVydGllc1xualF1ZXJ5LmVhY2goIHtcblx0bWFyZ2luOiBcIlwiLFxuXHRwYWRkaW5nOiBcIlwiLFxuXHRib3JkZXI6IFwiV2lkdGhcIlxufSwgZnVuY3Rpb24oIHByZWZpeCwgc3VmZml4ICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdID0ge1xuXHRcdGV4cGFuZDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGkgPSAwLFxuXHRcdFx0XHRleHBhbmRlZCA9IHt9LFxuXG5cdFx0XHRcdC8vIEFzc3VtZXMgYSBzaW5nbGUgbnVtYmVyIGlmIG5vdCBhIHN0cmluZ1xuXHRcdFx0XHRwYXJ0cyA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHZhbHVlLnNwbGl0KCBcIiBcIiApIDogWyB2YWx1ZSBdO1xuXG5cdFx0XHRmb3IgKCA7IGkgPCA0OyBpKysgKSB7XG5cdFx0XHRcdGV4cGFuZGVkWyBwcmVmaXggKyBjc3NFeHBhbmRbIGkgXSArIHN1ZmZpeCBdID1cblx0XHRcdFx0XHRwYXJ0c1sgaSBdIHx8IHBhcnRzWyBpIC0gMiBdIHx8IHBhcnRzWyAwIF07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBleHBhbmRlZDtcblx0XHR9XG5cdH07XG5cblx0aWYgKCBwcmVmaXggIT09IFwibWFyZ2luXCIgKSB7XG5cdFx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXS5zZXQgPSBzZXRQb3NpdGl2ZU51bWJlcjtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGNzczogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdHZhciBzdHlsZXMsIGxlbixcblx0XHRcdFx0bWFwID0ge30sXG5cdFx0XHRcdGkgPSAwO1xuXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIG5hbWUgKSApIHtcblx0XHRcdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICk7XG5cdFx0XHRcdGxlbiA9IG5hbWUubGVuZ3RoO1xuXG5cdFx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdG1hcFsgbmFtZVsgaSBdIF0gPSBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lWyBpIF0sIGZhbHNlLCBzdHlsZXMgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBtYXA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lLCB2YWx1ZSApIDpcblx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgbmFtZSApO1xuXHRcdH0sIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9XG59ICk7XG5cblxuZnVuY3Rpb24gVHdlZW4oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICkge1xuXHRyZXR1cm4gbmV3IFR3ZWVuLnByb3RvdHlwZS5pbml0KCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApO1xufVxualF1ZXJ5LlR3ZWVuID0gVHdlZW47XG5cblR3ZWVuLnByb3RvdHlwZSA9IHtcblx0Y29uc3RydWN0b3I6IFR3ZWVuLFxuXHRpbml0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcsIHVuaXQgKSB7XG5cdFx0dGhpcy5lbGVtID0gZWxlbTtcblx0XHR0aGlzLnByb3AgPSBwcm9wO1xuXHRcdHRoaXMuZWFzaW5nID0gZWFzaW5nIHx8IGpRdWVyeS5lYXNpbmcuX2RlZmF1bHQ7XG5cdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0XHR0aGlzLnN0YXJ0ID0gdGhpcy5ub3cgPSB0aGlzLmN1cigpO1xuXHRcdHRoaXMuZW5kID0gZW5kO1xuXHRcdHRoaXMudW5pdCA9IHVuaXQgfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICk7XG5cdH0sXG5cdGN1cjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdHJldHVybiBob29rcyAmJiBob29rcy5nZXQgP1xuXHRcdFx0aG9va3MuZ2V0KCB0aGlzICkgOlxuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LmdldCggdGhpcyApO1xuXHR9LFxuXHRydW46IGZ1bmN0aW9uKCBwZXJjZW50ICkge1xuXHRcdHZhciBlYXNlZCxcblx0XHRcdGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmR1cmF0aW9uICkge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IGpRdWVyeS5lYXNpbmdbIHRoaXMuZWFzaW5nIF0oXG5cdFx0XHRcdHBlcmNlbnQsIHRoaXMub3B0aW9ucy5kdXJhdGlvbiAqIHBlcmNlbnQsIDAsIDEsIHRoaXMub3B0aW9ucy5kdXJhdGlvblxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IHBlcmNlbnQ7XG5cdFx0fVxuXHRcdHRoaXMubm93ID0gKCB0aGlzLmVuZCAtIHRoaXMuc3RhcnQgKSAqIGVhc2VkICsgdGhpcy5zdGFydDtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnN0ZXAgKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMuc3RlcC5jYWxsKCB0aGlzLmVsZW0sIHRoaXMubm93LCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBob29rcy5zZXQgKSB7XG5cdFx0XHRob29rcy5zZXQoIHRoaXMgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LnNldCggdGhpcyApO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxufTtcblxuVHdlZW4ucHJvdG90eXBlLmluaXQucHJvdG90eXBlID0gVHdlZW4ucHJvdG90eXBlO1xuXG5Ud2Vlbi5wcm9wSG9va3MgPSB7XG5cdF9kZWZhdWx0OiB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0XHR2YXIgcmVzdWx0O1xuXG5cdFx0XHQvLyBVc2UgYSBwcm9wZXJ0eSBvbiB0aGUgZWxlbWVudCBkaXJlY3RseSB3aGVuIGl0IGlzIG5vdCBhIERPTSBlbGVtZW50LFxuXHRcdFx0Ly8gb3Igd2hlbiB0aGVyZSBpcyBubyBtYXRjaGluZyBzdHlsZSBwcm9wZXJ0eSB0aGF0IGV4aXN0cy5cblx0XHRcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAhPT0gMSB8fFxuXHRcdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gIT0gbnVsbCAmJiB0d2Vlbi5lbGVtLnN0eWxlWyB0d2Vlbi5wcm9wIF0gPT0gbnVsbCApIHtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUGFzc2luZyBhbiBlbXB0eSBzdHJpbmcgYXMgYSAzcmQgcGFyYW1ldGVyIHRvIC5jc3Mgd2lsbCBhdXRvbWF0aWNhbGx5XG5cdFx0XHQvLyBhdHRlbXB0IGEgcGFyc2VGbG9hdCBhbmQgZmFsbGJhY2sgdG8gYSBzdHJpbmcgaWYgdGhlIHBhcnNlIGZhaWxzLlxuXHRcdFx0Ly8gU2ltcGxlIHZhbHVlcyBzdWNoIGFzIFwiMTBweFwiIGFyZSBwYXJzZWQgdG8gRmxvYXQ7XG5cdFx0XHQvLyBjb21wbGV4IHZhbHVlcyBzdWNoIGFzIFwicm90YXRlKDFyYWQpXCIgYXJlIHJldHVybmVkIGFzLWlzLlxuXHRcdFx0cmVzdWx0ID0galF1ZXJ5LmNzcyggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgXCJcIiApO1xuXG5cdFx0XHQvLyBFbXB0eSBzdHJpbmdzLCBudWxsLCB1bmRlZmluZWQgYW5kIFwiYXV0b1wiIGFyZSBjb252ZXJ0ZWQgdG8gMC5cblx0XHRcdHJldHVybiAhcmVzdWx0IHx8IHJlc3VsdCA9PT0gXCJhdXRvXCIgPyAwIDogcmVzdWx0O1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cblx0XHRcdC8vIFVzZSBzdGVwIGhvb2sgZm9yIGJhY2sgY29tcGF0LlxuXHRcdFx0Ly8gVXNlIGNzc0hvb2sgaWYgaXRzIHRoZXJlLlxuXHRcdFx0Ly8gVXNlIC5zdHlsZSBpZiBhdmFpbGFibGUgYW5kIHVzZSBwbGFpbiBwcm9wZXJ0aWVzIHdoZXJlIGF2YWlsYWJsZS5cblx0XHRcdGlmICggalF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSApIHtcblx0XHRcdFx0alF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSggdHdlZW4gKTtcblx0XHRcdH0gZWxzZSBpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKFxuXHRcdFx0XHRcdGpRdWVyeS5jc3NIb29rc1sgdHdlZW4ucHJvcCBdIHx8XG5cdFx0XHRcdFx0dHdlZW4uZWxlbS5zdHlsZVsgZmluYWxQcm9wTmFtZSggdHdlZW4ucHJvcCApIF0gIT0gbnVsbCApICkge1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIHR3ZWVuLm5vdyArIHR3ZWVuLnVuaXQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4vLyBQYW5pYyBiYXNlZCBhcHByb2FjaCB0byBzZXR0aW5nIHRoaW5ncyBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblR3ZWVuLnByb3BIb29rcy5zY3JvbGxUb3AgPSBUd2Vlbi5wcm9wSG9va3Muc2Nyb2xsTGVmdCA9IHtcblx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICYmIHR3ZWVuLmVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5lYXNpbmcgPSB7XG5cdGxpbmVhcjogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIHA7XG5cdH0sXG5cdHN3aW5nOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gMC41IC0gTWF0aC5jb3MoIHAgKiBNYXRoLlBJICkgLyAyO1xuXHR9LFxuXHRfZGVmYXVsdDogXCJzd2luZ1wiXG59O1xuXG5qUXVlcnkuZnggPSBUd2Vlbi5wcm90b3R5cGUuaW5pdDtcblxuLy8gQmFjayBjb21wYXQgPDEuOCBleHRlbnNpb24gcG9pbnRcbmpRdWVyeS5meC5zdGVwID0ge307XG5cblxuXG5cbnZhclxuXHRmeE5vdywgaW5Qcm9ncmVzcyxcblx0cmZ4dHlwZXMgPSAvXig/OnRvZ2dsZXxzaG93fGhpZGUpJC8sXG5cdHJydW4gPSAvcXVldWVIb29rcyQvO1xuXG5mdW5jdGlvbiBzY2hlZHVsZSgpIHtcblx0aWYgKCBpblByb2dyZXNzICkge1xuXHRcdGlmICggZG9jdW1lbnQuaGlkZGVuID09PSBmYWxzZSAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lICkge1xuXHRcdFx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSggc2NoZWR1bGUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0d2luZG93LnNldFRpbWVvdXQoIHNjaGVkdWxlLCBqUXVlcnkuZnguaW50ZXJ2YWwgKTtcblx0XHR9XG5cblx0XHRqUXVlcnkuZngudGljaygpO1xuXHR9XG59XG5cbi8vIEFuaW1hdGlvbnMgY3JlYXRlZCBzeW5jaHJvbm91c2x5IHdpbGwgcnVuIHN5bmNocm9ub3VzbHlcbmZ1bmN0aW9uIGNyZWF0ZUZ4Tm93KCkge1xuXHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0ZnhOb3cgPSB1bmRlZmluZWQ7XG5cdH0gKTtcblx0cmV0dXJuICggZnhOb3cgPSBEYXRlLm5vdygpICk7XG59XG5cbi8vIEdlbmVyYXRlIHBhcmFtZXRlcnMgdG8gY3JlYXRlIGEgc3RhbmRhcmQgYW5pbWF0aW9uXG5mdW5jdGlvbiBnZW5GeCggdHlwZSwgaW5jbHVkZVdpZHRoICkge1xuXHR2YXIgd2hpY2gsXG5cdFx0aSA9IDAsXG5cdFx0YXR0cnMgPSB7IGhlaWdodDogdHlwZSB9O1xuXG5cdC8vIElmIHdlIGluY2x1ZGUgd2lkdGgsIHN0ZXAgdmFsdWUgaXMgMSB0byBkbyBhbGwgY3NzRXhwYW5kIHZhbHVlcyxcblx0Ly8gb3RoZXJ3aXNlIHN0ZXAgdmFsdWUgaXMgMiB0byBza2lwIG92ZXIgTGVmdCBhbmQgUmlnaHRcblx0aW5jbHVkZVdpZHRoID0gaW5jbHVkZVdpZHRoID8gMSA6IDA7XG5cdGZvciAoIDsgaSA8IDQ7IGkgKz0gMiAtIGluY2x1ZGVXaWR0aCApIHtcblx0XHR3aGljaCA9IGNzc0V4cGFuZFsgaSBdO1xuXHRcdGF0dHJzWyBcIm1hcmdpblwiICsgd2hpY2ggXSA9IGF0dHJzWyBcInBhZGRpbmdcIiArIHdoaWNoIF0gPSB0eXBlO1xuXHR9XG5cblx0aWYgKCBpbmNsdWRlV2lkdGggKSB7XG5cdFx0YXR0cnMub3BhY2l0eSA9IGF0dHJzLndpZHRoID0gdHlwZTtcblx0fVxuXG5cdHJldHVybiBhdHRycztcbn1cblxuZnVuY3Rpb24gY3JlYXRlVHdlZW4oIHZhbHVlLCBwcm9wLCBhbmltYXRpb24gKSB7XG5cdHZhciB0d2Vlbixcblx0XHRjb2xsZWN0aW9uID0gKCBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXSApLmNvbmNhdCggQW5pbWF0aW9uLnR3ZWVuZXJzWyBcIipcIiBdICksXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGlmICggKCB0d2VlbiA9IGNvbGxlY3Rpb25bIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBwcm9wLCB2YWx1ZSApICkgKSB7XG5cblx0XHRcdC8vIFdlJ3JlIGRvbmUgd2l0aCB0aGlzIHByb3BlcnR5XG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRQcmVmaWx0ZXIoIGVsZW0sIHByb3BzLCBvcHRzICkge1xuXHR2YXIgcHJvcCwgdmFsdWUsIHRvZ2dsZSwgaG9va3MsIG9sZGZpcmUsIHByb3BUd2VlbiwgcmVzdG9yZURpc3BsYXksIGRpc3BsYXksXG5cdFx0aXNCb3ggPSBcIndpZHRoXCIgaW4gcHJvcHMgfHwgXCJoZWlnaHRcIiBpbiBwcm9wcyxcblx0XHRhbmltID0gdGhpcyxcblx0XHRvcmlnID0ge30sXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlLFxuXHRcdGhpZGRlbiA9IGVsZW0ubm9kZVR5cGUgJiYgaXNIaWRkZW5XaXRoaW5UcmVlKCBlbGVtICksXG5cdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZnhzaG93XCIgKTtcblxuXHQvLyBRdWV1ZS1za2lwcGluZyBhbmltYXRpb25zIGhpamFjayB0aGUgZnggaG9va3Ncblx0aWYgKCAhb3B0cy5xdWV1ZSApIHtcblx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgXCJmeFwiICk7XG5cdFx0aWYgKCBob29rcy51bnF1ZXVlZCA9PSBudWxsICkge1xuXHRcdFx0aG9va3MudW5xdWV1ZWQgPSAwO1xuXHRcdFx0b2xkZmlyZSA9IGhvb2tzLmVtcHR5LmZpcmU7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggIWhvb2tzLnVucXVldWVkICkge1xuXHRcdFx0XHRcdG9sZGZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdFx0aG9va3MudW5xdWV1ZWQrKztcblxuXHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRW5zdXJlIHRoZSBjb21wbGV0ZSBoYW5kbGVyIGlzIGNhbGxlZCBiZWZvcmUgdGhpcyBjb21wbGV0ZXNcblx0XHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0aG9va3MudW5xdWV1ZWQtLTtcblx0XHRcdFx0aWYgKCAhalF1ZXJ5LnF1ZXVlKCBlbGVtLCBcImZ4XCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gRGV0ZWN0IHNob3cvaGlkZSBhbmltYXRpb25zXG5cdGZvciAoIHByb3AgaW4gcHJvcHMgKSB7XG5cdFx0dmFsdWUgPSBwcm9wc1sgcHJvcCBdO1xuXHRcdGlmICggcmZ4dHlwZXMudGVzdCggdmFsdWUgKSApIHtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgcHJvcCBdO1xuXHRcdFx0dG9nZ2xlID0gdG9nZ2xlIHx8IHZhbHVlID09PSBcInRvZ2dsZVwiO1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gKCBoaWRkZW4gPyBcImhpZGVcIiA6IFwic2hvd1wiICkgKSB7XG5cblx0XHRcdFx0Ly8gUHJldGVuZCB0byBiZSBoaWRkZW4gaWYgdGhpcyBpcyBhIFwic2hvd1wiIGFuZFxuXHRcdFx0XHQvLyB0aGVyZSBpcyBzdGlsbCBkYXRhIGZyb20gYSBzdG9wcGVkIHNob3cvaGlkZVxuXHRcdFx0XHRpZiAoIHZhbHVlID09PSBcInNob3dcIiAmJiBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0aGlkZGVuID0gdHJ1ZTtcblxuXHRcdFx0XHQvLyBJZ25vcmUgYWxsIG90aGVyIG5vLW9wIHNob3cvaGlkZSBkYXRhXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdG9yaWdbIHByb3AgXSA9IGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gfHwgalF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQmFpbCBvdXQgaWYgdGhpcyBpcyBhIG5vLW9wIGxpa2UgLmhpZGUoKS5oaWRlKClcblx0cHJvcFR3ZWVuID0gIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wcyApO1xuXHRpZiAoICFwcm9wVHdlZW4gJiYgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIG9yaWcgKSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBSZXN0cmljdCBcIm92ZXJmbG93XCIgYW5kIFwiZGlzcGxheVwiIHN0eWxlcyBkdXJpbmcgYm94IGFuaW1hdGlvbnNcblx0aWYgKCBpc0JveCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEsIEVkZ2UgMTIgLSAxNVxuXHRcdC8vIFJlY29yZCBhbGwgMyBvdmVyZmxvdyBhdHRyaWJ1dGVzIGJlY2F1c2UgSUUgZG9lcyBub3QgaW5mZXIgdGhlIHNob3J0aGFuZFxuXHRcdC8vIGZyb20gaWRlbnRpY2FsbHktdmFsdWVkIG92ZXJmbG93WCBhbmQgb3ZlcmZsb3dZIGFuZCBFZGdlIGp1c3QgbWlycm9yc1xuXHRcdC8vIHRoZSBvdmVyZmxvd1ggdmFsdWUgdGhlcmUuXG5cdFx0b3B0cy5vdmVyZmxvdyA9IFsgc3R5bGUub3ZlcmZsb3csIHN0eWxlLm92ZXJmbG93WCwgc3R5bGUub3ZlcmZsb3dZIF07XG5cblx0XHQvLyBJZGVudGlmeSBhIGRpc3BsYXkgdHlwZSwgcHJlZmVycmluZyBvbGQgc2hvdy9oaWRlIGRhdGEgb3ZlciB0aGUgQ1NTIGNhc2NhZGVcblx0XHRyZXN0b3JlRGlzcGxheSA9IGRhdGFTaG93ICYmIGRhdGFTaG93LmRpc3BsYXk7XG5cdFx0aWYgKCByZXN0b3JlRGlzcGxheSA9PSBudWxsICkge1xuXHRcdFx0cmVzdG9yZURpc3BsYXkgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0fVxuXHRcdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ICkge1xuXHRcdFx0XHRkaXNwbGF5ID0gcmVzdG9yZURpc3BsYXk7XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEdldCBub25lbXB0eSB2YWx1ZShzKSBieSB0ZW1wb3JhcmlseSBmb3JjaW5nIHZpc2liaWxpdHlcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdLCB0cnVlICk7XG5cdFx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5IHx8IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0XHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQW5pbWF0ZSBpbmxpbmUgZWxlbWVudHMgYXMgaW5saW5lLWJsb2NrXG5cdFx0aWYgKCBkaXNwbGF5ID09PSBcImlubGluZVwiIHx8IGRpc3BsYXkgPT09IFwiaW5saW5lLWJsb2NrXCIgJiYgcmVzdG9yZURpc3BsYXkgIT0gbnVsbCApIHtcblx0XHRcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJmbG9hdFwiICkgPT09IFwibm9uZVwiICkge1xuXG5cdFx0XHRcdC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIGRpc3BsYXkgdmFsdWUgYXQgdGhlIGVuZCBvZiBwdXJlIHNob3cvaGlkZSBhbmltYXRpb25zXG5cdFx0XHRcdGlmICggIXByb3BUd2VlbiApIHtcblx0XHRcdFx0XHRhbmltLmRvbmUoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0c3R5bGUuZGlzcGxheSA9IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRkaXNwbGF5ID0gc3R5bGUuZGlzcGxheTtcblx0XHRcdFx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZGlzcGxheSA9PT0gXCJub25lXCIgPyBcIlwiIDogZGlzcGxheTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0c3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBvcHRzLm92ZXJmbG93ICkge1xuXHRcdHN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcblx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHRzdHlsZS5vdmVyZmxvdyA9IG9wdHMub3ZlcmZsb3dbIDAgXTtcblx0XHRcdHN0eWxlLm92ZXJmbG93WCA9IG9wdHMub3ZlcmZsb3dbIDEgXTtcblx0XHRcdHN0eWxlLm92ZXJmbG93WSA9IG9wdHMub3ZlcmZsb3dbIDIgXTtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBJbXBsZW1lbnQgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0cHJvcFR3ZWVuID0gZmFsc2U7XG5cdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblxuXHRcdC8vIEdlbmVyYWwgc2hvdy9oaWRlIHNldHVwIGZvciB0aGlzIGVsZW1lbnQgYW5pbWF0aW9uXG5cdFx0aWYgKCAhcHJvcFR3ZWVuICkge1xuXHRcdFx0aWYgKCBkYXRhU2hvdyApIHtcblx0XHRcdFx0aWYgKCBcImhpZGRlblwiIGluIGRhdGFTaG93ICkge1xuXHRcdFx0XHRcdGhpZGRlbiA9IGRhdGFTaG93LmhpZGRlbjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIFwiZnhzaG93XCIsIHsgZGlzcGxheTogcmVzdG9yZURpc3BsYXkgfSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdG9yZSBoaWRkZW4vdmlzaWJsZSBmb3IgdG9nZ2xlIHNvIGAuc3RvcCgpLnRvZ2dsZSgpYCBcInJldmVyc2VzXCJcblx0XHRcdGlmICggdG9nZ2xlICkge1xuXHRcdFx0XHRkYXRhU2hvdy5oaWRkZW4gPSAhaGlkZGVuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTaG93IGVsZW1lbnRzIGJlZm9yZSBhbmltYXRpbmcgdGhlbVxuXHRcdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSwgdHJ1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1sb29wLWZ1bmMgKi9cblxuXHRcdFx0YW5pbS5kb25lKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0LyogZXNsaW50LWVuYWJsZSBuby1sb29wLWZ1bmMgKi9cblxuXHRcdFx0XHQvLyBUaGUgZmluYWwgc3RlcCBvZiBhIFwiaGlkZVwiIGFuaW1hdGlvbiBpcyBhY3R1YWxseSBoaWRpbmcgdGhlIGVsZW1lbnRcblx0XHRcdFx0aWYgKCAhaGlkZGVuICkge1xuXHRcdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgXCJmeHNob3dcIiApO1xuXHRcdFx0XHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBvcmlnWyBwcm9wIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdC8vIFBlci1wcm9wZXJ0eSBzZXR1cFxuXHRcdHByb3BUd2VlbiA9IGNyZWF0ZVR3ZWVuKCBoaWRkZW4gPyBkYXRhU2hvd1sgcHJvcCBdIDogMCwgcHJvcCwgYW5pbSApO1xuXHRcdGlmICggISggcHJvcCBpbiBkYXRhU2hvdyApICkge1xuXHRcdFx0ZGF0YVNob3dbIHByb3AgXSA9IHByb3BUd2Vlbi5zdGFydDtcblx0XHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0XHRwcm9wVHdlZW4uZW5kID0gcHJvcFR3ZWVuLnN0YXJ0O1xuXHRcdFx0XHRwcm9wVHdlZW4uc3RhcnQgPSAwO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBwcm9wRmlsdGVyKCBwcm9wcywgc3BlY2lhbEVhc2luZyApIHtcblx0dmFyIGluZGV4LCBuYW1lLCBlYXNpbmcsIHZhbHVlLCBob29rcztcblxuXHQvLyBjYW1lbENhc2UsIHNwZWNpYWxFYXNpbmcgYW5kIGV4cGFuZCBjc3NIb29rIHBhc3Ncblx0Zm9yICggaW5kZXggaW4gcHJvcHMgKSB7XG5cdFx0bmFtZSA9IGNhbWVsQ2FzZSggaW5kZXggKTtcblx0XHRlYXNpbmcgPSBzcGVjaWFsRWFzaW5nWyBuYW1lIF07XG5cdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRlYXNpbmcgPSB2YWx1ZVsgMSBdO1xuXHRcdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyAwIF07XG5cdFx0fVxuXG5cdFx0aWYgKCBpbmRleCAhPT0gbmFtZSApIHtcblx0XHRcdHByb3BzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgaW5kZXggXTtcblx0XHR9XG5cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdO1xuXHRcdGlmICggaG9va3MgJiYgXCJleHBhbmRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbHVlID0gaG9va3MuZXhwYW5kKCB2YWx1ZSApO1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBuYW1lIF07XG5cblx0XHRcdC8vIE5vdCBxdWl0ZSAkLmV4dGVuZCwgdGhpcyB3b24ndCBvdmVyd3JpdGUgZXhpc3Rpbmcga2V5cy5cblx0XHRcdC8vIFJldXNpbmcgJ2luZGV4JyBiZWNhdXNlIHdlIGhhdmUgdGhlIGNvcnJlY3QgXCJuYW1lXCJcblx0XHRcdGZvciAoIGluZGV4IGluIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICEoIGluZGV4IGluIHByb3BzICkgKSB7XG5cdFx0XHRcdFx0cHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgaW5kZXggXTtcblx0XHRcdFx0XHRzcGVjaWFsRWFzaW5nWyBpbmRleCBdID0gZWFzaW5nO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNwZWNpYWxFYXNpbmdbIG5hbWUgXSA9IGVhc2luZztcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gQW5pbWF0aW9uKCBlbGVtLCBwcm9wZXJ0aWVzLCBvcHRpb25zICkge1xuXHR2YXIgcmVzdWx0LFxuXHRcdHN0b3BwZWQsXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzLmxlbmd0aCxcblx0XHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIERvbid0IG1hdGNoIGVsZW0gaW4gdGhlIDphbmltYXRlZCBzZWxlY3RvclxuXHRcdFx0ZGVsZXRlIHRpY2suZWxlbTtcblx0XHR9ICksXG5cdFx0dGljayA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBzdG9wcGVkICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHR2YXIgY3VycmVudFRpbWUgPSBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuXHRcdFx0XHRyZW1haW5pbmcgPSBNYXRoLm1heCggMCwgYW5pbWF0aW9uLnN0YXJ0VGltZSArIGFuaW1hdGlvbi5kdXJhdGlvbiAtIGN1cnJlbnRUaW1lICksXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCAyLjMgb25seVxuXHRcdFx0XHQvLyBBcmNoYWljIGNyYXNoIGJ1ZyB3b24ndCBhbGxvdyB1cyB0byB1c2UgYDEgLSAoIDAuNSB8fCAwIClgICgjMTI0OTcpXG5cdFx0XHRcdHRlbXAgPSByZW1haW5pbmcgLyBhbmltYXRpb24uZHVyYXRpb24gfHwgMCxcblx0XHRcdFx0cGVyY2VudCA9IDEgLSB0ZW1wLFxuXHRcdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRcdGxlbmd0aCA9IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoO1xuXG5cdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggcGVyY2VudCApO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgcGVyY2VudCwgcmVtYWluaW5nIF0gKTtcblxuXHRcdFx0Ly8gSWYgdGhlcmUncyBtb3JlIHRvIGRvLCB5aWVsZFxuXHRcdFx0aWYgKCBwZXJjZW50IDwgMSAmJiBsZW5ndGggKSB7XG5cdFx0XHRcdHJldHVybiByZW1haW5pbmc7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoaXMgd2FzIGFuIGVtcHR5IGFuaW1hdGlvbiwgc3ludGhlc2l6ZSBhIGZpbmFsIHByb2dyZXNzIG5vdGlmaWNhdGlvblxuXHRcdFx0aWYgKCAhbGVuZ3RoICkge1xuXHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgMSwgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlc29sdmUgdGhlIGFuaW1hdGlvbiBhbmQgcmVwb3J0IGl0cyBjb25jbHVzaW9uXG5cdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24gXSApO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cdFx0YW5pbWF0aW9uID0gZGVmZXJyZWQucHJvbWlzZSgge1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdHByb3BzOiBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcGVydGllcyApLFxuXHRcdFx0b3B0czogalF1ZXJ5LmV4dGVuZCggdHJ1ZSwge1xuXHRcdFx0XHRzcGVjaWFsRWFzaW5nOiB7fSxcblx0XHRcdFx0ZWFzaW5nOiBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0XG5cdFx0XHR9LCBvcHRpb25zICksXG5cdFx0XHRvcmlnaW5hbFByb3BlcnRpZXM6IHByb3BlcnRpZXMsXG5cdFx0XHRvcmlnaW5hbE9wdGlvbnM6IG9wdGlvbnMsXG5cdFx0XHRzdGFydFRpbWU6IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbixcblx0XHRcdHR3ZWVuczogW10sXG5cdFx0XHRjcmVhdGVUd2VlbjogZnVuY3Rpb24oIHByb3AsIGVuZCApIHtcblx0XHRcdFx0dmFyIHR3ZWVuID0galF1ZXJ5LlR3ZWVuKCBlbGVtLCBhbmltYXRpb24ub3B0cywgcHJvcCwgZW5kLFxuXHRcdFx0XHRcdFx0YW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZ1sgcHJvcCBdIHx8IGFuaW1hdGlvbi5vcHRzLmVhc2luZyApO1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zLnB1c2goIHR3ZWVuICk7XG5cdFx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHRcdH0sXG5cdFx0XHRzdG9wOiBmdW5jdGlvbiggZ290b0VuZCApIHtcblx0XHRcdFx0dmFyIGluZGV4ID0gMCxcblxuXHRcdFx0XHRcdC8vIElmIHdlIGFyZSBnb2luZyB0byB0aGUgZW5kLCB3ZSB3YW50IHRvIHJ1biBhbGwgdGhlIHR3ZWVuc1xuXHRcdFx0XHRcdC8vIG90aGVyd2lzZSB3ZSBza2lwIHRoaXMgcGFydFxuXHRcdFx0XHRcdGxlbmd0aCA9IGdvdG9FbmQgPyBhbmltYXRpb24udHdlZW5zLmxlbmd0aCA6IDA7XG5cdFx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0XHRzdG9wcGVkID0gdHJ1ZTtcblx0XHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggMSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVzb2x2ZSB3aGVuIHdlIHBsYXllZCB0aGUgbGFzdCBmcmFtZTsgb3RoZXJ3aXNlLCByZWplY3Rcblx0XHRcdFx0aWYgKCBnb3RvRW5kICkge1xuXHRcdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCAxLCAwIF0gKTtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblx0XHR9ICksXG5cdFx0cHJvcHMgPSBhbmltYXRpb24ucHJvcHM7XG5cblx0cHJvcEZpbHRlciggcHJvcHMsIGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmcgKTtcblxuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdHJlc3VsdCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgZWxlbSwgcHJvcHMsIGFuaW1hdGlvbi5vcHRzICk7XG5cdFx0aWYgKCByZXN1bHQgKSB7XG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24oIHJlc3VsdC5zdG9wICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5fcXVldWVIb29rcyggYW5pbWF0aW9uLmVsZW0sIGFuaW1hdGlvbi5vcHRzLnF1ZXVlICkuc3RvcCA9XG5cdFx0XHRcdFx0cmVzdWx0LnN0b3AuYmluZCggcmVzdWx0ICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH1cblx0fVxuXG5cdGpRdWVyeS5tYXAoIHByb3BzLCBjcmVhdGVUd2VlbiwgYW5pbWF0aW9uICk7XG5cblx0aWYgKCBpc0Z1bmN0aW9uKCBhbmltYXRpb24ub3B0cy5zdGFydCApICkge1xuXHRcdGFuaW1hdGlvbi5vcHRzLnN0YXJ0LmNhbGwoIGVsZW0sIGFuaW1hdGlvbiApO1xuXHR9XG5cblx0Ly8gQXR0YWNoIGNhbGxiYWNrcyBmcm9tIG9wdGlvbnNcblx0YW5pbWF0aW9uXG5cdFx0LnByb2dyZXNzKCBhbmltYXRpb24ub3B0cy5wcm9ncmVzcyApXG5cdFx0LmRvbmUoIGFuaW1hdGlvbi5vcHRzLmRvbmUsIGFuaW1hdGlvbi5vcHRzLmNvbXBsZXRlIClcblx0XHQuZmFpbCggYW5pbWF0aW9uLm9wdHMuZmFpbCApXG5cdFx0LmFsd2F5cyggYW5pbWF0aW9uLm9wdHMuYWx3YXlzICk7XG5cblx0alF1ZXJ5LmZ4LnRpbWVyKFxuXHRcdGpRdWVyeS5leHRlbmQoIHRpY2ssIHtcblx0XHRcdGVsZW06IGVsZW0sXG5cdFx0XHRhbmltOiBhbmltYXRpb24sXG5cdFx0XHRxdWV1ZTogYW5pbWF0aW9uLm9wdHMucXVldWVcblx0XHR9IClcblx0KTtcblxuXHRyZXR1cm4gYW5pbWF0aW9uO1xufVxuXG5qUXVlcnkuQW5pbWF0aW9uID0galF1ZXJ5LmV4dGVuZCggQW5pbWF0aW9uLCB7XG5cblx0dHdlZW5lcnM6IHtcblx0XHRcIipcIjogWyBmdW5jdGlvbiggcHJvcCwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSB0aGlzLmNyZWF0ZVR3ZWVuKCBwcm9wLCB2YWx1ZSApO1xuXHRcdFx0YWRqdXN0Q1NTKCB0d2Vlbi5lbGVtLCBwcm9wLCByY3NzTnVtLmV4ZWMoIHZhbHVlICksIHR3ZWVuICk7XG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fSBdXG5cdH0sXG5cblx0dHdlZW5lcjogZnVuY3Rpb24oIHByb3BzLCBjYWxsYmFjayApIHtcblx0XHRpZiAoIGlzRnVuY3Rpb24oIHByb3BzICkgKSB7XG5cdFx0XHRjYWxsYmFjayA9IHByb3BzO1xuXHRcdFx0cHJvcHMgPSBbIFwiKlwiIF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHByb3BzID0gcHJvcHMubWF0Y2goIHJub3RodG1sd2hpdGUgKTtcblx0XHR9XG5cblx0XHR2YXIgcHJvcCxcblx0XHRcdGluZGV4ID0gMCxcblx0XHRcdGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRwcm9wID0gcHJvcHNbIGluZGV4IF07XG5cdFx0XHRBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSA9IEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdIHx8IFtdO1xuXHRcdFx0QW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0udW5zaGlmdCggY2FsbGJhY2sgKTtcblx0XHR9XG5cdH0sXG5cblx0cHJlZmlsdGVyczogWyBkZWZhdWx0UHJlZmlsdGVyIF0sXG5cblx0cHJlZmlsdGVyOiBmdW5jdGlvbiggY2FsbGJhY2ssIHByZXBlbmQgKSB7XG5cdFx0aWYgKCBwcmVwZW5kICkge1xuXHRcdFx0QW5pbWF0aW9uLnByZWZpbHRlcnMudW5zaGlmdCggY2FsbGJhY2sgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0QW5pbWF0aW9uLnByZWZpbHRlcnMucHVzaCggY2FsbGJhY2sgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxualF1ZXJ5LnNwZWVkID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGZuICkge1xuXHR2YXIgb3B0ID0gc3BlZWQgJiYgdHlwZW9mIHNwZWVkID09PSBcIm9iamVjdFwiID8galF1ZXJ5LmV4dGVuZCgge30sIHNwZWVkICkgOiB7XG5cdFx0Y29tcGxldGU6IGZuIHx8ICFmbiAmJiBlYXNpbmcgfHxcblx0XHRcdGlzRnVuY3Rpb24oIHNwZWVkICkgJiYgc3BlZWQsXG5cdFx0ZHVyYXRpb246IHNwZWVkLFxuXHRcdGVhc2luZzogZm4gJiYgZWFzaW5nIHx8IGVhc2luZyAmJiAhaXNGdW5jdGlvbiggZWFzaW5nICkgJiYgZWFzaW5nXG5cdH07XG5cblx0Ly8gR28gdG8gdGhlIGVuZCBzdGF0ZSBpZiBmeCBhcmUgb2ZmXG5cdGlmICggalF1ZXJ5LmZ4Lm9mZiApIHtcblx0XHRvcHQuZHVyYXRpb24gPSAwO1xuXG5cdH0gZWxzZSB7XG5cdFx0aWYgKCB0eXBlb2Ygb3B0LmR1cmF0aW9uICE9PSBcIm51bWJlclwiICkge1xuXHRcdFx0aWYgKCBvcHQuZHVyYXRpb24gaW4galF1ZXJ5LmZ4LnNwZWVkcyApIHtcblx0XHRcdFx0b3B0LmR1cmF0aW9uID0galF1ZXJ5LmZ4LnNwZWVkc1sgb3B0LmR1cmF0aW9uIF07XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5zcGVlZHMuX2RlZmF1bHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gTm9ybWFsaXplIG9wdC5xdWV1ZSAtIHRydWUvdW5kZWZpbmVkL251bGwgLT4gXCJmeFwiXG5cdGlmICggb3B0LnF1ZXVlID09IG51bGwgfHwgb3B0LnF1ZXVlID09PSB0cnVlICkge1xuXHRcdG9wdC5xdWV1ZSA9IFwiZnhcIjtcblx0fVxuXG5cdC8vIFF1ZXVlaW5nXG5cdG9wdC5vbGQgPSBvcHQuY29tcGxldGU7XG5cblx0b3B0LmNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBvcHQub2xkICkgKSB7XG5cdFx0XHRvcHQub2xkLmNhbGwoIHRoaXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdC5xdWV1ZSApIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCBvcHQucXVldWUgKTtcblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIG9wdDtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZmFkZVRvOiBmdW5jdGlvbiggc3BlZWQsIHRvLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXG5cdFx0Ly8gU2hvdyBhbnkgaGlkZGVuIGVsZW1lbnRzIGFmdGVyIHNldHRpbmcgb3BhY2l0eSB0byAwXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBpc0hpZGRlbldpdGhpblRyZWUgKS5jc3MoIFwib3BhY2l0eVwiLCAwICkuc2hvdygpXG5cblx0XHRcdC8vIEFuaW1hdGUgdG8gdGhlIHZhbHVlIHNwZWNpZmllZFxuXHRcdFx0LmVuZCgpLmFuaW1hdGUoIHsgb3BhY2l0eTogdG8gfSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fSxcblx0YW5pbWF0ZTogZnVuY3Rpb24oIHByb3AsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHZhciBlbXB0eSA9IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wICksXG5cdFx0XHRvcHRhbGwgPSBqUXVlcnkuc3BlZWQoIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICksXG5cdFx0XHRkb0FuaW1hdGlvbiA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIE9wZXJhdGUgb24gYSBjb3B5IG9mIHByb3Agc28gcGVyLXByb3BlcnR5IGVhc2luZyB3b24ndCBiZSBsb3N0XG5cdFx0XHRcdHZhciBhbmltID0gQW5pbWF0aW9uKCB0aGlzLCBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcCApLCBvcHRhbGwgKTtcblxuXHRcdFx0XHQvLyBFbXB0eSBhbmltYXRpb25zLCBvciBmaW5pc2hpbmcgcmVzb2x2ZXMgaW1tZWRpYXRlbHlcblx0XHRcdFx0aWYgKCBlbXB0eSB8fCBkYXRhUHJpdi5nZXQoIHRoaXMsIFwiZmluaXNoXCIgKSApIHtcblx0XHRcdFx0XHRhbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdGRvQW5pbWF0aW9uLmZpbmlzaCA9IGRvQW5pbWF0aW9uO1xuXG5cdFx0cmV0dXJuIGVtcHR5IHx8IG9wdGFsbC5xdWV1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0dGhpcy5lYWNoKCBkb0FuaW1hdGlvbiApIDpcblx0XHRcdHRoaXMucXVldWUoIG9wdGFsbC5xdWV1ZSwgZG9BbmltYXRpb24gKTtcblx0fSxcblx0c3RvcDogZnVuY3Rpb24oIHR5cGUsIGNsZWFyUXVldWUsIGdvdG9FbmQgKSB7XG5cdFx0dmFyIHN0b3BRdWV1ZSA9IGZ1bmN0aW9uKCBob29rcyApIHtcblx0XHRcdHZhciBzdG9wID0gaG9va3Muc3RvcDtcblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0c3RvcCggZ290b0VuZCApO1xuXHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0Z290b0VuZCA9IGNsZWFyUXVldWU7XG5cdFx0XHRjbGVhclF1ZXVlID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggY2xlYXJRdWV1ZSApIHtcblx0XHRcdHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGRlcXVldWUgPSB0cnVlLFxuXHRcdFx0XHRpbmRleCA9IHR5cGUgIT0gbnVsbCAmJiB0eXBlICsgXCJxdWV1ZUhvb2tzXCIsXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGRhdGEgPSBkYXRhUHJpdi5nZXQoIHRoaXMgKTtcblxuXHRcdFx0aWYgKCBpbmRleCApIHtcblx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCApIHtcblx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICggaW5kZXggaW4gZGF0YSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICYmIHJydW4udGVzdCggaW5kZXggKSApIHtcblx0XHRcdFx0XHRcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmXG5cdFx0XHRcdFx0KCB0eXBlID09IG51bGwgfHwgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkgKSB7XG5cblx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCBnb3RvRW5kICk7XG5cdFx0XHRcdFx0ZGVxdWV1ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhcnQgdGhlIG5leHQgaW4gdGhlIHF1ZXVlIGlmIHRoZSBsYXN0IHN0ZXAgd2Fzbid0IGZvcmNlZC5cblx0XHRcdC8vIFRpbWVycyBjdXJyZW50bHkgd2lsbCBjYWxsIHRoZWlyIGNvbXBsZXRlIGNhbGxiYWNrcywgd2hpY2hcblx0XHRcdC8vIHdpbGwgZGVxdWV1ZSBidXQgb25seSBpZiB0aGV5IHdlcmUgZ290b0VuZC5cblx0XHRcdGlmICggZGVxdWV1ZSB8fCAhZ290b0VuZCApIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cdGZpbmlzaDogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0aWYgKCB0eXBlICE9PSBmYWxzZSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaW5kZXgsXG5cdFx0XHRcdGRhdGEgPSBkYXRhUHJpdi5nZXQoIHRoaXMgKSxcblx0XHRcdFx0cXVldWUgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZVwiIF0sXG5cdFx0XHRcdGhvb2tzID0gZGF0YVsgdHlwZSArIFwicXVldWVIb29rc1wiIF0sXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGxlbmd0aCA9IHF1ZXVlID8gcXVldWUubGVuZ3RoIDogMDtcblxuXHRcdFx0Ly8gRW5hYmxlIGZpbmlzaGluZyBmbGFnIG9uIHByaXZhdGUgZGF0YVxuXHRcdFx0ZGF0YS5maW5pc2ggPSB0cnVlO1xuXG5cdFx0XHQvLyBFbXB0eSB0aGUgcXVldWUgZmlyc3Rcblx0XHRcdGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgW10gKTtcblxuXHRcdFx0aWYgKCBob29rcyAmJiBob29rcy5zdG9wICkge1xuXHRcdFx0XHRob29rcy5zdG9wLmNhbGwoIHRoaXMsIHRydWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTG9vayBmb3IgYW55IGFjdGl2ZSBhbmltYXRpb25zLCBhbmQgZmluaXNoIHRoZW1cblx0XHRcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG5cdFx0XHRcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiYgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkge1xuXHRcdFx0XHRcdHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvb2sgZm9yIGFueSBhbmltYXRpb25zIGluIHRoZSBvbGQgcXVldWUgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRpZiAoIHF1ZXVlWyBpbmRleCBdICYmIHF1ZXVlWyBpbmRleCBdLmZpbmlzaCApIHtcblx0XHRcdFx0XHRxdWV1ZVsgaW5kZXggXS5maW5pc2guY2FsbCggdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFR1cm4gb2ZmIGZpbmlzaGluZyBmbGFnXG5cdFx0XHRkZWxldGUgZGF0YS5maW5pc2g7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwidG9nZ2xlXCIsIFwic2hvd1wiLCBcImhpZGVcIiBdLCBmdW5jdGlvbiggX2ksIG5hbWUgKSB7XG5cdHZhciBjc3NGbiA9IGpRdWVyeS5mblsgbmFtZSBdO1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gc3BlZWQgPT0gbnVsbCB8fCB0eXBlb2Ygc3BlZWQgPT09IFwiYm9vbGVhblwiID9cblx0XHRcdGNzc0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSA6XG5cdFx0XHR0aGlzLmFuaW1hdGUoIGdlbkZ4KCBuYW1lLCB0cnVlICksIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH07XG59ICk7XG5cbi8vIEdlbmVyYXRlIHNob3J0Y3V0cyBmb3IgY3VzdG9tIGFuaW1hdGlvbnNcbmpRdWVyeS5lYWNoKCB7XG5cdHNsaWRlRG93bjogZ2VuRngoIFwic2hvd1wiICksXG5cdHNsaWRlVXA6IGdlbkZ4KCBcImhpZGVcIiApLFxuXHRzbGlkZVRvZ2dsZTogZ2VuRngoIFwidG9nZ2xlXCIgKSxcblx0ZmFkZUluOiB7IG9wYWNpdHk6IFwic2hvd1wiIH0sXG5cdGZhZGVPdXQ6IHsgb3BhY2l0eTogXCJoaWRlXCIgfSxcblx0ZmFkZVRvZ2dsZTogeyBvcGFjaXR5OiBcInRvZ2dsZVwiIH1cbn0sIGZ1bmN0aW9uKCBuYW1lLCBwcm9wcyApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYW5pbWF0ZSggcHJvcHMsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH07XG59ICk7XG5cbmpRdWVyeS50aW1lcnMgPSBbXTtcbmpRdWVyeS5meC50aWNrID0gZnVuY3Rpb24oKSB7XG5cdHZhciB0aW1lcixcblx0XHRpID0gMCxcblx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzO1xuXG5cdGZ4Tm93ID0gRGF0ZS5ub3coKTtcblxuXHRmb3IgKCA7IGkgPCB0aW1lcnMubGVuZ3RoOyBpKysgKSB7XG5cdFx0dGltZXIgPSB0aW1lcnNbIGkgXTtcblxuXHRcdC8vIFJ1biB0aGUgdGltZXIgYW5kIHNhZmVseSByZW1vdmUgaXQgd2hlbiBkb25lIChhbGxvd2luZyBmb3IgZXh0ZXJuYWwgcmVtb3ZhbClcblx0XHRpZiAoICF0aW1lcigpICYmIHRpbWVyc1sgaSBdID09PSB0aW1lciApIHtcblx0XHRcdHRpbWVycy5zcGxpY2UoIGktLSwgMSApO1xuXHRcdH1cblx0fVxuXG5cdGlmICggIXRpbWVycy5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5LmZ4LnN0b3AoKTtcblx0fVxuXHRmeE5vdyA9IHVuZGVmaW5lZDtcbn07XG5cbmpRdWVyeS5meC50aW1lciA9IGZ1bmN0aW9uKCB0aW1lciApIHtcblx0alF1ZXJ5LnRpbWVycy5wdXNoKCB0aW1lciApO1xuXHRqUXVlcnkuZnguc3RhcnQoKTtcbn07XG5cbmpRdWVyeS5meC5pbnRlcnZhbCA9IDEzO1xualF1ZXJ5LmZ4LnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG5cdGlmICggaW5Qcm9ncmVzcyApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRpblByb2dyZXNzID0gdHJ1ZTtcblx0c2NoZWR1bGUoKTtcbn07XG5cbmpRdWVyeS5meC5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdGluUHJvZ3Jlc3MgPSBudWxsO1xufTtcblxualF1ZXJ5LmZ4LnNwZWVkcyA9IHtcblx0c2xvdzogNjAwLFxuXHRmYXN0OiAyMDAsXG5cblx0Ly8gRGVmYXVsdCBzcGVlZFxuXHRfZGVmYXVsdDogNDAwXG59O1xuXG5cbi8vIEJhc2VkIG9mZiBvZiB0aGUgcGx1Z2luIGJ5IENsaW50IEhlbGZlcnMsIHdpdGggcGVybWlzc2lvbi5cbi8vIGh0dHBzOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDEwMDMyNDAxNDc0Ny9odHRwOi8vYmxpbmRzaWduYWxzLmNvbS9pbmRleC5waHAvMjAwOS8wNy9qcXVlcnktZGVsYXkvXG5qUXVlcnkuZm4uZGVsYXkgPSBmdW5jdGlvbiggdGltZSwgdHlwZSApIHtcblx0dGltZSA9IGpRdWVyeS5meCA/IGpRdWVyeS5meC5zcGVlZHNbIHRpbWUgXSB8fCB0aW1lIDogdGltZTtcblx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlLCBmdW5jdGlvbiggbmV4dCwgaG9va3MgKSB7XG5cdFx0dmFyIHRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCggbmV4dCwgdGltZSApO1xuXHRcdGhvb2tzLnN0b3AgPSBmdW5jdGlvbigpIHtcblx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQoIHRpbWVvdXQgKTtcblx0XHR9O1xuXHR9ICk7XG59O1xuXG5cbiggZnVuY3Rpb24oKSB7XG5cdHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApLFxuXHRcdHNlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwic2VsZWN0XCIgKSxcblx0XHRvcHQgPSBzZWxlY3QuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwib3B0aW9uXCIgKSApO1xuXG5cdGlucHV0LnR5cGUgPSBcImNoZWNrYm94XCI7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMyBvbmx5XG5cdC8vIERlZmF1bHQgdmFsdWUgZm9yIGEgY2hlY2tib3ggc2hvdWxkIGJlIFwib25cIlxuXHRzdXBwb3J0LmNoZWNrT24gPSBpbnB1dC52YWx1ZSAhPT0gXCJcIjtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gTXVzdCBhY2Nlc3Mgc2VsZWN0ZWRJbmRleCB0byBtYWtlIGRlZmF1bHQgb3B0aW9ucyBzZWxlY3Rcblx0c3VwcG9ydC5vcHRTZWxlY3RlZCA9IG9wdC5zZWxlY3RlZDtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gQW4gaW5wdXQgbG9zZXMgaXRzIHZhbHVlIGFmdGVyIGJlY29taW5nIGEgcmFkaW9cblx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblx0aW5wdXQudmFsdWUgPSBcInRcIjtcblx0aW5wdXQudHlwZSA9IFwicmFkaW9cIjtcblx0c3VwcG9ydC5yYWRpb1ZhbHVlID0gaW5wdXQudmFsdWUgPT09IFwidFwiO1xufSApKCk7XG5cblxudmFyIGJvb2xIb29rLFxuXHRhdHRySGFuZGxlID0galF1ZXJ5LmV4cHIuYXR0ckhhbmRsZTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRhdHRyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LmF0dHIsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXG5cdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBuYW1lICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIHRoaXMsIG5hbWUgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHRhdHRyOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIHJldCwgaG9va3MsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBEb24ndCBnZXQvc2V0IGF0dHJpYnV0ZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBGYWxsYmFjayB0byBwcm9wIHdoZW4gYXR0cmlidXRlcyBhcmUgbm90IHN1cHBvcnRlZFxuXHRcdGlmICggdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlID09PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5wcm9wKCBlbGVtLCBuYW1lLCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdC8vIEF0dHJpYnV0ZSBob29rcyBhcmUgZGV0ZXJtaW5lZCBieSB0aGUgbG93ZXJjYXNlIHZlcnNpb25cblx0XHQvLyBHcmFiIG5lY2Vzc2FyeSBob29rIGlmIG9uZSBpcyBkZWZpbmVkXG5cdFx0aWYgKCBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5hdHRySG9va3NbIG5hbWUudG9Mb3dlckNhc2UoKSBdIHx8XG5cdFx0XHRcdCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC50ZXN0KCBuYW1lICkgPyBib29sSG9vayA6IHVuZGVmaW5lZCApO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggdmFsdWUgPT09IG51bGwgKSB7XG5cdFx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIHZhbHVlICsgXCJcIiApO1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApICkgIT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblxuXHRcdHJldCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdC8vIE5vbi1leGlzdGVudCBhdHRyaWJ1dGVzIHJldHVybiBudWxsLCB3ZSBub3JtYWxpemUgdG8gdW5kZWZpbmVkXG5cdFx0cmV0dXJuIHJldCA9PSBudWxsID8gdW5kZWZpbmVkIDogcmV0O1xuXHR9LFxuXG5cdGF0dHJIb29rczoge1xuXHRcdHR5cGU6IHtcblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICFzdXBwb3J0LnJhZGlvVmFsdWUgJiYgdmFsdWUgPT09IFwicmFkaW9cIiAmJlxuXHRcdFx0XHRcdG5vZGVOYW1lKCBlbGVtLCBcImlucHV0XCIgKSApIHtcblx0XHRcdFx0XHR2YXIgdmFsID0gZWxlbS52YWx1ZTtcblx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIHZhbHVlICk7XG5cdFx0XHRcdFx0aWYgKCB2YWwgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnZhbHVlID0gdmFsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdHZhciBuYW1lLFxuXHRcdFx0aSA9IDAsXG5cblx0XHRcdC8vIEF0dHJpYnV0ZSBuYW1lcyBjYW4gY29udGFpbiBub24tSFRNTCB3aGl0ZXNwYWNlIGNoYXJhY3RlcnNcblx0XHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2F0dHJpYnV0ZXMtMlxuXHRcdFx0YXR0ck5hbWVzID0gdmFsdWUgJiYgdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKTtcblxuXHRcdGlmICggYXR0ck5hbWVzICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHR3aGlsZSAoICggbmFtZSA9IGF0dHJOYW1lc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIG5hbWUgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gSG9va3MgZm9yIGJvb2xlYW4gYXR0cmlidXRlc1xuYm9vbEhvb2sgPSB7XG5cdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBuYW1lICkge1xuXHRcdGlmICggdmFsdWUgPT09IGZhbHNlICkge1xuXG5cdFx0XHQvLyBSZW1vdmUgYm9vbGVhbiBhdHRyaWJ1dGVzIHdoZW4gc2V0IHRvIGZhbHNlXG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgbmFtZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gbmFtZTtcblx0fVxufTtcblxualF1ZXJ5LmVhY2goIGpRdWVyeS5leHByLm1hdGNoLmJvb2wuc291cmNlLm1hdGNoKCAvXFx3Ky9nICksIGZ1bmN0aW9uKCBfaSwgbmFtZSApIHtcblx0dmFyIGdldHRlciA9IGF0dHJIYW5kbGVbIG5hbWUgXSB8fCBqUXVlcnkuZmluZC5hdHRyO1xuXG5cdGF0dHJIYW5kbGVbIG5hbWUgXSA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgcmV0LCBoYW5kbGUsXG5cdFx0XHRsb3dlcmNhc2VOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cblx0XHRcdC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3AgYnkgdGVtcG9yYXJpbHkgcmVtb3ZpbmcgdGhpcyBmdW5jdGlvbiBmcm9tIHRoZSBnZXR0ZXJcblx0XHRcdGhhbmRsZSA9IGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXTtcblx0XHRcdGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXSA9IHJldDtcblx0XHRcdHJldCA9IGdldHRlciggZWxlbSwgbmFtZSwgaXNYTUwgKSAhPSBudWxsID9cblx0XHRcdFx0bG93ZXJjYXNlTmFtZSA6XG5cdFx0XHRcdG51bGw7XG5cdFx0XHRhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF0gPSBoYW5kbGU7XG5cdFx0fVxuXHRcdHJldHVybiByZXQ7XG5cdH07XG59ICk7XG5cblxuXG5cbnZhciByZm9jdXNhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcblx0cmNsaWNrYWJsZSA9IC9eKD86YXxhcmVhKSQvaTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRwcm9wOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LnByb3AsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXG5cdHJlbW92ZVByb3A6IGZ1bmN0aW9uKCBuYW1lICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0ZGVsZXRlIHRoaXNbIGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZSBdO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHByb3A6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHR2YXIgcmV0LCBob29rcyxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIERvbid0IGdldC9zZXQgcHJvcGVydGllcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoIG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXG5cdFx0XHQvLyBGaXggbmFtZSBhbmQgYXR0YWNoIGhvb2tzXG5cdFx0XHRuYW1lID0galF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lO1xuXHRcdFx0aG9va3MgPSBqUXVlcnkucHJvcEhvb2tzWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuICggZWxlbVsgbmFtZSBdID0gdmFsdWUgKTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSApICE9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cblx0XHRyZXR1cm4gZWxlbVsgbmFtZSBdO1xuXHR9LFxuXG5cdHByb3BIb29rczoge1xuXHRcdHRhYkluZGV4OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0XHRcdFx0Ly8gZWxlbS50YWJJbmRleCBkb2Vzbid0IGFsd2F5cyByZXR1cm4gdGhlXG5cdFx0XHRcdC8vIGNvcnJlY3QgdmFsdWUgd2hlbiBpdCBoYXNuJ3QgYmVlbiBleHBsaWNpdGx5IHNldFxuXHRcdFx0XHQvLyBodHRwczovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAxNDExMTYyMzMzNDcvaHR0cDovL2ZsdWlkcHJvamVjdC5vcmcvYmxvZy8yMDA4LzAxLzA5L2dldHRpbmctc2V0dGluZy1hbmQtcmVtb3ZpbmctdGFiaW5kZXgtdmFsdWVzLXdpdGgtamF2YXNjcmlwdC9cblx0XHRcdFx0Ly8gVXNlIHByb3BlciBhdHRyaWJ1dGUgcmV0cmlldmFsKCMxMjA3Milcblx0XHRcdFx0dmFyIHRhYmluZGV4ID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgXCJ0YWJpbmRleFwiICk7XG5cblx0XHRcdFx0aWYgKCB0YWJpbmRleCApIHtcblx0XHRcdFx0XHRyZXR1cm4gcGFyc2VJbnQoIHRhYmluZGV4LCAxMCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdHJmb2N1c2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApIHx8XG5cdFx0XHRcdFx0cmNsaWNrYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgJiZcblx0XHRcdFx0XHRlbGVtLmhyZWZcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHByb3BGaXg6IHtcblx0XHRcImZvclwiOiBcImh0bWxGb3JcIixcblx0XHRcImNsYXNzXCI6IFwiY2xhc3NOYW1lXCJcblx0fVxufSApO1xuXG4vLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcbi8vIEFjY2Vzc2luZyB0aGUgc2VsZWN0ZWRJbmRleCBwcm9wZXJ0eVxuLy8gZm9yY2VzIHRoZSBicm93c2VyIHRvIHJlc3BlY3Qgc2V0dGluZyBzZWxlY3RlZFxuLy8gb24gdGhlIG9wdGlvblxuLy8gVGhlIGdldHRlciBlbnN1cmVzIGEgZGVmYXVsdCBvcHRpb24gaXMgc2VsZWN0ZWRcbi8vIHdoZW4gaW4gYW4gb3B0Z3JvdXBcbi8vIGVzbGludCBydWxlIFwibm8tdW51c2VkLWV4cHJlc3Npb25zXCIgaXMgZGlzYWJsZWQgZm9yIHRoaXMgY29kZVxuLy8gc2luY2UgaXQgY29uc2lkZXJzIHN1Y2ggYWNjZXNzaW9ucyBub29wXG5pZiAoICFzdXBwb3J0Lm9wdFNlbGVjdGVkICkge1xuXHRqUXVlcnkucHJvcEhvb2tzLnNlbGVjdGVkID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdC8qIGVzbGludCBuby11bnVzZWQtZXhwcmVzc2lvbnM6IFwib2ZmXCIgKi9cblxuXHRcdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdGlmICggcGFyZW50ICYmIHBhcmVudC5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvKiBlc2xpbnQgbm8tdW51c2VkLWV4cHJlc3Npb25zOiBcIm9mZlwiICovXG5cblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoIHBhcmVudCApIHtcblx0XHRcdFx0cGFyZW50LnNlbGVjdGVkSW5kZXg7XG5cblx0XHRcdFx0aWYgKCBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG5qUXVlcnkuZWFjaCggW1xuXHRcInRhYkluZGV4XCIsXG5cdFwicmVhZE9ubHlcIixcblx0XCJtYXhMZW5ndGhcIixcblx0XCJjZWxsU3BhY2luZ1wiLFxuXHRcImNlbGxQYWRkaW5nXCIsXG5cdFwicm93U3BhblwiLFxuXHRcImNvbFNwYW5cIixcblx0XCJ1c2VNYXBcIixcblx0XCJmcmFtZUJvcmRlclwiLFxuXHRcImNvbnRlbnRFZGl0YWJsZVwiXG5dLCBmdW5jdGlvbigpIHtcblx0alF1ZXJ5LnByb3BGaXhbIHRoaXMudG9Mb3dlckNhc2UoKSBdID0gdGhpcztcbn0gKTtcblxuXG5cblxuXHQvLyBTdHJpcCBhbmQgY29sbGFwc2Ugd2hpdGVzcGFjZSBhY2NvcmRpbmcgdG8gSFRNTCBzcGVjXG5cdC8vIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNzdHJpcC1hbmQtY29sbGFwc2UtYXNjaWktd2hpdGVzcGFjZVxuXHRmdW5jdGlvbiBzdHJpcEFuZENvbGxhcHNlKCB2YWx1ZSApIHtcblx0XHR2YXIgdG9rZW5zID0gdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblx0XHRyZXR1cm4gdG9rZW5zLmpvaW4oIFwiIFwiICk7XG5cdH1cblxuXG5mdW5jdGlvbiBnZXRDbGFzcyggZWxlbSApIHtcblx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlICYmIGVsZW0uZ2V0QXR0cmlidXRlKCBcImNsYXNzXCIgKSB8fCBcIlwiO1xufVxuXG5mdW5jdGlvbiBjbGFzc2VzVG9BcnJheSggdmFsdWUgKSB7XG5cdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRyZXR1cm4gdmFsdWU7XG5cdH1cblx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cdH1cblx0cmV0dXJuIFtdO1xufVxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGFkZENsYXNzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGNsYXNzZXMsIGVsZW0sIGN1ciwgY3VyVmFsdWUsIGNsYXp6LCBqLCBmaW5hbFZhbHVlLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaiApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuYWRkQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIGdldENsYXNzKCB0aGlzICkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGNsYXNzZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcblxuXHRcdGlmICggY2xhc3Nlcy5sZW5ndGggKSB7XG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIGVsZW0gKTtcblx0XHRcdFx0Y3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZSggY3VyVmFsdWUgKSArIFwiIFwiICk7XG5cblx0XHRcdFx0aWYgKCBjdXIgKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGNsYXp6ID0gY2xhc3Nlc1sgaisrIF0gKSApIHtcblx0XHRcdFx0XHRcdGlmICggY3VyLmluZGV4T2YoIFwiIFwiICsgY2xhenogKyBcIiBcIiApIDwgMCApIHtcblx0XHRcdFx0XHRcdFx0Y3VyICs9IGNsYXp6ICsgXCIgXCI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cblx0XHRcdFx0XHRmaW5hbFZhbHVlID0gc3RyaXBBbmRDb2xsYXBzZSggY3VyICk7XG5cdFx0XHRcdFx0aWYgKCBjdXJWYWx1ZSAhPT0gZmluYWxWYWx1ZSApIHtcblx0XHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsIGZpbmFsVmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRyZW1vdmVDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnJlbW92ZUNsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCBnZXRDbGFzcyggdGhpcyApICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuYXR0ciggXCJjbGFzc1wiLCBcIlwiICk7XG5cdFx0fVxuXG5cdFx0Y2xhc3NlcyA9IGNsYXNzZXNUb0FycmF5KCB2YWx1ZSApO1xuXG5cdFx0aWYgKCBjbGFzc2VzLmxlbmd0aCApIHtcblx0XHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0Y3VyVmFsdWUgPSBnZXRDbGFzcyggZWxlbSApO1xuXG5cdFx0XHRcdC8vIFRoaXMgZXhwcmVzc2lvbiBpcyBoZXJlIGZvciBiZXR0ZXIgY29tcHJlc3NpYmlsaXR5IChzZWUgYWRkQ2xhc3MpXG5cdFx0XHRcdGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKCBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGN1clZhbHVlICkgKyBcIiBcIiApO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKCBjbGF6eiA9IGNsYXNzZXNbIGorKyBdICkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFJlbW92ZSAqYWxsKiBpbnN0YW5jZXNcblx0XHRcdFx0XHRcdHdoaWxlICggY3VyLmluZGV4T2YoIFwiIFwiICsgY2xhenogKyBcIiBcIiApID4gLTEgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciA9IGN1ci5yZXBsYWNlKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIsIFwiIFwiICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cblx0XHRcdFx0XHRmaW5hbFZhbHVlID0gc3RyaXBBbmRDb2xsYXBzZSggY3VyICk7XG5cdFx0XHRcdFx0aWYgKCBjdXJWYWx1ZSAhPT0gZmluYWxWYWx1ZSApIHtcblx0XHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsIGZpbmFsVmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR0b2dnbGVDbGFzczogZnVuY3Rpb24oIHZhbHVlLCBzdGF0ZVZhbCApIHtcblx0XHR2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZSxcblx0XHRcdGlzVmFsaWRWYWx1ZSA9IHR5cGUgPT09IFwic3RyaW5nXCIgfHwgQXJyYXkuaXNBcnJheSggdmFsdWUgKTtcblxuXHRcdGlmICggdHlwZW9mIHN0YXRlVmFsID09PSBcImJvb2xlYW5cIiAmJiBpc1ZhbGlkVmFsdWUgKSB7XG5cdFx0XHRyZXR1cm4gc3RhdGVWYWwgPyB0aGlzLmFkZENsYXNzKCB2YWx1ZSApIDogdGhpcy5yZW1vdmVDbGFzcyggdmFsdWUgKTtcblx0XHR9XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkudG9nZ2xlQ2xhc3MoXG5cdFx0XHRcdFx0dmFsdWUuY2FsbCggdGhpcywgaSwgZ2V0Q2xhc3MoIHRoaXMgKSwgc3RhdGVWYWwgKSxcblx0XHRcdFx0XHRzdGF0ZVZhbFxuXHRcdFx0XHQpO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGNsYXNzTmFtZSwgaSwgc2VsZiwgY2xhc3NOYW1lcztcblxuXHRcdFx0aWYgKCBpc1ZhbGlkVmFsdWUgKSB7XG5cblx0XHRcdFx0Ly8gVG9nZ2xlIGluZGl2aWR1YWwgY2xhc3MgbmFtZXNcblx0XHRcdFx0aSA9IDA7XG5cdFx0XHRcdHNlbGYgPSBqUXVlcnkoIHRoaXMgKTtcblx0XHRcdFx0Y2xhc3NOYW1lcyA9IGNsYXNzZXNUb0FycmF5KCB2YWx1ZSApO1xuXG5cdFx0XHRcdHdoaWxlICggKCBjbGFzc05hbWUgPSBjbGFzc05hbWVzWyBpKysgXSApICkge1xuXG5cdFx0XHRcdFx0Ly8gQ2hlY2sgZWFjaCBjbGFzc05hbWUgZ2l2ZW4sIHNwYWNlIHNlcGFyYXRlZCBsaXN0XG5cdFx0XHRcdFx0aWYgKCBzZWxmLmhhc0NsYXNzKCBjbGFzc05hbWUgKSApIHtcblx0XHRcdFx0XHRcdHNlbGYucmVtb3ZlQ2xhc3MoIGNsYXNzTmFtZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzZWxmLmFkZENsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gVG9nZ2xlIHdob2xlIGNsYXNzIG5hbWVcblx0XHRcdH0gZWxzZSBpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgfHwgdHlwZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRcdGNsYXNzTmFtZSA9IGdldENsYXNzKCB0aGlzICk7XG5cdFx0XHRcdGlmICggY2xhc3NOYW1lICkge1xuXG5cdFx0XHRcdFx0Ly8gU3RvcmUgY2xhc3NOYW1lIGlmIHNldFxuXHRcdFx0XHRcdGRhdGFQcml2LnNldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIsIGNsYXNzTmFtZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgdGhlIGVsZW1lbnQgaGFzIGEgY2xhc3MgbmFtZSBvciBpZiB3ZSdyZSBwYXNzZWQgYGZhbHNlYCxcblx0XHRcdFx0Ly8gdGhlbiByZW1vdmUgdGhlIHdob2xlIGNsYXNzbmFtZSAoaWYgdGhlcmUgd2FzIG9uZSwgdGhlIGFib3ZlIHNhdmVkIGl0KS5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGJyaW5nIGJhY2sgd2hhdGV2ZXIgd2FzIHByZXZpb3VzbHkgc2F2ZWQgKGlmIGFueXRoaW5nKSxcblx0XHRcdFx0Ly8gZmFsbGluZyBiYWNrIHRvIHRoZSBlbXB0eSBzdHJpbmcgaWYgbm90aGluZyB3YXMgc3RvcmVkLlxuXHRcdFx0XHRpZiAoIHRoaXMuc2V0QXR0cmlidXRlICkge1xuXHRcdFx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsXG5cdFx0XHRcdFx0XHRjbGFzc05hbWUgfHwgdmFsdWUgPT09IGZhbHNlID9cblx0XHRcdFx0XHRcdFwiXCIgOlxuXHRcdFx0XHRcdFx0ZGF0YVByaXYuZ2V0KCB0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiApIHx8IFwiXCJcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGhhc0NsYXNzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGNsYXNzTmFtZSwgZWxlbSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Y2xhc3NOYW1lID0gXCIgXCIgKyBzZWxlY3RvciArIFwiIFwiO1xuXHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHQoIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZSggZ2V0Q2xhc3MoIGVsZW0gKSApICsgXCIgXCIgKS5pbmRleE9mKCBjbGFzc05hbWUgKSA+IC0xICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufSApO1xuXG5cblxuXG52YXIgcnJldHVybiA9IC9cXHIvZztcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHR2YWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgaG9va3MsIHJldCwgdmFsdWVJc0Z1bmN0aW9uLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXTtcblxuXHRcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyBlbGVtLnR5cGUgXSB8fFxuXHRcdFx0XHRcdGpRdWVyeS52YWxIb29rc1sgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdFx0aWYgKCBob29rcyAmJlxuXHRcdFx0XHRcdFwiZ2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0XHQoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgXCJ2YWx1ZVwiICkgKSAhPT0gdW5kZWZpbmVkXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXQgPSBlbGVtLnZhbHVlO1xuXG5cdFx0XHRcdC8vIEhhbmRsZSBtb3N0IGNvbW1vbiBzdHJpbmcgY2FzZXNcblx0XHRcdFx0aWYgKCB0eXBlb2YgcmV0ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRcdHJldHVybiByZXQucmVwbGFjZSggcnJldHVybiwgXCJcIiApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSGFuZGxlIGNhc2VzIHdoZXJlIHZhbHVlIGlzIG51bGwvdW5kZWYgb3IgbnVtYmVyXG5cdFx0XHRcdHJldHVybiByZXQgPT0gbnVsbCA/IFwiXCIgOiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YWx1ZUlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHR2YXIgdmFsO1xuXG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB2YWx1ZUlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdHZhbCA9IHZhbHVlLmNhbGwoIHRoaXMsIGksIGpRdWVyeSggdGhpcyApLnZhbCgpICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVHJlYXQgbnVsbC91bmRlZmluZWQgYXMgXCJcIjsgY29udmVydCBudW1iZXJzIHRvIHN0cmluZ1xuXHRcdFx0aWYgKCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdFx0dmFsID0gXCJcIjtcblxuXHRcdFx0fSBlbHNlIGlmICggdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0dmFsICs9IFwiXCI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIEFycmF5LmlzQXJyYXkoIHZhbCApICkge1xuXHRcdFx0XHR2YWwgPSBqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSArIFwiXCI7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblxuXHRcdFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIHRoaXMudHlwZSBdIHx8IGpRdWVyeS52YWxIb29rc1sgdGhpcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdC8vIElmIHNldCByZXR1cm5zIHVuZGVmaW5lZCwgZmFsbCBiYWNrIHRvIG5vcm1hbCBzZXR0aW5nXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHwgaG9va3Muc2V0KCB0aGlzLCB2YWwsIFwidmFsdWVcIiApID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHRoaXMudmFsdWUgPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0dmFsSG9va3M6IHtcblx0XHRvcHRpb246IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdFx0dmFyIHZhbCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFwidmFsdWVcIiApO1xuXHRcdFx0XHRyZXR1cm4gdmFsICE9IG51bGwgP1xuXHRcdFx0XHRcdHZhbCA6XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTEwIC0gMTEgb25seVxuXHRcdFx0XHRcdC8vIG9wdGlvbi50ZXh0IHRocm93cyBleGNlcHRpb25zICgjMTQ2ODYsICMxNDg1OClcblx0XHRcdFx0XHQvLyBTdHJpcCBhbmQgY29sbGFwc2Ugd2hpdGVzcGFjZVxuXHRcdFx0XHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI3N0cmlwLWFuZC1jb2xsYXBzZS13aGl0ZXNwYWNlXG5cdFx0XHRcdFx0c3RyaXBBbmRDb2xsYXBzZSggalF1ZXJ5LnRleHQoIGVsZW0gKSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2VsZWN0OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgdmFsdWUsIG9wdGlvbiwgaSxcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdGluZGV4ID0gZWxlbS5zZWxlY3RlZEluZGV4LFxuXHRcdFx0XHRcdG9uZSA9IGVsZW0udHlwZSA9PT0gXCJzZWxlY3Qtb25lXCIsXG5cdFx0XHRcdFx0dmFsdWVzID0gb25lID8gbnVsbCA6IFtdLFxuXHRcdFx0XHRcdG1heCA9IG9uZSA/IGluZGV4ICsgMSA6IG9wdGlvbnMubGVuZ3RoO1xuXG5cdFx0XHRcdGlmICggaW5kZXggPCAwICkge1xuXHRcdFx0XHRcdGkgPSBtYXg7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpID0gb25lID8gaW5kZXggOiAwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTG9vcCB0aHJvdWdoIGFsbCB0aGUgc2VsZWN0ZWQgb3B0aW9uc1xuXHRcdFx0XHRmb3IgKCA7IGkgPCBtYXg7IGkrKyApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdC8vIElFOC05IGRvZXNuJ3QgdXBkYXRlIHNlbGVjdGVkIGFmdGVyIGZvcm0gcmVzZXQgKCMyNTUxKVxuXHRcdFx0XHRcdGlmICggKCBvcHRpb24uc2VsZWN0ZWQgfHwgaSA9PT0gaW5kZXggKSAmJlxuXG5cdFx0XHRcdFx0XHRcdC8vIERvbid0IHJldHVybiBvcHRpb25zIHRoYXQgYXJlIGRpc2FibGVkIG9yIGluIGEgZGlzYWJsZWQgb3B0Z3JvdXBcblx0XHRcdFx0XHRcdFx0IW9wdGlvbi5kaXNhYmxlZCAmJlxuXHRcdFx0XHRcdFx0XHQoICFvcHRpb24ucGFyZW50Tm9kZS5kaXNhYmxlZCB8fFxuXHRcdFx0XHRcdFx0XHRcdCFub2RlTmFtZSggb3B0aW9uLnBhcmVudE5vZGUsIFwib3B0Z3JvdXBcIiApICkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEdldCB0aGUgc3BlY2lmaWMgdmFsdWUgZm9yIHRoZSBvcHRpb25cblx0XHRcdFx0XHRcdHZhbHVlID0galF1ZXJ5KCBvcHRpb24gKS52YWwoKTtcblxuXHRcdFx0XHRcdFx0Ly8gV2UgZG9uJ3QgbmVlZCBhbiBhcnJheSBmb3Igb25lIHNlbGVjdHNcblx0XHRcdFx0XHRcdGlmICggb25lICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIE11bHRpLVNlbGVjdHMgcmV0dXJuIGFuIGFycmF5XG5cdFx0XHRcdFx0XHR2YWx1ZXMucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBvcHRpb25TZXQsIG9wdGlvbixcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdHZhbHVlcyA9IGpRdWVyeS5tYWtlQXJyYXkoIHZhbHVlICksXG5cdFx0XHRcdFx0aSA9IG9wdGlvbnMubGVuZ3RoO1xuXG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbmQtYXNzaWduICovXG5cblx0XHRcdFx0XHRpZiAoIG9wdGlvbi5zZWxlY3RlZCA9XG5cdFx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggalF1ZXJ5LnZhbEhvb2tzLm9wdGlvbi5nZXQoIG9wdGlvbiApLCB2YWx1ZXMgKSA+IC0xXG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRvcHRpb25TZXQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8qIGVzbGludC1lbmFibGUgbm8tY29uZC1hc3NpZ24gKi9cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEZvcmNlIGJyb3dzZXJzIHRvIGJlaGF2ZSBjb25zaXN0ZW50bHkgd2hlbiBub24tbWF0Y2hpbmcgdmFsdWUgaXMgc2V0XG5cdFx0XHRcdGlmICggIW9wdGlvblNldCApIHtcblx0XHRcdFx0XHRlbGVtLnNlbGVjdGVkSW5kZXggPSAtMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG4vLyBSYWRpb3MgYW5kIGNoZWNrYm94ZXMgZ2V0dGVyL3NldHRlclxualF1ZXJ5LmVhY2goIFsgXCJyYWRpb1wiLCBcImNoZWNrYm94XCIgXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdID0ge1xuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtLmNoZWNrZWQgPSBqUXVlcnkuaW5BcnJheSggalF1ZXJ5KCBlbGVtICkudmFsKCksIHZhbHVlICkgPiAtMSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0aWYgKCAhc3VwcG9ydC5jaGVja09uICkge1xuXHRcdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdLmdldCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gbnVsbCA/IFwib25cIiA6IGVsZW0udmFsdWU7XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG4vLyBSZXR1cm4galF1ZXJ5IGZvciBhdHRyaWJ1dGVzLW9ubHkgaW5jbHVzaW9uXG5cblxuc3VwcG9ydC5mb2N1c2luID0gXCJvbmZvY3VzaW5cIiBpbiB3aW5kb3c7XG5cblxudmFyIHJmb2N1c01vcnBoID0gL14oPzpmb2N1c2luZm9jdXN8Zm9jdXNvdXRibHVyKSQvLFxuXHRzdG9wUHJvcGFnYXRpb25DYWxsYmFjayA9IGZ1bmN0aW9uKCBlICkge1xuXHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH07XG5cbmpRdWVyeS5leHRlbmQoIGpRdWVyeS5ldmVudCwge1xuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCBldmVudCwgZGF0YSwgZWxlbSwgb25seUhhbmRsZXJzICkge1xuXG5cdFx0dmFyIGksIGN1ciwgdG1wLCBidWJibGVUeXBlLCBvbnR5cGUsIGhhbmRsZSwgc3BlY2lhbCwgbGFzdEVsZW1lbnQsXG5cdFx0XHRldmVudFBhdGggPSBbIGVsZW0gfHwgZG9jdW1lbnQgXSxcblx0XHRcdHR5cGUgPSBoYXNPd24uY2FsbCggZXZlbnQsIFwidHlwZVwiICkgPyBldmVudC50eXBlIDogZXZlbnQsXG5cdFx0XHRuYW1lc3BhY2VzID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcIm5hbWVzcGFjZVwiICkgPyBldmVudC5uYW1lc3BhY2Uuc3BsaXQoIFwiLlwiICkgOiBbXTtcblxuXHRcdGN1ciA9IGxhc3RFbGVtZW50ID0gdG1wID0gZWxlbSA9IGVsZW0gfHwgZG9jdW1lbnQ7XG5cblx0XHQvLyBEb24ndCBkbyBldmVudHMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIGZvY3VzL2JsdXIgbW9ycGhzIHRvIGZvY3VzaW4vb3V0OyBlbnN1cmUgd2UncmUgbm90IGZpcmluZyB0aGVtIHJpZ2h0IG5vd1xuXHRcdGlmICggcmZvY3VzTW9ycGgudGVzdCggdHlwZSArIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGUuaW5kZXhPZiggXCIuXCIgKSA+IC0xICkge1xuXG5cdFx0XHQvLyBOYW1lc3BhY2VkIHRyaWdnZXI7IGNyZWF0ZSBhIHJlZ2V4cCB0byBtYXRjaCBldmVudCB0eXBlIGluIGhhbmRsZSgpXG5cdFx0XHRuYW1lc3BhY2VzID0gdHlwZS5zcGxpdCggXCIuXCIgKTtcblx0XHRcdHR5cGUgPSBuYW1lc3BhY2VzLnNoaWZ0KCk7XG5cdFx0XHRuYW1lc3BhY2VzLnNvcnQoKTtcblx0XHR9XG5cdFx0b250eXBlID0gdHlwZS5pbmRleE9mKCBcIjpcIiApIDwgMCAmJiBcIm9uXCIgKyB0eXBlO1xuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGEgalF1ZXJ5LkV2ZW50IG9iamVjdCwgT2JqZWN0LCBvciBqdXN0IGFuIGV2ZW50IHR5cGUgc3RyaW5nXG5cdFx0ZXZlbnQgPSBldmVudFsgalF1ZXJ5LmV4cGFuZG8gXSA/XG5cdFx0XHRldmVudCA6XG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCB0eXBlLCB0eXBlb2YgZXZlbnQgPT09IFwib2JqZWN0XCIgJiYgZXZlbnQgKTtcblxuXHRcdC8vIFRyaWdnZXIgYml0bWFzazogJiAxIGZvciBuYXRpdmUgaGFuZGxlcnM7ICYgMiBmb3IgalF1ZXJ5IChhbHdheXMgdHJ1ZSlcblx0XHRldmVudC5pc1RyaWdnZXIgPSBvbmx5SGFuZGxlcnMgPyAyIDogMztcblx0XHRldmVudC5uYW1lc3BhY2UgPSBuYW1lc3BhY2VzLmpvaW4oIFwiLlwiICk7XG5cdFx0ZXZlbnQucm5hbWVzcGFjZSA9IGV2ZW50Lm5hbWVzcGFjZSA/XG5cdFx0XHRuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKCBcIlxcXFwuKD86LipcXFxcLnwpXCIgKSArIFwiKFxcXFwufCQpXCIgKSA6XG5cdFx0XHRudWxsO1xuXG5cdFx0Ly8gQ2xlYW4gdXAgdGhlIGV2ZW50IGluIGNhc2UgaXQgaXMgYmVpbmcgcmV1c2VkXG5cdFx0ZXZlbnQucmVzdWx0ID0gdW5kZWZpbmVkO1xuXHRcdGlmICggIWV2ZW50LnRhcmdldCApIHtcblx0XHRcdGV2ZW50LnRhcmdldCA9IGVsZW07XG5cdFx0fVxuXG5cdFx0Ly8gQ2xvbmUgYW55IGluY29taW5nIGRhdGEgYW5kIHByZXBlbmQgdGhlIGV2ZW50LCBjcmVhdGluZyB0aGUgaGFuZGxlciBhcmcgbGlzdFxuXHRcdGRhdGEgPSBkYXRhID09IG51bGwgP1xuXHRcdFx0WyBldmVudCBdIDpcblx0XHRcdGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEsIFsgZXZlbnQgXSApO1xuXG5cdFx0Ly8gQWxsb3cgc3BlY2lhbCBldmVudHMgdG8gZHJhdyBvdXRzaWRlIHRoZSBsaW5lc1xuXHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiBzcGVjaWFsLnRyaWdnZXIgJiYgc3BlY2lhbC50cmlnZ2VyLmFwcGx5KCBlbGVtLCBkYXRhICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBldmVudCBwcm9wYWdhdGlvbiBwYXRoIGluIGFkdmFuY2UsIHBlciBXM0MgZXZlbnRzIHNwZWMgKCM5OTUxKVxuXHRcdC8vIEJ1YmJsZSB1cCB0byBkb2N1bWVudCwgdGhlbiB0byB3aW5kb3c7IHdhdGNoIGZvciBhIGdsb2JhbCBvd25lckRvY3VtZW50IHZhciAoIzk3MjQpXG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFzcGVjaWFsLm5vQnViYmxlICYmICFpc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRidWJibGVUeXBlID0gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgfHwgdHlwZTtcblx0XHRcdGlmICggIXJmb2N1c01vcnBoLnRlc3QoIGJ1YmJsZVR5cGUgKyB0eXBlICkgKSB7XG5cdFx0XHRcdGN1ciA9IGN1ci5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICggOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRldmVudFBhdGgucHVzaCggY3VyICk7XG5cdFx0XHRcdHRtcCA9IGN1cjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT25seSBhZGQgd2luZG93IGlmIHdlIGdvdCB0byBkb2N1bWVudCAoZS5nLiwgbm90IHBsYWluIG9iaiBvciBkZXRhY2hlZCBET00pXG5cdFx0XHRpZiAoIHRtcCA9PT0gKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQgKSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIHRtcC5kZWZhdWx0VmlldyB8fCB0bXAucGFyZW50V2luZG93IHx8IHdpbmRvdyApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZpcmUgaGFuZGxlcnMgb24gdGhlIGV2ZW50IHBhdGhcblx0XHRpID0gMDtcblx0XHR3aGlsZSAoICggY3VyID0gZXZlbnRQYXRoWyBpKysgXSApICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0bGFzdEVsZW1lbnQgPSBjdXI7XG5cdFx0XHRldmVudC50eXBlID0gaSA+IDEgP1xuXHRcdFx0XHRidWJibGVUeXBlIDpcblx0XHRcdFx0c3BlY2lhbC5iaW5kVHlwZSB8fCB0eXBlO1xuXG5cdFx0XHQvLyBqUXVlcnkgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gKFxuXHRcdFx0XHRcdGRhdGFQcml2LmdldCggY3VyLCBcImV2ZW50c1wiICkgfHwgT2JqZWN0LmNyZWF0ZSggbnVsbCApXG5cdFx0XHRcdClbIGV2ZW50LnR5cGUgXSAmJlxuXHRcdFx0XHRkYXRhUHJpdi5nZXQoIGN1ciwgXCJoYW5kbGVcIiApO1xuXHRcdFx0aWYgKCBoYW5kbGUgKSB7XG5cdFx0XHRcdGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE5hdGl2ZSBoYW5kbGVyXG5cdFx0XHRoYW5kbGUgPSBvbnR5cGUgJiYgY3VyWyBvbnR5cGUgXTtcblx0XHRcdGlmICggaGFuZGxlICYmIGhhbmRsZS5hcHBseSAmJiBhY2NlcHREYXRhKCBjdXIgKSApIHtcblx0XHRcdFx0ZXZlbnQucmVzdWx0ID0gaGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcblx0XHRcdFx0aWYgKCBldmVudC5yZXN1bHQgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZXZlbnQudHlwZSA9IHR5cGU7XG5cblx0XHQvLyBJZiBub2JvZHkgcHJldmVudGVkIHRoZSBkZWZhdWx0IGFjdGlvbiwgZG8gaXQgbm93XG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSApIHtcblxuXHRcdFx0aWYgKCAoICFzcGVjaWFsLl9kZWZhdWx0IHx8XG5cdFx0XHRcdHNwZWNpYWwuX2RlZmF1bHQuYXBwbHkoIGV2ZW50UGF0aC5wb3AoKSwgZGF0YSApID09PSBmYWxzZSApICYmXG5cdFx0XHRcdGFjY2VwdERhdGEoIGVsZW0gKSApIHtcblxuXHRcdFx0XHQvLyBDYWxsIGEgbmF0aXZlIERPTSBtZXRob2Qgb24gdGhlIHRhcmdldCB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgdGhlIGV2ZW50LlxuXHRcdFx0XHQvLyBEb24ndCBkbyBkZWZhdWx0IGFjdGlvbnMgb24gd2luZG93LCB0aGF0J3Mgd2hlcmUgZ2xvYmFsIHZhcmlhYmxlcyBiZSAoIzYxNzApXG5cdFx0XHRcdGlmICggb250eXBlICYmIGlzRnVuY3Rpb24oIGVsZW1bIHR5cGUgXSApICYmICFpc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRcdFx0Ly8gRG9uJ3QgcmUtdHJpZ2dlciBhbiBvbkZPTyBldmVudCB3aGVuIHdlIGNhbGwgaXRzIEZPTygpIG1ldGhvZFxuXHRcdFx0XHRcdHRtcCA9IGVsZW1bIG9udHlwZSBdO1xuXG5cdFx0XHRcdFx0aWYgKCB0bXAgKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBvbnR5cGUgXSA9IG51bGw7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUHJldmVudCByZS10cmlnZ2VyaW5nIG9mIHRoZSBzYW1lIGV2ZW50LCBzaW5jZSB3ZSBhbHJlYWR5IGJ1YmJsZWQgaXQgYWJvdmVcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdHlwZTtcblxuXHRcdFx0XHRcdGlmICggZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdFx0XHRcdGxhc3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIHN0b3BQcm9wYWdhdGlvbkNhbGxiYWNrICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZWxlbVsgdHlwZSBdKCk7XG5cblx0XHRcdFx0XHRpZiAoIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRcdFx0XHRsYXN0RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBzdG9wUHJvcGFnYXRpb25DYWxsYmFjayApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gdG1wO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0Ly8gUGlnZ3liYWNrIG9uIGEgZG9ub3IgZXZlbnQgdG8gc2ltdWxhdGUgYSBkaWZmZXJlbnQgb25lXG5cdC8vIFVzZWQgb25seSBmb3IgYGZvY3VzKGluIHwgb3V0KWAgZXZlbnRzXG5cdHNpbXVsYXRlOiBmdW5jdGlvbiggdHlwZSwgZWxlbSwgZXZlbnQgKSB7XG5cdFx0dmFyIGUgPSBqUXVlcnkuZXh0ZW5kKFxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCgpLFxuXHRcdFx0ZXZlbnQsXG5cdFx0XHR7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdGlzU2ltdWxhdGVkOiB0cnVlXG5cdFx0XHR9XG5cdFx0KTtcblxuXHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBlLCBudWxsLCBlbGVtICk7XG5cdH1cblxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0dHJpZ2dlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgdGhpcyApO1xuXHRcdH0gKTtcblx0fSxcblx0dHJpZ2dlckhhbmRsZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBlbGVtID0gdGhpc1sgMCBdO1xuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgZWxlbSwgdHJ1ZSApO1xuXHRcdH1cblx0fVxufSApO1xuXG5cbi8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00NFxuLy8gRmlyZWZveCBkb2Vzbid0IGhhdmUgZm9jdXMoaW4gfCBvdXQpIGV2ZW50c1xuLy8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02ODc3ODdcbi8vXG4vLyBTdXBwb3J0OiBDaHJvbWUgPD00OCAtIDQ5LCBTYWZhcmkgPD05LjAgLSA5LjFcbi8vIGZvY3VzKGluIHwgb3V0KSBldmVudHMgZmlyZSBhZnRlciBmb2N1cyAmIGJsdXIgZXZlbnRzLFxuLy8gd2hpY2ggaXMgc3BlYyB2aW9sYXRpb24gLSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50cy1mb2N1c2V2ZW50LWV2ZW50LW9yZGVyXG4vLyBSZWxhdGVkIHRpY2tldCAtIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ0OTg1N1xuaWYgKCAhc3VwcG9ydC5mb2N1c2luICkge1xuXHRqUXVlcnkuZWFjaCggeyBmb2N1czogXCJmb2N1c2luXCIsIGJsdXI6IFwiZm9jdXNvdXRcIiB9LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXG5cdFx0Ly8gQXR0YWNoIGEgc2luZ2xlIGNhcHR1cmluZyBoYW5kbGVyIG9uIHRoZSBkb2N1bWVudCB3aGlsZSBzb21lb25lIHdhbnRzIGZvY3VzaW4vZm9jdXNvdXRcblx0XHR2YXIgaGFuZGxlciA9IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC5zaW11bGF0ZSggZml4LCBldmVudC50YXJnZXQsIGpRdWVyeS5ldmVudC5maXgoIGV2ZW50ICkgKTtcblx0XHR9O1xuXG5cdFx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGZpeCBdID0ge1xuXHRcdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIEhhbmRsZTogcmVndWxhciBub2RlcyAodmlhIGB0aGlzLm93bmVyRG9jdW1lbnRgKSwgd2luZG93XG5cdFx0XHRcdC8vICh2aWEgYHRoaXMuZG9jdW1lbnRgKSAmIGRvY3VtZW50ICh2aWEgYHRoaXNgKS5cblx0XHRcdFx0dmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLmRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLmFkZEV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4LCAoIGF0dGFjaGVzIHx8IDAgKSArIDEgKTtcblx0XHRcdH0sXG5cdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcy5kb2N1bWVudCB8fCB0aGlzLFxuXHRcdFx0XHRcdGF0dGFjaGVzID0gZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCApIC0gMTtcblxuXHRcdFx0XHRpZiAoICFhdHRhY2hlcyApIHtcblx0XHRcdFx0XHRkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lciggb3JpZywgaGFuZGxlciwgdHJ1ZSApO1xuXHRcdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZG9jLCBmaXggKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXgsIGF0dGFjaGVzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9ICk7XG59XG52YXIgbG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb247XG5cbnZhciBub25jZSA9IHsgZ3VpZDogRGF0ZS5ub3coKSB9O1xuXG52YXIgcnF1ZXJ5ID0gKCAvXFw/LyApO1xuXG5cblxuLy8gQ3Jvc3MtYnJvd3NlciB4bWwgcGFyc2luZ1xualF1ZXJ5LnBhcnNlWE1MID0gZnVuY3Rpb24oIGRhdGEgKSB7XG5cdHZhciB4bWw7XG5cdGlmICggIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seVxuXHQvLyBJRSB0aHJvd3Mgb24gcGFyc2VGcm9tU3RyaW5nIHdpdGggaW52YWxpZCBpbnB1dC5cblx0dHJ5IHtcblx0XHR4bWwgPSAoIG5ldyB3aW5kb3cuRE9NUGFyc2VyKCkgKS5wYXJzZUZyb21TdHJpbmcoIGRhdGEsIFwidGV4dC94bWxcIiApO1xuXHR9IGNhdGNoICggZSApIHtcblx0XHR4bWwgPSB1bmRlZmluZWQ7XG5cdH1cblxuXHRpZiAoICF4bWwgfHwgeG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcInBhcnNlcmVycm9yXCIgKS5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5LmVycm9yKCBcIkludmFsaWQgWE1MOiBcIiArIGRhdGEgKTtcblx0fVxuXHRyZXR1cm4geG1sO1xufTtcblxuXG52YXJcblx0cmJyYWNrZXQgPSAvXFxbXFxdJC8sXG5cdHJDUkxGID0gL1xccj9cXG4vZyxcblx0cnN1Ym1pdHRlclR5cGVzID0gL14oPzpzdWJtaXR8YnV0dG9ufGltYWdlfHJlc2V0fGZpbGUpJC9pLFxuXHRyc3VibWl0dGFibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxrZXlnZW4pL2k7XG5cbmZ1bmN0aW9uIGJ1aWxkUGFyYW1zKCBwcmVmaXgsIG9iaiwgdHJhZGl0aW9uYWwsIGFkZCApIHtcblx0dmFyIG5hbWU7XG5cblx0aWYgKCBBcnJheS5pc0FycmF5KCBvYmogKSApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBhcnJheSBpdGVtLlxuXHRcdGpRdWVyeS5lYWNoKCBvYmosIGZ1bmN0aW9uKCBpLCB2ICkge1xuXHRcdFx0aWYgKCB0cmFkaXRpb25hbCB8fCByYnJhY2tldC50ZXN0KCBwcmVmaXggKSApIHtcblxuXHRcdFx0XHQvLyBUcmVhdCBlYWNoIGFycmF5IGl0ZW0gYXMgYSBzY2FsYXIuXG5cdFx0XHRcdGFkZCggcHJlZml4LCB2ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gSXRlbSBpcyBub24tc2NhbGFyIChhcnJheSBvciBvYmplY3QpLCBlbmNvZGUgaXRzIG51bWVyaWMgaW5kZXguXG5cdFx0XHRcdGJ1aWxkUGFyYW1zKFxuXHRcdFx0XHRcdHByZWZpeCArIFwiW1wiICsgKCB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiAmJiB2ICE9IG51bGwgPyBpIDogXCJcIiApICsgXCJdXCIsXG5cdFx0XHRcdFx0dixcblx0XHRcdFx0XHR0cmFkaXRpb25hbCxcblx0XHRcdFx0XHRhZGRcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0fSBlbHNlIGlmICggIXRyYWRpdGlvbmFsICYmIHRvVHlwZSggb2JqICkgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgb2JqZWN0IGl0ZW0uXG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRidWlsZFBhcmFtcyggcHJlZml4ICsgXCJbXCIgKyBuYW1lICsgXCJdXCIsIG9ialsgbmFtZSBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cblx0XHQvLyBTZXJpYWxpemUgc2NhbGFyIGl0ZW0uXG5cdFx0YWRkKCBwcmVmaXgsIG9iaiApO1xuXHR9XG59XG5cbi8vIFNlcmlhbGl6ZSBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzIG9yIGEgc2V0IG9mXG4vLyBrZXkvdmFsdWVzIGludG8gYSBxdWVyeSBzdHJpbmdcbmpRdWVyeS5wYXJhbSA9IGZ1bmN0aW9uKCBhLCB0cmFkaXRpb25hbCApIHtcblx0dmFyIHByZWZpeCxcblx0XHRzID0gW10sXG5cdFx0YWRkID0gZnVuY3Rpb24oIGtleSwgdmFsdWVPckZ1bmN0aW9uICkge1xuXG5cdFx0XHQvLyBJZiB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCBpbnZva2UgaXQgYW5kIHVzZSBpdHMgcmV0dXJuIHZhbHVlXG5cdFx0XHR2YXIgdmFsdWUgPSBpc0Z1bmN0aW9uKCB2YWx1ZU9yRnVuY3Rpb24gKSA/XG5cdFx0XHRcdHZhbHVlT3JGdW5jdGlvbigpIDpcblx0XHRcdFx0dmFsdWVPckZ1bmN0aW9uO1xuXG5cdFx0XHRzWyBzLmxlbmd0aCBdID0gZW5jb2RlVVJJQ29tcG9uZW50KCBrZXkgKSArIFwiPVwiICtcblx0XHRcdFx0ZW5jb2RlVVJJQ29tcG9uZW50KCB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICk7XG5cdFx0fTtcblxuXHRpZiAoIGEgPT0gbnVsbCApIHtcblx0XHRyZXR1cm4gXCJcIjtcblx0fVxuXG5cdC8vIElmIGFuIGFycmF5IHdhcyBwYXNzZWQgaW4sIGFzc3VtZSB0aGF0IGl0IGlzIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMuXG5cdGlmICggQXJyYXkuaXNBcnJheSggYSApIHx8ICggYS5qcXVlcnkgJiYgIWpRdWVyeS5pc1BsYWluT2JqZWN0KCBhICkgKSApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSB0aGUgZm9ybSBlbGVtZW50c1xuXHRcdGpRdWVyeS5lYWNoKCBhLCBmdW5jdGlvbigpIHtcblx0XHRcdGFkZCggdGhpcy5uYW1lLCB0aGlzLnZhbHVlICk7XG5cdFx0fSApO1xuXG5cdH0gZWxzZSB7XG5cblx0XHQvLyBJZiB0cmFkaXRpb25hbCwgZW5jb2RlIHRoZSBcIm9sZFwiIHdheSAodGhlIHdheSAxLjMuMiBvciBvbGRlclxuXHRcdC8vIGRpZCBpdCksIG90aGVyd2lzZSBlbmNvZGUgcGFyYW1zIHJlY3Vyc2l2ZWx5LlxuXHRcdGZvciAoIHByZWZpeCBpbiBhICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCwgYVsgcHJlZml4IF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIHJlc3VsdGluZyBzZXJpYWxpemF0aW9uXG5cdHJldHVybiBzLmpvaW4oIFwiJlwiICk7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5wYXJhbSggdGhpcy5zZXJpYWxpemVBcnJheSgpICk7XG5cdH0sXG5cdHNlcmlhbGl6ZUFycmF5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBDYW4gYWRkIHByb3BIb29rIGZvciBcImVsZW1lbnRzXCIgdG8gZmlsdGVyIG9yIGFkZCBmb3JtIGVsZW1lbnRzXG5cdFx0XHR2YXIgZWxlbWVudHMgPSBqUXVlcnkucHJvcCggdGhpcywgXCJlbGVtZW50c1wiICk7XG5cdFx0XHRyZXR1cm4gZWxlbWVudHMgPyBqUXVlcnkubWFrZUFycmF5KCBlbGVtZW50cyApIDogdGhpcztcblx0XHR9IClcblx0XHQuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0eXBlID0gdGhpcy50eXBlO1xuXG5cdFx0XHQvLyBVc2UgLmlzKCBcIjpkaXNhYmxlZFwiICkgc28gdGhhdCBmaWVsZHNldFtkaXNhYmxlZF0gd29ya3Ncblx0XHRcdHJldHVybiB0aGlzLm5hbWUgJiYgIWpRdWVyeSggdGhpcyApLmlzKCBcIjpkaXNhYmxlZFwiICkgJiZcblx0XHRcdFx0cnN1Ym1pdHRhYmxlLnRlc3QoIHRoaXMubm9kZU5hbWUgKSAmJiAhcnN1Ym1pdHRlclR5cGVzLnRlc3QoIHR5cGUgKSAmJlxuXHRcdFx0XHQoIHRoaXMuY2hlY2tlZCB8fCAhcmNoZWNrYWJsZVR5cGUudGVzdCggdHlwZSApICk7XG5cdFx0fSApXG5cdFx0Lm1hcCggZnVuY3Rpb24oIF9pLCBlbGVtICkge1xuXHRcdFx0dmFyIHZhbCA9IGpRdWVyeSggdGhpcyApLnZhbCgpO1xuXG5cdFx0XHRpZiAoIHZhbCA9PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0cmV0dXJuIGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbCApIHtcblx0XHRcdFx0XHRyZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0fSApLmdldCgpO1xuXHR9XG59ICk7XG5cblxudmFyXG5cdHIyMCA9IC8lMjAvZyxcblx0cmhhc2ggPSAvIy4qJC8sXG5cdHJhbnRpQ2FjaGUgPSAvKFs/Jl0pXz1bXiZdKi8sXG5cdHJoZWFkZXJzID0gL14oLio/KTpbIFxcdF0qKFteXFxyXFxuXSopJC9tZyxcblxuXHQvLyAjNzY1MywgIzgxMjUsICM4MTUyOiBsb2NhbCBwcm90b2NvbCBkZXRlY3Rpb25cblx0cmxvY2FsUHJvdG9jb2wgPSAvXig/OmFib3V0fGFwcHxhcHAtc3RvcmFnZXwuKy1leHRlbnNpb258ZmlsZXxyZXN8d2lkZ2V0KTokLyxcblx0cm5vQ29udGVudCA9IC9eKD86R0VUfEhFQUQpJC8sXG5cdHJwcm90b2NvbCA9IC9eXFwvXFwvLyxcblxuXHQvKiBQcmVmaWx0ZXJzXG5cdCAqIDEpIFRoZXkgYXJlIHVzZWZ1bCB0byBpbnRyb2R1Y2UgY3VzdG9tIGRhdGFUeXBlcyAoc2VlIGFqYXgvanNvbnAuanMgZm9yIGFuIGV4YW1wbGUpXG5cdCAqIDIpIFRoZXNlIGFyZSBjYWxsZWQ6XG5cdCAqICAgIC0gQkVGT1JFIGFza2luZyBmb3IgYSB0cmFuc3BvcnRcblx0ICogICAgLSBBRlRFUiBwYXJhbSBzZXJpYWxpemF0aW9uIChzLmRhdGEgaXMgYSBzdHJpbmcgaWYgcy5wcm9jZXNzRGF0YSBpcyB0cnVlKVxuXHQgKiAzKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDQpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogNSkgZXhlY3V0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gY29udGludWUgZG93biB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHByZWZpbHRlcnMgPSB7fSxcblxuXHQvKiBUcmFuc3BvcnRzIGJpbmRpbmdzXG5cdCAqIDEpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogMikgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiAzKSBzZWxlY3Rpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBnbyB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHRyYW5zcG9ydHMgPSB7fSxcblxuXHQvLyBBdm9pZCBjb21tZW50LXByb2xvZyBjaGFyIHNlcXVlbmNlICgjMTAwOTgpOyBtdXN0IGFwcGVhc2UgbGludCBhbmQgZXZhZGUgY29tcHJlc3Npb25cblx0YWxsVHlwZXMgPSBcIiovXCIuY29uY2F0KCBcIipcIiApLFxuXG5cdC8vIEFuY2hvciB0YWcgZm9yIHBhcnNpbmcgdGhlIGRvY3VtZW50IG9yaWdpblxuXHRvcmlnaW5BbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXHRvcmlnaW5BbmNob3IuaHJlZiA9IGxvY2F0aW9uLmhyZWY7XG5cbi8vIEJhc2UgXCJjb25zdHJ1Y3RvclwiIGZvciBqUXVlcnkuYWpheFByZWZpbHRlciBhbmQgalF1ZXJ5LmFqYXhUcmFuc3BvcnRcbmZ1bmN0aW9uIGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlICkge1xuXG5cdC8vIGRhdGFUeXBlRXhwcmVzc2lvbiBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gXCIqXCJcblx0cmV0dXJuIGZ1bmN0aW9uKCBkYXRhVHlwZUV4cHJlc3Npb24sIGZ1bmMgKSB7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZUV4cHJlc3Npb24gIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRmdW5jID0gZGF0YVR5cGVFeHByZXNzaW9uO1xuXHRcdFx0ZGF0YVR5cGVFeHByZXNzaW9uID0gXCIqXCI7XG5cdFx0fVxuXG5cdFx0dmFyIGRhdGFUeXBlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRkYXRhVHlwZXMgPSBkYXRhVHlwZUV4cHJlc3Npb24udG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBmdW5jICkgKSB7XG5cblx0XHRcdC8vIEZvciBlYWNoIGRhdGFUeXBlIGluIHRoZSBkYXRhVHlwZUV4cHJlc3Npb25cblx0XHRcdHdoaWxlICggKCBkYXRhVHlwZSA9IGRhdGFUeXBlc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHQvLyBQcmVwZW5kIGlmIHJlcXVlc3RlZFxuXHRcdFx0XHRpZiAoIGRhdGFUeXBlWyAwIF0gPT09IFwiK1wiICkge1xuXHRcdFx0XHRcdGRhdGFUeXBlID0gZGF0YVR5cGUuc2xpY2UoIDEgKSB8fCBcIipcIjtcblx0XHRcdFx0XHQoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnVuc2hpZnQoIGZ1bmMgKTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYXBwZW5kXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0KCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10gKS5wdXNoKCBmdW5jICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbi8vIEJhc2UgaW5zcGVjdGlvbiBmdW5jdGlvbiBmb3IgcHJlZmlsdGVycyBhbmQgdHJhbnNwb3J0c1xuZnVuY3Rpb24gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSwgb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApIHtcblxuXHR2YXIgaW5zcGVjdGVkID0ge30sXG5cdFx0c2Vla2luZ1RyYW5zcG9ydCA9ICggc3RydWN0dXJlID09PSB0cmFuc3BvcnRzICk7XG5cblx0ZnVuY3Rpb24gaW5zcGVjdCggZGF0YVR5cGUgKSB7XG5cdFx0dmFyIHNlbGVjdGVkO1xuXHRcdGluc3BlY3RlZFsgZGF0YVR5cGUgXSA9IHRydWU7XG5cdFx0alF1ZXJ5LmVhY2goIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSwgZnVuY3Rpb24oIF8sIHByZWZpbHRlck9yRmFjdG9yeSApIHtcblx0XHRcdHZhciBkYXRhVHlwZU9yVHJhbnNwb3J0ID0gcHJlZmlsdGVyT3JGYWN0b3J5KCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICk7XG5cdFx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZU9yVHJhbnNwb3J0ID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCFzZWVraW5nVHJhbnNwb3J0ICYmICFpbnNwZWN0ZWRbIGRhdGFUeXBlT3JUcmFuc3BvcnQgXSApIHtcblxuXHRcdFx0XHRvcHRpb25zLmRhdGFUeXBlcy51bnNoaWZ0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdGluc3BlY3QoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSBlbHNlIGlmICggc2Vla2luZ1RyYW5zcG9ydCApIHtcblx0XHRcdFx0cmV0dXJuICEoIHNlbGVjdGVkID0gZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gc2VsZWN0ZWQ7XG5cdH1cblxuXHRyZXR1cm4gaW5zcGVjdCggb3B0aW9ucy5kYXRhVHlwZXNbIDAgXSApIHx8ICFpbnNwZWN0ZWRbIFwiKlwiIF0gJiYgaW5zcGVjdCggXCIqXCIgKTtcbn1cblxuLy8gQSBzcGVjaWFsIGV4dGVuZCBmb3IgYWpheCBvcHRpb25zXG4vLyB0aGF0IHRha2VzIFwiZmxhdFwiIG9wdGlvbnMgKG5vdCB0byBiZSBkZWVwIGV4dGVuZGVkKVxuLy8gRml4ZXMgIzk4ODdcbmZ1bmN0aW9uIGFqYXhFeHRlbmQoIHRhcmdldCwgc3JjICkge1xuXHR2YXIga2V5LCBkZWVwLFxuXHRcdGZsYXRPcHRpb25zID0galF1ZXJ5LmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9ucyB8fCB7fTtcblxuXHRmb3IgKCBrZXkgaW4gc3JjICkge1xuXHRcdGlmICggc3JjWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0KCBmbGF0T3B0aW9uc1sga2V5IF0gPyB0YXJnZXQgOiAoIGRlZXAgfHwgKCBkZWVwID0ge30gKSApIClbIGtleSBdID0gc3JjWyBrZXkgXTtcblx0XHR9XG5cdH1cblx0aWYgKCBkZWVwICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRydWUsIHRhcmdldCwgZGVlcCApO1xuXHR9XG5cblx0cmV0dXJuIHRhcmdldDtcbn1cblxuLyogSGFuZGxlcyByZXNwb25zZXMgdG8gYW4gYWpheCByZXF1ZXN0OlxuICogLSBmaW5kcyB0aGUgcmlnaHQgZGF0YVR5cGUgKG1lZGlhdGVzIGJldHdlZW4gY29udGVudC10eXBlIGFuZCBleHBlY3RlZCBkYXRhVHlwZSlcbiAqIC0gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuICovXG5mdW5jdGlvbiBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICkge1xuXG5cdHZhciBjdCwgdHlwZSwgZmluYWxEYXRhVHlwZSwgZmlyc3REYXRhVHlwZSxcblx0XHRjb250ZW50cyA9IHMuY29udGVudHMsXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXM7XG5cblx0Ly8gUmVtb3ZlIGF1dG8gZGF0YVR5cGUgYW5kIGdldCBjb250ZW50LXR5cGUgaW4gdGhlIHByb2Nlc3Ncblx0d2hpbGUgKCBkYXRhVHlwZXNbIDAgXSA9PT0gXCIqXCIgKSB7XG5cdFx0ZGF0YVR5cGVzLnNoaWZ0KCk7XG5cdFx0aWYgKCBjdCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Y3QgPSBzLm1pbWVUeXBlIHx8IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgd2UncmUgZGVhbGluZyB3aXRoIGEga25vd24gY29udGVudC10eXBlXG5cdGlmICggY3QgKSB7XG5cdFx0Zm9yICggdHlwZSBpbiBjb250ZW50cyApIHtcblx0XHRcdGlmICggY29udGVudHNbIHR5cGUgXSAmJiBjb250ZW50c1sgdHlwZSBdLnRlc3QoIGN0ICkgKSB7XG5cdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCB0eXBlICk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGEgcmVzcG9uc2UgZm9yIHRoZSBleHBlY3RlZCBkYXRhVHlwZVxuXHRpZiAoIGRhdGFUeXBlc1sgMCBdIGluIHJlc3BvbnNlcyApIHtcblx0XHRmaW5hbERhdGFUeXBlID0gZGF0YVR5cGVzWyAwIF07XG5cdH0gZWxzZSB7XG5cblx0XHQvLyBUcnkgY29udmVydGlibGUgZGF0YVR5cGVzXG5cdFx0Zm9yICggdHlwZSBpbiByZXNwb25zZXMgKSB7XG5cdFx0XHRpZiAoICFkYXRhVHlwZXNbIDAgXSB8fCBzLmNvbnZlcnRlcnNbIHR5cGUgKyBcIiBcIiArIGRhdGFUeXBlc1sgMCBdIF0gKSB7XG5cdFx0XHRcdGZpbmFsRGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggIWZpcnN0RGF0YVR5cGUgKSB7XG5cdFx0XHRcdGZpcnN0RGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE9yIGp1c3QgdXNlIGZpcnN0IG9uZVxuXHRcdGZpbmFsRGF0YVR5cGUgPSBmaW5hbERhdGFUeXBlIHx8IGZpcnN0RGF0YVR5cGU7XG5cdH1cblxuXHQvLyBJZiB3ZSBmb3VuZCBhIGRhdGFUeXBlXG5cdC8vIFdlIGFkZCB0aGUgZGF0YVR5cGUgdG8gdGhlIGxpc3QgaWYgbmVlZGVkXG5cdC8vIGFuZCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2Vcblx0aWYgKCBmaW5hbERhdGFUeXBlICkge1xuXHRcdGlmICggZmluYWxEYXRhVHlwZSAhPT0gZGF0YVR5cGVzWyAwIF0gKSB7XG5cdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggZmluYWxEYXRhVHlwZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzcG9uc2VzWyBmaW5hbERhdGFUeXBlIF07XG5cdH1cbn1cblxuLyogQ2hhaW4gY29udmVyc2lvbnMgZ2l2ZW4gdGhlIHJlcXVlc3QgYW5kIHRoZSBvcmlnaW5hbCByZXNwb25zZVxuICogQWxzbyBzZXRzIHRoZSByZXNwb25zZVhYWCBmaWVsZHMgb24gdGhlIGpxWEhSIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApIHtcblx0dmFyIGNvbnYyLCBjdXJyZW50LCBjb252LCB0bXAsIHByZXYsXG5cdFx0Y29udmVydGVycyA9IHt9LFxuXG5cdFx0Ly8gV29yayB3aXRoIGEgY29weSBvZiBkYXRhVHlwZXMgaW4gY2FzZSB3ZSBuZWVkIHRvIG1vZGlmeSBpdCBmb3IgY29udmVyc2lvblxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzLnNsaWNlKCk7XG5cblx0Ly8gQ3JlYXRlIGNvbnZlcnRlcnMgbWFwIHdpdGggbG93ZXJjYXNlZCBrZXlzXG5cdGlmICggZGF0YVR5cGVzWyAxIF0gKSB7XG5cdFx0Zm9yICggY29udiBpbiBzLmNvbnZlcnRlcnMgKSB7XG5cdFx0XHRjb252ZXJ0ZXJzWyBjb252LnRvTG93ZXJDYXNlKCkgXSA9IHMuY29udmVydGVyc1sgY29udiBdO1xuXHRcdH1cblx0fVxuXG5cdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHQvLyBDb252ZXJ0IHRvIGVhY2ggc2VxdWVudGlhbCBkYXRhVHlwZVxuXHR3aGlsZSAoIGN1cnJlbnQgKSB7XG5cblx0XHRpZiAoIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSApIHtcblx0XHRcdGpxWEhSWyBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gXSA9IHJlc3BvbnNlO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHRoZSBkYXRhRmlsdGVyIGlmIHByb3ZpZGVkXG5cdFx0aWYgKCAhcHJldiAmJiBpc1N1Y2Nlc3MgJiYgcy5kYXRhRmlsdGVyICkge1xuXHRcdFx0cmVzcG9uc2UgPSBzLmRhdGFGaWx0ZXIoIHJlc3BvbnNlLCBzLmRhdGFUeXBlICk7XG5cdFx0fVxuXG5cdFx0cHJldiA9IGN1cnJlbnQ7XG5cdFx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdFx0aWYgKCBjdXJyZW50ICkge1xuXG5cdFx0XHQvLyBUaGVyZSdzIG9ubHkgd29yayB0byBkbyBpZiBjdXJyZW50IGRhdGFUeXBlIGlzIG5vbi1hdXRvXG5cdFx0XHRpZiAoIGN1cnJlbnQgPT09IFwiKlwiICkge1xuXG5cdFx0XHRcdGN1cnJlbnQgPSBwcmV2O1xuXG5cdFx0XHQvLyBDb252ZXJ0IHJlc3BvbnNlIGlmIHByZXYgZGF0YVR5cGUgaXMgbm9uLWF1dG8gYW5kIGRpZmZlcnMgZnJvbSBjdXJyZW50XG5cdFx0XHR9IGVsc2UgaWYgKCBwcmV2ICE9PSBcIipcIiAmJiBwcmV2ICE9PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdC8vIFNlZWsgYSBkaXJlY3QgY29udmVydGVyXG5cdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyBjdXJyZW50IF0gfHwgY29udmVydGVyc1sgXCIqIFwiICsgY3VycmVudCBdO1xuXG5cdFx0XHRcdC8vIElmIG5vbmUgZm91bmQsIHNlZWsgYSBwYWlyXG5cdFx0XHRcdGlmICggIWNvbnYgKSB7XG5cdFx0XHRcdFx0Zm9yICggY29udjIgaW4gY29udmVydGVycyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSWYgY29udjIgb3V0cHV0cyBjdXJyZW50XG5cdFx0XHRcdFx0XHR0bXAgPSBjb252Mi5zcGxpdCggXCIgXCIgKTtcblx0XHRcdFx0XHRcdGlmICggdG1wWyAxIF0gPT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gSWYgcHJldiBjYW4gYmUgY29udmVydGVkIHRvIGFjY2VwdGVkIGlucHV0XG5cdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyB0bXBbIDAgXSBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0Y29udmVydGVyc1sgXCIqIFwiICsgdG1wWyAwIF0gXTtcblx0XHRcdFx0XHRcdFx0aWYgKCBjb252ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ29uZGVuc2UgZXF1aXZhbGVuY2UgY29udmVydGVyc1xuXHRcdFx0XHRcdFx0XHRcdGlmICggY29udiA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBjb252MiBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBpbnNlcnQgdGhlIGludGVybWVkaWF0ZSBkYXRhVHlwZVxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGNvbnZlcnRlcnNbIGNvbnYyIF0gIT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjdXJyZW50ID0gdG1wWyAwIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdG1wWyAxIF0gKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBcHBseSBjb252ZXJ0ZXIgKGlmIG5vdCBhbiBlcXVpdmFsZW5jZSlcblx0XHRcdFx0aWYgKCBjb252ICE9PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0Ly8gVW5sZXNzIGVycm9ycyBhcmUgYWxsb3dlZCB0byBidWJibGUsIGNhdGNoIGFuZCByZXR1cm4gdGhlbVxuXHRcdFx0XHRcdGlmICggY29udiAmJiBzLnRocm93cyApIHtcblx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdGU6IFwicGFyc2VyZXJyb3JcIixcblx0XHRcdFx0XHRcdFx0XHRlcnJvcjogY29udiA/IGUgOiBcIk5vIGNvbnZlcnNpb24gZnJvbSBcIiArIHByZXYgKyBcIiB0byBcIiArIGN1cnJlbnRcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4geyBzdGF0ZTogXCJzdWNjZXNzXCIsIGRhdGE6IHJlc3BvbnNlIH07XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBDb3VudGVyIGZvciBob2xkaW5nIHRoZSBudW1iZXIgb2YgYWN0aXZlIHF1ZXJpZXNcblx0YWN0aXZlOiAwLFxuXG5cdC8vIExhc3QtTW9kaWZpZWQgaGVhZGVyIGNhY2hlIGZvciBuZXh0IHJlcXVlc3Rcblx0bGFzdE1vZGlmaWVkOiB7fSxcblx0ZXRhZzoge30sXG5cblx0YWpheFNldHRpbmdzOiB7XG5cdFx0dXJsOiBsb2NhdGlvbi5ocmVmLFxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0aXNMb2NhbDogcmxvY2FsUHJvdG9jb2wudGVzdCggbG9jYXRpb24ucHJvdG9jb2wgKSxcblx0XHRnbG9iYWw6IHRydWUsXG5cdFx0cHJvY2Vzc0RhdGE6IHRydWUsXG5cdFx0YXN5bmM6IHRydWUsXG5cdFx0Y29udGVudFR5cGU6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04XCIsXG5cblx0XHQvKlxuXHRcdHRpbWVvdXQ6IDAsXG5cdFx0ZGF0YTogbnVsbCxcblx0XHRkYXRhVHlwZTogbnVsbCxcblx0XHR1c2VybmFtZTogbnVsbCxcblx0XHRwYXNzd29yZDogbnVsbCxcblx0XHRjYWNoZTogbnVsbCxcblx0XHR0aHJvd3M6IGZhbHNlLFxuXHRcdHRyYWRpdGlvbmFsOiBmYWxzZSxcblx0XHRoZWFkZXJzOiB7fSxcblx0XHQqL1xuXG5cdFx0YWNjZXB0czoge1xuXHRcdFx0XCIqXCI6IGFsbFR5cGVzLFxuXHRcdFx0dGV4dDogXCJ0ZXh0L3BsYWluXCIsXG5cdFx0XHRodG1sOiBcInRleHQvaHRtbFwiLFxuXHRcdFx0eG1sOiBcImFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWxcIixcblx0XHRcdGpzb246IFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9qYXZhc2NyaXB0XCJcblx0XHR9LFxuXG5cdFx0Y29udGVudHM6IHtcblx0XHRcdHhtbDogL1xcYnhtbFxcYi8sXG5cdFx0XHRodG1sOiAvXFxiaHRtbC8sXG5cdFx0XHRqc29uOiAvXFxianNvblxcYi9cblx0XHR9LFxuXG5cdFx0cmVzcG9uc2VGaWVsZHM6IHtcblx0XHRcdHhtbDogXCJyZXNwb25zZVhNTFwiLFxuXHRcdFx0dGV4dDogXCJyZXNwb25zZVRleHRcIixcblx0XHRcdGpzb246IFwicmVzcG9uc2VKU09OXCJcblx0XHR9LFxuXG5cdFx0Ly8gRGF0YSBjb252ZXJ0ZXJzXG5cdFx0Ly8gS2V5cyBzZXBhcmF0ZSBzb3VyY2UgKG9yIGNhdGNoYWxsIFwiKlwiKSBhbmQgZGVzdGluYXRpb24gdHlwZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuXHRcdGNvbnZlcnRlcnM6IHtcblxuXHRcdFx0Ly8gQ29udmVydCBhbnl0aGluZyB0byB0ZXh0XG5cdFx0XHRcIiogdGV4dFwiOiBTdHJpbmcsXG5cblx0XHRcdC8vIFRleHQgdG8gaHRtbCAodHJ1ZSA9IG5vIHRyYW5zZm9ybWF0aW9uKVxuXHRcdFx0XCJ0ZXh0IGh0bWxcIjogdHJ1ZSxcblxuXHRcdFx0Ly8gRXZhbHVhdGUgdGV4dCBhcyBhIGpzb24gZXhwcmVzc2lvblxuXHRcdFx0XCJ0ZXh0IGpzb25cIjogSlNPTi5wYXJzZSxcblxuXHRcdFx0Ly8gUGFyc2UgdGV4dCBhcyB4bWxcblx0XHRcdFwidGV4dCB4bWxcIjogalF1ZXJ5LnBhcnNlWE1MXG5cdFx0fSxcblxuXHRcdC8vIEZvciBvcHRpb25zIHRoYXQgc2hvdWxkbid0IGJlIGRlZXAgZXh0ZW5kZWQ6XG5cdFx0Ly8geW91IGNhbiBhZGQgeW91ciBvd24gY3VzdG9tIG9wdGlvbnMgaGVyZSBpZlxuXHRcdC8vIGFuZCB3aGVuIHlvdSBjcmVhdGUgb25lIHRoYXQgc2hvdWxkbid0IGJlXG5cdFx0Ly8gZGVlcCBleHRlbmRlZCAoc2VlIGFqYXhFeHRlbmQpXG5cdFx0ZmxhdE9wdGlvbnM6IHtcblx0XHRcdHVybDogdHJ1ZSxcblx0XHRcdGNvbnRleHQ6IHRydWVcblx0XHR9XG5cdH0sXG5cblx0Ly8gQ3JlYXRlcyBhIGZ1bGwgZmxlZGdlZCBzZXR0aW5ncyBvYmplY3QgaW50byB0YXJnZXRcblx0Ly8gd2l0aCBib3RoIGFqYXhTZXR0aW5ncyBhbmQgc2V0dGluZ3MgZmllbGRzLlxuXHQvLyBJZiB0YXJnZXQgaXMgb21pdHRlZCwgd3JpdGVzIGludG8gYWpheFNldHRpbmdzLlxuXHRhamF4U2V0dXA6IGZ1bmN0aW9uKCB0YXJnZXQsIHNldHRpbmdzICkge1xuXHRcdHJldHVybiBzZXR0aW5ncyA/XG5cblx0XHRcdC8vIEJ1aWxkaW5nIGEgc2V0dGluZ3Mgb2JqZWN0XG5cdFx0XHRhamF4RXh0ZW5kKCBhamF4RXh0ZW5kKCB0YXJnZXQsIGpRdWVyeS5hamF4U2V0dGluZ3MgKSwgc2V0dGluZ3MgKSA6XG5cblx0XHRcdC8vIEV4dGVuZGluZyBhamF4U2V0dGluZ3Ncblx0XHRcdGFqYXhFeHRlbmQoIGpRdWVyeS5hamF4U2V0dGluZ3MsIHRhcmdldCApO1xuXHR9LFxuXG5cdGFqYXhQcmVmaWx0ZXI6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycyApLFxuXHRhamF4VHJhbnNwb3J0OiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMgKSxcblxuXHQvLyBNYWluIG1ldGhvZFxuXHRhamF4OiBmdW5jdGlvbiggdXJsLCBvcHRpb25zICkge1xuXG5cdFx0Ly8gSWYgdXJsIGlzIGFuIG9iamVjdCwgc2ltdWxhdGUgcHJlLTEuNSBzaWduYXR1cmVcblx0XHRpZiAoIHR5cGVvZiB1cmwgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRvcHRpb25zID0gdXJsO1xuXHRcdFx0dXJsID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIEZvcmNlIG9wdGlvbnMgdG8gYmUgYW4gb2JqZWN0XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHR2YXIgdHJhbnNwb3J0LFxuXG5cdFx0XHQvLyBVUkwgd2l0aG91dCBhbnRpLWNhY2hlIHBhcmFtXG5cdFx0XHRjYWNoZVVSTCxcblxuXHRcdFx0Ly8gUmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nLFxuXHRcdFx0cmVzcG9uc2VIZWFkZXJzLFxuXG5cdFx0XHQvLyB0aW1lb3V0IGhhbmRsZVxuXHRcdFx0dGltZW91dFRpbWVyLFxuXG5cdFx0XHQvLyBVcmwgY2xlYW51cCB2YXJcblx0XHRcdHVybEFuY2hvcixcblxuXHRcdFx0Ly8gUmVxdWVzdCBzdGF0ZSAoYmVjb21lcyBmYWxzZSB1cG9uIHNlbmQgYW5kIHRydWUgdXBvbiBjb21wbGV0aW9uKVxuXHRcdFx0Y29tcGxldGVkLFxuXG5cdFx0XHQvLyBUbyBrbm93IGlmIGdsb2JhbCBldmVudHMgYXJlIHRvIGJlIGRpc3BhdGNoZWRcblx0XHRcdGZpcmVHbG9iYWxzLFxuXG5cdFx0XHQvLyBMb29wIHZhcmlhYmxlXG5cdFx0XHRpLFxuXG5cdFx0XHQvLyB1bmNhY2hlZCBwYXJ0IG9mIHRoZSB1cmxcblx0XHRcdHVuY2FjaGVkLFxuXG5cdFx0XHQvLyBDcmVhdGUgdGhlIGZpbmFsIG9wdGlvbnMgb2JqZWN0XG5cdFx0XHRzID0galF1ZXJ5LmFqYXhTZXR1cCgge30sIG9wdGlvbnMgKSxcblxuXHRcdFx0Ly8gQ2FsbGJhY2tzIGNvbnRleHRcblx0XHRcdGNhbGxiYWNrQ29udGV4dCA9IHMuY29udGV4dCB8fCBzLFxuXG5cdFx0XHQvLyBDb250ZXh0IGZvciBnbG9iYWwgZXZlbnRzIGlzIGNhbGxiYWNrQ29udGV4dCBpZiBpdCBpcyBhIERPTSBub2RlIG9yIGpRdWVyeSBjb2xsZWN0aW9uXG5cdFx0XHRnbG9iYWxFdmVudENvbnRleHQgPSBzLmNvbnRleHQgJiZcblx0XHRcdFx0KCBjYWxsYmFja0NvbnRleHQubm9kZVR5cGUgfHwgY2FsbGJhY2tDb250ZXh0LmpxdWVyeSApID9cblx0XHRcdFx0XHRqUXVlcnkoIGNhbGxiYWNrQ29udGV4dCApIDpcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQsXG5cblx0XHRcdC8vIERlZmVycmVkc1xuXHRcdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQgPSBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdHN0YXR1c0NvZGUgPSBzLnN0YXR1c0NvZGUgfHwge30sXG5cblx0XHRcdC8vIEhlYWRlcnMgKHRoZXkgYXJlIHNlbnQgYWxsIGF0IG9uY2UpXG5cdFx0XHRyZXF1ZXN0SGVhZGVycyA9IHt9LFxuXHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lcyA9IHt9LFxuXG5cdFx0XHQvLyBEZWZhdWx0IGFib3J0IG1lc3NhZ2Vcblx0XHRcdHN0ckFib3J0ID0gXCJjYW5jZWxlZFwiLFxuXG5cdFx0XHQvLyBGYWtlIHhoclxuXHRcdFx0anFYSFIgPSB7XG5cdFx0XHRcdHJlYWR5U3RhdGU6IDAsXG5cblx0XHRcdFx0Ly8gQnVpbGRzIGhlYWRlcnMgaGFzaHRhYmxlIGlmIG5lZWRlZFxuXHRcdFx0XHRnZXRSZXNwb25zZUhlYWRlcjogZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdFx0XHR2YXIgbWF0Y2g7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICFyZXNwb25zZUhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVycyA9IHt9O1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoICggbWF0Y2ggPSByaGVhZGVycy5leGVjKCByZXNwb25zZUhlYWRlcnNTdHJpbmcgKSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVyc1sgbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpICsgXCIgXCIgXSA9XG5cdFx0XHRcdFx0XHRcdFx0XHQoIHJlc3BvbnNlSGVhZGVyc1sgbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpICsgXCIgXCIgXSB8fCBbXSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5jb25jYXQoIG1hdGNoWyAyIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0bWF0Y2ggPSByZXNwb25zZUhlYWRlcnNbIGtleS50b0xvd2VyQ2FzZSgpICsgXCIgXCIgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoID09IG51bGwgPyBudWxsIDogbWF0Y2guam9pbiggXCIsIFwiICk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gUmF3IHN0cmluZ1xuXHRcdFx0XHRnZXRBbGxSZXNwb25zZUhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBjb21wbGV0ZWQgPyByZXNwb25zZUhlYWRlcnNTdHJpbmcgOiBudWxsO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIENhY2hlcyB0aGUgaGVhZGVyXG5cdFx0XHRcdHNldFJlcXVlc3RIZWFkZXI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0bmFtZSA9IHJlcXVlc3RIZWFkZXJzTmFtZXNbIG5hbWUudG9Mb3dlckNhc2UoKSBdID1cblx0XHRcdFx0XHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gfHwgbmFtZTtcblx0XHRcdFx0XHRcdHJlcXVlc3RIZWFkZXJzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gT3ZlcnJpZGVzIHJlc3BvbnNlIGNvbnRlbnQtdHlwZSBoZWFkZXJcblx0XHRcdFx0b3ZlcnJpZGVNaW1lVHlwZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdHMubWltZVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0XHRzdGF0dXNDb2RlOiBmdW5jdGlvbiggbWFwICkge1xuXHRcdFx0XHRcdHZhciBjb2RlO1xuXHRcdFx0XHRcdGlmICggbWFwICkge1xuXHRcdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gRXhlY3V0ZSB0aGUgYXBwcm9wcmlhdGUgY2FsbGJhY2tzXG5cdFx0XHRcdFx0XHRcdGpxWEhSLmFsd2F5cyggbWFwWyBqcVhIUi5zdGF0dXMgXSApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBMYXp5LWFkZCB0aGUgbmV3IGNhbGxiYWNrcyBpbiBhIHdheSB0aGF0IHByZXNlcnZlcyBvbGQgb25lc1xuXHRcdFx0XHRcdFx0XHRmb3IgKCBjb2RlIGluIG1hcCApIHtcblx0XHRcdFx0XHRcdFx0XHRzdGF0dXNDb2RlWyBjb2RlIF0gPSBbIHN0YXR1c0NvZGVbIGNvZGUgXSwgbWFwWyBjb2RlIF0gXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYW5jZWwgdGhlIHJlcXVlc3Rcblx0XHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCBzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHZhciBmaW5hbFRleHQgPSBzdGF0dXNUZXh0IHx8IHN0ckFib3J0O1xuXHRcdFx0XHRcdGlmICggdHJhbnNwb3J0ICkge1xuXHRcdFx0XHRcdFx0dHJhbnNwb3J0LmFib3J0KCBmaW5hbFRleHQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZG9uZSggMCwgZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHQvLyBBdHRhY2ggZGVmZXJyZWRzXG5cdFx0ZGVmZXJyZWQucHJvbWlzZSgganFYSFIgKTtcblxuXHRcdC8vIEFkZCBwcm90b2NvbCBpZiBub3QgcHJvdmlkZWQgKHByZWZpbHRlcnMgbWlnaHQgZXhwZWN0IGl0KVxuXHRcdC8vIEhhbmRsZSBmYWxzeSB1cmwgaW4gdGhlIHNldHRpbmdzIG9iamVjdCAoIzEwMDkzOiBjb25zaXN0ZW5jeSB3aXRoIG9sZCBzaWduYXR1cmUpXG5cdFx0Ly8gV2UgYWxzbyB1c2UgdGhlIHVybCBwYXJhbWV0ZXIgaWYgYXZhaWxhYmxlXG5cdFx0cy51cmwgPSAoICggdXJsIHx8IHMudXJsIHx8IGxvY2F0aW9uLmhyZWYgKSArIFwiXCIgKVxuXHRcdFx0LnJlcGxhY2UoIHJwcm90b2NvbCwgbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKTtcblxuXHRcdC8vIEFsaWFzIG1ldGhvZCBvcHRpb24gdG8gdHlwZSBhcyBwZXIgdGlja2V0ICMxMjAwNFxuXHRcdHMudHlwZSA9IG9wdGlvbnMubWV0aG9kIHx8IG9wdGlvbnMudHlwZSB8fCBzLm1ldGhvZCB8fCBzLnR5cGU7XG5cblx0XHQvLyBFeHRyYWN0IGRhdGFUeXBlcyBsaXN0XG5cdFx0cy5kYXRhVHlwZXMgPSAoIHMuZGF0YVR5cGUgfHwgXCIqXCIgKS50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cblx0XHQvLyBBIGNyb3NzLWRvbWFpbiByZXF1ZXN0IGlzIGluIG9yZGVyIHdoZW4gdGhlIG9yaWdpbiBkb2Vzbid0IG1hdGNoIHRoZSBjdXJyZW50IG9yaWdpbi5cblx0XHRpZiAoIHMuY3Jvc3NEb21haW4gPT0gbnVsbCApIHtcblx0XHRcdHVybEFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExLCBFZGdlIDEyIC0gMTVcblx0XHRcdC8vIElFIHRocm93cyBleGNlcHRpb24gb24gYWNjZXNzaW5nIHRoZSBocmVmIHByb3BlcnR5IGlmIHVybCBpcyBtYWxmb3JtZWQsXG5cdFx0XHQvLyBlLmcuIGh0dHA6Ly9leGFtcGxlLmNvbTo4MHgvXG5cdFx0XHR0cnkge1xuXHRcdFx0XHR1cmxBbmNob3IuaHJlZiA9IHMudXJsO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExIG9ubHlcblx0XHRcdFx0Ly8gQW5jaG9yJ3MgaG9zdCBwcm9wZXJ0eSBpc24ndCBjb3JyZWN0bHkgc2V0IHdoZW4gcy51cmwgaXMgcmVsYXRpdmVcblx0XHRcdFx0dXJsQW5jaG9yLmhyZWYgPSB1cmxBbmNob3IuaHJlZjtcblx0XHRcdFx0cy5jcm9zc0RvbWFpbiA9IG9yaWdpbkFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIG9yaWdpbkFuY2hvci5ob3N0ICE9PVxuXHRcdFx0XHRcdHVybEFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIHVybEFuY2hvci5ob3N0O1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0Ly8gSWYgdGhlcmUgaXMgYW4gZXJyb3IgcGFyc2luZyB0aGUgVVJMLCBhc3N1bWUgaXQgaXMgY3Jvc3NEb21haW4sXG5cdFx0XHRcdC8vIGl0IGNhbiBiZSByZWplY3RlZCBieSB0aGUgdHJhbnNwb3J0IGlmIGl0IGlzIGludmFsaWRcblx0XHRcdFx0cy5jcm9zc0RvbWFpbiA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBkYXRhIGlmIG5vdCBhbHJlYWR5IGEgc3RyaW5nXG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJiB0eXBlb2Ygcy5kYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cy5kYXRhID0galF1ZXJ5LnBhcmFtKCBzLmRhdGEsIHMudHJhZGl0aW9uYWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwcmVmaWx0ZXJzXG5cdFx0aW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhIHByZWZpbHRlciwgc3RvcCB0aGVyZVxuXHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0cmV0dXJuIGpxWEhSO1xuXHRcdH1cblxuXHRcdC8vIFdlIGNhbiBmaXJlIGdsb2JhbCBldmVudHMgYXMgb2Ygbm93IGlmIGFza2VkIHRvXG5cdFx0Ly8gRG9uJ3QgZmlyZSBldmVudHMgaWYgalF1ZXJ5LmV2ZW50IGlzIHVuZGVmaW5lZCBpbiBhbiBBTUQtdXNhZ2Ugc2NlbmFyaW8gKCMxNTExOClcblx0XHRmaXJlR2xvYmFscyA9IGpRdWVyeS5ldmVudCAmJiBzLmdsb2JhbDtcblxuXHRcdC8vIFdhdGNoIGZvciBhIG5ldyBzZXQgb2YgcmVxdWVzdHNcblx0XHRpZiAoIGZpcmVHbG9iYWxzICYmIGpRdWVyeS5hY3RpdmUrKyA9PT0gMCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdGFydFwiICk7XG5cdFx0fVxuXG5cdFx0Ly8gVXBwZXJjYXNlIHRoZSB0eXBlXG5cdFx0cy50eXBlID0gcy50eXBlLnRvVXBwZXJDYXNlKCk7XG5cblx0XHQvLyBEZXRlcm1pbmUgaWYgcmVxdWVzdCBoYXMgY29udGVudFxuXHRcdHMuaGFzQ29udGVudCA9ICFybm9Db250ZW50LnRlc3QoIHMudHlwZSApO1xuXG5cdFx0Ly8gU2F2ZSB0aGUgVVJMIGluIGNhc2Ugd2UncmUgdG95aW5nIHdpdGggdGhlIElmLU1vZGlmaWVkLVNpbmNlXG5cdFx0Ly8gYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyIGxhdGVyIG9uXG5cdFx0Ly8gUmVtb3ZlIGhhc2ggdG8gc2ltcGxpZnkgdXJsIG1hbmlwdWxhdGlvblxuXHRcdGNhY2hlVVJMID0gcy51cmwucmVwbGFjZSggcmhhc2gsIFwiXCIgKTtcblxuXHRcdC8vIE1vcmUgb3B0aW9ucyBoYW5kbGluZyBmb3IgcmVxdWVzdHMgd2l0aCBubyBjb250ZW50XG5cdFx0aWYgKCAhcy5oYXNDb250ZW50ICkge1xuXG5cdFx0XHQvLyBSZW1lbWJlciB0aGUgaGFzaCBzbyB3ZSBjYW4gcHV0IGl0IGJhY2tcblx0XHRcdHVuY2FjaGVkID0gcy51cmwuc2xpY2UoIGNhY2hlVVJMLmxlbmd0aCApO1xuXG5cdFx0XHQvLyBJZiBkYXRhIGlzIGF2YWlsYWJsZSBhbmQgc2hvdWxkIGJlIHByb2Nlc3NlZCwgYXBwZW5kIGRhdGEgdG8gdXJsXG5cdFx0XHRpZiAoIHMuZGF0YSAmJiAoIHMucHJvY2Vzc0RhdGEgfHwgdHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiApICkge1xuXHRcdFx0XHRjYWNoZVVSTCArPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgcy5kYXRhO1xuXG5cdFx0XHRcdC8vICM5NjgyOiByZW1vdmUgZGF0YSBzbyB0aGF0IGl0J3Mgbm90IHVzZWQgaW4gYW4gZXZlbnR1YWwgcmV0cnlcblx0XHRcdFx0ZGVsZXRlIHMuZGF0YTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIG9yIHVwZGF0ZSBhbnRpLWNhY2hlIHBhcmFtIGlmIG5lZWRlZFxuXHRcdFx0aWYgKCBzLmNhY2hlID09PSBmYWxzZSApIHtcblx0XHRcdFx0Y2FjaGVVUkwgPSBjYWNoZVVSTC5yZXBsYWNlKCByYW50aUNhY2hlLCBcIiQxXCIgKTtcblx0XHRcdFx0dW5jYWNoZWQgPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgXCJfPVwiICsgKCBub25jZS5ndWlkKysgKSArXG5cdFx0XHRcdFx0dW5jYWNoZWQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFB1dCBoYXNoIGFuZCBhbnRpLWNhY2hlIG9uIHRoZSBVUkwgdGhhdCB3aWxsIGJlIHJlcXVlc3RlZCAoZ2gtMTczMilcblx0XHRcdHMudXJsID0gY2FjaGVVUkwgKyB1bmNhY2hlZDtcblxuXHRcdC8vIENoYW5nZSAnJTIwJyB0byAnKycgaWYgdGhpcyBpcyBlbmNvZGVkIGZvcm0gYm9keSBjb250ZW50IChnaC0yNjU4KVxuXHRcdH0gZWxzZSBpZiAoIHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmXG5cdFx0XHQoIHMuY29udGVudFR5cGUgfHwgXCJcIiApLmluZGV4T2YoIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIgKSA9PT0gMCApIHtcblx0XHRcdHMuZGF0YSA9IHMuZGF0YS5yZXBsYWNlKCByMjAsIFwiK1wiICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cblx0XHRpZiAoIHMuaWZNb2RpZmllZCApIHtcblx0XHRcdGlmICggalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApIHtcblx0XHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJJZi1Nb2RpZmllZC1TaW5jZVwiLCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU5vbmUtTWF0Y2hcIiwgalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIGNvcnJlY3QgaGVhZGVyLCBpZiBkYXRhIGlzIGJlaW5nIHNlbnRcblx0XHRpZiAoIHMuZGF0YSAmJiBzLmhhc0NvbnRlbnQgJiYgcy5jb250ZW50VHlwZSAhPT0gZmFsc2UgfHwgb3B0aW9ucy5jb250ZW50VHlwZSApIHtcblx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiQ29udGVudC1UeXBlXCIsIHMuY29udGVudFR5cGUgKTtcblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIEFjY2VwdHMgaGVhZGVyIGZvciB0aGUgc2VydmVyLCBkZXBlbmRpbmcgb24gdGhlIGRhdGFUeXBlXG5cdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlcihcblx0XHRcdFwiQWNjZXB0XCIsXG5cdFx0XHRzLmRhdGFUeXBlc1sgMCBdICYmIHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbIDAgXSBdID9cblx0XHRcdFx0cy5hY2NlcHRzWyBzLmRhdGFUeXBlc1sgMCBdIF0gK1xuXHRcdFx0XHRcdCggcy5kYXRhVHlwZXNbIDAgXSAhPT0gXCIqXCIgPyBcIiwgXCIgKyBhbGxUeXBlcyArIFwiOyBxPTAuMDFcIiA6IFwiXCIgKSA6XG5cdFx0XHRcdHMuYWNjZXB0c1sgXCIqXCIgXVxuXHRcdCk7XG5cblx0XHQvLyBDaGVjayBmb3IgaGVhZGVycyBvcHRpb25cblx0XHRmb3IgKCBpIGluIHMuaGVhZGVycyApIHtcblx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIGksIHMuaGVhZGVyc1sgaSBdICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsb3cgY3VzdG9tIGhlYWRlcnMvbWltZXR5cGVzIGFuZCBlYXJseSBhYm9ydFxuXHRcdGlmICggcy5iZWZvcmVTZW5kICYmXG5cdFx0XHQoIHMuYmVmb3JlU2VuZC5jYWxsKCBjYWxsYmFja0NvbnRleHQsIGpxWEhSLCBzICkgPT09IGZhbHNlIHx8IGNvbXBsZXRlZCApICkge1xuXG5cdFx0XHQvLyBBYm9ydCBpZiBub3QgZG9uZSBhbHJlYWR5IGFuZCByZXR1cm5cblx0XHRcdHJldHVybiBqcVhIUi5hYm9ydCgpO1xuXHRcdH1cblxuXHRcdC8vIEFib3J0aW5nIGlzIG5vIGxvbmdlciBhIGNhbmNlbGxhdGlvblxuXHRcdHN0ckFib3J0ID0gXCJhYm9ydFwiO1xuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja3Mgb24gZGVmZXJyZWRzXG5cdFx0Y29tcGxldGVEZWZlcnJlZC5hZGQoIHMuY29tcGxldGUgKTtcblx0XHRqcVhIUi5kb25lKCBzLnN1Y2Nlc3MgKTtcblx0XHRqcVhIUi5mYWlsKCBzLmVycm9yICk7XG5cblx0XHQvLyBHZXQgdHJhbnNwb3J0XG5cdFx0dHJhbnNwb3J0ID0gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiBubyB0cmFuc3BvcnQsIHdlIGF1dG8tYWJvcnRcblx0XHRpZiAoICF0cmFuc3BvcnQgKSB7XG5cdFx0XHRkb25lKCAtMSwgXCJObyBUcmFuc3BvcnRcIiApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRqcVhIUi5yZWFkeVN0YXRlID0gMTtcblxuXHRcdFx0Ly8gU2VuZCBnbG9iYWwgZXZlbnRcblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhTZW5kXCIsIFsganFYSFIsIHMgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhamF4U2VuZCwgc3RvcCB0aGVyZVxuXHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdHJldHVybiBqcVhIUjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVGltZW91dFxuXHRcdFx0aWYgKCBzLmFzeW5jICYmIHMudGltZW91dCA+IDAgKSB7XG5cdFx0XHRcdHRpbWVvdXRUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRqcVhIUi5hYm9ydCggXCJ0aW1lb3V0XCIgKTtcblx0XHRcdFx0fSwgcy50aW1lb3V0ICk7XG5cdFx0XHR9XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdGNvbXBsZXRlZCA9IGZhbHNlO1xuXHRcdFx0XHR0cmFuc3BvcnQuc2VuZCggcmVxdWVzdEhlYWRlcnMsIGRvbmUgKTtcblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdC8vIFJldGhyb3cgcG9zdC1jb21wbGV0aW9uIGV4Y2VwdGlvbnNcblx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFByb3BhZ2F0ZSBvdGhlcnMgYXMgcmVzdWx0c1xuXHRcdFx0XHRkb25lKCAtMSwgZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGxiYWNrIGZvciB3aGVuIGV2ZXJ5dGhpbmcgaXMgZG9uZVxuXHRcdGZ1bmN0aW9uIGRvbmUoIHN0YXR1cywgbmF0aXZlU3RhdHVzVGV4dCwgcmVzcG9uc2VzLCBoZWFkZXJzICkge1xuXHRcdFx0dmFyIGlzU3VjY2Vzcywgc3VjY2VzcywgZXJyb3IsIHJlc3BvbnNlLCBtb2RpZmllZCxcblx0XHRcdFx0c3RhdHVzVGV4dCA9IG5hdGl2ZVN0YXR1c1RleHQ7XG5cblx0XHRcdC8vIElnbm9yZSByZXBlYXQgaW52b2NhdGlvbnNcblx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNvbXBsZXRlZCA9IHRydWU7XG5cblx0XHRcdC8vIENsZWFyIHRpbWVvdXQgaWYgaXQgZXhpc3RzXG5cdFx0XHRpZiAoIHRpbWVvdXRUaW1lciApIHtcblx0XHRcdFx0d2luZG93LmNsZWFyVGltZW91dCggdGltZW91dFRpbWVyICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIERlcmVmZXJlbmNlIHRyYW5zcG9ydCBmb3IgZWFybHkgZ2FyYmFnZSBjb2xsZWN0aW9uXG5cdFx0XHQvLyAobm8gbWF0dGVyIGhvdyBsb25nIHRoZSBqcVhIUiBvYmplY3Qgd2lsbCBiZSB1c2VkKVxuXHRcdFx0dHJhbnNwb3J0ID0gdW5kZWZpbmVkO1xuXG5cdFx0XHQvLyBDYWNoZSByZXNwb25zZSBoZWFkZXJzXG5cdFx0XHRyZXNwb25zZUhlYWRlcnNTdHJpbmcgPSBoZWFkZXJzIHx8IFwiXCI7XG5cblx0XHRcdC8vIFNldCByZWFkeVN0YXRlXG5cdFx0XHRqcVhIUi5yZWFkeVN0YXRlID0gc3RhdHVzID4gMCA/IDQgOiAwO1xuXG5cdFx0XHQvLyBEZXRlcm1pbmUgaWYgc3VjY2Vzc2Z1bFxuXHRcdFx0aXNTdWNjZXNzID0gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDAgfHwgc3RhdHVzID09PSAzMDQ7XG5cblx0XHRcdC8vIEdldCByZXNwb25zZSBkYXRhXG5cdFx0XHRpZiAoIHJlc3BvbnNlcyApIHtcblx0XHRcdFx0cmVzcG9uc2UgPSBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFVzZSBhIG5vb3AgY29udmVydGVyIGZvciBtaXNzaW5nIHNjcmlwdFxuXHRcdFx0aWYgKCAhaXNTdWNjZXNzICYmIGpRdWVyeS5pbkFycmF5KCBcInNjcmlwdFwiLCBzLmRhdGFUeXBlcyApID4gLTEgKSB7XG5cdFx0XHRcdHMuY29udmVydGVyc1sgXCJ0ZXh0IHNjcmlwdFwiIF0gPSBmdW5jdGlvbigpIHt9O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb252ZXJ0IG5vIG1hdHRlciB3aGF0ICh0aGF0IHdheSByZXNwb25zZVhYWCBmaWVsZHMgYXJlIGFsd2F5cyBzZXQpXG5cdFx0XHRyZXNwb25zZSA9IGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApO1xuXG5cdFx0XHQvLyBJZiBzdWNjZXNzZnVsLCBoYW5kbGUgdHlwZSBjaGFpbmluZ1xuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cblx0XHRcdFx0Ly8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cblx0XHRcdFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJMYXN0LU1vZGlmaWVkXCIgKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcImV0YWdcIiApO1xuXHRcdFx0XHRcdGlmICggbW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGlmIG5vIGNvbnRlbnRcblx0XHRcdFx0aWYgKCBzdGF0dXMgPT09IDIwNCB8fCBzLnR5cGUgPT09IFwiSEVBRFwiICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIm5vY29udGVudFwiO1xuXG5cdFx0XHRcdC8vIGlmIG5vdCBtb2RpZmllZFxuXHRcdFx0XHR9IGVsc2UgaWYgKCBzdGF0dXMgPT09IDMwNCApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub3Rtb2RpZmllZFwiO1xuXG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgZGF0YSwgbGV0J3MgY29udmVydCBpdFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSByZXNwb25zZS5zdGF0ZTtcblx0XHRcdFx0XHRzdWNjZXNzID0gcmVzcG9uc2UuZGF0YTtcblx0XHRcdFx0XHRlcnJvciA9IHJlc3BvbnNlLmVycm9yO1xuXHRcdFx0XHRcdGlzU3VjY2VzcyA9ICFlcnJvcjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBFeHRyYWN0IGVycm9yIGZyb20gc3RhdHVzVGV4dCBhbmQgbm9ybWFsaXplIGZvciBub24tYWJvcnRzXG5cdFx0XHRcdGVycm9yID0gc3RhdHVzVGV4dDtcblx0XHRcdFx0aWYgKCBzdGF0dXMgfHwgIXN0YXR1c1RleHQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwiZXJyb3JcIjtcblx0XHRcdFx0XHRpZiAoIHN0YXR1cyA8IDAgKSB7XG5cdFx0XHRcdFx0XHRzdGF0dXMgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgZGF0YSBmb3IgdGhlIGZha2UgeGhyIG9iamVjdFxuXHRcdFx0anFYSFIuc3RhdHVzID0gc3RhdHVzO1xuXHRcdFx0anFYSFIuc3RhdHVzVGV4dCA9ICggbmF0aXZlU3RhdHVzVGV4dCB8fCBzdGF0dXNUZXh0ICkgKyBcIlwiO1xuXG5cdFx0XHQvLyBTdWNjZXNzL0Vycm9yXG5cdFx0XHRpZiAoIGlzU3VjY2VzcyApIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBzdWNjZXNzLCBzdGF0dXNUZXh0LCBqcVhIUiBdICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQsIGVycm9yIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdGpxWEhSLnN0YXR1c0NvZGUoIHN0YXR1c0NvZGUgKTtcblx0XHRcdHN0YXR1c0NvZGUgPSB1bmRlZmluZWQ7XG5cblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBpc1N1Y2Nlc3MgPyBcImFqYXhTdWNjZXNzXCIgOiBcImFqYXhFcnJvclwiLFxuXHRcdFx0XHRcdFsganFYSFIsIHMsIGlzU3VjY2VzcyA/IHN1Y2Nlc3MgOiBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbXBsZXRlXG5cdFx0XHRjb21wbGV0ZURlZmVycmVkLmZpcmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQgXSApO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4Q29tcGxldGVcIiwgWyBqcVhIUiwgcyBdICk7XG5cblx0XHRcdFx0Ly8gSGFuZGxlIHRoZSBnbG9iYWwgQUpBWCBjb3VudGVyXG5cdFx0XHRcdGlmICggISggLS1qUXVlcnkuYWN0aXZlICkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIFwiYWpheFN0b3BcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpxWEhSO1xuXHR9LFxuXG5cdGdldEpTT046IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIGRhdGEsIGNhbGxiYWNrLCBcImpzb25cIiApO1xuXHR9LFxuXG5cdGdldFNjcmlwdDogZnVuY3Rpb24oIHVybCwgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgdW5kZWZpbmVkLCBjYWxsYmFjaywgXCJzY3JpcHRcIiApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwiZ2V0XCIsIFwicG9zdFwiIF0sIGZ1bmN0aW9uKCBfaSwgbWV0aG9kICkge1xuXHRqUXVlcnlbIG1ldGhvZCBdID0gZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2ssIHR5cGUgKSB7XG5cblx0XHQvLyBTaGlmdCBhcmd1bWVudHMgaWYgZGF0YSBhcmd1bWVudCB3YXMgb21pdHRlZFxuXHRcdGlmICggaXNGdW5jdGlvbiggZGF0YSApICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgY2FsbGJhY2s7XG5cdFx0XHRjYWxsYmFjayA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIFRoZSB1cmwgY2FuIGJlIGFuIG9wdGlvbnMgb2JqZWN0ICh3aGljaCB0aGVuIG11c3QgaGF2ZSAudXJsKVxuXHRcdHJldHVybiBqUXVlcnkuYWpheCggalF1ZXJ5LmV4dGVuZCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cdFx0XHR0eXBlOiBtZXRob2QsXG5cdFx0XHRkYXRhVHlwZTogdHlwZSxcblx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRzdWNjZXNzOiBjYWxsYmFja1xuXHRcdH0sIGpRdWVyeS5pc1BsYWluT2JqZWN0KCB1cmwgKSAmJiB1cmwgKSApO1xuXHR9O1xufSApO1xuXG5qUXVlcnkuYWpheFByZWZpbHRlciggZnVuY3Rpb24oIHMgKSB7XG5cdHZhciBpO1xuXHRmb3IgKCBpIGluIHMuaGVhZGVycyApIHtcblx0XHRpZiAoIGkudG9Mb3dlckNhc2UoKSA9PT0gXCJjb250ZW50LXR5cGVcIiApIHtcblx0XHRcdHMuY29udGVudFR5cGUgPSBzLmhlYWRlcnNbIGkgXSB8fCBcIlwiO1xuXHRcdH1cblx0fVxufSApO1xuXG5cbmpRdWVyeS5fZXZhbFVybCA9IGZ1bmN0aW9uKCB1cmwsIG9wdGlvbnMsIGRvYyApIHtcblx0cmV0dXJuIGpRdWVyeS5hamF4KCB7XG5cdFx0dXJsOiB1cmwsXG5cblx0XHQvLyBNYWtlIHRoaXMgZXhwbGljaXQsIHNpbmNlIHVzZXIgY2FuIG92ZXJyaWRlIHRoaXMgdGhyb3VnaCBhamF4U2V0dXAgKCMxMTI2NClcblx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdGRhdGFUeXBlOiBcInNjcmlwdFwiLFxuXHRcdGNhY2hlOiB0cnVlLFxuXHRcdGFzeW5jOiBmYWxzZSxcblx0XHRnbG9iYWw6IGZhbHNlLFxuXG5cdFx0Ly8gT25seSBldmFsdWF0ZSB0aGUgcmVzcG9uc2UgaWYgaXQgaXMgc3VjY2Vzc2Z1bCAoZ2gtNDEyNilcblx0XHQvLyBkYXRhRmlsdGVyIGlzIG5vdCBpbnZva2VkIGZvciBmYWlsdXJlIHJlc3BvbnNlcywgc28gdXNpbmcgaXQgaW5zdGVhZFxuXHRcdC8vIG9mIHRoZSBkZWZhdWx0IGNvbnZlcnRlciBpcyBrbHVkZ3kgYnV0IGl0IHdvcmtzLlxuXHRcdGNvbnZlcnRlcnM6IHtcblx0XHRcdFwidGV4dCBzY3JpcHRcIjogZnVuY3Rpb24oKSB7fVxuXHRcdH0sXG5cdFx0ZGF0YUZpbHRlcjogZnVuY3Rpb24oIHJlc3BvbnNlICkge1xuXHRcdFx0alF1ZXJ5Lmdsb2JhbEV2YWwoIHJlc3BvbnNlLCBvcHRpb25zLCBkb2MgKTtcblx0XHR9XG5cdH0gKTtcbn07XG5cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHR3cmFwQWxsOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgd3JhcDtcblxuXHRcdGlmICggdGhpc1sgMCBdICkge1xuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRcdGh0bWwgPSBodG1sLmNhbGwoIHRoaXNbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaGUgZWxlbWVudHMgdG8gd3JhcCB0aGUgdGFyZ2V0IGFyb3VuZFxuXHRcdFx0d3JhcCA9IGpRdWVyeSggaHRtbCwgdGhpc1sgMCBdLm93bmVyRG9jdW1lbnQgKS5lcSggMCApLmNsb25lKCB0cnVlICk7XG5cblx0XHRcdGlmICggdGhpc1sgMCBdLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHdyYXAuaW5zZXJ0QmVmb3JlKCB0aGlzWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0d3JhcC5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZWxlbSA9IHRoaXM7XG5cblx0XHRcdFx0d2hpbGUgKCBlbGVtLmZpcnN0RWxlbWVudENoaWxkICkge1xuXHRcdFx0XHRcdGVsZW0gPSBlbGVtLmZpcnN0RWxlbWVudENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGVsZW07XG5cdFx0XHR9ICkuYXBwZW5kKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0d3JhcElubmVyOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRpZiAoIGlzRnVuY3Rpb24oIGh0bWwgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS53cmFwSW5uZXIoIGh0bWwuY2FsbCggdGhpcywgaSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VsZiA9IGpRdWVyeSggdGhpcyApLFxuXHRcdFx0XHRjb250ZW50cyA9IHNlbGYuY29udGVudHMoKTtcblxuXHRcdFx0aWYgKCBjb250ZW50cy5sZW5ndGggKSB7XG5cdFx0XHRcdGNvbnRlbnRzLndyYXBBbGwoIGh0bWwgKTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2VsZi5hcHBlbmQoIGh0bWwgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0d3JhcDogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0dmFyIGh0bWxJc0Z1bmN0aW9uID0gaXNGdW5jdGlvbiggaHRtbCApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRqUXVlcnkoIHRoaXMgKS53cmFwQWxsKCBodG1sSXNGdW5jdGlvbiA/IGh0bWwuY2FsbCggdGhpcywgaSApIDogaHRtbCApO1xuXHRcdH0gKTtcblx0fSxcblxuXHR1bndyYXA6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR0aGlzLnBhcmVudCggc2VsZWN0b3IgKS5ub3QoIFwiYm9keVwiICkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkoIHRoaXMgKS5yZXBsYWNlV2l0aCggdGhpcy5jaGlsZE5vZGVzICk7XG5cdFx0fSApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59ICk7XG5cblxualF1ZXJ5LmV4cHIucHNldWRvcy5oaWRkZW4gPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuICFqUXVlcnkuZXhwci5wc2V1ZG9zLnZpc2libGUoIGVsZW0gKTtcbn07XG5qUXVlcnkuZXhwci5wc2V1ZG9zLnZpc2libGUgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuICEhKCBlbGVtLm9mZnNldFdpZHRoIHx8IGVsZW0ub2Zmc2V0SGVpZ2h0IHx8IGVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKTtcbn07XG5cblxuXG5cbmpRdWVyeS5hamF4U2V0dGluZ3MueGhyID0gZnVuY3Rpb24oKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKTtcblx0fSBjYXRjaCAoIGUgKSB7fVxufTtcblxudmFyIHhoclN1Y2Nlc3NTdGF0dXMgPSB7XG5cblx0XHQvLyBGaWxlIHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIGNvZGUgMCwgYXNzdW1lIDIwMFxuXHRcdDA6IDIwMCxcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0Ly8gIzE0NTA6IHNvbWV0aW1lcyBJRSByZXR1cm5zIDEyMjMgd2hlbiBpdCBzaG91bGQgYmUgMjA0XG5cdFx0MTIyMzogMjA0XG5cdH0sXG5cdHhoclN1cHBvcnRlZCA9IGpRdWVyeS5hamF4U2V0dGluZ3MueGhyKCk7XG5cbnN1cHBvcnQuY29ycyA9ICEheGhyU3VwcG9ydGVkICYmICggXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiB4aHJTdXBwb3J0ZWQgKTtcbnN1cHBvcnQuYWpheCA9IHhoclN1cHBvcnRlZCA9ICEheGhyU3VwcG9ydGVkO1xuXG5qUXVlcnkuYWpheFRyYW5zcG9ydCggZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdHZhciBjYWxsYmFjaywgZXJyb3JDYWxsYmFjaztcblxuXHQvLyBDcm9zcyBkb21haW4gb25seSBhbGxvd2VkIGlmIHN1cHBvcnRlZCB0aHJvdWdoIFhNTEh0dHBSZXF1ZXN0XG5cdGlmICggc3VwcG9ydC5jb3JzIHx8IHhoclN1cHBvcnRlZCAmJiAhb3B0aW9ucy5jcm9zc0RvbWFpbiApIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2VuZDogZnVuY3Rpb24oIGhlYWRlcnMsIGNvbXBsZXRlICkge1xuXHRcdFx0XHR2YXIgaSxcblx0XHRcdFx0XHR4aHIgPSBvcHRpb25zLnhocigpO1xuXG5cdFx0XHRcdHhoci5vcGVuKFxuXHRcdFx0XHRcdG9wdGlvbnMudHlwZSxcblx0XHRcdFx0XHRvcHRpb25zLnVybCxcblx0XHRcdFx0XHRvcHRpb25zLmFzeW5jLFxuXHRcdFx0XHRcdG9wdGlvbnMudXNlcm5hbWUsXG5cdFx0XHRcdFx0b3B0aW9ucy5wYXNzd29yZFxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdC8vIEFwcGx5IGN1c3RvbSBmaWVsZHMgaWYgcHJvdmlkZWRcblx0XHRcdFx0aWYgKCBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRmb3IgKCBpIGluIG9wdGlvbnMueGhyRmllbGRzICkge1xuXHRcdFx0XHRcdFx0eGhyWyBpIF0gPSBvcHRpb25zLnhockZpZWxkc1sgaSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE92ZXJyaWRlIG1pbWUgdHlwZSBpZiBuZWVkZWRcblx0XHRcdFx0aWYgKCBvcHRpb25zLm1pbWVUeXBlICYmIHhoci5vdmVycmlkZU1pbWVUeXBlICkge1xuXHRcdFx0XHRcdHhoci5vdmVycmlkZU1pbWVUeXBlKCBvcHRpb25zLm1pbWVUeXBlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBYLVJlcXVlc3RlZC1XaXRoIGhlYWRlclxuXHRcdFx0XHQvLyBGb3IgY3Jvc3MtZG9tYWluIHJlcXVlc3RzLCBzZWVpbmcgYXMgY29uZGl0aW9ucyBmb3IgYSBwcmVmbGlnaHQgYXJlXG5cdFx0XHRcdC8vIGFraW4gdG8gYSBqaWdzYXcgcHV6emxlLCB3ZSBzaW1wbHkgbmV2ZXIgc2V0IGl0IHRvIGJlIHN1cmUuXG5cdFx0XHRcdC8vIChpdCBjYW4gYWx3YXlzIGJlIHNldCBvbiBhIHBlci1yZXF1ZXN0IGJhc2lzIG9yIGV2ZW4gdXNpbmcgYWpheFNldHVwKVxuXHRcdFx0XHQvLyBGb3Igc2FtZS1kb21haW4gcmVxdWVzdHMsIHdvbid0IGNoYW5nZSBoZWFkZXIgaWYgYWxyZWFkeSBwcm92aWRlZC5cblx0XHRcdFx0aWYgKCAhb3B0aW9ucy5jcm9zc0RvbWFpbiAmJiAhaGVhZGVyc1sgXCJYLVJlcXVlc3RlZC1XaXRoXCIgXSApIHtcblx0XHRcdFx0XHRoZWFkZXJzWyBcIlgtUmVxdWVzdGVkLVdpdGhcIiBdID0gXCJYTUxIdHRwUmVxdWVzdFwiO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU2V0IGhlYWRlcnNcblx0XHRcdFx0Zm9yICggaSBpbiBoZWFkZXJzICkge1xuXHRcdFx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBoZWFkZXJzWyBpIF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBlcnJvckNhbGxiYWNrID0geGhyLm9ubG9hZCA9XG5cdFx0XHRcdFx0XHRcdFx0eGhyLm9uZXJyb3IgPSB4aHIub25hYm9ydCA9IHhoci5vbnRpbWVvdXQgPVxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlID09PSBcImFib3J0XCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0eGhyLmFib3J0KCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IFwiZXJyb3JcIiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0Ly8gT24gYSBtYW51YWwgbmF0aXZlIGFib3J0LCBJRTkgdGhyb3dzXG5cdFx0XHRcdFx0XHRcdFx0Ly8gZXJyb3JzIG9uIGFueSBwcm9wZXJ0eSBhY2Nlc3MgdGhhdCBpcyBub3QgcmVhZHlTdGF0ZVxuXHRcdFx0XHRcdFx0XHRcdGlmICggdHlwZW9mIHhoci5zdGF0dXMgIT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZSggMCwgXCJlcnJvclwiICk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKFxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIEZpbGU6IHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIDA7IHNlZSAjODYwNSwgIzE0MjA3XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXNUZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZShcblx0XHRcdFx0XHRcdFx0XHRcdHhoclN1Y2Nlc3NTdGF0dXNbIHhoci5zdGF0dXMgXSB8fCB4aHIuc3RhdHVzLFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1c1RleHQsXG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBJRTkgaGFzIG5vIFhIUjIgYnV0IHRocm93cyBvbiBiaW5hcnkgKHRyYWMtMTE0MjYpXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBGb3IgWEhSMiBub24tdGV4dCwgbGV0IHRoZSBjYWxsZXIgaGFuZGxlIGl0IChnaC0yNDk4KVxuXHRcdFx0XHRcdFx0XHRcdFx0KCB4aHIucmVzcG9uc2VUeXBlIHx8IFwidGV4dFwiICkgIT09IFwidGV4dFwiICB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0dHlwZW9mIHhoci5yZXNwb25zZVRleHQgIT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IGJpbmFyeTogeGhyLnJlc3BvbnNlIH0gOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IHRleHQ6IHhoci5yZXNwb25zZVRleHQgfSxcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuXHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdC8vIExpc3RlbiB0byBldmVudHNcblx0XHRcdFx0eGhyLm9ubG9hZCA9IGNhbGxiYWNrKCk7XG5cdFx0XHRcdGVycm9yQ2FsbGJhY2sgPSB4aHIub25lcnJvciA9IHhoci5vbnRpbWVvdXQgPSBjYWxsYmFjayggXCJlcnJvclwiICk7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgOSBvbmx5XG5cdFx0XHRcdC8vIFVzZSBvbnJlYWR5c3RhdGVjaGFuZ2UgdG8gcmVwbGFjZSBvbmFib3J0XG5cdFx0XHRcdC8vIHRvIGhhbmRsZSB1bmNhdWdodCBhYm9ydHNcblx0XHRcdFx0aWYgKCB4aHIub25hYm9ydCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHhoci5vbmFib3J0ID0gZXJyb3JDYWxsYmFjaztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHRcdC8vIENoZWNrIHJlYWR5U3RhdGUgYmVmb3JlIHRpbWVvdXQgYXMgaXQgY2hhbmdlc1xuXHRcdFx0XHRcdFx0aWYgKCB4aHIucmVhZHlTdGF0ZSA9PT0gNCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBBbGxvdyBvbmVycm9yIHRvIGJlIGNhbGxlZCBmaXJzdCxcblx0XHRcdFx0XHRcdFx0Ly8gYnV0IHRoYXQgd2lsbCBub3QgaGFuZGxlIGEgbmF0aXZlIGFib3J0XG5cdFx0XHRcdFx0XHRcdC8vIEFsc28sIHNhdmUgZXJyb3JDYWxsYmFjayB0byBhIHZhcmlhYmxlXG5cdFx0XHRcdFx0XHRcdC8vIGFzIHhoci5vbmVycm9yIGNhbm5vdCBiZSBhY2Nlc3NlZFxuXHRcdFx0XHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGVycm9yQ2FsbGJhY2soKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ3JlYXRlIHRoZSBhYm9ydCBjYWxsYmFja1xuXHRcdFx0XHRjYWxsYmFjayA9IGNhbGxiYWNrKCBcImFib3J0XCIgKTtcblxuXHRcdFx0XHR0cnkge1xuXG5cdFx0XHRcdFx0Ly8gRG8gc2VuZCB0aGUgcmVxdWVzdCAodGhpcyBtYXkgcmFpc2UgYW4gZXhjZXB0aW9uKVxuXHRcdFx0XHRcdHhoci5zZW5kKCBvcHRpb25zLmhhc0NvbnRlbnQgJiYgb3B0aW9ucy5kYXRhIHx8IG51bGwgKTtcblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0XHQvLyAjMTQ2ODM6IE9ubHkgcmV0aHJvdyBpZiB0aGlzIGhhc24ndCBiZWVuIG5vdGlmaWVkIGFzIGFuIGVycm9yIHlldFxuXHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFByZXZlbnQgYXV0by1leGVjdXRpb24gb2Ygc2NyaXB0cyB3aGVuIG5vIGV4cGxpY2l0IGRhdGFUeXBlIHdhcyBwcm92aWRlZCAoU2VlIGdoLTI0MzIpXG5qUXVlcnkuYWpheFByZWZpbHRlciggZnVuY3Rpb24oIHMgKSB7XG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRzLmNvbnRlbnRzLnNjcmlwdCA9IGZhbHNlO1xuXHR9XG59ICk7XG5cbi8vIEluc3RhbGwgc2NyaXB0IGRhdGFUeXBlXG5qUXVlcnkuYWpheFNldHVwKCB7XG5cdGFjY2VwdHM6IHtcblx0XHRzY3JpcHQ6IFwidGV4dC9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCBcIiArXG5cdFx0XHRcImFwcGxpY2F0aW9uL2VjbWFzY3JpcHQsIGFwcGxpY2F0aW9uL3gtZWNtYXNjcmlwdFwiXG5cdH0sXG5cdGNvbnRlbnRzOiB7XG5cdFx0c2NyaXB0OiAvXFxiKD86amF2YXxlY21hKXNjcmlwdFxcYi9cblx0fSxcblx0Y29udmVydGVyczoge1xuXHRcdFwidGV4dCBzY3JpcHRcIjogZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHRqUXVlcnkuZ2xvYmFsRXZhbCggdGV4dCApO1xuXHRcdFx0cmV0dXJuIHRleHQ7XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIEhhbmRsZSBjYWNoZSdzIHNwZWNpYWwgY2FzZSBhbmQgY3Jvc3NEb21haW5cbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblx0aWYgKCBzLmNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0cy5jYWNoZSA9IGZhbHNlO1xuXHR9XG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRzLnR5cGUgPSBcIkdFVFwiO1xuXHR9XG59ICk7XG5cbi8vIEJpbmQgc2NyaXB0IHRhZyBoYWNrIHRyYW5zcG9ydFxualF1ZXJ5LmFqYXhUcmFuc3BvcnQoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuXG5cdC8vIFRoaXMgdHJhbnNwb3J0IG9ubHkgZGVhbHMgd2l0aCBjcm9zcyBkb21haW4gb3IgZm9yY2VkLWJ5LWF0dHJzIHJlcXVlc3RzXG5cdGlmICggcy5jcm9zc0RvbWFpbiB8fCBzLnNjcmlwdEF0dHJzICkge1xuXHRcdHZhciBzY3JpcHQsIGNhbGxiYWNrO1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggXywgY29tcGxldGUgKSB7XG5cdFx0XHRcdHNjcmlwdCA9IGpRdWVyeSggXCI8c2NyaXB0PlwiIClcblx0XHRcdFx0XHQuYXR0ciggcy5zY3JpcHRBdHRycyB8fCB7fSApXG5cdFx0XHRcdFx0LnByb3AoIHsgY2hhcnNldDogcy5zY3JpcHRDaGFyc2V0LCBzcmM6IHMudXJsIH0gKVxuXHRcdFx0XHRcdC5vbiggXCJsb2FkIGVycm9yXCIsIGNhbGxiYWNrID0gZnVuY3Rpb24oIGV2dCApIHtcblx0XHRcdFx0XHRcdHNjcmlwdC5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdGNhbGxiYWNrID0gbnVsbDtcblx0XHRcdFx0XHRcdGlmICggZXZ0ICkge1xuXHRcdFx0XHRcdFx0XHRjb21wbGV0ZSggZXZ0LnR5cGUgPT09IFwiZXJyb3JcIiA/IDQwNCA6IDIwMCwgZXZ0LnR5cGUgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0Ly8gVXNlIG5hdGl2ZSBET00gbWFuaXB1bGF0aW9uIHRvIGF2b2lkIG91ciBkb21NYW5pcCBBSkFYIHRyaWNrZXJ5XG5cdFx0XHRcdGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdFsgMCBdICk7XG5cdFx0XHR9LFxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbnZhciBvbGRDYWxsYmFja3MgPSBbXSxcblx0cmpzb25wID0gLyg9KVxcPyg/PSZ8JCl8XFw/XFw/LztcblxuLy8gRGVmYXVsdCBqc29ucCBzZXR0aW5nc1xualF1ZXJ5LmFqYXhTZXR1cCgge1xuXHRqc29ucDogXCJjYWxsYmFja1wiLFxuXHRqc29ucENhbGxiYWNrOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2FsbGJhY2sgPSBvbGRDYWxsYmFja3MucG9wKCkgfHwgKCBqUXVlcnkuZXhwYW5kbyArIFwiX1wiICsgKCBub25jZS5ndWlkKysgKSApO1xuXHRcdHRoaXNbIGNhbGxiYWNrIF0gPSB0cnVlO1xuXHRcdHJldHVybiBjYWxsYmFjaztcblx0fVxufSApO1xuXG4vLyBEZXRlY3QsIG5vcm1hbGl6ZSBvcHRpb25zIGFuZCBpbnN0YWxsIGNhbGxiYWNrcyBmb3IganNvbnAgcmVxdWVzdHNcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcImpzb24ganNvbnBcIiwgZnVuY3Rpb24oIHMsIG9yaWdpbmFsU2V0dGluZ3MsIGpxWEhSICkge1xuXG5cdHZhciBjYWxsYmFja05hbWUsIG92ZXJ3cml0dGVuLCByZXNwb25zZUNvbnRhaW5lcixcblx0XHRqc29uUHJvcCA9IHMuanNvbnAgIT09IGZhbHNlICYmICggcmpzb25wLnRlc3QoIHMudXJsICkgP1xuXHRcdFx0XCJ1cmxcIiA6XG5cdFx0XHR0eXBlb2Ygcy5kYXRhID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCggcy5jb250ZW50VHlwZSB8fCBcIlwiIClcblx0XHRcdFx0XHQuaW5kZXhPZiggXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiApID09PSAwICYmXG5cdFx0XHRcdHJqc29ucC50ZXN0KCBzLmRhdGEgKSAmJiBcImRhdGFcIlxuXHRcdCk7XG5cblx0Ly8gSGFuZGxlIGlmZiB0aGUgZXhwZWN0ZWQgZGF0YSB0eXBlIGlzIFwianNvbnBcIiBvciB3ZSBoYXZlIGEgcGFyYW1ldGVyIHRvIHNldFxuXHRpZiAoIGpzb25Qcm9wIHx8IHMuZGF0YVR5cGVzWyAwIF0gPT09IFwianNvbnBcIiApIHtcblxuXHRcdC8vIEdldCBjYWxsYmFjayBuYW1lLCByZW1lbWJlcmluZyBwcmVleGlzdGluZyB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggaXRcblx0XHRjYWxsYmFja05hbWUgPSBzLmpzb25wQ2FsbGJhY2sgPSBpc0Z1bmN0aW9uKCBzLmpzb25wQ2FsbGJhY2sgKSA/XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2soKSA6XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2s7XG5cblx0XHQvLyBJbnNlcnQgY2FsbGJhY2sgaW50byB1cmwgb3IgZm9ybSBkYXRhXG5cdFx0aWYgKCBqc29uUHJvcCApIHtcblx0XHRcdHNbIGpzb25Qcm9wIF0gPSBzWyBqc29uUHJvcCBdLnJlcGxhY2UoIHJqc29ucCwgXCIkMVwiICsgY2FsbGJhY2tOYW1lICk7XG5cdFx0fSBlbHNlIGlmICggcy5qc29ucCAhPT0gZmFsc2UgKSB7XG5cdFx0XHRzLnVybCArPSAoIHJxdWVyeS50ZXN0KCBzLnVybCApID8gXCImXCIgOiBcIj9cIiApICsgcy5qc29ucCArIFwiPVwiICsgY2FsbGJhY2tOYW1lO1xuXHRcdH1cblxuXHRcdC8vIFVzZSBkYXRhIGNvbnZlcnRlciB0byByZXRyaWV2ZSBqc29uIGFmdGVyIHNjcmlwdCBleGVjdXRpb25cblx0XHRzLmNvbnZlcnRlcnNbIFwic2NyaXB0IGpzb25cIiBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoICFyZXNwb25zZUNvbnRhaW5lciApIHtcblx0XHRcdFx0alF1ZXJ5LmVycm9yKCBjYWxsYmFja05hbWUgKyBcIiB3YXMgbm90IGNhbGxlZFwiICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzcG9uc2VDb250YWluZXJbIDAgXTtcblx0XHR9O1xuXG5cdFx0Ly8gRm9yY2UganNvbiBkYXRhVHlwZVxuXHRcdHMuZGF0YVR5cGVzWyAwIF0gPSBcImpzb25cIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tcblx0XHRvdmVyd3JpdHRlbiA9IHdpbmRvd1sgY2FsbGJhY2tOYW1lIF07XG5cdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBhcmd1bWVudHM7XG5cdFx0fTtcblxuXHRcdC8vIENsZWFuLXVwIGZ1bmN0aW9uIChmaXJlcyBhZnRlciBjb252ZXJ0ZXJzKVxuXHRcdGpxWEhSLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIElmIHByZXZpb3VzIHZhbHVlIGRpZG4ndCBleGlzdCAtIHJlbW92ZSBpdFxuXHRcdFx0aWYgKCBvdmVyd3JpdHRlbiA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRqUXVlcnkoIHdpbmRvdyApLnJlbW92ZVByb3AoIGNhbGxiYWNrTmFtZSApO1xuXG5cdFx0XHQvLyBPdGhlcndpc2UgcmVzdG9yZSBwcmVleGlzdGluZyB2YWx1ZVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IG92ZXJ3cml0dGVuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTYXZlIGJhY2sgYXMgZnJlZVxuXHRcdFx0aWYgKCBzWyBjYWxsYmFja05hbWUgXSApIHtcblxuXHRcdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCByZS11c2luZyB0aGUgb3B0aW9ucyBkb2Vzbid0IHNjcmV3IHRoaW5ncyBhcm91bmRcblx0XHRcdFx0cy5qc29ucENhbGxiYWNrID0gb3JpZ2luYWxTZXR0aW5ncy5qc29ucENhbGxiYWNrO1xuXG5cdFx0XHRcdC8vIFNhdmUgdGhlIGNhbGxiYWNrIG5hbWUgZm9yIGZ1dHVyZSB1c2Vcblx0XHRcdFx0b2xkQ2FsbGJhY2tzLnB1c2goIGNhbGxiYWNrTmFtZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYWxsIGlmIGl0IHdhcyBhIGZ1bmN0aW9uIGFuZCB3ZSBoYXZlIGEgcmVzcG9uc2Vcblx0XHRcdGlmICggcmVzcG9uc2VDb250YWluZXIgJiYgaXNGdW5jdGlvbiggb3ZlcndyaXR0ZW4gKSApIHtcblx0XHRcdFx0b3ZlcndyaXR0ZW4oIHJlc3BvbnNlQ29udGFpbmVyWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBvdmVyd3JpdHRlbiA9IHVuZGVmaW5lZDtcblx0XHR9ICk7XG5cblx0XHQvLyBEZWxlZ2F0ZSB0byBzY3JpcHRcblx0XHRyZXR1cm4gXCJzY3JpcHRcIjtcblx0fVxufSApO1xuXG5cblxuXG4vLyBTdXBwb3J0OiBTYWZhcmkgOCBvbmx5XG4vLyBJbiBTYWZhcmkgOCBkb2N1bWVudHMgY3JlYXRlZCB2aWEgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50XG4vLyBjb2xsYXBzZSBzaWJsaW5nIGZvcm1zOiB0aGUgc2Vjb25kIG9uZSBiZWNvbWVzIGEgY2hpbGQgb2YgdGhlIGZpcnN0IG9uZS5cbi8vIEJlY2F1c2Ugb2YgdGhhdCwgdGhpcyBzZWN1cml0eSBtZWFzdXJlIGhhcyB0byBiZSBkaXNhYmxlZCBpbiBTYWZhcmkgOC5cbi8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzczMzdcbnN1cHBvcnQuY3JlYXRlSFRNTERvY3VtZW50ID0gKCBmdW5jdGlvbigpIHtcblx0dmFyIGJvZHkgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoIFwiXCIgKS5ib2R5O1xuXHRib2R5LmlubmVySFRNTCA9IFwiPGZvcm0+PC9mb3JtPjxmb3JtPjwvZm9ybT5cIjtcblx0cmV0dXJuIGJvZHkuY2hpbGROb2Rlcy5sZW5ndGggPT09IDI7XG59ICkoKTtcblxuXG4vLyBBcmd1bWVudCBcImRhdGFcIiBzaG91bGQgYmUgc3RyaW5nIG9mIGh0bWxcbi8vIGNvbnRleHQgKG9wdGlvbmFsKTogSWYgc3BlY2lmaWVkLCB0aGUgZnJhZ21lbnQgd2lsbCBiZSBjcmVhdGVkIGluIHRoaXMgY29udGV4dCxcbi8vIGRlZmF1bHRzIHRvIGRvY3VtZW50XG4vLyBrZWVwU2NyaXB0cyAob3B0aW9uYWwpOiBJZiB0cnVlLCB3aWxsIGluY2x1ZGUgc2NyaXB0cyBwYXNzZWQgaW4gdGhlIGh0bWwgc3RyaW5nXG5qUXVlcnkucGFyc2VIVE1MID0gZnVuY3Rpb24oIGRhdGEsIGNvbnRleHQsIGtlZXBTY3JpcHRzICkge1xuXHRpZiAoIHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBbXTtcblx0fVxuXHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRrZWVwU2NyaXB0cyA9IGNvbnRleHQ7XG5cdFx0Y29udGV4dCA9IGZhbHNlO1xuXHR9XG5cblx0dmFyIGJhc2UsIHBhcnNlZCwgc2NyaXB0cztcblxuXHRpZiAoICFjb250ZXh0ICkge1xuXG5cdFx0Ly8gU3RvcCBzY3JpcHRzIG9yIGlubGluZSBldmVudCBoYW5kbGVycyBmcm9tIGJlaW5nIGV4ZWN1dGVkIGltbWVkaWF0ZWx5XG5cdFx0Ly8gYnkgdXNpbmcgZG9jdW1lbnQuaW1wbGVtZW50YXRpb25cblx0XHRpZiAoIHN1cHBvcnQuY3JlYXRlSFRNTERvY3VtZW50ICkge1xuXHRcdFx0Y29udGV4dCA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCggXCJcIiApO1xuXG5cdFx0XHQvLyBTZXQgdGhlIGJhc2UgaHJlZiBmb3IgdGhlIGNyZWF0ZWQgZG9jdW1lbnRcblx0XHRcdC8vIHNvIGFueSBwYXJzZWQgZWxlbWVudHMgd2l0aCBVUkxzXG5cdFx0XHQvLyBhcmUgYmFzZWQgb24gdGhlIGRvY3VtZW50J3MgVVJMIChnaC0yOTY1KVxuXHRcdFx0YmFzZSA9IGNvbnRleHQuY3JlYXRlRWxlbWVudCggXCJiYXNlXCIgKTtcblx0XHRcdGJhc2UuaHJlZiA9IGRvY3VtZW50LmxvY2F0aW9uLmhyZWY7XG5cdFx0XHRjb250ZXh0LmhlYWQuYXBwZW5kQ2hpbGQoIGJhc2UgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29udGV4dCA9IGRvY3VtZW50O1xuXHRcdH1cblx0fVxuXG5cdHBhcnNlZCA9IHJzaW5nbGVUYWcuZXhlYyggZGF0YSApO1xuXHRzY3JpcHRzID0gIWtlZXBTY3JpcHRzICYmIFtdO1xuXG5cdC8vIFNpbmdsZSB0YWdcblx0aWYgKCBwYXJzZWQgKSB7XG5cdFx0cmV0dXJuIFsgY29udGV4dC5jcmVhdGVFbGVtZW50KCBwYXJzZWRbIDEgXSApIF07XG5cdH1cblxuXHRwYXJzZWQgPSBidWlsZEZyYWdtZW50KCBbIGRhdGEgXSwgY29udGV4dCwgc2NyaXB0cyApO1xuXG5cdGlmICggc2NyaXB0cyAmJiBzY3JpcHRzLmxlbmd0aCApIHtcblx0XHRqUXVlcnkoIHNjcmlwdHMgKS5yZW1vdmUoKTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnkubWVyZ2UoIFtdLCBwYXJzZWQuY2hpbGROb2RlcyApO1xufTtcblxuXG4vKipcbiAqIExvYWQgYSB1cmwgaW50byBhIHBhZ2VcbiAqL1xualF1ZXJ5LmZuLmxvYWQgPSBmdW5jdGlvbiggdXJsLCBwYXJhbXMsIGNhbGxiYWNrICkge1xuXHR2YXIgc2VsZWN0b3IsIHR5cGUsIHJlc3BvbnNlLFxuXHRcdHNlbGYgPSB0aGlzLFxuXHRcdG9mZiA9IHVybC5pbmRleE9mKCBcIiBcIiApO1xuXG5cdGlmICggb2ZmID4gLTEgKSB7XG5cdFx0c2VsZWN0b3IgPSBzdHJpcEFuZENvbGxhcHNlKCB1cmwuc2xpY2UoIG9mZiApICk7XG5cdFx0dXJsID0gdXJsLnNsaWNlKCAwLCBvZmYgKTtcblx0fVxuXG5cdC8vIElmIGl0J3MgYSBmdW5jdGlvblxuXHRpZiAoIGlzRnVuY3Rpb24oIHBhcmFtcyApICkge1xuXG5cdFx0Ly8gV2UgYXNzdW1lIHRoYXQgaXQncyB0aGUgY2FsbGJhY2tcblx0XHRjYWxsYmFjayA9IHBhcmFtcztcblx0XHRwYXJhbXMgPSB1bmRlZmluZWQ7XG5cblx0Ly8gT3RoZXJ3aXNlLCBidWlsZCBhIHBhcmFtIHN0cmluZ1xuXHR9IGVsc2UgaWYgKCBwYXJhbXMgJiYgdHlwZW9mIHBhcmFtcyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHR0eXBlID0gXCJQT1NUXCI7XG5cdH1cblxuXHQvLyBJZiB3ZSBoYXZlIGVsZW1lbnRzIHRvIG1vZGlmeSwgbWFrZSB0aGUgcmVxdWVzdFxuXHRpZiAoIHNlbGYubGVuZ3RoID4gMCApIHtcblx0XHRqUXVlcnkuYWpheCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cblx0XHRcdC8vIElmIFwidHlwZVwiIHZhcmlhYmxlIGlzIHVuZGVmaW5lZCwgdGhlbiBcIkdFVFwiIG1ldGhvZCB3aWxsIGJlIHVzZWQuXG5cdFx0XHQvLyBNYWtlIHZhbHVlIG9mIHRoaXMgZmllbGQgZXhwbGljaXQgc2luY2Vcblx0XHRcdC8vIHVzZXIgY2FuIG92ZXJyaWRlIGl0IHRocm91Z2ggYWpheFNldHVwIG1ldGhvZFxuXHRcdFx0dHlwZTogdHlwZSB8fCBcIkdFVFwiLFxuXHRcdFx0ZGF0YVR5cGU6IFwiaHRtbFwiLFxuXHRcdFx0ZGF0YTogcGFyYW1zXG5cdFx0fSApLmRvbmUoIGZ1bmN0aW9uKCByZXNwb25zZVRleHQgKSB7XG5cblx0XHRcdC8vIFNhdmUgcmVzcG9uc2UgZm9yIHVzZSBpbiBjb21wbGV0ZSBjYWxsYmFja1xuXHRcdFx0cmVzcG9uc2UgPSBhcmd1bWVudHM7XG5cblx0XHRcdHNlbGYuaHRtbCggc2VsZWN0b3IgP1xuXG5cdFx0XHRcdC8vIElmIGEgc2VsZWN0b3Igd2FzIHNwZWNpZmllZCwgbG9jYXRlIHRoZSByaWdodCBlbGVtZW50cyBpbiBhIGR1bW15IGRpdlxuXHRcdFx0XHQvLyBFeGNsdWRlIHNjcmlwdHMgdG8gYXZvaWQgSUUgJ1Blcm1pc3Npb24gRGVuaWVkJyBlcnJvcnNcblx0XHRcdFx0alF1ZXJ5KCBcIjxkaXY+XCIgKS5hcHBlbmQoIGpRdWVyeS5wYXJzZUhUTUwoIHJlc3BvbnNlVGV4dCApICkuZmluZCggc2VsZWN0b3IgKSA6XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHVzZSB0aGUgZnVsbCByZXN1bHRcblx0XHRcdFx0cmVzcG9uc2VUZXh0ICk7XG5cblx0XHQvLyBJZiB0aGUgcmVxdWVzdCBzdWNjZWVkcywgdGhpcyBmdW5jdGlvbiBnZXRzIFwiZGF0YVwiLCBcInN0YXR1c1wiLCBcImpxWEhSXCJcblx0XHQvLyBidXQgdGhleSBhcmUgaWdub3JlZCBiZWNhdXNlIHJlc3BvbnNlIHdhcyBzZXQgYWJvdmUuXG5cdFx0Ly8gSWYgaXQgZmFpbHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcImpxWEhSXCIsIFwic3RhdHVzXCIsIFwiZXJyb3JcIlxuXHRcdH0gKS5hbHdheXMoIGNhbGxiYWNrICYmIGZ1bmN0aW9uKCBqcVhIUiwgc3RhdHVzICkge1xuXHRcdFx0c2VsZi5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Y2FsbGJhY2suYXBwbHkoIHRoaXMsIHJlc3BvbnNlIHx8IFsganFYSFIucmVzcG9uc2VUZXh0LCBzdGF0dXMsIGpxWEhSIF0gKTtcblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cblxuXG5cbmpRdWVyeS5leHByLnBzZXVkb3MuYW5pbWF0ZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuIGpRdWVyeS5ncmVwKCBqUXVlcnkudGltZXJzLCBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW0gPT09IGZuLmVsZW07XG5cdH0gKS5sZW5ndGg7XG59O1xuXG5cblxuXG5qUXVlcnkub2Zmc2V0ID0ge1xuXHRzZXRPZmZzZXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBpICkge1xuXHRcdHZhciBjdXJQb3NpdGlvbiwgY3VyTGVmdCwgY3VyQ1NTVG9wLCBjdXJUb3AsIGN1ck9mZnNldCwgY3VyQ1NTTGVmdCwgY2FsY3VsYXRlUG9zaXRpb24sXG5cdFx0XHRwb3NpdGlvbiA9IGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApLFxuXHRcdFx0Y3VyRWxlbSA9IGpRdWVyeSggZWxlbSApLFxuXHRcdFx0cHJvcHMgPSB7fTtcblxuXHRcdC8vIFNldCBwb3NpdGlvbiBmaXJzdCwgaW4tY2FzZSB0b3AvbGVmdCBhcmUgc2V0IGV2ZW4gb24gc3RhdGljIGVsZW1cblx0XHRpZiAoIHBvc2l0aW9uID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0ZWxlbS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcblx0XHR9XG5cblx0XHRjdXJPZmZzZXQgPSBjdXJFbGVtLm9mZnNldCgpO1xuXHRcdGN1ckNTU1RvcCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwidG9wXCIgKTtcblx0XHRjdXJDU1NMZWZ0ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJsZWZ0XCIgKTtcblx0XHRjYWxjdWxhdGVQb3NpdGlvbiA9ICggcG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiB8fCBwb3NpdGlvbiA9PT0gXCJmaXhlZFwiICkgJiZcblx0XHRcdCggY3VyQ1NTVG9wICsgY3VyQ1NTTGVmdCApLmluZGV4T2YoIFwiYXV0b1wiICkgPiAtMTtcblxuXHRcdC8vIE5lZWQgdG8gYmUgYWJsZSB0byBjYWxjdWxhdGUgcG9zaXRpb24gaWYgZWl0aGVyXG5cdFx0Ly8gdG9wIG9yIGxlZnQgaXMgYXV0byBhbmQgcG9zaXRpb24gaXMgZWl0aGVyIGFic29sdXRlIG9yIGZpeGVkXG5cdFx0aWYgKCBjYWxjdWxhdGVQb3NpdGlvbiApIHtcblx0XHRcdGN1clBvc2l0aW9uID0gY3VyRWxlbS5wb3NpdGlvbigpO1xuXHRcdFx0Y3VyVG9wID0gY3VyUG9zaXRpb24udG9wO1xuXHRcdFx0Y3VyTGVmdCA9IGN1clBvc2l0aW9uLmxlZnQ7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VyVG9wID0gcGFyc2VGbG9hdCggY3VyQ1NTVG9wICkgfHwgMDtcblx0XHRcdGN1ckxlZnQgPSBwYXJzZUZsb2F0KCBjdXJDU1NMZWZ0ICkgfHwgMDtcblx0XHR9XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIG9wdGlvbnMgKSApIHtcblxuXHRcdFx0Ly8gVXNlIGpRdWVyeS5leHRlbmQgaGVyZSB0byBhbGxvdyBtb2RpZmljYXRpb24gb2YgY29vcmRpbmF0ZXMgYXJndW1lbnQgKGdoLTE4NDgpXG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucy5jYWxsKCBlbGVtLCBpLCBqUXVlcnkuZXh0ZW5kKCB7fSwgY3VyT2Zmc2V0ICkgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdGlvbnMudG9wICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy50b3AgPSAoIG9wdGlvbnMudG9wIC0gY3VyT2Zmc2V0LnRvcCApICsgY3VyVG9wO1xuXHRcdH1cblx0XHRpZiAoIG9wdGlvbnMubGVmdCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMubGVmdCA9ICggb3B0aW9ucy5sZWZ0IC0gY3VyT2Zmc2V0LmxlZnQgKSArIGN1ckxlZnQ7XG5cdFx0fVxuXG5cdFx0aWYgKCBcInVzaW5nXCIgaW4gb3B0aW9ucyApIHtcblx0XHRcdG9wdGlvbnMudXNpbmcuY2FsbCggZWxlbSwgcHJvcHMgKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBwcm9wcy50b3AgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdHByb3BzLnRvcCArPSBcInB4XCI7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHR5cGVvZiBwcm9wcy5sZWZ0ID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHRwcm9wcy5sZWZ0ICs9IFwicHhcIjtcblx0XHRcdH1cblx0XHRcdGN1ckVsZW0uY3NzKCBwcm9wcyApO1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdC8vIG9mZnNldCgpIHJlbGF0ZXMgYW4gZWxlbWVudCdzIGJvcmRlciBib3ggdG8gdGhlIGRvY3VtZW50IG9yaWdpblxuXHRvZmZzZXQ6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG5cdFx0Ly8gUHJlc2VydmUgY2hhaW5pbmcgZm9yIHNldHRlclxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiBvcHRpb25zID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHR0aGlzIDpcblx0XHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0XHRqUXVlcnkub2Zmc2V0LnNldE9mZnNldCggdGhpcywgb3B0aW9ucywgaSApO1xuXHRcdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0dmFyIHJlY3QsIHdpbixcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF07XG5cblx0XHRpZiAoICFlbGVtICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiB6ZXJvcyBmb3IgZGlzY29ubmVjdGVkIGFuZCBoaWRkZW4gKGRpc3BsYXk6IG5vbmUpIGVsZW1lbnRzIChnaC0yMzEwKVxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHRcdC8vIFJ1bm5pbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGFcblx0XHQvLyBkaXNjb25uZWN0ZWQgbm9kZSBpbiBJRSB0aHJvd3MgYW4gZXJyb3Jcblx0XHRpZiAoICFlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cdFx0fVxuXG5cdFx0Ly8gR2V0IGRvY3VtZW50LXJlbGF0aXZlIHBvc2l0aW9uIGJ5IGFkZGluZyB2aWV3cG9ydCBzY3JvbGwgdG8gdmlld3BvcnQtcmVsYXRpdmUgZ0JDUlxuXHRcdHJlY3QgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdHdpbiA9IGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldztcblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiByZWN0LnRvcCArIHdpbi5wYWdlWU9mZnNldCxcblx0XHRcdGxlZnQ6IHJlY3QubGVmdCArIHdpbi5wYWdlWE9mZnNldFxuXHRcdH07XG5cdH0sXG5cblx0Ly8gcG9zaXRpb24oKSByZWxhdGVzIGFuIGVsZW1lbnQncyBtYXJnaW4gYm94IHRvIGl0cyBvZmZzZXQgcGFyZW50J3MgcGFkZGluZyBib3hcblx0Ly8gVGhpcyBjb3JyZXNwb25kcyB0byB0aGUgYmVoYXZpb3Igb2YgQ1NTIGFic29sdXRlIHBvc2l0aW9uaW5nXG5cdHBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoICF0aGlzWyAwIF0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIG9mZnNldFBhcmVudCwgb2Zmc2V0LCBkb2MsXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdLFxuXHRcdFx0cGFyZW50T2Zmc2V0ID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcblxuXHRcdC8vIHBvc2l0aW9uOmZpeGVkIGVsZW1lbnRzIGFyZSBvZmZzZXQgZnJvbSB0aGUgdmlld3BvcnQsIHdoaWNoIGl0c2VsZiBhbHdheXMgaGFzIHplcm8gb2Zmc2V0XG5cdFx0aWYgKCBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSA9PT0gXCJmaXhlZFwiICkge1xuXG5cdFx0XHQvLyBBc3N1bWUgcG9zaXRpb246Zml4ZWQgaW1wbGllcyBhdmFpbGFiaWxpdHkgb2YgZ2V0Qm91bmRpbmdDbGllbnRSZWN0XG5cdFx0XHRvZmZzZXQgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdG9mZnNldCA9IHRoaXMub2Zmc2V0KCk7XG5cblx0XHRcdC8vIEFjY291bnQgZm9yIHRoZSAqcmVhbCogb2Zmc2V0IHBhcmVudCwgd2hpY2ggY2FuIGJlIHRoZSBkb2N1bWVudCBvciBpdHMgcm9vdCBlbGVtZW50XG5cdFx0XHQvLyB3aGVuIGEgc3RhdGljYWxseSBwb3NpdGlvbmVkIGVsZW1lbnQgaXMgaWRlbnRpZmllZFxuXHRcdFx0ZG9jID0gZWxlbS5vd25lckRvY3VtZW50O1xuXHRcdFx0b2Zmc2V0UGFyZW50ID0gZWxlbS5vZmZzZXRQYXJlbnQgfHwgZG9jLmRvY3VtZW50RWxlbWVudDtcblx0XHRcdHdoaWxlICggb2Zmc2V0UGFyZW50ICYmXG5cdFx0XHRcdCggb2Zmc2V0UGFyZW50ID09PSBkb2MuYm9keSB8fCBvZmZzZXRQYXJlbnQgPT09IGRvYy5kb2N1bWVudEVsZW1lbnQgKSAmJlxuXHRcdFx0XHRqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwicG9zaXRpb25cIiApID09PSBcInN0YXRpY1wiICkge1xuXG5cdFx0XHRcdG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBvZmZzZXRQYXJlbnQgJiYgb2Zmc2V0UGFyZW50ICE9PSBlbGVtICYmIG9mZnNldFBhcmVudC5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHQvLyBJbmNvcnBvcmF0ZSBib3JkZXJzIGludG8gaXRzIG9mZnNldCwgc2luY2UgdGhleSBhcmUgb3V0c2lkZSBpdHMgY29udGVudCBvcmlnaW5cblx0XHRcdFx0cGFyZW50T2Zmc2V0ID0galF1ZXJ5KCBvZmZzZXRQYXJlbnQgKS5vZmZzZXQoKTtcblx0XHRcdFx0cGFyZW50T2Zmc2V0LnRvcCArPSBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwiYm9yZGVyVG9wV2lkdGhcIiwgdHJ1ZSApO1xuXHRcdFx0XHRwYXJlbnRPZmZzZXQubGVmdCArPSBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwiYm9yZGVyTGVmdFdpZHRoXCIsIHRydWUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTdWJ0cmFjdCBwYXJlbnQgb2Zmc2V0cyBhbmQgZWxlbWVudCBtYXJnaW5zXG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogb2Zmc2V0LnRvcCAtIHBhcmVudE9mZnNldC50b3AgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpblRvcFwiLCB0cnVlICksXG5cdFx0XHRsZWZ0OiBvZmZzZXQubGVmdCAtIHBhcmVudE9mZnNldC5sZWZ0IC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5MZWZ0XCIsIHRydWUgKVxuXHRcdH07XG5cdH0sXG5cblx0Ly8gVGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gZG9jdW1lbnRFbGVtZW50IGluIHRoZSBmb2xsb3dpbmcgY2FzZXM6XG5cdC8vIDEpIEZvciB0aGUgZWxlbWVudCBpbnNpZGUgdGhlIGlmcmFtZSB3aXRob3V0IG9mZnNldFBhcmVudCwgdGhpcyBtZXRob2Qgd2lsbCByZXR1cm5cblx0Ly8gICAgZG9jdW1lbnRFbGVtZW50IG9mIHRoZSBwYXJlbnQgd2luZG93XG5cdC8vIDIpIEZvciB0aGUgaGlkZGVuIG9yIGRldGFjaGVkIGVsZW1lbnRcblx0Ly8gMykgRm9yIGJvZHkgb3IgaHRtbCBlbGVtZW50LCBpLmUuIGluIGNhc2Ugb2YgdGhlIGh0bWwgbm9kZSAtIGl0IHdpbGwgcmV0dXJuIGl0c2VsZlxuXHQvL1xuXHQvLyBidXQgdGhvc2UgZXhjZXB0aW9ucyB3ZXJlIG5ldmVyIHByZXNlbnRlZCBhcyBhIHJlYWwgbGlmZSB1c2UtY2FzZXNcblx0Ly8gYW5kIG1pZ2h0IGJlIGNvbnNpZGVyZWQgYXMgbW9yZSBwcmVmZXJhYmxlIHJlc3VsdHMuXG5cdC8vXG5cdC8vIFRoaXMgbG9naWMsIGhvd2V2ZXIsIGlzIG5vdCBndWFyYW50ZWVkIGFuZCBjYW4gY2hhbmdlIGF0IGFueSBwb2ludCBpbiB0aGUgZnV0dXJlXG5cdG9mZnNldFBhcmVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudDtcblxuXHRcdFx0d2hpbGUgKCBvZmZzZXRQYXJlbnQgJiYgalF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcInBvc2l0aW9uXCIgKSA9PT0gXCJzdGF0aWNcIiApIHtcblx0XHRcdFx0b2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50Lm9mZnNldFBhcmVudDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG9mZnNldFBhcmVudCB8fCBkb2N1bWVudEVsZW1lbnQ7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbi8vIENyZWF0ZSBzY3JvbGxMZWZ0IGFuZCBzY3JvbGxUb3AgbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgc2Nyb2xsTGVmdDogXCJwYWdlWE9mZnNldFwiLCBzY3JvbGxUb3A6IFwicGFnZVlPZmZzZXRcIiB9LCBmdW5jdGlvbiggbWV0aG9kLCBwcm9wICkge1xuXHR2YXIgdG9wID0gXCJwYWdlWU9mZnNldFwiID09PSBwcm9wO1xuXG5cdGpRdWVyeS5mblsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdmFsICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBtZXRob2QsIHZhbCApIHtcblxuXHRcdFx0Ly8gQ29hbGVzY2UgZG9jdW1lbnRzIGFuZCB3aW5kb3dzXG5cdFx0XHR2YXIgd2luO1xuXHRcdFx0aWYgKCBpc1dpbmRvdyggZWxlbSApICkge1xuXHRcdFx0XHR3aW4gPSBlbGVtO1xuXHRcdFx0fSBlbHNlIGlmICggZWxlbS5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0d2luID0gZWxlbS5kZWZhdWx0Vmlldztcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHdpbiA/IHdpblsgcHJvcCBdIDogZWxlbVsgbWV0aG9kIF07XG5cdFx0XHR9XG5cblx0XHRcdGlmICggd2luICkge1xuXHRcdFx0XHR3aW4uc2Nyb2xsVG8oXG5cdFx0XHRcdFx0IXRvcCA/IHZhbCA6IHdpbi5wYWdlWE9mZnNldCxcblx0XHRcdFx0XHR0b3AgPyB2YWwgOiB3aW4ucGFnZVlPZmZzZXRcblx0XHRcdFx0KTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbVsgbWV0aG9kIF0gPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSwgbWV0aG9kLCB2YWwsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fTtcbn0gKTtcblxuLy8gU3VwcG9ydDogU2FmYXJpIDw9NyAtIDkuMSwgQ2hyb21lIDw9MzcgLSA0OVxuLy8gQWRkIHRoZSB0b3AvbGVmdCBjc3NIb29rcyB1c2luZyBqUXVlcnkuZm4ucG9zaXRpb25cbi8vIFdlYmtpdCBidWc6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yOTA4NFxuLy8gQmxpbmsgYnVnOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD01ODkzNDdcbi8vIGdldENvbXB1dGVkU3R5bGUgcmV0dXJucyBwZXJjZW50IHdoZW4gc3BlY2lmaWVkIGZvciB0b3AvbGVmdC9ib3R0b20vcmlnaHQ7XG4vLyByYXRoZXIgdGhhbiBtYWtlIHRoZSBjc3MgbW9kdWxlIGRlcGVuZCBvbiB0aGUgb2Zmc2V0IG1vZHVsZSwganVzdCBjaGVjayBmb3IgaXQgaGVyZVxualF1ZXJ5LmVhY2goIFsgXCJ0b3BcIiwgXCJsZWZ0XCIgXSwgZnVuY3Rpb24oIF9pLCBwcm9wICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByb3AgXSA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5waXhlbFBvc2l0aW9uLFxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGNvbXB1dGVkID0gY3VyQ1NTKCBlbGVtLCBwcm9wICk7XG5cblx0XHRcdFx0Ly8gSWYgY3VyQ1NTIHJldHVybnMgcGVyY2VudGFnZSwgZmFsbGJhY2sgdG8gb2Zmc2V0XG5cdFx0XHRcdHJldHVybiBybnVtbm9ucHgudGVzdCggY29tcHV0ZWQgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5KCBlbGVtICkucG9zaXRpb24oKVsgcHJvcCBdICsgXCJweFwiIDpcblx0XHRcdFx0XHRjb21wdXRlZDtcblx0XHRcdH1cblx0XHR9XG5cdCk7XG59ICk7XG5cblxuLy8gQ3JlYXRlIGlubmVySGVpZ2h0LCBpbm5lcldpZHRoLCBoZWlnaHQsIHdpZHRoLCBvdXRlckhlaWdodCBhbmQgb3V0ZXJXaWR0aCBtZXRob2RzXG5qUXVlcnkuZWFjaCggeyBIZWlnaHQ6IFwiaGVpZ2h0XCIsIFdpZHRoOiBcIndpZHRoXCIgfSwgZnVuY3Rpb24oIG5hbWUsIHR5cGUgKSB7XG5cdGpRdWVyeS5lYWNoKCB7IHBhZGRpbmc6IFwiaW5uZXJcIiArIG5hbWUsIGNvbnRlbnQ6IHR5cGUsIFwiXCI6IFwib3V0ZXJcIiArIG5hbWUgfSxcblx0XHRmdW5jdGlvbiggZGVmYXVsdEV4dHJhLCBmdW5jTmFtZSApIHtcblxuXHRcdC8vIE1hcmdpbiBpcyBvbmx5IGZvciBvdXRlckhlaWdodCwgb3V0ZXJXaWR0aFxuXHRcdGpRdWVyeS5mblsgZnVuY05hbWUgXSA9IGZ1bmN0aW9uKCBtYXJnaW4sIHZhbHVlICkge1xuXHRcdFx0dmFyIGNoYWluYWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggJiYgKCBkZWZhdWx0RXh0cmEgfHwgdHlwZW9mIG1hcmdpbiAhPT0gXCJib29sZWFuXCIgKSxcblx0XHRcdFx0ZXh0cmEgPSBkZWZhdWx0RXh0cmEgfHwgKCBtYXJnaW4gPT09IHRydWUgfHwgdmFsdWUgPT09IHRydWUgPyBcIm1hcmdpblwiIDogXCJib3JkZXJcIiApO1xuXG5cdFx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgdHlwZSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBkb2M7XG5cblx0XHRcdFx0aWYgKCBpc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRcdFx0Ly8gJCggd2luZG93ICkub3V0ZXJXaWR0aC9IZWlnaHQgcmV0dXJuIHcvaCBpbmNsdWRpbmcgc2Nyb2xsYmFycyAoZ2gtMTcyOSlcblx0XHRcdFx0XHRyZXR1cm4gZnVuY05hbWUuaW5kZXhPZiggXCJvdXRlclwiICkgPT09IDAgP1xuXHRcdFx0XHRcdFx0ZWxlbVsgXCJpbm5lclwiICsgbmFtZSBdIDpcblx0XHRcdFx0XHRcdGVsZW0uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50WyBcImNsaWVudFwiICsgbmFtZSBdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gR2V0IGRvY3VtZW50IHdpZHRoIG9yIGhlaWdodFxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0ZG9jID0gZWxlbS5kb2N1bWVudEVsZW1lbnQ7XG5cblx0XHRcdFx0XHQvLyBFaXRoZXIgc2Nyb2xsW1dpZHRoL0hlaWdodF0gb3Igb2Zmc2V0W1dpZHRoL0hlaWdodF0gb3IgY2xpZW50W1dpZHRoL0hlaWdodF0sXG5cdFx0XHRcdFx0Ly8gd2hpY2hldmVyIGlzIGdyZWF0ZXN0XG5cdFx0XHRcdFx0cmV0dXJuIE1hdGgubWF4KFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcInNjcm9sbFwiICsgbmFtZSBdLCBkb2NbIFwic2Nyb2xsXCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwib2Zmc2V0XCIgKyBuYW1lIF0sIGRvY1sgXCJvZmZzZXRcIiArIG5hbWUgXSxcblx0XHRcdFx0XHRcdGRvY1sgXCJjbGllbnRcIiArIG5hbWUgXVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cblx0XHRcdFx0XHQvLyBHZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50LCByZXF1ZXN0aW5nIGJ1dCBub3QgZm9yY2luZyBwYXJzZUZsb2F0XG5cdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgdHlwZSwgZXh0cmEgKSA6XG5cblx0XHRcdFx0XHQvLyBTZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCB0eXBlLCB2YWx1ZSwgZXh0cmEgKTtcblx0XHRcdH0sIHR5cGUsIGNoYWluYWJsZSA/IG1hcmdpbiA6IHVuZGVmaW5lZCwgY2hhaW5hYmxlICk7XG5cdFx0fTtcblx0fSApO1xufSApO1xuXG5cbmpRdWVyeS5lYWNoKCBbXG5cdFwiYWpheFN0YXJ0XCIsXG5cdFwiYWpheFN0b3BcIixcblx0XCJhamF4Q29tcGxldGVcIixcblx0XCJhamF4RXJyb3JcIixcblx0XCJhamF4U3VjY2Vzc1wiLFxuXHRcImFqYXhTZW5kXCJcbl0sIGZ1bmN0aW9uKCBfaSwgdHlwZSApIHtcblx0alF1ZXJ5LmZuWyB0eXBlIF0gPSBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGUsIGZuICk7XG5cdH07XG59ICk7XG5cblxuXG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHRiaW5kOiBmdW5jdGlvbiggdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgbnVsbCwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5iaW5kOiBmdW5jdGlvbiggdHlwZXMsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9mZiggdHlwZXMsIG51bGwsIGZuICk7XG5cdH0sXG5cblx0ZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGZuICkge1xuXG5cdFx0Ly8gKCBuYW1lc3BhY2UgKSBvciAoIHNlbGVjdG9yLCB0eXBlcyBbLCBmbl0gKVxuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID9cblx0XHRcdHRoaXMub2ZmKCBzZWxlY3RvciwgXCIqKlwiICkgOlxuXHRcdFx0dGhpcy5vZmYoIHR5cGVzLCBzZWxlY3RvciB8fCBcIioqXCIsIGZuICk7XG5cdH0sXG5cblx0aG92ZXI6IGZ1bmN0aW9uKCBmbk92ZXIsIGZuT3V0ICkge1xuXHRcdHJldHVybiB0aGlzLm1vdXNlZW50ZXIoIGZuT3ZlciApLm1vdXNlbGVhdmUoIGZuT3V0IHx8IGZuT3ZlciApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCAoIFwiYmx1ciBmb2N1cyBmb2N1c2luIGZvY3Vzb3V0IHJlc2l6ZSBzY3JvbGwgY2xpY2sgZGJsY2xpY2sgXCIgK1xuXHRcIm1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIFwiICtcblx0XCJjaGFuZ2Ugc2VsZWN0IHN1Ym1pdCBrZXlkb3duIGtleXByZXNzIGtleXVwIGNvbnRleHRtZW51XCIgKS5zcGxpdCggXCIgXCIgKSxcblx0ZnVuY3Rpb24oIF9pLCBuYW1lICkge1xuXG5cdFx0Ly8gSGFuZGxlIGV2ZW50IGJpbmRpbmdcblx0XHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBkYXRhLCBmbiApIHtcblx0XHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMCA/XG5cdFx0XHRcdHRoaXMub24oIG5hbWUsIG51bGwsIGRhdGEsIGZuICkgOlxuXHRcdFx0XHR0aGlzLnRyaWdnZXIoIG5hbWUgKTtcblx0XHR9O1xuXHR9ICk7XG5cblxuXG5cbi8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seVxuLy8gTWFrZSBzdXJlIHdlIHRyaW0gQk9NIGFuZCBOQlNQXG52YXIgcnRyaW0gPSAvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2c7XG5cbi8vIEJpbmQgYSBmdW5jdGlvbiB0byBhIGNvbnRleHQsIG9wdGlvbmFsbHkgcGFydGlhbGx5IGFwcGx5aW5nIGFueVxuLy8gYXJndW1lbnRzLlxuLy8galF1ZXJ5LnByb3h5IGlzIGRlcHJlY2F0ZWQgdG8gcHJvbW90ZSBzdGFuZGFyZHMgKHNwZWNpZmljYWxseSBGdW5jdGlvbiNiaW5kKVxuLy8gSG93ZXZlciwgaXQgaXMgbm90IHNsYXRlZCBmb3IgcmVtb3ZhbCBhbnkgdGltZSBzb29uXG5qUXVlcnkucHJveHkgPSBmdW5jdGlvbiggZm4sIGNvbnRleHQgKSB7XG5cdHZhciB0bXAsIGFyZ3MsIHByb3h5O1xuXG5cdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0dG1wID0gZm5bIGNvbnRleHQgXTtcblx0XHRjb250ZXh0ID0gZm47XG5cdFx0Zm4gPSB0bXA7XG5cdH1cblxuXHQvLyBRdWljayBjaGVjayB0byBkZXRlcm1pbmUgaWYgdGFyZ2V0IGlzIGNhbGxhYmxlLCBpbiB0aGUgc3BlY1xuXHQvLyB0aGlzIHRocm93cyBhIFR5cGVFcnJvciwgYnV0IHdlIHdpbGwganVzdCByZXR1cm4gdW5kZWZpbmVkLlxuXHRpZiAoICFpc0Z1bmN0aW9uKCBmbiApICkge1xuXHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdH1cblxuXHQvLyBTaW11bGF0ZWQgYmluZFxuXHRhcmdzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzLCAyICk7XG5cdHByb3h5ID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGZuLmFwcGx5KCBjb250ZXh0IHx8IHRoaXMsIGFyZ3MuY29uY2F0KCBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSApICk7XG5cdH07XG5cblx0Ly8gU2V0IHRoZSBndWlkIG9mIHVuaXF1ZSBoYW5kbGVyIHRvIHRoZSBzYW1lIG9mIG9yaWdpbmFsIGhhbmRsZXIsIHNvIGl0IGNhbiBiZSByZW1vdmVkXG5cdHByb3h5Lmd1aWQgPSBmbi5ndWlkID0gZm4uZ3VpZCB8fCBqUXVlcnkuZ3VpZCsrO1xuXG5cdHJldHVybiBwcm94eTtcbn07XG5cbmpRdWVyeS5ob2xkUmVhZHkgPSBmdW5jdGlvbiggaG9sZCApIHtcblx0aWYgKCBob2xkICkge1xuXHRcdGpRdWVyeS5yZWFkeVdhaXQrKztcblx0fSBlbHNlIHtcblx0XHRqUXVlcnkucmVhZHkoIHRydWUgKTtcblx0fVxufTtcbmpRdWVyeS5pc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbmpRdWVyeS5wYXJzZUpTT04gPSBKU09OLnBhcnNlO1xualF1ZXJ5Lm5vZGVOYW1lID0gbm9kZU5hbWU7XG5qUXVlcnkuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5qUXVlcnkuaXNXaW5kb3cgPSBpc1dpbmRvdztcbmpRdWVyeS5jYW1lbENhc2UgPSBjYW1lbENhc2U7XG5qUXVlcnkudHlwZSA9IHRvVHlwZTtcblxualF1ZXJ5Lm5vdyA9IERhdGUubm93O1xuXG5qUXVlcnkuaXNOdW1lcmljID0gZnVuY3Rpb24oIG9iaiApIHtcblxuXHQvLyBBcyBvZiBqUXVlcnkgMy4wLCBpc051bWVyaWMgaXMgbGltaXRlZCB0b1xuXHQvLyBzdHJpbmdzIGFuZCBudW1iZXJzIChwcmltaXRpdmVzIG9yIG9iamVjdHMpXG5cdC8vIHRoYXQgY2FuIGJlIGNvZXJjZWQgdG8gZmluaXRlIG51bWJlcnMgKGdoLTI2NjIpXG5cdHZhciB0eXBlID0galF1ZXJ5LnR5cGUoIG9iaiApO1xuXHRyZXR1cm4gKCB0eXBlID09PSBcIm51bWJlclwiIHx8IHR5cGUgPT09IFwic3RyaW5nXCIgKSAmJlxuXG5cdFx0Ly8gcGFyc2VGbG9hdCBOYU5zIG51bWVyaWMtY2FzdCBmYWxzZSBwb3NpdGl2ZXMgKFwiXCIpXG5cdFx0Ly8gLi4uYnV0IG1pc2ludGVycHJldHMgbGVhZGluZy1udW1iZXIgc3RyaW5ncywgcGFydGljdWxhcmx5IGhleCBsaXRlcmFscyAoXCIweC4uLlwiKVxuXHRcdC8vIHN1YnRyYWN0aW9uIGZvcmNlcyBpbmZpbml0aWVzIHRvIE5hTlxuXHRcdCFpc05hTiggb2JqIC0gcGFyc2VGbG9hdCggb2JqICkgKTtcbn07XG5cbmpRdWVyeS50cmltID0gZnVuY3Rpb24oIHRleHQgKSB7XG5cdHJldHVybiB0ZXh0ID09IG51bGwgP1xuXHRcdFwiXCIgOlxuXHRcdCggdGV4dCArIFwiXCIgKS5yZXBsYWNlKCBydHJpbSwgXCJcIiApO1xufTtcblxuXG5cbi8vIFJlZ2lzdGVyIGFzIGEgbmFtZWQgQU1EIG1vZHVsZSwgc2luY2UgalF1ZXJ5IGNhbiBiZSBjb25jYXRlbmF0ZWQgd2l0aCBvdGhlclxuLy8gZmlsZXMgdGhhdCBtYXkgdXNlIGRlZmluZSwgYnV0IG5vdCB2aWEgYSBwcm9wZXIgY29uY2F0ZW5hdGlvbiBzY3JpcHQgdGhhdFxuLy8gdW5kZXJzdGFuZHMgYW5vbnltb3VzIEFNRCBtb2R1bGVzLiBBIG5hbWVkIEFNRCBpcyBzYWZlc3QgYW5kIG1vc3Qgcm9idXN0XG4vLyB3YXkgdG8gcmVnaXN0ZXIuIExvd2VyY2FzZSBqcXVlcnkgaXMgdXNlZCBiZWNhdXNlIEFNRCBtb2R1bGUgbmFtZXMgYXJlXG4vLyBkZXJpdmVkIGZyb20gZmlsZSBuYW1lcywgYW5kIGpRdWVyeSBpcyBub3JtYWxseSBkZWxpdmVyZWQgaW4gYSBsb3dlcmNhc2Vcbi8vIGZpbGUgbmFtZS4gRG8gdGhpcyBhZnRlciBjcmVhdGluZyB0aGUgZ2xvYmFsIHNvIHRoYXQgaWYgYW4gQU1EIG1vZHVsZSB3YW50c1xuLy8gdG8gY2FsbCBub0NvbmZsaWN0IHRvIGhpZGUgdGhpcyB2ZXJzaW9uIG9mIGpRdWVyeSwgaXQgd2lsbCB3b3JrLlxuXG4vLyBOb3RlIHRoYXQgZm9yIG1heGltdW0gcG9ydGFiaWxpdHksIGxpYnJhcmllcyB0aGF0IGFyZSBub3QgalF1ZXJ5IHNob3VsZFxuLy8gZGVjbGFyZSB0aGVtc2VsdmVzIGFzIGFub255bW91cyBtb2R1bGVzLCBhbmQgYXZvaWQgc2V0dGluZyBhIGdsb2JhbCBpZiBhblxuLy8gQU1EIGxvYWRlciBpcyBwcmVzZW50LiBqUXVlcnkgaXMgYSBzcGVjaWFsIGNhc2UuIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWVcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcmJ1cmtlL3JlcXVpcmVqcy93aWtpL1VwZGF0aW5nLWV4aXN0aW5nLWxpYnJhcmllcyN3aWtpLWFub25cblxuaWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcblx0ZGVmaW5lKCBcImpxdWVyeVwiLCBbXSwgZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGpRdWVyeTtcblx0fSApO1xufVxuXG5cblxuXG52YXJcblxuXHQvLyBNYXAgb3ZlciBqUXVlcnkgaW4gY2FzZSBvZiBvdmVyd3JpdGVcblx0X2pRdWVyeSA9IHdpbmRvdy5qUXVlcnksXG5cblx0Ly8gTWFwIG92ZXIgdGhlICQgaW4gY2FzZSBvZiBvdmVyd3JpdGVcblx0XyQgPSB3aW5kb3cuJDtcblxualF1ZXJ5Lm5vQ29uZmxpY3QgPSBmdW5jdGlvbiggZGVlcCApIHtcblx0aWYgKCB3aW5kb3cuJCA9PT0galF1ZXJ5ICkge1xuXHRcdHdpbmRvdy4kID0gXyQ7XG5cdH1cblxuXHRpZiAoIGRlZXAgJiYgd2luZG93LmpRdWVyeSA9PT0galF1ZXJ5ICkge1xuXHRcdHdpbmRvdy5qUXVlcnkgPSBfalF1ZXJ5O1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeTtcbn07XG5cbi8vIEV4cG9zZSBqUXVlcnkgYW5kICQgaWRlbnRpZmllcnMsIGV2ZW4gaW4gQU1EXG4vLyAoIzcxMDIjY29tbWVudDoxMCwgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnkvcHVsbC81NTcpXG4vLyBhbmQgQ29tbW9uSlMgZm9yIGJyb3dzZXIgZW11bGF0b3JzICgjMTM1NjYpXG5pZiAoIHR5cGVvZiBub0dsb2JhbCA9PT0gXCJ1bmRlZmluZWRcIiApIHtcblx0d2luZG93LmpRdWVyeSA9IHdpbmRvdy4kID0galF1ZXJ5O1xufVxuXG5cblxuXG5yZXR1cm4galF1ZXJ5O1xufSApO1xuIl0sIm1hcHBpbmdzIjoiOztBQUFBOzs7Ozs7Ozs7Ozs7O0FBYUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUNBO0FBTUE7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTFGQTtBQUNBO0FBNEZBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFPQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFyS0E7QUFDQTtBQXVLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFhQTtBQWJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUF1QkE7QUF2QkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQWdDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFwQ0E7QUF1Q0E7QUF2Q0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBK0NBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBekRBO0FBQUE7QUFnRUE7QUFDQTtBQWpFQTtBQW9FQTtBQXBFQTtBQXdFQTtBQUdBO0FBR0E7QUFDQTtBQS9FQTtBQXFGQTtBQUNBO0FBR0E7QUFHQTtBQTVGQTtBQWdHQTtBQWhHQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQTZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQWJBO0FBNUdBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFxSUE7QUFySUE7QUFBQTtBQTBJQTtBQUNBO0FBM0lBO0FBNklBO0FBRUE7QUFHQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUEzSkE7QUE4SkE7QUFDQTtBQS9KQTtBQWlLQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQS9LQTtBQWtMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF2TEE7QUEyTEE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFoQkE7QUFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFFQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFJQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7OztBQU1BO0FBQ0E7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBSUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFLQTtBQUNBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQUE7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FBRUE7QUFLQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7O0FBR0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFJQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFPQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBSUE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBSUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFFQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUlBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFKQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFHQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQS9FQTtBQWtGQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFJQTtBQU1BO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQVFBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBSUE7QUFHQTtBQUNBO0FBQ0E7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFNQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBRUE7QUFDQTtBQUdBO0FBS0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW5PQTtBQXNPQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFJQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQWpOQTtBQTVVQTtBQWlpQkE7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFNQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFNQTtBQU5BO0FBYUE7QUFiQTtBQW9CQTtBQUdBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU9BO0FBQ0E7QUFDQTtBQVRBO0FBV0E7QUFDQTtBQVpBO0FBY0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUtBO0FBRUE7QUFBQTtBQU9BO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBUUE7QUFSQTtBQVdBO0FBWEE7QUFDQTtBQWFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7QUFTQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFHQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQU9BO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFFQTtBQUVBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUtBO0FBekNBO0FBZ0RBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBRUE7QUFDQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQU1BO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFPQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQUVBO0FBQ0E7QUFLQTtBQUVBO0FBQ0E7QUFHQTtBQTlFQTtBQUNBO0FBZ0ZBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBdERBO0FBd0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0JBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBREE7QUFJQTtBQUpBO0FBT0E7QUFQQTtBQVVBO0FBVkE7QUFhQTtBQWJBO0FBZ0JBO0FBaEJBO0FBbUJBO0FBbkJBO0FBc0JBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWhFQTtBQW1FQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBakhBO0FBQ0E7QUFtSEE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUpBO0FBQUE7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBT0E7QUFFQTtBQUNBO0FBRUE7QUFPQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUF6RUE7QUE0RUE7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFXQTtBQUNBO0FBVUE7QUFTQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXBOQTtBQVpBO0FBQ0E7QUFvT0E7QUFDQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFHQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBSEE7QUFNQTtBQU5BO0FBU0E7QUFUQTtBQUFBO0FBYUE7QUFiQTtBQWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF6VkE7QUE4VkE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBM0JBO0FBOEJBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFJQTtBQUNBO0FBQUE7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBOUlBO0FBZ0pBO0FBRUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFyQkE7QUF3QkE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFoRkE7QUFvRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUEvREE7QUFrRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQWpFQTtBQW1FQTtBQUVBO0FBR0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRkE7QUFHQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBUkE7QUFBQTtBQUFBO0FBYUE7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbkJBO0FBcUJBO0FBRUE7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBVkE7QUFhQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBRUE7QUFFQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFKQTtBQUFBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBS0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBdkJBO0FBeUJBO0FBRUE7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFIQTtBQUtBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQTdDQTtBQWdEQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUF0REE7QUFoV0E7QUFvYUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBTEE7QUFDQTtBQVdBO0FBQ0E7QUFDQTtBQW5FQTtBQXFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUlBO0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFJQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFuQ0E7QUFDQTtBQXNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUExREE7QUE2REE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBdEJBO0FBd0JBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFNQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQWxCQTtBQW9CQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBM0NBO0FBK0NBO0FBR0E7QUFDQTtBQUNBO0FBTEE7QUFRQTtBQVJBO0FBQ0E7QUFXQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFPQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQS9FQTtBQWtGQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUF6SUE7QUE0SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBakRBO0FBbURBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFaQTtBQWNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUlBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUxBO0FBQUE7QUFPQTtBQUFBO0FBQUE7QUFBQTtBQVBBO0FBU0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBUUE7QUFSQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFKQTtBQUFBO0FBQUE7QUFBQTtBQWFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFTQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQURBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFwQkE7QUF1QkE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU1BO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFoS0E7QUFtS0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQUxBO0FBU0E7QUFUQTtBQUFBO0FBdUJBO0FBQ0E7QUFBQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFqRUE7QUFtRUE7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQWRBO0FBQ0E7QUFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQXRCQTtBQUNBO0FBeUJBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUF6Q0E7QUE0Q0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFsQ0E7QUFEQTtBQXdDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFVQTtBQUNBO0FBRUE7QUFLQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFNQTtBQUNBO0FBQ0E7QUFSQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQUxBO0FBQUE7QUFBQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUExQ0E7QUE0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBeENBO0FBM0NBO0FBQ0E7QUFzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUVBO0FBQ0E7QUFDQTtBQUhBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFyQ0E7QUFDQTtBQXVDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBSkE7QUFDQTtBQU9BO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFHQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQU9BO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXhIQTtBQTJIQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFOQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBTEE7QUFVQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFJQTtBQUdBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFZQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFYQTtBQURBO0FBZ0JBO0FBQ0E7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBNUVBO0FBQ0E7QUErRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQVZBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFLQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFZQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBdkJBO0FBREE7QUE0QkE7QUFDQTtBQUNBO0FBRkE7QUE3REE7QUFvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXZCQTtBQXlCQTtBQUNBO0FBQ0E7QUFZQTtBQUNBO0FBTUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTdKQTtBQW1LQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWxFQTtBQXFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWkE7QUFjQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBTUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBR0E7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUF0RUE7QUFmQTtBQURBO0FBQ0E7QUEyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBRUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBS0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFGQTtBQU1BO0FBQ0E7QUFsS0E7QUFzS0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFaQTtBQWlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUF4QkE7QUEwQkE7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBTUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQUE7QUFJQTtBQUNBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBbENBO0FBc0NBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFPQTtBQVBBO0FBQUE7QUFDQTtBQVVBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUEzQkE7QUE4QkE7QUE5QkE7QUFpQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBTUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQVpBO0FBZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQTlEQTtBQW9FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFIQTtBQU1BO0FBTkE7QUFBQTtBQVVBO0FBVkE7QUFhQTtBQWJBO0FBZ0JBO0FBaEJBO0FBbUJBO0FBbkJBO0FBc0JBO0FBdEJBO0FBeUJBO0FBekJBO0FBNEJBO0FBNUJBO0FBK0JBO0FBL0JBO0FBa0NBO0FBbENBO0FBd0NBO0FBeENBO0FBQUE7QUE0Q0E7QUE1Q0E7QUErQ0E7QUEvQ0E7QUFBQTtBQW1EQTtBQW5EQTtBQXNEQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQXRFQTtBQUNBO0FBQ0E7QUF3RUE7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFsaUJBO0FBcWlCQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBbEJBO0FBb0JBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBL0RBO0FBQ0E7QUFrRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQVBBO0FBQUE7QUFXQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUdBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbklBO0FBcUlBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQURBO0FBSUE7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBUkE7QUFDQTtBQWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFwQkE7QUFzQkE7QUFDQTtBQUtBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFDQTtBQVNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQVNBO0FBRUE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOzs7OztBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFXQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBR0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBdkRBO0FBMERBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXhHQTtBQUNBO0FBMkdBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUtBO0FBQ0E7QUFDQTtBQUdBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBdEJBO0FBeUJBO0FBS0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQU1BO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUlBO0FBR0E7QUFIQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/jquery/dist/jquery.js\n");

/***/ }),

/***/ "./node_modules/lodash.debounce/index.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash.debounce/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n/** Used as references for various `Number` constants. */\n\nvar NAN = 0 / 0;\n/** `Object#toString` result references. */\n\nvar symbolTag = '[object Symbol]';\n/** Used to match leading and trailing whitespace. */\n\nvar reTrim = /^\\s+|\\s+$/g;\n/** Used to detect bad signed hexadecimal string values. */\n\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n/** Used to detect binary string values. */\n\nvar reIsBinary = /^0b[01]+$/i;\n/** Used to detect octal string values. */\n\nvar reIsOctal = /^0o[0-7]+$/i;\n/** Built-in method references without a dependency on `root`. */\n\nvar freeParseInt = parseInt;\n/** Detect free variable `global` from Node.js. */\n\nvar freeGlobal = (typeof global === \"undefined\" ? \"undefined\" : _typeof(global)) == 'object' && global && global.Object === Object && global;\n/** Detect free variable `self`. */\n\nvar freeSelf = (typeof self === \"undefined\" ? \"undefined\" : _typeof(self)) == 'object' && self && self.Object === Object && self;\n/** Used as a reference to the global object. */\n\nvar root = freeGlobal || freeSelf || Function('return this')();\n/** Used for built-in method references. */\n\nvar objectProto = Object.prototype;\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\n\nvar objectToString = objectProto.toString;\n/* Built-in method references for those with the same name as other `lodash` methods. */\n\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\n\nvar now = function now() {\n  return root.Date.now();\n};\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\n\n\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n\n  wait = toNumber(wait) || 0;\n\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time; // Start the timer for the trailing edge.\n\n    timerId = setTimeout(timerExpired, wait); // Invoke the leading edge.\n\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        result = wait - timeSinceLastCall;\n    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime; // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n\n    return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;\n  }\n\n  function timerExpired() {\n    var time = now();\n\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    } // Restart the timer.\n\n\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined; // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n\n    return result;\n  }\n\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\n\n\nfunction isObject(value) {\n  var type = _typeof(value);\n\n  return !!value && (type == 'object' || type == 'function');\n}\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\n\n\nfunction isObjectLike(value) {\n  return !!value && _typeof(value) == 'object';\n}\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\n\n\nfunction isSymbol(value) {\n  return _typeof(value) == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;\n}\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\n\n\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n\n  if (isSymbol(value)) {\n    return NAN;\n  }\n\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? other + '' : other;\n  }\n\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;\n}\n\nmodule.exports = debounce;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbG9kYXNoLmRlYm91bmNlL2luZGV4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC5kZWJvdW5jZS9pbmRleC5qcz9mN2ZlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogbG9kYXNoIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcXVlcnkub3JnLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqL1xuXG4vKiogVXNlZCBhcyB0aGUgYFR5cGVFcnJvcmAgbWVzc2FnZSBmb3IgXCJGdW5jdGlvbnNcIiBtZXRob2RzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTkFOID0gMCAvIDA7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZS4gKi9cbnZhciByZVRyaW0gPSAvXlxccyt8XFxzKyQvZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJhZCBzaWduZWQgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmFkSGV4ID0gL15bLStdMHhbMC05YS1mXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiaW5hcnkgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmluYXJ5ID0gL14wYlswMV0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb2N0YWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzT2N0YWwgPSAvXjBvWzAtN10rJC9pO1xuXG4vKiogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgd2l0aG91dCBhIGRlcGVuZGVuY3kgb24gYHJvb3RgLiAqL1xudmFyIGZyZWVQYXJzZUludCA9IHBhcnNlSW50O1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXgsXG4gICAgbmF0aXZlTWluID0gTWF0aC5taW47XG5cbi8qKlxuICogR2V0cyB0aGUgdGltZXN0YW1wIG9mIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlXG4gKiB0aGUgVW5peCBlcG9jaCAoMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgRGF0ZVxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXN0YW1wLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmRlZmVyKGZ1bmN0aW9uKHN0YW1wKSB7XG4gKiAgIGNvbnNvbGUubG9nKF8ubm93KCkgLSBzdGFtcCk7XG4gKiB9LCBfLm5vdygpKTtcbiAqIC8vID0+IExvZ3MgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXQgdG9vayBmb3IgdGhlIGRlZmVycmVkIGludm9jYXRpb24uXG4gKi9cbnZhciBub3cgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHJvb3QuRGF0ZS5ub3coKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGRlYm91bmNlZCBmdW5jdGlvbiB0aGF0IGRlbGF5cyBpbnZva2luZyBgZnVuY2AgdW50aWwgYWZ0ZXIgYHdhaXRgXG4gKiBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgdGhlIGRlYm91bmNlZCBmdW5jdGlvbiB3YXNcbiAqIGludm9rZWQuIFRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgIG1ldGhvZCB0byBjYW5jZWxcbiAqIGRlbGF5ZWQgYGZ1bmNgIGludm9jYXRpb25zIGFuZCBhIGBmbHVzaGAgbWV0aG9kIHRvIGltbWVkaWF0ZWx5IGludm9rZSB0aGVtLlxuICogUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2Agc2hvdWxkIGJlIGludm9rZWQgb24gdGhlXG4gKiBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGAgdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkXG4gKiB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uLiBTdWJzZXF1ZW50XG4gKiBjYWxscyB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYFxuICogaW52b2NhdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG4gKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIGRlYm91bmNlZCBmdW5jdGlvblxuICogaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICpcbiAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZFxuICogdW50aWwgdG8gdGhlIG5leHQgdGljaywgc2ltaWxhciB0byBgc2V0VGltZW91dGAgd2l0aCBhIHRpbWVvdXQgb2YgYDBgLlxuICpcbiAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKVxuICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy5kZWJvdW5jZWAgYW5kIGBfLnRocm90dGxlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlYm91bmNlLlxuICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9ZmFsc2VdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heFdhaXRdXG4gKiAgVGhlIG1heGltdW0gdGltZSBgZnVuY2AgaXMgYWxsb3dlZCB0byBiZSBkZWxheWVkIGJlZm9yZSBpdCdzIGludm9rZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGRlYm91bmNlZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gQXZvaWQgY29zdGx5IGNhbGN1bGF0aW9ucyB3aGlsZSB0aGUgd2luZG93IHNpemUgaXMgaW4gZmx1eC5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdyZXNpemUnLCBfLmRlYm91bmNlKGNhbGN1bGF0ZUxheW91dCwgMTUwKSk7XG4gKlxuICogLy8gSW52b2tlIGBzZW5kTWFpbGAgd2hlbiBjbGlja2VkLCBkZWJvdW5jaW5nIHN1YnNlcXVlbnQgY2FsbHMuXG4gKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgXy5kZWJvdW5jZShzZW5kTWFpbCwgMzAwLCB7XG4gKiAgICdsZWFkaW5nJzogdHJ1ZSxcbiAqICAgJ3RyYWlsaW5nJzogZmFsc2VcbiAqIH0pKTtcbiAqXG4gKiAvLyBFbnN1cmUgYGJhdGNoTG9nYCBpcyBpbnZva2VkIG9uY2UgYWZ0ZXIgMSBzZWNvbmQgb2YgZGVib3VuY2VkIGNhbGxzLlxuICogdmFyIGRlYm91bmNlZCA9IF8uZGVib3VuY2UoYmF0Y2hMb2csIDI1MCwgeyAnbWF4V2FpdCc6IDEwMDAgfSk7XG4gKiB2YXIgc291cmNlID0gbmV3IEV2ZW50U291cmNlKCcvc3RyZWFtJyk7XG4gKiBqUXVlcnkoc291cmNlKS5vbignbWVzc2FnZScsIGRlYm91bmNlZCk7XG4gKlxuICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyBkZWJvdW5jZWQgaW52b2NhdGlvbi5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIGRlYm91bmNlZC5jYW5jZWwpO1xuICovXG5mdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gIHZhciBsYXN0QXJncyxcbiAgICAgIGxhc3RUaGlzLFxuICAgICAgbWF4V2FpdCxcbiAgICAgIHJlc3VsdCxcbiAgICAgIHRpbWVySWQsXG4gICAgICBsYXN0Q2FsbFRpbWUsXG4gICAgICBsYXN0SW52b2tlVGltZSA9IDAsXG4gICAgICBsZWFkaW5nID0gZmFsc2UsXG4gICAgICBtYXhpbmcgPSBmYWxzZSxcbiAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB3YWl0ID0gdG9OdW1iZXIod2FpdCkgfHwgMDtcbiAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgbGVhZGluZyA9ICEhb3B0aW9ucy5sZWFkaW5nO1xuICAgIG1heGluZyA9ICdtYXhXYWl0JyBpbiBvcHRpb25zO1xuICAgIG1heFdhaXQgPSBtYXhpbmcgPyBuYXRpdmVNYXgodG9OdW1iZXIob3B0aW9ucy5tYXhXYWl0KSB8fCAwLCB3YWl0KSA6IG1heFdhaXQ7XG4gICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUZ1bmModGltZSkge1xuICAgIHZhciBhcmdzID0gbGFzdEFyZ3MsXG4gICAgICAgIHRoaXNBcmcgPSBsYXN0VGhpcztcblxuICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxlYWRpbmdFZGdlKHRpbWUpIHtcbiAgICAvLyBSZXNldCBhbnkgYG1heFdhaXRgIHRpbWVyLlxuICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICAvLyBTdGFydCB0aGUgdGltZXIgZm9yIHRoZSB0cmFpbGluZyBlZGdlLlxuICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgLy8gSW52b2tlIHRoZSBsZWFkaW5nIGVkZ2UuXG4gICAgcmV0dXJuIGxlYWRpbmcgPyBpbnZva2VGdW5jKHRpbWUpIDogcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtYWluaW5nV2FpdCh0aW1lKSB7XG4gICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZSxcbiAgICAgICAgcmVzdWx0ID0gd2FpdCAtIHRpbWVTaW5jZUxhc3RDYWxsO1xuXG4gICAgcmV0dXJuIG1heGluZyA/IG5hdGl2ZU1pbihyZXN1bHQsIG1heFdhaXQgLSB0aW1lU2luY2VMYXN0SW52b2tlKSA6IHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3VsZEludm9rZSh0aW1lKSB7XG4gICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZTtcblxuICAgIC8vIEVpdGhlciB0aGlzIGlzIHRoZSBmaXJzdCBjYWxsLCBhY3Rpdml0eSBoYXMgc3RvcHBlZCBhbmQgd2UncmUgYXQgdGhlXG4gICAgLy8gdHJhaWxpbmcgZWRnZSwgdGhlIHN5c3RlbSB0aW1lIGhhcyBnb25lIGJhY2t3YXJkcyBhbmQgd2UncmUgdHJlYXRpbmdcbiAgICAvLyBpdCBhcyB0aGUgdHJhaWxpbmcgZWRnZSwgb3Igd2UndmUgaGl0IHRoZSBgbWF4V2FpdGAgbGltaXQuXG4gICAgcmV0dXJuIChsYXN0Q2FsbFRpbWUgPT09IHVuZGVmaW5lZCB8fCAodGltZVNpbmNlTGFzdENhbGwgPj0gd2FpdCkgfHxcbiAgICAgICh0aW1lU2luY2VMYXN0Q2FsbCA8IDApIHx8IChtYXhpbmcgJiYgdGltZVNpbmNlTGFzdEludm9rZSA+PSBtYXhXYWl0KSk7XG4gIH1cblxuICBmdW5jdGlvbiB0aW1lckV4cGlyZWQoKSB7XG4gICAgdmFyIHRpbWUgPSBub3coKTtcbiAgICBpZiAoc2hvdWxkSW52b2tlKHRpbWUpKSB7XG4gICAgICByZXR1cm4gdHJhaWxpbmdFZGdlKHRpbWUpO1xuICAgIH1cbiAgICAvLyBSZXN0YXJ0IHRoZSB0aW1lci5cbiAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHJlbWFpbmluZ1dhaXQodGltZSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhaWxpbmdFZGdlKHRpbWUpIHtcbiAgICB0aW1lcklkID0gdW5kZWZpbmVkO1xuXG4gICAgLy8gT25seSBpbnZva2UgaWYgd2UgaGF2ZSBgbGFzdEFyZ3NgIHdoaWNoIG1lYW5zIGBmdW5jYCBoYXMgYmVlblxuICAgIC8vIGRlYm91bmNlZCBhdCBsZWFzdCBvbmNlLlxuICAgIGlmICh0cmFpbGluZyAmJiBsYXN0QXJncykge1xuICAgICAgcmV0dXJuIGludm9rZUZ1bmModGltZSk7XG4gICAgfVxuICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICBpZiAodGltZXJJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgfVxuICAgIGxhc3RJbnZva2VUaW1lID0gMDtcbiAgICBsYXN0QXJncyA9IGxhc3RDYWxsVGltZSA9IGxhc3RUaGlzID0gdGltZXJJZCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgIHJldHVybiB0aW1lcklkID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiB0cmFpbGluZ0VkZ2Uobm93KCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVib3VuY2VkKCkge1xuICAgIHZhciB0aW1lID0gbm93KCksXG4gICAgICAgIGlzSW52b2tpbmcgPSBzaG91bGRJbnZva2UodGltZSk7XG5cbiAgICBsYXN0QXJncyA9IGFyZ3VtZW50cztcbiAgICBsYXN0VGhpcyA9IHRoaXM7XG4gICAgbGFzdENhbGxUaW1lID0gdGltZTtcblxuICAgIGlmIChpc0ludm9raW5nKSB7XG4gICAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBsZWFkaW5nRWRnZShsYXN0Q2FsbFRpbWUpO1xuICAgICAgfVxuICAgICAgaWYgKG1heGluZykge1xuICAgICAgICAvLyBIYW5kbGUgaW52b2NhdGlvbnMgaW4gYSB0aWdodCBsb29wLlxuICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgICByZXR1cm4gaW52b2tlRnVuYyhsYXN0Q2FsbFRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGRlYm91bmNlZC5jYW5jZWwgPSBjYW5jZWw7XG4gIGRlYm91bmNlZC5mbHVzaCA9IGZsdXNoO1xuICByZXR1cm4gZGVib3VuY2VkO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b051bWJlcigzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xuICogLy8gPT4gSW5maW5pdHlcbiAqXG4gKiBfLnRvTnVtYmVyKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gTkFOO1xuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgdmFsdWUgPSBpc09iamVjdChvdGhlcikgPyAob3RoZXIgKyAnJykgOiBvdGhlcjtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiArdmFsdWU7XG4gIH1cbiAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHJlVHJpbSwgJycpO1xuICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xuICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcbiAgICA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOClcbiAgICA6IChyZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkZWJvdW5jZTtcbiJdLCJtYXBwaW5ncyI6Ijs7QUFBQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUVBOzs7Ozs7QUFLQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNEQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXlCQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBd0JBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBO0FBQ0E7QUFFQTtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lodash.debounce/index.js\n");

/***/ }),

/***/ "./node_modules/lodash.throttle/index.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash.throttle/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n/** Used as references for various `Number` constants. */\n\nvar NAN = 0 / 0;\n/** `Object#toString` result references. */\n\nvar symbolTag = '[object Symbol]';\n/** Used to match leading and trailing whitespace. */\n\nvar reTrim = /^\\s+|\\s+$/g;\n/** Used to detect bad signed hexadecimal string values. */\n\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n/** Used to detect binary string values. */\n\nvar reIsBinary = /^0b[01]+$/i;\n/** Used to detect octal string values. */\n\nvar reIsOctal = /^0o[0-7]+$/i;\n/** Built-in method references without a dependency on `root`. */\n\nvar freeParseInt = parseInt;\n/** Detect free variable `global` from Node.js. */\n\nvar freeGlobal = (typeof global === \"undefined\" ? \"undefined\" : _typeof(global)) == 'object' && global && global.Object === Object && global;\n/** Detect free variable `self`. */\n\nvar freeSelf = (typeof self === \"undefined\" ? \"undefined\" : _typeof(self)) == 'object' && self && self.Object === Object && self;\n/** Used as a reference to the global object. */\n\nvar root = freeGlobal || freeSelf || Function('return this')();\n/** Used for built-in method references. */\n\nvar objectProto = Object.prototype;\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\n\nvar objectToString = objectProto.toString;\n/* Built-in method references for those with the same name as other `lodash` methods. */\n\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\n\nvar now = function now() {\n  return root.Date.now();\n};\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\n\n\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n\n  wait = toNumber(wait) || 0;\n\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time; // Start the timer for the trailing edge.\n\n    timerId = setTimeout(timerExpired, wait); // Invoke the leading edge.\n\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        result = wait - timeSinceLastCall;\n    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime; // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n\n    return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;\n  }\n\n  function timerExpired() {\n    var time = now();\n\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    } // Restart the timer.\n\n\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined; // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n\n    return result;\n  }\n\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n/**\n * Creates a throttled function that only invokes `func` at most once per\n * every `wait` milliseconds. The throttled function comes with a `cancel`\n * method to cancel delayed `func` invocations and a `flush` method to\n * immediately invoke them. Provide `options` to indicate whether `func`\n * should be invoked on the leading and/or trailing edge of the `wait`\n * timeout. The `func` is invoked with the last arguments provided to the\n * throttled function. Subsequent calls to the throttled function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the throttled function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.throttle` and `_.debounce`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to throttle.\n * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=true]\n *  Specify invoking on the leading edge of the timeout.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new throttled function.\n * @example\n *\n * // Avoid excessively updating the position while scrolling.\n * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n *\n * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n * jQuery(element).on('click', throttled);\n *\n * // Cancel the trailing throttled invocation.\n * jQuery(window).on('popstate', throttled.cancel);\n */\n\n\nfunction throttle(func, wait, options) {\n  var leading = true,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n\n  if (isObject(options)) {\n    leading = 'leading' in options ? !!options.leading : leading;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  return debounce(func, wait, {\n    'leading': leading,\n    'maxWait': wait,\n    'trailing': trailing\n  });\n}\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\n\n\nfunction isObject(value) {\n  var type = _typeof(value);\n\n  return !!value && (type == 'object' || type == 'function');\n}\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\n\n\nfunction isObjectLike(value) {\n  return !!value && _typeof(value) == 'object';\n}\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\n\n\nfunction isSymbol(value) {\n  return _typeof(value) == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;\n}\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\n\n\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n\n  if (isSymbol(value)) {\n    return NAN;\n  }\n\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? other + '' : other;\n  }\n\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;\n}\n\nmodule.exports = throttle;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbG9kYXNoLnRocm90dGxlL2luZGV4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC50aHJvdHRsZS9pbmRleC5qcz84NGEyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogbG9kYXNoIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcXVlcnkub3JnLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqL1xuXG4vKiogVXNlZCBhcyB0aGUgYFR5cGVFcnJvcmAgbWVzc2FnZSBmb3IgXCJGdW5jdGlvbnNcIiBtZXRob2RzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTkFOID0gMCAvIDA7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZS4gKi9cbnZhciByZVRyaW0gPSAvXlxccyt8XFxzKyQvZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJhZCBzaWduZWQgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmFkSGV4ID0gL15bLStdMHhbMC05YS1mXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiaW5hcnkgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmluYXJ5ID0gL14wYlswMV0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb2N0YWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzT2N0YWwgPSAvXjBvWzAtN10rJC9pO1xuXG4vKiogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgd2l0aG91dCBhIGRlcGVuZGVuY3kgb24gYHJvb3RgLiAqL1xudmFyIGZyZWVQYXJzZUludCA9IHBhcnNlSW50O1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXgsXG4gICAgbmF0aXZlTWluID0gTWF0aC5taW47XG5cbi8qKlxuICogR2V0cyB0aGUgdGltZXN0YW1wIG9mIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlXG4gKiB0aGUgVW5peCBlcG9jaCAoMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgRGF0ZVxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXN0YW1wLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmRlZmVyKGZ1bmN0aW9uKHN0YW1wKSB7XG4gKiAgIGNvbnNvbGUubG9nKF8ubm93KCkgLSBzdGFtcCk7XG4gKiB9LCBfLm5vdygpKTtcbiAqIC8vID0+IExvZ3MgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXQgdG9vayBmb3IgdGhlIGRlZmVycmVkIGludm9jYXRpb24uXG4gKi9cbnZhciBub3cgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHJvb3QuRGF0ZS5ub3coKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGRlYm91bmNlZCBmdW5jdGlvbiB0aGF0IGRlbGF5cyBpbnZva2luZyBgZnVuY2AgdW50aWwgYWZ0ZXIgYHdhaXRgXG4gKiBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgdGhlIGRlYm91bmNlZCBmdW5jdGlvbiB3YXNcbiAqIGludm9rZWQuIFRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgIG1ldGhvZCB0byBjYW5jZWxcbiAqIGRlbGF5ZWQgYGZ1bmNgIGludm9jYXRpb25zIGFuZCBhIGBmbHVzaGAgbWV0aG9kIHRvIGltbWVkaWF0ZWx5IGludm9rZSB0aGVtLlxuICogUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2Agc2hvdWxkIGJlIGludm9rZWQgb24gdGhlXG4gKiBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGAgdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkXG4gKiB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uLiBTdWJzZXF1ZW50XG4gKiBjYWxscyB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYFxuICogaW52b2NhdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG4gKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIGRlYm91bmNlZCBmdW5jdGlvblxuICogaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICpcbiAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZFxuICogdW50aWwgdG8gdGhlIG5leHQgdGljaywgc2ltaWxhciB0byBgc2V0VGltZW91dGAgd2l0aCBhIHRpbWVvdXQgb2YgYDBgLlxuICpcbiAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKVxuICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy5kZWJvdW5jZWAgYW5kIGBfLnRocm90dGxlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlYm91bmNlLlxuICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9ZmFsc2VdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heFdhaXRdXG4gKiAgVGhlIG1heGltdW0gdGltZSBgZnVuY2AgaXMgYWxsb3dlZCB0byBiZSBkZWxheWVkIGJlZm9yZSBpdCdzIGludm9rZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGRlYm91bmNlZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gQXZvaWQgY29zdGx5IGNhbGN1bGF0aW9ucyB3aGlsZSB0aGUgd2luZG93IHNpemUgaXMgaW4gZmx1eC5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdyZXNpemUnLCBfLmRlYm91bmNlKGNhbGN1bGF0ZUxheW91dCwgMTUwKSk7XG4gKlxuICogLy8gSW52b2tlIGBzZW5kTWFpbGAgd2hlbiBjbGlja2VkLCBkZWJvdW5jaW5nIHN1YnNlcXVlbnQgY2FsbHMuXG4gKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgXy5kZWJvdW5jZShzZW5kTWFpbCwgMzAwLCB7XG4gKiAgICdsZWFkaW5nJzogdHJ1ZSxcbiAqICAgJ3RyYWlsaW5nJzogZmFsc2VcbiAqIH0pKTtcbiAqXG4gKiAvLyBFbnN1cmUgYGJhdGNoTG9nYCBpcyBpbnZva2VkIG9uY2UgYWZ0ZXIgMSBzZWNvbmQgb2YgZGVib3VuY2VkIGNhbGxzLlxuICogdmFyIGRlYm91bmNlZCA9IF8uZGVib3VuY2UoYmF0Y2hMb2csIDI1MCwgeyAnbWF4V2FpdCc6IDEwMDAgfSk7XG4gKiB2YXIgc291cmNlID0gbmV3IEV2ZW50U291cmNlKCcvc3RyZWFtJyk7XG4gKiBqUXVlcnkoc291cmNlKS5vbignbWVzc2FnZScsIGRlYm91bmNlZCk7XG4gKlxuICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyBkZWJvdW5jZWQgaW52b2NhdGlvbi5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIGRlYm91bmNlZC5jYW5jZWwpO1xuICovXG5mdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gIHZhciBsYXN0QXJncyxcbiAgICAgIGxhc3RUaGlzLFxuICAgICAgbWF4V2FpdCxcbiAgICAgIHJlc3VsdCxcbiAgICAgIHRpbWVySWQsXG4gICAgICBsYXN0Q2FsbFRpbWUsXG4gICAgICBsYXN0SW52b2tlVGltZSA9IDAsXG4gICAgICBsZWFkaW5nID0gZmFsc2UsXG4gICAgICBtYXhpbmcgPSBmYWxzZSxcbiAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB3YWl0ID0gdG9OdW1iZXIod2FpdCkgfHwgMDtcbiAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgbGVhZGluZyA9ICEhb3B0aW9ucy5sZWFkaW5nO1xuICAgIG1heGluZyA9ICdtYXhXYWl0JyBpbiBvcHRpb25zO1xuICAgIG1heFdhaXQgPSBtYXhpbmcgPyBuYXRpdmVNYXgodG9OdW1iZXIob3B0aW9ucy5tYXhXYWl0KSB8fCAwLCB3YWl0KSA6IG1heFdhaXQ7XG4gICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUZ1bmModGltZSkge1xuICAgIHZhciBhcmdzID0gbGFzdEFyZ3MsXG4gICAgICAgIHRoaXNBcmcgPSBsYXN0VGhpcztcblxuICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxlYWRpbmdFZGdlKHRpbWUpIHtcbiAgICAvLyBSZXNldCBhbnkgYG1heFdhaXRgIHRpbWVyLlxuICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICAvLyBTdGFydCB0aGUgdGltZXIgZm9yIHRoZSB0cmFpbGluZyBlZGdlLlxuICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgLy8gSW52b2tlIHRoZSBsZWFkaW5nIGVkZ2UuXG4gICAgcmV0dXJuIGxlYWRpbmcgPyBpbnZva2VGdW5jKHRpbWUpIDogcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtYWluaW5nV2FpdCh0aW1lKSB7XG4gICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZSxcbiAgICAgICAgcmVzdWx0ID0gd2FpdCAtIHRpbWVTaW5jZUxhc3RDYWxsO1xuXG4gICAgcmV0dXJuIG1heGluZyA/IG5hdGl2ZU1pbihyZXN1bHQsIG1heFdhaXQgLSB0aW1lU2luY2VMYXN0SW52b2tlKSA6IHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3VsZEludm9rZSh0aW1lKSB7XG4gICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZTtcblxuICAgIC8vIEVpdGhlciB0aGlzIGlzIHRoZSBmaXJzdCBjYWxsLCBhY3Rpdml0eSBoYXMgc3RvcHBlZCBhbmQgd2UncmUgYXQgdGhlXG4gICAgLy8gdHJhaWxpbmcgZWRnZSwgdGhlIHN5c3RlbSB0aW1lIGhhcyBnb25lIGJhY2t3YXJkcyBhbmQgd2UncmUgdHJlYXRpbmdcbiAgICAvLyBpdCBhcyB0aGUgdHJhaWxpbmcgZWRnZSwgb3Igd2UndmUgaGl0IHRoZSBgbWF4V2FpdGAgbGltaXQuXG4gICAgcmV0dXJuIChsYXN0Q2FsbFRpbWUgPT09IHVuZGVmaW5lZCB8fCAodGltZVNpbmNlTGFzdENhbGwgPj0gd2FpdCkgfHxcbiAgICAgICh0aW1lU2luY2VMYXN0Q2FsbCA8IDApIHx8IChtYXhpbmcgJiYgdGltZVNpbmNlTGFzdEludm9rZSA+PSBtYXhXYWl0KSk7XG4gIH1cblxuICBmdW5jdGlvbiB0aW1lckV4cGlyZWQoKSB7XG4gICAgdmFyIHRpbWUgPSBub3coKTtcbiAgICBpZiAoc2hvdWxkSW52b2tlKHRpbWUpKSB7XG4gICAgICByZXR1cm4gdHJhaWxpbmdFZGdlKHRpbWUpO1xuICAgIH1cbiAgICAvLyBSZXN0YXJ0IHRoZSB0aW1lci5cbiAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHJlbWFpbmluZ1dhaXQodGltZSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhaWxpbmdFZGdlKHRpbWUpIHtcbiAgICB0aW1lcklkID0gdW5kZWZpbmVkO1xuXG4gICAgLy8gT25seSBpbnZva2UgaWYgd2UgaGF2ZSBgbGFzdEFyZ3NgIHdoaWNoIG1lYW5zIGBmdW5jYCBoYXMgYmVlblxuICAgIC8vIGRlYm91bmNlZCBhdCBsZWFzdCBvbmNlLlxuICAgIGlmICh0cmFpbGluZyAmJiBsYXN0QXJncykge1xuICAgICAgcmV0dXJuIGludm9rZUZ1bmModGltZSk7XG4gICAgfVxuICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICBpZiAodGltZXJJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgfVxuICAgIGxhc3RJbnZva2VUaW1lID0gMDtcbiAgICBsYXN0QXJncyA9IGxhc3RDYWxsVGltZSA9IGxhc3RUaGlzID0gdGltZXJJZCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgIHJldHVybiB0aW1lcklkID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiB0cmFpbGluZ0VkZ2Uobm93KCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVib3VuY2VkKCkge1xuICAgIHZhciB0aW1lID0gbm93KCksXG4gICAgICAgIGlzSW52b2tpbmcgPSBzaG91bGRJbnZva2UodGltZSk7XG5cbiAgICBsYXN0QXJncyA9IGFyZ3VtZW50cztcbiAgICBsYXN0VGhpcyA9IHRoaXM7XG4gICAgbGFzdENhbGxUaW1lID0gdGltZTtcblxuICAgIGlmIChpc0ludm9raW5nKSB7XG4gICAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBsZWFkaW5nRWRnZShsYXN0Q2FsbFRpbWUpO1xuICAgICAgfVxuICAgICAgaWYgKG1heGluZykge1xuICAgICAgICAvLyBIYW5kbGUgaW52b2NhdGlvbnMgaW4gYSB0aWdodCBsb29wLlxuICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgICByZXR1cm4gaW52b2tlRnVuYyhsYXN0Q2FsbFRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGRlYm91bmNlZC5jYW5jZWwgPSBjYW5jZWw7XG4gIGRlYm91bmNlZC5mbHVzaCA9IGZsdXNoO1xuICByZXR1cm4gZGVib3VuY2VkO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSB0aHJvdHRsZWQgZnVuY3Rpb24gdGhhdCBvbmx5IGludm9rZXMgYGZ1bmNgIGF0IG1vc3Qgb25jZSBwZXJcbiAqIGV2ZXJ5IGB3YWl0YCBtaWxsaXNlY29uZHMuIFRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgXG4gKiBtZXRob2QgdG8gY2FuY2VsIGRlbGF5ZWQgYGZ1bmNgIGludm9jYXRpb25zIGFuZCBhIGBmbHVzaGAgbWV0aG9kIHRvXG4gKiBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS4gUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2BcbiAqIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZSBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGBcbiAqIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZCB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGVcbiAqIHRocm90dGxlZCBmdW5jdGlvbi4gU3Vic2VxdWVudCBjYWxscyB0byB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHJldHVybiB0aGVcbiAqIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2AgaW52b2NhdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG4gKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIHRocm90dGxlZCBmdW5jdGlvblxuICogaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICpcbiAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZFxuICogdW50aWwgdG8gdGhlIG5leHQgdGljaywgc2ltaWxhciB0byBgc2V0VGltZW91dGAgd2l0aCBhIHRpbWVvdXQgb2YgYDBgLlxuICpcbiAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKVxuICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy50aHJvdHRsZWAgYW5kIGBfLmRlYm91bmNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHRocm90dGxlLlxuICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHRocm90dGxlIGludm9jYXRpb25zIHRvLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9dHJ1ZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHRocm90dGxlZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gQXZvaWQgZXhjZXNzaXZlbHkgdXBkYXRpbmcgdGhlIHBvc2l0aW9uIHdoaWxlIHNjcm9sbGluZy5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdzY3JvbGwnLCBfLnRocm90dGxlKHVwZGF0ZVBvc2l0aW9uLCAxMDApKTtcbiAqXG4gKiAvLyBJbnZva2UgYHJlbmV3VG9rZW5gIHdoZW4gdGhlIGNsaWNrIGV2ZW50IGlzIGZpcmVkLCBidXQgbm90IG1vcmUgdGhhbiBvbmNlIGV2ZXJ5IDUgbWludXRlcy5cbiAqIHZhciB0aHJvdHRsZWQgPSBfLnRocm90dGxlKHJlbmV3VG9rZW4sIDMwMDAwMCwgeyAndHJhaWxpbmcnOiBmYWxzZSB9KTtcbiAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCB0aHJvdHRsZWQpO1xuICpcbiAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgdGhyb3R0bGVkIGludm9jYXRpb24uXG4gKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCB0aHJvdHRsZWQuY2FuY2VsKTtcbiAqL1xuZnVuY3Rpb24gdGhyb3R0bGUoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICB2YXIgbGVhZGluZyA9IHRydWUsXG4gICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgbGVhZGluZyA9ICdsZWFkaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLmxlYWRpbmcgOiBsZWFkaW5nO1xuICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gIH1cbiAgcmV0dXJuIGRlYm91bmNlKGZ1bmMsIHdhaXQsIHtcbiAgICAnbGVhZGluZyc6IGxlYWRpbmcsXG4gICAgJ21heFdhaXQnOiB3YWl0LFxuICAgICd0cmFpbGluZyc6IHRyYWlsaW5nXG4gIH0pO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b051bWJlcigzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xuICogLy8gPT4gSW5maW5pdHlcbiAqXG4gKiBfLnRvTnVtYmVyKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gTkFOO1xuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgdmFsdWUgPSBpc09iamVjdChvdGhlcikgPyAob3RoZXIgKyAnJykgOiBvdGhlcjtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiArdmFsdWU7XG4gIH1cbiAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHJlVHJpbSwgJycpO1xuICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xuICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcbiAgICA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOClcbiAgICA6IChyZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0aHJvdHRsZTtcbiJdLCJtYXBwaW5ncyI6Ijs7QUFBQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUVBOzs7Ozs7QUFLQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNEQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE0Q0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBeUJBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF3QkE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkE7QUFDQTtBQUVBO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lodash.throttle/index.js\n");

/***/ }),

/***/ "./node_modules/picturefill/dist/picturefill.js":
/*!******************************************************!*\
  !*** ./node_modules/picturefill/dist/picturefill.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*! picturefill - v3.0.2 - 2016-02-12\n * https://scottjehl.github.io/picturefill/\n * Copyright (c) 2016 https://github.com/scottjehl/picturefill/blob/master/Authors.txt; Licensed MIT\n */\n\n/*! Gecko-Picture - v1.0\n * https://github.com/scottjehl/picturefill/tree/3.0/src/plugins/gecko-picture\n * Firefox's early picture implementation (prior to FF41) is static and does\n * not react to viewport changes. This tiny module fixes this.\n */\n(function (window) {\n  /*jshint eqnull:true */\n  var ua = navigator.userAgent;\n\n  if (window.HTMLPictureElement && /ecko/.test(ua) && ua.match(/rv\\:(\\d+)/) && RegExp.$1 < 45) {\n    addEventListener(\"resize\", function () {\n      var timer;\n      var dummySrc = document.createElement(\"source\");\n\n      var fixRespimg = function fixRespimg(img) {\n        var source, sizes;\n        var picture = img.parentNode;\n\n        if (picture.nodeName.toUpperCase() === \"PICTURE\") {\n          source = dummySrc.cloneNode();\n          picture.insertBefore(source, picture.firstElementChild);\n          setTimeout(function () {\n            picture.removeChild(source);\n          });\n        } else if (!img._pfLastSize || img.offsetWidth > img._pfLastSize) {\n          img._pfLastSize = img.offsetWidth;\n          sizes = img.sizes;\n          img.sizes += \",100vw\";\n          setTimeout(function () {\n            img.sizes = sizes;\n          });\n        }\n      };\n\n      var findPictureImgs = function findPictureImgs() {\n        var i;\n        var imgs = document.querySelectorAll(\"picture > img, img[srcset][sizes]\");\n\n        for (i = 0; i < imgs.length; i++) {\n          fixRespimg(imgs[i]);\n        }\n      };\n\n      var onResize = function onResize() {\n        clearTimeout(timer);\n        timer = setTimeout(findPictureImgs, 99);\n      };\n\n      var mq = window.matchMedia && matchMedia(\"(orientation: landscape)\");\n\n      var init = function init() {\n        onResize();\n\n        if (mq && mq.addListener) {\n          mq.addListener(onResize);\n        }\n      };\n\n      dummySrc.srcset = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n\n      if (/^[c|i]|d$/.test(document.readyState || \"\")) {\n        init();\n      } else {\n        document.addEventListener(\"DOMContentLoaded\", init);\n      }\n\n      return onResize;\n    }());\n  }\n})(window);\n/*! Picturefill - v3.0.2\n * http://scottjehl.github.io/picturefill\n * Copyright (c) 2015 https://github.com/scottjehl/picturefill/blob/master/Authors.txt;\n *  License: MIT\n */\n\n\n(function (window, document, undefined) {\n  // Enable strict mode\n  \"use strict\"; // HTML shim|v it for old IE (IE9 will still need the HTML video tag workaround)\n\n  document.createElement(\"picture\");\n  var warn, eminpx, alwaysCheckWDescriptor, evalId; // local object for method references and testing exposure\n\n  var pf = {};\n  var isSupportTestReady = false;\n\n  var noop = function noop() {};\n\n  var image = document.createElement(\"img\");\n  var getImgAttr = image.getAttribute;\n  var setImgAttr = image.setAttribute;\n  var removeImgAttr = image.removeAttribute;\n  var docElem = document.documentElement;\n  var types = {};\n  var cfg = {\n    //resource selection:\n    algorithm: \"\"\n  };\n  var srcAttr = \"data-pfsrc\";\n  var srcsetAttr = srcAttr + \"set\"; // ua sniffing is done for undetectable img loading features,\n  // to do some non crucial perf optimizations\n\n  var ua = navigator.userAgent;\n  var supportAbort = /rident/.test(ua) || /ecko/.test(ua) && ua.match(/rv\\:(\\d+)/) && RegExp.$1 > 35;\n  var curSrcProp = \"currentSrc\";\n  var regWDesc = /\\s+\\+?\\d+(e\\d+)?w/;\n  var regSize = /(\\([^)]+\\))?\\s*(.+)/;\n  var setOptions = window.picturefillCFG;\n  /**\n   * Shortcut property for https://w3c.github.io/webappsec/specs/mixedcontent/#restricts-mixed-content ( for easy overriding in tests )\n   */\n  // baseStyle also used by getEmValue (i.e.: width: 1em is important)\n\n  var baseStyle = \"position:absolute;left:0;visibility:hidden;display:block;padding:0;border:none;font-size:1em;width:1em;overflow:hidden;clip:rect(0px, 0px, 0px, 0px)\";\n  var fsCss = \"font-size:100%!important;\";\n  var isVwDirty = true;\n  var cssCache = {};\n  var sizeLengthCache = {};\n  var DPR = window.devicePixelRatio;\n  var units = {\n    px: 1,\n    \"in\": 96\n  };\n  var anchor = document.createElement(\"a\");\n  /**\n   * alreadyRun flag used for setOptions. is it true setOptions will reevaluate\n   * @type {boolean}\n   */\n\n  var alreadyRun = false; // Reusable, non-\"g\" Regexes\n  // (Don't use \\s, to avoid matching non-breaking space.)\n\n  var regexLeadingSpaces = /^[ \\t\\n\\r\\u000c]+/,\n      regexLeadingCommasOrSpaces = /^[, \\t\\n\\r\\u000c]+/,\n      regexLeadingNotSpaces = /^[^ \\t\\n\\r\\u000c]+/,\n      regexTrailingCommas = /[,]+$/,\n      regexNonNegativeInteger = /^\\d+$/,\n      // ( Positive or negative or unsigned integers or decimals, without or without exponents.\n  // Must include at least one digit.\n  // According to spec tests any decimal point must be followed by a digit.\n  // No leading plus sign is allowed.)\n  // https://html.spec.whatwg.org/multipage/infrastructure.html#valid-floating-point-number\n  regexFloatingPoint = /^-?(?:[0-9]+|[0-9]*\\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/;\n\n  var on = function on(obj, evt, fn, capture) {\n    if (obj.addEventListener) {\n      obj.addEventListener(evt, fn, capture || false);\n    } else if (obj.attachEvent) {\n      obj.attachEvent(\"on\" + evt, fn);\n    }\n  };\n  /**\n   * simple memoize function:\n   */\n\n\n  var memoize = function memoize(fn) {\n    var cache = {};\n    return function (input) {\n      if (!(input in cache)) {\n        cache[input] = fn(input);\n      }\n\n      return cache[input];\n    };\n  }; // UTILITY FUNCTIONS\n  // Manual is faster than RegEx\n  // http://jsperf.com/whitespace-character/5\n\n\n  function isSpace(c) {\n    return c === \" \" || // space\n    c === \"\\t\" || // horizontal tab\n    c === \"\\n\" || // new line\n    c === \"\\f\" || // form feed\n    c === \"\\r\"; // carriage return\n  }\n  /**\n   * gets a mediaquery and returns a boolean or gets a css length and returns a number\n   * @param css mediaqueries or css length\n   * @returns {boolean|number}\n   *\n   * based on: https://gist.github.com/jonathantneal/db4f77009b155f083738\n   */\n\n\n  var evalCSS = function () {\n    var regLength = /^([\\d\\.]+)(em|vw|px)$/;\n\n    var replace = function replace() {\n      var args = arguments,\n          index = 0,\n          string = args[0];\n\n      while (++index in args) {\n        string = string.replace(args[index], args[++index]);\n      }\n\n      return string;\n    };\n\n    var buildStr = memoize(function (css) {\n      return \"return \" + replace((css || \"\").toLowerCase(), // interpret `and`\n      /\\band\\b/g, \"&&\", // interpret `,`\n      /,/g, \"||\", // interpret `min-` as >=\n      /min-([a-z-\\s]+):/g, \"e.$1>=\", // interpret `max-` as <=\n      /max-([a-z-\\s]+):/g, \"e.$1<=\", //calc value\n      /calc([^)]+)/g, \"($1)\", // interpret css values\n      /(\\d+[\\.]*[\\d]*)([a-z]+)/g, \"($1 * e.$2)\", //make eval less evil\n      /^(?!(e.[a-z]|[0-9\\.&=|><\\+\\-\\*\\(\\)\\/])).*/ig, \"\") + \";\";\n    });\n    return function (css, length) {\n      var parsedLength;\n\n      if (!(css in cssCache)) {\n        cssCache[css] = false;\n\n        if (length && (parsedLength = css.match(regLength))) {\n          cssCache[css] = parsedLength[1] * units[parsedLength[2]];\n        } else {\n          /*jshint evil:true */\n          try {\n            cssCache[css] = new Function(\"e\", buildStr(css))(units);\n          } catch (e) {}\n          /*jshint evil:false */\n\n        }\n      }\n\n      return cssCache[css];\n    };\n  }();\n\n  var setResolution = function setResolution(candidate, sizesattr) {\n    if (candidate.w) {\n      // h = means height: || descriptor.type === 'h' do not handle yet...\n      candidate.cWidth = pf.calcListLength(sizesattr || \"100vw\");\n      candidate.res = candidate.w / candidate.cWidth;\n    } else {\n      candidate.res = candidate.d;\n    }\n\n    return candidate;\n  };\n  /**\n   *\n   * @param opt\n   */\n\n\n  var picturefill = function picturefill(opt) {\n    if (!isSupportTestReady) {\n      return;\n    }\n\n    var elements, i, plen;\n    var options = opt || {};\n\n    if (options.elements && options.elements.nodeType === 1) {\n      if (options.elements.nodeName.toUpperCase() === \"IMG\") {\n        options.elements = [options.elements];\n      } else {\n        options.context = options.elements;\n        options.elements = null;\n      }\n    }\n\n    elements = options.elements || pf.qsa(options.context || document, options.reevaluate || options.reselect ? pf.sel : pf.selShort);\n\n    if (plen = elements.length) {\n      pf.setupRun(options);\n      alreadyRun = true; // Loop through all elements\n\n      for (i = 0; i < plen; i++) {\n        pf.fillImg(elements[i], options);\n      }\n\n      pf.teardownRun(options);\n    }\n  };\n  /**\n   * outputs a warning for the developer\n   * @param {message}\n   * @type {Function}\n   */\n\n\n  warn = window.console && console.warn ? function (message) {\n    console.warn(message);\n  } : noop;\n\n  if (!(curSrcProp in image)) {\n    curSrcProp = \"src\";\n  } // Add support for standard mime types.\n\n\n  types[\"image/jpeg\"] = true;\n  types[\"image/gif\"] = true;\n  types[\"image/png\"] = true;\n\n  function detectTypeSupport(type, typeUri) {\n    // based on Modernizr's lossless img-webp test\n    // note: asynchronous\n    var image = new window.Image();\n\n    image.onerror = function () {\n      types[type] = false;\n      picturefill();\n    };\n\n    image.onload = function () {\n      types[type] = image.width === 1;\n      picturefill();\n    };\n\n    image.src = typeUri;\n    return \"pending\";\n  } // test svg support\n\n\n  types[\"image/svg+xml\"] = document.implementation.hasFeature(\"http://www.w3.org/TR/SVG11/feature#Image\", \"1.1\");\n  /**\n   * updates the internal vW property with the current viewport width in px\n   */\n\n  function updateMetrics() {\n    isVwDirty = false;\n    DPR = window.devicePixelRatio;\n    cssCache = {};\n    sizeLengthCache = {};\n    pf.DPR = DPR || 1;\n    units.width = Math.max(window.innerWidth || 0, docElem.clientWidth);\n    units.height = Math.max(window.innerHeight || 0, docElem.clientHeight);\n    units.vw = units.width / 100;\n    units.vh = units.height / 100;\n    evalId = [units.height, units.width, DPR].join(\"-\");\n    units.em = pf.getEmValue();\n    units.rem = units.em;\n  }\n\n  function chooseLowRes(lowerValue, higherValue, dprValue, isCached) {\n    var bonusFactor, tooMuch, bonus, meanDensity; //experimental\n\n    if (cfg.algorithm === \"saveData\") {\n      if (lowerValue > 2.7) {\n        meanDensity = dprValue + 1;\n      } else {\n        tooMuch = higherValue - dprValue;\n        bonusFactor = Math.pow(lowerValue - 0.6, 1.5);\n        bonus = tooMuch * bonusFactor;\n\n        if (isCached) {\n          bonus += 0.1 * bonusFactor;\n        }\n\n        meanDensity = lowerValue + bonus;\n      }\n    } else {\n      meanDensity = dprValue > 1 ? Math.sqrt(lowerValue * higherValue) : lowerValue;\n    }\n\n    return meanDensity > dprValue;\n  }\n\n  function applyBestCandidate(img) {\n    var srcSetCandidates;\n    var matchingSet = pf.getSet(img);\n    var evaluated = false;\n\n    if (matchingSet !== \"pending\") {\n      evaluated = evalId;\n\n      if (matchingSet) {\n        srcSetCandidates = pf.setRes(matchingSet);\n        pf.applySetCandidate(srcSetCandidates, img);\n      }\n    }\n\n    img[pf.ns].evaled = evaluated;\n  }\n\n  function ascendingSort(a, b) {\n    return a.res - b.res;\n  }\n\n  function setSrcToCur(img, src, set) {\n    var candidate;\n\n    if (!set && src) {\n      set = img[pf.ns].sets;\n      set = set && set[set.length - 1];\n    }\n\n    candidate = getCandidateForSrc(src, set);\n\n    if (candidate) {\n      src = pf.makeUrl(src);\n      img[pf.ns].curSrc = src;\n      img[pf.ns].curCan = candidate;\n\n      if (!candidate.res) {\n        setResolution(candidate, candidate.set.sizes);\n      }\n    }\n\n    return candidate;\n  }\n\n  function getCandidateForSrc(src, set) {\n    var i, candidate, candidates;\n\n    if (src && set) {\n      candidates = pf.parseSet(set);\n      src = pf.makeUrl(src);\n\n      for (i = 0; i < candidates.length; i++) {\n        if (src === pf.makeUrl(candidates[i].url)) {\n          candidate = candidates[i];\n          break;\n        }\n      }\n    }\n\n    return candidate;\n  }\n\n  function getAllSourceElements(picture, candidates) {\n    var i, len, source, srcset; // SPEC mismatch intended for size and perf:\n    // actually only source elements preceding the img should be used\n    // also note: don't use qsa here, because IE8 sometimes doesn't like source as the key part in a selector\n\n    var sources = picture.getElementsByTagName(\"source\");\n\n    for (i = 0, len = sources.length; i < len; i++) {\n      source = sources[i];\n      source[pf.ns] = true;\n      srcset = source.getAttribute(\"srcset\"); // if source does not have a srcset attribute, skip\n\n      if (srcset) {\n        candidates.push({\n          srcset: srcset,\n          media: source.getAttribute(\"media\"),\n          type: source.getAttribute(\"type\"),\n          sizes: source.getAttribute(\"sizes\")\n        });\n      }\n    }\n  }\n  /**\n   * Srcset Parser\n   * By Alex Bell |  MIT License\n   *\n   * @returns Array [{url: _, d: _, w: _, h:_, set:_(????)}, ...]\n   *\n   * Based super duper closely on the reference algorithm at:\n   * https://html.spec.whatwg.org/multipage/embedded-content.html#parse-a-srcset-attribute\n   */\n  // 1. Let input be the value passed to this algorithm.\n  // (TO-DO : Explain what \"set\" argument is here. Maybe choose a more\n  // descriptive & more searchable name.  Since passing the \"set\" in really has\n  // nothing to do with parsing proper, I would prefer this assignment eventually\n  // go in an external fn.)\n\n\n  function parseSrcset(input, set) {\n    function collectCharacters(regEx) {\n      var chars,\n          match = regEx.exec(input.substring(pos));\n\n      if (match) {\n        chars = match[0];\n        pos += chars.length;\n        return chars;\n      }\n    }\n\n    var inputLength = input.length,\n        url,\n        descriptors,\n        currentDescriptor,\n        state,\n        c,\n        // 2. Let position be a pointer into input, initially pointing at the start\n    //    of the string.\n    pos = 0,\n        // 3. Let candidates be an initially empty source set.\n    candidates = [];\n    /**\n    * Adds descriptor properties to a candidate, pushes to the candidates array\n    * @return undefined\n    */\n    // (Declared outside of the while loop so that it's only created once.\n    // (This fn is defined before it is used, in order to pass JSHINT.\n    // Unfortunately this breaks the sequencing of the spec comments. :/ )\n\n    function parseDescriptors() {\n      // 9. Descriptor parser: Let error be no.\n      var pError = false,\n          // 10. Let width be absent.\n      // 11. Let density be absent.\n      // 12. Let future-compat-h be absent. (We're implementing it now as h)\n      w,\n          d,\n          h,\n          i,\n          candidate = {},\n          desc,\n          lastChar,\n          value,\n          intVal,\n          floatVal; // 13. For each descriptor in descriptors, run the appropriate set of steps\n      // from the following list:\n\n      for (i = 0; i < descriptors.length; i++) {\n        desc = descriptors[i];\n        lastChar = desc[desc.length - 1];\n        value = desc.substring(0, desc.length - 1);\n        intVal = parseInt(value, 10);\n        floatVal = parseFloat(value); // If the descriptor consists of a valid non-negative integer followed by\n        // a U+0077 LATIN SMALL LETTER W character\n\n        if (regexNonNegativeInteger.test(value) && lastChar === \"w\") {\n          // If width and density are not both absent, then let error be yes.\n          if (w || d) {\n            pError = true;\n          } // Apply the rules for parsing non-negative integers to the descriptor.\n          // If the result is zero, let error be yes.\n          // Otherwise, let width be the result.\n\n\n          if (intVal === 0) {\n            pError = true;\n          } else {\n            w = intVal;\n          } // If the descriptor consists of a valid floating-point number followed by\n          // a U+0078 LATIN SMALL LETTER X character\n\n        } else if (regexFloatingPoint.test(value) && lastChar === \"x\") {\n          // If width, density and future-compat-h are not all absent, then let error\n          // be yes.\n          if (w || d || h) {\n            pError = true;\n          } // Apply the rules for parsing floating-point number values to the descriptor.\n          // If the result is less than zero, let error be yes. Otherwise, let density\n          // be the result.\n\n\n          if (floatVal < 0) {\n            pError = true;\n          } else {\n            d = floatVal;\n          } // If the descriptor consists of a valid non-negative integer followed by\n          // a U+0068 LATIN SMALL LETTER H character\n\n        } else if (regexNonNegativeInteger.test(value) && lastChar === \"h\") {\n          // If height and density are not both absent, then let error be yes.\n          if (h || d) {\n            pError = true;\n          } // Apply the rules for parsing non-negative integers to the descriptor.\n          // If the result is zero, let error be yes. Otherwise, let future-compat-h\n          // be the result.\n\n\n          if (intVal === 0) {\n            pError = true;\n          } else {\n            h = intVal;\n          } // Anything else, Let error be yes.\n\n        } else {\n          pError = true;\n        }\n      } // (close step 13 for loop)\n      // 15. If error is still no, then append a new image source to candidates whose\n      // URL is url, associated with a width width if not absent and a pixel\n      // density density if not absent. Otherwise, there is a parse error.\n\n\n      if (!pError) {\n        candidate.url = url;\n\n        if (w) {\n          candidate.w = w;\n        }\n\n        if (d) {\n          candidate.d = d;\n        }\n\n        if (h) {\n          candidate.h = h;\n        }\n\n        if (!h && !d && !w) {\n          candidate.d = 1;\n        }\n\n        if (candidate.d === 1) {\n          set.has1x = true;\n        }\n\n        candidate.set = set;\n        candidates.push(candidate);\n      }\n    } // (close parseDescriptors fn)\n\n    /**\n    * Tokenizes descriptor properties prior to parsing\n    * Returns undefined.\n    * (Again, this fn is defined before it is used, in order to pass JSHINT.\n    * Unfortunately this breaks the logical sequencing of the spec comments. :/ )\n    */\n\n\n    function tokenize() {\n      // 8.1. Descriptor tokeniser: Skip whitespace\n      collectCharacters(regexLeadingSpaces); // 8.2. Let current descriptor be the empty string.\n\n      currentDescriptor = \"\"; // 8.3. Let state be in descriptor.\n\n      state = \"in descriptor\";\n\n      while (true) {\n        // 8.4. Let c be the character at position.\n        c = input.charAt(pos); //  Do the following depending on the value of state.\n        //  For the purpose of this step, \"EOF\" is a special character representing\n        //  that position is past the end of input.\n        // In descriptor\n\n        if (state === \"in descriptor\") {\n          // Do the following, depending on the value of c:\n          // Space character\n          // If current descriptor is not empty, append current descriptor to\n          // descriptors and let current descriptor be the empty string.\n          // Set state to after descriptor.\n          if (isSpace(c)) {\n            if (currentDescriptor) {\n              descriptors.push(currentDescriptor);\n              currentDescriptor = \"\";\n              state = \"after descriptor\";\n            } // U+002C COMMA (,)\n            // Advance position to the next character in input. If current descriptor\n            // is not empty, append current descriptor to descriptors. Jump to the step\n            // labeled descriptor parser.\n\n          } else if (c === \",\") {\n            pos += 1;\n\n            if (currentDescriptor) {\n              descriptors.push(currentDescriptor);\n            }\n\n            parseDescriptors();\n            return; // U+0028 LEFT PARENTHESIS (()\n            // Append c to current descriptor. Set state to in parens.\n          } else if (c === \"(\") {\n            currentDescriptor = currentDescriptor + c;\n            state = \"in parens\"; // EOF\n            // If current descriptor is not empty, append current descriptor to\n            // descriptors. Jump to the step labeled descriptor parser.\n          } else if (c === \"\") {\n            if (currentDescriptor) {\n              descriptors.push(currentDescriptor);\n            }\n\n            parseDescriptors();\n            return; // Anything else\n            // Append c to current descriptor.\n          } else {\n            currentDescriptor = currentDescriptor + c;\n          } // (end \"in descriptor\"\n          // In parens\n\n        } else if (state === \"in parens\") {\n          // U+0029 RIGHT PARENTHESIS ())\n          // Append c to current descriptor. Set state to in descriptor.\n          if (c === \")\") {\n            currentDescriptor = currentDescriptor + c;\n            state = \"in descriptor\"; // EOF\n            // Append current descriptor to descriptors. Jump to the step labeled\n            // descriptor parser.\n          } else if (c === \"\") {\n            descriptors.push(currentDescriptor);\n            parseDescriptors();\n            return; // Anything else\n            // Append c to current descriptor.\n          } else {\n            currentDescriptor = currentDescriptor + c;\n          } // After descriptor\n\n        } else if (state === \"after descriptor\") {\n          // Do the following, depending on the value of c:\n          // Space character: Stay in this state.\n          if (isSpace(c)) {// EOF: Jump to the step labeled descriptor parser.\n          } else if (c === \"\") {\n            parseDescriptors();\n            return; // Anything else\n            // Set state to in descriptor. Set position to the previous character in input.\n          } else {\n            state = \"in descriptor\";\n            pos -= 1;\n          }\n        } // Advance position to the next character in input.\n\n\n        pos += 1; // Repeat this step.\n      } // (close while true loop)\n\n    } // 4. Splitting loop: Collect a sequence of characters that are space\n    //    characters or U+002C COMMA characters. If any U+002C COMMA characters\n    //    were collected, that is a parse error.\n\n\n    while (true) {\n      collectCharacters(regexLeadingCommasOrSpaces); // 5. If position is past the end of input, return candidates and abort these steps.\n\n      if (pos >= inputLength) {\n        return candidates; // (we're done, this is the sole return path)\n      } // 6. Collect a sequence of characters that are not space characters,\n      //    and let that be url.\n\n\n      url = collectCharacters(regexLeadingNotSpaces); // 7. Let descriptors be a new empty list.\n\n      descriptors = []; // 8. If url ends with a U+002C COMMA character (,), follow these substeps:\n      //\t\t(1). Remove all trailing U+002C COMMA characters from url. If this removed\n      //         more than one character, that is a parse error.\n\n      if (url.slice(-1) === \",\") {\n        url = url.replace(regexTrailingCommas, \"\"); // (Jump ahead to step 9 to skip tokenization and just push the candidate).\n\n        parseDescriptors(); //\tOtherwise, follow these substeps:\n      } else {\n        tokenize();\n      } // (close else of step 8)\n      // 16. Return to the step labeled splitting loop.\n\n    } // (Close of big while loop.)\n\n  }\n  /*\n   * Sizes Parser\n   *\n   * By Alex Bell |  MIT License\n   *\n   * Non-strict but accurate and lightweight JS Parser for the string value <img sizes=\"here\">\n   *\n   * Reference algorithm at:\n   * https://html.spec.whatwg.org/multipage/embedded-content.html#parse-a-sizes-attribute\n   *\n   * Most comments are copied in directly from the spec\n   * (except for comments in parens).\n   *\n   * Grammar is:\n   * <source-size-list> = <source-size># [ , <source-size-value> ]? | <source-size-value>\n   * <source-size> = <media-condition> <source-size-value>\n   * <source-size-value> = <length>\n   * http://www.w3.org/html/wg/drafts/html/master/embedded-content.html#attr-img-sizes\n   *\n   * E.g. \"(max-width: 30em) 100vw, (max-width: 50em) 70vw, 100vw\"\n   * or \"(min-width: 30em), calc(30vw - 15px)\" or just \"30vw\"\n   *\n   * Returns the first valid <css-length> with a media condition that evaluates to true,\n   * or \"100vw\" if all valid media conditions evaluate to false.\n   *\n   */\n\n\n  function parseSizes(strValue) {\n    // (Percentage CSS lengths are not allowed in this case, to avoid confusion:\n    // https://html.spec.whatwg.org/multipage/embedded-content.html#valid-source-size-list\n    // CSS allows a single optional plus or minus sign:\n    // http://www.w3.org/TR/CSS2/syndata.html#numbers\n    // CSS is ASCII case-insensitive:\n    // http://www.w3.org/TR/CSS2/syndata.html#characters )\n    // Spec allows exponential notation for <number> type:\n    // http://dev.w3.org/csswg/css-values/#numbers\n    var regexCssLengthWithUnits = /^(?:[+-]?[0-9]+|[0-9]*\\.[0-9]+)(?:[eE][+-]?[0-9]+)?(?:ch|cm|em|ex|in|mm|pc|pt|px|rem|vh|vmin|vmax|vw)$/i; // (This is a quick and lenient test. Because of optional unlimited-depth internal\n    // grouping parens and strict spacing rules, this could get very complicated.)\n\n    var regexCssCalc = /^calc\\((?:[0-9a-z \\.\\+\\-\\*\\/\\(\\)]+)\\)$/i;\n    var i;\n    var unparsedSizesList;\n    var unparsedSizesListLength;\n    var unparsedSize;\n    var lastComponentValue;\n    var size; // UTILITY FUNCTIONS\n    //  (Toy CSS parser. The goals here are:\n    //  1) expansive test coverage without the weight of a full CSS parser.\n    //  2) Avoiding regex wherever convenient.\n    //  Quick tests: http://jsfiddle.net/gtntL4gr/3/\n    //  Returns an array of arrays.)\n\n    function parseComponentValues(str) {\n      var chrctr;\n      var component = \"\";\n      var componentArray = [];\n      var listArray = [];\n      var parenDepth = 0;\n      var pos = 0;\n      var inComment = false;\n\n      function pushComponent() {\n        if (component) {\n          componentArray.push(component);\n          component = \"\";\n        }\n      }\n\n      function pushComponentArray() {\n        if (componentArray[0]) {\n          listArray.push(componentArray);\n          componentArray = [];\n        }\n      } // (Loop forwards from the beginning of the string.)\n\n\n      while (true) {\n        chrctr = str.charAt(pos);\n\n        if (chrctr === \"\") {\n          // ( End of string reached.)\n          pushComponent();\n          pushComponentArray();\n          return listArray;\n        } else if (inComment) {\n          if (chrctr === \"*\" && str[pos + 1] === \"/\") {\n            // (At end of a comment.)\n            inComment = false;\n            pos += 2;\n            pushComponent();\n            continue;\n          } else {\n            pos += 1; // (Skip all characters inside comments.)\n\n            continue;\n          }\n        } else if (isSpace(chrctr)) {\n          // (If previous character in loop was also a space, or if\n          // at the beginning of the string, do not add space char to\n          // component.)\n          if (str.charAt(pos - 1) && isSpace(str.charAt(pos - 1)) || !component) {\n            pos += 1;\n            continue;\n          } else if (parenDepth === 0) {\n            pushComponent();\n            pos += 1;\n            continue;\n          } else {\n            // (Replace any space character with a plain space for legibility.)\n            chrctr = \" \";\n          }\n        } else if (chrctr === \"(\") {\n          parenDepth += 1;\n        } else if (chrctr === \")\") {\n          parenDepth -= 1;\n        } else if (chrctr === \",\") {\n          pushComponent();\n          pushComponentArray();\n          pos += 1;\n          continue;\n        } else if (chrctr === \"/\" && str.charAt(pos + 1) === \"*\") {\n          inComment = true;\n          pos += 2;\n          continue;\n        }\n\n        component = component + chrctr;\n        pos += 1;\n      }\n    }\n\n    function isValidNonNegativeSourceSizeValue(s) {\n      if (regexCssLengthWithUnits.test(s) && parseFloat(s) >= 0) {\n        return true;\n      }\n\n      if (regexCssCalc.test(s)) {\n        return true;\n      } // ( http://www.w3.org/TR/CSS2/syndata.html#numbers says:\n      // \"-0 is equivalent to 0 and is not a negative number.\" which means that\n      // unitless zero and unitless negative zero must be accepted as special cases.)\n\n\n      if (s === \"0\" || s === \"-0\" || s === \"+0\") {\n        return true;\n      }\n\n      return false;\n    } // When asked to parse a sizes attribute from an element, parse a\n    // comma-separated list of component values from the value of the element's\n    // sizes attribute (or the empty string, if the attribute is absent), and let\n    // unparsed sizes list be the result.\n    // http://dev.w3.org/csswg/css-syntax/#parse-comma-separated-list-of-component-values\n\n\n    unparsedSizesList = parseComponentValues(strValue);\n    unparsedSizesListLength = unparsedSizesList.length; // For each unparsed size in unparsed sizes list:\n\n    for (i = 0; i < unparsedSizesListLength; i++) {\n      unparsedSize = unparsedSizesList[i]; // 1. Remove all consecutive <whitespace-token>s from the end of unparsed size.\n      // ( parseComponentValues() already omits spaces outside of parens. )\n      // If unparsed size is now empty, that is a parse error; continue to the next\n      // iteration of this algorithm.\n      // ( parseComponentValues() won't push an empty array. )\n      // 2. If the last component value in unparsed size is a valid non-negative\n      // <source-size-value>, let size be its value and remove the component value\n      // from unparsed size. Any CSS function other than the calc() function is\n      // invalid. Otherwise, there is a parse error; continue to the next iteration\n      // of this algorithm.\n      // http://dev.w3.org/csswg/css-syntax/#parse-component-value\n\n      lastComponentValue = unparsedSize[unparsedSize.length - 1];\n\n      if (isValidNonNegativeSourceSizeValue(lastComponentValue)) {\n        size = lastComponentValue;\n        unparsedSize.pop();\n      } else {\n        continue;\n      } // 3. Remove all consecutive <whitespace-token>s from the end of unparsed\n      // size. If unparsed size is now empty, return size and exit this algorithm.\n      // If this was not the last item in unparsed sizes list, that is a parse error.\n\n\n      if (unparsedSize.length === 0) {\n        return size;\n      } // 4. Parse the remaining component values in unparsed size as a\n      // <media-condition>. If it does not parse correctly, or it does parse\n      // correctly but the <media-condition> evaluates to false, continue to the\n      // next iteration of this algorithm.\n      // (Parsing all possible compound media conditions in JS is heavy, complicated,\n      // and the payoff is unclear. Is there ever an situation where the\n      // media condition parses incorrectly but still somehow evaluates to true?\n      // Can we just rely on the browser/polyfill to do it?)\n\n\n      unparsedSize = unparsedSize.join(\" \");\n\n      if (!pf.matchesMedia(unparsedSize)) {\n        continue;\n      } // 5. Return size and exit this algorithm.\n\n\n      return size;\n    } // If the above algorithm exhausts unparsed sizes list without returning a\n    // size value, return 100vw.\n\n\n    return \"100vw\";\n  } // namespace\n\n\n  pf.ns = (\"pf\" + new Date().getTime()).substr(0, 9); // srcset support test\n\n  pf.supSrcset = \"srcset\" in image;\n  pf.supSizes = \"sizes\" in image;\n  pf.supPicture = !!window.HTMLPictureElement; // UC browser does claim to support srcset and picture, but not sizes,\n  // this extended test reveals the browser does support nothing\n\n  if (pf.supSrcset && pf.supPicture && !pf.supSizes) {\n    (function (image2) {\n      image.srcset = \"data:,a\";\n      image2.src = \"data:,a\";\n      pf.supSrcset = image.complete === image2.complete;\n      pf.supPicture = pf.supSrcset && pf.supPicture;\n    })(document.createElement(\"img\"));\n  } // Safari9 has basic support for sizes, but does't expose the `sizes` idl attribute\n\n\n  if (pf.supSrcset && !pf.supSizes) {\n    (function () {\n      var width2 = \"data:image/gif;base64,R0lGODlhAgABAPAAAP///wAAACH5BAAAAAAALAAAAAACAAEAAAICBAoAOw==\";\n      var width1 = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n      var img = document.createElement(\"img\");\n\n      var test = function test() {\n        var width = img.width;\n\n        if (width === 2) {\n          pf.supSizes = true;\n        }\n\n        alwaysCheckWDescriptor = pf.supSrcset && !pf.supSizes;\n        isSupportTestReady = true; // force async\n\n        setTimeout(picturefill);\n      };\n\n      img.onload = test;\n      img.onerror = test;\n      img.setAttribute(\"sizes\", \"9px\");\n      img.srcset = width1 + \" 1w,\" + width2 + \" 9w\";\n      img.src = width1;\n    })();\n  } else {\n    isSupportTestReady = true;\n  } // using pf.qsa instead of dom traversing does scale much better,\n  // especially on sites mixing responsive and non-responsive images\n\n\n  pf.selShort = \"picture>img,img[srcset]\";\n  pf.sel = pf.selShort;\n  pf.cfg = cfg;\n  /**\n   * Shortcut property for `devicePixelRatio` ( for easy overriding in tests )\n   */\n\n  pf.DPR = DPR || 1;\n  pf.u = units; // container of supported mime types that one might need to qualify before using\n\n  pf.types = types;\n  pf.setSize = noop;\n  /**\n   * Gets a string and returns the absolute URL\n   * @param src\n   * @returns {String} absolute URL\n   */\n\n  pf.makeUrl = memoize(function (src) {\n    anchor.href = src;\n    return anchor.href;\n  });\n  /**\n   * Gets a DOM element or document and a selctor and returns the found matches\n   * Can be extended with jQuery/Sizzle for IE7 support\n   * @param context\n   * @param sel\n   * @returns {NodeList|Array}\n   */\n\n  pf.qsa = function (context, sel) {\n    return \"querySelector\" in context ? context.querySelectorAll(sel) : [];\n  };\n  /**\n   * Shortcut method for matchMedia ( for easy overriding in tests )\n   * wether native or pf.mMQ is used will be decided lazy on first call\n   * @returns {boolean}\n   */\n\n\n  pf.matchesMedia = function () {\n    if (window.matchMedia && (matchMedia(\"(min-width: 0.1em)\") || {}).matches) {\n      pf.matchesMedia = function (media) {\n        return !media || matchMedia(media).matches;\n      };\n    } else {\n      pf.matchesMedia = pf.mMQ;\n    }\n\n    return pf.matchesMedia.apply(this, arguments);\n  };\n  /**\n   * A simplified matchMedia implementation for IE8 and IE9\n   * handles only min-width/max-width with px or em values\n   * @param media\n   * @returns {boolean}\n   */\n\n\n  pf.mMQ = function (media) {\n    return media ? evalCSS(media) : true;\n  };\n  /**\n   * Returns the calculated length in css pixel from the given sourceSizeValue\n   * http://dev.w3.org/csswg/css-values-3/#length-value\n   * intended Spec mismatches:\n   * * Does not check for invalid use of CSS functions\n   * * Does handle a computed length of 0 the same as a negative and therefore invalid value\n   * @param sourceSizeValue\n   * @returns {Number}\n   */\n\n\n  pf.calcLength = function (sourceSizeValue) {\n    var value = evalCSS(sourceSizeValue, true) || false;\n\n    if (value < 0) {\n      value = false;\n    }\n\n    return value;\n  };\n  /**\n   * Takes a type string and checks if its supported\n   */\n\n\n  pf.supportsType = function (type) {\n    return type ? types[type] : true;\n  };\n  /**\n   * Parses a sourceSize into mediaCondition (media) and sourceSizeValue (length)\n   * @param sourceSizeStr\n   * @returns {*}\n   */\n\n\n  pf.parseSize = memoize(function (sourceSizeStr) {\n    var match = (sourceSizeStr || \"\").match(regSize);\n    return {\n      media: match && match[1],\n      length: match && match[2]\n    };\n  });\n\n  pf.parseSet = function (set) {\n    if (!set.cands) {\n      set.cands = parseSrcset(set.srcset, set);\n    }\n\n    return set.cands;\n  };\n  /**\n   * returns 1em in css px for html/body default size\n   * function taken from respondjs\n   * @returns {*|number}\n   */\n\n\n  pf.getEmValue = function () {\n    var body;\n\n    if (!eminpx && (body = document.body)) {\n      var div = document.createElement(\"div\"),\n          originalHTMLCSS = docElem.style.cssText,\n          originalBodyCSS = body.style.cssText;\n      div.style.cssText = baseStyle; // 1em in a media query is the value of the default font size of the browser\n      // reset docElem and body to ensure the correct value is returned\n\n      docElem.style.cssText = fsCss;\n      body.style.cssText = fsCss;\n      body.appendChild(div);\n      eminpx = div.offsetWidth;\n      body.removeChild(div); //also update eminpx before returning\n\n      eminpx = parseFloat(eminpx, 10); // restore the original values\n\n      docElem.style.cssText = originalHTMLCSS;\n      body.style.cssText = originalBodyCSS;\n    }\n\n    return eminpx || 16;\n  };\n  /**\n   * Takes a string of sizes and returns the width in pixels as a number\n   */\n\n\n  pf.calcListLength = function (sourceSizeListStr) {\n    // Split up source size list, ie ( max-width: 30em ) 100%, ( max-width: 50em ) 50%, 33%\n    //\n    //                           or (min-width:30em) calc(30% - 15px)\n    if (!(sourceSizeListStr in sizeLengthCache) || cfg.uT) {\n      var winningLength = pf.calcLength(parseSizes(sourceSizeListStr));\n      sizeLengthCache[sourceSizeListStr] = !winningLength ? units.width : winningLength;\n    }\n\n    return sizeLengthCache[sourceSizeListStr];\n  };\n  /**\n   * Takes a candidate object with a srcset property in the form of url/\n   * ex. \"images/pic-medium.png 1x, images/pic-medium-2x.png 2x\" or\n   *     \"images/pic-medium.png 400w, images/pic-medium-2x.png 800w\" or\n   *     \"images/pic-small.png\"\n   * Get an array of image candidates in the form of\n   *      {url: \"/foo/bar.png\", resolution: 1}\n   * where resolution is http://dev.w3.org/csswg/css-values-3/#resolution-value\n   * If sizes is specified, res is calculated\n   */\n\n\n  pf.setRes = function (set) {\n    var candidates;\n\n    if (set) {\n      candidates = pf.parseSet(set);\n\n      for (var i = 0, len = candidates.length; i < len; i++) {\n        setResolution(candidates[i], set.sizes);\n      }\n    }\n\n    return candidates;\n  };\n\n  pf.setRes.res = setResolution;\n\n  pf.applySetCandidate = function (candidates, img) {\n    if (!candidates.length) {\n      return;\n    }\n\n    var candidate, i, j, length, bestCandidate, curSrc, curCan, candidateSrc, abortCurSrc;\n    var imageData = img[pf.ns];\n    var dpr = pf.DPR;\n    curSrc = imageData.curSrc || img[curSrcProp];\n    curCan = imageData.curCan || setSrcToCur(img, curSrc, candidates[0].set); // if we have a current source, we might either become lazy or give this source some advantage\n\n    if (curCan && curCan.set === candidates[0].set) {\n      // if browser can abort image request and the image has a higher pixel density than needed\n      // and this image isn't downloaded yet, we skip next part and try to save bandwidth\n      abortCurSrc = supportAbort && !img.complete && curCan.res - 0.1 > dpr;\n\n      if (!abortCurSrc) {\n        curCan.cached = true; // if current candidate is \"best\", \"better\" or \"okay\",\n        // set it to bestCandidate\n\n        if (curCan.res >= dpr) {\n          bestCandidate = curCan;\n        }\n      }\n    }\n\n    if (!bestCandidate) {\n      candidates.sort(ascendingSort);\n      length = candidates.length;\n      bestCandidate = candidates[length - 1];\n\n      for (i = 0; i < length; i++) {\n        candidate = candidates[i];\n\n        if (candidate.res >= dpr) {\n          j = i - 1; // we have found the perfect candidate,\n          // but let's improve this a little bit with some assumptions ;-)\n\n          if (candidates[j] && (abortCurSrc || curSrc !== pf.makeUrl(candidate.url)) && chooseLowRes(candidates[j].res, candidate.res, dpr, candidates[j].cached)) {\n            bestCandidate = candidates[j];\n          } else {\n            bestCandidate = candidate;\n          }\n\n          break;\n        }\n      }\n    }\n\n    if (bestCandidate) {\n      candidateSrc = pf.makeUrl(bestCandidate.url);\n      imageData.curSrc = candidateSrc;\n      imageData.curCan = bestCandidate;\n\n      if (candidateSrc !== curSrc) {\n        pf.setSrc(img, bestCandidate);\n      }\n\n      pf.setSize(img);\n    }\n  };\n\n  pf.setSrc = function (img, bestCandidate) {\n    var origWidth;\n    img.src = bestCandidate.url; // although this is a specific Safari issue, we don't want to take too much different code paths\n\n    if (bestCandidate.set.type === \"image/svg+xml\") {\n      origWidth = img.style.width;\n      img.style.width = img.offsetWidth + 1 + \"px\"; // next line only should trigger a repaint\n      // if... is only done to trick dead code removal\n\n      if (img.offsetWidth + 1) {\n        img.style.width = origWidth;\n      }\n    }\n  };\n\n  pf.getSet = function (img) {\n    var i, set, supportsType;\n    var match = false;\n    var sets = img[pf.ns].sets;\n\n    for (i = 0; i < sets.length && !match; i++) {\n      set = sets[i];\n\n      if (!set.srcset || !pf.matchesMedia(set.media) || !(supportsType = pf.supportsType(set.type))) {\n        continue;\n      }\n\n      if (supportsType === \"pending\") {\n        set = supportsType;\n      }\n\n      match = set;\n      break;\n    }\n\n    return match;\n  };\n\n  pf.parseSets = function (element, parent, options) {\n    var srcsetAttribute, imageSet, isWDescripor, srcsetParsed;\n    var hasPicture = parent && parent.nodeName.toUpperCase() === \"PICTURE\";\n    var imageData = element[pf.ns];\n\n    if (imageData.src === undefined || options.src) {\n      imageData.src = getImgAttr.call(element, \"src\");\n\n      if (imageData.src) {\n        setImgAttr.call(element, srcAttr, imageData.src);\n      } else {\n        removeImgAttr.call(element, srcAttr);\n      }\n    }\n\n    if (imageData.srcset === undefined || options.srcset || !pf.supSrcset || element.srcset) {\n      srcsetAttribute = getImgAttr.call(element, \"srcset\");\n      imageData.srcset = srcsetAttribute;\n      srcsetParsed = true;\n    }\n\n    imageData.sets = [];\n\n    if (hasPicture) {\n      imageData.pic = true;\n      getAllSourceElements(parent, imageData.sets);\n    }\n\n    if (imageData.srcset) {\n      imageSet = {\n        srcset: imageData.srcset,\n        sizes: getImgAttr.call(element, \"sizes\")\n      };\n      imageData.sets.push(imageSet);\n      isWDescripor = (alwaysCheckWDescriptor || imageData.src) && regWDesc.test(imageData.srcset || \"\"); // add normal src as candidate, if source has no w descriptor\n\n      if (!isWDescripor && imageData.src && !getCandidateForSrc(imageData.src, imageSet) && !imageSet.has1x) {\n        imageSet.srcset += \", \" + imageData.src;\n        imageSet.cands.push({\n          url: imageData.src,\n          d: 1,\n          set: imageSet\n        });\n      }\n    } else if (imageData.src) {\n      imageData.sets.push({\n        srcset: imageData.src,\n        sizes: null\n      });\n    }\n\n    imageData.curCan = null;\n    imageData.curSrc = undefined; // if img has picture or the srcset was removed or has a srcset and does not support srcset at all\n    // or has a w descriptor (and does not support sizes) set support to false to evaluate\n\n    imageData.supported = !(hasPicture || imageSet && !pf.supSrcset || isWDescripor && !pf.supSizes);\n\n    if (srcsetParsed && pf.supSrcset && !imageData.supported) {\n      if (srcsetAttribute) {\n        setImgAttr.call(element, srcsetAttr, srcsetAttribute);\n        element.srcset = \"\";\n      } else {\n        removeImgAttr.call(element, srcsetAttr);\n      }\n    }\n\n    if (imageData.supported && !imageData.srcset && (!imageData.src && element.src || element.src !== pf.makeUrl(imageData.src))) {\n      if (imageData.src === null) {\n        element.removeAttribute(\"src\");\n      } else {\n        element.src = imageData.src;\n      }\n    }\n\n    imageData.parsed = true;\n  };\n\n  pf.fillImg = function (element, options) {\n    var imageData;\n    var extreme = options.reselect || options.reevaluate; // expando for caching data on the img\n\n    if (!element[pf.ns]) {\n      element[pf.ns] = {};\n    }\n\n    imageData = element[pf.ns]; // if the element has already been evaluated, skip it\n    // unless `options.reevaluate` is set to true ( this, for example,\n    // is set to true when running `picturefill` on `resize` ).\n\n    if (!extreme && imageData.evaled === evalId) {\n      return;\n    }\n\n    if (!imageData.parsed || options.reevaluate) {\n      pf.parseSets(element, element.parentNode, options);\n    }\n\n    if (!imageData.supported) {\n      applyBestCandidate(element);\n    } else {\n      imageData.evaled = evalId;\n    }\n  };\n\n  pf.setupRun = function () {\n    if (!alreadyRun || isVwDirty || DPR !== window.devicePixelRatio) {\n      updateMetrics();\n    }\n  }; // If picture is supported, well, that's awesome.\n\n\n  if (pf.supPicture) {\n    picturefill = noop;\n    pf.fillImg = noop;\n  } else {\n    // Set up picture polyfill by polling the document\n    (function () {\n      var isDomReady;\n      var regReady = window.attachEvent ? /d$|^c/ : /d$|^c|^i/;\n\n      var run = function run() {\n        var readyState = document.readyState || \"\";\n        timerId = setTimeout(run, readyState === \"loading\" ? 200 : 999);\n\n        if (document.body) {\n          pf.fillImgs();\n          isDomReady = isDomReady || regReady.test(readyState);\n\n          if (isDomReady) {\n            clearTimeout(timerId);\n          }\n        }\n      };\n\n      var timerId = setTimeout(run, document.body ? 9 : 99); // Also attach picturefill on resize and readystatechange\n      // http://modernjavascript.blogspot.com/2013/08/building-better-debounce.html\n\n      var debounce = function debounce(func, wait) {\n        var timeout, timestamp;\n\n        var later = function later() {\n          var last = new Date() - timestamp;\n\n          if (last < wait) {\n            timeout = setTimeout(later, wait - last);\n          } else {\n            timeout = null;\n            func();\n          }\n        };\n\n        return function () {\n          timestamp = new Date();\n\n          if (!timeout) {\n            timeout = setTimeout(later, wait);\n          }\n        };\n      };\n\n      var lastClientWidth = docElem.clientHeight;\n\n      var onResize = function onResize() {\n        isVwDirty = Math.max(window.innerWidth || 0, docElem.clientWidth) !== units.width || docElem.clientHeight !== lastClientWidth;\n        lastClientWidth = docElem.clientHeight;\n\n        if (isVwDirty) {\n          pf.fillImgs();\n        }\n      };\n\n      on(window, \"resize\", debounce(onResize, 99));\n      on(document, \"readystatechange\", run);\n    })();\n  }\n\n  pf.picturefill = picturefill; //use this internally for easy monkey patching/performance testing\n\n  pf.fillImgs = picturefill;\n  pf.teardownRun = noop;\n  /* expose methods for testing */\n\n  picturefill._ = pf;\n  window.picturefillCFG = {\n    pf: pf,\n    push: function push(args) {\n      var name = args.shift();\n\n      if (typeof pf[name] === \"function\") {\n        pf[name].apply(pf, args);\n      } else {\n        cfg[name] = args[0];\n\n        if (alreadyRun) {\n          pf.fillImgs({\n            reselect: true\n          });\n        }\n      }\n    }\n  };\n\n  while (setOptions && setOptions.length) {\n    window.picturefillCFG.push(setOptions.shift());\n  }\n  /* expose picturefill */\n\n\n  window.picturefill = picturefill;\n  /* expose picturefill */\n\n  if (( false ? undefined : _typeof(module)) === \"object\" && _typeof(module.exports) === \"object\") {\n    // CommonJS, just export\n    module.exports = picturefill;\n  } else if (true) {\n    // AMD support\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n      return picturefill;\n    }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } // IE8 evals this sync, so it must be the last thing we do\n\n\n  if (!pf.supPicture) {\n    types[\"image/webp\"] = detectTypeSupport(\"image/webp\", \"data:image/webp;base64,UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAABBxAR/Q9ERP8DAABWUDggGAAAADABAJ0BKgEAAQADADQlpAADcAD++/1QAA==\");\n  }\n})(window, document);\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcGljdHVyZWZpbGwvZGlzdC9waWN0dXJlZmlsbC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9waWN0dXJlZmlsbC9kaXN0L3BpY3R1cmVmaWxsLmpzP2VlYzgiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIHBpY3R1cmVmaWxsIC0gdjMuMC4yIC0gMjAxNi0wMi0xMlxuICogaHR0cHM6Ly9zY290dGplaGwuZ2l0aHViLmlvL3BpY3R1cmVmaWxsL1xuICogQ29weXJpZ2h0IChjKSAyMDE2IGh0dHBzOi8vZ2l0aHViLmNvbS9zY290dGplaGwvcGljdHVyZWZpbGwvYmxvYi9tYXN0ZXIvQXV0aG9ycy50eHQ7IExpY2Vuc2VkIE1JVFxuICovXG4vKiEgR2Vja28tUGljdHVyZSAtIHYxLjBcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zY290dGplaGwvcGljdHVyZWZpbGwvdHJlZS8zLjAvc3JjL3BsdWdpbnMvZ2Vja28tcGljdHVyZVxuICogRmlyZWZveCdzIGVhcmx5IHBpY3R1cmUgaW1wbGVtZW50YXRpb24gKHByaW9yIHRvIEZGNDEpIGlzIHN0YXRpYyBhbmQgZG9lc1xuICogbm90IHJlYWN0IHRvIHZpZXdwb3J0IGNoYW5nZXMuIFRoaXMgdGlueSBtb2R1bGUgZml4ZXMgdGhpcy5cbiAqL1xuKGZ1bmN0aW9uKHdpbmRvdykge1xuXHQvKmpzaGludCBlcW51bGw6dHJ1ZSAqL1xuXHR2YXIgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuXG5cdGlmICggd2luZG93LkhUTUxQaWN0dXJlRWxlbWVudCAmJiAoKC9lY2tvLykudGVzdCh1YSkgJiYgdWEubWF0Y2goL3J2XFw6KFxcZCspLykgJiYgUmVnRXhwLiQxIDwgNDUpICkge1xuXHRcdGFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHRpbWVyO1xuXG5cdFx0XHR2YXIgZHVtbXlTcmMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic291cmNlXCIpO1xuXG5cdFx0XHR2YXIgZml4UmVzcGltZyA9IGZ1bmN0aW9uKGltZykge1xuXHRcdFx0XHR2YXIgc291cmNlLCBzaXplcztcblx0XHRcdFx0dmFyIHBpY3R1cmUgPSBpbWcucGFyZW50Tm9kZTtcblxuXHRcdFx0XHRpZiAocGljdHVyZS5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09PSBcIlBJQ1RVUkVcIikge1xuXHRcdFx0XHRcdHNvdXJjZSA9IGR1bW15U3JjLmNsb25lTm9kZSgpO1xuXG5cdFx0XHRcdFx0cGljdHVyZS5pbnNlcnRCZWZvcmUoc291cmNlLCBwaWN0dXJlLmZpcnN0RWxlbWVudENoaWxkKTtcblx0XHRcdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cGljdHVyZS5yZW1vdmVDaGlsZChzb3VyY2UpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCFpbWcuX3BmTGFzdFNpemUgfHwgaW1nLm9mZnNldFdpZHRoID4gaW1nLl9wZkxhc3RTaXplKSB7XG5cdFx0XHRcdFx0aW1nLl9wZkxhc3RTaXplID0gaW1nLm9mZnNldFdpZHRoO1xuXHRcdFx0XHRcdHNpemVzID0gaW1nLnNpemVzO1xuXHRcdFx0XHRcdGltZy5zaXplcyArPSBcIiwxMDB2d1wiO1xuXHRcdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRpbWcuc2l6ZXMgPSBzaXplcztcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0dmFyIGZpbmRQaWN0dXJlSW1ncyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgaTtcblx0XHRcdFx0dmFyIGltZ3MgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwicGljdHVyZSA+IGltZywgaW1nW3NyY3NldF1bc2l6ZXNdXCIpO1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgaW1ncy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGZpeFJlc3BpbWcoaW1nc1tpXSk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHR2YXIgb25SZXNpemUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRpbWVyKTtcblx0XHRcdFx0dGltZXIgPSBzZXRUaW1lb3V0KGZpbmRQaWN0dXJlSW1ncywgOTkpO1xuXHRcdFx0fTtcblx0XHRcdHZhciBtcSA9IHdpbmRvdy5tYXRjaE1lZGlhICYmIG1hdGNoTWVkaWEoXCIob3JpZW50YXRpb246IGxhbmRzY2FwZSlcIik7XG5cdFx0XHR2YXIgaW5pdCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRvblJlc2l6ZSgpO1xuXG5cdFx0XHRcdGlmIChtcSAmJiBtcS5hZGRMaXN0ZW5lcikge1xuXHRcdFx0XHRcdG1xLmFkZExpc3RlbmVyKG9uUmVzaXplKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0ZHVtbXlTcmMuc3Jjc2V0ID0gXCJkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBUUFCQUFBQUFDSDVCQUVLQUFFQUxBQUFBQUFCQUFFQUFBSUNUQUVBT3c9PVwiO1xuXG5cdFx0XHRpZiAoL15bY3xpXXxkJC8udGVzdChkb2N1bWVudC5yZWFkeVN0YXRlIHx8IFwiXCIpKSB7XG5cdFx0XHRcdGluaXQoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsIGluaXQpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gb25SZXNpemU7XG5cdFx0fSkoKSk7XG5cdH1cbn0pKHdpbmRvdyk7XG5cbi8qISBQaWN0dXJlZmlsbCAtIHYzLjAuMlxuICogaHR0cDovL3Njb3R0amVobC5naXRodWIuaW8vcGljdHVyZWZpbGxcbiAqIENvcHlyaWdodCAoYykgMjAxNSBodHRwczovL2dpdGh1Yi5jb20vc2NvdHRqZWhsL3BpY3R1cmVmaWxsL2Jsb2IvbWFzdGVyL0F1dGhvcnMudHh0O1xuICogIExpY2Vuc2U6IE1JVFxuICovXG5cbihmdW5jdGlvbiggd2luZG93LCBkb2N1bWVudCwgdW5kZWZpbmVkICkge1xuXHQvLyBFbmFibGUgc3RyaWN0IG1vZGVcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Ly8gSFRNTCBzaGltfHYgaXQgZm9yIG9sZCBJRSAoSUU5IHdpbGwgc3RpbGwgbmVlZCB0aGUgSFRNTCB2aWRlbyB0YWcgd29ya2Fyb3VuZClcblx0ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJwaWN0dXJlXCIgKTtcblxuXHR2YXIgd2FybiwgZW1pbnB4LCBhbHdheXNDaGVja1dEZXNjcmlwdG9yLCBldmFsSWQ7XG5cdC8vIGxvY2FsIG9iamVjdCBmb3IgbWV0aG9kIHJlZmVyZW5jZXMgYW5kIHRlc3RpbmcgZXhwb3N1cmVcblx0dmFyIHBmID0ge307XG5cdHZhciBpc1N1cHBvcnRUZXN0UmVhZHkgPSBmYWxzZTtcblx0dmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9O1xuXHR2YXIgaW1hZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImltZ1wiICk7XG5cdHZhciBnZXRJbWdBdHRyID0gaW1hZ2UuZ2V0QXR0cmlidXRlO1xuXHR2YXIgc2V0SW1nQXR0ciA9IGltYWdlLnNldEF0dHJpYnV0ZTtcblx0dmFyIHJlbW92ZUltZ0F0dHIgPSBpbWFnZS5yZW1vdmVBdHRyaWJ1dGU7XG5cdHZhciBkb2NFbGVtID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXHR2YXIgdHlwZXMgPSB7fTtcblx0dmFyIGNmZyA9IHtcblx0XHQvL3Jlc291cmNlIHNlbGVjdGlvbjpcblx0XHRhbGdvcml0aG06IFwiXCJcblx0fTtcblx0dmFyIHNyY0F0dHIgPSBcImRhdGEtcGZzcmNcIjtcblx0dmFyIHNyY3NldEF0dHIgPSBzcmNBdHRyICsgXCJzZXRcIjtcblx0Ly8gdWEgc25pZmZpbmcgaXMgZG9uZSBmb3IgdW5kZXRlY3RhYmxlIGltZyBsb2FkaW5nIGZlYXR1cmVzLFxuXHQvLyB0byBkbyBzb21lIG5vbiBjcnVjaWFsIHBlcmYgb3B0aW1pemF0aW9uc1xuXHR2YXIgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuXHR2YXIgc3VwcG9ydEFib3J0ID0gKC9yaWRlbnQvKS50ZXN0KHVhKSB8fCAoKC9lY2tvLykudGVzdCh1YSkgJiYgdWEubWF0Y2goL3J2XFw6KFxcZCspLykgJiYgUmVnRXhwLiQxID4gMzUgKTtcblx0dmFyIGN1clNyY1Byb3AgPSBcImN1cnJlbnRTcmNcIjtcblx0dmFyIHJlZ1dEZXNjID0gL1xccytcXCs/XFxkKyhlXFxkKyk/dy87XG5cdHZhciByZWdTaXplID0gLyhcXChbXildK1xcKSk/XFxzKiguKykvO1xuXHR2YXIgc2V0T3B0aW9ucyA9IHdpbmRvdy5waWN0dXJlZmlsbENGRztcblx0LyoqXG5cdCAqIFNob3J0Y3V0IHByb3BlcnR5IGZvciBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjL3NwZWNzL21peGVkY29udGVudC8jcmVzdHJpY3RzLW1peGVkLWNvbnRlbnQgKCBmb3IgZWFzeSBvdmVycmlkaW5nIGluIHRlc3RzIClcblx0ICovXG5cdC8vIGJhc2VTdHlsZSBhbHNvIHVzZWQgYnkgZ2V0RW1WYWx1ZSAoaS5lLjogd2lkdGg6IDFlbSBpcyBpbXBvcnRhbnQpXG5cdHZhciBiYXNlU3R5bGUgPSBcInBvc2l0aW9uOmFic29sdXRlO2xlZnQ6MDt2aXNpYmlsaXR5OmhpZGRlbjtkaXNwbGF5OmJsb2NrO3BhZGRpbmc6MDtib3JkZXI6bm9uZTtmb250LXNpemU6MWVtO3dpZHRoOjFlbTtvdmVyZmxvdzpoaWRkZW47Y2xpcDpyZWN0KDBweCwgMHB4LCAwcHgsIDBweClcIjtcblx0dmFyIGZzQ3NzID0gXCJmb250LXNpemU6MTAwJSFpbXBvcnRhbnQ7XCI7XG5cdHZhciBpc1Z3RGlydHkgPSB0cnVlO1xuXG5cdHZhciBjc3NDYWNoZSA9IHt9O1xuXHR2YXIgc2l6ZUxlbmd0aENhY2hlID0ge307XG5cdHZhciBEUFIgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcblx0dmFyIHVuaXRzID0ge1xuXHRcdHB4OiAxLFxuXHRcdFwiaW5cIjogOTZcblx0fTtcblx0dmFyIGFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cdC8qKlxuXHQgKiBhbHJlYWR5UnVuIGZsYWcgdXNlZCBmb3Igc2V0T3B0aW9ucy4gaXMgaXQgdHJ1ZSBzZXRPcHRpb25zIHdpbGwgcmVldmFsdWF0ZVxuXHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0ICovXG5cdHZhciBhbHJlYWR5UnVuID0gZmFsc2U7XG5cblx0Ly8gUmV1c2FibGUsIG5vbi1cImdcIiBSZWdleGVzXG5cblx0Ly8gKERvbid0IHVzZSBcXHMsIHRvIGF2b2lkIG1hdGNoaW5nIG5vbi1icmVha2luZyBzcGFjZS4pXG5cdHZhciByZWdleExlYWRpbmdTcGFjZXMgPSAvXlsgXFx0XFxuXFxyXFx1MDAwY10rLyxcblx0ICAgIHJlZ2V4TGVhZGluZ0NvbW1hc09yU3BhY2VzID0gL15bLCBcXHRcXG5cXHJcXHUwMDBjXSsvLFxuXHQgICAgcmVnZXhMZWFkaW5nTm90U3BhY2VzID0gL15bXiBcXHRcXG5cXHJcXHUwMDBjXSsvLFxuXHQgICAgcmVnZXhUcmFpbGluZ0NvbW1hcyA9IC9bLF0rJC8sXG5cdCAgICByZWdleE5vbk5lZ2F0aXZlSW50ZWdlciA9IC9eXFxkKyQvLFxuXG5cdCAgICAvLyAoIFBvc2l0aXZlIG9yIG5lZ2F0aXZlIG9yIHVuc2lnbmVkIGludGVnZXJzIG9yIGRlY2ltYWxzLCB3aXRob3V0IG9yIHdpdGhvdXQgZXhwb25lbnRzLlxuXHQgICAgLy8gTXVzdCBpbmNsdWRlIGF0IGxlYXN0IG9uZSBkaWdpdC5cblx0ICAgIC8vIEFjY29yZGluZyB0byBzcGVjIHRlc3RzIGFueSBkZWNpbWFsIHBvaW50IG11c3QgYmUgZm9sbG93ZWQgYnkgYSBkaWdpdC5cblx0ICAgIC8vIE5vIGxlYWRpbmcgcGx1cyBzaWduIGlzIGFsbG93ZWQuKVxuXHQgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5mcmFzdHJ1Y3R1cmUuaHRtbCN2YWxpZC1mbG9hdGluZy1wb2ludC1udW1iZXJcblx0ICAgIHJlZ2V4RmxvYXRpbmdQb2ludCA9IC9eLT8oPzpbMC05XSt8WzAtOV0qXFwuWzAtOV0rKSg/OltlRV1bKy1dP1swLTldKyk/JC87XG5cblx0dmFyIG9uID0gZnVuY3Rpb24ob2JqLCBldnQsIGZuLCBjYXB0dXJlKSB7XG5cdFx0aWYgKCBvYmouYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdG9iai5hZGRFdmVudExpc3RlbmVyKGV2dCwgZm4sIGNhcHR1cmUgfHwgZmFsc2UpO1xuXHRcdH0gZWxzZSBpZiAoIG9iai5hdHRhY2hFdmVudCApIHtcblx0XHRcdG9iai5hdHRhY2hFdmVudCggXCJvblwiICsgZXZ0LCBmbik7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBzaW1wbGUgbWVtb2l6ZSBmdW5jdGlvbjpcblx0ICovXG5cblx0dmFyIG1lbW9pemUgPSBmdW5jdGlvbihmbikge1xuXHRcdHZhciBjYWNoZSA9IHt9O1xuXHRcdHJldHVybiBmdW5jdGlvbihpbnB1dCkge1xuXHRcdFx0aWYgKCAhKGlucHV0IGluIGNhY2hlKSApIHtcblx0XHRcdFx0Y2FjaGVbIGlucHV0IF0gPSBmbihpbnB1dCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY2FjaGVbIGlucHV0IF07XG5cdFx0fTtcblx0fTtcblxuXHQvLyBVVElMSVRZIEZVTkNUSU9OU1xuXG5cdC8vIE1hbnVhbCBpcyBmYXN0ZXIgdGhhbiBSZWdFeFxuXHQvLyBodHRwOi8vanNwZXJmLmNvbS93aGl0ZXNwYWNlLWNoYXJhY3Rlci81XG5cdGZ1bmN0aW9uIGlzU3BhY2UoYykge1xuXHRcdHJldHVybiAoYyA9PT0gXCJcXHUwMDIwXCIgfHwgLy8gc3BhY2Vcblx0XHQgICAgICAgIGMgPT09IFwiXFx1MDAwOVwiIHx8IC8vIGhvcml6b250YWwgdGFiXG5cdFx0ICAgICAgICBjID09PSBcIlxcdTAwMEFcIiB8fCAvLyBuZXcgbGluZVxuXHRcdCAgICAgICAgYyA9PT0gXCJcXHUwMDBDXCIgfHwgLy8gZm9ybSBmZWVkXG5cdFx0ICAgICAgICBjID09PSBcIlxcdTAwMERcIik7ICAvLyBjYXJyaWFnZSByZXR1cm5cblx0fVxuXG5cdC8qKlxuXHQgKiBnZXRzIGEgbWVkaWFxdWVyeSBhbmQgcmV0dXJucyBhIGJvb2xlYW4gb3IgZ2V0cyBhIGNzcyBsZW5ndGggYW5kIHJldHVybnMgYSBudW1iZXJcblx0ICogQHBhcmFtIGNzcyBtZWRpYXF1ZXJpZXMgb3IgY3NzIGxlbmd0aFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbnxudW1iZXJ9XG5cdCAqXG5cdCAqIGJhc2VkIG9uOiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9qb25hdGhhbnRuZWFsL2RiNGY3NzAwOWIxNTVmMDgzNzM4XG5cdCAqL1xuXHR2YXIgZXZhbENTUyA9IChmdW5jdGlvbigpIHtcblxuXHRcdHZhciByZWdMZW5ndGggPSAvXihbXFxkXFwuXSspKGVtfHZ3fHB4KSQvO1xuXHRcdHZhciByZXBsYWNlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgYXJncyA9IGFyZ3VtZW50cywgaW5kZXggPSAwLCBzdHJpbmcgPSBhcmdzWzBdO1xuXHRcdFx0d2hpbGUgKCsraW5kZXggaW4gYXJncykge1xuXHRcdFx0XHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShhcmdzW2luZGV4XSwgYXJnc1srK2luZGV4XSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gc3RyaW5nO1xuXHRcdH07XG5cblx0XHR2YXIgYnVpbGRTdHIgPSBtZW1vaXplKGZ1bmN0aW9uKGNzcykge1xuXG5cdFx0XHRyZXR1cm4gXCJyZXR1cm4gXCIgKyByZXBsYWNlKChjc3MgfHwgXCJcIikudG9Mb3dlckNhc2UoKSxcblx0XHRcdFx0Ly8gaW50ZXJwcmV0IGBhbmRgXG5cdFx0XHRcdC9cXGJhbmRcXGIvZywgXCImJlwiLFxuXG5cdFx0XHRcdC8vIGludGVycHJldCBgLGBcblx0XHRcdFx0LywvZywgXCJ8fFwiLFxuXG5cdFx0XHRcdC8vIGludGVycHJldCBgbWluLWAgYXMgPj1cblx0XHRcdFx0L21pbi0oW2Etei1cXHNdKyk6L2csIFwiZS4kMT49XCIsXG5cblx0XHRcdFx0Ly8gaW50ZXJwcmV0IGBtYXgtYCBhcyA8PVxuXHRcdFx0XHQvbWF4LShbYS16LVxcc10rKTovZywgXCJlLiQxPD1cIixcblxuXHRcdFx0XHQvL2NhbGMgdmFsdWVcblx0XHRcdFx0L2NhbGMoW14pXSspL2csIFwiKCQxKVwiLFxuXG5cdFx0XHRcdC8vIGludGVycHJldCBjc3MgdmFsdWVzXG5cdFx0XHRcdC8oXFxkK1tcXC5dKltcXGRdKikoW2Etel0rKS9nLCBcIigkMSAqIGUuJDIpXCIsXG5cdFx0XHRcdC8vbWFrZSBldmFsIGxlc3MgZXZpbFxuXHRcdFx0XHQvXig/IShlLlthLXpdfFswLTlcXC4mPXw+PFxcK1xcLVxcKlxcKFxcKVxcL10pKS4qL2lnLCBcIlwiXG5cdFx0XHQpICsgXCI7XCI7XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oY3NzLCBsZW5ndGgpIHtcblx0XHRcdHZhciBwYXJzZWRMZW5ndGg7XG5cdFx0XHRpZiAoIShjc3MgaW4gY3NzQ2FjaGUpKSB7XG5cdFx0XHRcdGNzc0NhY2hlW2Nzc10gPSBmYWxzZTtcblx0XHRcdFx0aWYgKGxlbmd0aCAmJiAocGFyc2VkTGVuZ3RoID0gY3NzLm1hdGNoKCByZWdMZW5ndGggKSkpIHtcblx0XHRcdFx0XHRjc3NDYWNoZVtjc3NdID0gcGFyc2VkTGVuZ3RoWyAxIF0gKiB1bml0c1twYXJzZWRMZW5ndGhbIDIgXV07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Lypqc2hpbnQgZXZpbDp0cnVlICovXG5cdFx0XHRcdFx0dHJ5e1xuXHRcdFx0XHRcdFx0Y3NzQ2FjaGVbY3NzXSA9IG5ldyBGdW5jdGlvbihcImVcIiwgYnVpbGRTdHIoY3NzKSkodW5pdHMpO1xuXHRcdFx0XHRcdH0gY2F0Y2goZSkge31cblx0XHRcdFx0XHQvKmpzaGludCBldmlsOmZhbHNlICovXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBjc3NDYWNoZVtjc3NdO1xuXHRcdH07XG5cdH0pKCk7XG5cblx0dmFyIHNldFJlc29sdXRpb24gPSBmdW5jdGlvbiggY2FuZGlkYXRlLCBzaXplc2F0dHIgKSB7XG5cdFx0aWYgKCBjYW5kaWRhdGUudyApIHsgLy8gaCA9IG1lYW5zIGhlaWdodDogfHwgZGVzY3JpcHRvci50eXBlID09PSAnaCcgZG8gbm90IGhhbmRsZSB5ZXQuLi5cblx0XHRcdGNhbmRpZGF0ZS5jV2lkdGggPSBwZi5jYWxjTGlzdExlbmd0aCggc2l6ZXNhdHRyIHx8IFwiMTAwdndcIiApO1xuXHRcdFx0Y2FuZGlkYXRlLnJlcyA9IGNhbmRpZGF0ZS53IC8gY2FuZGlkYXRlLmNXaWR0aCA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNhbmRpZGF0ZS5yZXMgPSBjYW5kaWRhdGUuZDtcblx0XHR9XG5cdFx0cmV0dXJuIGNhbmRpZGF0ZTtcblx0fTtcblxuXHQvKipcblx0ICpcblx0ICogQHBhcmFtIG9wdFxuXHQgKi9cblx0dmFyIHBpY3R1cmVmaWxsID0gZnVuY3Rpb24oIG9wdCApIHtcblxuXHRcdGlmICghaXNTdXBwb3J0VGVzdFJlYWR5KSB7cmV0dXJuO31cblxuXHRcdHZhciBlbGVtZW50cywgaSwgcGxlbjtcblxuXHRcdHZhciBvcHRpb25zID0gb3B0IHx8IHt9O1xuXG5cdFx0aWYgKCBvcHRpb25zLmVsZW1lbnRzICYmIG9wdGlvbnMuZWxlbWVudHMubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRpZiAoIG9wdGlvbnMuZWxlbWVudHMubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PT0gXCJJTUdcIiApIHtcblx0XHRcdFx0b3B0aW9ucy5lbGVtZW50cyA9ICBbIG9wdGlvbnMuZWxlbWVudHMgXTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9wdGlvbnMuY29udGV4dCA9IG9wdGlvbnMuZWxlbWVudHM7XG5cdFx0XHRcdG9wdGlvbnMuZWxlbWVudHMgPSAgbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRlbGVtZW50cyA9IG9wdGlvbnMuZWxlbWVudHMgfHwgcGYucXNhKCAob3B0aW9ucy5jb250ZXh0IHx8IGRvY3VtZW50KSwgKCBvcHRpb25zLnJlZXZhbHVhdGUgfHwgb3B0aW9ucy5yZXNlbGVjdCApID8gcGYuc2VsIDogcGYuc2VsU2hvcnQgKTtcblxuXHRcdGlmICggKHBsZW4gPSBlbGVtZW50cy5sZW5ndGgpICkge1xuXG5cdFx0XHRwZi5zZXR1cFJ1biggb3B0aW9ucyApO1xuXHRcdFx0YWxyZWFkeVJ1biA9IHRydWU7XG5cblx0XHRcdC8vIExvb3AgdGhyb3VnaCBhbGwgZWxlbWVudHNcblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgcGxlbjsgaSsrICkge1xuXHRcdFx0XHRwZi5maWxsSW1nKGVsZW1lbnRzWyBpIF0sIG9wdGlvbnMpO1xuXHRcdFx0fVxuXG5cdFx0XHRwZi50ZWFyZG93blJ1biggb3B0aW9ucyApO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogb3V0cHV0cyBhIHdhcm5pbmcgZm9yIHRoZSBkZXZlbG9wZXJcblx0ICogQHBhcmFtIHttZXNzYWdlfVxuXHQgKiBAdHlwZSB7RnVuY3Rpb259XG5cdCAqL1xuXHR3YXJuID0gKCB3aW5kb3cuY29uc29sZSAmJiBjb25zb2xlLndhcm4gKSA/XG5cdFx0ZnVuY3Rpb24oIG1lc3NhZ2UgKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oIG1lc3NhZ2UgKTtcblx0XHR9IDpcblx0XHRub29wXG5cdDtcblxuXHRpZiAoICEoY3VyU3JjUHJvcCBpbiBpbWFnZSkgKSB7XG5cdFx0Y3VyU3JjUHJvcCA9IFwic3JjXCI7XG5cdH1cblxuXHQvLyBBZGQgc3VwcG9ydCBmb3Igc3RhbmRhcmQgbWltZSB0eXBlcy5cblx0dHlwZXNbIFwiaW1hZ2UvanBlZ1wiIF0gPSB0cnVlO1xuXHR0eXBlc1sgXCJpbWFnZS9naWZcIiBdID0gdHJ1ZTtcblx0dHlwZXNbIFwiaW1hZ2UvcG5nXCIgXSA9IHRydWU7XG5cblx0ZnVuY3Rpb24gZGV0ZWN0VHlwZVN1cHBvcnQoIHR5cGUsIHR5cGVVcmkgKSB7XG5cdFx0Ly8gYmFzZWQgb24gTW9kZXJuaXpyJ3MgbG9zc2xlc3MgaW1nLXdlYnAgdGVzdFxuXHRcdC8vIG5vdGU6IGFzeW5jaHJvbm91c1xuXHRcdHZhciBpbWFnZSA9IG5ldyB3aW5kb3cuSW1hZ2UoKTtcblx0XHRpbWFnZS5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR0eXBlc1sgdHlwZSBdID0gZmFsc2U7XG5cdFx0XHRwaWN0dXJlZmlsbCgpO1xuXHRcdH07XG5cdFx0aW1hZ2Uub25sb2FkID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR0eXBlc1sgdHlwZSBdID0gaW1hZ2Uud2lkdGggPT09IDE7XG5cdFx0XHRwaWN0dXJlZmlsbCgpO1xuXHRcdH07XG5cdFx0aW1hZ2Uuc3JjID0gdHlwZVVyaTtcblx0XHRyZXR1cm4gXCJwZW5kaW5nXCI7XG5cdH1cblxuXHQvLyB0ZXN0IHN2ZyBzdXBwb3J0XG5cdHR5cGVzWyBcImltYWdlL3N2Zyt4bWxcIiBdID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZSggXCJodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9mZWF0dXJlI0ltYWdlXCIsIFwiMS4xXCIgKTtcblxuXHQvKipcblx0ICogdXBkYXRlcyB0aGUgaW50ZXJuYWwgdlcgcHJvcGVydHkgd2l0aCB0aGUgY3VycmVudCB2aWV3cG9ydCB3aWR0aCBpbiBweFxuXHQgKi9cblx0ZnVuY3Rpb24gdXBkYXRlTWV0cmljcygpIHtcblxuXHRcdGlzVndEaXJ0eSA9IGZhbHNlO1xuXHRcdERQUiA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuXHRcdGNzc0NhY2hlID0ge307XG5cdFx0c2l6ZUxlbmd0aENhY2hlID0ge307XG5cblx0XHRwZi5EUFIgPSBEUFIgfHwgMTtcblxuXHRcdHVuaXRzLndpZHRoID0gTWF0aC5tYXgod2luZG93LmlubmVyV2lkdGggfHwgMCwgZG9jRWxlbS5jbGllbnRXaWR0aCk7XG5cdFx0dW5pdHMuaGVpZ2h0ID0gTWF0aC5tYXgod2luZG93LmlubmVySGVpZ2h0IHx8IDAsIGRvY0VsZW0uY2xpZW50SGVpZ2h0KTtcblxuXHRcdHVuaXRzLnZ3ID0gdW5pdHMud2lkdGggLyAxMDA7XG5cdFx0dW5pdHMudmggPSB1bml0cy5oZWlnaHQgLyAxMDA7XG5cblx0XHRldmFsSWQgPSBbIHVuaXRzLmhlaWdodCwgdW5pdHMud2lkdGgsIERQUiBdLmpvaW4oXCItXCIpO1xuXG5cdFx0dW5pdHMuZW0gPSBwZi5nZXRFbVZhbHVlKCk7XG5cdFx0dW5pdHMucmVtID0gdW5pdHMuZW07XG5cdH1cblxuXHRmdW5jdGlvbiBjaG9vc2VMb3dSZXMoIGxvd2VyVmFsdWUsIGhpZ2hlclZhbHVlLCBkcHJWYWx1ZSwgaXNDYWNoZWQgKSB7XG5cdFx0dmFyIGJvbnVzRmFjdG9yLCB0b29NdWNoLCBib251cywgbWVhbkRlbnNpdHk7XG5cblx0XHQvL2V4cGVyaW1lbnRhbFxuXHRcdGlmIChjZmcuYWxnb3JpdGhtID09PSBcInNhdmVEYXRhXCIgKXtcblx0XHRcdGlmICggbG93ZXJWYWx1ZSA+IDIuNyApIHtcblx0XHRcdFx0bWVhbkRlbnNpdHkgPSBkcHJWYWx1ZSArIDE7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0b29NdWNoID0gaGlnaGVyVmFsdWUgLSBkcHJWYWx1ZTtcblx0XHRcdFx0Ym9udXNGYWN0b3IgPSBNYXRoLnBvdyhsb3dlclZhbHVlIC0gMC42LCAxLjUpO1xuXG5cdFx0XHRcdGJvbnVzID0gdG9vTXVjaCAqIGJvbnVzRmFjdG9yO1xuXG5cdFx0XHRcdGlmIChpc0NhY2hlZCkge1xuXHRcdFx0XHRcdGJvbnVzICs9IDAuMSAqIGJvbnVzRmFjdG9yO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bWVhbkRlbnNpdHkgPSBsb3dlclZhbHVlICsgYm9udXM7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1lYW5EZW5zaXR5ID0gKGRwclZhbHVlID4gMSkgP1xuXHRcdFx0XHRNYXRoLnNxcnQobG93ZXJWYWx1ZSAqIGhpZ2hlclZhbHVlKSA6XG5cdFx0XHRcdGxvd2VyVmFsdWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1lYW5EZW5zaXR5ID4gZHByVmFsdWU7XG5cdH1cblxuXHRmdW5jdGlvbiBhcHBseUJlc3RDYW5kaWRhdGUoIGltZyApIHtcblx0XHR2YXIgc3JjU2V0Q2FuZGlkYXRlcztcblx0XHR2YXIgbWF0Y2hpbmdTZXQgPSBwZi5nZXRTZXQoIGltZyApO1xuXHRcdHZhciBldmFsdWF0ZWQgPSBmYWxzZTtcblx0XHRpZiAoIG1hdGNoaW5nU2V0ICE9PSBcInBlbmRpbmdcIiApIHtcblx0XHRcdGV2YWx1YXRlZCA9IGV2YWxJZDtcblx0XHRcdGlmICggbWF0Y2hpbmdTZXQgKSB7XG5cdFx0XHRcdHNyY1NldENhbmRpZGF0ZXMgPSBwZi5zZXRSZXMoIG1hdGNoaW5nU2V0ICk7XG5cdFx0XHRcdHBmLmFwcGx5U2V0Q2FuZGlkYXRlKCBzcmNTZXRDYW5kaWRhdGVzLCBpbWcgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aW1nWyBwZi5ucyBdLmV2YWxlZCA9IGV2YWx1YXRlZDtcblx0fVxuXG5cdGZ1bmN0aW9uIGFzY2VuZGluZ1NvcnQoIGEsIGIgKSB7XG5cdFx0cmV0dXJuIGEucmVzIC0gYi5yZXM7XG5cdH1cblxuXHRmdW5jdGlvbiBzZXRTcmNUb0N1ciggaW1nLCBzcmMsIHNldCApIHtcblx0XHR2YXIgY2FuZGlkYXRlO1xuXHRcdGlmICggIXNldCAmJiBzcmMgKSB7XG5cdFx0XHRzZXQgPSBpbWdbIHBmLm5zIF0uc2V0cztcblx0XHRcdHNldCA9IHNldCAmJiBzZXRbc2V0Lmxlbmd0aCAtIDFdO1xuXHRcdH1cblxuXHRcdGNhbmRpZGF0ZSA9IGdldENhbmRpZGF0ZUZvclNyYyhzcmMsIHNldCk7XG5cblx0XHRpZiAoIGNhbmRpZGF0ZSApIHtcblx0XHRcdHNyYyA9IHBmLm1ha2VVcmwoc3JjKTtcblx0XHRcdGltZ1sgcGYubnMgXS5jdXJTcmMgPSBzcmM7XG5cdFx0XHRpbWdbIHBmLm5zIF0uY3VyQ2FuID0gY2FuZGlkYXRlO1xuXG5cdFx0XHRpZiAoICFjYW5kaWRhdGUucmVzICkge1xuXHRcdFx0XHRzZXRSZXNvbHV0aW9uKCBjYW5kaWRhdGUsIGNhbmRpZGF0ZS5zZXQuc2l6ZXMgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNhbmRpZGF0ZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldENhbmRpZGF0ZUZvclNyYyggc3JjLCBzZXQgKSB7XG5cdFx0dmFyIGksIGNhbmRpZGF0ZSwgY2FuZGlkYXRlcztcblx0XHRpZiAoIHNyYyAmJiBzZXQgKSB7XG5cdFx0XHRjYW5kaWRhdGVzID0gcGYucGFyc2VTZXQoIHNldCApO1xuXHRcdFx0c3JjID0gcGYubWFrZVVybChzcmMpO1xuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBjYW5kaWRhdGVzLmxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIHNyYyA9PT0gcGYubWFrZVVybChjYW5kaWRhdGVzWyBpIF0udXJsKSApIHtcblx0XHRcdFx0XHRjYW5kaWRhdGUgPSBjYW5kaWRhdGVzWyBpIF07XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNhbmRpZGF0ZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldEFsbFNvdXJjZUVsZW1lbnRzKCBwaWN0dXJlLCBjYW5kaWRhdGVzICkge1xuXHRcdHZhciBpLCBsZW4sIHNvdXJjZSwgc3Jjc2V0O1xuXG5cdFx0Ly8gU1BFQyBtaXNtYXRjaCBpbnRlbmRlZCBmb3Igc2l6ZSBhbmQgcGVyZjpcblx0XHQvLyBhY3R1YWxseSBvbmx5IHNvdXJjZSBlbGVtZW50cyBwcmVjZWRpbmcgdGhlIGltZyBzaG91bGQgYmUgdXNlZFxuXHRcdC8vIGFsc28gbm90ZTogZG9uJ3QgdXNlIHFzYSBoZXJlLCBiZWNhdXNlIElFOCBzb21ldGltZXMgZG9lc24ndCBsaWtlIHNvdXJjZSBhcyB0aGUga2V5IHBhcnQgaW4gYSBzZWxlY3RvclxuXHRcdHZhciBzb3VyY2VzID0gcGljdHVyZS5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJzb3VyY2VcIiApO1xuXG5cdFx0Zm9yICggaSA9IDAsIGxlbiA9IHNvdXJjZXMubGVuZ3RoOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRzb3VyY2UgPSBzb3VyY2VzWyBpIF07XG5cdFx0XHRzb3VyY2VbIHBmLm5zIF0gPSB0cnVlO1xuXHRcdFx0c3Jjc2V0ID0gc291cmNlLmdldEF0dHJpYnV0ZSggXCJzcmNzZXRcIiApO1xuXG5cdFx0XHQvLyBpZiBzb3VyY2UgZG9lcyBub3QgaGF2ZSBhIHNyY3NldCBhdHRyaWJ1dGUsIHNraXBcblx0XHRcdGlmICggc3Jjc2V0ICkge1xuXHRcdFx0XHRjYW5kaWRhdGVzLnB1c2goIHtcblx0XHRcdFx0XHRzcmNzZXQ6IHNyY3NldCxcblx0XHRcdFx0XHRtZWRpYTogc291cmNlLmdldEF0dHJpYnV0ZSggXCJtZWRpYVwiICksXG5cdFx0XHRcdFx0dHlwZTogc291cmNlLmdldEF0dHJpYnV0ZSggXCJ0eXBlXCIgKSxcblx0XHRcdFx0XHRzaXplczogc291cmNlLmdldEF0dHJpYnV0ZSggXCJzaXplc1wiIClcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBTcmNzZXQgUGFyc2VyXG5cdCAqIEJ5IEFsZXggQmVsbCB8ICBNSVQgTGljZW5zZVxuXHQgKlxuXHQgKiBAcmV0dXJucyBBcnJheSBbe3VybDogXywgZDogXywgdzogXywgaDpfLCBzZXQ6Xyg/Pz8/KX0sIC4uLl1cblx0ICpcblx0ICogQmFzZWQgc3VwZXIgZHVwZXIgY2xvc2VseSBvbiB0aGUgcmVmZXJlbmNlIGFsZ29yaXRobSBhdDpcblx0ICogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sI3BhcnNlLWEtc3Jjc2V0LWF0dHJpYnV0ZVxuXHQgKi9cblxuXHQvLyAxLiBMZXQgaW5wdXQgYmUgdGhlIHZhbHVlIHBhc3NlZCB0byB0aGlzIGFsZ29yaXRobS5cblx0Ly8gKFRPLURPIDogRXhwbGFpbiB3aGF0IFwic2V0XCIgYXJndW1lbnQgaXMgaGVyZS4gTWF5YmUgY2hvb3NlIGEgbW9yZVxuXHQvLyBkZXNjcmlwdGl2ZSAmIG1vcmUgc2VhcmNoYWJsZSBuYW1lLiAgU2luY2UgcGFzc2luZyB0aGUgXCJzZXRcIiBpbiByZWFsbHkgaGFzXG5cdC8vIG5vdGhpbmcgdG8gZG8gd2l0aCBwYXJzaW5nIHByb3BlciwgSSB3b3VsZCBwcmVmZXIgdGhpcyBhc3NpZ25tZW50IGV2ZW50dWFsbHlcblx0Ly8gZ28gaW4gYW4gZXh0ZXJuYWwgZm4uKVxuXHRmdW5jdGlvbiBwYXJzZVNyY3NldChpbnB1dCwgc2V0KSB7XG5cblx0XHRmdW5jdGlvbiBjb2xsZWN0Q2hhcmFjdGVycyhyZWdFeCkge1xuXHRcdFx0dmFyIGNoYXJzLFxuXHRcdFx0ICAgIG1hdGNoID0gcmVnRXguZXhlYyhpbnB1dC5zdWJzdHJpbmcocG9zKSk7XG5cdFx0XHRpZiAobWF0Y2gpIHtcblx0XHRcdFx0Y2hhcnMgPSBtYXRjaFsgMCBdO1xuXHRcdFx0XHRwb3MgKz0gY2hhcnMubGVuZ3RoO1xuXHRcdFx0XHRyZXR1cm4gY2hhcnM7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoLFxuXHRcdCAgICB1cmwsXG5cdFx0ICAgIGRlc2NyaXB0b3JzLFxuXHRcdCAgICBjdXJyZW50RGVzY3JpcHRvcixcblx0XHQgICAgc3RhdGUsXG5cdFx0ICAgIGMsXG5cblx0XHQgICAgLy8gMi4gTGV0IHBvc2l0aW9uIGJlIGEgcG9pbnRlciBpbnRvIGlucHV0LCBpbml0aWFsbHkgcG9pbnRpbmcgYXQgdGhlIHN0YXJ0XG5cdFx0ICAgIC8vICAgIG9mIHRoZSBzdHJpbmcuXG5cdFx0ICAgIHBvcyA9IDAsXG5cblx0XHQgICAgLy8gMy4gTGV0IGNhbmRpZGF0ZXMgYmUgYW4gaW5pdGlhbGx5IGVtcHR5IHNvdXJjZSBzZXQuXG5cdFx0ICAgIGNhbmRpZGF0ZXMgPSBbXTtcblxuXHRcdC8qKlxuXHRcdCogQWRkcyBkZXNjcmlwdG9yIHByb3BlcnRpZXMgdG8gYSBjYW5kaWRhdGUsIHB1c2hlcyB0byB0aGUgY2FuZGlkYXRlcyBhcnJheVxuXHRcdCogQHJldHVybiB1bmRlZmluZWRcblx0XHQqL1xuXHRcdC8vIChEZWNsYXJlZCBvdXRzaWRlIG9mIHRoZSB3aGlsZSBsb29wIHNvIHRoYXQgaXQncyBvbmx5IGNyZWF0ZWQgb25jZS5cblx0XHQvLyAoVGhpcyBmbiBpcyBkZWZpbmVkIGJlZm9yZSBpdCBpcyB1c2VkLCBpbiBvcmRlciB0byBwYXNzIEpTSElOVC5cblx0XHQvLyBVbmZvcnR1bmF0ZWx5IHRoaXMgYnJlYWtzIHRoZSBzZXF1ZW5jaW5nIG9mIHRoZSBzcGVjIGNvbW1lbnRzLiA6LyApXG5cdFx0ZnVuY3Rpb24gcGFyc2VEZXNjcmlwdG9ycygpIHtcblxuXHRcdFx0Ly8gOS4gRGVzY3JpcHRvciBwYXJzZXI6IExldCBlcnJvciBiZSBuby5cblx0XHRcdHZhciBwRXJyb3IgPSBmYWxzZSxcblxuXHRcdFx0Ly8gMTAuIExldCB3aWR0aCBiZSBhYnNlbnQuXG5cdFx0XHQvLyAxMS4gTGV0IGRlbnNpdHkgYmUgYWJzZW50LlxuXHRcdFx0Ly8gMTIuIExldCBmdXR1cmUtY29tcGF0LWggYmUgYWJzZW50LiAoV2UncmUgaW1wbGVtZW50aW5nIGl0IG5vdyBhcyBoKVxuXHRcdFx0ICAgIHcsIGQsIGgsIGksXG5cdFx0XHQgICAgY2FuZGlkYXRlID0ge30sXG5cdFx0XHQgICAgZGVzYywgbGFzdENoYXIsIHZhbHVlLCBpbnRWYWwsIGZsb2F0VmFsO1xuXG5cdFx0XHQvLyAxMy4gRm9yIGVhY2ggZGVzY3JpcHRvciBpbiBkZXNjcmlwdG9ycywgcnVuIHRoZSBhcHByb3ByaWF0ZSBzZXQgb2Ygc3RlcHNcblx0XHRcdC8vIGZyb20gdGhlIGZvbGxvd2luZyBsaXN0OlxuXHRcdFx0Zm9yIChpID0gMCA7IGkgPCBkZXNjcmlwdG9ycy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRkZXNjID0gZGVzY3JpcHRvcnNbIGkgXTtcblxuXHRcdFx0XHRsYXN0Q2hhciA9IGRlc2NbIGRlc2MubGVuZ3RoIC0gMSBdO1xuXHRcdFx0XHR2YWx1ZSA9IGRlc2Muc3Vic3RyaW5nKDAsIGRlc2MubGVuZ3RoIC0gMSk7XG5cdFx0XHRcdGludFZhbCA9IHBhcnNlSW50KHZhbHVlLCAxMCk7XG5cdFx0XHRcdGZsb2F0VmFsID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG5cblx0XHRcdFx0Ly8gSWYgdGhlIGRlc2NyaXB0b3IgY29uc2lzdHMgb2YgYSB2YWxpZCBub24tbmVnYXRpdmUgaW50ZWdlciBmb2xsb3dlZCBieVxuXHRcdFx0XHQvLyBhIFUrMDA3NyBMQVRJTiBTTUFMTCBMRVRURVIgVyBjaGFyYWN0ZXJcblx0XHRcdFx0aWYgKHJlZ2V4Tm9uTmVnYXRpdmVJbnRlZ2VyLnRlc3QodmFsdWUpICYmIChsYXN0Q2hhciA9PT0gXCJ3XCIpKSB7XG5cblx0XHRcdFx0XHQvLyBJZiB3aWR0aCBhbmQgZGVuc2l0eSBhcmUgbm90IGJvdGggYWJzZW50LCB0aGVuIGxldCBlcnJvciBiZSB5ZXMuXG5cdFx0XHRcdFx0aWYgKHcgfHwgZCkge3BFcnJvciA9IHRydWU7fVxuXG5cdFx0XHRcdFx0Ly8gQXBwbHkgdGhlIHJ1bGVzIGZvciBwYXJzaW5nIG5vbi1uZWdhdGl2ZSBpbnRlZ2VycyB0byB0aGUgZGVzY3JpcHRvci5cblx0XHRcdFx0XHQvLyBJZiB0aGUgcmVzdWx0IGlzIHplcm8sIGxldCBlcnJvciBiZSB5ZXMuXG5cdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBsZXQgd2lkdGggYmUgdGhlIHJlc3VsdC5cblx0XHRcdFx0XHRpZiAoaW50VmFsID09PSAwKSB7cEVycm9yID0gdHJ1ZTt9IGVsc2Uge3cgPSBpbnRWYWw7fVxuXG5cdFx0XHRcdC8vIElmIHRoZSBkZXNjcmlwdG9yIGNvbnNpc3RzIG9mIGEgdmFsaWQgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGZvbGxvd2VkIGJ5XG5cdFx0XHRcdC8vIGEgVSswMDc4IExBVElOIFNNQUxMIExFVFRFUiBYIGNoYXJhY3RlclxuXHRcdFx0XHR9IGVsc2UgaWYgKHJlZ2V4RmxvYXRpbmdQb2ludC50ZXN0KHZhbHVlKSAmJiAobGFzdENoYXIgPT09IFwieFwiKSkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgd2lkdGgsIGRlbnNpdHkgYW5kIGZ1dHVyZS1jb21wYXQtaCBhcmUgbm90IGFsbCBhYnNlbnQsIHRoZW4gbGV0IGVycm9yXG5cdFx0XHRcdFx0Ly8gYmUgeWVzLlxuXHRcdFx0XHRcdGlmICh3IHx8IGQgfHwgaCkge3BFcnJvciA9IHRydWU7fVxuXG5cdFx0XHRcdFx0Ly8gQXBwbHkgdGhlIHJ1bGVzIGZvciBwYXJzaW5nIGZsb2F0aW5nLXBvaW50IG51bWJlciB2YWx1ZXMgdG8gdGhlIGRlc2NyaXB0b3IuXG5cdFx0XHRcdFx0Ly8gSWYgdGhlIHJlc3VsdCBpcyBsZXNzIHRoYW4gemVybywgbGV0IGVycm9yIGJlIHllcy4gT3RoZXJ3aXNlLCBsZXQgZGVuc2l0eVxuXHRcdFx0XHRcdC8vIGJlIHRoZSByZXN1bHQuXG5cdFx0XHRcdFx0aWYgKGZsb2F0VmFsIDwgMCkge3BFcnJvciA9IHRydWU7fSBlbHNlIHtkID0gZmxvYXRWYWw7fVxuXG5cdFx0XHRcdC8vIElmIHRoZSBkZXNjcmlwdG9yIGNvbnNpc3RzIG9mIGEgdmFsaWQgbm9uLW5lZ2F0aXZlIGludGVnZXIgZm9sbG93ZWQgYnlcblx0XHRcdFx0Ly8gYSBVKzAwNjggTEFUSU4gU01BTEwgTEVUVEVSIEggY2hhcmFjdGVyXG5cdFx0XHRcdH0gZWxzZSBpZiAocmVnZXhOb25OZWdhdGl2ZUludGVnZXIudGVzdCh2YWx1ZSkgJiYgKGxhc3RDaGFyID09PSBcImhcIikpIHtcblxuXHRcdFx0XHRcdC8vIElmIGhlaWdodCBhbmQgZGVuc2l0eSBhcmUgbm90IGJvdGggYWJzZW50LCB0aGVuIGxldCBlcnJvciBiZSB5ZXMuXG5cdFx0XHRcdFx0aWYgKGggfHwgZCkge3BFcnJvciA9IHRydWU7fVxuXG5cdFx0XHRcdFx0Ly8gQXBwbHkgdGhlIHJ1bGVzIGZvciBwYXJzaW5nIG5vbi1uZWdhdGl2ZSBpbnRlZ2VycyB0byB0aGUgZGVzY3JpcHRvci5cblx0XHRcdFx0XHQvLyBJZiB0aGUgcmVzdWx0IGlzIHplcm8sIGxldCBlcnJvciBiZSB5ZXMuIE90aGVyd2lzZSwgbGV0IGZ1dHVyZS1jb21wYXQtaFxuXHRcdFx0XHRcdC8vIGJlIHRoZSByZXN1bHQuXG5cdFx0XHRcdFx0aWYgKGludFZhbCA9PT0gMCkge3BFcnJvciA9IHRydWU7fSBlbHNlIHtoID0gaW50VmFsO31cblxuXHRcdFx0XHQvLyBBbnl0aGluZyBlbHNlLCBMZXQgZXJyb3IgYmUgeWVzLlxuXHRcdFx0XHR9IGVsc2Uge3BFcnJvciA9IHRydWU7fVxuXHRcdFx0fSAvLyAoY2xvc2Ugc3RlcCAxMyBmb3IgbG9vcClcblxuXHRcdFx0Ly8gMTUuIElmIGVycm9yIGlzIHN0aWxsIG5vLCB0aGVuIGFwcGVuZCBhIG5ldyBpbWFnZSBzb3VyY2UgdG8gY2FuZGlkYXRlcyB3aG9zZVxuXHRcdFx0Ly8gVVJMIGlzIHVybCwgYXNzb2NpYXRlZCB3aXRoIGEgd2lkdGggd2lkdGggaWYgbm90IGFic2VudCBhbmQgYSBwaXhlbFxuXHRcdFx0Ly8gZGVuc2l0eSBkZW5zaXR5IGlmIG5vdCBhYnNlbnQuIE90aGVyd2lzZSwgdGhlcmUgaXMgYSBwYXJzZSBlcnJvci5cblx0XHRcdGlmICghcEVycm9yKSB7XG5cdFx0XHRcdGNhbmRpZGF0ZS51cmwgPSB1cmw7XG5cblx0XHRcdFx0aWYgKHcpIHsgY2FuZGlkYXRlLncgPSB3O31cblx0XHRcdFx0aWYgKGQpIHsgY2FuZGlkYXRlLmQgPSBkO31cblx0XHRcdFx0aWYgKGgpIHsgY2FuZGlkYXRlLmggPSBoO31cblx0XHRcdFx0aWYgKCFoICYmICFkICYmICF3KSB7Y2FuZGlkYXRlLmQgPSAxO31cblx0XHRcdFx0aWYgKGNhbmRpZGF0ZS5kID09PSAxKSB7c2V0LmhhczF4ID0gdHJ1ZTt9XG5cdFx0XHRcdGNhbmRpZGF0ZS5zZXQgPSBzZXQ7XG5cblx0XHRcdFx0Y2FuZGlkYXRlcy5wdXNoKGNhbmRpZGF0ZSk7XG5cdFx0XHR9XG5cdFx0fSAvLyAoY2xvc2UgcGFyc2VEZXNjcmlwdG9ycyBmbilcblxuXHRcdC8qKlxuXHRcdCogVG9rZW5pemVzIGRlc2NyaXB0b3IgcHJvcGVydGllcyBwcmlvciB0byBwYXJzaW5nXG5cdFx0KiBSZXR1cm5zIHVuZGVmaW5lZC5cblx0XHQqIChBZ2FpbiwgdGhpcyBmbiBpcyBkZWZpbmVkIGJlZm9yZSBpdCBpcyB1c2VkLCBpbiBvcmRlciB0byBwYXNzIEpTSElOVC5cblx0XHQqIFVuZm9ydHVuYXRlbHkgdGhpcyBicmVha3MgdGhlIGxvZ2ljYWwgc2VxdWVuY2luZyBvZiB0aGUgc3BlYyBjb21tZW50cy4gOi8gKVxuXHRcdCovXG5cdFx0ZnVuY3Rpb24gdG9rZW5pemUoKSB7XG5cblx0XHRcdC8vIDguMS4gRGVzY3JpcHRvciB0b2tlbmlzZXI6IFNraXAgd2hpdGVzcGFjZVxuXHRcdFx0Y29sbGVjdENoYXJhY3RlcnMocmVnZXhMZWFkaW5nU3BhY2VzKTtcblxuXHRcdFx0Ly8gOC4yLiBMZXQgY3VycmVudCBkZXNjcmlwdG9yIGJlIHRoZSBlbXB0eSBzdHJpbmcuXG5cdFx0XHRjdXJyZW50RGVzY3JpcHRvciA9IFwiXCI7XG5cblx0XHRcdC8vIDguMy4gTGV0IHN0YXRlIGJlIGluIGRlc2NyaXB0b3IuXG5cdFx0XHRzdGF0ZSA9IFwiaW4gZGVzY3JpcHRvclwiO1xuXG5cdFx0XHR3aGlsZSAodHJ1ZSkge1xuXG5cdFx0XHRcdC8vIDguNC4gTGV0IGMgYmUgdGhlIGNoYXJhY3RlciBhdCBwb3NpdGlvbi5cblx0XHRcdFx0YyA9IGlucHV0LmNoYXJBdChwb3MpO1xuXG5cdFx0XHRcdC8vICBEbyB0aGUgZm9sbG93aW5nIGRlcGVuZGluZyBvbiB0aGUgdmFsdWUgb2Ygc3RhdGUuXG5cdFx0XHRcdC8vICBGb3IgdGhlIHB1cnBvc2Ugb2YgdGhpcyBzdGVwLCBcIkVPRlwiIGlzIGEgc3BlY2lhbCBjaGFyYWN0ZXIgcmVwcmVzZW50aW5nXG5cdFx0XHRcdC8vICB0aGF0IHBvc2l0aW9uIGlzIHBhc3QgdGhlIGVuZCBvZiBpbnB1dC5cblxuXHRcdFx0XHQvLyBJbiBkZXNjcmlwdG9yXG5cdFx0XHRcdGlmIChzdGF0ZSA9PT0gXCJpbiBkZXNjcmlwdG9yXCIpIHtcblx0XHRcdFx0XHQvLyBEbyB0aGUgZm9sbG93aW5nLCBkZXBlbmRpbmcgb24gdGhlIHZhbHVlIG9mIGM6XG5cblx0XHRcdFx0ICAvLyBTcGFjZSBjaGFyYWN0ZXJcblx0XHRcdFx0ICAvLyBJZiBjdXJyZW50IGRlc2NyaXB0b3IgaXMgbm90IGVtcHR5LCBhcHBlbmQgY3VycmVudCBkZXNjcmlwdG9yIHRvXG5cdFx0XHRcdCAgLy8gZGVzY3JpcHRvcnMgYW5kIGxldCBjdXJyZW50IGRlc2NyaXB0b3IgYmUgdGhlIGVtcHR5IHN0cmluZy5cblx0XHRcdFx0ICAvLyBTZXQgc3RhdGUgdG8gYWZ0ZXIgZGVzY3JpcHRvci5cblx0XHRcdFx0XHRpZiAoaXNTcGFjZShjKSkge1xuXHRcdFx0XHRcdFx0aWYgKGN1cnJlbnREZXNjcmlwdG9yKSB7XG5cdFx0XHRcdFx0XHRcdGRlc2NyaXB0b3JzLnB1c2goY3VycmVudERlc2NyaXB0b3IpO1xuXHRcdFx0XHRcdFx0XHRjdXJyZW50RGVzY3JpcHRvciA9IFwiXCI7XG5cdFx0XHRcdFx0XHRcdHN0YXRlID0gXCJhZnRlciBkZXNjcmlwdG9yXCI7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBVKzAwMkMgQ09NTUEgKCwpXG5cdFx0XHRcdFx0Ly8gQWR2YW5jZSBwb3NpdGlvbiB0byB0aGUgbmV4dCBjaGFyYWN0ZXIgaW4gaW5wdXQuIElmIGN1cnJlbnQgZGVzY3JpcHRvclxuXHRcdFx0XHRcdC8vIGlzIG5vdCBlbXB0eSwgYXBwZW5kIGN1cnJlbnQgZGVzY3JpcHRvciB0byBkZXNjcmlwdG9ycy4gSnVtcCB0byB0aGUgc3RlcFxuXHRcdFx0XHRcdC8vIGxhYmVsZWQgZGVzY3JpcHRvciBwYXJzZXIuXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChjID09PSBcIixcIikge1xuXHRcdFx0XHRcdFx0cG9zICs9IDE7XG5cdFx0XHRcdFx0XHRpZiAoY3VycmVudERlc2NyaXB0b3IpIHtcblx0XHRcdFx0XHRcdFx0ZGVzY3JpcHRvcnMucHVzaChjdXJyZW50RGVzY3JpcHRvcik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRwYXJzZURlc2NyaXB0b3JzKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdFx0XHQvLyBVKzAwMjggTEVGVCBQQVJFTlRIRVNJUyAoKClcblx0XHRcdFx0XHQvLyBBcHBlbmQgYyB0byBjdXJyZW50IGRlc2NyaXB0b3IuIFNldCBzdGF0ZSB0byBpbiBwYXJlbnMuXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChjID09PSBcIlxcdTAwMjhcIikge1xuXHRcdFx0XHRcdFx0Y3VycmVudERlc2NyaXB0b3IgPSBjdXJyZW50RGVzY3JpcHRvciArIGM7XG5cdFx0XHRcdFx0XHRzdGF0ZSA9IFwiaW4gcGFyZW5zXCI7XG5cblx0XHRcdFx0XHQvLyBFT0Zcblx0XHRcdFx0XHQvLyBJZiBjdXJyZW50IGRlc2NyaXB0b3IgaXMgbm90IGVtcHR5LCBhcHBlbmQgY3VycmVudCBkZXNjcmlwdG9yIHRvXG5cdFx0XHRcdFx0Ly8gZGVzY3JpcHRvcnMuIEp1bXAgdG8gdGhlIHN0ZXAgbGFiZWxlZCBkZXNjcmlwdG9yIHBhcnNlci5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKGMgPT09IFwiXCIpIHtcblx0XHRcdFx0XHRcdGlmIChjdXJyZW50RGVzY3JpcHRvcikge1xuXHRcdFx0XHRcdFx0XHRkZXNjcmlwdG9ycy5wdXNoKGN1cnJlbnREZXNjcmlwdG9yKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHBhcnNlRGVzY3JpcHRvcnMoKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHRcdC8vIEFueXRoaW5nIGVsc2Vcblx0XHRcdFx0XHQvLyBBcHBlbmQgYyB0byBjdXJyZW50IGRlc2NyaXB0b3IuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGN1cnJlbnREZXNjcmlwdG9yID0gY3VycmVudERlc2NyaXB0b3IgKyBjO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0Ly8gKGVuZCBcImluIGRlc2NyaXB0b3JcIlxuXG5cdFx0XHRcdC8vIEluIHBhcmVuc1xuXHRcdFx0XHR9IGVsc2UgaWYgKHN0YXRlID09PSBcImluIHBhcmVuc1wiKSB7XG5cblx0XHRcdFx0XHQvLyBVKzAwMjkgUklHSFQgUEFSRU5USEVTSVMgKCkpXG5cdFx0XHRcdFx0Ly8gQXBwZW5kIGMgdG8gY3VycmVudCBkZXNjcmlwdG9yLiBTZXQgc3RhdGUgdG8gaW4gZGVzY3JpcHRvci5cblx0XHRcdFx0XHRpZiAoYyA9PT0gXCIpXCIpIHtcblx0XHRcdFx0XHRcdGN1cnJlbnREZXNjcmlwdG9yID0gY3VycmVudERlc2NyaXB0b3IgKyBjO1xuXHRcdFx0XHRcdFx0c3RhdGUgPSBcImluIGRlc2NyaXB0b3JcIjtcblxuXHRcdFx0XHRcdC8vIEVPRlxuXHRcdFx0XHRcdC8vIEFwcGVuZCBjdXJyZW50IGRlc2NyaXB0b3IgdG8gZGVzY3JpcHRvcnMuIEp1bXAgdG8gdGhlIHN0ZXAgbGFiZWxlZFxuXHRcdFx0XHRcdC8vIGRlc2NyaXB0b3IgcGFyc2VyLlxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoYyA9PT0gXCJcIikge1xuXHRcdFx0XHRcdFx0ZGVzY3JpcHRvcnMucHVzaChjdXJyZW50RGVzY3JpcHRvcik7XG5cdFx0XHRcdFx0XHRwYXJzZURlc2NyaXB0b3JzKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdFx0XHQvLyBBbnl0aGluZyBlbHNlXG5cdFx0XHRcdFx0Ly8gQXBwZW5kIGMgdG8gY3VycmVudCBkZXNjcmlwdG9yLlxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjdXJyZW50RGVzY3JpcHRvciA9IGN1cnJlbnREZXNjcmlwdG9yICsgYztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQWZ0ZXIgZGVzY3JpcHRvclxuXHRcdFx0XHR9IGVsc2UgaWYgKHN0YXRlID09PSBcImFmdGVyIGRlc2NyaXB0b3JcIikge1xuXG5cdFx0XHRcdFx0Ly8gRG8gdGhlIGZvbGxvd2luZywgZGVwZW5kaW5nIG9uIHRoZSB2YWx1ZSBvZiBjOlxuXHRcdFx0XHRcdC8vIFNwYWNlIGNoYXJhY3RlcjogU3RheSBpbiB0aGlzIHN0YXRlLlxuXHRcdFx0XHRcdGlmIChpc1NwYWNlKGMpKSB7XG5cblx0XHRcdFx0XHQvLyBFT0Y6IEp1bXAgdG8gdGhlIHN0ZXAgbGFiZWxlZCBkZXNjcmlwdG9yIHBhcnNlci5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKGMgPT09IFwiXCIpIHtcblx0XHRcdFx0XHRcdHBhcnNlRGVzY3JpcHRvcnMoKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHRcdC8vIEFueXRoaW5nIGVsc2Vcblx0XHRcdFx0XHQvLyBTZXQgc3RhdGUgdG8gaW4gZGVzY3JpcHRvci4gU2V0IHBvc2l0aW9uIHRvIHRoZSBwcmV2aW91cyBjaGFyYWN0ZXIgaW4gaW5wdXQuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHN0YXRlID0gXCJpbiBkZXNjcmlwdG9yXCI7XG5cdFx0XHRcdFx0XHRwb3MgLT0gMTtcblxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFkdmFuY2UgcG9zaXRpb24gdG8gdGhlIG5leHQgY2hhcmFjdGVyIGluIGlucHV0LlxuXHRcdFx0XHRwb3MgKz0gMTtcblxuXHRcdFx0Ly8gUmVwZWF0IHRoaXMgc3RlcC5cblx0XHRcdH0gLy8gKGNsb3NlIHdoaWxlIHRydWUgbG9vcClcblx0XHR9XG5cblx0XHQvLyA0LiBTcGxpdHRpbmcgbG9vcDogQ29sbGVjdCBhIHNlcXVlbmNlIG9mIGNoYXJhY3RlcnMgdGhhdCBhcmUgc3BhY2Vcblx0XHQvLyAgICBjaGFyYWN0ZXJzIG9yIFUrMDAyQyBDT01NQSBjaGFyYWN0ZXJzLiBJZiBhbnkgVSswMDJDIENPTU1BIGNoYXJhY3RlcnNcblx0XHQvLyAgICB3ZXJlIGNvbGxlY3RlZCwgdGhhdCBpcyBhIHBhcnNlIGVycm9yLlxuXHRcdHdoaWxlICh0cnVlKSB7XG5cdFx0XHRjb2xsZWN0Q2hhcmFjdGVycyhyZWdleExlYWRpbmdDb21tYXNPclNwYWNlcyk7XG5cblx0XHRcdC8vIDUuIElmIHBvc2l0aW9uIGlzIHBhc3QgdGhlIGVuZCBvZiBpbnB1dCwgcmV0dXJuIGNhbmRpZGF0ZXMgYW5kIGFib3J0IHRoZXNlIHN0ZXBzLlxuXHRcdFx0aWYgKHBvcyA+PSBpbnB1dExlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gY2FuZGlkYXRlczsgLy8gKHdlJ3JlIGRvbmUsIHRoaXMgaXMgdGhlIHNvbGUgcmV0dXJuIHBhdGgpXG5cdFx0XHR9XG5cblx0XHRcdC8vIDYuIENvbGxlY3QgYSBzZXF1ZW5jZSBvZiBjaGFyYWN0ZXJzIHRoYXQgYXJlIG5vdCBzcGFjZSBjaGFyYWN0ZXJzLFxuXHRcdFx0Ly8gICAgYW5kIGxldCB0aGF0IGJlIHVybC5cblx0XHRcdHVybCA9IGNvbGxlY3RDaGFyYWN0ZXJzKHJlZ2V4TGVhZGluZ05vdFNwYWNlcyk7XG5cblx0XHRcdC8vIDcuIExldCBkZXNjcmlwdG9ycyBiZSBhIG5ldyBlbXB0eSBsaXN0LlxuXHRcdFx0ZGVzY3JpcHRvcnMgPSBbXTtcblxuXHRcdFx0Ly8gOC4gSWYgdXJsIGVuZHMgd2l0aCBhIFUrMDAyQyBDT01NQSBjaGFyYWN0ZXIgKCwpLCBmb2xsb3cgdGhlc2Ugc3Vic3RlcHM6XG5cdFx0XHQvL1x0XHQoMSkuIFJlbW92ZSBhbGwgdHJhaWxpbmcgVSswMDJDIENPTU1BIGNoYXJhY3RlcnMgZnJvbSB1cmwuIElmIHRoaXMgcmVtb3ZlZFxuXHRcdFx0Ly8gICAgICAgICBtb3JlIHRoYW4gb25lIGNoYXJhY3RlciwgdGhhdCBpcyBhIHBhcnNlIGVycm9yLlxuXHRcdFx0aWYgKHVybC5zbGljZSgtMSkgPT09IFwiLFwiKSB7XG5cdFx0XHRcdHVybCA9IHVybC5yZXBsYWNlKHJlZ2V4VHJhaWxpbmdDb21tYXMsIFwiXCIpO1xuXHRcdFx0XHQvLyAoSnVtcCBhaGVhZCB0byBzdGVwIDkgdG8gc2tpcCB0b2tlbml6YXRpb24gYW5kIGp1c3QgcHVzaCB0aGUgY2FuZGlkYXRlKS5cblx0XHRcdFx0cGFyc2VEZXNjcmlwdG9ycygpO1xuXG5cdFx0XHQvL1x0T3RoZXJ3aXNlLCBmb2xsb3cgdGhlc2Ugc3Vic3RlcHM6XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0b2tlbml6ZSgpO1xuXHRcdFx0fSAvLyAoY2xvc2UgZWxzZSBvZiBzdGVwIDgpXG5cblx0XHQvLyAxNi4gUmV0dXJuIHRvIHRoZSBzdGVwIGxhYmVsZWQgc3BsaXR0aW5nIGxvb3AuXG5cdFx0fSAvLyAoQ2xvc2Ugb2YgYmlnIHdoaWxlIGxvb3AuKVxuXHR9XG5cblx0Lypcblx0ICogU2l6ZXMgUGFyc2VyXG5cdCAqXG5cdCAqIEJ5IEFsZXggQmVsbCB8ICBNSVQgTGljZW5zZVxuXHQgKlxuXHQgKiBOb24tc3RyaWN0IGJ1dCBhY2N1cmF0ZSBhbmQgbGlnaHR3ZWlnaHQgSlMgUGFyc2VyIGZvciB0aGUgc3RyaW5nIHZhbHVlIDxpbWcgc2l6ZXM9XCJoZXJlXCI+XG5cdCAqXG5cdCAqIFJlZmVyZW5jZSBhbGdvcml0aG0gYXQ6XG5cdCAqIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCNwYXJzZS1hLXNpemVzLWF0dHJpYnV0ZVxuXHQgKlxuXHQgKiBNb3N0IGNvbW1lbnRzIGFyZSBjb3BpZWQgaW4gZGlyZWN0bHkgZnJvbSB0aGUgc3BlY1xuXHQgKiAoZXhjZXB0IGZvciBjb21tZW50cyBpbiBwYXJlbnMpLlxuXHQgKlxuXHQgKiBHcmFtbWFyIGlzOlxuXHQgKiA8c291cmNlLXNpemUtbGlzdD4gPSA8c291cmNlLXNpemU+IyBbICwgPHNvdXJjZS1zaXplLXZhbHVlPiBdPyB8IDxzb3VyY2Utc2l6ZS12YWx1ZT5cblx0ICogPHNvdXJjZS1zaXplPiA9IDxtZWRpYS1jb25kaXRpb24+IDxzb3VyY2Utc2l6ZS12YWx1ZT5cblx0ICogPHNvdXJjZS1zaXplLXZhbHVlPiA9IDxsZW5ndGg+XG5cdCAqIGh0dHA6Ly93d3cudzMub3JnL2h0bWwvd2cvZHJhZnRzL2h0bWwvbWFzdGVyL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCNhdHRyLWltZy1zaXplc1xuXHQgKlxuXHQgKiBFLmcuIFwiKG1heC13aWR0aDogMzBlbSkgMTAwdncsIChtYXgtd2lkdGg6IDUwZW0pIDcwdncsIDEwMHZ3XCJcblx0ICogb3IgXCIobWluLXdpZHRoOiAzMGVtKSwgY2FsYygzMHZ3IC0gMTVweClcIiBvciBqdXN0IFwiMzB2d1wiXG5cdCAqXG5cdCAqIFJldHVybnMgdGhlIGZpcnN0IHZhbGlkIDxjc3MtbGVuZ3RoPiB3aXRoIGEgbWVkaWEgY29uZGl0aW9uIHRoYXQgZXZhbHVhdGVzIHRvIHRydWUsXG5cdCAqIG9yIFwiMTAwdndcIiBpZiBhbGwgdmFsaWQgbWVkaWEgY29uZGl0aW9ucyBldmFsdWF0ZSB0byBmYWxzZS5cblx0ICpcblx0ICovXG5cblx0ZnVuY3Rpb24gcGFyc2VTaXplcyhzdHJWYWx1ZSkge1xuXG5cdFx0Ly8gKFBlcmNlbnRhZ2UgQ1NTIGxlbmd0aHMgYXJlIG5vdCBhbGxvd2VkIGluIHRoaXMgY2FzZSwgdG8gYXZvaWQgY29uZnVzaW9uOlxuXHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCN2YWxpZC1zb3VyY2Utc2l6ZS1saXN0XG5cdFx0Ly8gQ1NTIGFsbG93cyBhIHNpbmdsZSBvcHRpb25hbCBwbHVzIG9yIG1pbnVzIHNpZ246XG5cdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMi9zeW5kYXRhLmh0bWwjbnVtYmVyc1xuXHRcdC8vIENTUyBpcyBBU0NJSSBjYXNlLWluc2Vuc2l0aXZlOlxuXHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIvc3luZGF0YS5odG1sI2NoYXJhY3RlcnMgKVxuXHRcdC8vIFNwZWMgYWxsb3dzIGV4cG9uZW50aWFsIG5vdGF0aW9uIGZvciA8bnVtYmVyPiB0eXBlOlxuXHRcdC8vIGh0dHA6Ly9kZXYudzMub3JnL2Nzc3dnL2Nzcy12YWx1ZXMvI251bWJlcnNcblx0XHR2YXIgcmVnZXhDc3NMZW5ndGhXaXRoVW5pdHMgPSAvXig/OlsrLV0/WzAtOV0rfFswLTldKlxcLlswLTldKykoPzpbZUVdWystXT9bMC05XSspPyg/OmNofGNtfGVtfGV4fGlufG1tfHBjfHB0fHB4fHJlbXx2aHx2bWlufHZtYXh8dncpJC9pO1xuXG5cdFx0Ly8gKFRoaXMgaXMgYSBxdWljayBhbmQgbGVuaWVudCB0ZXN0LiBCZWNhdXNlIG9mIG9wdGlvbmFsIHVubGltaXRlZC1kZXB0aCBpbnRlcm5hbFxuXHRcdC8vIGdyb3VwaW5nIHBhcmVucyBhbmQgc3RyaWN0IHNwYWNpbmcgcnVsZXMsIHRoaXMgY291bGQgZ2V0IHZlcnkgY29tcGxpY2F0ZWQuKVxuXHRcdHZhciByZWdleENzc0NhbGMgPSAvXmNhbGNcXCgoPzpbMC05YS16IFxcLlxcK1xcLVxcKlxcL1xcKFxcKV0rKVxcKSQvaTtcblxuXHRcdHZhciBpO1xuXHRcdHZhciB1bnBhcnNlZFNpemVzTGlzdDtcblx0XHR2YXIgdW5wYXJzZWRTaXplc0xpc3RMZW5ndGg7XG5cdFx0dmFyIHVucGFyc2VkU2l6ZTtcblx0XHR2YXIgbGFzdENvbXBvbmVudFZhbHVlO1xuXHRcdHZhciBzaXplO1xuXG5cdFx0Ly8gVVRJTElUWSBGVU5DVElPTlNcblxuXHRcdC8vICAoVG95IENTUyBwYXJzZXIuIFRoZSBnb2FscyBoZXJlIGFyZTpcblx0XHQvLyAgMSkgZXhwYW5zaXZlIHRlc3QgY292ZXJhZ2Ugd2l0aG91dCB0aGUgd2VpZ2h0IG9mIGEgZnVsbCBDU1MgcGFyc2VyLlxuXHRcdC8vICAyKSBBdm9pZGluZyByZWdleCB3aGVyZXZlciBjb252ZW5pZW50LlxuXHRcdC8vICBRdWljayB0ZXN0czogaHR0cDovL2pzZmlkZGxlLm5ldC9ndG50TDRnci8zL1xuXHRcdC8vICBSZXR1cm5zIGFuIGFycmF5IG9mIGFycmF5cy4pXG5cdFx0ZnVuY3Rpb24gcGFyc2VDb21wb25lbnRWYWx1ZXMoc3RyKSB7XG5cdFx0XHR2YXIgY2hyY3RyO1xuXHRcdFx0dmFyIGNvbXBvbmVudCA9IFwiXCI7XG5cdFx0XHR2YXIgY29tcG9uZW50QXJyYXkgPSBbXTtcblx0XHRcdHZhciBsaXN0QXJyYXkgPSBbXTtcblx0XHRcdHZhciBwYXJlbkRlcHRoID0gMDtcblx0XHRcdHZhciBwb3MgPSAwO1xuXHRcdFx0dmFyIGluQ29tbWVudCA9IGZhbHNlO1xuXG5cdFx0XHRmdW5jdGlvbiBwdXNoQ29tcG9uZW50KCkge1xuXHRcdFx0XHRpZiAoY29tcG9uZW50KSB7XG5cdFx0XHRcdFx0Y29tcG9uZW50QXJyYXkucHVzaChjb21wb25lbnQpO1xuXHRcdFx0XHRcdGNvbXBvbmVudCA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gcHVzaENvbXBvbmVudEFycmF5KCkge1xuXHRcdFx0XHRpZiAoY29tcG9uZW50QXJyYXlbMF0pIHtcblx0XHRcdFx0XHRsaXN0QXJyYXkucHVzaChjb21wb25lbnRBcnJheSk7XG5cdFx0XHRcdFx0Y29tcG9uZW50QXJyYXkgPSBbXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyAoTG9vcCBmb3J3YXJkcyBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHN0cmluZy4pXG5cdFx0XHR3aGlsZSAodHJ1ZSkge1xuXHRcdFx0XHRjaHJjdHIgPSBzdHIuY2hhckF0KHBvcyk7XG5cblx0XHRcdFx0aWYgKGNocmN0ciA9PT0gXCJcIikgeyAvLyAoIEVuZCBvZiBzdHJpbmcgcmVhY2hlZC4pXG5cdFx0XHRcdFx0cHVzaENvbXBvbmVudCgpO1xuXHRcdFx0XHRcdHB1c2hDb21wb25lbnRBcnJheSgpO1xuXHRcdFx0XHRcdHJldHVybiBsaXN0QXJyYXk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoaW5Db21tZW50KSB7XG5cdFx0XHRcdFx0aWYgKChjaHJjdHIgPT09IFwiKlwiKSAmJiAoc3RyW3BvcyArIDFdID09PSBcIi9cIikpIHsgLy8gKEF0IGVuZCBvZiBhIGNvbW1lbnQuKVxuXHRcdFx0XHRcdFx0aW5Db21tZW50ID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRwb3MgKz0gMjtcblx0XHRcdFx0XHRcdHB1c2hDb21wb25lbnQoKTtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRwb3MgKz0gMTsgLy8gKFNraXAgYWxsIGNoYXJhY3RlcnMgaW5zaWRlIGNvbW1lbnRzLilcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmIChpc1NwYWNlKGNocmN0cikpIHtcblx0XHRcdFx0XHQvLyAoSWYgcHJldmlvdXMgY2hhcmFjdGVyIGluIGxvb3Agd2FzIGFsc28gYSBzcGFjZSwgb3IgaWZcblx0XHRcdFx0XHQvLyBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzdHJpbmcsIGRvIG5vdCBhZGQgc3BhY2UgY2hhciB0b1xuXHRcdFx0XHRcdC8vIGNvbXBvbmVudC4pXG5cdFx0XHRcdFx0aWYgKCAoc3RyLmNoYXJBdChwb3MgLSAxKSAmJiBpc1NwYWNlKCBzdHIuY2hhckF0KHBvcyAtIDEpICkgKSB8fCAhY29tcG9uZW50ICkge1xuXHRcdFx0XHRcdFx0cG9zICs9IDE7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHBhcmVuRGVwdGggPT09IDApIHtcblx0XHRcdFx0XHRcdHB1c2hDb21wb25lbnQoKTtcblx0XHRcdFx0XHRcdHBvcyArPTE7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gKFJlcGxhY2UgYW55IHNwYWNlIGNoYXJhY3RlciB3aXRoIGEgcGxhaW4gc3BhY2UgZm9yIGxlZ2liaWxpdHkuKVxuXHRcdFx0XHRcdFx0Y2hyY3RyID0gXCIgXCI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKGNocmN0ciA9PT0gXCIoXCIpIHtcblx0XHRcdFx0XHRwYXJlbkRlcHRoICs9IDE7XG5cdFx0XHRcdH0gZWxzZSBpZiAoY2hyY3RyID09PSBcIilcIikge1xuXHRcdFx0XHRcdHBhcmVuRGVwdGggLT0gMTtcblx0XHRcdFx0fSBlbHNlIGlmIChjaHJjdHIgPT09IFwiLFwiKSB7XG5cdFx0XHRcdFx0cHVzaENvbXBvbmVudCgpO1xuXHRcdFx0XHRcdHB1c2hDb21wb25lbnRBcnJheSgpO1xuXHRcdFx0XHRcdHBvcyArPSAxO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCAoY2hyY3RyID09PSBcIi9cIikgJiYgKHN0ci5jaGFyQXQocG9zICsgMSkgPT09IFwiKlwiKSApIHtcblx0XHRcdFx0XHRpbkNvbW1lbnQgPSB0cnVlO1xuXHRcdFx0XHRcdHBvcyArPSAyO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29tcG9uZW50ID0gY29tcG9uZW50ICsgY2hyY3RyO1xuXHRcdFx0XHRwb3MgKz0gMTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpc1ZhbGlkTm9uTmVnYXRpdmVTb3VyY2VTaXplVmFsdWUocykge1xuXHRcdFx0aWYgKHJlZ2V4Q3NzTGVuZ3RoV2l0aFVuaXRzLnRlc3QocykgJiYgKHBhcnNlRmxvYXQocykgPj0gMCkpIHtyZXR1cm4gdHJ1ZTt9XG5cdFx0XHRpZiAocmVnZXhDc3NDYWxjLnRlc3QocykpIHtyZXR1cm4gdHJ1ZTt9XG5cdFx0XHQvLyAoIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIvc3luZGF0YS5odG1sI251bWJlcnMgc2F5czpcblx0XHRcdC8vIFwiLTAgaXMgZXF1aXZhbGVudCB0byAwIGFuZCBpcyBub3QgYSBuZWdhdGl2ZSBudW1iZXIuXCIgd2hpY2ggbWVhbnMgdGhhdFxuXHRcdFx0Ly8gdW5pdGxlc3MgemVybyBhbmQgdW5pdGxlc3MgbmVnYXRpdmUgemVybyBtdXN0IGJlIGFjY2VwdGVkIGFzIHNwZWNpYWwgY2FzZXMuKVxuXHRcdFx0aWYgKChzID09PSBcIjBcIikgfHwgKHMgPT09IFwiLTBcIikgfHwgKHMgPT09IFwiKzBcIikpIHtyZXR1cm4gdHJ1ZTt9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gV2hlbiBhc2tlZCB0byBwYXJzZSBhIHNpemVzIGF0dHJpYnV0ZSBmcm9tIGFuIGVsZW1lbnQsIHBhcnNlIGFcblx0XHQvLyBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBjb21wb25lbnQgdmFsdWVzIGZyb20gdGhlIHZhbHVlIG9mIHRoZSBlbGVtZW50J3Ncblx0XHQvLyBzaXplcyBhdHRyaWJ1dGUgKG9yIHRoZSBlbXB0eSBzdHJpbmcsIGlmIHRoZSBhdHRyaWJ1dGUgaXMgYWJzZW50KSwgYW5kIGxldFxuXHRcdC8vIHVucGFyc2VkIHNpemVzIGxpc3QgYmUgdGhlIHJlc3VsdC5cblx0XHQvLyBodHRwOi8vZGV2LnczLm9yZy9jc3N3Zy9jc3Mtc3ludGF4LyNwYXJzZS1jb21tYS1zZXBhcmF0ZWQtbGlzdC1vZi1jb21wb25lbnQtdmFsdWVzXG5cblx0XHR1bnBhcnNlZFNpemVzTGlzdCA9IHBhcnNlQ29tcG9uZW50VmFsdWVzKHN0clZhbHVlKTtcblx0XHR1bnBhcnNlZFNpemVzTGlzdExlbmd0aCA9IHVucGFyc2VkU2l6ZXNMaXN0Lmxlbmd0aDtcblxuXHRcdC8vIEZvciBlYWNoIHVucGFyc2VkIHNpemUgaW4gdW5wYXJzZWQgc2l6ZXMgbGlzdDpcblx0XHRmb3IgKGkgPSAwOyBpIDwgdW5wYXJzZWRTaXplc0xpc3RMZW5ndGg7IGkrKykge1xuXHRcdFx0dW5wYXJzZWRTaXplID0gdW5wYXJzZWRTaXplc0xpc3RbaV07XG5cblx0XHRcdC8vIDEuIFJlbW92ZSBhbGwgY29uc2VjdXRpdmUgPHdoaXRlc3BhY2UtdG9rZW4+cyBmcm9tIHRoZSBlbmQgb2YgdW5wYXJzZWQgc2l6ZS5cblx0XHRcdC8vICggcGFyc2VDb21wb25lbnRWYWx1ZXMoKSBhbHJlYWR5IG9taXRzIHNwYWNlcyBvdXRzaWRlIG9mIHBhcmVucy4gKVxuXG5cdFx0XHQvLyBJZiB1bnBhcnNlZCBzaXplIGlzIG5vdyBlbXB0eSwgdGhhdCBpcyBhIHBhcnNlIGVycm9yOyBjb250aW51ZSB0byB0aGUgbmV4dFxuXHRcdFx0Ly8gaXRlcmF0aW9uIG9mIHRoaXMgYWxnb3JpdGhtLlxuXHRcdFx0Ly8gKCBwYXJzZUNvbXBvbmVudFZhbHVlcygpIHdvbid0IHB1c2ggYW4gZW1wdHkgYXJyYXkuIClcblxuXHRcdFx0Ly8gMi4gSWYgdGhlIGxhc3QgY29tcG9uZW50IHZhbHVlIGluIHVucGFyc2VkIHNpemUgaXMgYSB2YWxpZCBub24tbmVnYXRpdmVcblx0XHRcdC8vIDxzb3VyY2Utc2l6ZS12YWx1ZT4sIGxldCBzaXplIGJlIGl0cyB2YWx1ZSBhbmQgcmVtb3ZlIHRoZSBjb21wb25lbnQgdmFsdWVcblx0XHRcdC8vIGZyb20gdW5wYXJzZWQgc2l6ZS4gQW55IENTUyBmdW5jdGlvbiBvdGhlciB0aGFuIHRoZSBjYWxjKCkgZnVuY3Rpb24gaXNcblx0XHRcdC8vIGludmFsaWQuIE90aGVyd2lzZSwgdGhlcmUgaXMgYSBwYXJzZSBlcnJvcjsgY29udGludWUgdG8gdGhlIG5leHQgaXRlcmF0aW9uXG5cdFx0XHQvLyBvZiB0aGlzIGFsZ29yaXRobS5cblx0XHRcdC8vIGh0dHA6Ly9kZXYudzMub3JnL2Nzc3dnL2Nzcy1zeW50YXgvI3BhcnNlLWNvbXBvbmVudC12YWx1ZVxuXHRcdFx0bGFzdENvbXBvbmVudFZhbHVlID0gdW5wYXJzZWRTaXplW3VucGFyc2VkU2l6ZS5sZW5ndGggLSAxXTtcblxuXHRcdFx0aWYgKGlzVmFsaWROb25OZWdhdGl2ZVNvdXJjZVNpemVWYWx1ZShsYXN0Q29tcG9uZW50VmFsdWUpKSB7XG5cdFx0XHRcdHNpemUgPSBsYXN0Q29tcG9uZW50VmFsdWU7XG5cdFx0XHRcdHVucGFyc2VkU2l6ZS5wb3AoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyAzLiBSZW1vdmUgYWxsIGNvbnNlY3V0aXZlIDx3aGl0ZXNwYWNlLXRva2VuPnMgZnJvbSB0aGUgZW5kIG9mIHVucGFyc2VkXG5cdFx0XHQvLyBzaXplLiBJZiB1bnBhcnNlZCBzaXplIGlzIG5vdyBlbXB0eSwgcmV0dXJuIHNpemUgYW5kIGV4aXQgdGhpcyBhbGdvcml0aG0uXG5cdFx0XHQvLyBJZiB0aGlzIHdhcyBub3QgdGhlIGxhc3QgaXRlbSBpbiB1bnBhcnNlZCBzaXplcyBsaXN0LCB0aGF0IGlzIGEgcGFyc2UgZXJyb3IuXG5cdFx0XHRpZiAodW5wYXJzZWRTaXplLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRyZXR1cm4gc2l6ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gNC4gUGFyc2UgdGhlIHJlbWFpbmluZyBjb21wb25lbnQgdmFsdWVzIGluIHVucGFyc2VkIHNpemUgYXMgYVxuXHRcdFx0Ly8gPG1lZGlhLWNvbmRpdGlvbj4uIElmIGl0IGRvZXMgbm90IHBhcnNlIGNvcnJlY3RseSwgb3IgaXQgZG9lcyBwYXJzZVxuXHRcdFx0Ly8gY29ycmVjdGx5IGJ1dCB0aGUgPG1lZGlhLWNvbmRpdGlvbj4gZXZhbHVhdGVzIHRvIGZhbHNlLCBjb250aW51ZSB0byB0aGVcblx0XHRcdC8vIG5leHQgaXRlcmF0aW9uIG9mIHRoaXMgYWxnb3JpdGhtLlxuXHRcdFx0Ly8gKFBhcnNpbmcgYWxsIHBvc3NpYmxlIGNvbXBvdW5kIG1lZGlhIGNvbmRpdGlvbnMgaW4gSlMgaXMgaGVhdnksIGNvbXBsaWNhdGVkLFxuXHRcdFx0Ly8gYW5kIHRoZSBwYXlvZmYgaXMgdW5jbGVhci4gSXMgdGhlcmUgZXZlciBhbiBzaXR1YXRpb24gd2hlcmUgdGhlXG5cdFx0XHQvLyBtZWRpYSBjb25kaXRpb24gcGFyc2VzIGluY29ycmVjdGx5IGJ1dCBzdGlsbCBzb21laG93IGV2YWx1YXRlcyB0byB0cnVlP1xuXHRcdFx0Ly8gQ2FuIHdlIGp1c3QgcmVseSBvbiB0aGUgYnJvd3Nlci9wb2x5ZmlsbCB0byBkbyBpdD8pXG5cdFx0XHR1bnBhcnNlZFNpemUgPSB1bnBhcnNlZFNpemUuam9pbihcIiBcIik7XG5cdFx0XHRpZiAoIShwZi5tYXRjaGVzTWVkaWEoIHVucGFyc2VkU2l6ZSApICkgKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyA1LiBSZXR1cm4gc2l6ZSBhbmQgZXhpdCB0aGlzIGFsZ29yaXRobS5cblx0XHRcdHJldHVybiBzaXplO1xuXHRcdH1cblxuXHRcdC8vIElmIHRoZSBhYm92ZSBhbGdvcml0aG0gZXhoYXVzdHMgdW5wYXJzZWQgc2l6ZXMgbGlzdCB3aXRob3V0IHJldHVybmluZyBhXG5cdFx0Ly8gc2l6ZSB2YWx1ZSwgcmV0dXJuIDEwMHZ3LlxuXHRcdHJldHVybiBcIjEwMHZ3XCI7XG5cdH1cblxuXHQvLyBuYW1lc3BhY2Vcblx0cGYubnMgPSAoXCJwZlwiICsgbmV3IERhdGUoKS5nZXRUaW1lKCkpLnN1YnN0cigwLCA5KTtcblxuXHQvLyBzcmNzZXQgc3VwcG9ydCB0ZXN0XG5cdHBmLnN1cFNyY3NldCA9IFwic3Jjc2V0XCIgaW4gaW1hZ2U7XG5cdHBmLnN1cFNpemVzID0gXCJzaXplc1wiIGluIGltYWdlO1xuXHRwZi5zdXBQaWN0dXJlID0gISF3aW5kb3cuSFRNTFBpY3R1cmVFbGVtZW50O1xuXG5cdC8vIFVDIGJyb3dzZXIgZG9lcyBjbGFpbSB0byBzdXBwb3J0IHNyY3NldCBhbmQgcGljdHVyZSwgYnV0IG5vdCBzaXplcyxcblx0Ly8gdGhpcyBleHRlbmRlZCB0ZXN0IHJldmVhbHMgdGhlIGJyb3dzZXIgZG9lcyBzdXBwb3J0IG5vdGhpbmdcblx0aWYgKHBmLnN1cFNyY3NldCAmJiBwZi5zdXBQaWN0dXJlICYmICFwZi5zdXBTaXplcykge1xuXHRcdChmdW5jdGlvbihpbWFnZTIpIHtcblx0XHRcdGltYWdlLnNyY3NldCA9IFwiZGF0YTosYVwiO1xuXHRcdFx0aW1hZ2UyLnNyYyA9IFwiZGF0YTosYVwiO1xuXHRcdFx0cGYuc3VwU3Jjc2V0ID0gaW1hZ2UuY29tcGxldGUgPT09IGltYWdlMi5jb21wbGV0ZTtcblx0XHRcdHBmLnN1cFBpY3R1cmUgPSBwZi5zdXBTcmNzZXQgJiYgcGYuc3VwUGljdHVyZTtcblx0XHR9KShkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpKTtcblx0fVxuXG5cdC8vIFNhZmFyaTkgaGFzIGJhc2ljIHN1cHBvcnQgZm9yIHNpemVzLCBidXQgZG9lcyd0IGV4cG9zZSB0aGUgYHNpemVzYCBpZGwgYXR0cmlidXRlXG5cdGlmIChwZi5zdXBTcmNzZXQgJiYgIXBmLnN1cFNpemVzKSB7XG5cblx0XHQoZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgd2lkdGgyID0gXCJkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBZ0FCQVBBQUFQLy8vd0FBQUNINUJBQUFBQUFBTEFBQUFBQUNBQUVBQUFJQ0JBb0FPdz09XCI7XG5cdFx0XHR2YXIgd2lkdGgxID0gXCJkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBUUFCQUFBQUFDSDVCQUVLQUFFQUxBQUFBQUFCQUFFQUFBSUNUQUVBT3c9PVwiO1xuXHRcdFx0dmFyIGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG5cdFx0XHR2YXIgdGVzdCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgd2lkdGggPSBpbWcud2lkdGg7XG5cblx0XHRcdFx0aWYgKHdpZHRoID09PSAyKSB7XG5cdFx0XHRcdFx0cGYuc3VwU2l6ZXMgPSB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YWx3YXlzQ2hlY2tXRGVzY3JpcHRvciA9IHBmLnN1cFNyY3NldCAmJiAhcGYuc3VwU2l6ZXM7XG5cblx0XHRcdFx0aXNTdXBwb3J0VGVzdFJlYWR5ID0gdHJ1ZTtcblx0XHRcdFx0Ly8gZm9yY2UgYXN5bmNcblx0XHRcdFx0c2V0VGltZW91dChwaWN0dXJlZmlsbCk7XG5cdFx0XHR9O1xuXG5cdFx0XHRpbWcub25sb2FkID0gdGVzdDtcblx0XHRcdGltZy5vbmVycm9yID0gdGVzdDtcblx0XHRcdGltZy5zZXRBdHRyaWJ1dGUoXCJzaXplc1wiLCBcIjlweFwiKTtcblxuXHRcdFx0aW1nLnNyY3NldCA9IHdpZHRoMSArIFwiIDF3LFwiICsgd2lkdGgyICsgXCIgOXdcIjtcblx0XHRcdGltZy5zcmMgPSB3aWR0aDE7XG5cdFx0fSkoKTtcblxuXHR9IGVsc2Uge1xuXHRcdGlzU3VwcG9ydFRlc3RSZWFkeSA9IHRydWU7XG5cdH1cblxuXHQvLyB1c2luZyBwZi5xc2EgaW5zdGVhZCBvZiBkb20gdHJhdmVyc2luZyBkb2VzIHNjYWxlIG11Y2ggYmV0dGVyLFxuXHQvLyBlc3BlY2lhbGx5IG9uIHNpdGVzIG1peGluZyByZXNwb25zaXZlIGFuZCBub24tcmVzcG9uc2l2ZSBpbWFnZXNcblx0cGYuc2VsU2hvcnQgPSBcInBpY3R1cmU+aW1nLGltZ1tzcmNzZXRdXCI7XG5cdHBmLnNlbCA9IHBmLnNlbFNob3J0O1xuXHRwZi5jZmcgPSBjZmc7XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHByb3BlcnR5IGZvciBgZGV2aWNlUGl4ZWxSYXRpb2AgKCBmb3IgZWFzeSBvdmVycmlkaW5nIGluIHRlc3RzIClcblx0ICovXG5cdHBmLkRQUiA9IChEUFIgIHx8IDEgKTtcblx0cGYudSA9IHVuaXRzO1xuXG5cdC8vIGNvbnRhaW5lciBvZiBzdXBwb3J0ZWQgbWltZSB0eXBlcyB0aGF0IG9uZSBtaWdodCBuZWVkIHRvIHF1YWxpZnkgYmVmb3JlIHVzaW5nXG5cdHBmLnR5cGVzID0gIHR5cGVzO1xuXG5cdHBmLnNldFNpemUgPSBub29wO1xuXG5cdC8qKlxuXHQgKiBHZXRzIGEgc3RyaW5nIGFuZCByZXR1cm5zIHRoZSBhYnNvbHV0ZSBVUkxcblx0ICogQHBhcmFtIHNyY1xuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBhYnNvbHV0ZSBVUkxcblx0ICovXG5cblx0cGYubWFrZVVybCA9IG1lbW9pemUoZnVuY3Rpb24oc3JjKSB7XG5cdFx0YW5jaG9yLmhyZWYgPSBzcmM7XG5cdFx0cmV0dXJuIGFuY2hvci5ocmVmO1xuXHR9KTtcblxuXHQvKipcblx0ICogR2V0cyBhIERPTSBlbGVtZW50IG9yIGRvY3VtZW50IGFuZCBhIHNlbGN0b3IgYW5kIHJldHVybnMgdGhlIGZvdW5kIG1hdGNoZXNcblx0ICogQ2FuIGJlIGV4dGVuZGVkIHdpdGggalF1ZXJ5L1NpenpsZSBmb3IgSUU3IHN1cHBvcnRcblx0ICogQHBhcmFtIGNvbnRleHRcblx0ICogQHBhcmFtIHNlbFxuXHQgKiBAcmV0dXJucyB7Tm9kZUxpc3R8QXJyYXl9XG5cdCAqL1xuXHRwZi5xc2EgPSBmdW5jdGlvbihjb250ZXh0LCBzZWwpIHtcblx0XHRyZXR1cm4gKCBcInF1ZXJ5U2VsZWN0b3JcIiBpbiBjb250ZXh0ICkgPyBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsKSA6IFtdO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCBtZXRob2QgZm9yIG1hdGNoTWVkaWEgKCBmb3IgZWFzeSBvdmVycmlkaW5nIGluIHRlc3RzIClcblx0ICogd2V0aGVyIG5hdGl2ZSBvciBwZi5tTVEgaXMgdXNlZCB3aWxsIGJlIGRlY2lkZWQgbGF6eSBvbiBmaXJzdCBjYWxsXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0cGYubWF0Y2hlc01lZGlhID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCB3aW5kb3cubWF0Y2hNZWRpYSAmJiAobWF0Y2hNZWRpYSggXCIobWluLXdpZHRoOiAwLjFlbSlcIiApIHx8IHt9KS5tYXRjaGVzICkge1xuXHRcdFx0cGYubWF0Y2hlc01lZGlhID0gZnVuY3Rpb24oIG1lZGlhICkge1xuXHRcdFx0XHRyZXR1cm4gIW1lZGlhIHx8ICggbWF0Y2hNZWRpYSggbWVkaWEgKS5tYXRjaGVzICk7XG5cdFx0XHR9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwZi5tYXRjaGVzTWVkaWEgPSBwZi5tTVE7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHBmLm1hdGNoZXNNZWRpYS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEEgc2ltcGxpZmllZCBtYXRjaE1lZGlhIGltcGxlbWVudGF0aW9uIGZvciBJRTggYW5kIElFOVxuXHQgKiBoYW5kbGVzIG9ubHkgbWluLXdpZHRoL21heC13aWR0aCB3aXRoIHB4IG9yIGVtIHZhbHVlc1xuXHQgKiBAcGFyYW0gbWVkaWFcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRwZi5tTVEgPSBmdW5jdGlvbiggbWVkaWEgKSB7XG5cdFx0cmV0dXJuIG1lZGlhID8gZXZhbENTUyhtZWRpYSkgOiB0cnVlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBjYWxjdWxhdGVkIGxlbmd0aCBpbiBjc3MgcGl4ZWwgZnJvbSB0aGUgZ2l2ZW4gc291cmNlU2l6ZVZhbHVlXG5cdCAqIGh0dHA6Ly9kZXYudzMub3JnL2Nzc3dnL2Nzcy12YWx1ZXMtMy8jbGVuZ3RoLXZhbHVlXG5cdCAqIGludGVuZGVkIFNwZWMgbWlzbWF0Y2hlczpcblx0ICogKiBEb2VzIG5vdCBjaGVjayBmb3IgaW52YWxpZCB1c2Ugb2YgQ1NTIGZ1bmN0aW9uc1xuXHQgKiAqIERvZXMgaGFuZGxlIGEgY29tcHV0ZWQgbGVuZ3RoIG9mIDAgdGhlIHNhbWUgYXMgYSBuZWdhdGl2ZSBhbmQgdGhlcmVmb3JlIGludmFsaWQgdmFsdWVcblx0ICogQHBhcmFtIHNvdXJjZVNpemVWYWx1ZVxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfVxuXHQgKi9cblx0cGYuY2FsY0xlbmd0aCA9IGZ1bmN0aW9uKCBzb3VyY2VTaXplVmFsdWUgKSB7XG5cblx0XHR2YXIgdmFsdWUgPSBldmFsQ1NTKHNvdXJjZVNpemVWYWx1ZSwgdHJ1ZSkgfHwgZmFsc2U7XG5cdFx0aWYgKHZhbHVlIDwgMCkge1xuXHRcdFx0dmFsdWUgPSBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsdWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRha2VzIGEgdHlwZSBzdHJpbmcgYW5kIGNoZWNrcyBpZiBpdHMgc3VwcG9ydGVkXG5cdCAqL1xuXG5cdHBmLnN1cHBvcnRzVHlwZSA9IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdHJldHVybiAoIHR5cGUgKSA/IHR5cGVzWyB0eXBlIF0gOiB0cnVlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBQYXJzZXMgYSBzb3VyY2VTaXplIGludG8gbWVkaWFDb25kaXRpb24gKG1lZGlhKSBhbmQgc291cmNlU2l6ZVZhbHVlIChsZW5ndGgpXG5cdCAqIEBwYXJhbSBzb3VyY2VTaXplU3RyXG5cdCAqIEByZXR1cm5zIHsqfVxuXHQgKi9cblx0cGYucGFyc2VTaXplID0gbWVtb2l6ZShmdW5jdGlvbiggc291cmNlU2l6ZVN0ciApIHtcblx0XHR2YXIgbWF0Y2ggPSAoIHNvdXJjZVNpemVTdHIgfHwgXCJcIiApLm1hdGNoKHJlZ1NpemUpO1xuXHRcdHJldHVybiB7XG5cdFx0XHRtZWRpYTogbWF0Y2ggJiYgbWF0Y2hbMV0sXG5cdFx0XHRsZW5ndGg6IG1hdGNoICYmIG1hdGNoWzJdXG5cdFx0fTtcblx0fSk7XG5cblx0cGYucGFyc2VTZXQgPSBmdW5jdGlvbiggc2V0ICkge1xuXHRcdGlmICggIXNldC5jYW5kcyApIHtcblx0XHRcdHNldC5jYW5kcyA9IHBhcnNlU3Jjc2V0KHNldC5zcmNzZXQsIHNldCk7XG5cdFx0fVxuXHRcdHJldHVybiBzZXQuY2FuZHM7XG5cdH07XG5cblx0LyoqXG5cdCAqIHJldHVybnMgMWVtIGluIGNzcyBweCBmb3IgaHRtbC9ib2R5IGRlZmF1bHQgc2l6ZVxuXHQgKiBmdW5jdGlvbiB0YWtlbiBmcm9tIHJlc3BvbmRqc1xuXHQgKiBAcmV0dXJucyB7KnxudW1iZXJ9XG5cdCAqL1xuXHRwZi5nZXRFbVZhbHVlID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGJvZHk7XG5cdFx0aWYgKCAhZW1pbnB4ICYmIChib2R5ID0gZG9jdW1lbnQuYm9keSkgKSB7XG5cdFx0XHR2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLFxuXHRcdFx0XHRvcmlnaW5hbEhUTUxDU1MgPSBkb2NFbGVtLnN0eWxlLmNzc1RleHQsXG5cdFx0XHRcdG9yaWdpbmFsQm9keUNTUyA9IGJvZHkuc3R5bGUuY3NzVGV4dDtcblxuXHRcdFx0ZGl2LnN0eWxlLmNzc1RleHQgPSBiYXNlU3R5bGU7XG5cblx0XHRcdC8vIDFlbSBpbiBhIG1lZGlhIHF1ZXJ5IGlzIHRoZSB2YWx1ZSBvZiB0aGUgZGVmYXVsdCBmb250IHNpemUgb2YgdGhlIGJyb3dzZXJcblx0XHRcdC8vIHJlc2V0IGRvY0VsZW0gYW5kIGJvZHkgdG8gZW5zdXJlIHRoZSBjb3JyZWN0IHZhbHVlIGlzIHJldHVybmVkXG5cdFx0XHRkb2NFbGVtLnN0eWxlLmNzc1RleHQgPSBmc0Nzcztcblx0XHRcdGJvZHkuc3R5bGUuY3NzVGV4dCA9IGZzQ3NzO1xuXG5cdFx0XHRib2R5LmFwcGVuZENoaWxkKCBkaXYgKTtcblx0XHRcdGVtaW5weCA9IGRpdi5vZmZzZXRXaWR0aDtcblx0XHRcdGJvZHkucmVtb3ZlQ2hpbGQoIGRpdiApO1xuXG5cdFx0XHQvL2Fsc28gdXBkYXRlIGVtaW5weCBiZWZvcmUgcmV0dXJuaW5nXG5cdFx0XHRlbWlucHggPSBwYXJzZUZsb2F0KCBlbWlucHgsIDEwICk7XG5cblx0XHRcdC8vIHJlc3RvcmUgdGhlIG9yaWdpbmFsIHZhbHVlc1xuXHRcdFx0ZG9jRWxlbS5zdHlsZS5jc3NUZXh0ID0gb3JpZ2luYWxIVE1MQ1NTO1xuXHRcdFx0Ym9keS5zdHlsZS5jc3NUZXh0ID0gb3JpZ2luYWxCb2R5Q1NTO1xuXG5cdFx0fVxuXHRcdHJldHVybiBlbWlucHggfHwgMTY7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRha2VzIGEgc3RyaW5nIG9mIHNpemVzIGFuZCByZXR1cm5zIHRoZSB3aWR0aCBpbiBwaXhlbHMgYXMgYSBudW1iZXJcblx0ICovXG5cdHBmLmNhbGNMaXN0TGVuZ3RoID0gZnVuY3Rpb24oIHNvdXJjZVNpemVMaXN0U3RyICkge1xuXHRcdC8vIFNwbGl0IHVwIHNvdXJjZSBzaXplIGxpc3QsIGllICggbWF4LXdpZHRoOiAzMGVtICkgMTAwJSwgKCBtYXgtd2lkdGg6IDUwZW0gKSA1MCUsIDMzJVxuXHRcdC8vXG5cdFx0Ly8gICAgICAgICAgICAgICAgICAgICAgICAgICBvciAobWluLXdpZHRoOjMwZW0pIGNhbGMoMzAlIC0gMTVweClcblx0XHRpZiAoICEoc291cmNlU2l6ZUxpc3RTdHIgaW4gc2l6ZUxlbmd0aENhY2hlKSB8fCBjZmcudVQgKSB7XG5cdFx0XHR2YXIgd2lubmluZ0xlbmd0aCA9IHBmLmNhbGNMZW5ndGgoIHBhcnNlU2l6ZXMoIHNvdXJjZVNpemVMaXN0U3RyICkgKTtcblxuXHRcdFx0c2l6ZUxlbmd0aENhY2hlWyBzb3VyY2VTaXplTGlzdFN0ciBdID0gIXdpbm5pbmdMZW5ndGggPyB1bml0cy53aWR0aCA6IHdpbm5pbmdMZW5ndGg7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNpemVMZW5ndGhDYWNoZVsgc291cmNlU2l6ZUxpc3RTdHIgXTtcblx0fTtcblxuXHQvKipcblx0ICogVGFrZXMgYSBjYW5kaWRhdGUgb2JqZWN0IHdpdGggYSBzcmNzZXQgcHJvcGVydHkgaW4gdGhlIGZvcm0gb2YgdXJsL1xuXHQgKiBleC4gXCJpbWFnZXMvcGljLW1lZGl1bS5wbmcgMXgsIGltYWdlcy9waWMtbWVkaXVtLTJ4LnBuZyAyeFwiIG9yXG5cdCAqICAgICBcImltYWdlcy9waWMtbWVkaXVtLnBuZyA0MDB3LCBpbWFnZXMvcGljLW1lZGl1bS0yeC5wbmcgODAwd1wiIG9yXG5cdCAqICAgICBcImltYWdlcy9waWMtc21hbGwucG5nXCJcblx0ICogR2V0IGFuIGFycmF5IG9mIGltYWdlIGNhbmRpZGF0ZXMgaW4gdGhlIGZvcm0gb2Zcblx0ICogICAgICB7dXJsOiBcIi9mb28vYmFyLnBuZ1wiLCByZXNvbHV0aW9uOiAxfVxuXHQgKiB3aGVyZSByZXNvbHV0aW9uIGlzIGh0dHA6Ly9kZXYudzMub3JnL2Nzc3dnL2Nzcy12YWx1ZXMtMy8jcmVzb2x1dGlvbi12YWx1ZVxuXHQgKiBJZiBzaXplcyBpcyBzcGVjaWZpZWQsIHJlcyBpcyBjYWxjdWxhdGVkXG5cdCAqL1xuXHRwZi5zZXRSZXMgPSBmdW5jdGlvbiggc2V0ICkge1xuXHRcdHZhciBjYW5kaWRhdGVzO1xuXHRcdGlmICggc2V0ICkge1xuXG5cdFx0XHRjYW5kaWRhdGVzID0gcGYucGFyc2VTZXQoIHNldCApO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGxlbiA9IGNhbmRpZGF0ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdHNldFJlc29sdXRpb24oIGNhbmRpZGF0ZXNbIGkgXSwgc2V0LnNpemVzICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBjYW5kaWRhdGVzO1xuXHR9O1xuXG5cdHBmLnNldFJlcy5yZXMgPSBzZXRSZXNvbHV0aW9uO1xuXG5cdHBmLmFwcGx5U2V0Q2FuZGlkYXRlID0gZnVuY3Rpb24oIGNhbmRpZGF0ZXMsIGltZyApIHtcblx0XHRpZiAoICFjYW5kaWRhdGVzLmxlbmd0aCApIHtyZXR1cm47fVxuXHRcdHZhciBjYW5kaWRhdGUsXG5cdFx0XHRpLFxuXHRcdFx0aixcblx0XHRcdGxlbmd0aCxcblx0XHRcdGJlc3RDYW5kaWRhdGUsXG5cdFx0XHRjdXJTcmMsXG5cdFx0XHRjdXJDYW4sXG5cdFx0XHRjYW5kaWRhdGVTcmMsXG5cdFx0XHRhYm9ydEN1clNyYztcblxuXHRcdHZhciBpbWFnZURhdGEgPSBpbWdbIHBmLm5zIF07XG5cdFx0dmFyIGRwciA9IHBmLkRQUjtcblxuXHRcdGN1clNyYyA9IGltYWdlRGF0YS5jdXJTcmMgfHwgaW1nW2N1clNyY1Byb3BdO1xuXG5cdFx0Y3VyQ2FuID0gaW1hZ2VEYXRhLmN1ckNhbiB8fCBzZXRTcmNUb0N1cihpbWcsIGN1clNyYywgY2FuZGlkYXRlc1swXS5zZXQpO1xuXG5cdFx0Ly8gaWYgd2UgaGF2ZSBhIGN1cnJlbnQgc291cmNlLCB3ZSBtaWdodCBlaXRoZXIgYmVjb21lIGxhenkgb3IgZ2l2ZSB0aGlzIHNvdXJjZSBzb21lIGFkdmFudGFnZVxuXHRcdGlmICggY3VyQ2FuICYmIGN1ckNhbi5zZXQgPT09IGNhbmRpZGF0ZXNbIDAgXS5zZXQgKSB7XG5cblx0XHRcdC8vIGlmIGJyb3dzZXIgY2FuIGFib3J0IGltYWdlIHJlcXVlc3QgYW5kIHRoZSBpbWFnZSBoYXMgYSBoaWdoZXIgcGl4ZWwgZGVuc2l0eSB0aGFuIG5lZWRlZFxuXHRcdFx0Ly8gYW5kIHRoaXMgaW1hZ2UgaXNuJ3QgZG93bmxvYWRlZCB5ZXQsIHdlIHNraXAgbmV4dCBwYXJ0IGFuZCB0cnkgdG8gc2F2ZSBiYW5kd2lkdGhcblx0XHRcdGFib3J0Q3VyU3JjID0gKHN1cHBvcnRBYm9ydCAmJiAhaW1nLmNvbXBsZXRlICYmIGN1ckNhbi5yZXMgLSAwLjEgPiBkcHIpO1xuXG5cdFx0XHRpZiAoICFhYm9ydEN1clNyYyApIHtcblx0XHRcdFx0Y3VyQ2FuLmNhY2hlZCA9IHRydWU7XG5cblx0XHRcdFx0Ly8gaWYgY3VycmVudCBjYW5kaWRhdGUgaXMgXCJiZXN0XCIsIFwiYmV0dGVyXCIgb3IgXCJva2F5XCIsXG5cdFx0XHRcdC8vIHNldCBpdCB0byBiZXN0Q2FuZGlkYXRlXG5cdFx0XHRcdGlmICggY3VyQ2FuLnJlcyA+PSBkcHIgKSB7XG5cdFx0XHRcdFx0YmVzdENhbmRpZGF0ZSA9IGN1ckNhbjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggIWJlc3RDYW5kaWRhdGUgKSB7XG5cblx0XHRcdGNhbmRpZGF0ZXMuc29ydCggYXNjZW5kaW5nU29ydCApO1xuXG5cdFx0XHRsZW5ndGggPSBjYW5kaWRhdGVzLmxlbmd0aDtcblx0XHRcdGJlc3RDYW5kaWRhdGUgPSBjYW5kaWRhdGVzWyBsZW5ndGggLSAxIF07XG5cblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdGNhbmRpZGF0ZSA9IGNhbmRpZGF0ZXNbIGkgXTtcblx0XHRcdFx0aWYgKCBjYW5kaWRhdGUucmVzID49IGRwciApIHtcblx0XHRcdFx0XHRqID0gaSAtIDE7XG5cblx0XHRcdFx0XHQvLyB3ZSBoYXZlIGZvdW5kIHRoZSBwZXJmZWN0IGNhbmRpZGF0ZSxcblx0XHRcdFx0XHQvLyBidXQgbGV0J3MgaW1wcm92ZSB0aGlzIGEgbGl0dGxlIGJpdCB3aXRoIHNvbWUgYXNzdW1wdGlvbnMgOy0pXG5cdFx0XHRcdFx0aWYgKGNhbmRpZGF0ZXNbIGogXSAmJlxuXHRcdFx0XHRcdFx0KGFib3J0Q3VyU3JjIHx8IGN1clNyYyAhPT0gcGYubWFrZVVybCggY2FuZGlkYXRlLnVybCApKSAmJlxuXHRcdFx0XHRcdFx0Y2hvb3NlTG93UmVzKGNhbmRpZGF0ZXNbIGogXS5yZXMsIGNhbmRpZGF0ZS5yZXMsIGRwciwgY2FuZGlkYXRlc1sgaiBdLmNhY2hlZCkpIHtcblxuXHRcdFx0XHRcdFx0YmVzdENhbmRpZGF0ZSA9IGNhbmRpZGF0ZXNbIGogXTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRiZXN0Q2FuZGlkYXRlID0gY2FuZGlkYXRlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggYmVzdENhbmRpZGF0ZSApIHtcblxuXHRcdFx0Y2FuZGlkYXRlU3JjID0gcGYubWFrZVVybCggYmVzdENhbmRpZGF0ZS51cmwgKTtcblxuXHRcdFx0aW1hZ2VEYXRhLmN1clNyYyA9IGNhbmRpZGF0ZVNyYztcblx0XHRcdGltYWdlRGF0YS5jdXJDYW4gPSBiZXN0Q2FuZGlkYXRlO1xuXG5cdFx0XHRpZiAoIGNhbmRpZGF0ZVNyYyAhPT0gY3VyU3JjICkge1xuXHRcdFx0XHRwZi5zZXRTcmMoIGltZywgYmVzdENhbmRpZGF0ZSApO1xuXHRcdFx0fVxuXHRcdFx0cGYuc2V0U2l6ZSggaW1nICk7XG5cdFx0fVxuXHR9O1xuXG5cdHBmLnNldFNyYyA9IGZ1bmN0aW9uKCBpbWcsIGJlc3RDYW5kaWRhdGUgKSB7XG5cdFx0dmFyIG9yaWdXaWR0aDtcblx0XHRpbWcuc3JjID0gYmVzdENhbmRpZGF0ZS51cmw7XG5cblx0XHQvLyBhbHRob3VnaCB0aGlzIGlzIGEgc3BlY2lmaWMgU2FmYXJpIGlzc3VlLCB3ZSBkb24ndCB3YW50IHRvIHRha2UgdG9vIG11Y2ggZGlmZmVyZW50IGNvZGUgcGF0aHNcblx0XHRpZiAoIGJlc3RDYW5kaWRhdGUuc2V0LnR5cGUgPT09IFwiaW1hZ2Uvc3ZnK3htbFwiICkge1xuXHRcdFx0b3JpZ1dpZHRoID0gaW1nLnN0eWxlLndpZHRoO1xuXHRcdFx0aW1nLnN0eWxlLndpZHRoID0gKGltZy5vZmZzZXRXaWR0aCArIDEpICsgXCJweFwiO1xuXG5cdFx0XHQvLyBuZXh0IGxpbmUgb25seSBzaG91bGQgdHJpZ2dlciBhIHJlcGFpbnRcblx0XHRcdC8vIGlmLi4uIGlzIG9ubHkgZG9uZSB0byB0cmljayBkZWFkIGNvZGUgcmVtb3ZhbFxuXHRcdFx0aWYgKCBpbWcub2Zmc2V0V2lkdGggKyAxICkge1xuXHRcdFx0XHRpbWcuc3R5bGUud2lkdGggPSBvcmlnV2lkdGg7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdHBmLmdldFNldCA9IGZ1bmN0aW9uKCBpbWcgKSB7XG5cdFx0dmFyIGksIHNldCwgc3VwcG9ydHNUeXBlO1xuXHRcdHZhciBtYXRjaCA9IGZhbHNlO1xuXHRcdHZhciBzZXRzID0gaW1nIFsgcGYubnMgXS5zZXRzO1xuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBzZXRzLmxlbmd0aCAmJiAhbWF0Y2g7IGkrKyApIHtcblx0XHRcdHNldCA9IHNldHNbaV07XG5cblx0XHRcdGlmICggIXNldC5zcmNzZXQgfHwgIXBmLm1hdGNoZXNNZWRpYSggc2V0Lm1lZGlhICkgfHwgIShzdXBwb3J0c1R5cGUgPSBwZi5zdXBwb3J0c1R5cGUoIHNldC50eXBlICkpICkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBzdXBwb3J0c1R5cGUgPT09IFwicGVuZGluZ1wiICkge1xuXHRcdFx0XHRzZXQgPSBzdXBwb3J0c1R5cGU7XG5cdFx0XHR9XG5cblx0XHRcdG1hdGNoID0gc2V0O1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hdGNoO1xuXHR9O1xuXG5cdHBmLnBhcnNlU2V0cyA9IGZ1bmN0aW9uKCBlbGVtZW50LCBwYXJlbnQsIG9wdGlvbnMgKSB7XG5cdFx0dmFyIHNyY3NldEF0dHJpYnV0ZSwgaW1hZ2VTZXQsIGlzV0Rlc2NyaXBvciwgc3Jjc2V0UGFyc2VkO1xuXG5cdFx0dmFyIGhhc1BpY3R1cmUgPSBwYXJlbnQgJiYgcGFyZW50Lm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT09IFwiUElDVFVSRVwiO1xuXHRcdHZhciBpbWFnZURhdGEgPSBlbGVtZW50WyBwZi5ucyBdO1xuXG5cdFx0aWYgKCBpbWFnZURhdGEuc3JjID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5zcmMgKSB7XG5cdFx0XHRpbWFnZURhdGEuc3JjID0gZ2V0SW1nQXR0ci5jYWxsKCBlbGVtZW50LCBcInNyY1wiICk7XG5cdFx0XHRpZiAoIGltYWdlRGF0YS5zcmMgKSB7XG5cdFx0XHRcdHNldEltZ0F0dHIuY2FsbCggZWxlbWVudCwgc3JjQXR0ciwgaW1hZ2VEYXRhLnNyYyApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVtb3ZlSW1nQXR0ci5jYWxsKCBlbGVtZW50LCBzcmNBdHRyICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBpbWFnZURhdGEuc3Jjc2V0ID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5zcmNzZXQgfHwgIXBmLnN1cFNyY3NldCB8fCBlbGVtZW50LnNyY3NldCApIHtcblx0XHRcdHNyY3NldEF0dHJpYnV0ZSA9IGdldEltZ0F0dHIuY2FsbCggZWxlbWVudCwgXCJzcmNzZXRcIiApO1xuXHRcdFx0aW1hZ2VEYXRhLnNyY3NldCA9IHNyY3NldEF0dHJpYnV0ZTtcblx0XHRcdHNyY3NldFBhcnNlZCA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aW1hZ2VEYXRhLnNldHMgPSBbXTtcblxuXHRcdGlmICggaGFzUGljdHVyZSApIHtcblx0XHRcdGltYWdlRGF0YS5waWMgPSB0cnVlO1xuXHRcdFx0Z2V0QWxsU291cmNlRWxlbWVudHMoIHBhcmVudCwgaW1hZ2VEYXRhLnNldHMgKTtcblx0XHR9XG5cblx0XHRpZiAoIGltYWdlRGF0YS5zcmNzZXQgKSB7XG5cdFx0XHRpbWFnZVNldCA9IHtcblx0XHRcdFx0c3Jjc2V0OiBpbWFnZURhdGEuc3Jjc2V0LFxuXHRcdFx0XHRzaXplczogZ2V0SW1nQXR0ci5jYWxsKCBlbGVtZW50LCBcInNpemVzXCIgKVxuXHRcdFx0fTtcblxuXHRcdFx0aW1hZ2VEYXRhLnNldHMucHVzaCggaW1hZ2VTZXQgKTtcblxuXHRcdFx0aXNXRGVzY3JpcG9yID0gKGFsd2F5c0NoZWNrV0Rlc2NyaXB0b3IgfHwgaW1hZ2VEYXRhLnNyYykgJiYgcmVnV0Rlc2MudGVzdChpbWFnZURhdGEuc3Jjc2V0IHx8IFwiXCIpO1xuXG5cdFx0XHQvLyBhZGQgbm9ybWFsIHNyYyBhcyBjYW5kaWRhdGUsIGlmIHNvdXJjZSBoYXMgbm8gdyBkZXNjcmlwdG9yXG5cdFx0XHRpZiAoICFpc1dEZXNjcmlwb3IgJiYgaW1hZ2VEYXRhLnNyYyAmJiAhZ2V0Q2FuZGlkYXRlRm9yU3JjKGltYWdlRGF0YS5zcmMsIGltYWdlU2V0KSAmJiAhaW1hZ2VTZXQuaGFzMXggKSB7XG5cdFx0XHRcdGltYWdlU2V0LnNyY3NldCArPSBcIiwgXCIgKyBpbWFnZURhdGEuc3JjO1xuXHRcdFx0XHRpbWFnZVNldC5jYW5kcy5wdXNoKHtcblx0XHRcdFx0XHR1cmw6IGltYWdlRGF0YS5zcmMsXG5cdFx0XHRcdFx0ZDogMSxcblx0XHRcdFx0XHRzZXQ6IGltYWdlU2V0XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICggaW1hZ2VEYXRhLnNyYyApIHtcblx0XHRcdGltYWdlRGF0YS5zZXRzLnB1c2goIHtcblx0XHRcdFx0c3Jjc2V0OiBpbWFnZURhdGEuc3JjLFxuXHRcdFx0XHRzaXplczogbnVsbFxuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGltYWdlRGF0YS5jdXJDYW4gPSBudWxsO1xuXHRcdGltYWdlRGF0YS5jdXJTcmMgPSB1bmRlZmluZWQ7XG5cblx0XHQvLyBpZiBpbWcgaGFzIHBpY3R1cmUgb3IgdGhlIHNyY3NldCB3YXMgcmVtb3ZlZCBvciBoYXMgYSBzcmNzZXQgYW5kIGRvZXMgbm90IHN1cHBvcnQgc3Jjc2V0IGF0IGFsbFxuXHRcdC8vIG9yIGhhcyBhIHcgZGVzY3JpcHRvciAoYW5kIGRvZXMgbm90IHN1cHBvcnQgc2l6ZXMpIHNldCBzdXBwb3J0IHRvIGZhbHNlIHRvIGV2YWx1YXRlXG5cdFx0aW1hZ2VEYXRhLnN1cHBvcnRlZCA9ICEoIGhhc1BpY3R1cmUgfHwgKCBpbWFnZVNldCAmJiAhcGYuc3VwU3Jjc2V0ICkgfHwgKGlzV0Rlc2NyaXBvciAmJiAhcGYuc3VwU2l6ZXMpICk7XG5cblx0XHRpZiAoIHNyY3NldFBhcnNlZCAmJiBwZi5zdXBTcmNzZXQgJiYgIWltYWdlRGF0YS5zdXBwb3J0ZWQgKSB7XG5cdFx0XHRpZiAoIHNyY3NldEF0dHJpYnV0ZSApIHtcblx0XHRcdFx0c2V0SW1nQXR0ci5jYWxsKCBlbGVtZW50LCBzcmNzZXRBdHRyLCBzcmNzZXRBdHRyaWJ1dGUgKTtcblx0XHRcdFx0ZWxlbWVudC5zcmNzZXQgPSBcIlwiO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVtb3ZlSW1nQXR0ci5jYWxsKCBlbGVtZW50LCBzcmNzZXRBdHRyICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGltYWdlRGF0YS5zdXBwb3J0ZWQgJiYgIWltYWdlRGF0YS5zcmNzZXQgJiYgKCghaW1hZ2VEYXRhLnNyYyAmJiBlbGVtZW50LnNyYykgfHwgIGVsZW1lbnQuc3JjICE9PSBwZi5tYWtlVXJsKGltYWdlRGF0YS5zcmMpKSkge1xuXHRcdFx0aWYgKGltYWdlRGF0YS5zcmMgPT09IG51bGwpIHtcblx0XHRcdFx0ZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJzcmNcIik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtZW50LnNyYyA9IGltYWdlRGF0YS5zcmM7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aW1hZ2VEYXRhLnBhcnNlZCA9IHRydWU7XG5cdH07XG5cblx0cGYuZmlsbEltZyA9IGZ1bmN0aW9uKGVsZW1lbnQsIG9wdGlvbnMpIHtcblx0XHR2YXIgaW1hZ2VEYXRhO1xuXHRcdHZhciBleHRyZW1lID0gb3B0aW9ucy5yZXNlbGVjdCB8fCBvcHRpb25zLnJlZXZhbHVhdGU7XG5cblx0XHQvLyBleHBhbmRvIGZvciBjYWNoaW5nIGRhdGEgb24gdGhlIGltZ1xuXHRcdGlmICggIWVsZW1lbnRbIHBmLm5zIF0gKSB7XG5cdFx0XHRlbGVtZW50WyBwZi5ucyBdID0ge307XG5cdFx0fVxuXG5cdFx0aW1hZ2VEYXRhID0gZWxlbWVudFsgcGYubnMgXTtcblxuXHRcdC8vIGlmIHRoZSBlbGVtZW50IGhhcyBhbHJlYWR5IGJlZW4gZXZhbHVhdGVkLCBza2lwIGl0XG5cdFx0Ly8gdW5sZXNzIGBvcHRpb25zLnJlZXZhbHVhdGVgIGlzIHNldCB0byB0cnVlICggdGhpcywgZm9yIGV4YW1wbGUsXG5cdFx0Ly8gaXMgc2V0IHRvIHRydWUgd2hlbiBydW5uaW5nIGBwaWN0dXJlZmlsbGAgb24gYHJlc2l6ZWAgKS5cblx0XHRpZiAoICFleHRyZW1lICYmIGltYWdlRGF0YS5ldmFsZWQgPT09IGV2YWxJZCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoICFpbWFnZURhdGEucGFyc2VkIHx8IG9wdGlvbnMucmVldmFsdWF0ZSApIHtcblx0XHRcdHBmLnBhcnNlU2V0cyggZWxlbWVudCwgZWxlbWVudC5wYXJlbnROb2RlLCBvcHRpb25zICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhaW1hZ2VEYXRhLnN1cHBvcnRlZCApIHtcblx0XHRcdGFwcGx5QmVzdENhbmRpZGF0ZSggZWxlbWVudCApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpbWFnZURhdGEuZXZhbGVkID0gZXZhbElkO1xuXHRcdH1cblx0fTtcblxuXHRwZi5zZXR1cFJ1biA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggIWFscmVhZHlSdW4gfHwgaXNWd0RpcnR5IHx8IChEUFIgIT09IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKSApIHtcblx0XHRcdHVwZGF0ZU1ldHJpY3MoKTtcblx0XHR9XG5cdH07XG5cblx0Ly8gSWYgcGljdHVyZSBpcyBzdXBwb3J0ZWQsIHdlbGwsIHRoYXQncyBhd2Vzb21lLlxuXHRpZiAoIHBmLnN1cFBpY3R1cmUgKSB7XG5cdFx0cGljdHVyZWZpbGwgPSBub29wO1xuXHRcdHBmLmZpbGxJbWcgPSBub29wO1xuXHR9IGVsc2Uge1xuXG5cdFx0IC8vIFNldCB1cCBwaWN0dXJlIHBvbHlmaWxsIGJ5IHBvbGxpbmcgdGhlIGRvY3VtZW50XG5cdFx0KGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGlzRG9tUmVhZHk7XG5cdFx0XHR2YXIgcmVnUmVhZHkgPSB3aW5kb3cuYXR0YWNoRXZlbnQgPyAvZCR8XmMvIDogL2QkfF5jfF5pLztcblxuXHRcdFx0dmFyIHJ1biA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgcmVhZHlTdGF0ZSA9IGRvY3VtZW50LnJlYWR5U3RhdGUgfHwgXCJcIjtcblxuXHRcdFx0XHR0aW1lcklkID0gc2V0VGltZW91dChydW4sIHJlYWR5U3RhdGUgPT09IFwibG9hZGluZ1wiID8gMjAwIDogIDk5OSk7XG5cdFx0XHRcdGlmICggZG9jdW1lbnQuYm9keSApIHtcblx0XHRcdFx0XHRwZi5maWxsSW1ncygpO1xuXHRcdFx0XHRcdGlzRG9tUmVhZHkgPSBpc0RvbVJlYWR5IHx8IHJlZ1JlYWR5LnRlc3QocmVhZHlTdGF0ZSk7XG5cdFx0XHRcdFx0aWYgKCBpc0RvbVJlYWR5ICkge1xuXHRcdFx0XHRcdFx0Y2xlYXJUaW1lb3V0KCB0aW1lcklkICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdHZhciB0aW1lcklkID0gc2V0VGltZW91dChydW4sIGRvY3VtZW50LmJvZHkgPyA5IDogOTkpO1xuXG5cdFx0XHQvLyBBbHNvIGF0dGFjaCBwaWN0dXJlZmlsbCBvbiByZXNpemUgYW5kIHJlYWR5c3RhdGVjaGFuZ2Vcblx0XHRcdC8vIGh0dHA6Ly9tb2Rlcm5qYXZhc2NyaXB0LmJsb2dzcG90LmNvbS8yMDEzLzA4L2J1aWxkaW5nLWJldHRlci1kZWJvdW5jZS5odG1sXG5cdFx0XHR2YXIgZGVib3VuY2UgPSBmdW5jdGlvbihmdW5jLCB3YWl0KSB7XG5cdFx0XHRcdHZhciB0aW1lb3V0LCB0aW1lc3RhbXA7XG5cdFx0XHRcdHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHZhciBsYXN0ID0gKG5ldyBEYXRlKCkpIC0gdGltZXN0YW1wO1xuXG5cdFx0XHRcdFx0aWYgKGxhc3QgPCB3YWl0KSB7XG5cdFx0XHRcdFx0XHR0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCAtIGxhc3QpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aW1lb3V0ID0gbnVsbDtcblx0XHRcdFx0XHRcdGZ1bmMoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHRpbWVzdGFtcCA9IG5ldyBEYXRlKCk7XG5cblx0XHRcdFx0XHRpZiAoIXRpbWVvdXQpIHtcblx0XHRcdFx0XHRcdHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdFx0dmFyIGxhc3RDbGllbnRXaWR0aCA9IGRvY0VsZW0uY2xpZW50SGVpZ2h0O1xuXHRcdFx0dmFyIG9uUmVzaXplID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlzVndEaXJ0eSA9IE1hdGgubWF4KHdpbmRvdy5pbm5lcldpZHRoIHx8IDAsIGRvY0VsZW0uY2xpZW50V2lkdGgpICE9PSB1bml0cy53aWR0aCB8fCBkb2NFbGVtLmNsaWVudEhlaWdodCAhPT0gbGFzdENsaWVudFdpZHRoO1xuXHRcdFx0XHRsYXN0Q2xpZW50V2lkdGggPSBkb2NFbGVtLmNsaWVudEhlaWdodDtcblx0XHRcdFx0aWYgKCBpc1Z3RGlydHkgKSB7XG5cdFx0XHRcdFx0cGYuZmlsbEltZ3MoKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0b24oIHdpbmRvdywgXCJyZXNpemVcIiwgZGVib3VuY2Uob25SZXNpemUsIDk5ICkgKTtcblx0XHRcdG9uKCBkb2N1bWVudCwgXCJyZWFkeXN0YXRlY2hhbmdlXCIsIHJ1biApO1xuXHRcdH0pKCk7XG5cdH1cblxuXHRwZi5waWN0dXJlZmlsbCA9IHBpY3R1cmVmaWxsO1xuXHQvL3VzZSB0aGlzIGludGVybmFsbHkgZm9yIGVhc3kgbW9ua2V5IHBhdGNoaW5nL3BlcmZvcm1hbmNlIHRlc3Rpbmdcblx0cGYuZmlsbEltZ3MgPSBwaWN0dXJlZmlsbDtcblx0cGYudGVhcmRvd25SdW4gPSBub29wO1xuXG5cdC8qIGV4cG9zZSBtZXRob2RzIGZvciB0ZXN0aW5nICovXG5cdHBpY3R1cmVmaWxsLl8gPSBwZjtcblxuXHR3aW5kb3cucGljdHVyZWZpbGxDRkcgPSB7XG5cdFx0cGY6IHBmLFxuXHRcdHB1c2g6IGZ1bmN0aW9uKGFyZ3MpIHtcblx0XHRcdHZhciBuYW1lID0gYXJncy5zaGlmdCgpO1xuXHRcdFx0aWYgKHR5cGVvZiBwZltuYW1lXSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdHBmW25hbWVdLmFwcGx5KHBmLCBhcmdzKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNmZ1tuYW1lXSA9IGFyZ3NbMF07XG5cdFx0XHRcdGlmIChhbHJlYWR5UnVuKSB7XG5cdFx0XHRcdFx0cGYuZmlsbEltZ3MoIHsgcmVzZWxlY3Q6IHRydWUgfSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdHdoaWxlIChzZXRPcHRpb25zICYmIHNldE9wdGlvbnMubGVuZ3RoKSB7XG5cdFx0d2luZG93LnBpY3R1cmVmaWxsQ0ZHLnB1c2goc2V0T3B0aW9ucy5zaGlmdCgpKTtcblx0fVxuXG5cdC8qIGV4cG9zZSBwaWN0dXJlZmlsbCAqL1xuXHR3aW5kb3cucGljdHVyZWZpbGwgPSBwaWN0dXJlZmlsbDtcblxuXHQvKiBleHBvc2UgcGljdHVyZWZpbGwgKi9cblx0aWYgKCB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHQvLyBDb21tb25KUywganVzdCBleHBvcnRcblx0XHRtb2R1bGUuZXhwb3J0cyA9IHBpY3R1cmVmaWxsO1xuXHR9IGVsc2UgaWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcblx0XHQvLyBBTUQgc3VwcG9ydFxuXHRcdGRlZmluZSggXCJwaWN0dXJlZmlsbFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHBpY3R1cmVmaWxsOyB9ICk7XG5cdH1cblxuXHQvLyBJRTggZXZhbHMgdGhpcyBzeW5jLCBzbyBpdCBtdXN0IGJlIHRoZSBsYXN0IHRoaW5nIHdlIGRvXG5cdGlmICggIXBmLnN1cFBpY3R1cmUgKSB7XG5cdFx0dHlwZXNbIFwiaW1hZ2Uvd2VicFwiIF0gPSBkZXRlY3RUeXBlU3VwcG9ydChcImltYWdlL3dlYnBcIiwgXCJkYXRhOmltYWdlL3dlYnA7YmFzZTY0LFVrbEdSa29BQUFCWFJVSlFWbEE0V0FvQUFBQVFBQUFBQUFBQUFBQUFRVXhRU0F3QUFBQUJCeEFSL1E5RVJQOERBQUJXVURnZ0dBQUFBREFCQUowQktnRUFBUUFEQURRbHBBQURjQUQrKy8xUUFBPT1cIiApO1xuXHR9XG5cbn0gKSggd2luZG93LCBkb2N1bWVudCApO1xuIl0sIm1hcHBpbmdzIjoiOztBQUFBOzs7OztBQUlBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTs7Ozs7QUFJQTtBQUlBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7QUFPQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFHQTtBQUdBO0FBR0E7QUFHQTtBQUdBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBOzs7Ozs7QUFJQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVFBO0FBQ0E7QUFUQTtBQVlBO0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBTEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBVUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQU1BO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMkJBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBRUE7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7O0FBU0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBSUE7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUVBOzs7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFVQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUtBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFaQTtBQUNBO0FBY0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBREE7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/picturefill/dist/picturefill.js\n");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {}; // cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n  throw new Error('setTimeout has not been defined');\n}\n\nfunction defaultClearTimeout() {\n  throw new Error('clearTimeout has not been defined');\n}\n\n(function () {\n  try {\n    if (typeof setTimeout === 'function') {\n      cachedSetTimeout = setTimeout;\n    } else {\n      cachedSetTimeout = defaultSetTimout;\n    }\n  } catch (e) {\n    cachedSetTimeout = defaultSetTimout;\n  }\n\n  try {\n    if (typeof clearTimeout === 'function') {\n      cachedClearTimeout = clearTimeout;\n    } else {\n      cachedClearTimeout = defaultClearTimeout;\n    }\n  } catch (e) {\n    cachedClearTimeout = defaultClearTimeout;\n  }\n})();\n\nfunction runTimeout(fun) {\n  if (cachedSetTimeout === setTimeout) {\n    //normal enviroments in sane situations\n    return setTimeout(fun, 0);\n  } // if setTimeout wasn't available but was latter defined\n\n\n  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n    cachedSetTimeout = setTimeout;\n    return setTimeout(fun, 0);\n  }\n\n  try {\n    // when when somebody has screwed with setTimeout but no I.E. maddness\n    return cachedSetTimeout(fun, 0);\n  } catch (e) {\n    try {\n      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n      return cachedSetTimeout.call(null, fun, 0);\n    } catch (e) {\n      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n      return cachedSetTimeout.call(this, fun, 0);\n    }\n  }\n}\n\nfunction runClearTimeout(marker) {\n  if (cachedClearTimeout === clearTimeout) {\n    //normal enviroments in sane situations\n    return clearTimeout(marker);\n  } // if clearTimeout wasn't available but was latter defined\n\n\n  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n    cachedClearTimeout = clearTimeout;\n    return clearTimeout(marker);\n  }\n\n  try {\n    // when when somebody has screwed with setTimeout but no I.E. maddness\n    return cachedClearTimeout(marker);\n  } catch (e) {\n    try {\n      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n      return cachedClearTimeout.call(null, marker);\n    } catch (e) {\n      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n      // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n      return cachedClearTimeout.call(this, marker);\n    }\n  }\n}\n\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n  if (!draining || !currentQueue) {\n    return;\n  }\n\n  draining = false;\n\n  if (currentQueue.length) {\n    queue = currentQueue.concat(queue);\n  } else {\n    queueIndex = -1;\n  }\n\n  if (queue.length) {\n    drainQueue();\n  }\n}\n\nfunction drainQueue() {\n  if (draining) {\n    return;\n  }\n\n  var timeout = runTimeout(cleanUpNextTick);\n  draining = true;\n  var len = queue.length;\n\n  while (len) {\n    currentQueue = queue;\n    queue = [];\n\n    while (++queueIndex < len) {\n      if (currentQueue) {\n        currentQueue[queueIndex].run();\n      }\n    }\n\n    queueIndex = -1;\n    len = queue.length;\n  }\n\n  currentQueue = null;\n  draining = false;\n  runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n  var args = new Array(arguments.length - 1);\n\n  if (arguments.length > 1) {\n    for (var i = 1; i < arguments.length; i++) {\n      args[i - 1] = arguments[i];\n    }\n  }\n\n  queue.push(new Item(fun, args));\n\n  if (queue.length === 1 && !draining) {\n    runTimeout(drainQueue);\n  }\n}; // v8 likes predictible objects\n\n\nfunction Item(fun, array) {\n  this.fun = fun;\n  this.array = array;\n}\n\nItem.prototype.run = function () {\n  this.fun.apply(null, this.array);\n};\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\n\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) {\n  return [];\n};\n\nprocess.binding = function (name) {\n  throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () {\n  return '/';\n};\n\nprocess.chdir = function (dir) {\n  throw new Error('process.chdir is not supported');\n};\n\nprocess.umask = function () {\n  return 0;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcz9mMjhjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/process/browser.js\n");

/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n  \"use strict\";\n\n  if (global.setImmediate) {\n    return;\n  }\n\n  var nextHandle = 1; // Spec says greater than zero\n\n  var tasksByHandle = {};\n  var currentlyRunningATask = false;\n  var doc = global.document;\n  var registerImmediate;\n\n  function setImmediate(callback) {\n    // Callback can either be a function or a string\n    if (typeof callback !== \"function\") {\n      callback = new Function(\"\" + callback);\n    } // Copy function arguments\n\n\n    var args = new Array(arguments.length - 1);\n\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i + 1];\n    } // Store and register the task\n\n\n    var task = {\n      callback: callback,\n      args: args\n    };\n    tasksByHandle[nextHandle] = task;\n    registerImmediate(nextHandle);\n    return nextHandle++;\n  }\n\n  function clearImmediate(handle) {\n    delete tasksByHandle[handle];\n  }\n\n  function run(task) {\n    var callback = task.callback;\n    var args = task.args;\n\n    switch (args.length) {\n      case 0:\n        callback();\n        break;\n\n      case 1:\n        callback(args[0]);\n        break;\n\n      case 2:\n        callback(args[0], args[1]);\n        break;\n\n      case 3:\n        callback(args[0], args[1], args[2]);\n        break;\n\n      default:\n        callback.apply(undefined, args);\n        break;\n    }\n  }\n\n  function runIfPresent(handle) {\n    // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n    // So if we're currently running a task, we'll need to delay this invocation.\n    if (currentlyRunningATask) {\n      // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n      // \"too much recursion\" error.\n      setTimeout(runIfPresent, 0, handle);\n    } else {\n      var task = tasksByHandle[handle];\n\n      if (task) {\n        currentlyRunningATask = true;\n\n        try {\n          run(task);\n        } finally {\n          clearImmediate(handle);\n          currentlyRunningATask = false;\n        }\n      }\n    }\n  }\n\n  function installNextTickImplementation() {\n    registerImmediate = function registerImmediate(handle) {\n      process.nextTick(function () {\n        runIfPresent(handle);\n      });\n    };\n  }\n\n  function canUsePostMessage() {\n    // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n    // where `global.postMessage` means something completely different and can't be used for this purpose.\n    if (global.postMessage && !global.importScripts) {\n      var postMessageIsAsynchronous = true;\n      var oldOnMessage = global.onmessage;\n\n      global.onmessage = function () {\n        postMessageIsAsynchronous = false;\n      };\n\n      global.postMessage(\"\", \"*\");\n      global.onmessage = oldOnMessage;\n      return postMessageIsAsynchronous;\n    }\n  }\n\n  function installPostMessageImplementation() {\n    // Installs an event handler on `global` for the `message` event: see\n    // * https://developer.mozilla.org/en/DOM/window.postMessage\n    // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n    var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n\n    var onGlobalMessage = function onGlobalMessage(event) {\n      if (event.source === global && typeof event.data === \"string\" && event.data.indexOf(messagePrefix) === 0) {\n        runIfPresent(+event.data.slice(messagePrefix.length));\n      }\n    };\n\n    if (global.addEventListener) {\n      global.addEventListener(\"message\", onGlobalMessage, false);\n    } else {\n      global.attachEvent(\"onmessage\", onGlobalMessage);\n    }\n\n    registerImmediate = function registerImmediate(handle) {\n      global.postMessage(messagePrefix + handle, \"*\");\n    };\n  }\n\n  function installMessageChannelImplementation() {\n    var channel = new MessageChannel();\n\n    channel.port1.onmessage = function (event) {\n      var handle = event.data;\n      runIfPresent(handle);\n    };\n\n    registerImmediate = function registerImmediate(handle) {\n      channel.port2.postMessage(handle);\n    };\n  }\n\n  function installReadyStateChangeImplementation() {\n    var html = doc.documentElement;\n\n    registerImmediate = function registerImmediate(handle) {\n      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n      var script = doc.createElement(\"script\");\n\n      script.onreadystatechange = function () {\n        runIfPresent(handle);\n        script.onreadystatechange = null;\n        html.removeChild(script);\n        script = null;\n      };\n\n      html.appendChild(script);\n    };\n  }\n\n  function installSetTimeoutImplementation() {\n    registerImmediate = function registerImmediate(handle) {\n      setTimeout(runIfPresent, 0, handle);\n    };\n  } // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n\n\n  var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n  attachTo = attachTo && attachTo.setTimeout ? attachTo : global; // Don't get fooled by e.g. browserify environments.\n\n  if ({}.toString.call(global.process) === \"[object process]\") {\n    // For Node.js before 0.9\n    installNextTickImplementation();\n  } else if (canUsePostMessage()) {\n    // For non-IE10 modern browsers\n    installPostMessageImplementation();\n  } else if (global.MessageChannel) {\n    // For web workers, where supported\n    installMessageChannelImplementation();\n  } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n    // For IE 6–8\n    installReadyStateChangeImplementation();\n  } else {\n    // For older browsers\n    installSetTimeoutImplementation();\n  }\n\n  attachTo.setImmediate = setImmediate;\n  attachTo.clearImmediate = clearImmediate;\n})(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self);\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzPzYwMTciXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgdmFyIHRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgcmVnaXN0ZXJJbW1lZGlhdGU7XG5cbiAgICBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcbiAgICAgIC8vIENhbGxiYWNrIGNhbiBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZ1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbmV3IEZ1bmN0aW9uKFwiXCIgKyBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICAvLyBDb3B5IGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgICB9XG4gICAgICAvLyBTdG9yZSBhbmQgcmVnaXN0ZXIgdGhlIHRhc2tcbiAgICAgIHZhciB0YXNrID0geyBjYWxsYmFjazogY2FsbGJhY2ssIGFyZ3M6IGFyZ3MgfTtcbiAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSB0YXNrO1xuICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUobmV4dEhhbmRsZSk7XG4gICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bih0YXNrKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRhc2suY2FsbGJhY2s7XG4gICAgICAgIHZhciBhcmdzID0gdGFzay5hcmdzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cIlxuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICBpZiAoY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgICAgICAgLy8gXCJ0b28gbXVjaCByZWN1cnNpb25cIiBlcnJvci5cbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcnVuKHRhc2spO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW1tZWRpYXRlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJ1bklmUHJlc2VudChoYW5kbGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Vc2VQb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKGdsb2JhbC5wb3N0TWVzc2FnZSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCBcIipcIik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXG4gICAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xuXG4gICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xufSh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiA/IHR5cGVvZiBnbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgPyB0aGlzIDogZ2xvYmFsIDogc2VsZikpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBZkE7QUFpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/setimmediate/setImmediate.js\n");

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var scope = typeof global !== \"undefined\" && global || typeof self !== \"undefined\" && self || window;\nvar apply = Function.prototype.apply; // DOM APIs, for completeness\n\nexports.setTimeout = function () {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\n\nexports.setInterval = function () {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\n\nexports.clearTimeout = exports.clearInterval = function (timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\n\nTimeout.prototype.unref = Timeout.prototype.ref = function () {};\n\nTimeout.prototype.close = function () {\n  this._clearFn.call(scope, this._id);\n}; // Does not start the time, just sets up the members needed.\n\n\nexports.enroll = function (item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function (item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function (item) {\n  clearTimeout(item._idleTimeoutId);\n  var msecs = item._idleTimeout;\n\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout) item._onTimeout();\n    }, msecs);\n  }\n}; // setimmediate attaches itself to the global object\n\n\n__webpack_require__(/*! setimmediate */ \"./node_modules/setimmediate/setImmediate.js\"); // On some exotic environments, it's not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\n\n\nexports.setImmediate = typeof self !== \"undefined\" && self.setImmediate || typeof global !== \"undefined\" && global.setImmediate || this && this.setImmediate;\nexports.clearImmediate = typeof self !== \"undefined\" && self.clearImmediate || typeof global !== \"undefined\" && global.clearImmediate || this && this.clearImmediate;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzPzUxMTgiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHNjb3BlID0gKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsKSB8fFxuICAgICAgICAgICAgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYpIHx8XG4gICAgICAgICAgICB3aW5kb3c7XG52YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkge1xuICBpZiAodGltZW91dCkge1xuICAgIHRpbWVvdXQuY2xvc2UoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbChzY29wZSwgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIHNldGltbWVkaWF0ZSBhdHRhY2hlcyBpdHNlbGYgdG8gdGhlIGdsb2JhbCBvYmplY3RcbnJlcXVpcmUoXCJzZXRpbW1lZGlhdGVcIik7XG4vLyBPbiBzb21lIGV4b3RpYyBlbnZpcm9ubWVudHMsIGl0J3Mgbm90IGNsZWFyIHdoaWNoIG9iamVjdCBgc2V0aW1tZWRpYXRlYCB3YXNcbi8vIGFibGUgdG8gaW5zdGFsbCBvbnRvLiAgU2VhcmNoIGVhY2ggcG9zc2liaWxpdHkgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlXG4vLyBgc2V0aW1tZWRpYXRlYCBsaWJyYXJ5LlxuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0aGlzICYmIHRoaXMuc2V0SW1tZWRpYXRlKTtcbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5jbGVhckltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuY2xlYXJJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMgJiYgdGhpcy5jbGVhckltbWVkaWF0ZSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/timers-browserify/main.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar g; // This works in non-strict mode\n\ng = function () {\n  return this;\n}();\n\ntry {\n  // This works if eval is allowed (see CSP)\n  g = g || new Function(\"return this\")();\n} catch (e) {\n  // This works if the window reference is available\n  if ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === \"object\") g = window;\n} // g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\n\nmodule.exports = g;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL2dsb2JhbC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanM/Y2QwMCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/global.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function (module) {\n  if (!module.webpackPolyfill) {\n    module.deprecate = function () {};\n\n    module.paths = []; // module.parent = undefined by default\n\n    if (!module.children) module.children = [];\n    Object.defineProperty(module, \"loaded\", {\n      enumerable: true,\n      get: function get() {\n        return module.l;\n      }\n    });\n    Object.defineProperty(module, \"id\", {\n      enumerable: true,\n      get: function get() {\n        return module.i;\n      }\n    });\n    module.webpackPolyfill = 1;\n  }\n\n  return module;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL21vZHVsZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanM/Y2VkMiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuXHRpZiAoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcblx0XHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XG5cdH1cblx0cmV0dXJuIG1vZHVsZTtcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQUE7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/module.js\n");

/***/ }),

/***/ 0:
/*!*******************************************************************!*\
  !*** multi lodash.throttle lodash.debounce dompurify picturefill ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! lodash.throttle */"./node_modules/lodash.throttle/index.js");
__webpack_require__(/*! lodash.debounce */"./node_modules/lodash.debounce/index.js");
__webpack_require__(/*! dompurify */"./node_modules/dompurify/dist/purify.js");
module.exports = __webpack_require__(/*! picturefill */"./node_modules/picturefill/dist/picturefill.js");


/***/ })

}]);